{"sha": "eeb5f171da2486c34e4e473c97a1468279d05e7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYjVmMTcxZGEyNDg2YzM0ZTRlNDczYzk3YTE0NjgyNzlkMDVlN2M=", "commit": {"author": {"name": "Denys Zariaiev", "email": "denys.zariaiev@gmail.com", "date": "2019-03-13T20:00:45Z"}, "committer": {"name": "Denys Zariaiev", "email": "denys.zariaiev@gmail.com", "date": "2019-03-13T20:00:45Z"}, "message": "Merge remote-tracking branch 'upstream/master' into asm-compile-tests", "tree": {"sha": "b452442f799d5d62141419e7091de13c212de9ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b452442f799d5d62141419e7091de13c212de9ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeb5f171da2486c34e4e473c97a1468279d05e7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb5f171da2486c34e4e473c97a1468279d05e7c", "html_url": "https://github.com/rust-lang/rust/commit/eeb5f171da2486c34e4e473c97a1468279d05e7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeb5f171da2486c34e4e473c97a1468279d05e7c/comments", "author": {"login": "denzp", "id": 747869, "node_id": "MDQ6VXNlcjc0Nzg2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/747869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denzp", "html_url": "https://github.com/denzp", "followers_url": "https://api.github.com/users/denzp/followers", "following_url": "https://api.github.com/users/denzp/following{/other_user}", "gists_url": "https://api.github.com/users/denzp/gists{/gist_id}", "starred_url": "https://api.github.com/users/denzp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denzp/subscriptions", "organizations_url": "https://api.github.com/users/denzp/orgs", "repos_url": "https://api.github.com/users/denzp/repos", "events_url": "https://api.github.com/users/denzp/events{/privacy}", "received_events_url": "https://api.github.com/users/denzp/received_events", "type": "User", "site_admin": false}, "committer": {"login": "denzp", "id": 747869, "node_id": "MDQ6VXNlcjc0Nzg2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/747869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denzp", "html_url": "https://github.com/denzp", "followers_url": "https://api.github.com/users/denzp/followers", "following_url": "https://api.github.com/users/denzp/following{/other_user}", "gists_url": "https://api.github.com/users/denzp/gists{/gist_id}", "starred_url": "https://api.github.com/users/denzp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denzp/subscriptions", "organizations_url": "https://api.github.com/users/denzp/orgs", "repos_url": "https://api.github.com/users/denzp/repos", "events_url": "https://api.github.com/users/denzp/events{/privacy}", "received_events_url": "https://api.github.com/users/denzp/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c7ec6c421af26666d3ec1c5fe022d099133951c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c7ec6c421af26666d3ec1c5fe022d099133951c", "html_url": "https://github.com/rust-lang/rust/commit/5c7ec6c421af26666d3ec1c5fe022d099133951c"}, {"sha": "8bf1f1c8f4100247c1f9b3d9b7aecea5c970263e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bf1f1c8f4100247c1f9b3d9b7aecea5c970263e", "html_url": "https://github.com/rust-lang/rust/commit/8bf1f1c8f4100247c1f9b3d9b7aecea5c970263e"}], "stats": {"total": 51133, "additions": 27972, "deletions": 23161}, "files": [{"sha": "0733086284947dd8be6ce8b75944940ededc669f", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -161,6 +161,7 @@ Michael Woerister <michaelwoerister@posteo> <michaelwoerister@gmail>\n Micka\u00ebl Raybaud-Roig <raybaudroigm@gmail.com> m-r-r <raybaudroigm@gmail.com>\n Ms2ger <ms2ger@gmail.com> <Ms2ger@gmail.com>\n Mukilan Thiagarajan <mukilanthiagarajan@gmail.com>\n+Nathan West <Lucretiel@gmail.com> <lucretiel@gmail.com>\n Nathan Wilson <wilnathan@gmail.com>\n Nathaniel Herman <nherman@post.harvard.edu> Nathaniel Herman <nherman@college.harvard.edu>\n Neil Pankey <npankey@gmail.com> <neil@wire.im>"}, {"sha": "39ecc880097e3a9d62049c0d517ba58ce5790e36", "filename": "Cargo.lock", "status": "modified", "additions": 113, "deletions": 60, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -230,15 +230,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"cargo\"\n-version = \"0.35.0\"\n+version = \"0.36.0\"\n dependencies = [\n  \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bufstream 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bytesize 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core-foundation 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"crates-io 0.23.0\",\n+ \"crates-io 0.24.0\",\n  \"crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crypto-hash 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -374,7 +374,7 @@ dependencies = [\n  \"clippy-mini-macro-test 0.2.0\",\n  \"clippy_dev 0.0.1\",\n  \"clippy_lints 0.0.212\",\n- \"compiletest_rs 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiletest_rs 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -493,7 +493,7 @@ dependencies = [\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.3.18\"\n+version = \"0.3.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -508,6 +508,7 @@ dependencies = [\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tester 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -539,7 +540,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.23.0\"\n+version = \"0.24.0\"\n dependencies = [\n  \"curl 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -744,7 +745,7 @@ dependencies = [\n \n [[package]]\n name = \"dlmalloc\"\n-version = \"0.1.2\"\n+version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"compiler_builtins 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1339,7 +1340,7 @@ dependencies = [\n \n [[package]]\n name = \"lsp-codec\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bytes 0.4.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1399,7 +1400,7 @@ dependencies = [\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"string_cache 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"string_cache_codegen 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"string_cache_codegen 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tendril 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1590,7 +1591,7 @@ dependencies = [\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"colored 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiletest_rs 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiletest_rs 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"directories 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1936,14 +1937,6 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"proc-macro2\"\n-version = \"0.3.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"proc-macro2\"\n version = \"0.4.24\"\n@@ -2015,14 +2008,6 @@ name = \"quote\"\n version = \"0.3.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"quote\"\n-version = \"0.5.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"proc-macro2 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"quote\"\n version = \"0.6.10\"\n@@ -2247,7 +2232,7 @@ dependencies = [\n name = \"rls\"\n version = \"1.34.0\"\n dependencies = [\n- \"cargo 0.35.0\",\n+ \"cargo 0.36.0\",\n  \"cargo_metadata 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"clippy_lints 0.0.212\",\n  \"crossbeam-channel 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2261,7 +2246,7 @@ dependencies = [\n  \"jsonrpc-core 10.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lsp-codec 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lsp-codec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lsp-types 0.55.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ordslice 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2272,7 +2257,7 @@ dependencies = [\n  \"rls-analysis 0.16.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-blacklist 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-data 0.18.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-rustc 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-rustc 0.6.0\",\n  \"rls-span 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-vfs 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2325,8 +2310,7 @@ dependencies = [\n \n [[package]]\n name = \"rls-rustc\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+version = \"0.6.0\"\n \n [[package]]\n name = \"rls-span\"\n@@ -2374,14 +2358,15 @@ dependencies = [\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"polonius-engine 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon-core 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_fs_util 0.0.0\",\n+ \"rustc_macros 0.1.0\",\n  \"rustc_target 0.0.0\",\n- \"scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n@@ -2425,8 +2410,8 @@ dependencies = [\n  \"rustc-ap-rustc_cratesio_shim 373.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-serialize 373.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon-core 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2524,23 +2509,23 @@ dependencies = [\n \n [[package]]\n name = \"rustc-rayon\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n+ \"crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon-core 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-rayon-core\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2640,6 +2625,7 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n@@ -2688,11 +2674,13 @@ dependencies = [\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n+ \"jobserver 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon-core 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n  \"serialize 0.0.0\",\n  \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2708,13 +2696,14 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n+ \"rustc_interface 0.0.0\",\n  \"rustc_lint 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n@@ -2726,7 +2715,7 @@ dependencies = [\n  \"rustc_target 0.0.0\",\n  \"rustc_traits 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n- \"scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n@@ -2758,7 +2747,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_fs_util 0.0.0\",\n@@ -2767,6 +2756,36 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_interface\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc 0.0.0\",\n+ \"rustc-rayon 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_allocator 0.0.0\",\n+ \"rustc_borrowck 0.0.0\",\n+ \"rustc_codegen_utils 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_incremental 0.0.0\",\n+ \"rustc_lint 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"rustc_passes 0.0.0\",\n+ \"rustc_plugin 0.0.0\",\n+ \"rustc_privacy 0.0.0\",\n+ \"rustc_resolve 0.0.0\",\n+ \"rustc_traits 0.0.0\",\n+ \"rustc_typeck 0.0.0\",\n+ \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serialize 0.0.0\",\n+ \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntax 0.0.0\",\n+ \"syntax_ext 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_lint\"\n version = \"0.0.0\"\n@@ -2798,6 +2817,16 @@ dependencies = [\n  \"core 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_macros\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc_metadata\"\n version = \"0.0.0\"\n@@ -3090,6 +3119,11 @@ name = \"scoped-tls\"\n version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"scoped-tls\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"scoped_threadpool\"\n version = \"0.1.9\"\n@@ -3230,7 +3264,7 @@ dependencies = [\n  \"cc 1.0.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n- \"dlmalloc 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"dlmalloc 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fortanix-sgx-abi 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"panic_abort 0.0.0\",\n@@ -3255,19 +3289,19 @@ dependencies = [\n  \"phf_shared 0.7.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"precomputed-hash 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"string_cache_codegen 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"string_cache_codegen 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"string_cache_shared 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"string_cache_codegen\"\n-version = \"0.4.1\"\n+version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"phf_generator 0.7.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"phf_shared 0.7.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proc-macro2 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"string_cache_shared 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -3345,7 +3379,7 @@ dependencies = [\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n- \"scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax_pos 0.0.0\",\n@@ -3372,7 +3406,7 @@ dependencies = [\n  \"arena 0.0.0\",\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n- \"scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -3415,6 +3449,15 @@ dependencies = [\n name = \"term\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"term\"\n+version = \"0.4.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"term\"\n version = \"0.5.1\"\n@@ -3451,6 +3494,16 @@ dependencies = [\n  \"term 0.0.0\",\n ]\n \n+[[package]]\n+name = \"tester\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"textwrap\"\n version = \"0.10.0\"\n@@ -3976,7 +4029,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum commoncrypto 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d056a8586ba25a1e4d61cb090900e495952c7886786fc55f909ab2f819b69007\"\n \"checksum commoncrypto-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1fed34f46747aa73dfaa578069fd8279d2818ade2b55f38f22a9401c7f4083e2\"\n \"checksum compiler_builtins 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6711d51cb46744dd8305293cc3fbc392aaff7a8f5095a7c4fae1e5113ef07c96\"\n-\"checksum compiletest_rs 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d76d4322a40f6b0db7259d4f2c8a65ed8b0d84fce0bbc61b98cf47f8ec6eec3\"\n+\"checksum compiletest_rs 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"56c799b1f7142badf3b047b4c1f2074cc96b6b784fb2432f2ed9c87da0a03749\"\n \"checksum constant_time_eq 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8ff012e225ce166d4422e0e78419d901719760f62ae2b7969ca6b564d1b54a9e\"\n \"checksum core-foundation 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4e2640d6d0bf22e82bed1b73c6aef8d5dd31e5abe6666c57e6d45e2649f4f887\"\n \"checksum core-foundation-sys 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e7ca8a5221364ef15ce201e8ed2f609fc312682a8f4e0e3d4aa5879764e0fa3b\"\n@@ -4000,7 +4053,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum digest 0.7.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"03b072242a8cbaf9c145665af9d250c59af3b958f83ed6824e13533cf76d5b90\"\n \"checksum directories 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72d337a64190607d4fcca2cb78982c5dd57f4916e19696b48a575fa746b6cb0f\"\n \"checksum dirs 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"88972de891f6118092b643d85a0b28e0678e0f948d7f879aa32f2d5aafe97d2a\"\n-\"checksum dlmalloc 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d56ad71b31043818d0ee10a7fb9664882f8e45849c81647585e6a3124f185517\"\n+\"checksum dlmalloc 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f283302e035e61c23f2b86b3093e8c6273a4c3125742d6087e96ade001ca5e63\"\n \"checksum either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3be565ca5c557d7f59e7cfcf1844f9e3033650c929c6566f511e8005f205c1d0\"\n \"checksum elasticlunr-rs 2.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a99a310cd1f9770e7bf8e48810c7bcbb0e078c8fb23a8c7bcf0da4c2bf61a455\"\n \"checksum ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f56c93cc076508c549d9bb747f79aa9b4eb098be7b8cad8830c3137ef52d1e00\"\n@@ -4064,7 +4117,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum lock_api 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"949826a5ccf18c1b3a7c3d57692778d21768b79e46eb9dd07bfc4c2160036c54\"\n \"checksum log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6\"\n \"checksum log_settings 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"19af41f0565d7c19b2058153ad0b42d4d5ce89ec4dbf06ed6741114a8b63e7cd\"\n-\"checksum lsp-codec 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f3570f641b984e3e4613a1ca34db2ea72549bbc3c0316d33f5af91ab514dcbff\"\n+\"checksum lsp-codec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"169d737ad89cf8ddd82d1804d9122f54568c49377665157277cc90d747b1d31a\"\n \"checksum lsp-types 0.55.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6392b5843615b8a2adeebe87b83fdd29567c0870baba3407a67e6dbfee4712f8\"\n \"checksum lzma-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d1eaa027402541975218bb0eec67d6b0412f6233af96e0d096d31dbdfd22e614\"\n \"checksum mac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c41e0c4fef86961ac6d6f8a82609f55f31b05e4fce149ac5710e439df7619ba4\"\n@@ -4124,15 +4177,13 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum precomputed-hash 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"925383efa346730478fb4838dbe9137d2a47675ad789c546d150a6e1dd4ab31c\"\n \"checksum pretty_assertions 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a029430f0d744bc3d15dd474d591bed2402b645d024583082b9f63bb936dac6\"\n \"checksum pretty_env_logger 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df8b3f4e0475def7d9c2e5de8e5a1306949849761e107b360d03e98eafaffd61\"\n-\"checksum proc-macro2 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1b06e2f335f48d24442b35a19df506a835fb3547bc3c06ef27340da9acf5cae7\"\n \"checksum proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"77619697826f31a02ae974457af0b29b723e5619e113e9397b8b82c6bd253f09\"\n \"checksum proptest 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"926d0604475349f463fe44130aae73f2294b5309ab2ca0310b998bd334ef191f\"\n \"checksum pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6fdf85cda6cadfae5428a54661d431330b312bc767ddbc57adbedc24da66e32\"\n \"checksum pulldown-cmark 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eef52fac62d0ea7b9b4dc7da092aa64ea7ec3d90af6679422d3d7e0e14b6ee15\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n-\"checksum quote 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9949cfe66888ffe1d53e6ec9d9f3b70714083854be20fd5e271b232a017401e8\"\n \"checksum quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"53fa22a1994bd0f9372d7a816207d8a2677ad0325b073f5c5332760f0fb62b5c\"\n \"checksum racer 2.1.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d634483bed41bb116122b84ffe0ef8740345c2ceb2784ce86c33499700eb13a7\"\n \"checksum rand 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8356f47b32624fef5b3301c1be97e5944ecdd595409cc5da11d05f211db6cfbd\"\n@@ -4158,7 +4209,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rls-analysis 0.16.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae18d8ad01dec3b2014f4d7ae3c607d7adbcff79e5d3b48ea42ea71c10d43a71\"\n \"checksum rls-blacklist 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b8ce1fdac03e138c4617ff87b194e1ff57a39bb985a044ccbd8673d30701e411\"\n \"checksum rls-data 0.18.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f80b84551b32e26affaf7f12374913b5061730c0dcd185d9e8fa5a15e36e65c\"\n-\"checksum rls-rustc 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9dba7390427aefa953608429701e3665192ca810ba8ae09301e001b7c7bed0\"\n \"checksum rls-span 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"33d66f1d6c6ccd5c98029f162544131698f6ebb61d8c697681cac409dcd08805\"\n \"checksum rls-vfs 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72d56425bd5aa86d9d4372b76f0381d3b4bda9c0220e71956c9fcc929f45c1f1\"\n \"checksum rustc-ap-arena 373.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be999235b541fc8eb54901b66e899a06076709ac5f53d6b2c5c59d29ad54780\"\n@@ -4172,8 +4222,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-ap-syntax_pos 373.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8e4f88a1213562373cee9de5a1d77bbf16dd706030304af041c9733492fcc952\"\n \"checksum rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"82ae957aa1b3055d8e086486723c0ccd3d7b8fa190ae8fa2e35543b6171c810e\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n-\"checksum rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c6d5a683c6ba4ed37959097e88d71c9e8e26659a3cb5be8b389078e7ad45306\"\n-\"checksum rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40f06724db71e18d68b3b946fdf890ca8c921d9edccc1404fdfdb537b0d12649\"\n+\"checksum rustc-rayon 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d98c51d9cbbe810c8b6693236d3412d8cd60513ff27a3e1b6af483dca0af544\"\n+\"checksum rustc-rayon-core 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"526e7b6d2707a5b9bec3927d424ad70fa3cfc68e0ac1b75e46cdbbc95adc5108\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \"checksum rustc_tools_util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3c5a95edfa0c893236ae4778bb7c4752760e4c0d245e19b5eff33c5aa5eb9dc\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n@@ -4183,6 +4233,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum same-file 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8f20c4be53a8a1ff4c1f1b2bd14570d2f634628709752f0702ecdd2b3f9a5267\"\n \"checksum schannel 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e1a231dc10abf6749cfa5d7767f25888d484201accbd919b66ab5413c502d56\"\n \"checksum scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"332ffa32bf586782a3efaeb58f127980944bbc8c4d6913a86107ac2a5ab24b28\"\n+\"checksum scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea6a9290e3c9cf0f18145ef7ffa62d68ee0bf5fcd651017e586dc7fd5da448c2\"\n \"checksum scoped_threadpool 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d51f5df5af43ab3f1360b429fa5e0152ac5ce8c0bd6485cae490332e96846a8\"\n \"checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27\"\n \"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n@@ -4201,7 +4252,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum socket2 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4d11a52082057d87cb5caa31ad812f4504b97ab44732cd8359df2e9ff9f48e7\"\n \"checksum stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ffbc596e092fe5f598b12ef46cc03754085ac2f4d8c739ad61c4ae266cc3b3fa\"\n \"checksum string_cache 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"25d70109977172b127fe834e5449e5ab1740b9ba49fa18a2020f509174f25423\"\n-\"checksum string_cache_codegen 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"35293b05cf1494e8ddd042a7df6756bf18d07f42d234f32e71dce8a7aabb0191\"\n+\"checksum string_cache_codegen 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1eea1eee654ef80933142157fdad9dd8bc43cf7c74e999e369263496f04ff4da\"\n \"checksum string_cache_shared 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b1884d1bc09741d466d9b14e6d37ac89d6909cbcac41dd9ae982d4d063bbedfc\"\n \"checksum strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550\"\n \"checksum strum 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f6c3a2071519ab6a48f465808c4c1ffdd00dfc8e93111d02b4fc5abab177676e\"\n@@ -4213,9 +4264,11 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum tar 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a303ba60a099fcd2aaa646b14d2724591a96a75283e4b7ed3d1a1658909d9ae2\"\n \"checksum tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e91405c14320e5c79b3d148e1c86f40749a36e490642202a31689cb1a3452b2\"\n \"checksum tendril 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9de21546595a0873061940d994bbbc5c35f024ae4fd61ec5c5b159115684f508\"\n+\"checksum term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fa63644f74ce96fbeb9b794f66aff2a52d601cbd5e80f4b97123e3899f4570f1\"\n \"checksum term 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5e6b677dd1e8214ea1ef4297f85dbcbed8e8cdddb561040cc998ca2551c37561\"\n \"checksum termcolor 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4096add70612622289f2fdcdbd5086dc81c1e2675e6ae58d6c4f62a16c6d7f2f\"\n \"checksum termion 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"689a3bdfaab439fd92bc87df5c4c78417d3cbe537487274e9b0b2dce76e92096\"\n+\"checksum tester 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5e812cb26c597f86a49b26dbb58b878bd2a2b4b93fc069dc39499228fe556ff6\"\n \"checksum textwrap 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"307686869c93e71f94da64286f9a9524c0f308a9e1c87a583de8e9c9039ad3f6\"\n \"checksum thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b\"\n \"checksum time 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d825be0eb33fda1a7e68012d51e9c7f451dc1a69391e7fdc197060bb8c56667b\""}, {"sha": "4cda02c5c2ebed35030a79de4d68abca20ffac5b", "filename": "RELEASES.md", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -4,10 +4,10 @@ Version 1.33.0 (2019-02-28)\n Language\n --------\n - [You can now use the `cfg(target_vendor)` attribute.][57465] E.g.\n-  `#[cfg(target_vendor=\"linux\")] fn main() { println!(\"Hello Linux!\"); }`\n+  `#[cfg(target_vendor=\"apple\")] fn main() { println!(\"Hello Apple!\"); }`\n - [Integer patterns such as in a match expression can now be exhaustive.][56362]\n   E.g. You can have match statement on a `u8` that covers `0..=255` and\n-  you would no longer be required to have a `_ => unreachable!()` case. \n+  you would no longer be required to have a `_ => unreachable!()` case.\n - [You can now have multiple patterns in `if let` and `while let`\n   expressions.][57532] You can do this with the same syntax as a `match`\n   expression. E.g.\n@@ -51,8 +51,7 @@ Language\n   // Allowed as there is only one `Read` in the module.\n   pub trait Read {}\n   ```\n-- [`extern` functions will now abort by default when panicking.][55982]\n-  This was previously undefined behaviour.\n+- [You may now use `Rc`, `Arc`, and `Pin` as method receivers][56805].\n \n Compiler\n --------\n@@ -109,27 +108,30 @@ Compatibility Notes\n   are now deprecated in the standard library, and their usage will now produce a warning.\n   Please use the `str::{trim_start, trim_end, trim_start_matches, trim_end_matches}`\n   methods instead.\n+- The `Error::cause` method has been deprecated in favor of `Error::source` which supports\n+  downcasting.\n \n-[57615]: https://github.com/rust-lang/rust/pull/57615/\n-[57465]: https://github.com/rust-lang/rust/pull/57465/\n-[57532]: https://github.com/rust-lang/rust/pull/57532/\n-[57535]: https://github.com/rust-lang/rust/pull/57535/\n-[57566]: https://github.com/rust-lang/rust/pull/57566/\n+[55982]: https://github.com/rust-lang/rust/pull/55982/\n+[56303]: https://github.com/rust-lang/rust/pull/56303/\n+[56351]: https://github.com/rust-lang/rust/pull/56351/\n+[56362]: https://github.com/rust-lang/rust/pull/56362\n+[56642]: https://github.com/rust-lang/rust/pull/56642/\n+[56769]: https://github.com/rust-lang/rust/pull/56769/\n+[56805]: https://github.com/rust-lang/rust/pull/56805\n+[56947]: https://github.com/rust-lang/rust/pull/56947/\n+[57049]: https://github.com/rust-lang/rust/pull/57049/\n+[57067]: https://github.com/rust-lang/rust/pull/57067/\n+[57105]: https://github.com/rust-lang/rust/pull/57105\n [57130]: https://github.com/rust-lang/rust/pull/57130/\n [57167]: https://github.com/rust-lang/rust/pull/57167/\n [57175]: https://github.com/rust-lang/rust/pull/57175/\n [57234]: https://github.com/rust-lang/rust/pull/57234/\n [57332]: https://github.com/rust-lang/rust/pull/57332/\n-[56947]: https://github.com/rust-lang/rust/pull/56947/\n-[57049]: https://github.com/rust-lang/rust/pull/57049/\n-[57067]: https://github.com/rust-lang/rust/pull/57067/\n-[56769]: https://github.com/rust-lang/rust/pull/56769/\n-[56642]: https://github.com/rust-lang/rust/pull/56642/\n-[56303]: https://github.com/rust-lang/rust/pull/56303/\n-[56351]: https://github.com/rust-lang/rust/pull/56351/\n-[55982]: https://github.com/rust-lang/rust/pull/55982/\n-[56362]: https://github.com/rust-lang/rust/pull/56362\n-[57105]: https://github.com/rust-lang/rust/pull/57105\n+[57465]: https://github.com/rust-lang/rust/pull/57465/\n+[57532]: https://github.com/rust-lang/rust/pull/57532/\n+[57535]: https://github.com/rust-lang/rust/pull/57535/\n+[57566]: https://github.com/rust-lang/rust/pull/57566/\n+[57615]: https://github.com/rust-lang/rust/pull/57615/\n [cargo/6484]: https://github.com/rust-lang/cargo/pull/6484/\n [`unix::FileExt::read_exact_at`]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.read_exact_at\n [`unix::FileExt::write_all_at`]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.write_all_at\n@@ -170,7 +172,7 @@ Language\n - [You can now match against literals in macros with the `literal`\n   specifier.][56072] This will match against a literal of any type.\n   E.g. `1`, `'A'`, `\"Hello World\"`\n-- [Self can now be used as a constructor and pattern for unit and tuple structs.][56365] E.g. \n+- [Self can now be used as a constructor and pattern for unit and tuple structs.][56365] E.g.\n   ```rust\n   struct Point(i32, i32);\n \n@@ -460,7 +462,7 @@ Version 1.31.0 (2018-12-06)\n \n Language\n --------\n-- \ud83c\udf89 [This version marks the release of the 2018 edition of Rust.][54057] \ud83c\udf89 \n+- \ud83c\udf89 [This version marks the release of the 2018 edition of Rust.][54057] \ud83c\udf89\n - [New lifetime elision rules now allow for eliding lifetimes in functions and\n   impl headers.][54778] E.g. `impl<'a> Reader for BufReader<'a> {}` can now be\n   `impl Reader for BufReader<'_> {}`. Lifetimes are still required to be defined"}, {"sha": "d70ad54b1c812ee6ef9b293cbfa9f434f4fb882b", "filename": "appveyor.yml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -5,11 +5,6 @@ environment:\n   # server goes down presumably. See #43333 for more info\n   CARGO_HTTP_CHECK_REVOKE: false\n \n-  # Execute the builds on GCE instead of Hyper-V. Those builders have a 3-4\n-  # minute startup overhead, but AppVeyor support recommended this as a\n-  # possible solution for #58160 (spurious 259 exit codes)\n-  appveyor_build_worker_cloud: gce\n-\n   matrix:\n   # 32/64 bit MSVC tests\n   - MSYS_BITS: 64"}, {"sha": "9afbd937c422c187ce58113dd664b1748729708c", "filename": "config.toml.example", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -61,7 +61,7 @@\n # support. You'll need to write a target specification at least, and most\n # likely, teach rustc about the C ABI of the target. Get in touch with the\n # Rust team and file an issue if you need assistance in porting!\n-#targets = \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc;NVPTX;Hexagon\"\n+#targets = \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;MSP430;Sparc;NVPTX;Hexagon\"\n \n # LLVM experimental targets to build support for. These targets are specified in\n # the same format as above, but since these targets are experimental, they are\n@@ -104,6 +104,8 @@\n # The value specified here will be passed as `-DLLVM_USE_LINKER` to CMake.\n #use-linker = \"lld\"\n \n+# Whether or not to specify `-DLLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN=YES`\n+#allow-old-toolchain = false\n \n # =============================================================================\n # General build configuration options\n@@ -162,6 +164,9 @@\n # Python interpreter to use for various tasks throughout the build, notably\n # rustdoc tests, the lldb python interpreter, and some dist bits and pieces.\n # Note that Python 2 is currently required.\n+#\n+# Defaults to python2.7, then python2. If neither executable can be found, then\n+# it defaults to the Python interpreter used to execute x.py.\n #python = \"python2.7\"\n \n # Force Cargo to check that Cargo.lock describes the precise dependency"}, {"sha": "ca86aeb8100a9e6a52e44e313355163e55b5f649", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -107,6 +107,14 @@ fn main() {\n         // actually downloaded, so we just always pass the `--sysroot` option.\n         cmd.arg(\"--sysroot\").arg(&sysroot);\n \n+        cmd.arg(\"-Zexternal-macro-backtrace\");\n+\n+        // Link crates to the proc macro crate for the target, but use a host proc macro crate\n+        // to actually run the macros\n+        if env::var_os(\"RUST_DUAL_PROC_MACROS\").is_some() {\n+            cmd.arg(\"-Zdual-proc-macros\");\n+        }\n+\n         // When we build Rust dylibs they're all intended for intermediate\n         // usage, so make sure we pass the -Cprefer-dynamic flag instead of\n         // linking all deps statically into the dylib.\n@@ -256,13 +264,6 @@ fn main() {\n             }\n         }\n \n-        // Force all crates compiled by this compiler to (a) be unstable and (b)\n-        // allow the `rustc_private` feature to link to other unstable crates\n-        // also in the sysroot.\n-        if env::var_os(\"RUSTC_FORCE_UNSTABLE\").is_some() {\n-            cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n-        }\n-\n         if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n             cmd.arg(\"--remap-path-prefix\").arg(&map);\n         }\n@@ -282,6 +283,14 @@ fn main() {\n         }\n     }\n \n+    // Force all crates compiled by this compiler to (a) be unstable and (b)\n+    // allow the `rustc_private` feature to link to other unstable crates\n+    // also in the sysroot. We also do this for host crates, since those\n+    // may be proc macros, in which case we might ship them.\n+    if env::var_os(\"RUSTC_FORCE_UNSTABLE\").is_some() && (stage != \"0\" || target.is_some()) {\n+        cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n+    }\n+\n     if env::var_os(\"RUSTC_PARALLEL_COMPILER\").is_some() {\n         cmd.arg(\"--cfg\").arg(\"parallel_compiler\");\n     }"}, {"sha": "8af7aa4856c381c196466407833370e7841c7ac1", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -262,6 +262,10 @@ def default_build_triple():\n         cputype = 'arm'\n         if ostype == 'linux-android':\n             ostype = 'linux-androideabi'\n+        elif ostype == 'unknown-freebsd':\n+            cputype = subprocess.check_output(\n+                ['uname', '-p']).strip().decode(default_encoding)\n+            ostype = 'unknown-freebsd'\n     elif cputype == 'armv6l':\n         cputype = 'arm'\n         if ostype == 'linux-android':\n@@ -830,7 +834,7 @@ def main():\n \n     # x.py help <cmd> ...\n     if len(sys.argv) > 1 and sys.argv[1] == 'help':\n-        sys.argv = sys.argv[:1] + [sys.argv[2], '-h'] + sys.argv[3:]\n+        sys.argv = [sys.argv[0], '-h'] + sys.argv[2:]\n \n     help_triggered = (\n         '-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)"}, {"sha": "1a36cb45d269fa0dd847ce6b47d3b8a741a7c4f2", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -405,7 +405,8 @@ impl<'a> Builder<'a> {\n                 test::Miri,\n                 test::Clippy,\n                 test::CompiletestTest,\n-                test::RustdocJS,\n+                test::RustdocJSStd,\n+                test::RustdocJSNotStd,\n                 test::RustdocTheme,\n                 // Run bootstrap close to the end as it's unlikely to fail\n                 test::Bootstrap,\n@@ -813,6 +814,17 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUST_CHECK\", \"1\");\n         }\n \n+        match mode {\n+            Mode::Std | Mode::Test | Mode::ToolBootstrap | Mode::ToolStd | Mode::ToolTest=> {},\n+            Mode::Rustc | Mode::Codegen | Mode::ToolRustc => {\n+                // Build proc macros both for the host and the target\n+                if target != compiler.host && cmd != \"check\" {\n+                    cargo.arg(\"-Zdual-proc-macros\");\n+                    cargo.env(\"RUST_DUAL_PROC_MACROS\", \"1\");\n+                }\n+            },\n+        }\n+\n         cargo.arg(\"-j\").arg(self.jobs().to_string());\n         // Remove make-related flags to ensure Cargo can correctly set things up\n         cargo.env_remove(\"MAKEFLAGS\");"}, {"sha": "aa683161b6547fe5a47f102c9b6eb1078998bda4", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -14,7 +14,7 @@ use crate::Build;\n use crate::config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.34.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.35.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "a30b465698e2a263b40b10f7ef6b7a33dd3442a4", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -42,7 +42,8 @@ impl Step for Std {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&builder, &libdir, &libstd_stamp(builder, compiler, target));\n+        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+        add_to_sysroot(&builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n     }\n }\n \n@@ -88,7 +89,8 @@ impl Step for Rustc {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&builder, &libdir, &librustc_stamp(builder, compiler, target));\n+        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+        add_to_sysroot(&builder, &libdir, &hostdir, &librustc_stamp(builder, compiler, target));\n     }\n }\n \n@@ -175,7 +177,8 @@ impl Step for Test {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(builder, &libdir, &libtest_stamp(builder, compiler, target));\n+        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+        add_to_sysroot(builder, &libdir, &hostdir, &libtest_stamp(builder, compiler, target));\n     }\n }\n \n@@ -222,7 +225,8 @@ impl Step for Rustdoc {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&builder, &libdir, &rustdoc_stamp(builder, compiler, target));\n+        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+        add_to_sysroot(&builder, &libdir, &hostdir, &rustdoc_stamp(builder, compiler, target));\n         builder.cargo(compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }"}, {"sha": "9498dbb59523294c9a1ec26fca48757fb4245939", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 55, "deletions": 19, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -224,7 +224,8 @@ impl Step for StdLink {\n                 target_compiler.host,\n                 target));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n-        add_to_sysroot(builder, &libdir, &libstd_stamp(builder, compiler, target));\n+        let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n+        add_to_sysroot(builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n \n         if builder.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n             // The sanitizers are only built in stage1 or above, so the dylibs will\n@@ -431,8 +432,12 @@ impl Step for TestLink {\n                 &compiler.host,\n                 target_compiler.host,\n                 target));\n-        add_to_sysroot(builder, &builder.sysroot_libdir(target_compiler, target),\n-                    &libtest_stamp(builder, compiler, target));\n+        add_to_sysroot(\n+            builder,\n+            &builder.sysroot_libdir(target_compiler, target),\n+            &builder.sysroot_libdir(target_compiler, compiler.host),\n+            &libtest_stamp(builder, compiler, target)\n+        );\n \n         builder.cargo(target_compiler, Mode::ToolTest, target, \"clean\");\n     }\n@@ -496,8 +501,8 @@ impl Step for Rustc {\n             return;\n         }\n \n-        // Ensure that build scripts have a std to link against.\n-        builder.ensure(Std {\n+        // Ensure that build scripts and proc macros have a std / libproc_macro to link against.\n+        builder.ensure(Test {\n             compiler: builder.compiler(self.compiler.stage, builder.config.build),\n             target: builder.config.build,\n         });\n@@ -592,8 +597,12 @@ impl Step for RustcLink {\n                  &compiler.host,\n                  target_compiler.host,\n                  target));\n-        add_to_sysroot(builder, &builder.sysroot_libdir(target_compiler, target),\n-                       &librustc_stamp(builder, compiler, target));\n+        add_to_sysroot(\n+            builder,\n+            &builder.sysroot_libdir(target_compiler, target),\n+            &builder.sysroot_libdir(target_compiler, compiler.host),\n+            &librustc_stamp(builder, compiler, target)\n+        );\n         builder.cargo(target_compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }\n@@ -1015,10 +1024,20 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-pub fn add_to_sysroot(builder: &Builder<'_>, sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(\n+    builder: &Builder<'_>,\n+    sysroot_dst: &Path,\n+    sysroot_host_dst: &Path,\n+    stamp: &Path\n+) {\n     t!(fs::create_dir_all(&sysroot_dst));\n-    for path in builder.read_stamp_file(stamp) {\n-        builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n+    t!(fs::create_dir_all(&sysroot_host_dst));\n+    for (path, host) in builder.read_stamp_file(stamp) {\n+        if host {\n+            builder.copy(&path, &sysroot_host_dst.join(path.file_name().unwrap()));\n+        } else {\n+            builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n+        }\n     }\n }\n \n@@ -1047,8 +1066,14 @@ pub fn run_cargo(builder: &Builder<'_>,\n     let mut deps = Vec::new();\n     let mut toplevel = Vec::new();\n     let ok = stream_cargo(builder, cargo, &mut |msg| {\n-        let filenames = match msg {\n-            CargoMessage::CompilerArtifact { filenames, .. } => filenames,\n+        let (filenames, crate_types) = match msg {\n+            CargoMessage::CompilerArtifact {\n+                filenames,\n+                target: CargoTarget {\n+                    crate_types,\n+                },\n+                ..\n+            } => (filenames, crate_types),\n             _ => return,\n         };\n         for filename in filenames {\n@@ -1063,15 +1088,19 @@ pub fn run_cargo(builder: &Builder<'_>,\n             let filename = Path::new(&*filename);\n \n             // If this was an output file in the \"host dir\" we don't actually\n-            // worry about it, it's not relevant for us.\n+            // worry about it, it's not relevant for us\n             if filename.starts_with(&host_root_dir) {\n+                // Unless it's a proc macro used in the compiler\n+                if crate_types.iter().any(|t| t == \"proc-macro\") {\n+                    deps.push((filename.to_path_buf(), true));\n+                }\n                 continue;\n             }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n             if filename.starts_with(&target_deps_dir) {\n-                deps.push(filename.to_path_buf());\n+                deps.push((filename.to_path_buf(), false));\n                 continue;\n             }\n \n@@ -1124,10 +1153,10 @@ pub fn run_cargo(builder: &Builder<'_>,\n             let candidate = format!(\"{}.lib\", path_to_add);\n             let candidate = PathBuf::from(candidate);\n             if candidate.exists() {\n-                deps.push(candidate);\n+                deps.push((candidate, false));\n             }\n         }\n-        deps.push(path_to_add.into());\n+        deps.push((path_to_add.into(), false));\n     }\n \n     // Now we want to update the contents of the stamp file, if necessary. First\n@@ -1140,12 +1169,13 @@ pub fn run_cargo(builder: &Builder<'_>,\n     let mut new_contents = Vec::new();\n     let mut max = None;\n     let mut max_path = None;\n-    for dep in deps.iter() {\n+    for (dep, proc_macro) in deps.iter() {\n         let mtime = mtime(dep);\n         if Some(mtime) > max {\n             max = Some(mtime);\n             max_path = Some(dep.clone());\n         }\n+        new_contents.extend(if *proc_macro { b\"h\" } else { b\"t\" });\n         new_contents.extend(dep.to_str().unwrap().as_bytes());\n         new_contents.extend(b\"\\0\");\n     }\n@@ -1157,15 +1187,15 @@ pub fn run_cargo(builder: &Builder<'_>,\n     if contents_equal && max <= stamp_mtime {\n         builder.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n                 stamp, max, stamp_mtime));\n-        return deps\n+        return deps.into_iter().map(|(d, _)| d).collect()\n     }\n     if max > stamp_mtime {\n         builder.verbose(&format!(\"updating {:?} as {:?} changed\", stamp, max_path));\n     } else {\n         builder.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n     }\n     t!(fs::write(&stamp, &new_contents));\n-    deps\n+    deps.into_iter().map(|(d, _)| d).collect()\n }\n \n pub fn stream_cargo(\n@@ -1211,13 +1241,19 @@ pub fn stream_cargo(\n     status.success()\n }\n \n+#[derive(Deserialize)]\n+pub struct CargoTarget<'a> {\n+    crate_types: Vec<Cow<'a, str>>,\n+}\n+\n #[derive(Deserialize)]\n #[serde(tag = \"reason\", rename_all = \"kebab-case\")]\n pub enum CargoMessage<'a> {\n     CompilerArtifact {\n         package_id: Cow<'a, str>,\n         features: Vec<Cow<'a, str>>,\n         filenames: Vec<Cow<'a, str>>,\n+        target: CargoTarget<'a>,\n     },\n     BuildScriptExecuted {\n         package_id: Cow<'a, str>,"}, {"sha": "d20958854ed6a132a14a6daa18ded263d3440afd", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -78,6 +78,7 @@ pub struct Config {\n     pub llvm_link_jobs: Option<u32>,\n     pub llvm_version_suffix: Option<String>,\n     pub llvm_use_linker: Option<String>,\n+    pub llvm_allow_old_toolchain: Option<bool>,\n \n     pub lld_enabled: bool,\n     pub lldb_enabled: bool,\n@@ -263,6 +264,7 @@ struct Llvm {\n     ldflags: Option<String>,\n     use_libcxx: Option<bool>,\n     use_linker: Option<String>,\n+    allow_old_toolchain: Option<bool>,\n }\n \n #[derive(Deserialize, Default, Clone)]\n@@ -530,6 +532,7 @@ impl Config {\n             config.llvm_ldflags = llvm.ldflags.clone();\n             set(&mut config.llvm_use_libcxx, llvm.use_libcxx);\n             config.llvm_use_linker = llvm.use_linker.clone();\n+            config.llvm_allow_old_toolchain = llvm.allow_old_toolchain.clone();\n         }\n \n         if let Some(ref rust) = toml.rust {"}, {"sha": "2c40dd6d2961d49ab6838708ef7b05516cef5563", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -904,6 +904,8 @@ impl Step for Src {\n             \"src/stdsimd\",\n             \"src/libproc_macro\",\n             \"src/tools/rustc-std-workspace-core\",\n+            \"src/librustc\",\n+            \"src/libsyntax\",\n         ];\n \n         copy_src_dirs(builder, &std_src_dirs[..], &[], &dst_src);"}, {"sha": "e0ad0422a6ce30acc69cb07828af0c36cb2c285d", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -60,7 +60,7 @@ macro_rules! book {\n // NOTE: When adding a book here, make sure to ALSO build the book by\n // adding a build step in `src/bootstrap/builder.rs`!\n book!(\n-    EditionGuide, \"src/doc/edition-guide\", \"edition-guide\", RustbookVersion::MdBook1;\n+    EditionGuide, \"src/doc/edition-guide\", \"edition-guide\", RustbookVersion::MdBook2;\n     EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\", RustbookVersion::MdBook2;\n     Nomicon, \"src/doc/nomicon\", \"nomicon\", RustbookVersion::MdBook1;\n     Reference, \"src/doc/reference\", \"reference\", RustbookVersion::MdBook1;"}, {"sha": "9317a40545eac9f2b4c208223bc92c31c0227e1b", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1129,7 +1129,7 @@ impl Build {\n         ret\n     }\n \n-    fn read_stamp_file(&self, stamp: &Path) -> Vec<PathBuf> {\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, bool)> {\n         if self.config.dry_run {\n             return Vec::new();\n         }\n@@ -1142,8 +1142,9 @@ impl Build {\n             if part.is_empty() {\n                 continue\n             }\n-            let path = PathBuf::from(t!(str::from_utf8(part)));\n-            paths.push(path);\n+            let host = part[0] as char == 'h';\n+            let path = PathBuf::from(t!(str::from_utf8(&part[1..])));\n+            paths.push((path, host));\n         }\n         paths\n     }"}, {"sha": "d78670cfe515af762c32a009294ca0b04fb461ed", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -238,6 +238,10 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_USE_LINKER\", linker);\n         }\n \n+        if let Some(true) = builder.config.llvm_allow_old_toolchain {\n+            cfg.define(\"LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN\", \"YES\");\n+        }\n+\n         if let Some(ref python) = builder.config.python {\n             cfg.define(\"PYTHON_EXECUTABLE\", python);\n         }"}, {"sha": "b9f456e91003843fe10655c6910220a3dcc098ae", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -34,15 +34,17 @@ impl Finder {\n \n     fn maybe_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> Option<PathBuf> {\n         let cmd: OsString = cmd.as_ref().into();\n-        let path = self.path.clone();\n+        let path = &self.path;\n         self.cache.entry(cmd.clone()).or_insert_with(|| {\n-            for path in env::split_paths(&path) {\n+            for path in env::split_paths(path) {\n                 let target = path.join(&cmd);\n-                let mut cmd_alt = cmd.clone();\n-                cmd_alt.push(\".exe\");\n-                if target.is_file() || // some/path/git\n-                target.with_extension(\"exe\").exists() || // some/path/git.exe\n-                target.join(&cmd_alt).exists() { // some/path/git/git.exe\n+                let mut cmd_exe = cmd.clone();\n+                cmd_exe.push(\".exe\");\n+\n+                if target.is_file()                   // some/path/git\n+                    || path.join(&cmd_exe).exists()   // some/path/git.exe\n+                    || target.join(&cmd_exe).exists() // some/path/git/git.exe\n+                {\n                     return Some(target);\n                 }\n             }\n@@ -107,9 +109,9 @@ pub fn check(build: &mut Build) {\n     }\n \n     build.config.python = build.config.python.take().map(|p| cmd_finder.must_have(p))\n-        .or_else(|| env::var_os(\"BOOTSTRAP_PYTHON\").map(PathBuf::from)) // set by bootstrap.py\n         .or_else(|| cmd_finder.maybe_have(\"python2.7\"))\n         .or_else(|| cmd_finder.maybe_have(\"python2\"))\n+        .or_else(|| env::var_os(\"BOOTSTRAP_PYTHON\").map(PathBuf::from)) // set by bootstrap.py\n         .or_else(|| Some(cmd_finder.must_have(\"python\")));\n \n     build.config.nodejs = build.config.nodejs.take().map(|p| cmd_finder.must_have(p))"}, {"sha": "cb66eb238b34095dbd6acedc7759bec426428b36", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -574,22 +574,22 @@ impl Step for RustdocTheme {\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct RustdocJS {\n+pub struct RustdocJSStd {\n     pub host: Interned<String>,\n     pub target: Interned<String>,\n }\n \n-impl Step for RustdocJS {\n+impl Step for RustdocJSStd {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/test/rustdoc-js\")\n+        run.path(\"src/test/rustdoc-js-std\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(RustdocJS {\n+        run.builder.ensure(RustdocJSStd {\n             host: run.host,\n             target: run.target,\n         });\n@@ -598,12 +598,55 @@ impl Step for RustdocJS {\n     fn run(self, builder: &Builder<'_>) {\n         if let Some(ref nodejs) = builder.config.nodejs {\n             let mut command = Command::new(nodejs);\n-            command.args(&[\"src/tools/rustdoc-js/tester.js\", &*self.host]);\n+            command.args(&[\"src/tools/rustdoc-js-std/tester.js\", &*self.host]);\n             builder.ensure(crate::doc::Std {\n                 target: self.target,\n                 stage: builder.top_stage,\n             });\n             builder.run(&mut command);\n+        } else {\n+            builder.info(\n+                \"No nodejs found, skipping \\\"src/test/rustdoc-js-std\\\" tests\"\n+            );\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustdocJSNotStd {\n+    pub host: Interned<String>,\n+    pub target: Interned<String>,\n+    pub compiler: Compiler,\n+}\n+\n+impl Step for RustdocJSNotStd {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/test/rustdoc-js\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+        run.builder.ensure(RustdocJSNotStd {\n+            host: run.host,\n+            target: run.target,\n+            compiler,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        if builder.config.nodejs.is_some() {\n+            builder.ensure(Compiletest {\n+                compiler: self.compiler,\n+                target: self.target,\n+                mode: \"js-doc-test\",\n+                suite: \"rustdoc-js\",\n+                path: None,\n+                compare_mode: None,\n+            });\n         } else {\n             builder.info(\n                 \"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\"\n@@ -996,12 +1039,13 @@ impl Step for Compiletest {\n             .arg(builder.sysroot_libdir(compiler, target));\n         cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n \n-        let is_rustdoc_ui = suite.ends_with(\"rustdoc-ui\");\n+        let is_rustdoc = suite.ends_with(\"rustdoc-ui\") || suite.ends_with(\"rustdoc-js\");\n \n         // Avoid depending on rustdoc when we don't need it.\n         if mode == \"rustdoc\"\n             || (mode == \"run-make\" && suite.ends_with(\"fulldeps\"))\n-            || (mode == \"ui\" && is_rustdoc_ui)\n+            || (mode == \"ui\" && is_rustdoc)\n+            || mode == \"js-doc-test\"\n         {\n             cmd.arg(\"--rustdoc-path\")\n                 .arg(builder.rustdoc(compiler.host));\n@@ -1035,12 +1079,12 @@ impl Step for Compiletest {\n             cmd.arg(\"--nodejs\").arg(nodejs);\n         }\n \n-        let mut flags = if is_rustdoc_ui {\n+        let mut flags = if is_rustdoc {\n             Vec::new()\n         } else {\n             vec![\"-Crpath\".to_string()]\n         };\n-        if !is_rustdoc_ui {\n+        if !is_rustdoc {\n             if builder.config.rust_optimize_tests {\n                 flags.push(\"-O\".to_string());\n             }"}, {"sha": "9dbcacf70262c131f32a6608a6d8e0c9665f329f", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -91,7 +91,8 @@ impl Step for ToolBuild {\n                 compile::CargoMessage::CompilerArtifact {\n                     package_id,\n                     features,\n-                    filenames\n+                    filenames,\n+                    target: _,\n                 } => {\n                     (package_id, features, filenames)\n                 }"}, {"sha": "44b1aaa24b19d9747bf4a8ed81cba44533ee7f70", "filename": "src/ci/docker/dist-x86_64-netbsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -3,23 +3,8 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n-\n-COPY scripts/rustbuild-setup.sh /scripts/\n-RUN sh /scripts/rustbuild-setup.sh\n-USER rustbuild\n-WORKDIR /tmp\n-\n COPY dist-x86_64-netbsd/build-netbsd-toolchain.sh /tmp/\n-RUN ./build-netbsd-toolchain.sh\n-\n-USER root\n+RUN /tmp/build-netbsd-toolchain.sh\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "b5377c64b1f546a0b3470d4db5fbfd152903bf4f", "filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -28,15 +28,15 @@ mkdir -p /x-tools/x86_64-unknown-netbsd/sysroot\n URL=https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n \n # Originally from ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-$BSD/source/sets/*.tgz\n-curl $URL/2017-03-17-netbsd-src.tgz | tar xzf -\n-curl $URL/2017-03-17-netbsd-gnusrc.tgz | tar xzf -\n-curl $URL/2017-03-17-netbsd-sharesrc.tgz | tar xzf -\n-curl $URL/2017-03-17-netbsd-syssrc.tgz | tar xzf -\n+curl $URL/2018-03-01-netbsd-src.tgz | tar xzf -\n+curl $URL/2018-03-01-netbsd-gnusrc.tgz | tar xzf -\n+curl $URL/2018-03-01-netbsd-sharesrc.tgz | tar xzf -\n+curl $URL/2018-03-01-netbsd-syssrc.tgz | tar xzf -\n \n # Originally from ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-$BSD/amd64/binary/sets/*.tgz\n-curl $URL/2017-03-17-netbsd-base.tgz | \\\n+curl $URL/2018-03-01-netbsd-base.tgz | \\\n   tar xzf - -C /x-tools/x86_64-unknown-netbsd/sysroot ./usr/include ./usr/lib ./lib\n-curl $URL/2017-03-17-netbsd-comp.tgz | \\\n+curl $URL/2018-03-01-netbsd-comp.tgz | \\\n   tar xzf - -C /x-tools/x86_64-unknown-netbsd/sysroot ./usr/include ./usr/lib\n \n cd usr/src"}, {"sha": "17441ddb4546b02b8e87f20c9510e8f083ce7b54", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -18,4 +18,10 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n-ENV SCRIPT python2.7 ../x.py test\n+# Exclude some tests that are unlikely to be platform specific, to speed up\n+# this slow job.\n+ENV SCRIPT python2.7 ../x.py test \\\n+  --exclude src/bootstrap \\\n+  --exclude src/test/rustdoc-js \\\n+  --exclude src/tools/error_index_generator \\\n+  --exclude src/tools/linkchecker"}, {"sha": "9cffbeabec3bcec42d09432bfe7705125c848889", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1 +1 @@\n-Subproject commit 0e9061cbaf95adfb9f3ed36c6cef4c046f282e86\n+Subproject commit 9cffbeabec3bcec42d09432bfe7705125c848889"}, {"sha": "aa0022c875907886cae8f3ef8e9ebf6e2a5e728d", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1 +1 @@\n-Subproject commit 419edb885ec1a98c0747b3907003d79e3e6b93a9\n+Subproject commit aa0022c875907886cae8f3ef8e9ebf6e2a5e728d"}, {"sha": "9e656ead82bfe869493dec82653a52e27fa6a05c", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1 +1 @@\n-Subproject commit bd2778f304989ee52be8201504d6ec621dd60ca9\n+Subproject commit 9e656ead82bfe869493dec82653a52e27fa6a05c"}, {"sha": "f1ff93b66844493a7b03101c7df66ac958c62418", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1 +1 @@\n-Subproject commit b7eb4a087207af2405c0669fa577f8545b894c66\n+Subproject commit f1ff93b66844493a7b03101c7df66ac958c62418"}, {"sha": "41493ffce5d0e17d54eaf5ec9a995054e2b9aece", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1 +1 @@\n-Subproject commit 1c775a1dc5e29bc44b36604b510d6196d98077fa\n+Subproject commit 41493ffce5d0e17d54eaf5ec9a995054e2b9aece"}, {"sha": "3938df1a6826743b089edef4ba533f99cd485090", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -53,7 +53,7 @@ For example, in the following code:\n ```rust\n /// Does the thing.\n pub fn do_the_thing(_: SomeType) {\n-\tprintln!(\"Let's do the thing!\");\n+    println!(\"Let's do the thing!\");\n }\n \n /// Token you use to [`do_the_thing`].\n@@ -66,15 +66,15 @@ target out also works:\n \n ```rust\n pub mod some_module {\n-\t/// Token you use to do the thing.\n-\tpub struct SomeStruct;\n+    /// Token you use to do the thing.\n+    pub struct SomeStruct;\n }\n \n /// Does the thing. Requires one [`SomeStruct`] for the thing to work.\n ///\n /// [`SomeStruct`]: some_module::SomeStruct\n pub fn do_the_thing(_: some_module::SomeStruct) {\n-\tprintln!(\"Let's do the thing!\");\n+    println!(\"Let's do the thing!\");\n }\n ```\n \n@@ -428,3 +428,30 @@ $ rustdoc src/lib.rs --test -Z unstable-options --persist-doctests target/rustdo\n This flag allows you to keep doctest executables around after they're compiled or run.\n Usually, rustdoc will immediately discard a compiled doctest after it's been tested, but\n with this option, you can keep those binaries around for farther testing.\n+\n+### `--show-coverage`: calculate the percentage of items with documentation\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --show-coverage\n+```\n+\n+If you want to determine how many items in your crate are documented, pass this flag to rustdoc.\n+When it receives this flag, it will count the public items in your crate that have documentation,\n+and print out the counts and a percentage instead of generating docs.\n+\n+Some methodology notes about what rustdoc counts in this metric:\n+\n+* Rustdoc will only count items from your crate (i.e. items re-exported from other crates don't\n+  count).\n+* Docs written directly onto inherent impl blocks are not counted, even though their doc comments\n+  are displayed, because the common pattern in Rust code is to write all inherent methods into the\n+  same impl block.\n+* Items in a trait implementation are not counted, as those impls will inherit any docs from the\n+  trait itself.\n+* By default, only public items are counted. To count private items as well, pass\n+  `--document-private-items` at the same time.\n+\n+Public items that are not documented can be seen with the built-in `missing_docs` lint. Private\n+items that are not documented can be seen with Clippy's `missing_docs_in_private_items` lint."}, {"sha": "9e7968d906fbf5ff62a3824b764c43a690bd1644", "filename": "src/doc/unstable-book/src/language-features/c-variadic.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fc-variadic.md", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fc-variadic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fc-variadic.md?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -0,0 +1,24 @@\n+# `c_variadic`\n+\n+The tracking issue for this feature is: [#44930]\n+\n+[#44930]: https://github.com/rust-lang/rust/issues/44930\n+\n+------------------------\n+\n+The `c_variadic` language feature enables C-variadic functions to be\n+defined in Rust. The may be called both from within Rust and via FFI.\n+\n+## Examples\n+\n+```rust\n+#![feature(c_variadic)]\n+\n+pub unsafe extern \"C\" fn add(n: usize, mut args: ...) -> usize {\n+    let mut sum = 0;\n+    for _ in 0..n {\n+        sum += args.arg::<usize>();\n+    }\n+    sum\n+}\n+```"}, {"sha": "77762116e6b1c072c650ff19939447044a21343a", "filename": "src/doc/unstable-book/src/library-features/c-variadic.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fc-variadic.md", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fc-variadic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fc-variadic.md?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -0,0 +1,26 @@\n+# `c_variadic`\n+\n+The tracking issue for this feature is: [#44930]\n+\n+[#44930]: https://github.com/rust-lang/rust/issues/44930\n+\n+------------------------\n+\n+The `c_variadic` library feature exposes the `VaList` structure,\n+Rust's analogue of C's `va_list` type.\n+\n+## Examples\n+\n+```rust\n+#![feature(c_variadic)]\n+\n+use std::ffi::VaList;\n+\n+pub unsafe extern \"C\" fn vadd(n: usize, mut args: VaList) -> usize {\n+    let mut sum = 0;\n+    for _ in 0..n {\n+        sum += args.arg::<usize>();\n+    }\n+    sum\n+}\n+```"}, {"sha": "fdc1c4fa0cc38d95d0f74e324b596dbcec729347", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -290,6 +290,8 @@ def render_element(i):\n \n \n def read_utf8_string(ptr_val, byte_count):\n+    if byte_count == 0:\n+        return '\"\"'\n     error = lldb.SBError()\n     process = ptr_val.get_wrapped_value().GetProcess()\n     data = process.ReadMemory(ptr_val.as_integer(), byte_count, error)"}, {"sha": "9bce142b483f22f06c996aa8269a20eb19c7d59b", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -489,7 +489,7 @@ impl<T: ?Sized> From<Box<T>> for Pin<Box<T>> {\n }\n \n #[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\n-impl<'a, T: Copy> From<&'a [T]> for Box<[T]> {\n+impl<T: Copy> From<&[T]> for Box<[T]> {\n     /// Converts a `&[T]` into a `Box<[T]>`\n     ///\n     /// This conversion allocates on the heap\n@@ -503,15 +503,15 @@ impl<'a, T: Copy> From<&'a [T]> for Box<[T]> {\n     ///\n     /// println!(\"{:?}\", boxed_slice);\n     /// ```\n-    fn from(slice: &'a [T]) -> Box<[T]> {\n+    fn from(slice: &[T]) -> Box<[T]> {\n         let mut boxed = unsafe { RawVec::with_capacity(slice.len()).into_box() };\n         boxed.copy_from_slice(slice);\n         boxed\n     }\n }\n \n #[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\n-impl<'a> From<&'a str> for Box<str> {\n+impl From<&str> for Box<str> {\n     /// Converts a `&str` into a `Box<str>`\n     ///\n     /// This conversion allocates on the heap\n@@ -523,7 +523,7 @@ impl<'a> From<&'a str> for Box<str> {\n     /// println!(\"{}\", boxed);\n     /// ```\n     #[inline]\n-    fn from(s: &'a str) -> Box<str> {\n+    fn from(s: &str) -> Box<str> {\n         unsafe { from_boxed_utf8_unchecked(Box::from(s.as_bytes())) }\n     }\n }"}, {"sha": "dd128e096f952c521c67816020ecdbddee54c012", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -34,8 +34,7 @@\n #[cfg(not(test))]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(not(stage0), allow_internal_unstable(box_syntax))]\n-#[cfg_attr(stage0, allow_internal_unstable)]\n+#[allow_internal_unstable(box_syntax)]\n macro_rules! vec {\n     ($elem:expr; $n:expr) => (\n         $crate::vec::from_elem($elem, $n)"}, {"sha": "68eecd97ea11ad1996f42eecbfb3441cb335d249", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1145,15 +1145,15 @@ impl<T> From<T> for Rc<T> {\n }\n \n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n-impl<'a, T: Clone> From<&'a [T]> for Rc<[T]> {\n+impl<T: Clone> From<&[T]> for Rc<[T]> {\n     #[inline]\n     fn from(v: &[T]) -> Rc<[T]> {\n         <Self as RcFromSlice<T>>::from_slice(v)\n     }\n }\n \n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n-impl<'a> From<&'a str> for Rc<str> {\n+impl From<&str> for Rc<str> {\n     #[inline]\n     fn from(v: &str) -> Rc<str> {\n         let rc = Rc::<[u8]>::from(v.as_bytes());"}, {"sha": "a3e2098695f70c851478c99be85bd59947d51a6d", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -486,7 +486,7 @@ impl String {\n     /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n     /// [`as_bytes`]: struct.String.html#method.as_bytes\n     /// [`FromUtf8Error`]: struct.FromUtf8Error.html\n-    /// [`Err`]: ../../stdresult/enum.Result.html#variant.Err\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n@@ -2073,48 +2073,17 @@ impl ops::DerefMut for String {\n /// [`String`]: struct.String.html\n /// [`from_str`]: ../../std/str/trait.FromStr.html#tymethod.from_str\n #[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n-#[derive(Copy)]\n-pub enum ParseError {}\n+pub type ParseError = core::convert::Infallible;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for String {\n-    type Err = ParseError;\n+    type Err = core::convert::Infallible;\n     #[inline]\n     fn from_str(s: &str) -> Result<String, ParseError> {\n         Ok(String::from(s))\n     }\n }\n \n-#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n-impl Clone for ParseError {\n-    fn clone(&self) -> ParseError {\n-        match *self {}\n-    }\n-}\n-\n-#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n-impl fmt::Debug for ParseError {\n-    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {}\n-    }\n-}\n-\n-#[stable(feature = \"str_parse_error2\", since = \"1.8.0\")]\n-impl fmt::Display for ParseError {\n-    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {}\n-    }\n-}\n-\n-#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n-impl PartialEq for ParseError {\n-    fn eq(&self, _: &ParseError) -> bool {\n-        match *self {}\n-    }\n-}\n-\n-#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n-impl Eq for ParseError {}\n \n /// A trait for converting a value to a `String`.\n ///\n@@ -2203,9 +2172,9 @@ impl AsRef<[u8]> for String {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a str> for String {\n+impl From<&str> for String {\n     #[inline]\n-    fn from(s: &'a str) -> String {\n+    fn from(s: &str) -> String {\n         s.to_owned()\n     }\n }"}, {"sha": "cd62c3e05244c4399693864ee51fef8311b13c14", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1260,7 +1260,7 @@ impl<T> Vec<T> {\n     /// This method uses a closure to create new values on every push. If\n     /// you'd rather [`Clone`] a given value, use [`resize`]. If you want\n     /// to use the [`Default`] trait to generate values, you can pass\n-    /// [`Default::default()`] as the second argument..\n+    /// [`Default::default()`] as the second argument.\n     ///\n     /// # Examples\n     ///\n@@ -2182,25 +2182,25 @@ impl<T> AsMut<[T]> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: Clone> From<&'a [T]> for Vec<T> {\n+impl<T: Clone> From<&[T]> for Vec<T> {\n     #[cfg(not(test))]\n-    fn from(s: &'a [T]) -> Vec<T> {\n+    fn from(s: &[T]) -> Vec<T> {\n         s.to_vec()\n     }\n     #[cfg(test)]\n-    fn from(s: &'a [T]) -> Vec<T> {\n+    fn from(s: &[T]) -> Vec<T> {\n         crate::slice::to_vec(s)\n     }\n }\n \n #[stable(feature = \"vec_from_mut\", since = \"1.19.0\")]\n-impl<'a, T: Clone> From<&'a mut [T]> for Vec<T> {\n+impl<T: Clone> From<&mut [T]> for Vec<T> {\n     #[cfg(not(test))]\n-    fn from(s: &'a mut [T]) -> Vec<T> {\n+    fn from(s: &mut [T]) -> Vec<T> {\n         s.to_vec()\n     }\n     #[cfg(test)]\n-    fn from(s: &'a mut [T]) -> Vec<T> {\n+    fn from(s: &mut [T]) -> Vec<T> {\n         crate::slice::to_vec(s)\n     }\n }\n@@ -2231,8 +2231,8 @@ impl<T> From<Vec<T>> for Box<[T]> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a str> for Vec<u8> {\n-    fn from(s: &'a str) -> Vec<u8> {\n+impl From<&str> for Vec<u8> {\n+    fn from(s: &str) -> Vec<u8> {\n         From::from(s.as_bytes())\n     }\n }\n@@ -2468,6 +2468,25 @@ impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n     }\n }\n \n+impl<'a, T> Drain<'a, T> {\n+    /// Returns the remaining items of this iterator as a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(vec_drain_as_slice)]\n+    /// let mut vec = vec!['a', 'b', 'c'];\n+    /// let mut drain = vec.drain(..);\n+    /// assert_eq!(drain.as_slice(), &['a', 'b', 'c']);\n+    /// let _ = drain.next().unwrap();\n+    /// assert_eq!(drain.as_slice(), &['b', 'c']);\n+    /// ```\n+    #[unstable(feature = \"vec_drain_as_slice\", reason = \"recently added\", issue = \"58957\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        self.iter.as_slice()\n+    }\n+}\n+\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]"}, {"sha": "dcd9ce6dad756b669fafdaf60ae750516095805d", "filename": "src/libcore/array.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -49,7 +49,7 @@ unsafe impl<T, A: Unsize<[T]>> FixedSizeArray<T> for A {\n }\n \n /// The error type returned when a conversion from a slice to an array fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n #[derive(Debug, Copy, Clone)]\n pub struct TryFromSliceError(());\n \n@@ -138,16 +138,16 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"try_from\", issue = \"33417\")]\n-            impl<'a, T> TryFrom<&'a [T]> for [T; $N] where T: Copy {\n+            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+            impl<T> TryFrom<&[T]> for [T; $N] where T: Copy {\n                 type Error = TryFromSliceError;\n \n                 fn try_from(slice: &[T]) -> Result<[T; $N], TryFromSliceError> {\n                     <&Self>::try_from(slice).map(|r| *r)\n                 }\n             }\n \n-            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n             impl<'a, T> TryFrom<&'a [T]> for &'a [T; $N] {\n                 type Error = TryFromSliceError;\n \n@@ -161,7 +161,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n             impl<'a, T> TryFrom<&'a mut [T]> for &'a mut [T; $N] {\n                 type Error = TryFromSliceError;\n "}, {"sha": "825bd368bdf1d944edb3bb807b93a4d70104a18c", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -35,7 +35,7 @@ fn scatter(x: i32) -> i32 { (x * 31) % 127 }\n fn bench_max_by_key(b: &mut Bencher) {\n     b.iter(|| {\n         let it = 0..100;\n-        it.max_by_key(|&x| scatter(x))\n+        it.map(black_box).max_by_key(|&x| scatter(x))\n     })\n }\n \n@@ -56,7 +56,7 @@ fn bench_max_by_key2(b: &mut Bencher) {\n fn bench_max(b: &mut Bencher) {\n     b.iter(|| {\n         let it = 0..100;\n-        it.map(scatter).max()\n+        it.map(black_box).map(scatter).max()\n     })\n }\n \n@@ -185,13 +185,13 @@ bench_sums! {\n bench_sums! {\n     bench_filter_sum,\n     bench_filter_ref_sum,\n-    (0i64..1000000).filter(|x| x % 2 == 0)\n+    (0i64..1000000).filter(|x| x % 3 == 0)\n }\n \n bench_sums! {\n     bench_filter_chain_sum,\n     bench_filter_chain_ref_sum,\n-    (0i64..1000000).chain(0..1000000).filter(|x| x % 2 == 0)\n+    (0i64..1000000).chain(0..1000000).filter(|x| x % 3 == 0)\n }\n \n bench_sums! {\n@@ -306,3 +306,31 @@ fn bench_skip_then_zip(b: &mut Bencher) {\n         assert_eq!(s, 2009900);\n     });\n }\n+\n+#[bench]\n+fn bench_filter_count(b: &mut Bencher) {\n+    b.iter(|| {\n+        (0i64..1000000).map(black_box).filter(|x| x % 3 == 0).count()\n+    })\n+}\n+\n+#[bench]\n+fn bench_filter_ref_count(b: &mut Bencher) {\n+    b.iter(|| {\n+        (0i64..1000000).map(black_box).by_ref().filter(|x| x % 3 == 0).count()\n+    })\n+}\n+\n+#[bench]\n+fn bench_filter_chain_count(b: &mut Bencher) {\n+    b.iter(|| {\n+        (0i64..1000000).chain(0..1000000).map(black_box).filter(|x| x % 3 == 0).count()\n+    })\n+}\n+\n+#[bench]\n+fn bench_filter_chain_ref_count(b: &mut Bencher) {\n+    b.iter(|| {\n+        (0i64..1000000).chain(0..1000000).map(black_box).by_ref().filter(|x| x % 3 == 0).count()\n+    })\n+}"}, {"sha": "6a5abfb408f5bfbbd8109026f438585f724a7f3c", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -218,7 +218,7 @@ impl FromStr for char {\n }\n \n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl TryFrom<u32> for char {\n     type Error = CharTryFromError;\n \n@@ -233,11 +233,11 @@ impl TryFrom<u32> for char {\n }\n \n /// The error type returned when a conversion from u32 to char fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct CharTryFromError(());\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl fmt::Display for CharTryFromError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         \"converted integer out of range for `char`\".fmt(f)"}, {"sha": "f3369c4d94010bdd3bf2e63509c988734073f0c4", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -30,7 +30,7 @@ pub use self::convert::{from_u32, from_digit};\n pub use self::convert::from_u32_unchecked;\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n pub use self::convert::ParseCharError;\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub use self::convert::CharTryFromError;\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};"}, {"sha": "94bed3708369a6999699553eb024a8c0aa465578", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1004,26 +1004,26 @@ mod impls {\n     // & pointers\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: & &B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: & &B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialOrd<&B> for &A where A: PartialOrd<B> {\n         #[inline]\n-        fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n+        fn partial_cmp(&self, other: &&B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n         }\n         #[inline]\n-        fn lt(&self, other: & &'b B) -> bool { PartialOrd::lt(*self, *other) }\n+        fn lt(&self, other: & &B) -> bool { PartialOrd::lt(*self, *other) }\n         #[inline]\n-        fn le(&self, other: & &'b B) -> bool { PartialOrd::le(*self, *other) }\n+        fn le(&self, other: & &B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: & &'b B) -> bool { PartialOrd::ge(*self, *other) }\n+        fn ge(&self, other: & &B) -> bool { PartialOrd::ge(*self, *other) }\n         #[inline]\n-        fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n+        fn gt(&self, other: & &B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<A: ?Sized> Ord for &A where A: Ord {\n@@ -1036,26 +1036,26 @@ mod impls {\n     // &mut pointers\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&mut B> for &mut A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialOrd<&mut B> for &mut A where A: PartialOrd<B> {\n         #[inline]\n-        fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n+        fn partial_cmp(&self, other: &&mut B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n         }\n         #[inline]\n-        fn lt(&self, other: &&'b mut B) -> bool { PartialOrd::lt(*self, *other) }\n+        fn lt(&self, other: &&mut B) -> bool { PartialOrd::lt(*self, *other) }\n         #[inline]\n-        fn le(&self, other: &&'b mut B) -> bool { PartialOrd::le(*self, *other) }\n+        fn le(&self, other: &&mut B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: &&'b mut B) -> bool { PartialOrd::ge(*self, *other) }\n+        fn ge(&self, other: &&mut B) -> bool { PartialOrd::ge(*self, *other) }\n         #[inline]\n-        fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n+        fn gt(&self, other: &&mut B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<A: ?Sized> Ord for &mut A where A: Ord {\n@@ -1066,18 +1066,18 @@ mod impls {\n     impl<A: ?Sized> Eq for &mut A where A: Eq {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&mut B> for &A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &mut A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: &&'b B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&B) -> bool { PartialEq::ne(*self, *other) }\n     }\n }"}, {"sha": "774d648558b48ebd80f30dc519b4f253c7e619c1", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 183, "deletions": 11, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -41,6 +41,8 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use fmt;\n+\n /// An identity function.\n ///\n /// Two things are important to note about this function:\n@@ -359,30 +361,88 @@ pub trait From<T>: Sized {\n /// An attempted conversion that consumes `self`, which may or may not be\n /// expensive.\n ///\n-/// Library authors should not directly implement this trait, but should prefer\n-/// implementing the [`TryFrom`] trait, which offers greater flexibility and\n-/// provides an equivalent `TryInto` implementation for free, thanks to a\n-/// blanket implementation in the standard library. For more information on this,\n-/// see the documentation for [`Into`].\n+/// Library authors should usually not directly implement this trait,\n+/// but should prefer implementing the [`TryFrom`] trait, which offers\n+/// greater flexibility and provides an equivalent `TryInto`\n+/// implementation for free, thanks to a blanket implementation in the\n+/// standard library. For more information on this, see the\n+/// documentation for [`Into`].\n+///\n+/// # Implementing `TryInto`\n+///\n+/// This suffers the same restrictions and reasoning as implementing\n+/// [`Into`], see there for details.\n ///\n /// [`TryFrom`]: trait.TryFrom.html\n /// [`Into`]: trait.Into.html\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub trait TryInto<T>: Sized {\n     /// The type returned in the event of a conversion error.\n+    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n     type Error;\n \n     /// Performs the conversion.\n+    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n     fn try_into(self) -> Result<T, Self::Error>;\n }\n \n-/// Attempt to construct `Self` via a conversion.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+/// Simple and safe type conversions that may fail in a controlled\n+/// way under some circumstances. It is the reciprocal of [`TryInto`].\n+///\n+/// This is useful when you are doing a type conversion that may\n+/// trivially succeed but may also need special handling.\n+/// For example, there is no way to convert an `i64` into an `i32`\n+/// using the [`From`] trait, because an `i64` may contain a value\n+/// that an `i32` cannot represent and so the conversion would lose data.\n+/// This might be handled by truncating the `i64` to an `i32` (essentially\n+/// giving the `i64`'s value modulo `i32::MAX`) or by simply returning\n+/// `i32::MAX`, or by some other method.  The `From` trait is intended\n+/// for perfect conversions, so the `TryFrom` trait informs the\n+/// programmer when a type conversion could go bad and lets them\n+/// decide how to handle it.\n+///\n+/// # Generic Implementations\n+///\n+/// - `TryFrom<T> for U` implies [`TryInto<U>`]` for T`\n+/// - [`try_from`] is reflexive, which means that `TryFrom<T> for T`\n+/// is implemented and cannot fail -- the associated `Error` type for\n+/// calling `T::try_from()` on a value of type `T` is `Infallible`.\n+/// When the `!` type is stablized `Infallible` and `!` will be\n+/// equivalent.\n+///\n+/// # Examples\n+///\n+/// As described, [`i32`] implements `TryFrom<i64>`:\n+///\n+/// ```\n+/// use std::convert::TryFrom;\n+///\n+/// let big_number = 1_000_000_000_000i64;\n+/// // Silently truncates `big_number`, requires detecting\n+/// // and handling the truncation after the fact.\n+/// let smaller_number = big_number as i32;\n+/// assert_eq!(smaller_number, -727379968);\n+///\n+/// // Returns an error because `big_number` is too big to\n+/// // fit in an `i32`.\n+/// let try_smaller_number = i32::try_from(big_number);\n+/// assert!(try_smaller_number.is_err());\n+///\n+/// // Returns `Ok(3)`.\n+/// let try_successful_smaller_number = i32::try_from(3);\n+/// assert!(try_successful_smaller_number.is_ok());\n+/// ```\n+///\n+/// [`try_from`]: trait.TryFrom.html#tymethod.try_from\n+/// [`TryInto`]: trait.TryInto.html\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub trait TryFrom<T>: Sized {\n     /// The type returned in the event of a conversion error.\n+    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n     type Error;\n \n     /// Performs the conversion.\n+    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n     fn try_from(value: T) -> Result<Self, Self::Error>;\n }\n \n@@ -450,7 +510,7 @@ impl<T> From<T> for T {\n \n \n // TryFrom implies TryInto\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl<T, U> TryInto<U> for T where U: TryFrom<T>\n {\n     type Error = U::Error;\n@@ -462,9 +522,9 @@ impl<T, U> TryInto<U> for T where U: TryFrom<T>\n \n // Infallible conversions are semantically equivalent to fallible conversions\n // with an uninhabited error type.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl<T, U> TryFrom<U> for T where U: Into<T> {\n-    type Error = !;\n+    type Error = Infallible;\n \n     fn try_from(value: U) -> Result<Self, Self::Error> {\n         Ok(U::into(value))\n@@ -496,3 +556,115 @@ impl AsRef<str> for str {\n         self\n     }\n }\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// THE NO-ERROR ERROR TYPE\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// The error type for errors that can never happen.\n+///\n+/// Since this enum has no variant, a value of this type can never actually exist.\n+/// This can be useful for generic APIs that use [`Result`] and parameterize the error type,\n+/// to indicate that the result is always [`Ok`].\n+///\n+/// For example, the [`TryFrom`] trait (conversion that returns a [`Result`])\n+/// has a blanket implementation for all types where a reverse [`Into`] implementation exists.\n+///\n+/// ```ignore (illustrates std code, duplicating the impl in a doctest would be an error)\n+/// impl<T, U> TryFrom<U> for T where U: Into<T> {\n+///     type Error = Infallible;\n+///\n+///     fn try_from(value: U) -> Result<Self, Infallible> {\n+///         Ok(U::into(value))  // Never returns `Err`\n+///     }\n+/// }\n+/// ```\n+///\n+/// # Future compatibility\n+///\n+/// This enum has the same role as [the `!` \u201cnever\u201d type][never],\n+/// which is unstable in this version of Rust.\n+/// When `!` is stabilized, we plan to make `Infallible` a type alias to it:\n+///\n+/// ```ignore (illustrates future std change)\n+/// pub type Infallible = !;\n+/// ```\n+///\n+/// \u2026 and eventually deprecate `Infallible`.\n+///\n+///\n+/// However there is one case where `!` syntax can be used\n+/// before `!` is stabilized as a full-fleged type: in the position of a function\u2019s return type.\n+/// Specifically, it is possible implementations for two different function pointer types:\n+///\n+/// ```\n+/// trait MyTrait {}\n+/// impl MyTrait for fn() -> ! {}\n+/// impl MyTrait for fn() -> std::convert::Infallible {}\n+/// ```\n+///\n+/// With `Infallible` being an enum, this code is valid.\n+/// However when `Infallible` becomes an alias for the never type,\n+/// the two `impl`s will start to overlap\n+/// and therefore will be disallowed by the language\u2019s trait coherence rules.\n+///\n+/// [`Ok`]: ../result/enum.Result.html#variant.Ok\n+/// [`Result`]: ../result/enum.Result.html\n+/// [`TryFrom`]: trait.TryFrom.html\n+/// [`Into`]: trait.Into.html\n+/// [never]: ../../std/primitive.never.html\n+#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n+#[derive(Copy)]\n+pub enum Infallible {}\n+\n+#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n+impl Clone for Infallible {\n+    fn clone(&self) -> Infallible {\n+        match *self {}\n+    }\n+}\n+\n+#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n+impl fmt::Debug for Infallible {\n+    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {}\n+    }\n+}\n+\n+#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n+impl fmt::Display for Infallible {\n+    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {}\n+    }\n+}\n+\n+#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n+impl PartialEq for Infallible {\n+    fn eq(&self, _: &Infallible) -> bool {\n+        match *self {}\n+    }\n+}\n+\n+#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n+impl Eq for Infallible {}\n+\n+#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n+impl PartialOrd for Infallible {\n+    fn partial_cmp(&self, _other: &Self) -> Option<crate::cmp::Ordering> {\n+        match *self {}\n+    }\n+}\n+\n+#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n+impl Ord for Infallible {\n+    fn cmp(&self, _other: &Self) -> crate::cmp::Ordering {\n+        match *self {}\n+    }\n+}\n+\n+#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n+impl From<!> for Infallible {\n+    fn from(x: !) -> Self {\n+        x\n+    }\n+}"}, {"sha": "edeb65afd67b2d89e336cbcbedae2a6ef3a8f9bf", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -15,6 +15,7 @@ fn float_to_decimal_common_exact<T>(fmt: &mut Formatter, num: &T,\n         // FIXME(#53491): Technically, this is calling `get_mut` on an uninitialized\n         // `MaybeUninit` (here and elsewhere in this file).  Revisit this once\n         // we decided whether that is valid or not.\n+        // Using `freeze` is *not enough*; `flt2dec::Part` is an enum!\n         let formatted = flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact,\n                                                     *num, sign, precision,\n                                                     false, buf.get_mut(), parts.get_mut());\n@@ -33,6 +34,7 @@ fn float_to_decimal_common_shortest<T>(fmt: &mut Formatter, num: &T,\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n         let mut parts = MaybeUninit::<[flt2dec::Part; 4]>::uninitialized();\n+        // FIXME(#53491)\n         let formatted = flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num,\n                                                  sign, precision, false, buf.get_mut(),\n                                                  parts.get_mut());\n@@ -71,6 +73,7 @@ fn float_to_exponential_common_exact<T>(fmt: &mut Formatter, num: &T,\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninitialized(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        // FIXME(#53491)\n         let formatted = flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact,\n                                                   *num, sign, precision,\n                                                   upper, buf.get_mut(), parts.get_mut());\n@@ -90,6 +93,7 @@ fn float_to_exponential_common_shortest<T>(fmt: &mut Formatter,\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n         let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        // FIXME(#53491)\n         let formatted = flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest,\n                                                      *num, sign, (0, 0), upper,\n                                                      buf.get_mut(), parts.get_mut());"}, {"sha": "b5c20582986b262368344a8df54b27b495c59f5d", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -37,21 +37,21 @@ macro_rules! forward_ref_binop {\n         }\n \n         #[$attr]\n-        impl<'a> $imp<&'a $u> for $t {\n+        impl $imp<&$u> for $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n             #[inline]\n-            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n                 $imp::$method(self, *other)\n             }\n         }\n \n         #[$attr]\n-        impl<'a, 'b> $imp<&'a $u> for &'b $t {\n+        impl $imp<&$u> for &$t {\n             type Output = <$t as $imp<$u>>::Output;\n \n             #[inline]\n-            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n                 $imp::$method(*self, *other)\n             }\n         }\n@@ -67,9 +67,9 @@ macro_rules! forward_ref_op_assign {\n     };\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n         #[$attr]\n-        impl<'a> $imp<&'a $u> for $t {\n+        impl $imp<&$u> for $t {\n             #[inline]\n-            fn $method(&mut self, other: &'a $u) {\n+            fn $method(&mut self, other: &$u) {\n                 $imp::$method(self, *other);\n             }\n         }"}, {"sha": "75a33394e3d2f6edb4f74ec08415c8348a7b292b", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1282,13 +1282,11 @@ extern \"rust-intrinsic\" {\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,\n     /// [`std::u32::saturating_add`](../../std/primitive.u32.html#method.saturating_add)\n-    #[cfg(not(stage0))]\n     pub fn saturating_add<T>(a: T, b: T) -> T;\n     /// Computes `a - b`, while saturating at numeric bounds.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_sub` method. For example,\n     /// [`std::u32::saturating_sub`](../../std/primitive.u32.html#method.saturating_sub)\n-    #[cfg(not(stage0))]\n     pub fn saturating_sub<T>(a: T, b: T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v',"}, {"sha": "d4ad22c16bbfa697458af3c5d2e7882be0588bc8", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -681,12 +681,7 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n-        for x in &mut self.iter {\n-            if (self.predicate)(&x) {\n-                return Some(x);\n-            }\n-        }\n-        None\n+        self.try_for_each(Err).err()\n     }\n \n     #[inline]\n@@ -707,12 +702,9 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n     // Using the branchless version will also simplify the LLVM byte code, thus\n     // leaving more budget for LLVM optimizations.\n     #[inline]\n-    fn count(mut self) -> usize {\n-        let mut count = 0;\n-        for x in &mut self.iter {\n-            count += (self.predicate)(&x) as usize;\n-        }\n-        count\n+    fn count(self) -> usize {\n+        let mut predicate = self.predicate;\n+        self.iter.map(|x| predicate(&x) as usize).sum()\n     }\n \n     #[inline]\n@@ -746,12 +738,7 @@ impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<I::Item> {\n-        for x in self.iter.by_ref().rev() {\n-            if (self.predicate)(&x) {\n-                return Some(x);\n-            }\n-        }\n-        None\n+        self.try_rfold((), |_, x| Err(x)).err()\n     }\n \n     #[inline]\n@@ -820,12 +807,7 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n \n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        for x in self.iter.by_ref() {\n-            if let Some(y) = (self.f)(x) {\n-                return Some(y);\n-            }\n-        }\n-        None\n+        self.try_for_each(Err).err()\n     }\n \n     #[inline]\n@@ -863,12 +845,7 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n-        for x in self.iter.by_ref().rev() {\n-            if let Some(y) = (self.f)(x) {\n-                return Some(y);\n-            }\n-        }\n-        None\n+        self.try_rfold((), |_, x| Err(x)).err()\n     }\n \n     #[inline]"}, {"sha": "ca7feed0712d1e72cc76faa39aec7c1a82f632f8", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 19, "deletions": 56, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -2008,12 +2008,7 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |_, x, _, y| *x <= *y)\n-            .map(|(_, x)| x)\n+        self.max_by(Ord::cmp)\n     }\n \n     /// Returns the minimum element of an iterator.\n@@ -2038,12 +2033,7 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // only switch to y if it is strictly smaller, to\n-                     // preserve stability.\n-                     |_, x, _, y| *x > *y)\n-            .map(|(_, x)| x)\n+        self.min_by(Ord::cmp)\n     }\n \n     /// Returns the element that gives the maximum value from the\n@@ -2062,15 +2052,11 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+    fn max_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n-        select_fold1(self,\n-                     f,\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |x_p, _, y_p, _| x_p <= y_p)\n-            .map(|(_, x)| x)\n+        // switch to y even if it is only equal, to preserve stability.\n+        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p <= y_p).map(|(_, x)| x)\n     }\n \n     /// Returns the element that gives the maximum value with respect to the\n@@ -2092,12 +2078,8 @@ pub trait Iterator {\n     fn max_by<F>(self, mut compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |_, x, _, y| Ordering::Greater != compare(x, y))\n-            .map(|(_, x)| x)\n+        // switch to y even if it is only equal, to preserve stability.\n+        select_fold1(self, |x, y| compare(x, y) != Ordering::Greater)\n     }\n \n     /// Returns the element that gives the minimum value from the\n@@ -2115,15 +2097,11 @@ pub trait Iterator {\n     /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+    fn min_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n-        select_fold1(self,\n-                     f,\n-                     // only switch to y if it is strictly smaller, to\n-                     // preserve stability.\n-                     |x_p, _, y_p, _| x_p > y_p)\n-            .map(|(_, x)| x)\n+        // only switch to y if it is strictly smaller, to preserve stability.\n+        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p > y_p).map(|(_, x)| x)\n     }\n \n     /// Returns the element that gives the minimum value with respect to the\n@@ -2145,12 +2123,8 @@ pub trait Iterator {\n     fn min_by<F>(self, mut compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is strictly smaller, to\n-                     // preserve stability.\n-                     |_, x, _, y| Ordering::Greater == compare(x, y))\n-            .map(|(_, x)| x)\n+        // only switch to y if it is strictly smaller, to preserve stability.\n+        select_fold1(self, |x, y| compare(x, y) == Ordering::Greater)\n     }\n \n \n@@ -2693,34 +2667,23 @@ pub trait Iterator {\n     }\n }\n \n-/// Select an element from an iterator based on the given \"projection\"\n-/// and \"comparison\" function.\n+/// Select an element from an iterator based on the given \"comparison\"\n+/// function.\n ///\n /// This is an idiosyncratic helper to try to factor out the\n /// commonalities of {max,min}{,_by}. In particular, this avoids\n /// having to implement optimizations several times.\n #[inline]\n-fn select_fold1<I, B, FProj, FCmp>(mut it: I,\n-                                   mut f_proj: FProj,\n-                                   mut f_cmp: FCmp) -> Option<(B, I::Item)>\n-    where I: Iterator,\n-          FProj: FnMut(&I::Item) -> B,\n-          FCmp: FnMut(&B, &I::Item, &B, &I::Item) -> bool\n+fn select_fold1<I, F>(mut it: I, mut f: F) -> Option<I::Item>\n+    where\n+        I: Iterator,\n+        F: FnMut(&I::Item, &I::Item) -> bool,\n {\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n     it.next().map(|first| {\n-        let first_p = f_proj(&first);\n-\n-        it.fold((first_p, first), |(sel_p, sel), x| {\n-            let x_p = f_proj(&x);\n-            if f_cmp(&sel_p, &sel, &x_p, &x) {\n-                (x_p, x)\n-            } else {\n-                (sel_p, sel)\n-            }\n-        })\n+        it.fold(first, |sel, x| if f(&sel, &x) { x } else { sel })\n     })\n }\n "}, {"sha": "63688e70c45cb5dcc8a65d7a2fd8bf983b09184c", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -123,7 +123,6 @@\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n #![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n-#![feature(unrestricted_attribute_tokens)]\n #![feature(external_doc)]\n \n #[prelude_import]"}, {"sha": "b052f59b0f5c2ae07f2f178764012852fae66ac5", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,7 +1,6 @@\n /// Entry point of thread panic. For details, see `std::macros`.\n #[macro_export]\n-#[cfg_attr(not(stage0), allow_internal_unstable(core_panic, __rust_unstable_column))]\n-#[cfg_attr(stage0, allow_internal_unstable)]\n+#[allow_internal_unstable(core_panic, __rust_unstable_column)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n@@ -422,8 +421,7 @@ macro_rules! write {\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(stage0, allow_internal_unstable)]\n-#[cfg_attr(not(stage0), allow_internal_unstable(format_args_nl))]\n+#[allow_internal_unstable(format_args_nl)]\n macro_rules! writeln {\n     ($dst:expr) => (\n         write!($dst, \"\\n\")"}, {"sha": "9b1ead7edd68b03d6dd4cd7bc1b8f6ede6e32ab3", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -636,7 +636,7 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// [`Pin<P>`]: ../pin/struct.Pin.html\n /// [`pin module`]: ../../std/pin/index.html\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-#[cfg_attr(not(stage0), lang = \"unpin\")]\n+#[lang = \"unpin\"]\n pub auto trait Unpin {}\n \n /// A marker type which does not implement `Unpin`."}, {"sha": "90e84d0b28c3b0bea5c8d0a0c3d315f74ab73148", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 232, "deletions": 29, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -900,10 +900,16 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n     }\n }\n \n+// FIXME: Reference `MaybeUninit` from these docs, once that is stable.\n /// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n ///\n /// This wrapper is 0-cost.\n ///\n+/// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n+/// As a consequence, it has *no effect* on the assumptions that the compiler makes\n+/// about all values being initialized at their type.  In particular, initializing\n+/// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n+///\n /// # Examples\n ///\n /// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n@@ -935,6 +941,8 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n ///     }\n /// }\n /// ```\n+///\n+/// [`mem::zeroed`]: fn.zeroed.html\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[lang = \"manually_drop\"]\n #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -1035,7 +1043,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n     }\n }\n \n-/// A newtype to construct uninitialized instances of `T`.\n+/// A wrapper to construct uninitialized instances of `T`.\n ///\n /// The compiler, in general, assumes that variables are properly initialized\n /// at their respective type. For example, a variable of reference type must\n@@ -1049,41 +1057,51 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n-/// // equivalent code with `MaybeUninit`\n+/// // The equivalent code with `MaybeUninit<&i32>`:\n /// let x: &i32 = unsafe { MaybeUninit::zeroed().into_initialized() }; // undefined behavior!\n /// ```\n ///\n /// This is exploited by the compiler for various optimizations, such as eliding\n /// run-time checks and optimizing `enum` layout.\n ///\n-/// Not initializing memory at all (instead of zero-initializing it) causes the same\n-/// issue: after all, the initial value of the variable might just happen to be\n-/// one that violates the invariant. Moreover, uninitialized memory is special\n-/// in that the compiler knows that it does not have a fixed value. This makes\n-/// it undefined behavior to have uninitialized data in a variable even if that\n-/// variable has otherwise no restrictions about which values are valid:\n+/// Similarly, entirely uninitialized memory may have any content, while a `bool` must\n+/// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n+///\n+/// ```rust,no_run\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<bool>`:\n+/// let b: bool = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n+/// ```\n+///\n+/// Moreover, uninitialized memory is special in that the compiler knows that\n+/// it does not have a fixed value. This makes it undefined behavior to have\n+/// uninitialized data in a variable even if that variable has an integer type,\n+/// which otherwise can hold any bit pattern:\n ///\n /// ```rust,no_run\n /// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n-/// // equivalent code with `MaybeUninit`\n+/// // The equivalent code with `MaybeUninit<i32>`:\n /// let x: i32 = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n /// ```\n /// (Notice that the rules around uninitialized integers are not finalized yet, but\n /// until they are, it is advisable to avoid them.)\n ///\n-/// `MaybeUninit` serves to enable unsafe code to deal with uninitialized data:\n-/// it is a signal to the compiler indicating that the data here might *not*\n+/// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n+/// It is a signal to the compiler indicating that the data here might *not*\n /// be initialized:\n ///\n /// ```rust\n /// #![feature(maybe_uninit)]\n /// use std::mem::MaybeUninit;\n ///\n /// // Create an explicitly uninitialized reference. The compiler knows that data inside\n-/// // a `MaybeUninit` may be invalid, and hence this is not UB:\n+/// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n /// let mut x = MaybeUninit::<&i32>::uninitialized();\n /// // Set it to a valid value.\n /// x.set(&0);\n@@ -1092,45 +1110,84 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// let x = unsafe { x.into_initialized() };\n /// ```\n ///\n-/// The compiler then knows to not optimize this code.\n+/// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n // FIXME before stabilizing, explain how to initialize a struct field-by-field.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n-// NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::{uninitialized,zeroed}`\n+#[derive(Copy)]\n+// NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::uninitialized`.\n pub union MaybeUninit<T> {\n     uninit: (),\n     value: ManuallyDrop<T>,\n }\n \n+#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+impl<T: Copy> Clone for MaybeUninit<T> {\n+    #[inline(always)]\n+    fn clone(&self) -> Self {\n+        // Not calling T::clone(), we cannot know if we are initialized enough for that.\n+        *self\n+    }\n+}\n+\n impl<T> MaybeUninit<T> {\n-    /// Create a new `MaybeUninit` initialized with the given value.\n+    /// Create a new `MaybeUninit<T>` initialized with the given value.\n     ///\n-    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub const fn new(val: T) -> MaybeUninit<T> {\n         MaybeUninit { value: ManuallyDrop::new(val) }\n     }\n \n-    /// Creates a new `MaybeUninit` in an uninitialized state.\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state.\n     ///\n-    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub const fn uninitialized() -> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n-    /// Creates a new `MaybeUninit` in an uninitialized state, with the memory being\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n     /// filled with `0` bytes. It depends on `T` whether that already makes for\n     /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n     /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n     /// be null.\n     ///\n-    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// # Example\n+    ///\n+    /// Correct usage of this function: initializing a struct with zero, where all\n+    /// fields of the struct can hold the bit-pattern 0 as a valid value.\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n+    /// let x = unsafe { x.into_initialized() };\n+    /// assert_eq!(x, (0, false));\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this function: initializing a struct with zero, where some fields\n+    /// cannot hold 0 as a valid value.\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// enum NotZero { One = 1, Two = 2 };\n+    ///\n+    /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n+    /// let x = unsafe { x.into_initialized() };\n+    /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n+    /// // This is undefined behavior.\n+    /// ```\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline]\n     pub fn zeroed() -> MaybeUninit<T> {\n@@ -1141,9 +1198,10 @@ impl<T> MaybeUninit<T> {\n         u\n     }\n \n-    /// Sets the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n-    /// For your convenience, this also returns a mutable reference to the (now safely initialized)\n-    /// contents of `self`.\n+    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n+    /// without dropping it, so be careful not to use this twice unless you want to\n+    /// skip running the destructor. For your convenience, this also returns a mutable\n+    /// reference to the (now safely initialized) contents of `self`.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn set(&mut self, val: T) -> &mut T {\n@@ -1154,42 +1212,187 @@ impl<T> MaybeUninit<T> {\n     }\n \n     /// Gets a pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// assert_eq!(x_vec.len(), 3);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_ptr(&self) -> *const T {\n         unsafe { &*self.value as *const T }\n     }\n \n     /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n+    /// // This is okay because we initialized it.\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// x_vec.push(3);\n+    /// assert_eq!(x_vec.len(), 4);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         unsafe { &mut *self.value as *mut T }\n     }\n \n-    /// Extracts the value from the `MaybeUninit` container. This is a great way\n+    /// Extracts the value from the `MaybeUninit<T>` container. This is a great way\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<bool>::uninitialized();\n+    /// unsafe { x.as_mut_ptr().write(true); }\n+    /// let x_init = unsafe { x.into_initialized() };\n+    /// assert_eq!(x_init, true);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let x_init = unsafe { x.into_initialized() };\n+    /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n+    /// ```\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn into_initialized(self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n         ManuallyDrop::into_inner(self.value)\n     }\n \n+    /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n+    /// to the usual drop handling.\n+    ///\n+    /// Whenever possible, it is preferrable to use [`into_initialized`] instead, which\n+    /// prevents duplicating the content of the `MaybeUninit<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    ///\n+    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n+    /// multiple copies of the data (by calling `read_initialized` multiple times, or first\n+    /// calling `read_initialized` and then [`into_initialized`]), it is your responsibility\n+    /// to ensure that that data may indeed be duplicated.\n+    ///\n+    /// [`into_initialized`]: #method.into_initialized\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<u32>::uninitialized();\n+    /// x.set(13);\n+    /// let x1 = unsafe { x.read_initialized() };\n+    /// // `u32` is `Copy`, so we may read multiple times.\n+    /// let x2 = unsafe { x.read_initialized() };\n+    /// assert_eq!(x1, x2);\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninitialized();\n+    /// x.set(None);\n+    /// let x1 = unsafe { x.read_initialized() };\n+    /// // Duplicating a `None` value is okay, so we may read multiple times.\n+    /// let x2 = unsafe { x.read_initialized() };\n+    /// assert_eq!(x1, x2);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninitialized();\n+    /// x.set(Some(vec![0,1,2]));\n+    /// let x1 = unsafe { x.read_initialized() };\n+    /// let x2 = unsafe { x.read_initialized() };\n+    /// // We now created two copies of the same vector, leading to a double-free when\n+    /// // they both get dropped!\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn read_initialized(&self) -> T {\n+        intrinsics::panic_if_uninhabited::<T>();\n+        self.as_ptr().read()\n+    }\n+\n     /// Gets a reference to the contained value.\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n@@ -1202,7 +1405,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references"}, {"sha": "d93cfbc2a28acd571b4a621af2aa2875ffc58844", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 44, "deletions": 130, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -2,7 +2,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use convert::TryFrom;\n+use convert::{TryFrom, Infallible};\n use fmt;\n use intrinsics;\n use mem;\n@@ -346,7 +346,7 @@ $EndFeature, \"\n             concat!(\"Shifts the bits to the left by a specified amount, `n`,\n wrapping the truncated bits to the end of the resulting integer.\n \n-Please note this isn't the same operation as `<<`!\n+Please note this isn't the same operation as the `<<` shifting operator!\n \n # Examples\n \n@@ -370,7 +370,7 @@ assert_eq!(n.rotate_left(\", $rot, \"), m);\n wrapping the truncated bits to the beginning of the resulting\n integer.\n \n-Please note this isn't the same operation as `>>`!\n+Please note this isn't the same operation as the `>>` shifting operator!\n \n # Examples\n \n@@ -874,33 +874,6 @@ bounds instead of overflowing.\n \n Basic usage:\n \n-```\n-\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n-assert_eq!(\", stringify!($SelfT), \"::max_value().saturating_add(100), \", stringify!($SelfT),\n-\"::max_value());\",\n-$EndFeature, \"\n-```\"),\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            #[cfg(stage0)]\n-            pub fn saturating_add(self, rhs: Self) -> Self {\n-                match self.checked_add(rhs) {\n-                    Some(x) => x,\n-                    None if rhs >= 0 => Self::max_value(),\n-                    None => Self::min_value(),\n-                }\n-            }\n-\n-        }\n-\n-        doc_comment! {\n-            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n-bounds instead of overflowing.\n-\n-# Examples\n-\n-Basic usage:\n-\n ```\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n assert_eq!(\", stringify!($SelfT), \"::max_value().saturating_add(100), \", stringify!($SelfT),\n@@ -911,37 +884,11 @@ $EndFeature, \"\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n             #[inline]\n-            #[cfg(not(stage0))]\n             pub const fn saturating_add(self, rhs: Self) -> Self {\n                 intrinsics::saturating_add(self, rhs)\n             }\n         }\n \n-        doc_comment! {\n-            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating at the\n-numeric bounds instead of overflowing.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\n-assert_eq!(\", stringify!($SelfT), \"::min_value().saturating_sub(100), \", stringify!($SelfT),\n-\"::min_value());\",\n-$EndFeature, \"\n-```\"),\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            #[cfg(stage0)]\n-            pub fn saturating_sub(self, rhs: Self) -> Self {\n-                match self.checked_sub(rhs) {\n-                    Some(x) => x,\n-                    None if rhs >= 0 => Self::min_value(),\n-                    None => Self::max_value(),\n-                }\n-            }\n-        }\n \n         doc_comment! {\n             concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating at the\n@@ -960,7 +907,6 @@ $EndFeature, \"\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n             #[inline]\n-            #[cfg(not(stage0))]\n             pub const fn saturating_sub(self, rhs: Self) -> Self {\n                 intrinsics::saturating_sub(self, rhs)\n             }\n@@ -2000,7 +1946,6 @@ assert_eq!(value, \", $swap_op, \");\n When starting from a slice rather than an array, fallible conversion APIs can be used:\n \n ```\n-#![feature(try_from)]\n use std::convert::TryInto;\n \n fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n@@ -2032,13 +1977,12 @@ assert_eq!(value, \", $swap_op, \");\n When starting from a slice rather than an array, fallible conversion APIs can be used:\n \n ```\n-#![feature(try_from)]\n use std::convert::TryInto;\n \n-fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n     let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n     *input = rest;\n-    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\n }\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n@@ -2074,13 +2018,12 @@ assert_eq!(value, \", $swap_op, \");\n When starting from a slice rather than an array, fallible conversion APIs can be used:\n \n ```\n-#![feature(try_from)]\n use std::convert::TryInto;\n \n-fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n     let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n     *input = rest;\n-    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\n }\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n@@ -2303,7 +2246,7 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n             concat!(\"Shifts the bits to the left by a specified amount, `n`,\n wrapping the truncated bits to the end of the resulting integer.\n \n-Please note this isn't the same operation as `<<`!\n+Please note this isn't the same operation as the `<<` shifting operator!\n \n # Examples\n \n@@ -2327,7 +2270,7 @@ assert_eq!(n.rotate_left(\", $rot, \"), m);\n wrapping the truncated bits to the beginning of the resulting\n integer.\n \n-Please note this isn't the same operation as `>>`!\n+Please note this isn't the same operation as the `>>` shifting operator!\n \n # Examples\n \n@@ -2783,29 +2726,6 @@ the numeric bounds instead of overflowing.\n \n Basic usage:\n \n-```\n-\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n-assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n-```\"),\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            #[cfg(stage0)]\n-            pub fn saturating_add(self, rhs: Self) -> Self {\n-                match self.checked_add(rhs) {\n-                    Some(x) => x,\n-                    None => Self::max_value(),\n-                }\n-            }\n-        }\n-\n-        doc_comment! {\n-            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at\n-the numeric bounds instead of overflowing.\n-\n-# Examples\n-\n-Basic usage:\n-\n ```\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n@@ -2814,7 +2734,6 @@ assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n             #[inline]\n-            #[cfg(not(stage0))]\n             pub const fn saturating_add(self, rhs: Self) -> Self {\n                 intrinsics::saturating_add(self, rhs)\n             }\n@@ -2828,37 +2747,13 @@ at the numeric bounds instead of overflowing.\n \n Basic usage:\n \n-```\n-\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\n-assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\", $EndFeature, \"\n-```\"),\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            #[cfg(stage0)]\n-            pub fn saturating_sub(self, rhs: Self) -> Self {\n-                match self.checked_sub(rhs) {\n-                    Some(x) => x,\n-                    None => Self::min_value(),\n-                }\n-            }\n-        }\n-\n-        doc_comment! {\n-            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating\n-at the numeric bounds instead of overflowing.\n-\n-# Examples\n-\n-Basic usage:\n-\n ```\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\n assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n             #[inline]\n-            #[cfg(not(stage0))]\n             pub const fn saturating_sub(self, rhs: Self) -> Self {\n                 intrinsics::saturating_sub(self, rhs)\n             }\n@@ -3767,7 +3662,6 @@ assert_eq!(value, \", $swap_op, \");\n When starting from a slice rather than an array, fallible conversion APIs can be used:\n \n ```\n-#![feature(try_from)]\n use std::convert::TryInto;\n \n fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n@@ -3799,13 +3693,12 @@ assert_eq!(value, \", $swap_op, \");\n When starting from a slice rather than an array, fallible conversion APIs can be used:\n \n ```\n-#![feature(try_from)]\n use std::convert::TryInto;\n \n-fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n     let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n     *input = rest;\n-    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\n }\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n@@ -3841,13 +3734,12 @@ assert_eq!(value, \", $swap_op, \");\n When starting from a slice rather than an array, fallible conversion APIs can be used:\n \n ```\n-#![feature(try_from)]\n use std::convert::TryInto;\n \n-fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n     let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n     *input = rest;\n-    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\n }\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n@@ -4504,7 +4396,7 @@ macro_rules! from_str_radix_int_impl {\n from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n \n /// The error type returned when a checked integral type conversion fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub struct TryFromIntError(());\n \n@@ -4519,27 +4411,40 @@ impl TryFromIntError {\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl fmt::Display for TryFromIntError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         self.__description().fmt(fmt)\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl From<Infallible> for TryFromIntError {\n+    fn from(x: Infallible) -> TryFromIntError {\n+        match x {}\n+    }\n+}\n+\n+#[unstable(feature = \"never_type\", issue = \"35121\")]\n impl From<!> for TryFromIntError {\n     fn from(never: !) -> TryFromIntError {\n-        never\n+        // Match rather than coerce to make sure that code like\n+        // `From<Infallible> for TryFromIntError` above will keep working\n+        // when `Infallible` becomes an alias to `!`.\n+        match never {}\n     }\n }\n \n // no possible bounds violation\n macro_rules! try_from_unbounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n             #[inline]\n             fn try_from(value: $source) -> Result<Self, Self::Error> {\n                 Ok(value as $target)\n@@ -4551,10 +4456,13 @@ macro_rules! try_from_unbounded {\n // only negative bounds\n macro_rules! try_from_lower_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n             #[inline]\n             fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n                 if u >= 0 {\n@@ -4570,10 +4478,13 @@ macro_rules! try_from_lower_bounded {\n // unsigned to signed (only positive bound)\n macro_rules! try_from_upper_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n             #[inline]\n             fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n                 if u > (<$target>::max_value() as $source) {\n@@ -4589,10 +4500,13 @@ macro_rules! try_from_upper_bounded {\n // all other cases\n macro_rules! try_from_both_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n             #[inline]\n             fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n                 let min = <$target>::min_value() as $source;\n@@ -4613,7 +4527,7 @@ macro_rules! rev {\n     )*}\n }\n \n-/// intra-sign conversions\n+// intra-sign conversions\n try_from_upper_bounded!(u16, u8);\n try_from_upper_bounded!(u32, u16, u8);\n try_from_upper_bounded!(u64, u32, u16, u8);"}, {"sha": "9cd5108ade411ebc7f97838a0538bce608a51f07", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -429,7 +429,8 @@ assert_eq!(n.trailing_zeros(), 3);\n             /// wrapping the truncated bits to the end of the resulting\n             /// integer.\n             ///\n-            /// Please note this isn't the same operation as `>>`!\n+            /// Please note this isn't the same operation as the `>>` shifting\n+            /// operator!\n             ///\n             /// # Examples\n             ///\n@@ -454,7 +455,8 @@ assert_eq!(n.trailing_zeros(), 3);\n             /// wrapping the truncated bits to the beginning of the resulting\n             /// integer.\n             ///\n-            /// Please note this isn't the same operation as `<<`!\n+            /// Please note this isn't the same operation as the `<<` shifting\n+            /// operator!\n             ///\n             /// # Examples\n             ///"}, {"sha": "81a8d001dd9cb4237d256eb9b470c5ece38012c7", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -26,11 +26,13 @@ use hash::{Hash, Hasher};\n /// Used as a [slicing index], `RangeFull` produces the full array as a slice.\n ///\n /// ```\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ .. ], [0,1,2,3]);  // RangeFull\n-/// assert_eq!(arr[ ..3], [0,1,2  ]);\n-/// assert_eq!(arr[1.. ], [  1,2,3]);\n-/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);  // RangeFull\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n ///\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n@@ -60,11 +62,13 @@ impl fmt::Debug for RangeFull {\n /// assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n /// assert_eq!(3 + 4 + 5, (3..6).sum());\n ///\n-/// let arr = ['a', 'b', 'c', 'd'];\n-/// assert_eq!(arr[ .. ], ['a', 'b', 'c', 'd']);\n-/// assert_eq!(arr[ ..3], ['a', 'b', 'c',    ]);\n-/// assert_eq!(arr[1.. ], [     'b', 'c', 'd']);\n-/// assert_eq!(arr[1..3], [     'b', 'c'     ]);  // Range\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);  // Range\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n #[doc(alias = \"..\")]\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n@@ -160,11 +164,13 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n /// assert_eq!((2..), std::ops::RangeFrom { start: 2 });\n /// assert_eq!(2 + 3 + 4, (2..).take(3).sum());\n ///\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ .. ], [0,1,2,3]);\n-/// assert_eq!(arr[ ..3], [0,1,2  ]);\n-/// assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n-/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);  // RangeFrom\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n ///\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n@@ -240,11 +246,13 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n /// elements before the index indicated by `end`.\n ///\n /// ```\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ .. ], [0,1,2,3]);\n-/// assert_eq!(arr[ ..3], [0,1,2  ]);  // RangeTo\n-/// assert_eq!(arr[1.. ], [  1,2,3]);\n-/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);  // RangeTo\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n ///\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n@@ -312,9 +320,13 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// assert_eq!((3..=5), std::ops::RangeInclusive::new(3, 5));\n /// assert_eq!(3 + 4 + 5, (3..=5).sum());\n ///\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ ..=2], [0,1,2  ]);\n-/// assert_eq!(arr[1..=2], [  1,2  ]);  // RangeInclusive\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);  // RangeInclusive\n /// ```\n #[doc(alias = \"..=\")]\n #[derive(Clone)]  // not Copy -- see #27186\n@@ -569,9 +581,13 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// array elements up to and including the index indicated by `end`.\n ///\n /// ```\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ ..=2], [0,1,2  ]);  // RangeToInclusive\n-/// assert_eq!(arr[1..=2], [  1,2  ]);\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);  // RangeToInclusive\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n ///\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n@@ -676,7 +692,7 @@ pub enum Bound<T> {\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n /// `RangeBounds` is implemented by Rust's built-in range types, produced\n-/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n+/// by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.\n pub trait RangeBounds<T: ?Sized> {\n     /// Start index bound.\n     ///"}, {"sha": "46dfe28da622c451f8e4c3fe9fa54d927e151227", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1286,7 +1286,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// # Examples\n     ///\n     /// Here is an example which increments every integer in a vector.\n-    /// `We use the checked variant of `add` that returns `None` when the\n+    /// We use the checked variant of `add` that returns `None` when the\n     /// calculation would result in an overflow.\n     ///\n     /// ```"}, {"sha": "fb78f5e5a238424764e7460bbbdc450d6dd7e7a1", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -215,7 +215,7 @@\n //!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n //!     Then we could do the following:\n //!     ```compile_fail\n-//!     fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>) {\n+//!     fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>>) {\n //!         { let p = rc.as_mut().get_pin_mut(); } // Here we get pinned access to the `T`.\n //!         let rc_shr: &RefCell<T> = rc.into_ref().get_ref();\n //!         let b = rc_shr.borrow_mut();\n@@ -279,7 +279,7 @@ use ops::{Deref, DerefMut, Receiver, CoerceUnsized, DispatchFromDyn};\n // implementations, are allowed because they all only use `&P`, so they cannot move\n // the value behind `pointer`.\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-#[cfg_attr(not(stage0), lang = \"pin\")]\n+#[lang = \"pin\"]\n #[fundamental]\n #[repr(transparent)]\n #[derive(Copy, Clone, Hash, Eq, Ord)]"}, {"sha": "a9a029d606d6f84315931b1b69381dfe663c1de4", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -301,7 +301,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Perform the swap\n     copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n     copy(y, x, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping(tmp.get_ref(), y, 1);\n+    copy_nonoverlapping(tmp.as_ptr(), y, 1);\n }\n \n /// Swaps `count * size_of::<T>()` bytes between the two regions of memory\n@@ -2790,7 +2790,7 @@ impl<T: ?Sized> Unique<T> {\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n-    pub fn as_ptr(self) -> *mut T {\n+    pub const fn as_ptr(self) -> *mut T {\n         self.pointer as *mut T\n     }\n \n@@ -2837,15 +2837,15 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<'a, T: ?Sized> From<&'a mut T> for Unique<T> {\n-    fn from(reference: &'a mut T) -> Self {\n+impl<T: ?Sized> From<&mut T> for Unique<T> {\n+    fn from(reference: &mut T) -> Self {\n         unsafe { Unique { pointer: reference as *mut T, _marker: PhantomData } }\n     }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<'a, T: ?Sized> From<&'a T> for Unique<T> {\n-    fn from(reference: &'a T) -> Self {\n+impl<T: ?Sized> From<&T> for Unique<T> {\n+    fn from(reference: &T) -> Self {\n         unsafe { Unique { pointer: reference as *const T, _marker: PhantomData } }\n     }\n }\n@@ -2874,6 +2874,16 @@ impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n /// Usually this won't be necessary; covariance is correct for most safe abstractions,\n /// such as Box, Rc, Arc, Vec, and LinkedList. This is the case because they\n /// provide a public API that follows the normal shared XOR mutable rules of Rust.\n+///\n+/// Notice that `NonNull<T>` has a `From` instance for `&T`. However, this does\n+/// not change the fact that mutating through a (pointer derived from a) shared\n+/// reference is undefined behavior unless the mutation happens inside an\n+/// [`UnsafeCell<T>`]. The same goes for creating a mutable reference from a shared\n+/// reference. When using this `From` instance without an `UnsafeCell<T>`,\n+/// it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`\n+/// is never used for mutation.\n+///\n+/// [`UnsafeCell<T>`]: ../cell/struct.UnsafeCell.html\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n #[repr(transparent)]\n #[rustc_layout_scalar_valid_range_start(1)]\n@@ -2903,7 +2913,8 @@ impl<T: Sized> NonNull<T> {\n     /// some other means.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n-    pub fn dangling() -> Self {\n+    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_ptr_nonnull\"))]\n+    pub const fn dangling() -> Self {\n         unsafe {\n             let ptr = mem::align_of::<T>() as *mut T;\n             NonNull::new_unchecked(ptr)\n@@ -2966,7 +2977,8 @@ impl<T: ?Sized> NonNull<T> {\n     /// Cast to a pointer of another type\n     #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n     #[inline]\n-    pub fn cast<U>(self) -> NonNull<U> {\n+    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_ptr_nonnull\"))]\n+    pub const fn cast<U>(self) -> NonNull<U> {\n         unsafe {\n             NonNull::new_unchecked(self.as_ptr() as *mut U)\n         }\n@@ -3047,17 +3059,17 @@ impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<'a, T: ?Sized> From<&'a mut T> for NonNull<T> {\n+impl<T: ?Sized> From<&mut T> for NonNull<T> {\n     #[inline]\n-    fn from(reference: &'a mut T) -> Self {\n+    fn from(reference: &mut T) -> Self {\n         unsafe { NonNull { pointer: reference as *mut T } }\n     }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<'a, T: ?Sized> From<&'a T> for NonNull<T> {\n+impl<T: ?Sized> From<&T> for NonNull<T> {\n     #[inline]\n-    fn from(reference: &'a T) -> Self {\n+    fn from(reference: &T) -> Self {\n         unsafe { NonNull { pointer: reference as *const T } }\n     }\n }"}, {"sha": "2bd6b536301e8de10241cbbbf0e74a7b2777ad8a", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1200,7 +1200,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|x: &u32|\n     ///     x.checked_add(1).ok_or(\"Overflow!\")\n     /// ).collect();\n-    /// assert!(res == Ok(vec![2, 3]));\n+    /// assert_eq!(res, Ok(vec![2, 3]));\n     /// ```\n     #[inline]\n     fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {"}, {"sha": "b3594f8a3858aec27cc66408fa1bb8ae41fe523f", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -3288,6 +3288,34 @@ impl<'a, T> IterMut<'a, T> {\n     pub fn into_slice(self) -> &'a mut [T] {\n         unsafe { from_raw_parts_mut(self.ptr, len!(self)) }\n     }\n+\n+    /// Views the underlying data as a subslice of the original data.\n+    ///\n+    /// To avoid creating `&mut [T]` references that alias, the returned slice\n+    /// borrows its lifetime from the iterator the method is applied on.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// # #![feature(slice_iter_mut_as_slice)]\n+    /// let mut slice: &mut [usize] = &mut [1, 2, 3];\n+    ///\n+    /// // First, we get the iterator:\n+    /// let mut iter = slice.iter_mut();\n+    /// // So if we check what the `as_slice` method returns here, we have \"[1, 2, 3]\":\n+    /// assert_eq!(iter.as_slice(), &[1, 2, 3]);\n+    ///\n+    /// // Next, we move to the second element of the slice:\n+    /// iter.next();\n+    /// // Now `as_slice` returns \"[2, 3]\":\n+    /// assert_eq!(iter.as_slice(), &[2, 3]);\n+    /// ```\n+    #[unstable(feature = \"slice_iter_mut_as_slice\", reason = \"recently added\", issue = \"58957\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        self.make_slice()\n+    }\n }\n \n iterator!{struct IterMut -> *mut T, &'a mut T, mut, {mut}, {}}"}, {"sha": "53334adadb856d83a4888393c5fc00a5663a0a0d", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -3965,7 +3965,7 @@ impl str {\n         me.make_ascii_lowercase()\n     }\n \n-    /// Return an iterator that escapes each char in `s` with [`char::escape_debug`].\n+    /// Return an iterator that escapes each char in `self` with [`char::escape_debug`].\n     ///\n     /// Note: only extended grapheme codepoints that begin the string will be\n     /// escaped.\n@@ -4013,7 +4013,7 @@ impl str {\n         }\n     }\n \n-    /// Return an iterator that escapes each char in `s` with [`char::escape_default`].\n+    /// Return an iterator that escapes each char in `self` with [`char::escape_default`].\n     ///\n     /// [`char::escape_default`]: ../std/primitive.char.html#method.escape_default\n     ///\n@@ -4051,7 +4051,7 @@ impl str {\n         EscapeDefault { inner: self.chars().flat_map(CharEscapeDefault) }\n     }\n \n-    /// Return an iterator that escapes each char in `s` with [`char::escape_unicode`].\n+    /// Return an iterator that escapes each char in `self` with [`char::escape_unicode`].\n     ///\n     /// [`char::escape_unicode`]: ../std/primitive.char.html#method.escape_unicode\n     ///"}, {"sha": "04a49d253015f439913b542367db8a5a02cdff3a", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -290,15 +290,11 @@ pub enum Ordering {\n /// [`AtomicBool`]: struct.AtomicBool.html\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(not(stage0), rustc_deprecated(\n+#[rustc_deprecated(\n     since = \"1.34.0\",\n     reason = \"the `new` function is now preferred\",\n     suggestion = \"AtomicBool::new(false)\",\n-))]\n-#[cfg_attr(stage0, rustc_deprecated(\n-    since = \"1.34.0\",\n-    reason = \"the `new` function is now preferred\",\n-))]\n+)]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n \n #[cfg(target_has_atomic = \"8\")]\n@@ -1158,15 +1154,11 @@ macro_rules! atomic_int {\n \n         /// An atomic integer initialized to `0`.\n         #[$stable_init_const]\n-        #[cfg_attr(stage0, rustc_deprecated(\n-            since = \"1.34.0\",\n-            reason = \"the `new` function is now preferred\",\n-        ))]\n-        #[cfg_attr(not(stage0), rustc_deprecated(\n+        #[rustc_deprecated(\n             since = \"1.34.0\",\n             reason = \"the `new` function is now preferred\",\n             suggestion = $atomic_new,\n-        ))]\n+        )]\n         pub const $atomic_init: $atomic_type = $atomic_type::new(0);\n \n         #[$stable]"}, {"sha": "10fcf8b76ccb4bd7c8e47a8d842bcd03feecc678", "filename": "src/libcore/tests/fmt/num.rs", "status": "modified", "additions": 118, "deletions": 118, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -3,146 +3,146 @@ fn test_format_int() {\n     // Formatting integers should select the right implementation based off\n     // the type of the argument. Also, hex/octal/binary should be defined\n     // for integers, but they shouldn't emit the negative sign.\n-    assert!(format!(\"{}\", 1isize) == \"1\");\n-    assert!(format!(\"{}\", 1i8) == \"1\");\n-    assert!(format!(\"{}\", 1i16) == \"1\");\n-    assert!(format!(\"{}\", 1i32) == \"1\");\n-    assert!(format!(\"{}\", 1i64) == \"1\");\n-    assert!(format!(\"{}\", -1isize) == \"-1\");\n-    assert!(format!(\"{}\", -1i8) == \"-1\");\n-    assert!(format!(\"{}\", -1i16) == \"-1\");\n-    assert!(format!(\"{}\", -1i32) == \"-1\");\n-    assert!(format!(\"{}\", -1i64) == \"-1\");\n-    assert!(format!(\"{:?}\", 1isize) == \"1\");\n-    assert!(format!(\"{:?}\", 1i8) == \"1\");\n-    assert!(format!(\"{:?}\", 1i16) == \"1\");\n-    assert!(format!(\"{:?}\", 1i32) == \"1\");\n-    assert!(format!(\"{:?}\", 1i64) == \"1\");\n-    assert!(format!(\"{:b}\", 1isize) == \"1\");\n-    assert!(format!(\"{:b}\", 1i8) == \"1\");\n-    assert!(format!(\"{:b}\", 1i16) == \"1\");\n-    assert!(format!(\"{:b}\", 1i32) == \"1\");\n-    assert!(format!(\"{:b}\", 1i64) == \"1\");\n-    assert!(format!(\"{:x}\", 1isize) == \"1\");\n-    assert!(format!(\"{:x}\", 1i8) == \"1\");\n-    assert!(format!(\"{:x}\", 1i16) == \"1\");\n-    assert!(format!(\"{:x}\", 1i32) == \"1\");\n-    assert!(format!(\"{:x}\", 1i64) == \"1\");\n-    assert!(format!(\"{:X}\", 1isize) == \"1\");\n-    assert!(format!(\"{:X}\", 1i8) == \"1\");\n-    assert!(format!(\"{:X}\", 1i16) == \"1\");\n-    assert!(format!(\"{:X}\", 1i32) == \"1\");\n-    assert!(format!(\"{:X}\", 1i64) == \"1\");\n-    assert!(format!(\"{:o}\", 1isize) == \"1\");\n-    assert!(format!(\"{:o}\", 1i8) == \"1\");\n-    assert!(format!(\"{:o}\", 1i16) == \"1\");\n-    assert!(format!(\"{:o}\", 1i32) == \"1\");\n-    assert!(format!(\"{:o}\", 1i64) == \"1\");\n+    assert_eq!(format!(\"{}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{}\", -1isize), \"-1\");\n+    assert_eq!(format!(\"{}\", -1i8), \"-1\");\n+    assert_eq!(format!(\"{}\", -1i16), \"-1\");\n+    assert_eq!(format!(\"{}\", -1i32), \"-1\");\n+    assert_eq!(format!(\"{}\", -1i64), \"-1\");\n+    assert_eq!(format!(\"{:?}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1i64), \"1\");\n \n-    assert!(format!(\"{}\", 1usize) == \"1\");\n-    assert!(format!(\"{}\", 1u8) == \"1\");\n-    assert!(format!(\"{}\", 1u16) == \"1\");\n-    assert!(format!(\"{}\", 1u32) == \"1\");\n-    assert!(format!(\"{}\", 1u64) == \"1\");\n-    assert!(format!(\"{:?}\", 1usize) == \"1\");\n-    assert!(format!(\"{:?}\", 1u8) == \"1\");\n-    assert!(format!(\"{:?}\", 1u16) == \"1\");\n-    assert!(format!(\"{:?}\", 1u32) == \"1\");\n-    assert!(format!(\"{:?}\", 1u64) == \"1\");\n-    assert!(format!(\"{:b}\", 1usize) == \"1\");\n-    assert!(format!(\"{:b}\", 1u8) == \"1\");\n-    assert!(format!(\"{:b}\", 1u16) == \"1\");\n-    assert!(format!(\"{:b}\", 1u32) == \"1\");\n-    assert!(format!(\"{:b}\", 1u64) == \"1\");\n-    assert!(format!(\"{:x}\", 1usize) == \"1\");\n-    assert!(format!(\"{:x}\", 1u8) == \"1\");\n-    assert!(format!(\"{:x}\", 1u16) == \"1\");\n-    assert!(format!(\"{:x}\", 1u32) == \"1\");\n-    assert!(format!(\"{:x}\", 1u64) == \"1\");\n-    assert!(format!(\"{:X}\", 1usize) == \"1\");\n-    assert!(format!(\"{:X}\", 1u8) == \"1\");\n-    assert!(format!(\"{:X}\", 1u16) == \"1\");\n-    assert!(format!(\"{:X}\", 1u32) == \"1\");\n-    assert!(format!(\"{:X}\", 1u64) == \"1\");\n-    assert!(format!(\"{:o}\", 1usize) == \"1\");\n-    assert!(format!(\"{:o}\", 1u8) == \"1\");\n-    assert!(format!(\"{:o}\", 1u16) == \"1\");\n-    assert!(format!(\"{:o}\", 1u32) == \"1\");\n-    assert!(format!(\"{:o}\", 1u64) == \"1\");\n+    assert_eq!(format!(\"{}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1u64), \"1\");\n \n     // Test a larger number\n-    assert!(format!(\"{:b}\", 55) == \"110111\");\n-    assert!(format!(\"{:o}\", 55) == \"67\");\n-    assert!(format!(\"{}\", 55) == \"55\");\n-    assert!(format!(\"{:x}\", 55) == \"37\");\n-    assert!(format!(\"{:X}\", 55) == \"37\");\n+    assert_eq!(format!(\"{:b}\", 55), \"110111\");\n+    assert_eq!(format!(\"{:o}\", 55), \"67\");\n+    assert_eq!(format!(\"{}\", 55), \"55\");\n+    assert_eq!(format!(\"{:x}\", 55), \"37\");\n+    assert_eq!(format!(\"{:X}\", 55), \"37\");\n }\n \n #[test]\n fn test_format_int_zero() {\n-    assert!(format!(\"{}\", 0) == \"0\");\n-    assert!(format!(\"{:?}\", 0) == \"0\");\n-    assert!(format!(\"{:b}\", 0) == \"0\");\n-    assert!(format!(\"{:o}\", 0) == \"0\");\n-    assert!(format!(\"{:x}\", 0) == \"0\");\n-    assert!(format!(\"{:X}\", 0) == \"0\");\n+    assert_eq!(format!(\"{}\", 0), \"0\");\n+    assert_eq!(format!(\"{:?}\", 0), \"0\");\n+    assert_eq!(format!(\"{:b}\", 0), \"0\");\n+    assert_eq!(format!(\"{:o}\", 0), \"0\");\n+    assert_eq!(format!(\"{:x}\", 0), \"0\");\n+    assert_eq!(format!(\"{:X}\", 0), \"0\");\n \n-    assert!(format!(\"{}\", 0u32) == \"0\");\n-    assert!(format!(\"{:?}\", 0u32) == \"0\");\n-    assert!(format!(\"{:b}\", 0u32) == \"0\");\n-    assert!(format!(\"{:o}\", 0u32) == \"0\");\n-    assert!(format!(\"{:x}\", 0u32) == \"0\");\n-    assert!(format!(\"{:X}\", 0u32) == \"0\");\n+    assert_eq!(format!(\"{}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:?}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:b}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:o}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:x}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:X}\", 0u32), \"0\");\n }\n \n #[test]\n fn test_format_int_flags() {\n-    assert!(format!(\"{:3}\", 1) == \"  1\");\n-    assert!(format!(\"{:>3}\", 1) == \"  1\");\n-    assert!(format!(\"{:>+3}\", 1) == \" +1\");\n-    assert!(format!(\"{:<3}\", 1) == \"1  \");\n-    assert!(format!(\"{:#}\", 1) == \"1\");\n-    assert!(format!(\"{:#x}\", 10) == \"0xa\");\n-    assert!(format!(\"{:#X}\", 10) == \"0xA\");\n-    assert!(format!(\"{:#5x}\", 10) == \"  0xa\");\n-    assert!(format!(\"{:#o}\", 10) == \"0o12\");\n-    assert!(format!(\"{:08x}\", 10) == \"0000000a\");\n-    assert!(format!(\"{:8x}\", 10) == \"       a\");\n-    assert!(format!(\"{:<8x}\", 10) == \"a       \");\n-    assert!(format!(\"{:>8x}\", 10) == \"       a\");\n-    assert!(format!(\"{:#08x}\", 10) == \"0x00000a\");\n-    assert!(format!(\"{:08}\", -10) == \"-0000010\");\n-    assert!(format!(\"{:x}\", !0u8) == \"ff\");\n-    assert!(format!(\"{:X}\", !0u8) == \"FF\");\n-    assert!(format!(\"{:b}\", !0u8) == \"11111111\");\n-    assert!(format!(\"{:o}\", !0u8) == \"377\");\n-    assert!(format!(\"{:#x}\", !0u8) == \"0xff\");\n-    assert!(format!(\"{:#X}\", !0u8) == \"0xFF\");\n-    assert!(format!(\"{:#b}\", !0u8) == \"0b11111111\");\n-    assert!(format!(\"{:#o}\", !0u8) == \"0o377\");\n+    assert_eq!(format!(\"{:3}\", 1), \"  1\");\n+    assert_eq!(format!(\"{:>3}\", 1), \"  1\");\n+    assert_eq!(format!(\"{:>+3}\", 1), \" +1\");\n+    assert_eq!(format!(\"{:<3}\", 1), \"1  \");\n+    assert_eq!(format!(\"{:#}\", 1), \"1\");\n+    assert_eq!(format!(\"{:#x}\", 10), \"0xa\");\n+    assert_eq!(format!(\"{:#X}\", 10), \"0xA\");\n+    assert_eq!(format!(\"{:#5x}\", 10), \"  0xa\");\n+    assert_eq!(format!(\"{:#o}\", 10), \"0o12\");\n+    assert_eq!(format!(\"{:08x}\", 10), \"0000000a\");\n+    assert_eq!(format!(\"{:8x}\", 10), \"       a\");\n+    assert_eq!(format!(\"{:<8x}\", 10), \"a       \");\n+    assert_eq!(format!(\"{:>8x}\", 10), \"       a\");\n+    assert_eq!(format!(\"{:#08x}\", 10), \"0x00000a\");\n+    assert_eq!(format!(\"{:08}\", -10), \"-0000010\");\n+    assert_eq!(format!(\"{:x}\", !0u8), \"ff\");\n+    assert_eq!(format!(\"{:X}\", !0u8), \"FF\");\n+    assert_eq!(format!(\"{:b}\", !0u8), \"11111111\");\n+    assert_eq!(format!(\"{:o}\", !0u8), \"377\");\n+    assert_eq!(format!(\"{:#x}\", !0u8), \"0xff\");\n+    assert_eq!(format!(\"{:#X}\", !0u8), \"0xFF\");\n+    assert_eq!(format!(\"{:#b}\", !0u8), \"0b11111111\");\n+    assert_eq!(format!(\"{:#o}\", !0u8), \"0o377\");\n }\n \n #[test]\n fn test_format_int_sign_padding() {\n-    assert!(format!(\"{:+5}\", 1) == \"   +1\");\n-    assert!(format!(\"{:+5}\", -1) == \"   -1\");\n-    assert!(format!(\"{:05}\", 1) == \"00001\");\n-    assert!(format!(\"{:05}\", -1) == \"-0001\");\n-    assert!(format!(\"{:+05}\", 1) == \"+0001\");\n-    assert!(format!(\"{:+05}\", -1) == \"-0001\");\n+    assert_eq!(format!(\"{:+5}\", 1), \"   +1\");\n+    assert_eq!(format!(\"{:+5}\", -1), \"   -1\");\n+    assert_eq!(format!(\"{:05}\", 1), \"00001\");\n+    assert_eq!(format!(\"{:05}\", -1), \"-0001\");\n+    assert_eq!(format!(\"{:+05}\", 1), \"+0001\");\n+    assert_eq!(format!(\"{:+05}\", -1), \"-0001\");\n }\n \n #[test]\n fn test_format_int_twos_complement() {\n-    use core::{i8, i16, i32, i64};\n-    assert!(format!(\"{}\", i8::MIN) == \"-128\");\n-    assert!(format!(\"{}\", i16::MIN) == \"-32768\");\n-    assert!(format!(\"{}\", i32::MIN) == \"-2147483648\");\n-    assert!(format!(\"{}\", i64::MIN) == \"-9223372036854775808\");\n+    use core::{i16, i32, i64, i8};\n+    assert_eq!(format!(\"{}\", i8::MIN), \"-128\");\n+    assert_eq!(format!(\"{}\", i16::MIN), \"-32768\");\n+    assert_eq!(format!(\"{}\", i32::MIN), \"-2147483648\");\n+    assert_eq!(format!(\"{}\", i64::MIN), \"-9223372036854775808\");\n }\n \n #[test]\n fn test_format_debug_hex() {\n-    assert!(format!(\"{:02x?}\", b\"Foo\\0\") == \"[46, 6f, 6f, 00]\");\n-    assert!(format!(\"{:02X?}\", b\"Foo\\0\") == \"[46, 6F, 6F, 00]\");\n+    assert_eq!(format!(\"{:02x?}\", b\"Foo\\0\"), \"[46, 6f, 6f, 00]\");\n+    assert_eq!(format!(\"{:02X?}\", b\"Foo\\0\"), \"[46, 6F, 6F, 00]\");\n }"}, {"sha": "a9db9b35d8d80e3be984a78d7b385d7243b48e98", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1082,12 +1082,39 @@ fn test_iterator_product_result() {\n     assert_eq!(v.iter().cloned().product::<Result<i32, _>>(), Err(()));\n }\n \n+/// A wrapper struct that implements `Eq` and `Ord` based on the wrapped\n+/// integer modulo 3. Used to test that `Iterator::max` and `Iterator::min`\n+/// return the correct element if some of them are equal.\n+#[derive(Debug)]\n+struct Mod3(i32);\n+\n+impl PartialEq for Mod3 {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0 % 3 == other.0 % 3\n+    }\n+}\n+\n+impl Eq for Mod3 {}\n+\n+impl PartialOrd for Mod3 {\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Mod3 {\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        (self.0 % 3).cmp(&(other.0 % 3))\n+    }\n+}\n+\n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(v[..4].iter().cloned().max(), Some(3));\n     assert_eq!(v.iter().cloned().max(), Some(10));\n     assert_eq!(v[..0].iter().cloned().max(), None);\n+    assert_eq!(v.iter().cloned().map(Mod3).max().map(|x| x.0), Some(8));\n }\n \n #[test]\n@@ -1096,6 +1123,7 @@ fn test_iterator_min() {\n     assert_eq!(v[..4].iter().cloned().min(), Some(0));\n     assert_eq!(v.iter().cloned().min(), Some(0));\n     assert_eq!(v[..0].iter().cloned().min(), None);\n+    assert_eq!(v.iter().cloned().map(Mod3).min().map(|x| x.0), Some(0));\n }\n \n #[test]"}, {"sha": "d0021376389772ee42e118508b980bb8942fe495", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -26,7 +26,6 @@\n #![feature(str_internals)]\n #![feature(test)]\n #![feature(trusted_len)]\n-#![feature(try_from)]\n #![feature(try_trait)]\n #![feature(align_offset)]\n #![feature(reverse_bits)]"}, {"sha": "31e10c19c7a60599351cd664673d9cb8f0fa60dd", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -17,13 +17,14 @@ graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n lazy_static = \"1.0.0\"\n num_cpus = \"1.0\"\n-scoped-tls = { version = \"0.1.1\", features = [\"nightly\"] }\n+scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n polonius-engine = \"0.6.2\"\n-rustc-rayon = \"0.1.1\"\n-rustc-rayon-core = \"0.1.1\"\n+rustc-rayon = \"0.1.2\"\n+rustc-rayon-core = \"0.1.2\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "e96709f6d14e5bd57b373786582ab9b6034715dc", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -398,7 +398,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             args: I) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        let m = self.tcx.hir().get_module_parent(call_expr.id);\n+        let m = self.tcx.hir().get_module_parent_by_hir_id(call_expr.hir_id);\n         if self.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(call_expr)) {\n             self.add_unreachable_node()\n         } else {\n@@ -571,9 +571,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match destination.target_id {\n             Ok(loop_id) => {\n                 for b in &self.breakable_block_scopes {\n-                    if b.block_expr_id == self.tcx.hir().node_to_hir_id(loop_id).local_id {\n+                    if b.block_expr_id == loop_id.local_id {\n                         let scope = region::Scope {\n-                            id: self.tcx.hir().node_to_hir_id(loop_id).local_id,\n+                            id: loop_id.local_id,\n                             data: region::ScopeData::Node\n                         };\n                         return (scope, match scope_cf_kind {\n@@ -583,9 +583,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     }\n                 }\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == self.tcx.hir().node_to_hir_id(loop_id).local_id {\n+                    if l.loop_id == loop_id.local_id {\n                         let scope = region::Scope {\n-                            id: self.tcx.hir().node_to_hir_id(loop_id).local_id,\n+                            id: loop_id.local_id,\n                             data: region::ScopeData::Node\n                         };\n                         return (scope, match scope_cf_kind {"}, {"sha": "41a4a8031006f9d6ee354e6611a0ac7f92cbed0b", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -67,7 +67,7 @@ use crate::traits::query::{\n };\n use crate::ty::{TyCtxt, FnSig, Instance, InstanceDef,\n          ParamEnv, ParamEnvAnd, Predicate, PolyFnSig, PolyTraitRef, Ty};\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::SubstsRef;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e., which sub-expression of the macro we are in) but don't need\n@@ -456,6 +456,8 @@ define_dep_nodes!( <'tcx>\n     [eval_always] CoherenceInherentImplOverlapCheck,\n     [] CoherenceCheckTrait(DefId),\n     [eval_always] PrivacyAccessLevels(CrateNum),\n+    [eval_always] CheckPrivateInPublic(CrateNum),\n+    [eval_always] Analysis(CrateNum),\n \n     // Represents the MIR for a fn; also used as the task node for\n     // things read/modify that MIR.\n@@ -661,7 +663,7 @@ define_dep_nodes!( <'tcx>\n     [] TypeOpNormalizePolyFnSig(CanonicalTypeOpNormalizeGoal<'tcx, PolyFnSig<'tcx>>),\n     [] TypeOpNormalizeFnSig(CanonicalTypeOpNormalizeGoal<'tcx, FnSig<'tcx>>),\n \n-    [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n+    [] SubstituteNormalizeAndTestPredicates { key: (DefId, SubstsRef<'tcx>) },\n     [] MethodAutoderefSteps(CanonicalTyGoal<'tcx>),\n \n     [input] TargetFeaturesWhitelist,"}, {"sha": "86f7e149964883d0b410dd039dcd1b1058759dc7", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     /// Checks any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.id));\n+            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n         } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(\"target_feature\")) {\n             self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n                 .span_label(item.span, \"not a function\")\n@@ -344,12 +344,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckAttrVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_attrs(tcx.hir().local_def_id(module));\n-    }\n-}\n-\n fn is_c_like_enum(item: &hir::Item) -> bool {\n     if let hir::ItemKind::Enum(ref def, _) = item.node {\n         for variant in &def.variants {"}, {"sha": "b45fc3ffd82fe0118ba89baaa58db033ba234392", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -3,12 +3,13 @@ use crate::util::nodemap::{NodeMap, DefIdMap};\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax_pos::Span;\n+use rustc_macros::HashStable;\n use crate::hir;\n use crate::ty;\n \n use self::Namespace::*;\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum CtorKind {\n     /// Constructor function automatically created by a tuple struct/variant.\n     Fn,\n@@ -18,7 +19,7 @@ pub enum CtorKind {\n     Fictive,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum NonMacroAttrKind {\n     /// Single-segment attribute defined by the language (`#[inline]`)\n     Builtin,\n@@ -32,7 +33,7 @@ pub enum NonMacroAttrKind {\n     Custom,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum Def {\n     // Type namespace\n     Mod(DefId),\n@@ -209,7 +210,7 @@ pub type ExportMap = DefIdMap<Vec<Export>>;\n /// namespace.\n pub type ImportMap = NodeMap<PerNS<Option<PathResolution>>>;\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Export {\n     /// The name of the target.\n     pub ident: ast::Ident,"}, {"sha": "977830315e23e893c74ea3dc240800bfcad33817", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -34,7 +34,6 @@\n use syntax::ast::{Ident, Name, Attribute};\n use syntax_pos::Span;\n use crate::hir::*;\n-use crate::hir::def::Def;\n use crate::hir::map::Map;\n use super::itemlikevisit::DeepVisitor;\n \n@@ -228,9 +227,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_id(&mut self, _hir_id: HirId) {\n         // Nothing to do.\n     }\n-    fn visit_def_mention(&mut self, _def: Def) {\n-        // Nothing to do.\n-    }\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n@@ -494,13 +490,10 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n-        ItemKind::Existential(ExistTy {ref generics, ref bounds, impl_trait_fn}) => {\n+        ItemKind::Existential(ExistTy { ref generics, ref bounds, impl_trait_fn: _ }) => {\n             visitor.visit_id(item.hir_id);\n             walk_generics(visitor, generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n-            if let Some(impl_trait_fn) = impl_trait_fn {\n-                visitor.visit_def_mention(Def::Fn(impl_trait_fn))\n-            }\n         }\n         ItemKind::Enum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n@@ -617,6 +610,9 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyKind::Typeof(ref expression) => {\n             visitor.visit_anon_const(expression)\n         }\n+        TyKind::CVarArgs(ref lt) => {\n+            visitor.visit_lifetime(lt)\n+        }\n         TyKind::Infer | TyKind::Err => {}\n     }\n }\n@@ -637,7 +633,6 @@ pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath, id: Hir\n }\n \n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n-    visitor.visit_def_mention(path.def);\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n     }\n@@ -694,8 +689,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatKind::Binding(_, canonical_id, _hir_id, ident, ref optional_subpattern) => {\n-            visitor.visit_def_mention(Def::Local(canonical_id));\n+        PatKind::Binding(_, _hir_id, ident, ref optional_subpattern) => {\n             visitor.visit_ident(ident);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n@@ -875,7 +869,6 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItem {\n-        id: _,\n         hir_id: _,\n         ident,\n         ref vis,\n@@ -1062,18 +1055,12 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprKind::Break(ref destination, ref opt_expr) => {\n             if let Some(ref label) = destination.label {\n                 visitor.visit_label(label);\n-                if let Ok(node_id) = destination.target_id {\n-                    visitor.visit_def_mention(Def::Label(node_id))\n-                }\n             }\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n         ExprKind::Continue(ref destination) => {\n             if let Some(ref label) = destination.label {\n                 visitor.visit_label(label);\n-                if let Ok(node_id) = destination.target_id {\n-                    visitor.visit_def_mention(Def::Label(node_id))\n-                }\n             }\n         }\n         ExprKind::Ret(ref optional_expression) => {\n@@ -1103,7 +1090,7 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n }\n \n pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n-    if let VisibilityKind::Restricted { ref path, id: _, hir_id } = vis.node {\n+    if let VisibilityKind::Restricted { ref path, hir_id } = vis.node {\n         visitor.visit_id(hir_id);\n         visitor.visit_path(path, hir_id)\n     }"}, {"sha": "949fdd2682b96dfcc62d328f26b4af63ddc83560", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 121, "deletions": 177, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -74,7 +74,7 @@ const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n \n-    // Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n+    /// Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n     sess: &'a Session,\n \n     cstore: &'a dyn CrateStore,\n@@ -107,25 +107,25 @@ pub struct LoweringContext<'a> {\n     /// written at all (e.g., `&T` or `std::cell::Ref<T>`).\n     anonymous_lifetime_mode: AnonymousLifetimeMode,\n \n-    // Used to create lifetime definitions from in-band lifetime usages.\n-    // e.g., `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n-    // When a named lifetime is encountered in a function or impl header and\n-    // has not been defined\n-    // (i.e., it doesn't appear in the in_scope_lifetimes list), it is added\n-    // to this list. The results of this list are then added to the list of\n-    // lifetime definitions in the corresponding impl or function generics.\n+    /// Used to create lifetime definitions from in-band lifetime usages.\n+    /// e.g., `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n+    /// When a named lifetime is encountered in a function or impl header and\n+    /// has not been defined\n+    /// (i.e., it doesn't appear in the in_scope_lifetimes list), it is added\n+    /// to this list. The results of this list are then added to the list of\n+    /// lifetime definitions in the corresponding impl or function generics.\n     lifetimes_to_define: Vec<(Span, ParamName)>,\n \n-    // Whether or not in-band lifetimes are being collected. This is used to\n-    // indicate whether or not we're in a place where new lifetimes will result\n-    // in in-band lifetime definitions, such a function or an impl header,\n-    // including implicit lifetimes from `impl_header_lifetime_elision`.\n+    /// Whether or not in-band lifetimes are being collected. This is used to\n+    /// indicate whether or not we're in a place where new lifetimes will result\n+    /// in in-band lifetime definitions, such a function or an impl header,\n+    /// including implicit lifetimes from `impl_header_lifetime_elision`.\n     is_collecting_in_band_lifetimes: bool,\n \n-    // Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n-    // When `is_collectin_in_band_lifetimes` is true, each lifetime is checked\n-    // against this list to see if it is already in-scope, or if a definition\n-    // needs to be created for it.\n+    /// Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n+    /// When `is_collectin_in_band_lifetimes` is true, each lifetime is checked\n+    /// against this list to see if it is already in-scope, or if a definition\n+    /// needs to be created for it.\n     in_scope_lifetimes: Vec<Ident>,\n \n     current_module: NodeId,\n@@ -469,8 +469,8 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_trait_item(&mut self, item: &'lcx TraitItem) {\n                 self.lctx.with_hir_id_owner(item.id, |lctx| {\n-                    let id = hir::TraitItemId { node_id: item.id };\n                     let hir_item = lctx.lower_trait_item(item);\n+                    let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n                     lctx.trait_items.insert(id, hir_item);\n                     lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n                 });\n@@ -480,8 +480,8 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_impl_item(&mut self, item: &'lcx ImplItem) {\n                 self.lctx.with_hir_id_owner(item.id, |lctx| {\n-                    let id = hir::ImplItemId { node_id: item.id };\n                     let hir_item = lctx.lower_impl_item(item);\n+                    let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n                     lctx.impl_items.insert(id, hir_item);\n                     lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n                 });\n@@ -780,7 +780,6 @@ impl<'a> LoweringContext<'a> {\n                 );\n \n                 hir::GenericParam {\n-                    id: node_id,\n                     hir_id,\n                     name: hir_name,\n                     attrs: hir_vec![],\n@@ -955,7 +954,7 @@ impl<'a> LoweringContext<'a> {\n         let decl = FnDecl {\n             inputs: vec![],\n             output,\n-            variadic: false\n+            c_variadic: false\n         };\n         let body_id = self.record_body(body_expr, Some(&decl));\n         self.is_generator = prev_is_generator;\n@@ -964,7 +963,6 @@ impl<'a> LoweringContext<'a> {\n         let closure_hir_id = self.lower_node_id(closure_node_id).hir_id;\n         let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, None);\n         let generator = hir::Expr {\n-            id: closure_node_id,\n             hir_id: closure_hir_id,\n             node: hir::ExprKind::Closure(capture_clause, decl, body_id, span,\n                 Some(hir::GeneratorMovability::Static)),\n@@ -1070,7 +1068,7 @@ impl<'a> LoweringContext<'a> {\n         let target_id = match destination {\n             Some((id, _)) => {\n                 if let Def::Label(loop_id) = self.expect_full_def(id) {\n-                    Ok(self.lower_node_id(loop_id).node_id)\n+                    Ok(self.lower_node_id(loop_id).hir_id)\n                 } else {\n                     Err(hir::LoopIdError::UnresolvedLabel)\n                 }\n@@ -1079,7 +1077,7 @@ impl<'a> LoweringContext<'a> {\n                 self.loop_scopes\n                     .last()\n                     .cloned()\n-                    .map(|id| Ok(self.lower_node_id(id).node_id))\n+                    .map(|id| Ok(self.lower_node_id(id).hir_id))\n                     .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n                     .into()\n             }\n@@ -1153,10 +1151,9 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_ty_binding(&mut self, b: &TypeBinding,\n                         itctx: ImplTraitContext<'_>) -> hir::TypeBinding {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(b.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(b.id);\n \n         hir::TypeBinding {\n-            id: node_id,\n             hir_id,\n             ident: b.ident,\n             ty: self.lower_ty(&b.ty, itctx),\n@@ -1300,7 +1297,6 @@ impl<'a> LoweringContext<'a> {\n                         // Set the name to `impl Bound1 + Bound2`.\n                         let ident = Ident::from_str(&pprust::ty_to_string(t)).with_span_pos(span);\n                         in_band_ty_params.push(hir::GenericParam {\n-                            id: def_node_id,\n                             hir_id,\n                             name: ParamName::Plain(ident),\n                             pure_wrt_drop: false,\n@@ -1348,11 +1344,16 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n             TyKind::Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n+            TyKind::CVarArgs => {\n+                // Create the implicit lifetime of the \"spoofed\" `VaList`.\n+                let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n+                let lt = self.new_implicit_lifetime(span);\n+                hir::TyKind::CVarArgs(lt)\n+            },\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(t.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(t.id);\n         hir::Ty {\n-            id: node_id,\n             node: kind,\n             span: t.span,\n             hir_id,\n@@ -1394,12 +1395,11 @@ impl<'a> LoweringContext<'a> {\n         );\n \n         self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n-            let LoweredNodeId { node_id, hir_id } = lctx.next_id();\n+            let LoweredNodeId { node_id: _, hir_id } = lctx.next_id();\n             let exist_ty_item_kind = hir::ItemKind::Existential(hir::ExistTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n                     where_clause: hir::WhereClause {\n-                        id: node_id,\n                         hir_id,\n                         predicates: Vec::new().into(),\n                     },\n@@ -1414,7 +1414,6 @@ impl<'a> LoweringContext<'a> {\n \n             trace!(\"exist ty def index: {:#?}\", exist_ty_def_index);\n             let exist_ty_item = hir::Item {\n-                id: exist_ty_id.node_id,\n                 hir_id: exist_ty_id.hir_id,\n                 ident: keywords::Invalid.ident(),\n                 attrs: Default::default(),\n@@ -1533,9 +1532,8 @@ impl<'a> LoweringContext<'a> {\n                     && !self.already_defined_lifetimes.contains(&name) {\n                     self.already_defined_lifetimes.insert(name);\n \n-                    let LoweredNodeId { node_id, hir_id } = self.context.next_id();\n+                    let LoweredNodeId { node_id: _, hir_id } = self.context.next_id();\n                     self.output_lifetimes.push(hir::GenericArg::Lifetime(hir::Lifetime {\n-                        id: node_id,\n                         hir_id,\n                         span: lifetime.span,\n                         name,\n@@ -1569,7 +1567,6 @@ impl<'a> LoweringContext<'a> {\n                     };\n \n                     self.output_lifetime_params.push(hir::GenericParam {\n-                        id: def_node_id,\n                         hir_id,\n                         name,\n                         span: lifetime.span,\n@@ -1935,7 +1932,6 @@ impl<'a> LoweringContext<'a> {\n \n         hir::PathSegment::new(\n             segment.ident,\n-            Some(id.node_id),\n             Some(id.hir_id),\n             Some(def),\n             generic_args,\n@@ -1980,17 +1976,16 @@ impl<'a> LoweringContext<'a> {\n                     .map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed()))\n                     .collect();\n                 let mk_tup = |this: &mut Self, tys, span| {\n-                    let LoweredNodeId { node_id, hir_id } = this.next_id();\n-                    hir::Ty { node: hir::TyKind::Tup(tys), id: node_id, hir_id, span }\n+                    let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n+                    hir::Ty { node: hir::TyKind::Tup(tys), hir_id, span }\n                 };\n-                let LoweredNodeId { node_id, hir_id } = this.next_id();\n+                let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n \n                 (\n                     hir::GenericArgs {\n                         args: hir_vec![GenericArg::Type(mk_tup(this, inputs, span))],\n                         bindings: hir_vec![\n                             hir::TypeBinding {\n-                                id: node_id,\n                                 hir_id,\n                                 ident: Ident::from_str(FN_OUTPUT_NAME),\n                                 ty: output\n@@ -2009,7 +2004,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_local(&mut self, l: &Local) -> (hir::Local, SmallVec<[hir::ItemId; 1]>) {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(l.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(l.id);\n         let mut ids = SmallVec::<[hir::ItemId; 1]>::new();\n         if self.sess.features_untracked().impl_trait_in_bindings {\n             if let Some(ref ty) = l.ty {\n@@ -2019,7 +2014,6 @@ impl<'a> LoweringContext<'a> {\n         }\n         let parent_def_id = DefId::local(self.current_hir_id_owner.last().unwrap().0);\n         (hir::Local {\n-            id: node_id,\n             hir_id,\n             ty: l.ty\n                 .as_ref()\n@@ -2046,9 +2040,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(arg.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(arg.id);\n         hir::Arg {\n-            id: node_id,\n             hir_id,\n             pat: self.lower_pat(&arg.pat),\n         }\n@@ -2119,7 +2112,7 @@ impl<'a> LoweringContext<'a> {\n         P(hir::FnDecl {\n             inputs,\n             output,\n-            variadic: decl.variadic,\n+            c_variadic: decl.c_variadic,\n             implicit_self: decl.inputs.get(0).map_or(\n                 hir::ImplicitSelfKind::None,\n                 |arg| {\n@@ -2318,9 +2311,8 @@ impl<'a> LoweringContext<'a> {\n                     this.lower_ty(ty, ImplTraitContext::Existential(Some(fn_def_id)))\n                 }\n                 FunctionRetTy::Default(span) => {\n-                    let LoweredNodeId { node_id, hir_id } = this.next_id();\n+                    let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n                     P(hir::Ty {\n-                        id: node_id,\n                         hir_id,\n                         node: hir::TyKind::Tup(hir_vec![]),\n                         span: *span,\n@@ -2329,13 +2321,12 @@ impl<'a> LoweringContext<'a> {\n             };\n \n             // \"<Output = T>\"\n-            let LoweredNodeId { node_id, hir_id } = this.next_id();\n+            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n             let future_params = P(hir::GenericArgs {\n                 args: hir_vec![],\n                 bindings: hir_vec![hir::TypeBinding {\n                     ident: Ident::from_str(FN_OUTPUT_NAME),\n                     ty: output_ty,\n-                    id: node_id,\n                     hir_id,\n                     span,\n                 }],\n@@ -2345,13 +2336,12 @@ impl<'a> LoweringContext<'a> {\n             let future_path =\n                 this.std_path(span, &[\"future\", \"Future\"], Some(future_params), false);\n \n-            let LoweredNodeId { node_id, hir_id } = this.next_id();\n+            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n             let mut bounds = vec![\n                 hir::GenericBound::Trait(\n                     hir::PolyTraitRef {\n                         trait_ref: hir::TraitRef {\n                             path: future_path,\n-                            ref_id: node_id,\n                             hir_ref_id: hir_id,\n                         },\n                         bound_generic_params: hir_vec![],\n@@ -2362,17 +2352,16 @@ impl<'a> LoweringContext<'a> {\n             ];\n \n             if let Some((name, span)) = bound_lifetime {\n-                let LoweredNodeId { node_id, hir_id } = this.next_id();\n+                let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n                 bounds.push(hir::GenericBound::Outlives(\n-                    hir::Lifetime { id: node_id, hir_id, name, span }));\n+                    hir::Lifetime { hir_id, name, span }));\n             }\n \n             hir::HirVec::from(bounds)\n         });\n \n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n         let impl_trait_ty = P(hir::Ty {\n-            id: node_id,\n             node: impl_trait_ty,\n             span,\n             hir_id,\n@@ -2431,10 +2420,9 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         name: hir::LifetimeName,\n     ) -> hir::Lifetime {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n         hir::Lifetime {\n-            id: node_id,\n             hir_id,\n             span,\n             name: name,\n@@ -2524,10 +2512,9 @@ impl<'a> LoweringContext<'a> {\n             }\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(param.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(param.id);\n \n         hir::GenericParam {\n-            id: node_id,\n             hir_id,\n             name,\n             span: param.ident.span,\n@@ -2608,10 +2595,9 @@ impl<'a> LoweringContext<'a> {\n         self.with_anonymous_lifetime_mode(\n             AnonymousLifetimeMode::ReportError,\n             |this| {\n-                let LoweredNodeId { node_id, hir_id } = this.lower_node_id(wc.id);\n+                let LoweredNodeId { node_id: _, hir_id } = this.lower_node_id(wc.id);\n \n                 hir::WhereClause {\n-                    id: node_id,\n                     hir_id,\n                     predicates: wc.predicates\n                         .iter()\n@@ -2672,10 +2658,9 @@ impl<'a> LoweringContext<'a> {\n                 ref rhs_ty,\n                 span,\n             }) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                    id: node_id,\n                     hir_id,\n                     lhs_ty: self.lower_ty(lhs_ty, ImplTraitContext::disallowed()),\n                     rhs_ty: self.lower_ty(rhs_ty, ImplTraitContext::disallowed()),\n@@ -2688,35 +2673,33 @@ impl<'a> LoweringContext<'a> {\n     fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData {\n         match *vdata {\n             VariantData::Struct(ref fields, id) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n                 hir::VariantData::Struct(\n                     fields\n                         .iter()\n                         .enumerate()\n                         .map(|f| self.lower_struct_field(f))\n                         .collect(),\n-                    node_id,\n                     hir_id,\n                 )\n             },\n             VariantData::Tuple(ref fields, id) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n                 hir::VariantData::Tuple(\n                     fields\n                         .iter()\n                         .enumerate()\n                         .map(|f| self.lower_struct_field(f))\n                         .collect(),\n-                    node_id,\n                     hir_id,\n                 )\n             },\n             VariantData::Unit(id) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n-                hir::VariantData::Unit(node_id, hir_id)\n+                hir::VariantData::Unit(hir_id)\n             },\n         }\n     }\n@@ -2726,10 +2709,9 @@ impl<'a> LoweringContext<'a> {\n             hir::QPath::Resolved(None, path) => path.and_then(|path| path),\n             qpath => bug!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath),\n         };\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.ref_id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(p.ref_id);\n         hir::TraitRef {\n             path,\n-            ref_id: node_id,\n             hir_ref_id: hir_id,\n         }\n     }\n@@ -2757,11 +2739,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(f.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(f.id);\n \n         hir::StructField {\n             span: f.span,\n-            id: node_id,\n             hir_id,\n             ident: match f.ident {\n                 Some(ident) => ident,\n@@ -2775,10 +2756,9 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_field(&mut self, f: &Field) -> hir::Field {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n         hir::Field {\n-            id: node_id,\n             hir_id,\n             ident: f.ident,\n             expr: P(self.lower_expr(&f.expr)),\n@@ -2816,10 +2796,9 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(b.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(b.id);\n \n         P(hir::Block {\n-            id: node_id,\n             hir_id,\n             stmts: stmts.into(),\n             expr,\n@@ -2906,7 +2885,7 @@ impl<'a> LoweringContext<'a> {\n                     // `impl Future<Output = T>` here because lower_body\n                     // only cares about the input argument patterns in the function\n                     // declaration (decl), not the return types.\n-                    let body_id = this.lower_async_body(decl, header.asyncness, body);\n+                    let body_id = this.lower_async_body(decl, header.asyncness.node, body);\n \n                     let (generics, fn_decl) = this.add_in_band_defs(\n                         generics,\n@@ -2916,7 +2895,7 @@ impl<'a> LoweringContext<'a> {\n                             decl,\n                             Some((fn_def_id, idty)),\n                             true,\n-                            header.asyncness.opt_return_id()\n+                            header.asyncness.node.opt_return_id()\n                         ),\n                     );\n \n@@ -3131,12 +3110,11 @@ impl<'a> LoweringContext<'a> {\n                             hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n                             hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n                             hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-                            hir::VisibilityKind::Restricted { ref path, id: _, hir_id: _ } => {\n+                            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n                                 let id = this.next_id();\n                                 let path = this.renumber_segment_ids(path);\n                                 hir::VisibilityKind::Restricted {\n                                     path,\n-                                    id: id.node_id,\n                                     hir_id: id.hir_id,\n                                 }\n                             }\n@@ -3146,7 +3124,6 @@ impl<'a> LoweringContext<'a> {\n                         this.insert_item(\n                             new_id.node_id,\n                             hir::Item {\n-                                id: new_id.node_id,\n                                 hir_id: new_id.hir_id,\n                                 ident,\n                                 attrs: attrs.clone(),\n@@ -3238,12 +3215,11 @@ impl<'a> LoweringContext<'a> {\n                             hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n                             hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n                             hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-                            hir::VisibilityKind::Restricted { ref path, id: _, hir_id: _ } => {\n+                            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n                                 let id = this.next_id();\n                                 let path = this.renumber_segment_ids(path);\n                                 hir::VisibilityKind::Restricted {\n                                     path: path,\n-                                    id: id.node_id,\n                                     hir_id: id.hir_id,\n                                 }\n                             }\n@@ -3253,7 +3229,6 @@ impl<'a> LoweringContext<'a> {\n                         this.insert_item(\n                             new_id,\n                             hir::Item {\n-                                id: new_id,\n                                 hir_id: new_hir_id,\n                                 ident,\n                                 attrs: attrs.clone(),\n@@ -3300,10 +3275,8 @@ impl<'a> LoweringContext<'a> {\n         debug!(\"renumber_segment_ids(path = {:?})\", path);\n         let mut path = path.clone();\n         for seg in path.segments.iter_mut() {\n-            if seg.id.is_some() {\n-                let next_id = self.next_id();\n-                seg.id = Some(next_id.node_id);\n-                seg.hir_id = Some(next_id.hir_id);\n+            if seg.hir_id.is_some() {\n+                seg.hir_id = Some(self.next_id().hir_id);\n             }\n         }\n         path\n@@ -3361,7 +3334,6 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         hir::TraitItem {\n-            id: node_id,\n             hir_id,\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n@@ -3388,7 +3360,7 @@ impl<'a> LoweringContext<'a> {\n             TraitItemKind::Macro(..) => unimplemented!(),\n         };\n         hir::TraitItemRef {\n-            id: hir::TraitItemId { node_id: i.id },\n+            id: hir::TraitItemId { hir_id: self.lower_node_id(i.id).hir_id },\n             ident: i.ident,\n             span: i.span,\n             defaultness: self.lower_defaultness(Defaultness::Default, has_default),\n@@ -3412,14 +3384,14 @@ impl<'a> LoweringContext<'a> {\n                 )\n             }\n             ImplItemKind::Method(ref sig, ref body) => {\n-                let body_id = self.lower_async_body(&sig.decl, sig.header.asyncness, body);\n+                let body_id = self.lower_async_body(&sig.decl, sig.header.asyncness.node, body);\n                 let impl_trait_return_allow = !self.is_in_trait_impl;\n                 let (generics, sig) = self.lower_method_sig(\n                     &i.generics,\n                     sig,\n                     impl_item_def_id,\n                     impl_trait_return_allow,\n-                    sig.header.asyncness.opt_return_id(),\n+                    sig.header.asyncness.node.opt_return_id(),\n                 );\n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n@@ -3437,7 +3409,6 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         hir::ImplItem {\n-            id: node_id,\n             hir_id,\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n@@ -3453,7 +3424,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { node_id: i.id },\n+            id: hir::ImplItemId { hir_id: self.lower_node_id(i.id).hir_id },\n             ident: i.ident,\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n@@ -3544,7 +3515,6 @@ impl<'a> LoweringContext<'a> {\n                     name: ident.name,\n                     vis,\n                     attrs,\n-                    id: i.id,\n                     hir_id,\n                     span: i.span,\n                     body,\n@@ -3556,10 +3526,9 @@ impl<'a> LoweringContext<'a> {\n \n         let node = self.lower_item_kind(i.id, &mut ident, &attrs, &mut vis, &i.node);\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(i.id);\n \n         Some(hir::Item {\n-            id: node_id,\n             hir_id,\n             ident,\n             attrs,\n@@ -3573,7 +3542,6 @@ impl<'a> LoweringContext<'a> {\n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n         let def_id = self.resolver.definitions().local_def_id(node_id);\n         hir::ForeignItem {\n-            id: node_id,\n             hir_id,\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n@@ -3639,7 +3607,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n         hir::FnHeader {\n             unsafety: self.lower_unsafety(h.unsafety),\n-            asyncness: self.lower_asyncness(h.asyncness),\n+            asyncness: self.lower_asyncness(h.asyncness.node),\n             constness: self.lower_constness(h.constness),\n             abi: h.abi,\n         }\n@@ -3711,11 +3679,10 @@ impl<'a> LoweringContext<'a> {\n                             Some(Def::Local(id)) => id,\n                             _ => p.id,\n                         };\n-                        let hir_id = self.lower_node_id(canonical_id).hir_id;\n+\n                         hir::PatKind::Binding(\n                             self.lower_binding_mode(binding_mode),\n-                            canonical_id,\n-                            hir_id,\n+                            self.lower_node_id(canonical_id).hir_id,\n                             ident,\n                             sub.as_ref().map(|x| self.lower_pat(x)),\n                         )\n@@ -3767,12 +3734,11 @@ impl<'a> LoweringContext<'a> {\n                 let fs = fields\n                     .iter()\n                     .map(|f| {\n-                        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n                         Spanned {\n                             span: f.span,\n                             node: hir::FieldPat {\n-                                id: node_id,\n                                 hir_id,\n                                 ident: f.node.ident,\n                                 pat: self.lower_pat(&f.node.pat),\n@@ -3804,9 +3770,8 @@ impl<'a> LoweringContext<'a> {\n             PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(p.id);\n         P(hir::Pat {\n-            id: node_id,\n             hir_id,\n             node,\n             span: p.span,\n@@ -3822,9 +3787,8 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_anon_const(&mut self, c: &AnonConst) -> hir::AnonConst {\n         self.with_new_scopes(|this| {\n-            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(c.id);\n+            let LoweredNodeId { node_id: _, hir_id } = this.lower_node_id(c.id);\n             hir::AnonConst {\n-                id: node_id,\n                 hir_id,\n                 body: this.lower_body(None, |this| this.lower_expr(&c.value)),\n             }\n@@ -3900,11 +3864,10 @@ impl<'a> LoweringContext<'a> {\n                             // Wrap the `if let` expr in a block.\n                             let span = els.span;\n                             let els = P(self.lower_expr(els));\n-                            let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                            let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n                             let blk = P(hir::Block {\n                                 stmts: hir_vec![],\n                                 expr: Some(els),\n-                                id: node_id,\n                                 hir_id,\n                                 rules: hir::DefaultBlock,\n                                 span,\n@@ -3947,10 +3910,9 @@ impl<'a> LoweringContext<'a> {\n                     let mut block = this.lower_block(body, true).into_inner();\n                     let tail = block.expr.take().map_or_else(\n                         || {\n-                            let LoweredNodeId { node_id, hir_id } = this.next_id();\n+                            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n                             let span = this.sess.source_map().end_point(unstable_span);\n                             hir::Expr {\n-                                id: node_id,\n                                 span,\n                                 node: hir::ExprKind::Tup(hir_vec![]),\n                                 attrs: ThinVec::new(),\n@@ -3984,7 +3946,7 @@ impl<'a> LoweringContext<'a> {\n                     let outer_decl = FnDecl {\n                         inputs: decl.inputs.clone(),\n                         output: FunctionRetTy::Default(fn_decl_span),\n-                        variadic: false,\n+                        c_variadic: false,\n                     };\n                     // We need to lower the declaration outside the new scope, because we\n                     // have to conserve the state of being inside a loop condition for the\n@@ -4135,10 +4097,9 @@ impl<'a> LoweringContext<'a> {\n                 let struct_path = self.std_path(e.span, &struct_path, None, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(e.id);\n \n                 return hir::Expr {\n-                    id: node_id,\n                     hir_id,\n                     node: if is_unit {\n                         hir::ExprKind::Path(struct_path)\n@@ -4384,7 +4345,7 @@ impl<'a> LoweringContext<'a> {\n                 let iter = self.str_to_ident(\"iter\");\n \n                 let next_ident = self.str_to_ident(\"__next\");\n-                let next_pat = self.pat_ident_binding_mode(\n+                let (next_pat, next_pat_nid) = self.pat_ident_binding_mode(\n                     desugared_span,\n                     next_ident,\n                     hir::BindingAnnotation::Mutable,\n@@ -4393,9 +4354,9 @@ impl<'a> LoweringContext<'a> {\n                 // `::std::option::Option::Some(val) => next = val`\n                 let pat_arm = {\n                     let val_ident = self.str_to_ident(\"val\");\n-                    let val_pat = self.pat_ident(pat.span, val_ident);\n-                    let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat.id));\n-                    let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat.id));\n+                    let (val_pat, val_pat_nid) = self.pat_ident(pat.span, val_ident);\n+                    let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_nid));\n+                    let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_nid));\n                     let assign = P(self.expr(\n                         pat.span,\n                         hir::ExprKind::Assign(next_expr, val_expr),\n@@ -4414,15 +4375,15 @@ impl<'a> LoweringContext<'a> {\n                 };\n \n                 // `mut iter`\n-                let iter_pat = self.pat_ident_binding_mode(\n+                let (iter_pat, iter_pat_nid) = self.pat_ident_binding_mode(\n                     desugared_span,\n                     iter,\n                     hir::BindingAnnotation::Mutable\n                 );\n \n                 // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                 let match_expr = {\n-                    let iter = P(self.expr_ident(head_sp, iter, iter_pat.id));\n+                    let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n                     let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n                     let next_path = &[\"iter\", \"Iterator\", \"next\"];\n                     let next_path = P(self.expr_std_path(head_sp, next_path, None, ThinVec::new()));\n@@ -4439,15 +4400,14 @@ impl<'a> LoweringContext<'a> {\n                         ThinVec::new(),\n                     ))\n                 };\n-                let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n                 let match_stmt = hir::Stmt {\n-                    id: node_id,\n                     hir_id,\n                     node: hir::StmtKind::Expr(match_expr),\n                     span: head_sp,\n                 };\n \n-                let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat.id));\n+                let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_nid));\n \n                 // `let mut __next`\n                 let next_let = self.stmt_let_pat(\n@@ -4468,9 +4428,8 @@ impl<'a> LoweringContext<'a> {\n \n                 let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n                 let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n-                let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n                 let body_stmt = hir::Stmt {\n-                    id: node_id,\n                     hir_id,\n                     node: hir::StmtKind::Expr(body_expr),\n                     span: body.span,\n@@ -4488,9 +4447,8 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_label(opt_label),\n                     hir::LoopSource::ForLoop,\n                 );\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(e.id);\n                 let loop_expr = P(hir::Expr {\n-                    id: node_id,\n                     hir_id,\n                     node: loop_expr,\n                     span: e.span,\n@@ -4576,11 +4534,11 @@ impl<'a> LoweringContext<'a> {\n                 // `Ok(val) => #[allow(unreachable_code)] val,`\n                 let ok_arm = {\n                     let val_ident = self.str_to_ident(\"val\");\n-                    let val_pat = self.pat_ident(e.span, val_ident);\n+                    let (val_pat, val_pat_nid) = self.pat_ident(e.span, val_ident);\n                     let val_expr = P(self.expr_ident_with_attrs(\n                         e.span,\n                         val_ident,\n-                        val_pat.id,\n+                        val_pat_nid,\n                         ThinVec::from(attrs.clone()),\n                     ));\n                     let ok_pat = self.pat_ok(e.span, val_pat);\n@@ -4592,12 +4550,12 @@ impl<'a> LoweringContext<'a> {\n                 //              return Try::from_error(From::from(err)),`\n                 let err_arm = {\n                     let err_ident = self.str_to_ident(\"err\");\n-                    let err_local = self.pat_ident(e.span, err_ident);\n+                    let (err_local, err_local_nid) = self.pat_ident(e.span, err_ident);\n                     let from_expr = {\n                         let path = &[\"convert\", \"From\", \"from\"];\n                         let from = P(self.expr_std_path(\n                                 e.span, path, None, ThinVec::new()));\n-                        let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n+                        let err_expr = self.expr_ident(e.span, err_ident, err_local_nid);\n \n                         self.expr_call(e.span, from, hir_vec![err_expr])\n                     };\n@@ -4606,12 +4564,13 @@ impl<'a> LoweringContext<'a> {\n                     let thin_attrs = ThinVec::from(attrs);\n                     let catch_scope = self.catch_scopes.last().map(|x| *x);\n                     let ret_expr = if let Some(catch_node) = catch_scope {\n+                        let target_id = Ok(self.lower_node_id(catch_node).hir_id);\n                         P(self.expr(\n                             e.span,\n                             hir::ExprKind::Break(\n                                 hir::Destination {\n                                     label: None,\n-                                    target_id: Ok(catch_node),\n+                                    target_id,\n                                 },\n                                 Some(from_err_expr),\n                             ),\n@@ -4635,10 +4594,9 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(e.id);\n \n         hir::Expr {\n-            id: node_id,\n             hir_id,\n             node: kind,\n             span: e.span,\n@@ -4653,21 +4611,19 @@ impl<'a> LoweringContext<'a> {\n                 let mut ids: SmallVec<[hir::Stmt; 1]> = item_ids\n                     .into_iter()\n                     .map(|item_id| {\n-                        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n                         hir::Stmt {\n-                            id: node_id,\n                             hir_id,\n                             node: hir::StmtKind::Item(item_id),\n                             span: s.span,\n                         }\n                     })\n                     .collect();\n                 ids.push({\n-                    let LoweredNodeId { node_id, hir_id } = self.lower_node_id(s.id);\n+                    let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(s.id);\n \n                     hir::Stmt {\n-                        id: node_id,\n                         hir_id,\n                         node: hir::StmtKind::Local(P(l)),\n                         span: s.span,\n@@ -4681,12 +4637,11 @@ impl<'a> LoweringContext<'a> {\n                 return self.lower_item_id(it)\n                     .into_iter()\n                     .map(|item_id| {\n-                        let LoweredNodeId { node_id, hir_id } = id.take()\n+                        let LoweredNodeId { node_id: _, hir_id } = id.take()\n                           .map(|id| self.lower_node_id(id))\n                           .unwrap_or_else(|| self.next_id());\n \n                         hir::Stmt {\n-                            id: node_id,\n                             hir_id,\n                             node: hir::StmtKind::Item(item_id),\n                             span: s.span,\n@@ -4695,20 +4650,18 @@ impl<'a> LoweringContext<'a> {\n                     .collect();\n             }\n             StmtKind::Expr(ref e) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(s.id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(s.id);\n \n                 hir::Stmt {\n-                    id: node_id,\n                     hir_id,\n                     node: hir::StmtKind::Expr(P(self.lower_expr(e))),\n                     span: s.span,\n                 }\n             },\n             StmtKind::Semi(ref e) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(s.id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(s.id);\n \n                 hir::Stmt {\n-                    id: node_id,\n                     hir_id,\n                     node: hir::StmtKind::Semi(P(self.lower_expr(e))),\n                     span: s.span,\n@@ -4753,7 +4706,6 @@ impl<'a> LoweringContext<'a> {\n                         ParamMode::Explicit,\n                         explicit_owner,\n                     )),\n-                    id: lowered_id.node_id,\n                     hir_id: lowered_id.hir_id,\n                 }\n             },\n@@ -4823,10 +4775,9 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn field(&mut self, ident: Ident, expr: P<hir::Expr>, span: Span) -> hir::Field {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n         hir::Field {\n-            id: node_id,\n             hir_id,\n             ident,\n             span,\n@@ -4910,9 +4861,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr(&mut self, span: Span, node: hir::ExprKind, attrs: ThinVec<Attribute>) -> hir::Expr {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n         hir::Expr {\n-            id: node_id,\n             hir_id,\n             node,\n             span,\n@@ -4927,22 +4877,20 @@ impl<'a> LoweringContext<'a> {\n         pat: P<hir::Pat>,\n         source: hir::LocalSource,\n     ) -> hir::Stmt {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n         let local = hir::Local {\n             pat,\n             ty: None,\n             init: ex,\n-            id: node_id,\n             hir_id,\n             span: sp,\n             attrs: ThinVec::new(),\n             source,\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n         hir::Stmt {\n-            id: node_id,\n             hir_id,\n             node: hir::StmtKind::Local(P(local)),\n             span: sp\n@@ -4956,15 +4904,15 @@ impl<'a> LoweringContext<'a> {\n         ident: Ident,\n         ex: P<hir::Expr>,\n     ) -> (hir::Stmt, NodeId) {\n-        let pat = if mutbl {\n+        let (pat, pat_nid) = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, hir::BindingAnnotation::Mutable)\n         } else {\n             self.pat_ident(sp, ident)\n         };\n-        let pat_id = pat.id;\n+\n         (\n             self.stmt_let_pat(sp, Some(ex), pat, hir::LocalSource::Normal),\n-            pat_id,\n+            pat_nid,\n         )\n     }\n \n@@ -4978,12 +4926,11 @@ impl<'a> LoweringContext<'a> {\n         stmts: hir::HirVec<hir::Stmt>,\n         expr: Option<P<hir::Expr>>,\n     ) -> hir::Block {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n         hir::Block {\n             stmts,\n             expr,\n-            id: node_id,\n             hir_id,\n             rules: hir::DefaultBlock,\n             span,\n@@ -5023,7 +4970,7 @@ impl<'a> LoweringContext<'a> {\n         self.pat(span, pt)\n     }\n \n-    fn pat_ident(&mut self, span: Span, ident: Ident) -> P<hir::Pat> {\n+    fn pat_ident(&mut self, span: Span, ident: Ident) -> (P<hir::Pat>, NodeId) {\n         self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::Unannotated)\n     }\n \n@@ -5032,25 +4979,26 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         ident: Ident,\n         bm: hir::BindingAnnotation,\n-    ) -> P<hir::Pat> {\n+    ) -> (P<hir::Pat>, NodeId) {\n         let LoweredNodeId { node_id, hir_id } = self.next_id();\n \n-        P(hir::Pat {\n-            id: node_id,\n-            hir_id,\n-            node: hir::PatKind::Binding(bm, node_id, hir_id, ident.with_span_pos(span), None),\n-            span,\n-        })\n+        (\n+            P(hir::Pat {\n+                hir_id,\n+                node: hir::PatKind::Binding(bm, hir_id, ident.with_span_pos(span), None),\n+                span,\n+            }),\n+            node_id\n+        )\n     }\n \n     fn pat_wild(&mut self, span: Span) -> P<hir::Pat> {\n         self.pat(span, hir::PatKind::Wild)\n     }\n \n     fn pat(&mut self, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n         P(hir::Pat {\n-            id: node_id,\n             hir_id,\n             node: pat,\n             span,\n@@ -5073,8 +5021,8 @@ impl<'a> LoweringContext<'a> {\n \n \n         for seg in path.segments.iter_mut() {\n-            if let Some(id) = seg.id {\n-                seg.id = Some(self.lower_node_id(id).node_id);\n+            if seg.hir_id.is_some() {\n+                seg.hir_id = Some(self.next_id().hir_id);\n             }\n         }\n         path\n@@ -5091,7 +5039,6 @@ impl<'a> LoweringContext<'a> {\n                             bound_generic_params: hir::HirVec::new(),\n                             trait_ref: hir::TraitRef {\n                                 path: path.and_then(|path| path),\n-                                ref_id: id.node_id,\n                                 hir_ref_id: id.hir_id,\n                             },\n                             span,\n@@ -5108,7 +5055,6 @@ impl<'a> LoweringContext<'a> {\n             _ => hir::TyKind::Path(qpath),\n         };\n         hir::Ty {\n-            id: id.node_id,\n             hir_id: id.hir_id,\n             node,\n             span,\n@@ -5124,9 +5070,8 @@ impl<'a> LoweringContext<'a> {\n             // `'f`.\n             AnonymousLifetimeMode::CreateParameter => {\n                 let fresh_name = self.collect_fresh_in_band_lifetime(span);\n-                let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n                 hir::Lifetime {\n-                    id: node_id,\n                     hir_id,\n                     span,\n                     name: hir::LifetimeName::Param(fresh_name),\n@@ -5227,10 +5172,9 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n         hir::Lifetime {\n-            id: node_id,\n             hir_id,\n             span,\n             name: hir::LifetimeName::Implicit,"}, {"sha": "1114ef52bbc0c8aba1e10c5a599809fde89ed8d9", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -75,10 +75,10 @@ pub enum Code<'a> {\n }\n \n impl<'a> Code<'a> {\n-    pub fn id(&self) -> NodeId {\n+    pub fn id(&self) -> ast::HirId {\n         match *self {\n             Code::FnLike(node) => node.id(),\n-            Code::Expr(block) => block.id,\n+            Code::Expr(block) => block.hir_id,\n         }\n     }\n \n@@ -104,7 +104,7 @@ struct ItemFnParts<'a> {\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n     body:     ast::BodyId,\n-    id:       NodeId,\n+    id:       ast::HirId,\n     span:     Span,\n     attrs:    &'a [Attribute],\n }\n@@ -114,13 +114,13 @@ struct ItemFnParts<'a> {\n struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n     body: ast::BodyId,\n-    id: NodeId,\n+    id: ast::HirId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: ast::BodyId, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(d: &'a FnDecl, b: ast::BodyId, id: ast::HirId, s: Span, attrs: &'a [Attribute]) -> Self {\n         ClosureParts {\n             decl: d,\n             body: b,\n@@ -168,7 +168,7 @@ impl<'a> FnLikeNode<'a> {\n                     |c: ClosureParts<'_>| c.span)\n     }\n \n-    pub fn id(self) -> NodeId {\n+    pub fn id(self) -> ast::HirId {\n         self.handle(|i: ItemFnParts<'_>| i.id,\n                     |id, _, _: &'a ast::MethodSig, _, _, _, _| id,\n                     |c: ClosureParts<'_>| c.id)\n@@ -213,7 +213,7 @@ impl<'a> FnLikeNode<'a> {\n \n     fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n-        M: FnOnce(NodeId,\n+        M: FnOnce(ast::HirId,\n                   Ident,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n@@ -227,7 +227,7 @@ impl<'a> FnLikeNode<'a> {\n             map::Node::Item(i) => match i.node {\n                 ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n-                        id: i.id,\n+                        id: i.hir_id,\n                         ident: i.ident,\n                         decl: &decl,\n                         body: block,\n@@ -241,21 +241,21 @@ impl<'a> FnLikeNode<'a> {\n             },\n             map::Node::TraitItem(ti) => match ti.node {\n                 ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n-                    method(ti.id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n+                    method(ti.hir_id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::Node::ImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, body) => {\n-                        method(ii.id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n+                        method(ii.hir_id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => bug!(\"impl method FnLikeNode that is not fn-like\")\n                 }\n             },\n             map::Node::Expr(e) => match e.node {\n                 ast::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) =>\n-                    closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n+                    closure(ClosureParts::new(&decl, block, e.hir_id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => bug!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "9f39d648df1bfcf08df8590669cf482eb94ef6b1", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -356,7 +356,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir Item) {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(i.hir_id.owner,\n-                         self.definitions.opt_def_index(i.id).unwrap());\n+                         self.definitions.opt_def_index(self.hir_to_node_id[&i.hir_id]).unwrap());\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n             this.insert(i.span, i.hir_id, Node::Item(i));\n             this.with_parent(i.hir_id, |this| {\n@@ -386,7 +386,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n-                         self.definitions.opt_def_index(ti.id).unwrap());\n+                         self.definitions.opt_def_index(self.hir_to_node_id[&ti.hir_id]).unwrap());\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n             this.insert(ti.span, ti.hir_id, Node::TraitItem(ti));\n \n@@ -398,7 +398,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_impl_item(&mut self, ii: &'hir ImplItem) {\n         debug_assert_eq!(ii.hir_id.owner,\n-                         self.definitions.opt_def_index(ii.id).unwrap());\n+                         self.definitions.opt_def_index(self.hir_to_node_id[&ii.hir_id]).unwrap());\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n             this.insert(ii.span, ii.hir_id, Node::ImplItem(ii));\n \n@@ -507,7 +507,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'hir MacroDef) {\n-        let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n+        let node_id = self.hir_to_node_id[&macro_def.hir_id];\n+        let def_index = self.definitions.opt_def_index(node_id).unwrap();\n \n         self.with_dep_node_owner(def_index, macro_def, |this| {\n             this.insert(macro_def.span, macro_def.hir_id, Node::MacroDef(macro_def));"}, {"sha": "12760f8b9828b2372c40c6335d1a422bfa64775f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -73,7 +73,7 @@ impl<'a> DefCollector<'a> {\n         decl: &'a FnDecl,\n         body: &'a Block,\n     ) {\n-        let (closure_id, return_impl_trait_id) = match header.asyncness {\n+        let (closure_id, return_impl_trait_id) = match header.asyncness.node {\n             IsAsync::Async {\n                 closure_id,\n                 return_impl_trait_id,\n@@ -129,10 +129,10 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             }\n             ItemKind::Fn(\n                 ref decl,\n-                ref header @ FnHeader { asyncness: IsAsync::Async { .. }, .. },\n+                ref header,\n                 ref generics,\n                 ref body,\n-            ) => {\n+            ) if header.asyncness.node.is_async() => {\n                 return self.visit_async_fn(\n                     i.id,\n                     i.ident.name,\n@@ -242,9 +242,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(MethodSig {\n-                header: ref header @ FnHeader { asyncness: IsAsync::Async { .. }, .. },\n+                ref header,\n                 ref decl,\n-            }, ref body) => {\n+            }, ref body) if header.asyncness.node.is_async() => {\n                 return self.visit_async_fn(\n                     ii.id,\n                     ii.ident.name,"}, {"sha": "86b6805cc9b4c39f600ddf7952e3217c27f501ee", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 55, "deletions": 61, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -319,7 +319,7 @@ impl<'hir> Map<'hir> {\n \n         match node {\n             Node::Item(item) => {\n-                let def_id = || self.local_def_id(item.id);\n+                let def_id = || self.local_def_id_from_hir_id(item.hir_id);\n \n                 match item.node {\n                     ItemKind::Static(_, m, _) => Some(Def::Static(def_id(), m == MutMutable)),\n@@ -341,23 +341,23 @@ impl<'hir> Map<'hir> {\n                 }\n             }\n             Node::ForeignItem(item) => {\n-                let def_id = self.local_def_id(item.id);\n+                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n                     ForeignItemKind::Fn(..) => Some(Def::Fn(def_id)),\n                     ForeignItemKind::Static(_, m) => Some(Def::Static(def_id, m)),\n                     ForeignItemKind::Type => Some(Def::ForeignTy(def_id)),\n                 }\n             }\n             Node::TraitItem(item) => {\n-                let def_id = self.local_def_id(item.id);\n+                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n                     TraitItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n                     TraitItemKind::Method(..) => Some(Def::Method(def_id)),\n                     TraitItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n                 }\n             }\n             Node::ImplItem(item) => {\n-                let def_id = self.local_def_id(item.id);\n+                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n                     ImplItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n                     ImplItemKind::Method(..) => Some(Def::Method(def_id)),\n@@ -366,11 +366,11 @@ impl<'hir> Map<'hir> {\n                 }\n             }\n             Node::Variant(variant) => {\n-                let def_id = self.local_def_id(variant.node.data.id());\n+                let def_id = self.local_def_id_from_hir_id(variant.node.data.hir_id());\n                 Some(Def::Variant(def_id))\n             }\n             Node::StructCtor(variant) => {\n-                let def_id = self.local_def_id(variant.id());\n+                let def_id = self.local_def_id_from_hir_id(variant.hir_id());\n                 Some(Def::StructCtor(def_id, def::CtorKind::from_hir(variant)))\n             }\n             Node::AnonConst(_) |\n@@ -387,17 +387,22 @@ impl<'hir> Map<'hir> {\n             Node::Block(_) |\n             Node::Crate => None,\n             Node::Local(local) => {\n-                Some(Def::Local(local.id))\n+                Some(Def::Local(self.hir_to_node_id(local.hir_id)))\n             }\n             Node::MacroDef(macro_def) => {\n-                Some(Def::Macro(self.local_def_id(macro_def.id),\n+                Some(Def::Macro(self.local_def_id_from_hir_id(macro_def.hir_id),\n                                 MacroKind::Bang))\n             }\n             Node::GenericParam(param) => {\n                 Some(match param.kind {\n-                    GenericParamKind::Lifetime { .. } => Def::Local(param.id),\n-                    GenericParamKind::Type { .. } => Def::TyParam(self.local_def_id(param.id)),\n-                    GenericParamKind::Const { .. } => Def::ConstParam(self.local_def_id(param.id)),\n+                    GenericParamKind::Lifetime { .. } => {\n+                        let node_id = self.hir_to_node_id(param.hir_id);\n+                        Def::Local(node_id)\n+                    },\n+                    GenericParamKind::Type { .. } => Def::TyParam(\n+                        self.local_def_id_from_hir_id(param.hir_id)),\n+                    GenericParamKind::Const { .. } => Def::ConstParam(\n+                        self.local_def_id_from_hir_id(param.hir_id)),\n                 })\n             }\n         }\n@@ -422,15 +427,15 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem {\n-        self.read(id.node_id);\n+        self.read_by_hir_id(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_item(id)\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem {\n-        self.read(id.node_id);\n+        self.read_by_hir_id(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n@@ -496,10 +501,10 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Given a body owner's id, returns the `BodyId` associated with it.\n-    pub fn body_owned_by(&self, id: NodeId) -> BodyId {\n-        self.maybe_body_owned_by(id).unwrap_or_else(|| {\n-            span_bug!(self.span(id), \"body_owned_by: {} has no associated body\",\n-                      self.node_to_string(id));\n+    pub fn body_owned_by(&self, id: HirId) -> BodyId {\n+        self.maybe_body_owned_by_by_hir_id(id).unwrap_or_else(|| {\n+            span_bug!(self.span_by_hir_id(id), \"body_owned_by: {} has no associated body\",\n+                      self.hir_to_string(id));\n         })\n     }\n \n@@ -534,19 +539,19 @@ impl<'hir> Map<'hir> {\n         self.body_owner_kind(node_id)\n     }\n \n-    pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n-        match self.get(id) {\n+    pub fn ty_param_owner(&self, id: HirId) -> HirId {\n+        match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n-            Node::GenericParam(_) => self.get_parent_node(id),\n-            _ => bug!(\"ty_param_owner: {} not a type parameter\", self.node_to_string(id))\n+            Node::GenericParam(_) => self.get_parent_node_by_hir_id(id),\n+            _ => bug!(\"ty_param_owner: {} not a type parameter\", self.hir_to_string(id))\n         }\n     }\n \n-    pub fn ty_param_name(&self, id: NodeId) -> Name {\n-        match self.get(id) {\n+    pub fn ty_param_name(&self, id: HirId) -> Name {\n+        match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfUpper.name(),\n             Node::GenericParam(param) => param.name.ident().name,\n-            _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n+            _ => bug!(\"ty_param_name: {} not a type parameter\", self.hir_to_string(id)),\n         }\n     }\n \n@@ -613,11 +618,11 @@ impl<'hir> Map<'hir> {\n         }\n \n         for id in &module.trait_items {\n-            visitor.visit_trait_item(self.expect_trait_item(id.node_id));\n+            visitor.visit_trait_item(self.expect_trait_item(id.hir_id));\n         }\n \n         for id in &module.impl_items {\n-            visitor.visit_impl_item(self.expect_impl_item(id.node_id));\n+            visitor.visit_impl_item(self.expect_impl_item(id.hir_id));\n         }\n     }\n \n@@ -794,7 +799,7 @@ impl<'hir> Map<'hir> {\n     ///     false\n     /// }\n     /// ```\n-    pub fn get_return_block(&self, id: NodeId) -> Option<NodeId> {\n+    pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n         let match_fn = |node: &Node<'_>| {\n             match *node {\n                 Node::Item(_) |\n@@ -817,7 +822,10 @@ impl<'hir> Map<'hir> {\n             }\n         };\n \n-        self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n+        let node_id = self.hir_to_node_id(id);\n+        self.walk_parent_nodes(node_id, match_fn, match_non_returning_block)\n+            .ok()\n+            .map(|return_node_id| self.node_to_hir_id(return_node_id))\n     }\n \n     /// Retrieves the `NodeId` for `id`'s parent item, or `id` itself if no\n@@ -921,66 +929,52 @@ impl<'hir> Map<'hir> {\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn expect_item_by_hir_id(&self, id: HirId) -> &'hir Item {\n-        let node_id = self.hir_to_node_id(id);\n-        self.expect_item(node_id)\n+        match self.find_by_hir_id(id) { // read recorded by `find`\n+            Some(Node::Item(item)) => item,\n+            _ => bug!(\"expected item, found {}\", self.hir_to_string(id))\n+        }\n     }\n \n-    pub fn expect_impl_item(&self, id: NodeId) -> &'hir ImplItem {\n-        match self.find(id) {\n+    pub fn expect_impl_item(&self, id: HirId) -> &'hir ImplItem {\n+        match self.find_by_hir_id(id) {\n             Some(Node::ImplItem(item)) => item,\n-            _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected impl item, found {}\", self.hir_to_string(id))\n         }\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn expect_impl_item_by_hir_id(&self, id: HirId) -> &'hir ImplItem {\n-        let node_id = self.hir_to_node_id(id);\n-        self.expect_impl_item(node_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn expect_trait_item_by_hir_id(&self, id: HirId) -> &'hir TraitItem {\n-        let node_id = self.hir_to_node_id(id);\n-        self.expect_trait_item(node_id)\n-    }\n-\n-    pub fn expect_trait_item(&self, id: NodeId) -> &'hir TraitItem {\n-        match self.find(id) {\n+    pub fn expect_trait_item(&self, id: HirId) -> &'hir TraitItem {\n+        match self.find_by_hir_id(id) {\n             Some(Node::TraitItem(item)) => item,\n-            _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected trait item, found {}\", self.hir_to_string(id))\n         }\n     }\n \n     pub fn expect_variant_data(&self, id: HirId) -> &'hir VariantData {\n-        let id = self.hir_to_node_id(id); // FIXME(@ljedrz): remove when possible\n-\n-        match self.find(id) {\n+        match self.find_by_hir_id(id) {\n             Some(Node::Item(i)) => {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) |\n                     ItemKind::Union(ref struct_def, _) => struct_def,\n-                    _ => bug!(\"struct ID bound to non-struct {}\", self.node_to_string(id))\n+                    _ => bug!(\"struct ID bound to non-struct {}\", self.hir_to_string(id))\n                 }\n             }\n             Some(Node::StructCtor(data)) => data,\n             Some(Node::Variant(variant)) => &variant.node.data,\n-            _ => bug!(\"expected struct or variant, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected struct or variant, found {}\", self.hir_to_string(id))\n         }\n     }\n \n     pub fn expect_variant(&self, id: HirId) -> &'hir Variant {\n-        let id = self.hir_to_node_id(id); // FIXME(@ljedrz): remove when possible\n-\n-        match self.find(id) {\n+        match self.find_by_hir_id(id) {\n             Some(Node::Variant(variant)) => variant,\n-            _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n+            _ => bug!(\"expected variant, found {}\", self.hir_to_string(id)),\n         }\n     }\n \n-    pub fn expect_foreign_item(&self, id: NodeId) -> &'hir ForeignItem {\n-        match self.find(id) {\n+    pub fn expect_foreign_item(&self, id: HirId) -> &'hir ForeignItem {\n+        match self.find_by_hir_id(id) {\n             Some(Node::ForeignItem(item)) => item,\n-            _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected foreign item, found {}\", self.hir_to_string(id))\n         }\n     }\n \n@@ -1008,7 +1002,7 @@ impl<'hir> Map<'hir> {\n             Node::Field(f) => f.ident.name,\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n-            Node::Binding(&Pat { node: PatKind::Binding(_, _, _, l, _), .. }) => l.name,\n+            Node::Binding(&Pat { node: PatKind::Binding(_, _, l, _), .. }) => l.name,\n             Node::StructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }"}, {"sha": "88ab58d10fc34867e5926f43fd5f4c326f09a454", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 156, "deletions": 157, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -19,7 +19,7 @@ use errors::FatalError;\n use syntax_pos::{Span, DUMMY_SP, symbol::InternedString};\n use syntax::source_map::Spanned;\n use rustc_target::spec::abi::Abi;\n-use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n+use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, Lit, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::ext::hygiene::SyntaxContext;\n@@ -30,8 +30,9 @@ use syntax::util::parser::ExprPrecedence;\n use crate::ty::AdtKind;\n use crate::ty::query::Providers;\n \n-use rustc_data_structures::sync::{ParallelIterator, par_iter, Send, Sync};\n+use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_macros::HashStable;\n \n use serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::{BTreeSet, BTreeMap};\n@@ -112,19 +113,28 @@ impl serialize::UseSpecializedDecodable for HirId {\n     }\n }\n \n+impl fmt::Display for HirId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n // hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n mod item_local_id_inner {\n     use rustc_data_structures::indexed_vec::Idx;\n-    /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n-    /// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n-    /// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n-    /// the node's position within the owning item in any way, but there is a\n-    /// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n-    /// integers starting at zero, so a mapping that maps all or most nodes within\n-    /// an \"item-like\" to something else can be implement by a `Vec` instead of a\n-    /// tree or hash map.\n+    use rustc_macros::HashStable;\n     newtype_index! {\n-        pub struct ItemLocalId { .. }\n+        /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n+        /// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n+        /// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n+        /// the node's position within the owning item in any way, but there is a\n+        /// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n+        /// integers starting at zero, so a mapping that maps all or most nodes within\n+        /// an \"item-like\" to something else can be implement by a `Vec` instead of a\n+        /// tree or hash map.\n+        pub struct ItemLocalId {\n+            derive [HashStable]\n+        }\n     }\n }\n \n@@ -143,9 +153,8 @@ pub const DUMMY_HIR_ID: HirId = HirId {\n \n pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId::MAX;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Copy, HashStable)]\n pub struct Lifetime {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub span: Span,\n \n@@ -158,7 +167,7 @@ pub struct Lifetime {\n     pub name: LifetimeName,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, HashStable)]\n pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n     Plain(Ident),\n@@ -201,7 +210,7 @@ impl ParamName {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, HashStable)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(ParamName),\n@@ -266,7 +275,7 @@ impl fmt::Debug for Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f,\n                \"lifetime({}: {})\",\n-               self.id,\n+               self.hir_id,\n                print::to_string(print::NO_ANN, |s| s.print_lifetime(self)))\n     }\n }\n@@ -284,7 +293,7 @@ impl Lifetime {\n /// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Path {\n     pub span: Span,\n     /// The definition that the path resolved to.\n@@ -313,16 +322,16 @@ impl fmt::Display for Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     // `id` and `def` are optional. We currently only use these in save-analysis,\n     // any path segments without these will not have save-analysis info and\n     // therefore will not have 'jump to def' in IDEs, but otherwise will not be\n     // affected. (In general, we don't bother to get the defs for synthesized\n     // segments, only for segments which have come from the AST).\n-    pub id: Option<NodeId>,\n     pub hir_id: Option<HirId>,\n     pub def: Option<Def>,\n \n@@ -345,7 +354,6 @@ impl PathSegment {\n     pub fn from_ident(ident: Ident) -> PathSegment {\n         PathSegment {\n             ident,\n-            id: None,\n             hir_id: None,\n             def: None,\n             infer_types: true,\n@@ -355,15 +363,13 @@ impl PathSegment {\n \n     pub fn new(\n         ident: Ident,\n-        id: Option<NodeId>,\n         hir_id: Option<HirId>,\n         def: Option<Def>,\n         args: GenericArgs,\n         infer_types: bool,\n     ) -> Self {\n         PathSegment {\n             ident,\n-            id,\n             hir_id,\n             def,\n             infer_types,\n@@ -389,13 +395,13 @@ impl PathSegment {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ConstArg {\n     pub value: AnonConst,\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericArg {\n     Lifetime(Lifetime),\n     Type(Ty),\n@@ -411,16 +417,16 @@ impl GenericArg {\n         }\n     }\n \n-    pub fn id(&self) -> NodeId {\n+    pub fn id(&self) -> HirId {\n         match self {\n-            GenericArg::Lifetime(l) => l.id,\n-            GenericArg::Type(t) => t.id,\n-            GenericArg::Const(c) => c.value.id,\n+            GenericArg::Lifetime(l) => l.hir_id,\n+            GenericArg::Type(t) => t.hir_id,\n+            GenericArg::Const(c) => c.value.hir_id,\n         }\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GenericArgs {\n     /// The generic arguments for this path segment.\n     pub args: HirVec<GenericArg>,\n@@ -484,7 +490,7 @@ impl GenericArgs {\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum TraitBoundModifier {\n     None,\n     Maybe,\n@@ -494,7 +500,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -511,7 +517,7 @@ impl GenericBound {\n \n pub type GenericBounds = HirVec<GenericBound>;\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LifetimeParamKind {\n     // Indicates that the lifetime definition was explicitly declared (e.g., in\n     // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`).\n@@ -530,7 +536,7 @@ pub enum LifetimeParamKind {\n     Error,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericParamKind {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n@@ -545,9 +551,8 @@ pub enum GenericParamKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GenericParam {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub name: ParamName,\n     pub attrs: HirVec<Attribute>,\n@@ -567,7 +572,7 @@ pub struct GenericParamCount {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Generics {\n     pub params: HirVec<GenericParam>,\n     pub where_clause: WhereClause,\n@@ -579,7 +584,6 @@ impl Generics {\n         Generics {\n             params: HirVec::new(),\n             where_clause: WhereClause {\n-                id: DUMMY_NODE_ID,\n                 hir_id: DUMMY_HIR_ID,\n                 predicates: HirVec::new(),\n             },\n@@ -616,15 +620,14 @@ impl Generics {\n \n /// Synthetic type parameters are converted to another form during lowering; this allows\n /// us to track the original form they had, and is useful for error messages.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum SyntheticTyParamKind {\n     ImplTrait\n }\n \n /// A where-clause in a definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereClause {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub predicates: HirVec<WherePredicate>,\n }\n@@ -642,7 +645,7 @@ impl WhereClause {\n }\n \n /// A single predicate in a where-clause.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum WherePredicate {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate),\n@@ -663,7 +666,7 @@ impl WherePredicate {\n }\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n@@ -675,17 +678,16 @@ pub struct WhereBoundPredicate {\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds,\n }\n \n /// An equality predicate (e.g., `T = int`); currently unsupported.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereEqPredicate {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub lhs_ty: P<Ty>,\n@@ -781,15 +783,15 @@ impl Crate {\n         where V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send\n     {\n         parallel!({\n-            par_iter(&self.items).for_each(|(_, item)| {\n+            par_for_each_in(&self.items, |(_, item)| {\n                 visitor.visit_item(item);\n             });\n         }, {\n-            par_iter(&self.trait_items).for_each(|(_, trait_item)| {\n+            par_for_each_in(&self.trait_items, |(_, trait_item)| {\n                 visitor.visit_trait_item(trait_item);\n             });\n         }, {\n-            par_iter(&self.impl_items).for_each(|(_, impl_item)| {\n+            par_for_each_in(&self.impl_items, |(_, impl_item)| {\n                 visitor.visit_impl_item(impl_item);\n             });\n         });\n@@ -803,26 +805,25 @@ impl Crate {\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MacroDef {\n     pub name: Name,\n     pub vis: Visibility,\n     pub attrs: HirVec<Attribute>,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub body: TokenStream,\n     pub legacy: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Block {\n     /// Statements in a block.\n     pub stmts: HirVec<Stmt>,\n     /// An expression at the end of the block\n     /// without a semicolon, if any.\n     pub expr: Option<P<Expr>>,\n-    pub id: NodeId,\n+    #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n@@ -833,17 +834,17 @@ pub struct Block {\n     pub targeted_by_break: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Pat {\n-    pub id: NodeId,\n+    #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub node: PatKind,\n     pub span: Span,\n }\n \n impl fmt::Debug for Pat {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"pat({}: {})\", self.id,\n+        write!(f, \"pat({}: {})\", self.hir_id,\n                print::to_string(print::NO_ANN, |s| s.print_pat(self)))\n     }\n }\n@@ -896,11 +897,12 @@ impl Pat {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except `is_shorthand` is true.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FieldPat {\n-    pub id: NodeId,\n+    #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     /// The identifier for the field.\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     /// The pattern the field is destructured to.\n     pub pat: P<Pat>,\n@@ -910,7 +912,7 @@ pub struct FieldPat {\n /// Explicit binding annotations given in the HIR for a binding. Note\n /// that this is not the final binding *mode* that we infer after type\n /// inference.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum BindingAnnotation {\n     /// No binding annotation given: this means that the final binding mode\n     /// will depend on whether we have skipped through a `&` reference\n@@ -931,22 +933,22 @@ pub enum BindingAnnotation {\n     RefMut,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum RangeEnd {\n     Included,\n     Excluded,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n-    /// The `NodeId` is the canonical ID for the variable being bound,\n+    /// The `HirId` is the canonical ID for the variable being bound,\n     /// (e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID),\n     /// which is the pattern ID of the first `x`.\n-    Binding(BindingAnnotation, NodeId, HirId, Ident, Option<P<Pat>>),\n+    Binding(BindingAnnotation, HirId, Ident, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -982,7 +984,8 @@ pub enum PatKind {\n     Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum Mutability {\n     MutMutable,\n     MutImmutable,\n@@ -998,7 +1001,7 @@ impl Mutability {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash, HashStable)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1132,7 +1135,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash, HashStable)]\n pub enum UnOp {\n     /// The `*` operator (deferencing).\n     UnDeref,\n@@ -1163,20 +1166,19 @@ impl UnOp {\n /// A statement.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Stmt {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub node: StmtKind,\n     pub span: Span,\n }\n \n impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"stmt({}: {})\", self.id,\n+        write!(f, \"stmt({}: {})\", self.hir_id,\n                print::to_string(print::NO_ANN, |s| s.print_stmt(self)))\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum StmtKind {\n     /// A local (`let`) binding.\n     Local(P<Local>),\n@@ -1203,52 +1205,51 @@ impl StmtKind {\n }\n \n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Local {\n     pub pat: P<Pat>,\n     pub ty: Option<P<Ty>>,\n     /// Initializer expression to set the value, if any.\n     pub init: Option<P<Expr>>,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n     pub source: LocalSource,\n }\n \n /// Represents a single arm of a `match` expression.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arm {\n     pub attrs: HirVec<Attribute>,\n     pub pats: HirVec<P<Pat>>,\n     pub guard: Option<Guard>,\n     pub body: P<Expr>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Guard {\n     If(P<Expr>),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Field {\n-    pub id: NodeId,\n+    #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub ident: Ident,\n     pub expr: P<Expr>,\n     pub span: Span,\n     pub is_shorthand: bool,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n@@ -1324,17 +1325,15 @@ impl BodyOwnerKind {\n /// These are usually found nested inside types (e.g., array lengths)\n /// or expressions (e.g., repeat counts), and also used to define\n /// explicit discriminant values for enum variants.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct AnonConst {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub body: BodyId,\n }\n \n /// An expression\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Expr {\n-    pub id: NodeId,\n     pub span: Span,\n     pub node: ExprKind,\n     pub attrs: ThinVec<Attribute>,\n@@ -1437,12 +1436,12 @@ impl Expr {\n \n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"expr({}: {})\", self.id,\n+        write!(f, \"expr({}: {})\", self.hir_id,\n                print::to_string(print::NO_ANN, |s| s.print_expr(self)))\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n@@ -1548,7 +1547,7 @@ pub enum ExprKind {\n }\n \n /// Optionally `Self`-qualified value/type path or associated extension.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n@@ -1568,7 +1567,7 @@ pub enum QPath {\n }\n \n /// Hints at the original code for a let statement.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum LocalSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1577,7 +1576,7 @@ pub enum LocalSource {\n }\n \n /// Hints at the original code for a `match _ { .. }`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, HashStable)]\n pub enum MatchSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1595,7 +1594,7 @@ pub enum MatchSource {\n }\n \n /// The loop type that yielded an `ExprKind::Loop`.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n@@ -1605,7 +1604,7 @@ pub enum LoopSource {\n     ForLoop,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum LoopIdError {\n     OutsideLoopScope,\n     UnlabeledCfInWhileCondition,\n@@ -1623,38 +1622,39 @@ impl fmt::Display for LoopIdError {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub struct Destination {\n     // This is `Some(_)` iff there is an explicit user-specified `label\n     pub label: Option<Label>,\n \n     // These errors are caught and then reported during the diagnostics pass in\n     // librustc_passes/loops.rs\n-    pub target_id: Result<NodeId, LoopIdError>,\n+    pub target_id: Result<HirId, LoopIdError>,\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum GeneratorMovability {\n     Static,\n     Movable,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum CaptureClause {\n     CaptureByValue,\n     CaptureByRef,\n }\n \n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a method's signature in a trait declaration or implementation.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MethodSig {\n     pub header: FnHeader,\n     pub decl: P<FnDecl>,\n@@ -1665,7 +1665,7 @@ pub struct MethodSig {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitItemId {\n-    pub node_id: NodeId,\n+    pub hir_id: HirId,\n }\n \n /// Represents an item declaration within a trait declaration,\n@@ -1674,7 +1674,6 @@ pub struct TraitItemId {\n /// signature) or provided (meaning it has a default implementation).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitItem {\n-    pub id: NodeId,\n     pub ident: Ident,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n@@ -1684,7 +1683,7 @@ pub struct TraitItem {\n }\n \n /// A trait method's body (or just argument names).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitMethod {\n     /// No default body in the trait, just a signature.\n     Required(HirVec<Ident>),\n@@ -1694,7 +1693,7 @@ pub enum TraitMethod {\n }\n \n /// Represents a trait method or associated constant or type\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitItemKind {\n     /// An associated constant with an optional value (otherwise `impl`s\n     /// must contain a value)\n@@ -1711,13 +1710,12 @@ pub enum TraitItemKind {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItemId {\n-    pub node_id: NodeId,\n+    pub hir_id: HirId,\n }\n \n /// Represents anything within an `impl` block\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItem {\n-    pub id: NodeId,\n     pub ident: Ident,\n     pub hir_id: HirId,\n     pub vis: Visibility,\n@@ -1729,7 +1727,7 @@ pub struct ImplItem {\n }\n \n /// Represents different contents within `impl`s\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ImplItemKind {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression\n@@ -1743,18 +1741,17 @@ pub enum ImplItemKind {\n }\n \n // Bind a type to an associated type: `A=Foo`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TypeBinding {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub ty: P<Ty>,\n     pub span: Span,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n-    pub id: NodeId,\n     pub node: TyKind,\n     pub span: Span,\n     pub hir_id: HirId,\n@@ -1768,7 +1765,7 @@ impl fmt::Debug for Ty {\n }\n \n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, HashStable)]\n pub enum PrimTy {\n     Int(IntTy),\n     Uint(UintTy),\n@@ -1778,7 +1775,7 @@ pub enum PrimTy {\n     Char,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n@@ -1787,15 +1784,15 @@ pub struct BareFnTy {\n     pub arg_names: HirVec<Ident>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ExistTy {\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n     pub impl_trait_fn: Option<DefId>,\n }\n \n /// The various kinds of types recognized by the compiler.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TyKind {\n     /// A variable length slice (i.e., `[T]`).\n     Slice(P<Ty>),\n@@ -1832,17 +1829,20 @@ pub enum TyKind {\n     Infer,\n     /// Placeholder for a type that has failed to be defined.\n     Err,\n+    /// Placeholder for C-variadic arguments. We \"spoof\" the `VaList` created\n+    /// from the variadic arguments. This type is only valid up to typeck.\n+    CVarArgs(Lifetime),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct InlineAsmOutput {\n     pub constraint: Symbol,\n     pub is_rw: bool,\n     pub is_indirect: bool,\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct InlineAsm {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n@@ -1852,29 +1852,29 @@ pub struct InlineAsm {\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n+    #[stable_hasher(ignore)] // This is used for error reporting\n     pub ctxt: SyntaxContext,\n }\n \n /// Represents an argument in a function header.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arg {\n     pub pat: P<Pat>,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n }\n \n /// Represents the header (not the body) of a function declaration.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnDecl {\n     pub inputs: HirVec<Ty>,\n     pub output: FunctionRetTy,\n-    pub variadic: bool,\n+    pub c_variadic: bool,\n     /// Does the function have an implicit self?\n     pub implicit_self: ImplicitSelfKind,\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -1900,31 +1900,33 @@ impl ImplicitSelfKind {\n }\n \n /// Is the trait definition an auto trait?\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum IsAuto {\n     Yes,\n     No\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, HashStable,\n+         Ord, RustcEncodable, RustcDecodable, Debug)]\n pub enum IsAsync {\n     Async,\n     NotAsync,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Unsafety {\n     Unsafe,\n     Normal,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Constness {\n     Const,\n     NotConst,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Defaultness {\n     Default { has_value: bool },\n     Final,\n@@ -1960,7 +1962,7 @@ impl fmt::Display for Unsafety {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ImplPolarity {\n     /// `impl Trait for Type`\n     Positive,\n@@ -1978,7 +1980,7 @@ impl fmt::Debug for ImplPolarity {\n }\n \n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum FunctionRetTy {\n     /// Return type is not specified.\n     ///\n@@ -2017,25 +2019,27 @@ pub struct Mod {\n     pub item_ids: HirVec<ItemId>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub items: HirVec<ForeignItem>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n+    #[stable_hasher(ignore)] // This is used for error reporting\n     pub ctxt: SyntaxContext,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct EnumDef {\n     pub variants: HirVec<Variant>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct VariantKind {\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n@@ -2045,7 +2049,7 @@ pub struct VariantKind {\n \n pub type Variant = Spanned<VariantKind>;\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n@@ -2067,10 +2071,11 @@ pub enum UseKind {\n /// that the ref_id is for. Note that ref_id's value is not the NodeId of the\n /// trait being referred to but just a unique NodeId that serves as a key\n /// within the DefMap.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitRef {\n     pub path: Path,\n-    pub ref_id: NodeId,\n+    // Don't hash the ref_id. It is tracked via the thing it is used to access\n+    #[stable_hasher(ignore)]\n     pub hir_ref_id: HirId,\n }\n \n@@ -2088,7 +2093,7 @@ impl TraitRef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: HirVec<GenericParam>,\n@@ -2105,7 +2110,7 @@ pub type Visibility = Spanned<VisibilityKind>;\n pub enum VisibilityKind {\n     Public,\n     Crate(CrateSugar),\n-    Restricted { path: P<Path>, id: NodeId, hir_id: HirId },\n+    Restricted { path: P<Path>, hir_id: HirId },\n     Inherited,\n }\n \n@@ -2136,12 +2141,12 @@ impl VisibilityKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct StructField {\n     pub span: Span,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub vis: Visibility,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub ty: P<Ty>,\n     pub attrs: HirVec<Attribute>,\n@@ -2166,11 +2171,11 @@ impl StructField {\n /// used for `Struct`-structs (but still present). Structures don't have an analogue of \"Id of\n /// the variant itself\" from enum variants.\n /// Id of the whole struct lives in `Item`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum VariantData {\n-    Struct(HirVec<StructField>, NodeId, HirId),\n-    Tuple(HirVec<StructField>, NodeId, HirId),\n-    Unit(NodeId, HirId),\n+    Struct(HirVec<StructField>, HirId),\n+    Tuple(HirVec<StructField>, HirId),\n+    Unit(HirId),\n }\n \n impl VariantData {\n@@ -2180,18 +2185,11 @@ impl VariantData {\n             _ => &[],\n         }\n     }\n-    pub fn id(&self) -> NodeId {\n-        match *self {\n-            VariantData::Struct(_, id, ..)\n-            | VariantData::Tuple(_, id, ..)\n-            | VariantData::Unit(id, ..) => id,\n-        }\n-    }\n     pub fn hir_id(&self) -> HirId {\n         match *self {\n-            VariantData::Struct(_, _, hir_id)\n-            | VariantData::Tuple(_, _, hir_id)\n-            | VariantData::Unit(_, hir_id) => hir_id,\n+            VariantData::Struct(_, hir_id)\n+            | VariantData::Tuple(_, hir_id)\n+            | VariantData::Unit(hir_id) => hir_id,\n         }\n     }\n     pub fn is_struct(&self) -> bool {\n@@ -2231,23 +2229,22 @@ pub struct ItemId {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Item {\n     pub ident: Ident,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n     pub node: ItemKind,\n     pub vis: Visibility,\n     pub span: Span,\n }\n \n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub constness: Constness,\n     pub asyncness: IsAsync,\n     pub abi: Abi,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n@@ -2350,9 +2347,10 @@ impl ItemKind {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub kind: AssociatedItemKind,\n     pub span: Span,\n@@ -2365,37 +2363,38 @@ pub struct TraitItemRef {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ImplItemRef {\n     pub id: ImplItemId,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub kind: AssociatedItemKind,\n     pub span: Span,\n     pub vis: Visibility,\n     pub defaultness: Defaultness,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum AssociatedItemKind {\n     Const,\n     Method { has_self: bool },\n     Type,\n     Existential,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ForeignItem {\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub attrs: HirVec<Attribute>,\n     pub node: ForeignItemKind,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub vis: Visibility,\n }\n \n /// An item within an `extern` block.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ForeignItemKind {\n     /// A foreign function.\n     Fn(P<FnDecl>, HirVec<Ident>, Generics),\n@@ -2417,7 +2416,7 @@ impl ForeignItemKind {\n }\n \n /// A free variable referred to in a function.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Freevar {\n     /// The variable being accessed free.\n     pub def: Def,\n@@ -2458,7 +2457,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.describe_def = map::describe_def;\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct CodegenFnAttrs {\n     pub flags: CodegenFnAttrFlags,\n     /// Parsed representation of the `#[inline]` attribute\n@@ -2484,7 +2483,7 @@ pub struct CodegenFnAttrs {\n }\n \n bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable)]\n+    #[derive(RustcEncodable, RustcDecodable, HashStable)]\n     pub struct CodegenFnAttrFlags: u32 {\n         /// `#[cold]`: a hint to LLVM that this function, when called, is never on\n         /// the hot path."}, {"sha": "18a3d6708db64c815a1465b630b44a606c3bb58d", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -70,7 +70,7 @@ impl hir::Pat {\n         where F: FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n     {\n         self.walk(|p| {\n-            if let PatKind::Binding(binding_mode, _, _, ident, _) = p.node {\n+            if let PatKind::Binding(binding_mode, _, ident, _) = p.node {\n                 f(binding_mode, p.hir_id, p.span, ident);\n             }\n             true\n@@ -110,8 +110,8 @@ impl hir::Pat {\n \n     pub fn simple_ident(&self) -> Option<ast::Ident> {\n         match self.node {\n-            PatKind::Binding(hir::BindingAnnotation::Unannotated, _, _, ident, None) |\n-            PatKind::Binding(hir::BindingAnnotation::Mutable, _, _, ident, None) => Some(ident),\n+            PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, None) |\n+            PatKind::Binding(hir::BindingAnnotation::Mutable, _, ident, None) => Some(ident),\n             _ => None,\n         }\n     }"}, {"sha": "54a21f2ed5c2a8c519d020d525d2a55ca31c18c0", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -25,7 +25,7 @@ pub enum AnnNode<'a> {\n     Name(&'a ast::Name),\n     Block(&'a hir::Block),\n     Item(&'a hir::Item),\n-    SubItem(ast::NodeId),\n+    SubItem(hir::HirId),\n     Expr(&'a hir::Expr),\n     Pat(&'a hir::Pat),\n }\n@@ -434,6 +434,9 @@ impl<'a> State<'a> {\n                 self.s.word(\"/*ERROR*/\")?;\n                 self.pclose()?;\n             }\n+            hir::TyKind::CVarArgs(_) => {\n+                self.s.word(\"...\")?;\n+            }\n         }\n         self.end()\n     }\n@@ -924,7 +927,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem) -> io::Result<()> {\n-        self.ann.pre(self, AnnNode::SubItem(ti.id))?;\n+        self.ann.pre(self, AnnNode::SubItem(ti.hir_id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ti.span.lo())?;\n         self.print_outer_attributes(&ti.attrs)?;\n@@ -956,11 +959,11 @@ impl<'a> State<'a> {\n                                            default.as_ref().map(|ty| &**ty))?;\n             }\n         }\n-        self.ann.post(self, AnnNode::SubItem(ti.id))\n+        self.ann.post(self, AnnNode::SubItem(ti.hir_id))\n     }\n \n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem) -> io::Result<()> {\n-        self.ann.pre(self, AnnNode::SubItem(ii.id))?;\n+        self.ann.pre(self, AnnNode::SubItem(ii.hir_id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ii.span.lo())?;\n         self.print_outer_attributes(&ii.attrs)?;\n@@ -986,7 +989,7 @@ impl<'a> State<'a> {\n                 self.print_associated_type(ii.ident, Some(bounds), None)?;\n             }\n         }\n-        self.ann.post(self, AnnNode::SubItem(ii.id))\n+        self.ann.post(self, AnnNode::SubItem(ii.hir_id))\n     }\n \n     pub fn print_stmt(&mut self, st: &hir::Stmt) -> io::Result<()> {\n@@ -1762,7 +1765,7 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.node {\n             PatKind::Wild => self.s.word(\"_\")?,\n-            PatKind::Binding(binding_mode, _, _, ident, ref sub) => {\n+            PatKind::Binding(binding_mode, _, ident, ref sub) => {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\")?;\n@@ -2004,7 +2007,7 @@ impl<'a> State<'a> {\n             s.print_type(ty)?;\n             s.end()\n         })?;\n-        if decl.variadic {\n+        if decl.c_variadic {\n             self.s.word(\", ...\")?;\n         }\n         self.pclose()?;\n@@ -2248,7 +2251,6 @@ impl<'a> State<'a> {\n         let generics = hir::Generics {\n             params: hir::HirVec::new(),\n             where_clause: hir::WhereClause {\n-                id: ast::DUMMY_NODE_ID,\n                 hir_id: hir::DUMMY_HIR_ID,\n                 predicates: hir::HirVec::new(),\n             },"}, {"sha": "17ed1a79d45e0ae293a3248b1b3d750e0995cdb5", "filename": "src/librustc/ich/impls_cstore.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5c7ec6c421af26666d3ec1c5fe022d099133951c/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7ec6c421af26666d3ec1c5fe022d099133951c/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=5c7ec6c421af26666d3ec1c5fe022d099133951c", "patch": "@@ -1,53 +0,0 @@\n-//! This module contains `HashStable` implementations for various data types\n-//! from rustc::middle::cstore in no particular order.\n-\n-impl_stable_hash_for!(enum crate::middle::cstore::DepKind {\n-    UnexportedMacrosOnly,\n-    MacrosOnly,\n-    Implicit,\n-    Explicit\n-});\n-\n-impl_stable_hash_for!(enum crate::middle::cstore::NativeLibraryKind {\n-    NativeStatic,\n-    NativeStaticNobundle,\n-    NativeFramework,\n-    NativeUnknown\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::cstore::NativeLibrary {\n-    kind,\n-    name,\n-    cfg,\n-    foreign_module,\n-    wasm_import_module\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::cstore::ForeignModule {\n-    foreign_items,\n-    def_id\n-});\n-\n-impl_stable_hash_for!(enum crate::middle::cstore::LinkagePreference {\n-    RequireDynamic,\n-    RequireStatic\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::cstore::ExternCrate {\n-    src,\n-    span,\n-    path_len,\n-    direct\n-});\n-\n-impl_stable_hash_for!(enum crate::middle::cstore::ExternCrateSource {\n-    Extern(def_id),\n-    Use,\n-    Path,\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::cstore::CrateSource {\n-    dylib,\n-    rlib,\n-    rmeta\n-});"}, {"sha": "9491a073b8f8c35d076504849508b1d9e84c7ed7", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 787, "changes": 792, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -69,15 +69,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for CrateNum {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::ItemLocalId {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.as_u32().hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl<'a> ToStableHashKey<StableHashingContext<'a>>\n for hir::ItemLocalId {\n     type KeyType = hir::ItemLocalId;\n@@ -116,11 +107,11 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItemId {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItemId {\n-            node_id\n+            hir_id\n         } = * self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            node_id.hash_stable(hcx, hasher);\n+            hir_id.hash_stable(hcx, hasher);\n         })\n     }\n }\n@@ -130,195 +121,26 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItemId {\n-            node_id\n+            hir_id\n         } = * self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            node_id.hash_stable(hcx, hasher);\n+            hir_id.hash_stable(hcx, hasher);\n         })\n     }\n }\n \n-impl_stable_hash_for!(enum hir::ParamName {\n-    Plain(name),\n-    Fresh(index),\n-    Error,\n-});\n-\n-impl_stable_hash_for!(enum hir::LifetimeName {\n-    Param(param_name),\n-    Implicit,\n-    Underscore,\n-    Static,\n-    Error,\n-});\n \n impl_stable_hash_for!(struct ast::Label {\n     ident\n });\n \n-impl_stable_hash_for!(struct hir::Lifetime {\n-    id,\n-    hir_id,\n-    span,\n-    name\n-});\n-\n-impl_stable_hash_for!(struct hir::Path {\n-    span,\n-    def,\n-    segments\n-});\n-\n-impl_stable_hash_for!(struct hir::PathSegment {\n-    ident -> (ident.name),\n-    id,\n-    hir_id,\n-    def,\n-    infer_types,\n-    args\n-});\n-\n-impl_stable_hash_for!(struct hir::ConstArg {\n-    value,\n-    span,\n-});\n-\n-impl_stable_hash_for!(enum hir::GenericArg {\n-    Lifetime(lt),\n-    Type(ty),\n-    Const(ct),\n-});\n-\n-impl_stable_hash_for!(struct hir::GenericArgs {\n-    args,\n-    bindings,\n-    parenthesized\n-});\n-\n-impl_stable_hash_for!(enum hir::GenericBound {\n-    Trait(poly_trait_ref, trait_bound_modifier),\n-    Outlives(lifetime)\n-});\n-\n-impl_stable_hash_for!(enum hir::TraitBoundModifier {\n-    None,\n-    Maybe\n-});\n-\n-impl_stable_hash_for!(struct hir::GenericParam {\n-    id,\n-    hir_id,\n-    name,\n-    pure_wrt_drop,\n-    attrs,\n-    bounds,\n-    span,\n-    kind\n-});\n-\n-impl_stable_hash_for!(enum hir::LifetimeParamKind {\n-    Explicit,\n-    InBand,\n-    Elided,\n-    Error,\n-});\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::GenericParamKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            hir::GenericParamKind::Lifetime { kind } => {\n-                kind.hash_stable(hcx, hasher);\n-            }\n-            hir::GenericParamKind::Type { ref default, synthetic } => {\n-                default.hash_stable(hcx, hasher);\n-                synthetic.hash_stable(hcx, hasher);\n-            }\n-            hir::GenericParamKind::Const { ref ty } => {\n-                ty.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct hir::Generics {\n-    params,\n-    where_clause,\n-    span\n-});\n-\n-impl_stable_hash_for!(enum hir::SyntheticTyParamKind {\n-    ImplTrait\n-});\n-\n-impl_stable_hash_for!(struct hir::WhereClause {\n-    id,\n-    hir_id,\n-    predicates\n-});\n-\n-impl_stable_hash_for!(enum hir::WherePredicate {\n-    BoundPredicate(pred),\n-    RegionPredicate(pred),\n-    EqPredicate(pred)\n-});\n-\n-impl_stable_hash_for!(struct hir::WhereBoundPredicate {\n-    span,\n-    bound_generic_params,\n-    bounded_ty,\n-    bounds\n-});\n-\n-impl_stable_hash_for!(struct hir::WhereRegionPredicate {\n-    span,\n-    lifetime,\n-    bounds\n-});\n-\n-impl_stable_hash_for!(struct hir::WhereEqPredicate {\n-    id,\n-    hir_id,\n-    span,\n-    lhs_ty,\n-    rhs_ty\n-});\n-\n-impl_stable_hash_for!(struct hir::MutTy {\n-    ty,\n-    mutbl\n-});\n-\n-impl_stable_hash_for!(struct hir::MethodSig {\n-    header,\n-    decl\n-});\n-\n-impl_stable_hash_for!(struct hir::TypeBinding {\n-    id,\n-    hir_id,\n-    ident -> (ident.name),\n-    ty,\n-    span\n-});\n-\n-impl_stable_hash_for!(struct hir::FnHeader {\n-    unsafety,\n-    constness,\n-    asyncness,\n-    abi\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n-                id: _,\n                 hir_id: _,\n                 ref node,\n                 ref span,\n@@ -330,243 +152,25 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::PrimTy {\n-    Int(int_ty),\n-    Uint(uint_ty),\n-    Float(float_ty),\n-    Str,\n-    Bool,\n-    Char\n-});\n-\n-impl_stable_hash_for!(struct hir::BareFnTy {\n-    unsafety,\n-    abi,\n-    generic_params,\n-    decl,\n-    arg_names\n-});\n-\n-impl_stable_hash_for!(struct hir::ExistTy {\n-    generics,\n-    impl_trait_fn,\n-    bounds\n-});\n-\n-impl_stable_hash_for!(enum hir::TyKind {\n-    Slice(t),\n-    Array(t, body_id),\n-    Ptr(t),\n-    Rptr(lifetime, t),\n-    BareFn(t),\n-    Never,\n-    Tup(ts),\n-    Path(qpath),\n-    Def(it, lt),\n-    TraitObject(trait_refs, lifetime),\n-    Typeof(body_id),\n-    Err,\n-    Infer\n-});\n-\n-impl_stable_hash_for!(struct hir::FnDecl {\n-    inputs,\n-    output,\n-    variadic,\n-    implicit_self\n-});\n-\n-impl_stable_hash_for!(enum hir::FunctionRetTy {\n-    DefaultReturn(span),\n-    Return(t)\n-});\n-\n-impl_stable_hash_for!(enum hir::ImplicitSelfKind {\n-    Imm,\n-    Mut,\n-    ImmRef,\n-    MutRef,\n-    None\n-});\n-\n-impl_stable_hash_for!(struct hir::TraitRef {\n-    // Don't hash the ref_id. It is tracked via the thing it is used to access\n-    ref_id -> _,\n-    hir_ref_id -> _,\n-    path,\n-});\n-\n-impl_stable_hash_for!(struct hir::PolyTraitRef {\n-    bound_generic_params,\n-    trait_ref,\n-    span\n-});\n-\n-impl_stable_hash_for!(enum hir::QPath {\n-    Resolved(t, path),\n-    TypeRelative(t, path_segment)\n-});\n-\n-impl_stable_hash_for!(struct hir::MacroDef {\n-    name,\n-    vis,\n-    attrs,\n-    id,\n-    hir_id,\n-    span,\n-    legacy,\n-    body\n-});\n-\n-impl_stable_hash_for!(struct hir::Block {\n-    stmts,\n-    expr,\n-    id -> _,\n-    hir_id -> _,\n-    rules,\n-    span,\n-    targeted_by_break,\n-});\n-\n-impl_stable_hash_for!(struct hir::Pat {\n-    id -> _,\n-    hir_id -> _,\n-    node,\n-    span,\n-});\n-\n impl_stable_hash_for_spanned!(hir::FieldPat);\n \n-impl_stable_hash_for!(struct hir::FieldPat {\n-    id -> _,\n-    hir_id -> _,\n-    ident -> (ident.name),\n-    pat,\n-    is_shorthand,\n-});\n-\n-impl_stable_hash_for!(enum hir::BindingAnnotation {\n-    Unannotated,\n-    Mutable,\n-    Ref,\n-    RefMut\n-});\n-\n-impl_stable_hash_for!(enum hir::RangeEnd {\n-    Included,\n-    Excluded\n-});\n-\n-impl_stable_hash_for!(enum hir::PatKind {\n-    Wild,\n-    Binding(binding_mode, var, hir_id, name, sub),\n-    Struct(path, field_pats, dotdot),\n-    TupleStruct(path, field_pats, dotdot),\n-    Path(path),\n-    Tuple(field_pats, dotdot),\n-    Box(sub),\n-    Ref(sub, mutability),\n-    Lit(expr),\n-    Range(start, end, end_kind),\n-    Slice(one, two, three)\n-});\n-\n-impl_stable_hash_for!(enum hir::BinOpKind {\n-    Add,\n-    Sub,\n-    Mul,\n-    Div,\n-    Rem,\n-    And,\n-    Or,\n-    BitXor,\n-    BitAnd,\n-    BitOr,\n-    Shl,\n-    Shr,\n-    Eq,\n-    Lt,\n-    Le,\n-    Ne,\n-    Ge,\n-    Gt\n-});\n-\n impl_stable_hash_for_spanned!(hir::BinOpKind);\n \n-impl_stable_hash_for!(enum hir::UnOp {\n-    UnDeref,\n-    UnNot,\n-    UnNeg\n-});\n-\n impl_stable_hash_for!(struct hir::Stmt {\n-    id,\n     hir_id,\n     node,\n     span,\n });\n \n \n-impl_stable_hash_for!(struct hir::Local {\n-    pat,\n-    ty,\n-    init,\n-    id,\n-    hir_id,\n-    span,\n-    attrs,\n-    source\n-});\n-\n-impl_stable_hash_for!(struct hir::Arm {\n-    attrs,\n-    pats,\n-    guard,\n-    body\n-});\n-\n-impl_stable_hash_for!(enum hir::Guard {\n-    If(expr),\n-});\n-\n-impl_stable_hash_for!(struct hir::Field {\n-    id -> _,\n-    hir_id -> _,\n-    ident,\n-    expr,\n-    span,\n-    is_shorthand,\n-});\n-\n impl_stable_hash_for_spanned!(ast::Name);\n \n-\n-impl_stable_hash_for!(enum hir::BlockCheckMode {\n-    DefaultBlock,\n-    UnsafeBlock(src),\n-    PushUnsafeBlock(src),\n-    PopUnsafeBlock(src)\n-});\n-\n-impl_stable_hash_for!(enum hir::UnsafeSource {\n-    CompilerGenerated,\n-    UserProvided\n-});\n-\n-impl_stable_hash_for!(struct hir::AnonConst {\n-    id,\n-    hir_id,\n-    body\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n-                id: _,\n                 hir_id: _,\n                 ref span,\n                 ref node,\n@@ -580,96 +184,10 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::ExprKind {\n-    Box(sub),\n-    Array(subs),\n-    Call(callee, args),\n-    MethodCall(segment, span, args),\n-    Tup(fields),\n-    Binary(op, lhs, rhs),\n-    Unary(op, operand),\n-    Lit(value),\n-    Cast(expr, t),\n-    Type(expr, t),\n-    If(cond, then, els),\n-    While(cond, body, label),\n-    Loop(body, label, loop_src),\n-    Match(matchee, arms, match_src),\n-    Closure(capture_clause, decl, body_id, span, gen),\n-    Block(blk, label),\n-    Assign(lhs, rhs),\n-    AssignOp(op, lhs, rhs),\n-    Field(owner, ident),\n-    Index(lhs, rhs),\n-    Path(path),\n-    AddrOf(mutability, sub),\n-    Break(destination, sub),\n-    Continue(destination),\n-    Ret(val),\n-    InlineAsm(asm, inputs, outputs),\n-    Struct(path, fields, base),\n-    Repeat(val, times),\n-    Yield(val),\n-    Err\n-});\n-\n-impl_stable_hash_for!(enum hir::LocalSource {\n-    Normal,\n-    ForLoopDesugar\n-});\n-\n-impl_stable_hash_for!(enum hir::LoopSource {\n-    Loop,\n-    WhileLet,\n-    ForLoop\n-});\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::MatchSource {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::hir::MatchSource;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            MatchSource::Normal |\n-            MatchSource::WhileLetDesugar |\n-            MatchSource::ForLoopDesugar |\n-            MatchSource::TryDesugar => {\n-                // No fields to hash.\n-            }\n-            MatchSource::IfLetDesugar { contains_else_clause } => {\n-                contains_else_clause.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum hir::GeneratorMovability {\n-    Static,\n-    Movable\n-});\n-\n-impl_stable_hash_for!(enum hir::CaptureClause {\n-    CaptureByValue,\n-    CaptureByRef\n-});\n-\n impl_stable_hash_for_spanned!(usize);\n \n-impl_stable_hash_for!(struct hir::Destination {\n-    label,\n-    target_id\n-});\n-\n impl_stable_hash_for_spanned!(ast::Ident);\n \n-impl_stable_hash_for!(enum hir::LoopIdError {\n-    OutsideLoopScope,\n-    UnlabeledCfInWhileCondition,\n-    UnresolvedLabel\n-});\n-\n impl_stable_hash_for!(struct ast::Ident {\n     name,\n     span,\n@@ -680,7 +198,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n-            id: _,\n             hir_id: _,\n             ident,\n             ref attrs,\n@@ -699,23 +216,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::TraitMethod {\n-    Required(name),\n-    Provided(body)\n-});\n-\n-impl_stable_hash_for!(enum hir::TraitItemKind {\n-    Const(t, body),\n-    Method(sig, method),\n-    Type(bounds, rhs)\n-});\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n-            id: _,\n             hir_id: _,\n             ident,\n             ref vis,\n@@ -738,13 +244,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::ImplItemKind {\n-    Const(t, body),\n-    Method(sig, body),\n-    Existential(bounds),\n-    Type(t)\n-});\n-\n impl_stable_hash_for!(enum ::syntax::ast::CrateSugar {\n     JustCrate,\n     PubCrate,\n@@ -763,9 +262,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n             hir::VisibilityKind::Crate(sugar) => {\n                 sugar.hash_stable(hcx, hasher);\n             }\n-            hir::VisibilityKind::Restricted { ref path, id, hir_id } => {\n+            hir::VisibilityKind::Restricted { ref path, hir_id } => {\n                 hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                    id.hash_stable(hcx, hasher);\n                     hir_id.hash_stable(hcx, hasher);\n                 });\n                 path.hash_stable(hcx, hasher);\n@@ -776,27 +274,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n \n impl_stable_hash_for_spanned!(hir::VisibilityKind);\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Defaultness {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            hir::Defaultness::Final => {\n-                // No fields to hash.\n-            }\n-            hir::Defaultness::Default { has_value } => {\n-                has_value.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum hir::ImplPolarity {\n-    Positive,\n-    Negative\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -826,45 +303,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     }\n }\n \n-impl_stable_hash_for!(struct hir::ForeignMod {\n-    abi,\n-    items\n-});\n-\n-impl_stable_hash_for!(struct hir::EnumDef {\n-    variants\n-});\n-\n-impl_stable_hash_for!(struct hir::VariantKind {\n-    ident -> (ident.name),\n-    attrs,\n-    data,\n-    disr_expr\n-});\n-\n impl_stable_hash_for_spanned!(hir::VariantKind);\n \n-impl_stable_hash_for!(enum hir::UseKind {\n-    Single,\n-    Glob,\n-    ListStem\n-});\n-\n-impl_stable_hash_for!(struct hir::StructField {\n-    span,\n-    ident -> (ident.name),\n-    vis,\n-    id,\n-    hir_id,\n-    ty,\n-    attrs\n-});\n-\n-impl_stable_hash_for!(enum hir::VariantData {\n-    Struct(fields, id, hir_id),\n-    Tuple(fields, id, hir_id),\n-    Unit(id, hir_id)\n-});\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -873,7 +313,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n         let hir::Item {\n             ident,\n             ref attrs,\n-            id: _,\n             hir_id: _,\n             ref node,\n             ref vis,\n@@ -890,89 +329,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::ItemKind {\n-    ExternCrate(orig_name),\n-    Use(path, use_kind),\n-    Static(ty, mutability, body_id),\n-    Const(ty, body_id),\n-    Fn(fn_decl, header, generics, body_id),\n-    Mod(module),\n-    ForeignMod(foreign_mod),\n-    GlobalAsm(global_asm),\n-    Ty(ty, generics),\n-    Existential(exist),\n-    Enum(enum_def, generics),\n-    Struct(variant_data, generics),\n-    Union(variant_data, generics),\n-    Trait(is_auto, unsafety, generics, bounds, item_refs),\n-    TraitAlias(generics, bounds),\n-    Impl(unsafety, impl_polarity, impl_defaultness, generics, trait_ref, ty, impl_item_refs)\n-});\n-\n-impl_stable_hash_for!(struct hir::TraitItemRef {\n-    id,\n-    ident -> (ident.name),\n-    kind,\n-    span,\n-    defaultness\n-});\n-\n-impl_stable_hash_for!(struct hir::ImplItemRef {\n-    id,\n-    ident -> (ident.name),\n-    kind,\n-    span,\n-    vis,\n-    defaultness\n-});\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::AssociatedItemKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            hir::AssociatedItemKind::Const |\n-            hir::AssociatedItemKind::Existential |\n-            hir::AssociatedItemKind::Type => {\n-                // No fields to hash.\n-            }\n-            hir::AssociatedItemKind::Method { has_self } => {\n-                has_self.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct hir::ForeignItem {\n-    ident -> (ident.name),\n-    attrs,\n-    node,\n-    id,\n-    hir_id,\n-    span,\n-    vis\n-});\n-\n-impl_stable_hash_for!(enum hir::ForeignItemKind {\n-    Fn(fn_decl, arg_names, generics),\n-    Static(ty, is_mutbl),\n-    Type\n-});\n-\n-impl_stable_hash_for!(enum hir::StmtKind {\n-    Local(local),\n-    Item(item_id),\n-    Expr(expr),\n-    Semi(expr)\n-});\n-\n-impl_stable_hash_for!(struct hir::Arg {\n-    pat,\n-    id,\n-    hir_id\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -1003,103 +359,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::BodyId {\n     }\n }\n \n-impl_stable_hash_for!(struct hir::InlineAsmOutput {\n-    constraint,\n-    is_rw,\n-    is_indirect,\n-    span\n-});\n-\n-impl_stable_hash_for!(struct hir::GlobalAsm {\n-    asm,\n-    ctxt -> _, // This is used for error reporting\n-});\n-\n-impl_stable_hash_for!(struct hir::InlineAsm {\n-    asm,\n-    asm_str_style,\n-    outputs,\n-    inputs,\n-    clobbers,\n-    volatile,\n-    alignstack,\n-    dialect,\n-    ctxt -> _, // This is used for error reporting\n-});\n-\n-impl_stable_hash_for!(enum hir::def::CtorKind {\n-    Fn,\n-    Const,\n-    Fictive\n-});\n-\n-impl_stable_hash_for!(enum hir::def::NonMacroAttrKind {\n-    Builtin,\n-    Tool,\n-    DeriveHelper,\n-    LegacyPluginHelper,\n-    Custom,\n-});\n-\n-impl_stable_hash_for!(enum hir::def::Def {\n-    Mod(def_id),\n-    Struct(def_id),\n-    Union(def_id),\n-    Enum(def_id),\n-    Existential(def_id),\n-    Variant(def_id),\n-    Trait(def_id),\n-    TyAlias(def_id),\n-    TraitAlias(def_id),\n-    AssociatedTy(def_id),\n-    AssociatedExistential(def_id),\n-    PrimTy(prim_ty),\n-    TyParam(def_id),\n-    ConstParam(def_id),\n-    SelfTy(trait_def_id, impl_def_id),\n-    ForeignTy(def_id),\n-    Fn(def_id),\n-    Const(def_id),\n-    Static(def_id, is_mutbl),\n-    StructCtor(def_id, ctor_kind),\n-    SelfCtor(impl_def_id),\n-    VariantCtor(def_id, ctor_kind),\n-    Method(def_id),\n-    AssociatedConst(def_id),\n-    Local(def_id),\n-    Upvar(def_id, index, expr_id),\n-    Label(node_id),\n-    Macro(def_id, macro_kind),\n-    ToolMod,\n-    NonMacroAttr(attr_kind),\n-    Err\n-});\n-\n-impl_stable_hash_for!(enum hir::Mutability {\n-    MutMutable,\n-    MutImmutable\n-});\n-\n-impl_stable_hash_for!(enum hir::IsAuto {\n-    Yes,\n-    No\n-});\n-\n-impl_stable_hash_for!(enum hir::Unsafety {\n-    Unsafe,\n-    Normal\n-});\n-\n-impl_stable_hash_for!(enum hir::IsAsync {\n-    Async,\n-    NotAsync\n-});\n-\n-impl_stable_hash_for!(enum hir::Constness {\n-    Const,\n-    NotConst\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -1119,18 +378,6 @@ for hir::def_id::DefIndex {\n     }\n }\n \n-impl_stable_hash_for!(struct hir::def::Export {\n-    ident,\n-    def,\n-    vis,\n-    span\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::lib_features::LibFeatures {\n-    stable,\n-    unstable\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _: &mut StableHashingContext<'a>,\n@@ -1139,11 +386,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::Lan\n     }\n }\n \n-impl_stable_hash_for!(struct crate::middle::lang_items::LanguageItems {\n-    items,\n-    missing\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -1178,26 +420,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n     }\n }\n \n-impl_stable_hash_for!(struct hir::CodegenFnAttrs {\n-    flags,\n-    inline,\n-    optimize,\n-    export_name,\n-    link_name,\n-    target_features,\n-    linkage,\n-    link_section,\n-});\n-\n-impl<'hir> HashStable<StableHashingContext<'hir>> for hir::CodegenFnAttrFlags\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'hir>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.bits().hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl<'hir> HashStable<StableHashingContext<'hir>> for attr::InlineAttr {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'hir>,\n@@ -1214,7 +436,3 @@ impl<'hir> HashStable<StableHashingContext<'hir>> for attr::OptimizeAttr {\n     }\n }\n \n-impl_stable_hash_for!(struct hir::Freevar {\n-    def,\n-    span\n-});"}, {"sha": "ddc091b7187063eb714aecee9d1724c5f329a9ee", "filename": "src/librustc/ich/impls_mir.rs", "status": "removed", "additions": 0, "deletions": 503, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/5c7ec6c421af26666d3ec1c5fe022d099133951c/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7ec6c421af26666d3ec1c5fe022d099133951c/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=5c7ec6c421af26666d3ec1c5fe022d099133951c", "patch": "@@ -1,503 +0,0 @@\n-//! This module contains `HashStable` implementations for various MIR data\n-//! types in no particular order.\n-\n-use crate::ich::StableHashingContext;\n-use crate::mir;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n-use std::mem;\n-\n-impl_stable_hash_for!(struct mir::GeneratorLayout<'tcx> { fields });\n-impl_stable_hash_for!(struct mir::SourceInfo { span, scope });\n-impl_stable_hash_for!(enum mir::Mutability { Mut, Not });\n-impl_stable_hash_for!(enum mir::LocalKind { Var, Temp, Arg, ReturnPointer });\n-impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n-    mutability,\n-    ty,\n-    user_ty,\n-    name,\n-    source_info,\n-    visibility_scope,\n-    internal,\n-    is_block_tail,\n-    is_user_variable\n-});\n-impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, var_hir_id, by_ref, mutability });\n-impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n-impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, details, kind });\n-impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });\n-\n-impl_stable_hash_for!(enum mir::BorrowKind {\n-    Shared,\n-    Shallow,\n-    Unique,\n-    Mut { allow_two_phase_borrow },\n-});\n-\n-impl_stable_hash_for!(enum mir::UnsafetyViolationKind {\n-    General,\n-    GeneralAndConstFn,\n-    ExternStatic(lint_node_id),\n-    BorrowPacked(lint_node_id),\n-});\n-\n-impl_stable_hash_for!(struct mir::Terminator<'tcx> {\n-    kind,\n-    source_info\n-});\n-\n-impl_stable_hash_for!(\n-    impl<T> for enum mir::ClearCrossCrate<T> [ mir::ClearCrossCrate ] {\n-        Clear,\n-        Set(value),\n-    }\n-);\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::Local {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::BasicBlock {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::Field {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>>\n-for mir::SourceScope {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::Promoted {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for mir::TerminatorKind<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::TerminatorKind::Goto { ref target } => {\n-                target.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::SwitchInt { ref discr,\n-                                             switch_ty,\n-                                             ref values,\n-                                             ref targets } => {\n-                discr.hash_stable(hcx, hasher);\n-                switch_ty.hash_stable(hcx, hasher);\n-                values.hash_stable(hcx, hasher);\n-                targets.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::Resume |\n-            mir::TerminatorKind::Abort |\n-            mir::TerminatorKind::Return |\n-            mir::TerminatorKind::GeneratorDrop |\n-            mir::TerminatorKind::Unreachable => {}\n-            mir::TerminatorKind::Drop { ref location, target, unwind } => {\n-                location.hash_stable(hcx, hasher);\n-                target.hash_stable(hcx, hasher);\n-                unwind.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::DropAndReplace { ref location,\n-                                                  ref value,\n-                                                  target,\n-                                                  unwind, } => {\n-                location.hash_stable(hcx, hasher);\n-                value.hash_stable(hcx, hasher);\n-                target.hash_stable(hcx, hasher);\n-                unwind.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::Yield { ref value,\n-                                        resume,\n-                                        drop } => {\n-                value.hash_stable(hcx, hasher);\n-                resume.hash_stable(hcx, hasher);\n-                drop.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::Call { ref func,\n-                                        ref args,\n-                                        ref destination,\n-                                        cleanup,\n-                                        from_hir_call, } => {\n-                func.hash_stable(hcx, hasher);\n-                args.hash_stable(hcx, hasher);\n-                destination.hash_stable(hcx, hasher);\n-                cleanup.hash_stable(hcx, hasher);\n-                from_hir_call.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::Assert { ref cond,\n-                                          expected,\n-                                          ref msg,\n-                                          target,\n-                                          cleanup } => {\n-                cond.hash_stable(hcx, hasher);\n-                expected.hash_stable(hcx, hasher);\n-                msg.hash_stable(hcx, hasher);\n-                target.hash_stable(hcx, hasher);\n-                cleanup.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::FalseEdges { ref real_target, ref imaginary_targets } => {\n-                real_target.hash_stable(hcx, hasher);\n-                for target in imaginary_targets {\n-                    target.hash_stable(hcx, hasher);\n-                }\n-            }\n-            mir::TerminatorKind::FalseUnwind { ref real_target, ref unwind } => {\n-                real_target.hash_stable(hcx, hasher);\n-                unwind.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n-\n-impl_stable_hash_for!(impl<'gcx> for enum mir::StatementKind<'gcx> [ mir::StatementKind ] {\n-    Assign(place, rvalue),\n-    FakeRead(cause, place),\n-    SetDiscriminant { place, variant_index },\n-    StorageLive(place),\n-    StorageDead(place),\n-    Retag(retag_kind, place),\n-    AscribeUserType(place, variance, c_ty),\n-    Nop,\n-    InlineAsm { asm, outputs, inputs },\n-});\n-\n-impl_stable_hash_for!(enum mir::RetagKind { FnEntry, TwoPhase, Raw, Default });\n-impl_stable_hash_for!(enum mir::FakeReadCause {\n-    ForMatchGuard,\n-    ForMatchedPlace,\n-    ForGuardBinding,\n-    ForLet\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::Place::Local(ref local) => {\n-                local.hash_stable(hcx, hasher);\n-            }\n-            mir::Place::Static(ref statik) => {\n-                statik.hash_stable(hcx, hasher);\n-            }\n-            mir::Place::Promoted(ref promoted) => {\n-                promoted.hash_stable(hcx, hasher);\n-            }\n-            mir::Place::Projection(ref place_projection) => {\n-                place_projection.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, B, V, T> HashStable<StableHashingContext<'a>>\n-for mir::Projection<'gcx, B, V, T>\n-    where B: HashStable<StableHashingContext<'a>>,\n-          V: HashStable<StableHashingContext<'a>>,\n-          T: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let mir::Projection {\n-            ref base,\n-            ref elem,\n-        } = *self;\n-\n-        base.hash_stable(hcx, hasher);\n-        elem.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, V, T> HashStable<StableHashingContext<'a>>\n-for mir::ProjectionElem<'gcx, V, T>\n-    where V: HashStable<StableHashingContext<'a>>,\n-          T: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::ProjectionElem::Deref => {}\n-            mir::ProjectionElem::Field(field, ref ty) => {\n-                field.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            mir::ProjectionElem::Index(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            mir::ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n-                offset.hash_stable(hcx, hasher);\n-                min_length.hash_stable(hcx, hasher);\n-                from_end.hash_stable(hcx, hasher);\n-            }\n-            mir::ProjectionElem::Subslice { from, to } => {\n-                from.hash_stable(hcx, hasher);\n-                to.hash_stable(hcx, hasher);\n-            }\n-            mir::ProjectionElem::Downcast(adt_def, variant) => {\n-                adt_def.hash_stable(hcx, hasher);\n-                variant.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct mir::SourceScopeData { span, parent_scope });\n-impl_stable_hash_for!(struct mir::SourceScopeLocalData {\n-    lint_root, safety\n-});\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::Safety {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::Safety::Safe |\n-            mir::Safety::BuiltinUnsafe |\n-            mir::Safety::FnUnsafe => {}\n-            mir::Safety::ExplicitUnsafe(node_id) => {\n-                node_id.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Operand<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::Operand::Copy(ref place) => {\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::Operand::Move(ref place) => {\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::Operand::Constant(ref constant) => {\n-                constant.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Rvalue<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::Rvalue::Use(ref operand) => {\n-                operand.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Repeat(ref operand, ref val) => {\n-                operand.hash_stable(hcx, hasher);\n-                val.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Ref(region, borrow_kind, ref place) => {\n-                region.hash_stable(hcx, hasher);\n-                borrow_kind.hash_stable(hcx, hasher);\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Len(ref place) => {\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Cast(cast_kind, ref operand, ty) => {\n-                cast_kind.hash_stable(hcx, hasher);\n-                operand.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::BinaryOp(op, ref operand1, ref operand2) |\n-            mir::Rvalue::CheckedBinaryOp(op, ref operand1, ref operand2) => {\n-                op.hash_stable(hcx, hasher);\n-                operand1.hash_stable(hcx, hasher);\n-                operand2.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::UnaryOp(op, ref operand) => {\n-                op.hash_stable(hcx, hasher);\n-                operand.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Discriminant(ref place) => {\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::NullaryOp(op, ty) => {\n-                op.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n-                kind.hash_stable(hcx, hasher);\n-                operands.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum mir::CastKind {\n-    Misc,\n-    ReifyFnPointer,\n-    ClosureFnPointer,\n-    UnsafeFnPointer,\n-    Unsize\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for mir::AggregateKind<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::AggregateKind::Tuple => {}\n-            mir::AggregateKind::Array(t) => {\n-                t.hash_stable(hcx, hasher);\n-            }\n-            mir::AggregateKind::Adt(adt_def, idx, substs, user_substs, active_field) => {\n-                adt_def.hash_stable(hcx, hasher);\n-                idx.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-                user_substs.hash_stable(hcx, hasher);\n-                active_field.hash_stable(hcx, hasher);\n-            }\n-            mir::AggregateKind::Closure(def_id, ref substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            mir::AggregateKind::Generator(def_id, ref substs, movability) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-                movability.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum mir::BinOp {\n-    Add,\n-    Sub,\n-    Mul,\n-    Div,\n-    Rem,\n-    BitXor,\n-    BitAnd,\n-    BitOr,\n-    Shl,\n-    Shr,\n-    Eq,\n-    Lt,\n-    Le,\n-    Ne,\n-    Ge,\n-    Gt,\n-    Offset\n-});\n-\n-impl_stable_hash_for!(enum mir::UnOp {\n-    Not,\n-    Neg\n-});\n-\n-impl_stable_hash_for!(enum mir::NullOp {\n-    Box,\n-    SizeOf\n-});\n-\n-impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, user_ty, literal });\n-\n-impl_stable_hash_for!(struct mir::Location { block, statement_index });\n-\n-impl_stable_hash_for!(struct mir::BorrowCheckResult<'tcx> {\n-    closure_requirements,\n-    used_mut_upvars\n-});\n-\n-impl_stable_hash_for!(struct mir::ClosureRegionRequirements<'tcx> {\n-    num_external_vids,\n-    outlives_requirements\n-});\n-\n-impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement<'tcx> {\n-    subject,\n-    outlived_free_region,\n-    blame_span,\n-    category\n-});\n-\n-impl_stable_hash_for!(enum mir::ConstraintCategory {\n-    Return,\n-    Yield,\n-    UseAsConst,\n-    UseAsStatic,\n-    TypeAnnotation,\n-    Cast,\n-    ClosureBounds,\n-    CallArgument,\n-    CopyBound,\n-    SizedBound,\n-    Assignment,\n-    OpaqueType,\n-    Boring,\n-    BoringNoLocation,\n-    Internal,\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::ClosureOutlivesSubject<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::ClosureOutlivesSubject::Ty(ref ty) => {\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            mir::ClosureOutlivesSubject::Region(ref region) => {\n-                region.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct mir::interpret::GlobalId<'tcx> { instance, promoted });\n-\n-impl_stable_hash_for!(struct mir::UserTypeProjection<'tcx> { base, projs });\n-impl_stable_hash_for!(struct mir::UserTypeProjections<'tcx> { contents });"}, {"sha": "417305139e472ee58a4e30c9c1d29a6a2e8b6a53", "filename": "src/librustc/ich/impls_misc.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_misc.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,15 +1,6 @@\n //! This module contains `HashStable` implementations for various data types\n //! that don't fit into any of the other impls_xxx modules.\n \n-impl_stable_hash_for!(enum crate::session::search_paths::PathKind {\n-    Native,\n-    Crate,\n-    Dependency,\n-    Framework,\n-    ExternFlag,\n-    All\n-});\n-\n impl_stable_hash_for!(enum ::rustc_target::spec::PanicStrategy {\n     Abort,\n     Unwind"}, {"sha": "ec1b0da68107439f0b436c1280ad35854edc4963", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 5, "deletions": 1033, "changes": 1038, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -6,11 +6,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use std::cell::RefCell;\n-use std::hash as std_hash;\n use std::mem;\n use crate::middle::region;\n-use crate::infer;\n-use crate::traits;\n use crate::ty;\n use crate::mir;\n \n@@ -65,19 +62,6 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::subst::Kind<'gcx> {\n     }\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::subst::UnpackedKind<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            ty::subst::UnpackedKind::Lifetime(lt) => lt.hash_stable(hcx, hasher),\n-            ty::subst::UnpackedKind::Type(ty) => ty.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>>\n for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -134,114 +118,24 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::BoundVar {\n+impl<'gcx, 'tcx> HashStable<StableHashingContext<'gcx>> for ty::ConstVid<'tcx> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::adjustment::AutoBorrow<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::adjustment::AutoBorrow::Ref(ref region, mutability) => {\n-                region.hash_stable(hcx, hasher);\n-                mutability.hash_stable(hcx, hasher);\n-            }\n-            ty::adjustment::AutoBorrow::RawPtr(mutability) => {\n-                mutability.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::adjustment::Adjust<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::adjustment::Adjust::NeverToAny |\n-            ty::adjustment::Adjust::ReifyFnPointer |\n-            ty::adjustment::Adjust::UnsafeFnPointer |\n-            ty::adjustment::Adjust::ClosureFnPointer |\n-            ty::adjustment::Adjust::MutToConstPointer |\n-            ty::adjustment::Adjust::Unsize => {}\n-            ty::adjustment::Adjust::Deref(ref overloaded) => {\n-                overloaded.hash_stable(hcx, hasher);\n-            }\n-            ty::adjustment::Adjust::Borrow(ref autoref) => {\n-                autoref.hash_stable(hcx, hasher);\n-            }\n-        }\n+        self.index.hash_stable(hcx, hasher);\n     }\n }\n \n-impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n-impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl });\n-impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n-impl_stable_hash_for!(enum ty::adjustment::AllowTwoPhase {\n-    Yes,\n-    No\n-});\n-\n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::adjustment::AutoBorrowMutability {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::BoundVar {\n+    #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::adjustment::AutoBorrowMutability::Mutable { ref allow_two_phase_borrow } => {\n-                allow_two_phase_borrow.hash_stable(hcx, hasher);\n-            }\n-            ty::adjustment::AutoBorrowMutability::Immutable => {}\n-        }\n+        self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl_stable_hash_for!(tuple_struct ty::util::NeedsDrop { value });\n-\n-impl_stable_hash_for!(tuple_struct ty::AdtSizedConstraint<'tcx> { list });\n-\n-impl_stable_hash_for!(struct ty::UpvarPath { hir_id });\n-\n-impl_stable_hash_for!(struct ty::UpvarId { var_path, closure_expr_id });\n-\n-impl_stable_hash_for!(enum ty::BorrowKind {\n-    ImmBorrow,\n-    UniqueImmBorrow,\n-    MutBorrow\n-});\n-\n-impl_stable_hash_for!(impl<'gcx> for enum ty::UpvarCapture<'gcx> [ ty::UpvarCapture ] {\n-    ByValue,\n-    ByRef(up_var_borrow),\n-});\n-\n-impl_stable_hash_for!(struct ty::GenSig<'tcx> {\n-    yield_ty,\n-    return_ty\n-});\n-\n-impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n-    inputs_and_output,\n-    variadic,\n-    unsafety,\n-    abi\n-});\n-\n-impl_stable_hash_for!(struct ty::ResolvedOpaqueTy<'tcx> {\n-    concrete_type,\n-    substs\n-});\n-\n impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n     where T: HashStable<StableHashingContext<'a>>\n {\n@@ -252,97 +146,6 @@ impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n     }\n }\n \n-impl_stable_hash_for!(enum ty::ClosureKind { Fn, FnMut, FnOnce });\n-\n-impl_stable_hash_for!(enum ty::Visibility {\n-    Public,\n-    Restricted(def_id),\n-    Invisible\n-});\n-\n-impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n-impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n-impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n-impl_stable_hash_for!(impl<A, B> for tuple_struct ty::OutlivesPredicate<A, B> { a, b });\n-impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty });\n-impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { substs, item_def_id });\n-\n-impl_stable_hash_for!(\n-    impl<'tcx> for enum ty::Predicate<'tcx> [ ty::Predicate ] {\n-        Trait(pred),\n-        Subtype(pred),\n-        RegionOutlives(pred),\n-        TypeOutlives(pred),\n-        Projection(pred),\n-        WellFormed(ty),\n-        ObjectSafe(def_id),\n-        ClosureKind(def_id, closure_substs, closure_kind),\n-        ConstEvaluatable(def_id, substs),\n-    }\n-);\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for ty::AdtFlags {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        std_hash::Hash::hash(self, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for ty::VariantFlags {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        std_hash::Hash::hash(self, hasher);\n-    }\n-}\n-\n-impl_stable_hash_for!(enum ty::VariantDiscr {\n-    Explicit(def_id),\n-    Relative(distance)\n-});\n-\n-impl_stable_hash_for!(struct ty::FieldDef {\n-    did,\n-    ident -> (ident.name),\n-    vis,\n-});\n-\n-impl_stable_hash_for!(\n-    impl<'tcx> for enum mir::interpret::ConstValue<'tcx> [ mir::interpret::ConstValue ] {\n-        Scalar(val),\n-        Slice(a, b),\n-        ByRef(ptr, alloc),\n-    }\n-);\n-impl_stable_hash_for!(struct crate::mir::interpret::RawConst<'tcx> {\n-    alloc_id,\n-    ty,\n-});\n-\n-impl_stable_hash_for! {\n-    impl<Tag> for struct mir::interpret::Pointer<Tag> {\n-        alloc_id,\n-        offset,\n-        tag,\n-    }\n-}\n-\n-impl_stable_hash_for!(\n-    impl<Tag> for enum mir::interpret::Scalar<Tag> [ mir::interpret::Scalar ] {\n-        Bits { bits, size },\n-        Ptr(ptr),\n-    }\n-);\n-\n-impl_stable_hash_for!(\n-    impl<'tcx> for enum mir::interpret::AllocKind<'tcx> [ mir::interpret::AllocKind ] {\n-        Function(instance),\n-        Static(def_id),\n-        Memory(mem),\n-    }\n-);\n-\n // AllocIds get resolved to whatever they point to (to be stable)\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     fn hash_stable<W: StableHasherResult>(\n@@ -381,193 +184,6 @@ impl_stable_hash_for!(enum ::syntax::ast::Mutability {\n     Mutable\n });\n \n-impl_stable_hash_for!(struct ty::Const<'tcx> {\n-    ty,\n-    val\n-});\n-\n-impl_stable_hash_for!(impl<'tcx> for enum ty::LazyConst<'tcx> [ty::LazyConst] {\n-    Unevaluated(did, substs),\n-    Evaluated(c)\n-});\n-\n-impl_stable_hash_for!(enum mir::interpret::ErrorHandled {\n-    Reported,\n-    TooGeneric\n-});\n-\n-impl_stable_hash_for!(struct mir::interpret::FrameInfo<'tcx> {\n-    call_site,\n-    lint_root,\n-    instance\n-});\n-\n-impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n-impl_stable_hash_for!(struct ty::GeneratorSubsts<'tcx> { substs });\n-\n-impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n-    parent,\n-    predicates\n-});\n-\n-impl_stable_hash_for!(\n-    impl<'tcx, O> for enum mir::interpret::EvalErrorKind<'tcx, O>\n-        [ mir::interpret::EvalErrorKind ]\n-    {\n-        FunctionArgCountMismatch,\n-        DanglingPointerDeref,\n-        DoubleFree,\n-        InvalidMemoryAccess,\n-        InvalidFunctionPointer,\n-        InvalidBool,\n-        InvalidNullPointerUsage,\n-        ReadPointerAsBytes,\n-        ReadBytesAsPointer,\n-        ReadForeignStatic,\n-        InvalidPointerMath,\n-        DeadLocal,\n-        StackFrameLimitReached,\n-        OutOfTls,\n-        TlsOutOfBounds,\n-        CalledClosureAsFunction,\n-        VtableForArgumentlessMethod,\n-        ModifiedConstantMemory,\n-        ModifiedStatic,\n-        AssumptionNotHeld,\n-        InlineAsm,\n-        ReallocateNonBasePtr,\n-        DeallocateNonBasePtr,\n-        HeapAllocZeroBytes,\n-        Unreachable,\n-        ReadFromReturnPointer,\n-        UnimplementedTraitSelection,\n-        TypeckError,\n-        TooGeneric,\n-        DerefFunctionPointer,\n-        ExecuteMemory,\n-        OverflowNeg,\n-        RemainderByZero,\n-        DivisionByZero,\n-        GeneratorResumedAfterReturn,\n-        GeneratorResumedAfterPanic,\n-        ReferencedConstant,\n-        InfiniteLoop,\n-        ReadUndefBytes(offset),\n-        InvalidDiscriminant(val),\n-        Panic { msg, file, line, col },\n-        MachineError(err),\n-        FunctionAbiMismatch(a, b),\n-        FunctionArgMismatch(a, b),\n-        FunctionRetMismatch(a, b),\n-        NoMirFor(s),\n-        UnterminatedCString(ptr),\n-        PointerOutOfBounds { ptr, check, allocation_size },\n-        InvalidBoolOp(bop),\n-        Unimplemented(s),\n-        BoundsCheck { len, index },\n-        Intrinsic(s),\n-        InvalidChar(c),\n-        AbiViolation(s),\n-        AlignmentCheckFailed { required, has },\n-        ValidationFailure(s),\n-        TypeNotPrimitive(ty),\n-        ReallocatedWrongMemoryKind(a, b),\n-        DeallocatedWrongMemoryKind(a, b),\n-        IncorrectAllocationInformation(a, b, c, d),\n-        Layout(lay),\n-        HeapAllocNonPowerOfTwoAlignment(n),\n-        PathNotFound(v),\n-        Overflow(op),\n-    }\n-);\n-\n-impl_stable_hash_for!(enum mir::interpret::InboundsCheck {\n-    Live,\n-    MaybeDead\n-});\n-\n-impl_stable_hash_for!(enum ty::Variance {\n-    Covariant,\n-    Invariant,\n-    Contravariant,\n-    Bivariant\n-});\n-\n-impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n-    Struct(index)\n-});\n-\n-impl_stable_hash_for!(struct ty::Generics {\n-    parent,\n-    parent_count,\n-    params,\n-    // Reverse map to each param's `index` field, from its `def_id`.\n-    param_def_id_to_index -> _, // Don't hash this\n-    has_self,\n-    has_late_bound_regions,\n-});\n-\n-impl_stable_hash_for!(struct ty::GenericParamDef {\n-    name,\n-    def_id,\n-    index,\n-    pure_wrt_drop,\n-    kind\n-});\n-\n-impl_stable_hash_for!(enum ty::GenericParamDefKind {\n-    Lifetime,\n-    Type { has_default, object_lifetime_default, synthetic },\n-});\n-\n-impl_stable_hash_for!(\n-    impl<T> for enum crate::middle::resolve_lifetime::Set1<T>\n-        [ crate::middle::resolve_lifetime::Set1 ]\n-    {\n-        Empty,\n-        Many,\n-        One(value),\n-    }\n-);\n-\n-impl_stable_hash_for!(enum crate::middle::resolve_lifetime::LifetimeDefOrigin {\n-    ExplicitOrElided,\n-    InBand,\n-    Error,\n-});\n-\n-impl_stable_hash_for!(enum crate::middle::resolve_lifetime::Region {\n-    Static,\n-    EarlyBound(index, decl, is_in_band),\n-    LateBound(db_index, decl, is_in_band),\n-    LateBoundAnon(db_index, anon_index),\n-    Free(call_site_scope_data, decl)\n-});\n-\n-impl_stable_hash_for!(enum ty::cast::CastKind {\n-    CoercionCast,\n-    PtrPtrCast,\n-    PtrAddrCast,\n-    AddrPtrCast,\n-    NumericCast,\n-    EnumCast,\n-    PrimIntCast,\n-    U8CharCast,\n-    ArrayPtrCast,\n-    FnPtrPtrCast,\n-    FnPtrAddrCast\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::region::Scope { id, data });\n-\n-impl_stable_hash_for!(enum crate::middle::region::ScopeData {\n-    Node,\n-    CallSite,\n-    Arguments,\n-    Destruction,\n-    Remainder(first_statement_index)\n-});\n-\n impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     type KeyType = region::Scope;\n \n@@ -577,129 +193,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     }\n }\n \n-impl_stable_hash_for!(struct ty::adjustment::CoerceUnsizedInfo {\n-    custom_kind\n-});\n-\n-impl_stable_hash_for!(struct ty::FreeRegion {\n-    scope,\n-    bound_region\n-});\n-\n-impl_stable_hash_for!(enum ty::BoundRegion {\n-    BrAnon(index),\n-    BrNamed(def_id, name),\n-    BrFresh(index),\n-    BrEnv\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::TyKind<'gcx>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::ty::TyKind::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            Bool  |\n-            Char  |\n-            Str   |\n-            Error |\n-            Never => {\n-                // Nothing more to hash.\n-            }\n-            Int(int_ty) => {\n-                int_ty.hash_stable(hcx, hasher);\n-            }\n-            Uint(uint_ty) => {\n-                uint_ty.hash_stable(hcx, hasher);\n-            }\n-            Float(float_ty)  => {\n-                float_ty.hash_stable(hcx, hasher);\n-            }\n-            Adt(adt_def, substs) => {\n-                adt_def.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            Array(inner_ty, len) => {\n-                inner_ty.hash_stable(hcx, hasher);\n-                len.hash_stable(hcx, hasher);\n-            }\n-            Slice(inner_ty) => {\n-                inner_ty.hash_stable(hcx, hasher);\n-            }\n-            RawPtr(pointee_ty) => {\n-                pointee_ty.hash_stable(hcx, hasher);\n-            }\n-            Ref(region, pointee_ty, mutbl) => {\n-                region.hash_stable(hcx, hasher);\n-                pointee_ty.hash_stable(hcx, hasher);\n-                mutbl.hash_stable(hcx, hasher);\n-            }\n-            FnDef(def_id, substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            FnPtr(ref sig) => {\n-                sig.hash_stable(hcx, hasher);\n-            }\n-            Dynamic(ref existential_predicates, region) => {\n-                existential_predicates.hash_stable(hcx, hasher);\n-                region.hash_stable(hcx, hasher);\n-            }\n-            Closure(def_id, closure_substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                closure_substs.hash_stable(hcx, hasher);\n-            }\n-            Generator(def_id, generator_substs, movability) => {\n-                def_id.hash_stable(hcx, hasher);\n-                generator_substs.hash_stable(hcx, hasher);\n-                movability.hash_stable(hcx, hasher);\n-            }\n-            GeneratorWitness(types) => {\n-                types.hash_stable(hcx, hasher)\n-            }\n-            Tuple(inner_tys) => {\n-                inner_tys.hash_stable(hcx, hasher);\n-            }\n-            Projection(ref data) | UnnormalizedProjection(ref data) => {\n-                data.hash_stable(hcx, hasher);\n-            }\n-            Opaque(def_id, substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            Param(param_ty) => {\n-                param_ty.hash_stable(hcx, hasher);\n-            }\n-            Bound(debruijn, bound_ty) => {\n-                debruijn.hash_stable(hcx, hasher);\n-                bound_ty.hash_stable(hcx, hasher);\n-            }\n-            ty::Placeholder(placeholder_ty) => {\n-                placeholder_ty.hash_stable(hcx, hasher);\n-            }\n-            Foreign(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            Infer(infer_ty) => {\n-                infer_ty.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum ty::InferTy {\n-    TyVar(a),\n-    IntVar(a),\n-    FloatVar(a),\n-    FreshTy(a),\n-    FreshIntTy(a),\n-    FreshFloatTy(a),\n-});\n-\n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::TyVid\n {\n@@ -736,141 +229,6 @@ for ty::FloatVid\n     }\n }\n \n-impl_stable_hash_for!(struct ty::ParamTy {\n-    idx,\n-    name\n-});\n-\n-impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n-    ty,\n-    mutbl\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::ExistentialPredicate<'gcx>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::ExistentialPredicate::Trait(ref trait_ref) => {\n-                trait_ref.hash_stable(hcx, hasher);\n-            }\n-            ty::ExistentialPredicate::Projection(ref projection) => {\n-                projection.hash_stable(hcx, hasher);\n-            }\n-            ty::ExistentialPredicate::AutoTrait(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct ty::ExistentialTraitRef<'tcx> {\n-    def_id,\n-    substs\n-});\n-\n-impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n-    item_def_id,\n-    substs,\n-    ty\n-});\n-\n-impl_stable_hash_for!(struct ty::Instance<'tcx> {\n-    def,\n-    substs\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::InstanceDef<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            ty::InstanceDef::Item(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::VtableShim(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::Intrinsic(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::FnPtrShim(def_id, ty) => {\n-                def_id.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::Virtual(def_id, n) => {\n-                def_id.hash_stable(hcx, hasher);\n-                n.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::ClosureOnceShim { call_once } => {\n-                call_once.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::DropGlue(def_id, ty) => {\n-                def_id.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::CloneShim(def_id, ty) => {\n-                def_id.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct ty::TraitDef {\n-    // We already have the def_path_hash below, no need to hash it twice\n-    def_id -> _,\n-    unsafety,\n-    paren_sugar,\n-    has_auto_impl,\n-    is_marker,\n-    def_path_hash,\n-});\n-\n-impl_stable_hash_for!(struct ty::Destructor {\n-    did\n-});\n-\n-impl_stable_hash_for!(struct ty::CrateVariancesMap {\n-    variances,\n-    // This is just an irrelevant helper value.\n-    empty_variance -> _,\n-});\n-\n-impl_stable_hash_for!(struct ty::CratePredicatesMap<'tcx> {\n-    predicates,\n-    // This is just an irrelevant helper value.\n-    empty_predicate -> _,\n-});\n-\n-impl_stable_hash_for!(struct ty::AssociatedItem {\n-    def_id,\n-    ident -> (ident.name),\n-    kind,\n-    vis,\n-    defaultness,\n-    container,\n-    method_has_self_argument\n-});\n-\n-impl_stable_hash_for!(enum ty::AssociatedKind {\n-    Const,\n-    Method,\n-    Existential,\n-    Type\n-});\n-\n-impl_stable_hash_for!(enum ty::AssociatedItemContainer {\n-    TraitContainer(def_id),\n-    ImplContainer(def_id)\n-});\n-\n-\n impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for ty::steal::Steal<T>\n     where T: HashStable<StableHashingContext<'a>>\n@@ -882,24 +240,6 @@ for ty::steal::Steal<T>\n     }\n }\n \n-impl_stable_hash_for!(struct ty::ParamEnv<'tcx> {\n-    caller_bounds,\n-    reveal,\n-    def_id\n-});\n-\n-impl_stable_hash_for!(enum traits::Reveal {\n-    UserFacing,\n-    All\n-});\n-\n-impl_stable_hash_for!(enum crate::middle::privacy::AccessLevel {\n-    ReachableFromImplTrait,\n-    Reachable,\n-    Exported,\n-    Public\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>>\n for crate::middle::privacy::AccessLevels {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -914,371 +254,3 @@ for crate::middle::privacy::AccessLevels {\n         });\n     }\n }\n-\n-impl_stable_hash_for!(struct ty::CrateInherentImpls {\n-    inherent_impls\n-});\n-\n-impl_stable_hash_for!(enum crate::session::CompileIncomplete {\n-    Stopped,\n-    Errored(error_reported)\n-});\n-\n-impl_stable_hash_for!(struct crate::util::common::ErrorReported {});\n-\n-impl_stable_hash_for!(tuple_struct crate::middle::reachable::ReachableSet {\n-    reachable_set\n-});\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::Vtable::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match self {\n-            &VtableImpl(ref table_impl) => table_impl.hash_stable(hcx, hasher),\n-            &VtableAutoImpl(ref table_def_impl) => table_def_impl.hash_stable(hcx, hasher),\n-            &VtableParam(ref table_param) => table_param.hash_stable(hcx, hasher),\n-            &VtableObject(ref table_obj) => table_obj.hash_stable(hcx, hasher),\n-            &VtableBuiltin(ref table_builtin) => table_builtin.hash_stable(hcx, hasher),\n-            &VtableClosure(ref table_closure) => table_closure.hash_stable(hcx, hasher),\n-            &VtableFnPointer(ref table_fn_pointer) => table_fn_pointer.hash_stable(hcx, hasher),\n-            &VtableGenerator(ref table_generator) => table_generator.hash_stable(hcx, hasher),\n-            &VtableTraitAlias(ref table_alias) => table_alias.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableImplData {\n-            impl_def_id,\n-            substs,\n-            ref nested,\n-        } = *self;\n-        impl_def_id.hash_stable(hcx, hasher);\n-        substs.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableAutoImplData<N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableAutoImplData {\n-            trait_def_id,\n-            ref nested,\n-        } = *self;\n-        trait_def_id.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableObjectData {\n-            upcast_trait_ref,\n-            vtable_base,\n-            ref nested,\n-        } = *self;\n-        upcast_trait_ref.hash_stable(hcx, hasher);\n-        vtable_base.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableBuiltinData {\n-            ref nested,\n-        } = *self;\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableClosureData {\n-            closure_def_id,\n-            substs,\n-            ref nested,\n-        } = *self;\n-        closure_def_id.hash_stable(hcx, hasher);\n-        substs.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableFnPointerData {\n-            fn_ty,\n-            ref nested,\n-        } = *self;\n-        fn_ty.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableGeneratorData {\n-            generator_def_id,\n-            substs,\n-            ref nested,\n-        } = *self;\n-        generator_def_id.hash_stable(hcx, hasher);\n-        substs.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableTraitAliasData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableTraitAliasData {\n-            alias_def_id,\n-            substs,\n-            ref nested,\n-        } = *self;\n-        alias_def_id.hash_stable(hcx, hasher);\n-        substs.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl_stable_hash_for!(\n-    impl<'tcx, V> for struct infer::canonical::Canonical<'tcx, V> {\n-        max_universe, variables, value\n-    }\n-);\n-\n-impl_stable_hash_for!(\n-    struct infer::canonical::CanonicalVarValues<'tcx> {\n-        var_values\n-    }\n-);\n-\n-impl_stable_hash_for!(struct infer::canonical::CanonicalVarInfo {\n-    kind\n-});\n-\n-impl_stable_hash_for!(enum infer::canonical::CanonicalVarKind {\n-    Ty(k),\n-    PlaceholderTy(placeholder),\n-    Region(ui),\n-    PlaceholderRegion(placeholder),\n-});\n-\n-impl_stable_hash_for!(enum infer::canonical::CanonicalTyVarKind {\n-    General(ui),\n-    Int,\n-    Float\n-});\n-\n-impl_stable_hash_for!(\n-    impl<'tcx, R> for struct infer::canonical::QueryResponse<'tcx, R> {\n-        var_values, region_constraints, certainty, value\n-    }\n-);\n-\n-impl_stable_hash_for!(enum infer::canonical::Certainty {\n-    Proven, Ambiguous\n-});\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClause<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::WhereClause::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Implemented(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n-            ProjectionEq(projection) => projection.hash_stable(hcx, hasher),\n-            TypeOutlives(ty_outlives) => ty_outlives.hash_stable(hcx, hasher),\n-            RegionOutlives(region_outlives) => region_outlives.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WellFormed<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::WellFormed::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Trait(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n-            Ty(ty) => ty.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::FromEnv<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::FromEnv::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Trait(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n-            Ty(ty) => ty.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::DomainGoal<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::DomainGoal::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Holds(wc) => wc.hash_stable(hcx, hasher),\n-            WellFormed(wf) => wf.hash_stable(hcx, hasher),\n-            FromEnv(from_env) => from_env.hash_stable(hcx, hasher),\n-            Normalize(projection) => projection.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::GoalKind::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Implies(hypotheses, goal) => {\n-                hypotheses.hash_stable(hcx, hasher);\n-                goal.hash_stable(hcx, hasher);\n-            },\n-            And(goal1, goal2) => {\n-                goal1.hash_stable(hcx, hasher);\n-                goal2.hash_stable(hcx, hasher);\n-            }\n-            Not(goal) => goal.hash_stable(hcx, hasher),\n-            DomainGoal(domain_goal) => domain_goal.hash_stable(hcx, hasher),\n-            Quantified(quantifier, goal) => {\n-                quantifier.hash_stable(hcx, hasher);\n-                goal.hash_stable(hcx, hasher);\n-            },\n-            Subtype(a, b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-            }\n-            CannotProve => { },\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(\n-    struct traits::ProgramClause<'tcx> {\n-        goal, hypotheses, category\n-    }\n-);\n-\n-impl_stable_hash_for!(enum traits::ProgramClauseCategory {\n-    ImpliedBound,\n-    WellFormed,\n-    Other,\n-});\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::Clause::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Implies(clause) => clause.hash_stable(hcx, hasher),\n-            ForAll(clause) => clause.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum traits::QuantifierKind {\n-    Universal,\n-    Existential\n-});\n-\n-impl_stable_hash_for!(struct ty::subst::UserSubsts<'tcx> { substs, user_self_ty });\n-\n-impl_stable_hash_for!(struct ty::subst::UserSelfTy<'tcx> { impl_def_id, self_ty });\n-\n-impl_stable_hash_for!(\n-    struct traits::Environment<'tcx> {\n-        clauses,\n-    }\n-);\n-\n-impl_stable_hash_for!(\n-    impl<'tcx, G> for struct traits::InEnvironment<'tcx, G> {\n-        environment,\n-        goal,\n-    }\n-);\n-\n-impl_stable_hash_for!(\n-    struct ty::CanonicalUserTypeAnnotation<'tcx> {\n-        user_ty, span, inferred_ty\n-    }\n-);\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::UserType<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::UserType::Ty(ref ty) => {\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            ty::UserType::TypeOf(ref def_id, ref substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for ty::UserTypeAnnotationIndex {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}"}, {"sha": "b407b75e68c9af4c6e307fc6ae2c3ff6ef80465f", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -7,9 +7,7 @@ pub use self::hcx::{StableHashingContextProvider, StableHashingContext, NodeIdHa\n mod caching_source_map_view;\n mod hcx;\n \n-mod impls_cstore;\n mod impls_hir;\n-mod impls_mir;\n mod impls_misc;\n mod impls_ty;\n mod impls_syntax;"}, {"sha": "95fdd6f01e2a861193931f4025d725f3f3a8330f", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -24,6 +24,7 @@\n use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n+use rustc_macros::HashStable;\n use serialize::UseSpecializedDecodable;\n use smallvec::SmallVec;\n use std::ops::Index;\n@@ -41,7 +42,7 @@ mod substitute;\n /// A \"canonicalized\" type `V` is one where all free inference\n /// variables have been rewritten to \"canonical vars\". These are\n /// numbered starting from 0 in order of first appearance.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub struct Canonical<'gcx, V> {\n     pub max_universe: ty::UniverseIndex,\n     pub variables: CanonicalVarInfos<'gcx>,\n@@ -61,7 +62,7 @@ impl<'gcx> UseSpecializedDecodable for CanonicalVarInfos<'gcx> {}\n /// vectors with the original values that were replaced by canonical\n /// variables. You will need to supply it later to instantiate the\n /// canonicalized query response.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub struct CanonicalVarValues<'tcx> {\n     pub var_values: IndexVec<BoundVar, Kind<'tcx>>,\n }\n@@ -99,7 +100,7 @@ impl Default for OriginalQueryValues<'tcx> {\n /// canonical value. This is sufficient information for code to create\n /// a copy of the canonical value in some other inference context,\n /// with fresh inference variables replacing the canonical values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub struct CanonicalVarInfo {\n     pub kind: CanonicalVarKind,\n }\n@@ -122,7 +123,7 @@ impl CanonicalVarInfo {\n /// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n /// in the type-theory sense of the term -- i.e., a \"meta\" type system\n /// that analyzes type-like values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub enum CanonicalVarKind {\n     /// Some kind of type inference variable.\n     Ty(CanonicalTyVarKind),\n@@ -159,7 +160,7 @@ impl CanonicalVarKind {\n /// 22.) can only be instantiated with integral/float types (e.g.,\n /// usize or f32). In order to faithfully reproduce a type, we need to\n /// know what set of types a given type variable can be unified with.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub enum CanonicalTyVarKind {\n     /// General type variable `?T` that can be unified with arbitrary types.\n     General(ty::UniverseIndex),\n@@ -174,7 +175,7 @@ pub enum CanonicalTyVarKind {\n /// After we execute a query with a canonicalized key, we get back a\n /// `Canonical<QueryResponse<..>>`. You can use\n /// `instantiate_query_result` to access the data in this result.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, HashStable)]\n pub struct QueryResponse<'tcx, R> {\n     pub var_values: CanonicalVarValues<'tcx>,\n     pub region_constraints: Vec<QueryRegionConstraint<'tcx>>,\n@@ -189,7 +190,7 @@ pub type CanonicalizedQueryResponse<'gcx, T> =\n \n /// Indicates whether or not we were able to prove the query to be\n /// true.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub enum Certainty {\n     /// The query is known to be true, presuming that you apply the\n     /// given `var_values` and the region-constraints are satisfied.\n@@ -443,6 +444,9 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                     UnpackedKind::Lifetime(..) => tcx.mk_region(\n                         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i))\n                     ).into(),\n+                    UnpackedKind::Const(..) => {\n+                        unimplemented!() // FIXME(const_generics)\n+                    }\n                 })\n                 .collect()\n         }"}, {"sha": "008882fd50036fc6c0df553fd73735c1dbd2d282", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -315,6 +315,10 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                     obligations.extend(ok.into_obligations());\n                 }\n \n+                (UnpackedKind::Const(..), UnpackedKind::Const(..)) => {\n+                    unimplemented!() // FIXME(const_generics)\n+                }\n+\n                 _ => {\n                     bug!(\n                         \"kind mismatch, cannot unify {:?} and {:?}\",\n@@ -473,6 +477,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                         opt_values[br.assert_bound_var()] = Some(*original_value);\n                     }\n                 }\n+                UnpackedKind::Const(..) => {\n+                    unimplemented!() // FIXME(const_generics)\n+                }\n             }\n         }\n \n@@ -568,6 +575,11 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                                 ty::OutlivesPredicate(t1, r2)\n                             )\n                         ),\n+                        UnpackedKind::Const(..) => {\n+                            // Consts cannot outlive one another, so we don't expect to\n+                            // ecounter this branch.\n+                            span_bug!(cause.span, \"unexpected const outlives {:?}\", constraint);\n+                        }\n                     }\n                 )\n             })\n@@ -602,6 +614,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                         obligations\n                             .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n                     }\n+                    (UnpackedKind::Const(..), UnpackedKind::Const(..)) => {\n+                        unimplemented!() // FIXME(const_generics)\n+                    }\n                     _ => {\n                         bug!(\"kind mismatch, cannot unify {:?} and {:?}\", value1, value2,);\n                     }"}, {"sha": "885b439ef1ca58c44c7eb4cfce5f05f438c7e327", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -34,7 +34,7 @@ use crate::ty::{IntType, UintType};\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::error::TypeError;\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::SubstsRef;\n use crate::traits::{Obligation, PredicateObligations};\n \n use syntax::ast;\n@@ -373,9 +373,9 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n \n     fn relate_item_substs(&mut self,\n                           item_def_id: DefId,\n-                          a_subst: &'tcx Substs<'tcx>,\n-                          b_subst: &'tcx Substs<'tcx>)\n-                          -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+                          a_subst: SubstsRef<'tcx>,\n+                          b_subst: SubstsRef<'tcx>)\n+                          -> RelateResult<'tcx, SubstsRef<'tcx>>\n     {\n         if self.ambient_variance == ty::Variance::Invariant {\n             // Avoid fetching the variance if we are in an invariant\n@@ -449,7 +449,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n \n                             let origin = *variables.var_origin(vid);\n                             let new_var_id = variables.new_var(self.for_universe, false, origin);\n-                            let u = self.tcx().mk_var(new_var_id);\n+                            let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);\n                             return Ok(u);"}, {"sha": "31b01eecf5cb6e88231f428b7f908c0a93f41178", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -5,7 +5,7 @@ use crate::hir::def_id::DefId;\n \n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::TyVar;\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::SubstsRef;\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n@@ -33,9 +33,9 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n     fn relate_item_substs(&mut self,\n                           _item_def_id: DefId,\n-                          a_subst: &'tcx Substs<'tcx>,\n-                          b_subst: &'tcx Substs<'tcx>)\n-                          -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+                          a_subst: SubstsRef<'tcx>,\n+                          b_subst: SubstsRef<'tcx>)\n+                          -> RelateResult<'tcx, SubstsRef<'tcx>>\n     {\n         // N.B., once we are equating types, we don't care about\n         // variance, so don't try to lookup the variance here. This"}, {"sha": "c7936534aad2e00d0cc8689a97e5ec99b0cd1c95", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -56,7 +56,7 @@ use crate::hir::Node;\n use crate::middle::region;\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::error::TypeError;\n-use crate::ty::{self, subst::Subst, Region, Ty, TyCtxt, TyKind, TypeFoldable};\n+use crate::ty::{self, subst::{Subst, SubstsRef}, Region, Ty, TyCtxt, TyKind, TypeFoldable};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use std::{cmp, fmt};\n use syntax_pos::{Pos, Span};\n@@ -570,7 +570,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value: &mut DiagnosticStyledString,\n         other_value: &mut DiagnosticStyledString,\n         name: String,\n-        sub: &ty::subst::Substs<'tcx>,\n+        sub: ty::subst::SubstsRef<'tcx>,\n         pos: usize,\n         other_ty: &Ty<'tcx>,\n     ) {\n@@ -648,7 +648,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         mut t1_out: &mut DiagnosticStyledString,\n         mut t2_out: &mut DiagnosticStyledString,\n         path: String,\n-        sub: &ty::subst::Substs<'tcx>,\n+        sub: ty::subst::SubstsRef<'tcx>,\n         other_path: String,\n         other_ty: &Ty<'tcx>,\n     ) -> Option<()> {\n@@ -687,21 +687,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn strip_generic_default_params(\n         &self,\n         def_id: DefId,\n-        substs: &ty::subst::Substs<'tcx>,\n-    ) -> &'tcx ty::subst::Substs<'tcx> {\n+        substs: ty::subst::SubstsRef<'tcx>,\n+    ) -> SubstsRef<'tcx> {\n         let generics = self.tcx.generics_of(def_id);\n         let mut num_supplied_defaults = 0;\n-        let mut type_params = generics\n-            .params\n-            .iter()\n-            .rev()\n-            .filter_map(|param| match param.kind {\n-                ty::GenericParamDefKind::Lifetime => None,\n-                ty::GenericParamDefKind::Type { has_default, .. } => {\n-                    Some((param.def_id, has_default))\n-                }\n-            })\n-            .peekable();\n+        let mut type_params = generics.params.iter().rev().filter_map(|param| match param.kind {\n+            ty::GenericParamDefKind::Lifetime => None,\n+            ty::GenericParamDefKind::Type { has_default, .. } => Some((param.def_id, has_default)),\n+            ty::GenericParamDefKind::Const => None, // FIXME(const_generics:defaults)\n+        }).peekable();\n         let has_default = {\n             let has_default = type_params.peek().map(|(_, has_default)| has_default);\n             *has_default.unwrap_or(&false)"}, {"sha": "86d7a19bc83090cc1aeb7db4a54294f14b37ec00", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n \n         let (span_1, span_2, main_label, span_label) = match (sup_is_ret_type, sub_is_ret_type) {\n             (None, None) => {\n-                let (main_label_1, span_label_1) = if ty_sup.id == ty_sub.id {\n+                let (main_label_1, span_label_1) = if ty_sup.hir_id == ty_sub.hir_id {\n                     (\n                         \"this type is declared with multiple lifetimes...\".to_owned(),\n                         \"...but data with one lifetime flows into the other here\".to_owned()"}, {"sha": "506388c268bb107e01ecade10240980af9297ab7", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -7,7 +7,7 @@ use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty;\n use crate::ty::error::ExpectedFound;\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::SubstsRef;\n use crate::util::ppaux::RegionHighlightMode;\n \n impl NiceRegionError<'me, 'gcx, 'tcx> {\n@@ -175,8 +175,8 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         sub_placeholder: Option<ty::Region<'tcx>>,\n         sup_placeholder: Option<ty::Region<'tcx>>,\n         trait_def_id: DefId,\n-        expected_substs: &'tcx Substs<'tcx>,\n-        actual_substs: &'tcx Substs<'tcx>,\n+        expected_substs: SubstsRef<'tcx>,\n+        actual_substs: SubstsRef<'tcx>,\n     ) -> DiagnosticBuilder<'me> {\n         debug!(\n             \"try_report_placeholders_trait(\\"}, {"sha": "cc1c439f3bd94fbc7a4a4e65b146eaec8ab6c270", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -18,7 +18,7 @@ use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use crate::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::relate::RelateResult;\n-use crate::ty::subst::{Kind, Substs};\n+use crate::ty::subst::{Kind, InternalSubsts, SubstsRef};\n use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners};\n use crate::ty::{FloatVid, IntVid, TyVid};\n use crate::util::nodemap::FxHashMap;\n@@ -656,7 +656,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         type_variables\n             .unsolved_variables()\n             .into_iter()\n-            .map(|t| self.tcx.mk_var(t))\n+            .map(|t| self.tcx.mk_ty_var(t))\n             .chain(\n                 (0..int_unification_table.len())\n                     .map(|i| ty::IntVid { index: i as u32 })\n@@ -981,7 +981,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(false, origin))\n+        self.tcx.mk_ty_var(self.next_ty_var_id(false, origin))\n     }\n \n     pub fn next_ty_var_in_universe(\n@@ -992,11 +992,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let vid = self.type_variables\n             .borrow_mut()\n             .new_var(universe, false, origin);\n-        self.tcx.mk_var(vid)\n+        self.tcx.mk_ty_var(vid)\n     }\n \n     pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(true, origin))\n+        self.tcx.mk_ty_var(self.next_ty_var_id(true, origin))\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -1081,15 +1081,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     TypeVariableOrigin::TypeParameterDefinition(span, param.name),\n                 );\n \n-                self.tcx.mk_var(ty_var_id).into()\n+                self.tcx.mk_ty_var(ty_var_id).into()\n+            }\n+            GenericParamDefKind::Const { .. } => {\n+                unimplemented!() // FIXME(const_generics)\n             }\n         }\n     }\n \n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n-    pub fn fresh_substs_for_item(&self, span: Span, def_id: DefId) -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))\n+    pub fn fresh_substs_for_item(&self, span: Span, def_id: DefId) -> SubstsRef<'tcx> {\n+        InternalSubsts::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))\n     }\n \n     /// Returns `true` if errors have been reported since this infcx was"}, {"sha": "7140af36acbdc4191a0133b85f35f323b250b863", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -310,7 +310,7 @@ where\n             ty::Projection(projection_ty)\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {\n-                return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_var(vid)));\n+                return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_ty_var(vid)));\n             }\n \n             _ => (),\n@@ -764,7 +764,7 @@ where\n                             // the universe `_universe`.\n                             let new_var_id = variables.new_var(self.universe, false, origin);\n \n-                            let u = self.tcx().mk_var(new_var_id);\n+                            let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\n                                 \"generalize: replacing original vid={:?} with new={:?}\",\n                                 vid,"}, {"sha": "8bd20843163201d84419586d2af284c98e95f62b", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -4,12 +4,11 @@ use crate::hir::Node;\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n-use syntax::ast;\n use crate::traits::{self, PredicateObligation};\n use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n use crate::ty::outlives::Component;\n-use crate::ty::subst::{Kind, Substs, UnpackedKind};\n+use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, UnpackedKind};\n use crate::util::nodemap::DefIdMap;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n@@ -30,7 +29,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     ///     fn foo<'a, 'b, T>() -> Foo<'a, T>\n     ///\n     /// then `substs` would be `['a, T]`.\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n \n     /// The type variable that represents the value of the abstract type\n     /// that we require. In other words, after we compile this function,\n@@ -381,10 +380,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         substs,\n                         item_def_id: _,\n                     }) => {\n-                        for r in substs.regions() {\n-                            bound_region(r);\n+                        for k in substs {\n+                            match k.unpack() {\n+                                UnpackedKind::Lifetime(lt) => bound_region(lt),\n+                                UnpackedKind::Type(ty) => types.push(ty),\n+                                UnpackedKind::Const(_) => {\n+                                    // Const parameters don't impose constraints.\n+                                }\n+                            }\n                         }\n-                        types.extend(substs.types());\n                     }\n \n                     Component::EscapingProjection(more_components) => {\n@@ -437,7 +441,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // lifetimes with 'static and remapping only those used in the\n         // `impl Trait` return type, resulting in the parameters\n         // shifting.\n-        let id_substs = Substs::identity_for_item(gcx, def_id);\n+        let id_substs = InternalSubsts::identity_for_item(gcx, def_id);\n         let map: FxHashMap<Kind<'tcx>, Kind<'gcx>> = opaque_defn\n             .substs\n             .iter()\n@@ -681,13 +685,14 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                     //     let x = || foo(); // returns the Opaque assoc with `foo`\n                     // }\n                     // ```\n-                    if let Some(opaque_node_id) = tcx.hir().as_local_node_id(def_id) {\n+                    if let Some(opaque_hir_id) = tcx.hir().as_local_hir_id(def_id) {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n-                            let opaque_parent_node_id = tcx.hir().get_parent(opaque_node_id);\n-                            parent_def_id == tcx.hir().local_def_id(opaque_parent_node_id)\n+                            let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n+                            parent_def_id == tcx.hir()\n+                                                .local_def_id_from_hir_id(opaque_parent_hir_id)\n                         };\n-                        let in_definition_scope = match tcx.hir().find(opaque_node_id) {\n+                        let in_definition_scope = match tcx.hir().find_by_hir_id(opaque_hir_id) {\n                             Some(Node::Item(item)) => match item.node {\n                                 // impl trait\n                                 hir::ItemKind::Existential(hir::ExistTy {\n@@ -701,21 +706,21 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                                 }) => may_define_existential_type(\n                                     tcx,\n                                     self.parent_def_id,\n-                                    opaque_node_id,\n+                                    opaque_hir_id,\n                                 ),\n                                 _ => def_scope_default(),\n                             },\n                             Some(Node::ImplItem(item)) => match item.node {\n                                 hir::ImplItemKind::Existential(_) => may_define_existential_type(\n                                     tcx,\n                                     self.parent_def_id,\n-                                    opaque_node_id,\n+                                    opaque_hir_id,\n                                 ),\n                                 _ => def_scope_default(),\n                             },\n                             _ => bug!(\n                                 \"expected (impl) item, found {}\",\n-                                tcx.hir().node_to_string(opaque_node_id),\n+                                tcx.hir().hir_to_string(opaque_hir_id),\n                             ),\n                         };\n                         if in_definition_scope {\n@@ -740,7 +745,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         &mut self,\n         ty: Ty<'tcx>,\n         def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n+        substs: SubstsRef<'tcx>,\n     ) -> Ty<'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n@@ -834,20 +839,20 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n pub fn may_define_existential_type(\n     tcx: TyCtxt<'_, '_, '_>,\n     def_id: DefId,\n-    opaque_node_id: ast::NodeId,\n+    opaque_hir_id: hir::HirId,\n ) -> bool {\n-    let mut node_id = tcx\n+    let mut hir_id = tcx\n         .hir()\n-        .as_local_node_id(def_id)\n+        .as_local_hir_id(def_id)\n         .unwrap();\n     // named existential types can be defined by any siblings or\n     // children of siblings\n-    let mod_id = tcx.hir().get_parent(opaque_node_id);\n+    let mod_id = tcx.hir().get_parent_item(opaque_hir_id);\n     // so we walk up the node tree until we hit the root or the parent\n     // of the opaque type\n-    while node_id != mod_id && node_id != ast::CRATE_NODE_ID {\n-        node_id = tcx.hir().get_parent(node_id);\n+    while hir_id != mod_id && hir_id != hir::CRATE_HIR_ID {\n+        hir_id = tcx.hir().get_parent_item(hir_id);\n     }\n     // syntactically we are allowed to define the concrete type\n-    node_id == mod_id\n+    hir_id == mod_id\n }"}, {"sha": "ee66032848519887c0454b0290946d6fd872c398", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -67,6 +67,7 @@ use crate::hir;\n use crate::traits::ObligationCause;\n use crate::ty::outlives::Component;\n use crate::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::subst::UnpackedKind;\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Registers that the given region obligation must be resolved\n@@ -430,13 +431,18 @@ where\n         if approx_env_bounds.is_empty() && trait_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n-            for component_ty in projection_ty.substs.types() {\n-                self.type_must_outlive(origin.clone(), component_ty, region);\n-            }\n-\n-            for r in projection_ty.substs.regions() {\n-                self.delegate\n-                    .push_sub_region_constraint(origin.clone(), region, r);\n+            for k in projection_ty.substs {\n+                match k.unpack() {\n+                    UnpackedKind::Lifetime(lt) => {\n+                        self.delegate.push_sub_region_constraint(origin.clone(), region, lt);\n+                    }\n+                    UnpackedKind::Type(ty) => {\n+                        self.type_must_outlive(origin.clone(), ty, region);\n+                    }\n+                    UnpackedKind::Const(_) => {\n+                        // Const parameters don't impose constraints.\n+                    }\n+                }\n             }\n \n             return;"}, {"sha": "e1ad5aeea19fcb189ec636562a1eef7d1c3a3019", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -2,7 +2,7 @@ use crate::hir::def_id::DefId;\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::{GenericKind, VerifyBound};\n use crate::traits;\n-use crate::ty::subst::{Subst, Substs};\n+use crate::ty::subst::{Subst, InternalSubsts};\n use crate::ty::{self, Ty, TyCtxt};\n use crate::util::captures::Captures;\n \n@@ -292,7 +292,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n             .iter()\n             .map(|(p, _)| *p)\n             .collect();\n-        let identity_substs = Substs::identity_for_item(tcx, assoc_item_def_id);\n+        let identity_substs = InternalSubsts::identity_for_item(tcx, assoc_item_def_id);\n         let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n         self.collect_outlives_from_predicate_list(\n             move |ty| ty == identity_proj,"}, {"sha": "6adfaa53946ac29615932017d041d8d49fd83840", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -141,14 +141,8 @@ pub mod util {\n     pub mod bug;\n }\n \n-// A private module so that macro-expanded idents like\n-// `::rustc::lint::Lint` will also work in `rustc` itself.\n-//\n-// `libstd` uses the same trick.\n-#[doc(hidden)]\n-mod rustc {\n-    pub use crate::lint;\n-}\n+// Allows macros to refer to this crate as `::rustc`\n+extern crate self as rustc;\n \n // FIXME(#27438): right now the unit tests of librustc don't refer to any actual\n //                functions generated in librustc_data_structures (all"}, {"sha": "ad0ed39185c1c4b19c017de63080a870f566c308", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -386,6 +386,12 @@ declare_lint! {\n     \"ambiguous associated items\"\n }\n \n+declare_lint! {\n+    pub NESTED_IMPL_TRAIT,\n+    Warn,\n+    \"nested occurrence of `impl Trait` type\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// that are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -457,6 +463,7 @@ impl LintPass for HardwiredLints {\n             parser::ILL_FORMED_ATTRIBUTE_INPUT,\n             DEPRECATED_IN_FUTURE,\n             AMBIGUOUS_ASSOCIATED_ITEMS,\n+            NESTED_IMPL_TRAIT,\n         )\n     }\n }\n@@ -474,6 +481,7 @@ pub enum BuiltinLintDiagnostics {\n     ElidedLifetimesInPaths(usize, Span, bool, Span, String),\n     UnknownCrateTypes(Span, String, String),\n     UnusedImports(String, Vec<(Span, String)>),\n+    NestedImplTrait { outer_impl_trait_span: Span, inner_impl_trait_span: Span },\n }\n \n impl BuiltinLintDiagnostics {\n@@ -564,6 +572,12 @@ impl BuiltinLintDiagnostics {\n                     );\n                 }\n             }\n+            BuiltinLintDiagnostics::NestedImplTrait {\n+                outer_impl_trait_span, inner_impl_trait_span\n+            } => {\n+                db.span_label(outer_impl_trait_span, \"outer `impl Trait`\");\n+                db.span_label(inner_impl_trait_span, \"nested `impl Trait` here\");\n+            }\n         }\n     }\n }"}, {"sha": "9761ee313533fe446b3b2410996e798f676e4e88", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -729,8 +729,7 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n         match span {\n             Some(s) => self.tcx.struct_span_lint_hir(lint, hir_id, s, msg),\n             None => {\n-                let node_id = self.tcx.hir().hir_to_node_id(hir_id); // FIXME(@ljedrz): remove later\n-                self.tcx.struct_lint_node(lint, node_id, msg)\n+                self.tcx.struct_lint_node(lint, hir_id, msg)\n             },\n         }\n     }\n@@ -793,11 +792,11 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n         run_lints!(self, exit_lint_attrs, attrs);\n     }\n \n-    fn with_param_env<F>(&mut self, id: ast::NodeId, f: F)\n+    fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n         where F: FnOnce(&mut Self),\n     {\n         let old_param_env = self.param_env;\n-        self.param_env = self.tcx.param_env(self.tcx.hir().local_def_id(id));\n+        self.param_env = self.tcx.param_env(self.tcx.hir().local_def_id_from_hir_id(id));\n         f(self);\n         self.param_env = old_param_env;\n     }\n@@ -841,7 +840,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         let generics = self.generics.take();\n         self.generics = it.node.generics();\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.id, |cx| {\n+            cx.with_param_env(it.hir_id, |cx| {\n                 run_lints!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n                 run_lints!(cx, check_item_post, it);\n@@ -852,7 +851,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.id, |cx| {\n+            cx.with_param_env(it.hir_id, |cx| {\n                 run_lints!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n                 run_lints!(cx, check_foreign_item_post, it);\n@@ -983,7 +982,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         let generics = self.generics.take();\n         self.generics = Some(&trait_item.generics);\n         self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n-            cx.with_param_env(trait_item.id, |cx| {\n+            cx.with_param_env(trait_item.hir_id, |cx| {\n                 run_lints!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n                 run_lints!(cx, check_trait_item_post, trait_item);\n@@ -996,7 +995,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         let generics = self.generics.take();\n         self.generics = Some(&impl_item.generics);\n         self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n-            cx.with_param_env(impl_item.id, |cx| {\n+            cx.with_param_env(impl_item.hir_id, |cx| {\n                 run_lints!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n                 run_lints!(cx, check_impl_item_post, impl_item);"}, {"sha": "496ff568b31b4d5a775a0f1f1382dfa477a9fff6", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -132,14 +132,22 @@ macro_rules! declare_lint {\n \n #[macro_export]\n macro_rules! declare_tool_lint {\n-    ($vis: vis $tool: ident ::$NAME: ident, $Level: ident, $desc: expr) => (\n-        declare_tool_lint!{$vis $tool::$NAME, $Level, $desc, false}\n+    (\n+        $(#[$attr:meta])* $vis:vis $tool:ident ::$NAME:ident, $Level: ident, $desc: expr\n+    ) => (\n+        declare_tool_lint!{$(#[$attr])* $vis $tool::$NAME, $Level, $desc, false}\n     );\n-    ($vis: vis $tool: ident ::$NAME: ident, $Level: ident, $desc: expr,\n-     report_in_external_macro: $rep: expr) => (\n-         declare_tool_lint!{$vis $tool::$NAME, $Level, $desc, $rep}\n+    (\n+        $(#[$attr:meta])* $vis:vis $tool:ident ::$NAME:ident, $Level:ident, $desc:expr,\n+        report_in_external_macro: $rep:expr\n+    ) => (\n+         declare_tool_lint!{$(#[$attr])* $vis $tool::$NAME, $Level, $desc, $rep}\n     );\n-    ($vis: vis $tool: ident ::$NAME: ident, $Level: ident, $desc: expr, $external: expr) => (\n+    (\n+        $(#[$attr:meta])* $vis:vis $tool:ident ::$NAME:ident, $Level:ident, $desc:expr,\n+        $external:expr\n+    ) => (\n+        $(#[$attr])*\n         $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n             name: &concat!(stringify!($tool), \"::\", stringify!($NAME)),\n             default_level: $crate::lint::$Level,\n@@ -723,7 +731,7 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n     };\n     let krate = tcx.hir().krate();\n \n-    builder.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |builder| {\n+    builder.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |builder| {\n         intravisit::walk_crate(builder, krate);\n     });\n \n@@ -737,13 +745,13 @@ struct LintLevelMapBuilder<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n     fn with_lint_attrs<F>(&mut self,\n-                          id: ast::NodeId,\n+                          id: hir::HirId,\n                           attrs: &[ast::Attribute],\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n         let push = self.levels.push(attrs);\n-        self.levels.register_id(self.tcx.hir().definitions().node_to_hir_id(id));\n+        self.levels.register_id(id);\n         f(self);\n         self.levels.pop(push);\n     }\n@@ -755,25 +763,25 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        self.with_lint_attrs(it.id, &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n             intravisit::walk_item(builder, it);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n-        self.with_lint_attrs(it.id, &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n             intravisit::walk_foreign_item(builder, it);\n         })\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n-        self.with_lint_attrs(e.id, &e.attrs, |builder| {\n+        self.with_lint_attrs(e.hir_id, &e.attrs, |builder| {\n             intravisit::walk_expr(builder, e);\n         })\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        self.with_lint_attrs(s.id, &s.attrs, |builder| {\n+        self.with_lint_attrs(s.hir_id, &s.attrs, |builder| {\n             intravisit::walk_struct_field(builder, s);\n         })\n     }\n@@ -782,25 +790,25 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.data.id(), &v.node.attrs, |builder| {\n+        self.with_lint_attrs(v.node.data.hir_id(), &v.node.attrs, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n-        self.with_lint_attrs(l.id, &l.attrs, |builder| {\n+        self.with_lint_attrs(l.hir_id, &l.attrs, |builder| {\n             intravisit::walk_local(builder, l);\n         })\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |builder| {\n+        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |builder| {\n             intravisit::walk_trait_item(builder, trait_item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |builder| {\n+        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |builder| {\n             intravisit::walk_impl_item(builder, impl_item);\n         });\n     }"}, {"sha": "e4890977c9bd62357ad9e5786cb02076a9e79d46", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -17,21 +17,23 @@ use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_target::spec::Target;\n use rustc_data_structures::sync::{self, MetadataRef, Lrc};\n+use rustc_macros::HashStable;\n \n pub use self::NativeLibraryKind::*;\n \n // lonely orphan structs and enums looking for a better home\n \n /// Where a crate came from on the local filesystem. One of these three options\n /// must be non-None.\n-#[derive(PartialEq, Clone, Debug)]\n+#[derive(PartialEq, Clone, Debug, HashStable)]\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n     pub rmeta: Option<(PathBuf, PathKind)>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Copy, Clone,\n+         Ord, PartialOrd, Eq, PartialEq, Debug, HashStable)]\n pub enum DepKind {\n     /// A dependency that is only used for its macros, none of which are visible from other crates.\n     /// These are included in the metadata only as placeholders and are ignored when decoding.\n@@ -79,13 +81,14 @@ impl LibSource {\n     }\n }\n \n-#[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub enum NativeLibraryKind {\n     /// native static library (.a archive)\n     NativeStatic,\n@@ -97,7 +100,7 @@ pub enum NativeLibraryKind {\n     NativeUnknown,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n     pub name: Option<Symbol>,\n@@ -106,13 +109,13 @@ pub struct NativeLibrary {\n     pub wasm_import_module: Option<Symbol>,\n }\n \n-#[derive(Clone, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ForeignModule {\n     pub foreign_items: Vec<DefId>,\n     pub def_id: DefId,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub struct ExternCrate {\n     pub src: ExternCrateSource,\n \n@@ -129,7 +132,7 @@ pub struct ExternCrate {\n     pub direct: bool,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub enum ExternCrateSource {\n     /// Crate is loaded by `extern crate`.\n     Extern("}, {"sha": "94de999c25da81843fe95ae8889034faa3094bee", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 78, "deletions": 66, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -3,7 +3,7 @@\n // from live codes are live, and everything else is dead.\n \n use crate::hir::Node;\n-use crate::hir::{self, PatKind};\n+use crate::hir::{self, PatKind, TyKind};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n \n@@ -26,8 +26,8 @@ use syntax_pos;\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            node_id: ast::NodeId) -> bool {\n-    match tcx.hir().find(node_id) {\n+                            hir_id: hir::HirId) -> bool {\n+    match tcx.hir().find_by_hir_id(hir_id) {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n         Some(Node::ForeignItem(..)) |\n@@ -39,33 +39,33 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n-    worklist: Vec<ast::NodeId>,\n+    worklist: Vec<hir::HirId>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n-    live_symbols: FxHashSet<ast::NodeId>,\n+    live_symbols: FxHashSet<hir::HirId>,\n     repr_has_repr_c: bool,\n     in_pat: bool,\n     inherited_pub_visibility: bool,\n     ignore_variant_stack: Vec<DefId>,\n     // maps from tuple struct constructors to tuple struct items\n-    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n+    struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-            if should_explore(self.tcx, node_id) ||\n-               self.struct_constructors.contains_key(&node_id) {\n-                self.worklist.push(node_id);\n+        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+            if should_explore(self.tcx, hir_id) ||\n+               self.struct_constructors.contains_key(&hir_id) {\n+                self.worklist.push(hir_id);\n             }\n-            self.live_symbols.insert(node_id);\n+            self.live_symbols.insert(hir_id);\n         }\n     }\n \n     fn insert_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-            debug_assert!(!should_explore(self.tcx, node_id));\n-            self.live_symbols.insert(node_id);\n+        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+            debug_assert!(!should_explore(self.tcx, hir_id));\n+            self.live_symbols.insert(hir_id);\n         }\n     }\n \n@@ -99,10 +99,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_access(&mut self, lhs: &hir::Expr, node_id: ast::NodeId) {\n+    fn handle_field_access(&mut self, lhs: &hir::Expr, hir_id: hir::HirId) {\n         match self.tables.expr_ty_adjusted(lhs).sty {\n             ty::Adt(def, _) => {\n-                let index = self.tcx.field_index(node_id, self.tables);\n+                let index = self.tcx.field_index(hir_id, self.tables);\n                 self.insert_def_id(def.non_enum_variant().fields[index].did);\n             }\n             ty::Tuple(..) => {}\n@@ -120,7 +120,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             if let PatKind::Wild = pat.node.pat.node {\n                 continue;\n             }\n-            let index = self.tcx.field_index(pat.node.id, self.tables);\n+            let index = self.tcx.field_index(pat.node.hir_id, self.tables);\n             self.insert_def_id(variant.fields[index].did);\n         }\n     }\n@@ -136,7 +136,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             // tuple struct constructor function\n             let id = self.struct_constructors.get(&id).cloned().unwrap_or(id);\n \n-            if let Some(node) = self.tcx.hir().find(id) {\n+            if let Some(node) = self.tcx.hir().find_by_hir_id(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }\n@@ -152,7 +152,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                        let def_id = self.tcx.hir().local_def_id(item.id);\n+                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                         let def = self.tcx.adt_def(def_id);\n                         self.repr_has_repr_c = def.repr.c();\n \n@@ -190,7 +190,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &hir::HirVec<hir::Field>) {\n         if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did.is_local() {\n             for field in fields {\n-                let index = self.tcx.field_index(field.id, self.tables);\n+                let index = self.tcx.field_index(field.hir_id, self.tables);\n                 self.insert_def_id(adt.non_enum_variant().fields[index].did);\n             }\n         }\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         let live_fields = def.fields().iter().filter(|f| {\n             has_repr_c || inherited_pub_visibility || f.vis.node.is_pub()\n         });\n-        self.live_symbols.extend(live_fields.map(|f| f.id));\n+        self.live_symbols.extend(live_fields.map(|f| f.hir_id));\n \n         intravisit::walk_struct_def(self, def);\n     }\n@@ -232,7 +232,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.lookup_and_handle_method(expr.hir_id);\n             }\n             hir::ExprKind::Field(ref lhs, ..) => {\n-                self.handle_field_access(&lhs, expr.id);\n+                self.handle_field_access(&lhs, expr.hir_id);\n             }\n             hir::ExprKind::Struct(_, ref fields, _) => {\n                 if let ty::Adt(ref adt, _) = self.tables.expr_ty(expr).sty {\n@@ -282,10 +282,21 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         self.handle_definition(path.def);\n         intravisit::walk_path(self, path);\n     }\n+\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        match ty.node {\n+            TyKind::Def(item_id, _) => {\n+                let item = self.tcx.hir().expect_item(item_id.id);\n+                intravisit::walk_item(self, item);\n+            }\n+            _ => ()\n+        }\n+        intravisit::walk_ty(self, ty);\n+    }\n }\n \n fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n-                                    id: ast::NodeId,\n+                                    id: hir::HirId,\n                                     attrs: &[ast::Attribute]) -> bool {\n     if attr::contains_name(attrs, \"lang\") {\n         return true;\n@@ -306,7 +317,7 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n         return true;\n     }\n \n-    let def_id = tcx.hir().local_def_id(id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let cg_attrs = tcx.codegen_fn_attrs(def_id);\n \n     // #[used], #[no_mangle], #[export_name], etc also keeps the item alive\n@@ -333,25 +344,25 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n struct LifeSeeder<'k, 'tcx: 'k> {\n-    worklist: Vec<ast::NodeId>,\n+    worklist: Vec<hir::HirId>,\n     krate: &'k hir::Crate,\n     tcx: TyCtxt<'k, 'tcx, 'tcx>,\n     // see `MarkSymbolVisitor::struct_constructors`\n-    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n+    struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n }\n \n impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let allow_dead_code = has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                               item.id,\n+                                                               item.hir_id,\n                                                                &item.attrs);\n         if allow_dead_code {\n-            self.worklist.push(item.id);\n+            self.worklist.push(item.hir_id);\n         }\n         match item.node {\n             hir::ItemKind::Enum(ref enum_def, _) if allow_dead_code => {\n                 self.worklist.extend(enum_def.variants.iter()\n-                                                      .map(|variant| variant.node.data.id()));\n+                                                      .map(|variant| variant.node.data.hir_id()));\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n@@ -360,9 +371,9 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                         hir::TraitItemKind::Const(_, Some(_)) |\n                         hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n                             if has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                                trait_item.id,\n+                                                                trait_item.hir_id,\n                                                                 &trait_item.attrs) {\n-                                self.worklist.push(trait_item.id);\n+                                self.worklist.push(trait_item.hir_id);\n                             }\n                         }\n                         _ => {}\n@@ -374,14 +385,14 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if opt_trait.is_some() ||\n                             has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                             impl_item.id,\n+                                                             impl_item.hir_id,\n                                                              &impl_item.attrs) {\n-                        self.worklist.push(impl_item_ref.id.node_id);\n+                        self.worklist.push(impl_item_ref.id.hir_id);\n                     }\n                 }\n             }\n             hir::ItemKind::Struct(ref variant_data, _) => {\n-                self.struct_constructors.insert(variant_data.id(), item.id);\n+                self.struct_constructors.insert(variant_data.hir_id(), item.hir_id);\n             }\n             _ => ()\n         }\n@@ -400,16 +411,16 @@ fn create_and_seed_worklist<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     access_levels: &privacy::AccessLevels,\n     krate: &hir::Crate,\n-) -> (Vec<ast::NodeId>, FxHashMap<ast::NodeId, ast::NodeId>) {\n+) -> (Vec<hir::HirId>, FxHashMap<hir::HirId, hir::HirId>) {\n     let worklist = access_levels.map.iter().filter_map(|(&id, level)| {\n         if level >= &privacy::AccessLevel::Reachable {\n-            Some(id)\n+            Some(tcx.hir().node_to_hir_id(id))\n         } else {\n             None\n         }\n     }).chain(\n         // Seed entry point\n-        tcx.entry_fn(LOCAL_CRATE).map(|(def_id, _)| tcx.hir().as_local_node_id(def_id).unwrap())\n+        tcx.entry_fn(LOCAL_CRATE).map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id).unwrap())\n     ).collect::<Vec<_>>();\n \n     // Seed implemented trait items\n@@ -427,7 +438,7 @@ fn create_and_seed_worklist<'a, 'tcx>(\n fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n-                       -> FxHashSet<ast::NodeId> {\n+                       -> FxHashSet<hir::HirId> {\n     let (worklist, struct_constructors) = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n@@ -446,7 +457,7 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct DeadVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: FxHashSet<ast::NodeId>,\n+    live_symbols: FxHashSet<hir::HirId>,\n }\n \n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n@@ -461,33 +472,33 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             | hir::ItemKind::Union(..) => true,\n             _ => false\n         };\n-        should_warn && !self.symbol_is_live(item.id)\n+        should_warn && !self.symbol_is_live(item.hir_id)\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.id));\n+        let field_type = self.tcx.type_of(self.tcx.hir().local_def_id_from_hir_id(field.hir_id));\n         !field.is_positional()\n-            && !self.symbol_is_live(field.id)\n+            && !self.symbol_is_live(field.hir_id)\n             && !field_type.is_phantom_data()\n-            && !has_allow_dead_code_or_lang_attr(self.tcx, field.id, &field.attrs)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, field.hir_id, &field.attrs)\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n-        !self.symbol_is_live(variant.data.id())\n+        !self.symbol_is_live(variant.data.hir_id())\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                 variant.data.id(),\n+                                                 variant.data.hir_id(),\n                                                  &variant.attrs)\n     }\n \n     fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem) -> bool {\n-        !self.symbol_is_live(fi.id)\n-            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.id, &fi.attrs)\n+        !self.symbol_is_live(fi.hir_id)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.hir_id, &fi.attrs)\n     }\n \n-    // id := node id of an item's definition.\n+    // id := HIR id of an item's definition.\n     fn symbol_is_live(\n         &mut self,\n-        id: ast::NodeId,\n+        id: hir::HirId,\n     ) -> bool {\n         if self.live_symbols.contains(&id) {\n             return true;\n@@ -496,12 +507,12 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let def_id = self.tcx.hir().local_def_id(id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(id);\n         let inherent_impls = self.tcx.inherent_impls(def_id);\n         for &impl_did in inherent_impls.iter() {\n             for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n-                if let Some(item_node_id) = self.tcx.hir().as_local_node_id(item_did) {\n-                    if self.live_symbols.contains(&item_node_id) {\n+                if let Some(item_hir_id) = self.tcx.hir().as_local_hir_id(item_did) {\n+                    if self.live_symbols.contains(&item_hir_id) {\n                         return true;\n                     }\n                 }\n@@ -511,18 +522,18 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn warn_dead_code(&mut self,\n-                      id: ast::NodeId,\n+                      id: hir::HirId,\n                       span: syntax_pos::Span,\n                       name: ast::Name,\n                       node_type: &str,\n                       participle: &str) {\n         if !name.as_str().starts_with(\"_\") {\n             self.tcx\n-                .lint_node(lint::builtin::DEAD_CODE,\n-                           id,\n-                           span,\n-                           &format!(\"{} is never {}: `{}`\",\n-                                    node_type, participle, name));\n+                .lint_hir(lint::builtin::DEAD_CODE,\n+                          id,\n+                          span,\n+                          &format!(\"{} is never {}: `{}`\",\n+                                   node_type, participle, name));\n         }\n     }\n }\n@@ -555,7 +566,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 _ => \"used\"\n             };\n             self.warn_dead_code(\n-                item.id,\n+                item.hir_id,\n                 span,\n                 item.ident.name,\n                 item.node.descriptive_variant(),\n@@ -572,7 +583,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                      g: &'tcx hir::Generics,\n                      id: hir::HirId) {\n         if self.should_warn_about_variant(&variant.node) {\n-            self.warn_dead_code(variant.node.data.id(), variant.span, variant.node.ident.name,\n+            self.warn_dead_code(variant.node.data.hir_id(), variant.span, variant.node.ident.name,\n                                 \"variant\", \"constructed\");\n         } else {\n             intravisit::walk_variant(self, variant, g, id);\n@@ -581,24 +592,24 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n         if self.should_warn_about_foreign_item(fi) {\n-            self.warn_dead_code(fi.id, fi.span, fi.ident.name,\n+            self.warn_dead_code(fi.hir_id, fi.span, fi.ident.name,\n                                 fi.node.descriptive_variant(), \"used\");\n         }\n         intravisit::walk_foreign_item(self, fi);\n     }\n \n     fn visit_struct_field(&mut self, field: &'tcx hir::StructField) {\n         if self.should_warn_about_field(&field) {\n-            self.warn_dead_code(field.id, field.span, field.ident.name, \"field\", \"used\");\n+            self.warn_dead_code(field.hir_id, field.span, field.ident.name, \"field\", \"used\");\n         }\n         intravisit::walk_struct_field(self, field);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n             hir::ImplItemKind::Const(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id) {\n-                    self.warn_dead_code(impl_item.id,\n+                if !self.symbol_is_live(impl_item.hir_id) {\n+                    self.warn_dead_code(impl_item.hir_id,\n                                         impl_item.span,\n                                         impl_item.ident.name,\n                                         \"associated const\",\n@@ -607,9 +618,10 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Method(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id) {\n+                if !self.symbol_is_live(impl_item.hir_id) {\n                     let span = self.tcx.sess.source_map().def_span(impl_item.span);\n-                    self.warn_dead_code(impl_item.id, span, impl_item.ident.name, \"method\", \"used\");\n+                    self.warn_dead_code(impl_item.hir_id, span, impl_item.ident.name, \"method\",\n+                        \"used\");\n                 }\n                 self.visit_nested_body(body_id)\n             }"}, {"sha": "c20454a8822cd65915aadf872bd6246a4c99d4d8", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -2,11 +2,10 @@ use crate::hir::map as hir_map;\n use crate::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use crate::session::{config, Session};\n use crate::session::config::EntryFnType;\n-use syntax::ast::NodeId;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n use syntax_pos::Span;\n-use crate::hir::{Item, ItemKind, ImplItem, TraitItem};\n+use crate::hir::{HirId, Item, ItemKind, ImplItem, TraitItem};\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n use crate::ty::TyCtxt;\n use crate::ty::query::Providers;\n@@ -17,22 +16,22 @@ struct EntryContext<'a, 'tcx: 'a> {\n     map: &'a hir_map::Map<'tcx>,\n \n     // The top-level function called 'main'\n-    main_fn: Option<(NodeId, Span)>,\n+    main_fn: Option<(HirId, Span)>,\n \n     // The function that has attribute named 'main'\n-    attr_main_fn: Option<(NodeId, Span)>,\n+    attr_main_fn: Option<(HirId, Span)>,\n \n     // The function that has the attribute 'start' on it\n-    start_fn: Option<(NodeId, Span)>,\n+    start_fn: Option<(HirId, Span)>,\n \n     // The functions that one might think are 'main' but aren't, e.g.\n     // main functions not defined at the top level. For diagnostics.\n-    non_main_fns: Vec<(NodeId, Span)> ,\n+    non_main_fns: Vec<(HirId, Span)> ,\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item) {\n-        let def_id = self.map.local_def_id(item.id);\n+        let def_id = self.map.local_def_id_from_hir_id(item.hir_id);\n         let def_key = self.map.def_key(def_id);\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n@@ -106,18 +105,18 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n     match entry_point_type(item, at_root) {\n         EntryPointType::MainNamed => {\n             if ctxt.main_fn.is_none() {\n-                ctxt.main_fn = Some((item.id, item.span));\n+                ctxt.main_fn = Some((item.hir_id, item.span));\n             } else {\n                 span_err!(ctxt.session, item.span, E0136,\n                           \"multiple 'main' functions\");\n             }\n         },\n         EntryPointType::OtherMain => {\n-            ctxt.non_main_fns.push((item.id, item.span));\n+            ctxt.non_main_fns.push((item.hir_id, item.span));\n         },\n         EntryPointType::MainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n-                ctxt.attr_main_fn = Some((item.id, item.span));\n+                ctxt.attr_main_fn = Some((item.hir_id, item.span));\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0137,\n                                  \"multiple functions with a #[main] attribute\")\n@@ -128,7 +127,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n         },\n         EntryPointType::Start => {\n             if ctxt.start_fn.is_none() {\n-                ctxt.start_fn = Some((item.id, item.span));\n+                ctxt.start_fn = Some((item.hir_id, item.span));\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0138, \"multiple 'start' functions\")\n                     .span_label(ctxt.start_fn.unwrap().1, \"previous `start` function here\")\n@@ -144,12 +143,12 @@ fn configure_main(\n     tcx: TyCtxt<'_, '_, '_>,\n     visitor: &EntryContext<'_, '_>,\n ) -> Option<(DefId, EntryFnType)> {\n-    if let Some((node_id, _)) = visitor.start_fn {\n-        Some((tcx.hir().local_def_id(node_id), EntryFnType::Start))\n-    } else if let Some((node_id, _)) = visitor.attr_main_fn {\n-        Some((tcx.hir().local_def_id(node_id), EntryFnType::Main))\n-    } else if let Some((node_id, _)) = visitor.main_fn {\n-        Some((tcx.hir().local_def_id(node_id), EntryFnType::Main))\n+    if let Some((hir_id, _)) = visitor.start_fn {\n+        Some((tcx.hir().local_def_id_from_hir_id(hir_id), EntryFnType::Start))\n+    } else if let Some((hir_id, _)) = visitor.attr_main_fn {\n+        Some((tcx.hir().local_def_id_from_hir_id(hir_id), EntryFnType::Main))\n+    } else if let Some((hir_id, _)) = visitor.main_fn {\n+        Some((tcx.hir().local_def_id_from_hir_id(hir_id), EntryFnType::Main))\n     } else {\n         // No main function\n         let mut err = struct_err!(tcx.sess, E0601,"}, {"sha": "32c7216765533cf65fc925b962b74d1096752dca", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n use std::cmp;\n use std::mem;\n use crate::ty;\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::SubstsRef;\n \n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any\n@@ -33,7 +33,7 @@ impl SymbolExportLevel {\n #[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum ExportedSymbol<'tcx> {\n     NonGeneric(DefId),\n-    Generic(DefId, &'tcx Substs<'tcx>),\n+    Generic(DefId, SubstsRef<'tcx>),\n     NoDefId(ty::SymbolName),\n }\n "}, {"sha": "8ada67efaafdd3048c871095a1ccd73d2e15afbc", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -19,7 +19,6 @@ use crate::ty::{self, TyCtxt, adjustment};\n use crate::hir::{self, PatKind};\n use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n-use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n use crate::util::nodemap::ItemLocalSet;\n@@ -33,7 +32,7 @@ pub trait Delegate<'tcx> {\n     // The value found at `cmt` is either copied or moved, depending\n     // on mode.\n     fn consume(&mut self,\n-               consume_id: ast::NodeId,\n+               consume_id: hir::HirId,\n                consume_span: Span,\n                cmt: &mc::cmt_<'tcx>,\n                mode: ConsumeMode);\n@@ -65,7 +64,7 @@ pub trait Delegate<'tcx> {\n     // The value found at `borrow` is being borrowed at the point\n     // `borrow_id` for the region `loan_region` with kind `bk`.\n     fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n+              borrow_id: hir::HirId,\n               borrow_span: Span,\n               cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n@@ -74,15 +73,18 @@ pub trait Delegate<'tcx> {\n \n     // The local variable `id` is declared but not initialized.\n     fn decl_without_init(&mut self,\n-                         id: ast::NodeId,\n+                         id: hir::HirId,\n                          span: Span);\n \n     // The path at `cmt` is being assigned to.\n     fn mutate(&mut self,\n-              assignment_id: ast::NodeId,\n+              assignment_id: hir::HirId,\n               assignment_span: Span,\n               assignee_cmt: &mc::cmt_<'tcx>,\n               mode: MutateMode);\n+\n+    // A nested closure or generator - only one layer deep.\n+    fn nested_body(&mut self, _body_id: hir::BodyId) {}\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -329,7 +331,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn delegate_consume(&mut self,\n-                        consume_id: ast::NodeId,\n+                        consume_id: hir::HirId,\n                         consume_span: Span,\n                         cmt: &mc::cmt_<'tcx>) {\n         debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n@@ -349,7 +351,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate_consume(expr.id, expr.span, &cmt);\n+        self.delegate_consume(expr.hir_id, expr.span, &cmt);\n         self.walk_expr(expr);\n     }\n \n@@ -359,7 +361,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                    expr: &hir::Expr,\n                    mode: MutateMode) {\n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.mutate(assignment_expr.id, span, &cmt, mode);\n+        self.delegate.mutate(assignment_expr.hir_id, span, &cmt, mode);\n         self.walk_expr(expr);\n     }\n \n@@ -372,7 +374,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                expr, r, bk);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.borrow(expr.id, expr.span, &cmt, r, bk, cause);\n+        self.delegate.borrow(expr.hir_id, expr.span, &cmt, r, bk, cause);\n \n         self.walk_expr(expr)\n     }\n@@ -532,8 +534,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprKind::Closure(.., fn_decl_span, _) => {\n-                self.walk_captures(expr, fn_decl_span)\n+            hir::ExprKind::Closure(_, _, body_id, fn_decl_span, _) => {\n+                self.delegate.nested_body(body_id);\n+                self.walk_captures(expr, fn_decl_span);\n             }\n \n             hir::ExprKind::Box(ref base) => {\n@@ -609,8 +612,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match local.init {\n             None => {\n                 local.pat.each_binding(|_, hir_id, span, _| {\n-                    let node_id = self.mc.tcx.hir().hir_to_node_id(hir_id);\n-                    self.delegate.decl_without_init(node_id, span);\n+                    self.delegate.decl_without_init(hir_id, span);\n                 })\n             }\n \n@@ -629,7 +631,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     /// Indicates that the value of `blk` will be consumed, meaning either copied or moved\n     /// depending on its type.\n     fn walk_block(&mut self, blk: &hir::Block) {\n-        debug!(\"walk_block(blk.id={})\", blk.id);\n+        debug!(\"walk_block(blk.hir_id={})\", blk.hir_id);\n \n         for stmt in &blk.stmts {\n             self.walk_stmt(stmt);\n@@ -662,7 +664,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n                     let is_mentioned = fields.iter().any(|f| {\n-                        self.tcx().field_index(f.id, self.mc.tables) == f_index\n+                        self.tcx().field_index(f.hir_id, self.mc.tables) == f_index\n                     });\n                     if !is_mentioned {\n                         let cmt_field = self.mc.cat_field(\n@@ -672,7 +674,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                             with_field.ident,\n                             with_field.ty(self.tcx(), substs)\n                         );\n-                        self.delegate_consume(with_expr.id, with_expr.span, &cmt_field);\n+                        self.delegate_consume(with_expr.hir_id, with_expr.span, &cmt_field);\n                     }\n                 }\n             }\n@@ -711,7 +713,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 adjustment::Adjust::Unsize => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    self.delegate_consume(expr.id, expr.span, &cmt);\n+                    self.delegate_consume(expr.hir_id, expr.span, &cmt);\n                 }\n \n                 adjustment::Adjust::Deref(None) => {}\n@@ -723,7 +725,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // this is an autoref of `x`.\n                 adjustment::Adjust::Deref(Some(ref deref)) => {\n                     let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n-                    self.delegate.borrow(expr.id, expr.span, &cmt, deref.region, bk, AutoRef);\n+                    self.delegate.borrow(expr.hir_id, expr.span, &cmt, deref.region, bk, AutoRef);\n                 }\n \n                 adjustment::Adjust::Borrow(ref autoref) => {\n@@ -741,14 +743,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     expr: &hir::Expr,\n                     cmt_base: &mc::cmt_<'tcx>,\n                     autoref: &adjustment::AutoBorrow<'tcx>) {\n-        debug!(\"walk_autoref(expr.id={} cmt_base={:?} autoref={:?})\",\n-               expr.id,\n+        debug!(\"walk_autoref(expr.hir_id={} cmt_base={:?} autoref={:?})\",\n+               expr.hir_id,\n                cmt_base,\n                autoref);\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n-                self.delegate.borrow(expr.id,\n+                self.delegate.borrow(expr.hir_id,\n                                      expr.span,\n                                      cmt_base,\n                                      r,\n@@ -757,8 +759,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n-                debug!(\"walk_autoref: expr.id={} cmt_base={:?}\",\n-                       expr.id,\n+                debug!(\"walk_autoref: expr.hir_id={} cmt_base={:?}\",\n+                       expr.hir_id,\n                        cmt_base);\n \n                 // Converting from a &T to *T (or &mut T to *mut T) is\n@@ -770,7 +772,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         data: region::ScopeData::Node\n                     }));\n \n-                self.delegate.borrow(expr.id,\n+                self.delegate.borrow(expr.hir_id,\n                                      expr.span,\n                                      cmt_base,\n                                      r,\n@@ -862,17 +864,17 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n                     // Each match binding is effectively an assignment to the\n                     // binding being produced.\n-                    let def = Def::Local(canonical_id);\n+                    let def = Def::Local(mc.tcx.hir().hir_to_node_id(canonical_id));\n                     if let Ok(ref binding_cmt) = mc.cat_def(pat.hir_id, pat.span, pat_ty, def) {\n-                        delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n+                        delegate.mutate(pat.hir_id, pat.span, binding_cmt, MutateMode::Init);\n                     }\n \n                     // It is also a borrow or copy/move of the value being matched.\n                     match bm {\n                         ty::BindByReference(m) => {\n                             if let ty::Ref(r, _, _) = pat_ty.sty {\n                                 let bk = ty::BorrowKind::from_mutbl(m);\n-                                delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n+                                delegate.borrow(pat.hir_id, pat.span, &cmt_pat, r, bk, RefBinding);\n                             }\n                         }\n                         ty::BindByValue(..) => {\n@@ -920,10 +922,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_captures(&mut self, closure_expr: &hir::Expr, fn_decl_span: Span) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n-        self.tcx().with_freevars(closure_expr.id, |freevars| {\n+        let closure_def_id = self.tcx().hir().local_def_id_from_hir_id(closure_expr.hir_id);\n+        self.tcx().with_freevars(closure_expr.hir_id, |freevars| {\n             for freevar in freevars {\n                 let var_hir_id = self.tcx().hir().node_to_hir_id(freevar.var_id());\n-                let closure_def_id = self.tcx().hir().local_def_id(closure_expr.id);\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n                     closure_expr_id: closure_def_id.to_local(),\n@@ -938,10 +940,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                                 self.param_env,\n                                                 &cmt_var,\n                                                 CaptureMove);\n-                        self.delegate.consume(closure_expr.id, freevar.span, &cmt_var, mode);\n+                        self.delegate.consume(closure_expr.hir_id, freevar.span, &cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                        self.delegate.borrow(closure_expr.id,\n+                        self.delegate.borrow(closure_expr.hir_id,\n                                              fn_decl_span,\n                                              &cmt_var,\n                                              upvar_borrow.region,"}, {"sha": "c4071e9f354b18e632c03e0aee8a0c039c4283a0", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -10,12 +10,6 @@ use syntax_pos::Span;\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir;\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_intrinsics(tcx.hir().local_def_id(module));\n-    }\n-}\n-\n fn check_mod_intrinsics<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,"}, {"sha": "5d809f1407114aec0849b8554ce227cbf8df61d9", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -20,6 +20,7 @@ use crate::util::nodemap::FxHashMap;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n+use rustc_macros::HashStable;\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n use crate::hir;\n \n@@ -45,6 +46,7 @@ impl LangItem {\n     }\n }\n \n+#[derive(HashStable)]\n pub struct LanguageItems {\n     pub items: Vec<Option<DefId>>,\n     pub missing: Vec<LangItem>,\n@@ -98,7 +100,7 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n             match self.item_refs.get(&*value.as_str()).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n-                    let def_id = self.tcx.hir().local_def_id(item.id);\n+                    let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                     self.collect_item(item_index, def_id);\n                 },\n                 // Known lang item with attribute on incorrect target."}, {"sha": "9d15b0543cb41b2e65311f05013569192bd35ab9", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -10,8 +10,10 @@ use syntax::symbol::Symbol;\n use syntax::ast::{Attribute, MetaItem, MetaItemKind};\n use syntax_pos::Span;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_macros::HashStable;\n use errors::DiagnosticId;\n \n+#[derive(HashStable)]\n pub struct LibFeatures {\n     // A map from feature to stabilisation version.\n     pub stable: FxHashMap<Symbol, Symbol>,"}, {"sha": "f5a95d7004bffdbdc2ad3097d65c5f489eda7573", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -102,7 +102,7 @@ use crate::hir::Node;\n use crate::ty::{self, TyCtxt};\n use crate::ty::query::Providers;\n use crate::lint;\n-use crate::util::nodemap::{NodeMap, HirIdMap, HirIdSet};\n+use crate::util::nodemap::{HirIdMap, HirIdSet};\n \n use errors::Applicability;\n use std::collections::{BTreeMap, VecDeque};\n@@ -185,12 +185,6 @@ fn check_mod_liveness<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut IrMaps::new(tcx).as_deep_visitor());\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_liveness(tcx.hir().local_def_id(module));\n-    }\n-}\n-\n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         check_mod_liveness,\n@@ -265,7 +259,7 @@ struct IrMaps<'a, 'tcx: 'a> {\n     num_vars: usize,\n     live_node_map: HirIdMap<LiveNode>,\n     variable_map: HirIdMap<Variable>,\n-    capture_info_map: NodeMap<Rc<Vec<CaptureInfo>>>,\n+    capture_info_map: HirIdMap<Rc<Vec<CaptureInfo>>>,\n     var_kinds: Vec<VarKind>,\n     lnks: Vec<LiveNodeKind>,\n }\n@@ -344,8 +338,8 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n         }\n     }\n \n-    fn set_captures(&mut self, node_id: NodeId, cs: Vec<CaptureInfo>) {\n-        self.capture_info_map.insert(node_id, Rc::new(cs));\n+    fn set_captures(&mut self, hir_id: HirId, cs: Vec<CaptureInfo>) {\n+        self.capture_info_map.insert(hir_id, Rc::new(cs));\n     }\n \n     fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n@@ -379,9 +373,22 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     let body = ir.tcx.hir().body(body_id);\n \n     for arg in &body.arguments {\n+        let is_shorthand = match arg.pat.node {\n+            crate::hir::PatKind::Struct(..) => true,\n+            _ => false,\n+        };\n         arg.pat.each_binding(|_bm, hir_id, _x, ident| {\n             debug!(\"adding argument {:?}\", hir_id);\n-            fn_maps.add_variable(Arg(hir_id, ident.name));\n+            let var = if is_shorthand {\n+                Local(LocalInfo {\n+                    id: hir_id,\n+                    name: ident.name,\n+                    is_shorthand: true,\n+                })\n+            } else {\n+                Arg(hir_id, ident.name)\n+            };\n+            fn_maps.add_variable(var);\n         })\n     };\n \n@@ -407,7 +414,7 @@ fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n     while let Some(pat) = pats.pop_front() {\n         use crate::hir::PatKind::*;\n         match pat.node {\n-            Binding(_, _, _, _, ref inner_pat) => {\n+            Binding(_, _, _, ref inner_pat) => {\n                 pats.extend(inner_pat.iter());\n             }\n             Struct(_, ref fields, _) => {\n@@ -460,7 +467,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n-        debug!(\"expr {}: path that leads to {:?}\", expr.id, path.def);\n+        debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.def);\n         if let Def::Local(..) = path.def {\n             ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         }\n@@ -476,7 +483,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        ir.tcx.with_freevars(expr.id, |freevars| {\n+        ir.tcx.with_freevars(expr.hir_id, |freevars| {\n             call_caps.extend(freevars.iter().filter_map(|fv| {\n                 if let Def::Local(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n@@ -487,7 +494,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n                 }\n             }));\n         });\n-        ir.set_captures(expr.id, call_caps);\n+        ir.set_captures(expr.hir_id, call_caps);\n \n         intravisit::walk_expr(ir, expr);\n       }\n@@ -669,8 +676,8 @@ struct Liveness<'a, 'tcx: 'a> {\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n-    break_ln: NodeMap<LiveNode>,\n-    cont_ln: NodeMap<LiveNode>,\n+    break_ln: HirIdMap<LiveNode>,\n+    cont_ln: HirIdMap<LiveNode>,\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n@@ -925,7 +932,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn compute(&mut self, body: &hir::Expr) -> LiveNode {\n-        debug!(\"compute: using id for body, {}\", self.ir.tcx.hir().node_to_pretty_string(body.id));\n+        debug!(\"compute: using id for body, {}\",\n+               self.ir.tcx.hir().hir_to_pretty_string(body.hir_id));\n \n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n@@ -940,7 +948,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                    for ln_idx in 0..self.ir.num_live_nodes {\n                         debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n                    }\n-                   body.id\n+                   body.hir_id\n                },\n                entry_ln);\n \n@@ -950,7 +958,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode)\n                                -> LiveNode {\n         if blk.targeted_by_break {\n-            self.break_ln.insert(blk.id, succ);\n+            self.break_ln.insert(blk.hir_id, succ);\n         }\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n@@ -1002,7 +1010,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n                               -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().node_to_pretty_string(expr.id));\n+        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n \n         match expr.node {\n             // Interesting cases with control flow or which gen/kill\n@@ -1016,11 +1024,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Closure(..) => {\n                 debug!(\"{} is an ExprKind::Closure\",\n-                       self.ir.tcx.hir().node_to_pretty_string(expr.id));\n+                       self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n \n                 // the construction of a closure itself is not important,\n                 // but we have to consider the closed over variables.\n-                let caps = self.ir.capture_info_map.get(&expr.id).cloned().unwrap_or_else(||\n+                let caps = self.ir.capture_info_map.get(&expr.hir_id).cloned().unwrap_or_else(||\n                     span_bug!(expr.span, \"no registered caps\"));\n \n                 caps.iter().rev().fold(succ, |succ, cap| {\n@@ -1109,7 +1117,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             hir::ExprKind::Break(label, ref opt_expr) => {\n                 // Find which label this break jumps to\n                 let target = match label.target_id {\n-                    Ok(node_id) => self.break_ln.get(&node_id),\n+                    Ok(hir_id) => self.break_ln.get(&hir_id),\n                     Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n                 }.cloned();\n \n@@ -1169,7 +1177,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Call(ref f, ref args) => {\n-                let m = self.ir.tcx.hir().get_module_parent(expr.id);\n+                let m = self.ir.tcx.hir().get_module_parent_by_hir_id(expr.hir_id);\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n@@ -1180,7 +1188,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::MethodCall(.., ref args) => {\n-                let m = self.ir.tcx.hir().get_module_parent(expr.id);\n+                let m = self.ir.tcx.hir().get_module_parent_by_hir_id(expr.hir_id);\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n@@ -1386,17 +1394,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n-               expr.id, self.ir.tcx.hir().node_to_pretty_string(body.id));\n-\n+               expr.hir_id, self.ir.tcx.hir().hir_to_pretty_string(body.hir_id));\n \n-        self.break_ln.insert(expr.id, succ);\n+        self.break_ln.insert(expr.hir_id, succ);\n \n         let cond_ln = match kind {\n             LoopLoop => ln,\n             WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n         };\n \n-        self.cont_ln.insert(expr.id, cond_ln);\n+        self.cont_ln.insert(expr.hir_id, cond_ln);\n \n         let body_ln = self.propagate_through_block(body, cond_ln);\n "}, {"sha": "a3e8598194e790550f12d5a3ff5f08a412a571b7", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -88,7 +88,7 @@ pub enum Categorization<'tcx> {\n     ThreadLocal(ty::Region<'tcx>),       // value that cannot move, but still restricted in scope\n     StaticItem,\n     Upvar(Upvar),                        // upvar referenced by closure env\n-    Local(ast::NodeId),                  // local variable\n+    Local(hir::HirId),                   // local variable\n     Deref(cmt<'tcx>, PointerKind<'tcx>), // deref of a ptr\n     Interior(cmt<'tcx>, InteriorKind),   // something interior: field, tuple, etc\n     Downcast(cmt<'tcx>, DefId),          // selects a particular enum variant (*1)\n@@ -198,9 +198,9 @@ pub struct cmt_<'tcx> {\n pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n pub enum ImmutabilityBlame<'tcx> {\n-    ImmLocal(ast::NodeId),\n+    ImmLocal(hir::HirId),\n     ClosureEnv(LocalDefId),\n-    LocalDeref(ast::NodeId),\n+    LocalDeref(hir::HirId),\n     AdtFieldDeref(&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n }\n \n@@ -230,8 +230,8 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Deref(ref base_cmt, BorrowedPtr(ty::ImmBorrow, _)) => {\n                 // try to figure out where the immutable reference came from\n                 match base_cmt.cat {\n-                    Categorization::Local(node_id) =>\n-                        Some(ImmutabilityBlame::LocalDeref(node_id)),\n+                    Categorization::Local(hir_id) =>\n+                        Some(ImmutabilityBlame::LocalDeref(hir_id)),\n                     Categorization::Interior(ref base_cmt, InteriorField(field_index)) => {\n                         base_cmt.resolve_field(field_index.0).map(|(adt_def, field_def)| {\n                             ImmutabilityBlame::AdtFieldDeref(adt_def, field_def)\n@@ -247,8 +247,8 @@ impl<'tcx> cmt_<'tcx> {\n                     _ => None\n                 }\n             }\n-            Categorization::Local(node_id) => {\n-                Some(ImmutabilityBlame::ImmLocal(node_id))\n+            Categorization::Local(hir_id) => {\n+                Some(ImmutabilityBlame::ImmLocal(hir_id))\n             }\n             Categorization::Rvalue(..) |\n             Categorization::Upvar(..) |\n@@ -632,7 +632,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n-        debug!(\"cat_expr: id={} expr={:?}\", expr.id, expr);\n+        debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n@@ -648,10 +648,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Field(ref base, f_ident) => {\n                 let base_cmt = Rc::new(self.cat_expr(&base)?);\n                 debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n-                       expr.id,\n+                       expr.hir_id,\n                        expr,\n                        base_cmt);\n-                let f_index = self.tcx.field_index(expr.id, self.tables);\n+                let f_index = self.tcx.field_index(expr.hir_id, self.tables);\n                 Ok(self.cat_field(expr, base_cmt, f_index, f_ident, expr_ty))\n             }\n \n@@ -741,7 +741,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 Ok(cmt_ {\n                     hir_id,\n                     span,\n-                    cat: Categorization::Local(vid),\n+                    cat: Categorization::Local(self.tcx.hir().node_to_hir_id(vid)),\n                     mutbl: MutabilityCategory::from_local(self.tcx, self.tables, vid),\n                     ty: expr_ty,\n                     note: NoteNone\n@@ -1321,7 +1321,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n                 for fp in field_pats {\n                     let field_ty = self.pat_ty_adjusted(&fp.node.pat)?; // see (*2)\n-                    let f_index = self.tcx.field_index(fp.node.id, self.tables);\n+                    let f_index = self.tcx.field_index(fp.node.hir_id, self.tables);\n                     let cmt_field = Rc::new(self.cat_field(pat, cmt.clone(), f_index,\n                                                            fp.node.ident, field_ty));\n                     self.cat_pattern_(cmt_field, &fp.node.pat, op)?;\n@@ -1495,7 +1495,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"non-place\".into()\n             }\n             Categorization::Local(vid) => {\n-                if tcx.hir().is_argument(vid) {\n+                if tcx.hir().is_argument(tcx.hir().hir_to_node_id(vid)) {\n                     \"argument\"\n                 } else {\n                     \"local variable\""}, {"sha": "6ba55f882f8fda02222495dad5ae9adc4bfc7b22", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -7,9 +7,10 @@ use crate::util::nodemap::{DefIdSet, FxHashMap};\n use std::hash::Hash;\n use std::fmt;\n use syntax::ast::NodeId;\n+use rustc_macros::HashStable;\n \n // Accessibility levels, sorted in ascending order\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n pub enum AccessLevel {\n     /// Superset of `AccessLevel::Reachable` used to mark impl Trait items.\n     ReachableFromImplTrait,"}, {"sha": "72f6d22b696f7f6d609df91c2e8b8703b8a0ae9c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -14,10 +14,10 @@ use crate::ty::{self, TyCtxt};\n use crate::ty::query::Providers;\n use crate::middle::privacy;\n use crate::session::config;\n-use crate::util::nodemap::{NodeSet, FxHashSet};\n+use crate::util::nodemap::{HirIdSet, FxHashSet};\n \n use rustc_target::spec::abi::Abi;\n-use syntax::ast;\n+use rustc_macros::HashStable;\n use crate::hir;\n use crate::hir::def_id::LOCAL_CRATE;\n use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n@@ -37,7 +37,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match item.node {\n         hir::ItemKind::Impl(..) |\n         hir::ItemKind::Fn(..) => {\n-            let generics = tcx.generics_of(tcx.hir().local_def_id(item.id));\n+            let generics = tcx.generics_of(tcx.hir().local_def_id_from_hir_id(item.hir_id));\n             generics.requires_monomorphization(tcx)\n         }\n         _ => false,\n@@ -48,12 +48,12 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n-    let generics = tcx.generics_of(tcx.hir().local_def_id(impl_item.id));\n+    let generics = tcx.generics_of(tcx.hir().local_def_id_from_hir_id(impl_item.hir_id));\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true\n     }\n-    if let Some(impl_node_id) = tcx.hir().as_local_node_id(impl_src) {\n-        match tcx.hir().find(impl_node_id) {\n+    if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_src) {\n+        match tcx.hir().find_by_hir_id(impl_hir_id) {\n             Some(Node::Item(item)) =>\n                 item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None =>\n@@ -70,10 +70,10 @@ struct ReachableContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: NodeSet,\n+    reachable_symbols: HirIdSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: Vec<ast::NodeId>,\n+    worklist: Vec<hir::HirId>,\n     // Whether any output of this compilation is a library\n     any_library: bool,\n }\n@@ -104,27 +104,28 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n \n         match def {\n             Some(Def::Local(node_id)) | Some(Def::Upvar(node_id, ..)) => {\n-                self.reachable_symbols.insert(node_id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n+                self.reachable_symbols.insert(hir_id);\n             }\n             Some(def) => {\n-                if let Some((node_id, def_id)) = def.opt_def_id().and_then(|def_id| {\n-                    self.tcx.hir().as_local_node_id(def_id).map(|node_id| (node_id, def_id))\n+                if let Some((hir_id, def_id)) = def.opt_def_id().and_then(|def_id| {\n+                    self.tcx.hir().as_local_hir_id(def_id).map(|hir_id| (hir_id, def_id))\n                 }) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n-                        self.worklist.push(node_id);\n+                        self.worklist.push(hir_id);\n                     } else {\n                         match def {\n                             // If this path leads to a constant, then we need to\n                             // recurse into the constant to continue finding\n                             // items that are reachable.\n                             Def::Const(..) | Def::AssociatedConst(..) => {\n-                                self.worklist.push(node_id);\n+                                self.worklist.push(hir_id);\n                             }\n \n                             // If this wasn't a static, then the destination is\n                             // surely reachable.\n                             _ => {\n-                                self.reachable_symbols.insert(node_id);\n+                                self.reachable_symbols.insert(hir_id);\n                             }\n                         }\n                     }\n@@ -141,12 +142,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n-        let node_id = match self.tcx.hir().as_local_node_id(def_id) {\n-            Some(node_id) => node_id,\n+        let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n+            Some(hir_id) => hir_id,\n             None => { return false; }\n         };\n \n-        match self.tcx.hir().find(node_id) {\n+        match self.tcx.hir().find_by_hir_id(hir_id) {\n             Some(Node::Item(item)) => {\n                 match item.node {\n                     hir::ItemKind::Fn(..) =>\n@@ -173,7 +174,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         } else {\n                             let impl_did = self.tcx\n                                                .hir()\n-                                               .get_parent_did(node_id);\n+                                               .get_parent_did_by_hir_id(hir_id);\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n@@ -204,14 +205,14 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref item) = self.tcx.hir().find(search_item) {\n+            if let Some(ref item) = self.tcx.hir().find_by_hir_id(search_item) {\n                 self.propagate_node(item, search_item);\n             }\n         }\n     }\n \n     fn propagate_node(&mut self, node: &Node<'tcx>,\n-                      search_item: ast::NodeId) {\n+                      search_item: hir::HirId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n@@ -221,7 +222,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 } else {\n                     false\n                 };\n-                let def_id = self.tcx.hir().local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n                 let is_extern = codegen_attrs.contains_extern_indicator();\n                 let std_internal = codegen_attrs.flags.contains(\n@@ -242,7 +243,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Fn(.., body) => {\n-                        let def_id = self.tcx.hir().local_def_id(item.id);\n+                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                         if item_might_be_inlined(self.tcx,\n                                                  &item,\n                                                  self.tcx.codegen_fn_attrs(def_id)) {\n@@ -295,7 +296,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         self.visit_nested_body(body);\n                     }\n                     hir::ImplItemKind::Method(_, body) => {\n-                        let did = self.tcx.hir().get_parent_did(search_item);\n+                        let did = self.tcx.hir().get_parent_did_by_hir_id(search_item);\n                         if method_might_be_inlined(self.tcx, impl_item, did) {\n                             self.visit_nested_body(body)\n                         }\n@@ -317,7 +318,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             _ => {\n                 bug!(\n                     \"found unexpected node kind in worklist: {} ({:?})\",\n-                    self.tcx.hir().node_to_string(search_item),\n+                    self.tcx.hir().hir_to_string(search_item),\n                     node,\n                 );\n             }\n@@ -336,25 +337,26 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     access_levels: &'a privacy::AccessLevels,\n-    worklist: &'a mut Vec<ast::NodeId>,\n+    worklist: &'a mut Vec<hir::HirId>,\n }\n \n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         // Anything which has custom linkage gets thrown on the worklist no\n         // matter where it is in the crate, along with \"special std symbols\"\n         // which are currently akin to allocator symbols.\n-        let def_id = self.tcx.hir().local_def_id(item.id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n         if codegen_attrs.contains_extern_indicator() ||\n             codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n-            self.worklist.push(item.id);\n+            self.worklist.push(item.hir_id);\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n-            if !self.access_levels.is_reachable(item.id) {\n-                self.worklist.extend(impl_item_refs.iter().map(|r| r.id.node_id));\n+            let node_id = self.tcx.hir().hir_to_node_id(item.hir_id);\n+            if !self.access_levels.is_reachable(node_id) {\n+                self.worklist.extend(impl_item_refs.iter().map(|ii_ref| ii_ref.id.hir_id));\n \n                 let trait_def_id = match trait_ref.path.def {\n                     Def::Trait(def_id) => def_id,\n@@ -368,11 +370,11 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n                 let provided_trait_methods = self.tcx.provided_trait_methods(trait_def_id);\n                 self.worklist.reserve(provided_trait_methods.len());\n                 for default_method in provided_trait_methods {\n-                    let node_id = self.tcx\n-                                      .hir()\n-                                      .as_local_node_id(default_method.def_id)\n-                                      .unwrap();\n-                    self.worklist.push(node_id);\n+                    let hir_id = self.tcx\n+                                     .hir()\n+                                     .as_local_hir_id(default_method.def_id)\n+                                     .unwrap();\n+                    self.worklist.push(hir_id);\n                 }\n             }\n         }\n@@ -387,8 +389,8 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n \n // We introduce a new-type here, so we can have a specialized HashStable\n // implementation for it.\n-#[derive(Clone)]\n-pub struct ReachableSet(pub Lrc<NodeSet>);\n+#[derive(Clone, HashStable)]\n+pub struct ReachableSet(pub Lrc<HirIdSet>);\n \n fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n     debug_assert!(crate_num == LOCAL_CRATE);\n@@ -412,11 +414,12 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     //         If other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    reachable_context.worklist.extend(access_levels.map.iter().map(|(id, _)| *id));\n+    reachable_context.worklist.extend(\n+        access_levels.map.iter().map(|(id, _)| tcx.hir().node_to_hir_id(*id)));\n     for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n-            if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n-                reachable_context.worklist.push(node_id);\n+            if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+                reachable_context.worklist.push(hir_id);\n             }\n         }\n     }"}, {"sha": "42e253273ab3e59fda9fab5eef174c9c4dc94331", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -13,6 +13,7 @@ use crate::ty;\n use std::mem;\n use std::fmt;\n use rustc_data_structures::sync::Lrc;\n+use rustc_macros::HashStable;\n use syntax::source_map;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -90,7 +91,8 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n // placate the same deriving in `ty::FreeRegion`, but we may want to\n // actually attach a more meaningful ordering to scopes than the one\n // generated via deriving here.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct Scope {\n     pub id: hir::ItemLocalId,\n     pub data: ScopeData,\n@@ -113,7 +115,8 @@ impl fmt::Debug for Scope {\n     }\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub enum ScopeData {\n     Node,\n \n@@ -132,25 +135,24 @@ pub enum ScopeData {\n     Remainder(FirstStatementIndex)\n }\n \n-/// Represents a subscope of `block` for a binding that is introduced\n-/// by `block.stmts[first_statement_index]`. Such subscopes represent\n-/// a suffix of the block. Note that each subscope does not include\n-/// the initializer expression, if any, for the statement indexed by\n-/// `first_statement_index`.\n-///\n-/// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n-///\n-/// * The subscope with `first_statement_index == 0` is scope of both\n-///   `a` and `b`; it does not include EXPR_1, but does include\n-///   everything after that first `let`. (If you want a scope that\n-///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n-///   but instead another `Scope` that encompasses the whole block,\n-///   e.g., `Scope::Node`.\n-///\n-/// * The subscope with `first_statement_index == 1` is scope of `c`,\n-///   and thus does not include EXPR_2, but covers the `...`.\n-\n newtype_index! {\n+    /// Represents a subscope of `block` for a binding that is introduced\n+    /// by `block.stmts[first_statement_index]`. Such subscopes represent\n+    /// a suffix of the block. Note that each subscope does not include\n+    /// the initializer expression, if any, for the statement indexed by\n+    /// `first_statement_index`.\n+    ///\n+    /// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n+    ///\n+    /// * The subscope with `first_statement_index == 0` is scope of both\n+    ///   `a` and `b`; it does not include EXPR_1, but does include\n+    ///   everything after that first `let`. (If you want a scope that\n+    ///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n+    ///   but instead another `Scope` that encompasses the whole block,\n+    ///   e.g., `Scope::Node`.\n+    ///\n+    /// * The subscope with `first_statement_index == 1` is scope of `c`,\n+    ///   and thus does not include EXPR_2, but covers the `...`.\n     pub struct FirstStatementIndex { .. }\n }\n \n@@ -223,7 +225,7 @@ pub struct ScopeTree {\n     /// The parent of the root body owner, if the latter is an\n     /// an associated const or method, as impls/traits can also\n     /// have lifetime parameters free in this body.\n-    root_parent: Option<ast::NodeId>,\n+    root_parent: Option<hir::HirId>,\n \n     /// `parent_map` maps from a scope ID to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n@@ -650,8 +652,8 @@ impl<'tcx> ScopeTree {\n                                       -> Scope {\n         let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n \n-        let param_owner_id = tcx.hir().as_local_node_id(param_owner).unwrap();\n-        let scope = tcx.hir().maybe_body_owned_by(param_owner_id).map(|body_id| {\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n+        let scope = tcx.hir().maybe_body_owned_by_by_hir_id(param_owner_id).map(|body_id| {\n             tcx.hir().body(body_id).value.hir_id.local_id\n         }).unwrap_or_else(|| {\n             // The lifetime was defined on node that doesn't own a body,\n@@ -661,7 +663,7 @@ impl<'tcx> ScopeTree {\n                        \"free_scope: {:?} not recognized by the \\\n                         region scope tree for {:?} / {:?}\",\n                        param_owner,\n-                       self.root_parent.map(|id| tcx.hir().local_def_id(id)),\n+                       self.root_parent.map(|id| tcx.hir().local_def_id_from_hir_id(id)),\n                        self.root_body.map(|hir_id| DefId::local(hir_id.owner)));\n \n             // The trait/impl lifetime is in scope for the method's body.\n@@ -686,7 +688,7 @@ impl<'tcx> ScopeTree {\n         // on the same function that they ended up being freed in.\n         assert_eq!(param_owner, fr.scope);\n \n-        let param_owner_id = tcx.hir().as_local_node_id(param_owner).unwrap();\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n         let body_id = tcx.hir().body_owned_by(param_owner_id);\n         Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n     }\n@@ -745,7 +747,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor<'_, '_>,\n }\n \n fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk: &'tcx hir::Block) {\n-    debug!(\"resolve_block(blk.id={:?})\", blk.id);\n+    debug!(\"resolve_block(blk.hir_id={:?})\", blk.hir_id);\n \n     let prev_cx = visitor.cx;\n \n@@ -1328,8 +1330,8 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         return tcx.region_scope_tree(closure_base_def_id);\n     }\n \n-    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by_by_hir_id(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n             scope_tree: ScopeTree::default(),\n@@ -1348,10 +1350,10 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         // If the item is an associated const or a method,\n         // record its impl/trait parent, as it can also have\n         // lifetime parameters free in this body.\n-        match tcx.hir().get(id) {\n+        match tcx.hir().get_by_hir_id(id) {\n             Node::ImplItem(_) |\n             Node::TraitItem(_) => {\n-                visitor.scope_tree.root_parent = Some(tcx.hir().get_parent(id));\n+                visitor.scope_tree.root_parent = Some(tcx.hir().get_parent_item(id));\n             }\n             _ => {}\n         }"}, {"sha": "96f0beafa005fb420722813b2eb9071e2db4fc2a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 90, "deletions": 78, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -13,9 +13,10 @@ use crate::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n \n use crate::rustc::lint;\n use crate::session::Session;\n-use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n+use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, HirIdMap, HirIdSet};\n use errors::{Applicability, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n+use rustc_macros::HashStable;\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::mem::replace;\n@@ -31,7 +32,7 @@ use crate::hir::{self, GenericParamKind, LifetimeParamKind};\n /// The origin of a named lifetime definition.\n ///\n /// This is used to prevent the usage of in-band lifetimes in `Fn`/`fn` syntax.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LifetimeDefOrigin {\n     // Explicit binders like `fn foo<'a>(x: &'a u8)` or elided like `impl Foo<&u32>`\n     ExplicitOrElided,\n@@ -62,7 +63,7 @@ pub enum LifetimeUseSet<'tcx> {\n     Many,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Region {\n     Static,\n     EarlyBound(\n@@ -83,15 +84,15 @@ impl Region {\n     fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam) -> (ParamName, Region) {\n         let i = *index;\n         *index += 1;\n-        let def_id = hir_map.local_def_id(param.id);\n+        let def_id = hir_map.local_def_id_from_hir_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n         (param.name.modern(), Region::EarlyBound(i, def_id, origin))\n     }\n \n     fn late(hir_map: &Map<'_>, param: &GenericParam) -> (ParamName, Region) {\n         let depth = ty::INNERMOST;\n-        let def_id = hir_map.local_def_id(param.id);\n+        let def_id = hir_map.local_def_id_from_hir_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n@@ -151,7 +152,7 @@ impl Region {\n         if let Region::EarlyBound(index, _, _) = self {\n             params\n                 .nth(index as usize)\n-                .and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n+                .and_then(|lifetime| map.defs.get(&lifetime.hir_id).cloned())\n         } else {\n             Some(self)\n         }\n@@ -161,7 +162,7 @@ impl Region {\n /// A set containing, at most, one known element.\n /// If two distinct values are inserted into a set, then it\n /// becomes `Many`, which can be used to detect ambiguities.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Set1<T> {\n     Empty,\n     One(T),\n@@ -195,16 +196,16 @@ pub type ObjectLifetimeDefault = Set1<Region>;\n struct NamedRegionMap {\n     // maps from every use of a named (not anonymous) lifetime to a\n     // `Region` describing how that region is bound\n-    pub defs: NodeMap<Region>,\n+    pub defs: HirIdMap<Region>,\n \n     // the set of lifetime def ids that are late-bound; a region can\n     // be late-bound if (a) it does NOT appear in a where-clause and\n     // (b) it DOES appear in the arguments.\n-    pub late_bound: NodeSet,\n+    pub late_bound: HirIdSet,\n \n     // For each type and trait definition, maps type parameters\n     // to the trait object lifetime defaults computed from them.\n-    pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n+    pub object_lifetime_defaults: HirIdMap<Vec<ObjectLifetimeDefault>>,\n }\n \n /// See [`NamedRegionMap`].\n@@ -385,20 +386,17 @@ fn resolve_lifetimes<'tcx>(\n \n     let mut rl = ResolveLifetimes::default();\n \n-    for (k, v) in named_region_map.defs {\n-        let hir_id = tcx.hir().node_to_hir_id(k);\n+    for (hir_id, v) in named_region_map.defs {\n         let map = rl.defs.entry(hir_id.owner_local_def_id()).or_default();\n         Lrc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n     }\n-    for k in named_region_map.late_bound {\n-        let hir_id = tcx.hir().node_to_hir_id(k);\n+    for hir_id in named_region_map.late_bound {\n         let map = rl.late_bound\n             .entry(hir_id.owner_local_def_id())\n             .or_default();\n         Lrc::get_mut(map).unwrap().insert(hir_id.local_id);\n     }\n-    for (k, v) in named_region_map.object_lifetime_defaults {\n-        let hir_id = tcx.hir().node_to_hir_id(k);\n+    for (hir_id, v) in named_region_map.object_lifetime_defaults {\n         let map = rl.object_lifetime_defaults\n             .entry(hir_id.owner_local_def_id())\n             .or_default();\n@@ -570,7 +568,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        debug!(\"visit_ty: id={:?} ty={:?}\", ty.id, ty);\n+        debug!(\"visit_ty: id={:?} ty={:?}\", ty.hir_id, ty);\n         match ty.node {\n             hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n@@ -629,7 +627,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             hir::TyKind::Rptr(ref lifetime_ref, ref mt) => {\n                 self.visit_lifetime(lifetime_ref);\n                 let scope = Scope::ObjectLifetimeDefault {\n-                    lifetime: self.map.defs.get(&lifetime_ref.id).cloned(),\n+                    lifetime: self.map.defs.get(&lifetime_ref.hir_id).cloned(),\n                     s: self.scope,\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n@@ -672,15 +670,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // and ban them. Type variables instantiated inside binders aren't\n                         // well-supported at the moment, so this doesn't work.\n                         // In the future, this should be fixed and this error should be removed.\n-                        let def = self.map.defs.get(&lifetime.id).cloned();\n+                        let def = self.map.defs.get(&lifetime.hir_id).cloned();\n                         if let Some(Region::LateBound(_, def_id, _)) = def {\n-                            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n+                            if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n                                 // Ensure that the parent of the def is an item, not HRTB\n-                                let parent_id = self.tcx.hir().get_parent_node(node_id);\n-                                let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n-                                let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n+                                let parent_id = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+                                let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n+                                let parent_trait_id = hir::TraitItemId { hir_id: parent_id };\n                                 let krate = self.tcx.hir().forest.krate();\n-                                if !(krate.items.contains_key(&parent_id)\n+                                let parent_node_id = self.tcx.hir().hir_to_node_id(parent_id);\n+                                if !(krate.items.contains_key(&parent_node_id)\n                                     || krate.impl_items.contains_key(&parent_impl_id)\n                                     || krate.trait_items.contains_key(&parent_trait_id))\n                                 {\n@@ -766,6 +765,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     });\n                 }\n             }\n+            hir::TyKind::CVarArgs(ref lt) => {\n+                // Resolve the generated lifetime for the C-variadic arguments.\n+                // The lifetime is generated in AST -> HIR lowering.\n+                if lt.name.is_elided() {\n+                    self.resolve_elided_lifetimes(vec![lt])\n+                }\n+            }\n             _ => intravisit::walk_ty(self, ty),\n         }\n     }\n@@ -776,7 +782,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir().get_parent(trait_item.id)),\n+                    Some(tcx.hir().get_parent_item(trait_item.hir_id)),\n                     &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n@@ -828,7 +834,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir().get_parent(impl_item.id)),\n+                    Some(tcx.hir().get_parent_item(impl_item.hir_id)),\n                     &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n@@ -1261,8 +1267,8 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n \n fn compute_object_lifetime_defaults(\n     tcx: TyCtxt<'_, '_, '_>,\n-) -> NodeMap<Vec<ObjectLifetimeDefault>> {\n-    let mut map = NodeMap::default();\n+) -> HirIdMap<Vec<ObjectLifetimeDefault>> {\n+    let mut map = HirIdMap::default();\n     for item in tcx.hir().krate().items.values() {\n         match item.node {\n             hir::ItemKind::Struct(_, ref generics)\n@@ -1306,7 +1312,7 @@ fn compute_object_lifetime_defaults(\n                     tcx.sess.span_err(item.span, &object_lifetime_default_reprs);\n                 }\n \n-                map.insert(item.id, result);\n+                map.insert(item.hir_id, result);\n             }\n             _ => {}\n         }\n@@ -1339,7 +1345,7 @@ fn object_lifetime_defaults_for_item(\n \n                 add_bounds(&mut set, &param.bounds);\n \n-                let param_def_id = tcx.hir().local_def_id(param.id);\n+                let param_def_id = tcx.hir().local_def_id_from_hir_id(param.hir_id);\n                 for predicate in &generics.where_clause.predicates {\n                     // Look for `type: ...` where clauses.\n                     let data = match *predicate {\n@@ -1374,7 +1380,7 @@ fn object_lifetime_defaults_for_item(\n                                 .iter()\n                                 .filter_map(|param| match param.kind {\n                                     GenericParamKind::Lifetime { .. } => Some((\n-                                        param.id,\n+                                        param.hir_id,\n                                         hir::LifetimeName::Param(param.name),\n                                         LifetimeDefOrigin::from_param(param),\n                                     )),\n@@ -1383,7 +1389,7 @@ fn object_lifetime_defaults_for_item(\n                                 .enumerate()\n                                 .find(|&(_, (_, lt_name, _))| lt_name == name)\n                                 .map_or(Set1::Many, |(i, (id, _, origin))| {\n-                                    let def_id = tcx.hir().local_def_id(id);\n+                                    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n                                     Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n                                 })\n                         }\n@@ -1501,8 +1507,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n         };\n-        if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get(lifetime.id) {\n-            if let Some(parent) = self.tcx.hir().find(self.tcx.hir().get_parent(hir_lifetime.id)) {\n+        if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get_by_hir_id(lifetime.hir_id) {\n+            if let Some(parent) = self.tcx.hir().find_by_hir_id(\n+                self.tcx.hir().get_parent_item(hir_lifetime.hir_id))\n+            {\n                 match parent {\n                     Node::Item(item) => {\n                         if let hir::ItemKind::Fn(decl, _, _, _) = &item.node {\n@@ -1578,26 +1586,26 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n-                    let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n-                    debug!(\"node id first={:?}\", node_id);\n-                    if let Some((id, span, name)) = match self.tcx.hir().get(node_id) {\n+                    let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    debug!(\"hir id first={:?}\", hir_id);\n+                    if let Some((id, span, name)) = match self.tcx.hir().get_by_hir_id(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n-                            hir_lifetime.id,\n+                            hir_lifetime.hir_id,\n                             hir_lifetime.span,\n                             hir_lifetime.name.ident(),\n                         )),\n                         Node::GenericParam(param) => {\n-                            Some((param.id, param.span, param.name.ident()))\n+                            Some((param.hir_id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n                     } {\n-                        debug!(\"id = {:?} span = {:?} name = {:?}\", node_id, span, name);\n+                        debug!(\"id = {:?} span = {:?} name = {:?}\", id, span, name);\n \n                         if name == keywords::UnderscoreLifetime.ident() {\n                             continue;\n                         }\n \n-                        let mut err = self.tcx.struct_span_lint_node(\n+                        let mut err = self.tcx.struct_span_lint_hir(\n                             lint::builtin::SINGLE_USE_LIFETIMES,\n                             id,\n                             span,\n@@ -1619,20 +1627,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"Not one use lifetime\");\n                 }\n                 None => {\n-                    let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n-                    if let Some((id, span, name)) = match self.tcx.hir().get(node_id) {\n+                    let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    if let Some((id, span, name)) = match self.tcx.hir().get_by_hir_id(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n-                            hir_lifetime.id,\n+                            hir_lifetime.hir_id,\n                             hir_lifetime.span,\n                             hir_lifetime.name.ident(),\n                         )),\n                         Node::GenericParam(param) => {\n-                            Some((param.id, param.span, param.name.ident()))\n+                            Some((param.hir_id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n                     } {\n-                        debug!(\"id ={:?} span = {:?} name = {:?}\", node_id, span, name);\n-                        let mut err = self.tcx.struct_span_lint_node(\n+                        debug!(\"id ={:?} span = {:?} name = {:?}\", id, span, name);\n+                        let mut err = self.tcx.struct_span_lint_hir(\n                             lint::builtin::UNUSED_LIFETIMES,\n                             id,\n                             span,\n@@ -1678,7 +1686,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(\n         &mut self,\n-        parent_id: Option<ast::NodeId>,\n+        parent_id: Option<hir::HirId>,\n         decl: &'tcx hir::FnDecl,\n         generics: &'tcx hir::Generics,\n         walk: F,\n@@ -1690,7 +1698,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // Find the start of nested early scopes, e.g., in methods.\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n-            let parent = self.tcx.hir().expect_item(parent_id);\n+            let parent = self.tcx.hir().expect_item_by_hir_id(parent_id);\n             if sub_items_have_self_param(&parent.node) {\n                 index += 1; // Self comes before lifetimes\n             }\n@@ -1706,7 +1714,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut non_lifetime_count = 0;\n         let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n             GenericParamKind::Lifetime { .. } => {\n-                if self.map.late_bound.contains(&param.id) {\n+                if self.map.late_bound.contains(&param.hir_id) {\n                     Some(Region::late(&self.tcx.hir(), param))\n                 } else {\n                     Some(Region::early(&self.tcx.hir(), &mut index, param))\n@@ -1952,7 +1960,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n \n             let map = &self.map;\n-            let unsubst = if let Some(id) = self.tcx.hir().as_local_node_id(def_id) {\n+            let unsubst = if let Some(id) = self.tcx.hir().as_local_hir_id(def_id) {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n                 let tcx = self.tcx;\n@@ -1967,7 +1975,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                     object_lifetime_default,\n                                     ..\n                                 } => Some(object_lifetime_default),\n-                                GenericParamDefKind::Lifetime => None,\n+                                GenericParamDefKind::Lifetime | GenericParamDefKind::Const => None,\n                             })\n                             .collect()\n                     })\n@@ -2049,8 +2057,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // and whether there's a `self` argument (treated specially).\n         let mut assoc_item_kind = None;\n         let mut impl_self = None;\n-        let parent = self.tcx.hir().get_parent_node(output.id);\n-        let body = match self.tcx.hir().get(parent) {\n+        let parent = self.tcx.hir().get_parent_node_by_hir_id(output.hir_id);\n+        let body = match self.tcx.hir().get_by_hir_id(parent) {\n             // `fn` definitions and methods.\n             Node::Item(&hir::Item {\n                 node: hir::ItemKind::Fn(.., body),\n@@ -2063,12 +2071,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }) => {\n                 if let hir::ItemKind::Trait(.., ref trait_items) = self.tcx\n                     .hir()\n-                    .expect_item(self.tcx.hir().get_parent(parent))\n+                    .expect_item_by_hir_id(self.tcx.hir().get_parent_item(parent))\n                     .node\n                 {\n                     assoc_item_kind = trait_items\n                         .iter()\n-                        .find(|ti| ti.id.node_id == parent)\n+                        .find(|ti| ti.id.hir_id == parent)\n                         .map(|ti| ti.kind);\n                 }\n                 match *m {\n@@ -2083,13 +2091,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }) => {\n                 if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) = self.tcx\n                     .hir()\n-                    .expect_item(self.tcx.hir().get_parent(parent))\n+                    .expect_item_by_hir_id(self.tcx.hir().get_parent_item(parent))\n                     .node\n                 {\n                     impl_self = Some(self_ty);\n                     assoc_item_kind = impl_items\n                         .iter()\n-                        .find(|ii| ii.id.node_id == parent)\n+                        .find(|ii| ii.id.hir_id == parent)\n                         .map(|ii| ii.kind);\n                 }\n                 Some(body)\n@@ -2143,7 +2151,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             if let hir::TyKind::Rptr(lifetime_ref, ref mt) = inputs[0].node {\n                 if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.node {\n                     if is_self_ty(path.def) {\n-                        if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n+                        if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n                             let scope = Scope::Elision {\n                                 elide: Elide::Exact(lifetime),\n                                 s: self.scope,\n@@ -2223,18 +2231,22 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 if let hir::TyKind::BareFn(_) = ty.node {\n                     self.outer_index.shift_in(1);\n                 }\n-                if let hir::TyKind::TraitObject(ref bounds, ref lifetime) = ty.node {\n-                    for bound in bounds {\n-                        self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n-                    }\n+                match ty.node {\n+                    hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n+                        for bound in bounds {\n+                            self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                        }\n \n-                    // Stay on the safe side and don't include the object\n-                    // lifetime default (which may not end up being used).\n-                    if !lifetime.is_elided() {\n-                        self.visit_lifetime(lifetime);\n+                        // Stay on the safe side and don't include the object\n+                        // lifetime default (which may not end up being used).\n+                        if !lifetime.is_elided() {\n+                            self.visit_lifetime(lifetime);\n+                        }\n+                    }\n+                    hir::TyKind::CVarArgs(_) => {}\n+                    _ => {\n+                        intravisit::walk_ty(self, ty);\n                     }\n-                } else {\n-                    intravisit::walk_ty(self, ty);\n                 }\n                 if let hir::TyKind::BareFn(_) = ty.node {\n                     self.outer_index.shift_out(1);\n@@ -2262,7 +2274,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-                if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n+                if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n                     match lifetime {\n                         Region::LateBound(debruijn, _, _) | Region::LateBoundAnon(debruijn, _)\n                             if debruijn < self.outer_index =>\n@@ -2385,7 +2397,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             let help_name = if let Some(body) = parent {\n                 let arg = &self.tcx.hir().body(body).arguments[index];\n-                format!(\"`{}`\", self.tcx.hir().node_to_pretty_string(arg.pat.id))\n+                format!(\"`{}`\", self.tcx.hir().hir_to_pretty_string(arg.pat.hir_id))\n             } else {\n                 format!(\"argument {}\", index + 1)\n             };\n@@ -2653,7 +2665,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: Region) {\n-        if lifetime_ref.id == ast::DUMMY_NODE_ID {\n+        if lifetime_ref.hir_id == hir::DUMMY_HIR_ID {\n             span_bug!(\n                 lifetime_ref.span,\n                 \"lifetime reference not renumbered, \\\n@@ -2663,11 +2675,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         debug!(\n             \"insert_lifetime: {} resolved to {:?} span={:?}\",\n-            self.tcx.hir().node_to_string(lifetime_ref.id),\n+            self.tcx.hir().hir_to_string(lifetime_ref.hir_id),\n             def,\n             self.tcx.sess.source_map().span_to_string(lifetime_ref.span)\n         );\n-        self.map.defs.insert(lifetime_ref.id, def);\n+        self.map.defs.insert(lifetime_ref.hir_id, def);\n \n         match def {\n             Region::LateBoundAnon(..) | Region::Static => {\n@@ -2699,7 +2711,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// error (esp. around impl trait). In that case, we remove the\n     /// entry into `map.defs` so as not to confuse later code.\n     fn uninsert_lifetime_on_error(&mut self, lifetime_ref: &'tcx hir::Lifetime, bad_def: Region) {\n-        let old_value = self.map.defs.remove(&lifetime_ref.id);\n+        let old_value = self.map.defs.remove(&lifetime_ref.hir_id);\n         assert_eq!(old_value, Some(bad_def));\n     }\n }\n@@ -2789,11 +2801,11 @@ fn insert_late_bound_lifetimes(\n         debug!(\n             \"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n             param.name.ident(),\n-            param.id\n+            param.hir_id\n         );\n \n-        let inserted = map.late_bound.insert(param.id);\n-        assert!(inserted, \"visited lifetime {:?} twice\", param.id);\n+        let inserted = map.late_bound.insert(param.hir_id);\n+        assert!(inserted, \"visited lifetime {:?} twice\", param.hir_id);\n     }\n \n     return;"}, {"sha": "1677384059e09e276c351a8734c688a3f3ee83e1", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 46, "deletions": 55, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -13,8 +13,7 @@ use crate::middle::privacy::AccessLevels;\n use crate::session::{DiagnosticMessageId, Session};\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, MultiSpan};\n-use syntax::ast;\n-use syntax::ast::{NodeId, Attribute};\n+use syntax::ast::Attribute;\n use syntax::errors::Applicability;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::attr::{self, Stability, Deprecation};\n@@ -117,13 +116,13 @@ struct Annotator<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n-    fn annotate<F>(&mut self, id: NodeId, attrs: &[Attribute],\n+    fn annotate<F>(&mut self, hir_id: HirId, attrs: &[Attribute],\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n         where F: FnOnce(&mut Self)\n     {\n         if self.tcx.features().staged_api {\n             // This crate explicitly wants staged API.\n-            debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n+            debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n             if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n                 self.tcx.sess.span_err(item_sp, \"`#[deprecated]` cannot be used in staged api, \\\n                                                  use `#[rustc_deprecated]` instead\");\n@@ -178,7 +177,6 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                     }\n                 }\n \n-                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 self.index.stab_map.insert(hir_id, stab);\n \n                 let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n@@ -188,7 +186,6 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n                 if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n-                        let hir_id = self.tcx.hir().node_to_hir_id(id);\n                         self.index.stab_map.insert(hir_id, stab);\n                     }\n                 }\n@@ -209,7 +206,6 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             // -Zforce-unstable-if-unmarked is set.\n             if let Some(stab) = self.parent_stab {\n                 if stab.level.is_unstable() {\n-                    let hir_id = self.tcx.hir().node_to_hir_id(id);\n                     self.index.stab_map.insert(hir_id, stab);\n                 }\n             }\n@@ -220,7 +216,6 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n \n                 // `Deprecation` is just two pointers, no need to intern it\n-                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 let depr_entry = DeprecationEntry::local(depr, hir_id);\n                 self.index.depr_map.insert(hir_id, depr_entry.clone());\n \n@@ -229,7 +224,6 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 visit_children(self);\n                 self.parent_depr = orig_parent_depr;\n             } else if let Some(parent_depr) = self.parent_depr.clone() {\n-                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 self.index.depr_map.insert(hir_id, parent_depr);\n                 visit_children(self);\n             } else {\n@@ -264,20 +258,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             }\n             hir::ItemKind::Struct(ref sd, _) => {\n                 if !sd.is_struct() {\n-                    self.annotate(sd.id(), &i.attrs, i.span, AnnotationKind::Required, |_| {})\n+                    self.annotate(sd.hir_id(), &i.attrs, i.span, AnnotationKind::Required, |_| {})\n                 }\n             }\n             _ => {}\n         }\n \n-        self.annotate(i.id, &i.attrs, i.span, kind, |v| {\n+        self.annotate(i.hir_id, &i.attrs, i.span, kind, |v| {\n             intravisit::walk_item(v, i)\n         });\n         self.in_trait_impl = orig_in_trait_impl;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        self.annotate(ti.id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n+        self.annotate(ti.hir_id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n             intravisit::walk_trait_item(v, ti);\n         });\n     }\n@@ -288,31 +282,30 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         } else {\n             AnnotationKind::Required\n         };\n-        self.annotate(ii.id, &ii.attrs, ii.span, kind, |v| {\n+        self.annotate(ii.hir_id, &ii.attrs, ii.span, kind, |v| {\n             intravisit::walk_impl_item(v, ii);\n         });\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.annotate(var.node.data.id(), &var.node.attrs, var.span, AnnotationKind::Required, |v| {\n-            intravisit::walk_variant(v, var, g, item_id);\n-        })\n+        self.annotate(var.node.data.hir_id(), &var.node.attrs, var.span, AnnotationKind::Required,\n+            |v| { intravisit::walk_variant(v, var, g, item_id) })\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField) {\n-        self.annotate(s.id, &s.attrs, s.span, AnnotationKind::Required, |v| {\n+        self.annotate(s.hir_id, &s.attrs, s.span, AnnotationKind::Required, |v| {\n             intravisit::walk_struct_field(v, s);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n-        self.annotate(i.id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n+        self.annotate(i.hir_id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n             intravisit::walk_foreign_item(v, i);\n         });\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        self.annotate(md.id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n+        self.annotate(md.hir_id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n     }\n }\n \n@@ -322,12 +315,11 @@ struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n-    fn check_missing_stability(&self, id: NodeId, span: Span, name: &str) {\n-        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+    fn check_missing_stability(&self, hir_id: HirId, span: Span, name: &str) {\n         let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&\n                         stab.is_none() &&\n-                        self.access_levels.is_reachable(id);\n+                        self.access_levels.is_reachable(self.tcx.hir().hir_to_node_id(hir_id));\n         if is_error {\n             self.tcx.sess.span_err(\n                 span,\n@@ -350,42 +342,43 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n             // optional. They inherit stability from their parents when unannotated.\n             hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n \n-            _ => self.check_missing_stability(i.id, i.span, i.node.descriptive_variant())\n+            _ => self.check_missing_stability(i.hir_id, i.span, i.node.descriptive_variant())\n         }\n \n         intravisit::walk_item(self, i)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        self.check_missing_stability(ti.id, ti.span, \"item\");\n+        self.check_missing_stability(ti.hir_id, ti.span, \"item\");\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent(ii.id));\n+        let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(\n+            self.tcx.hir().get_parent_item(ii.hir_id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n-            self.check_missing_stability(ii.id, ii.span, \"item\");\n+            self.check_missing_stability(ii.hir_id, ii.span, \"item\");\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.check_missing_stability(var.node.data.id(), var.span, \"variant\");\n+        self.check_missing_stability(var.node.data.hir_id(), var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField) {\n-        self.check_missing_stability(s.id, s.span, \"field\");\n+        self.check_missing_stability(s.hir_id, s.span, \"field\");\n         intravisit::walk_struct_field(self, s);\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n-        self.check_missing_stability(i.id, i.span, i.node.descriptive_variant());\n+        self.check_missing_stability(i.hir_id, i.span, i.node.descriptive_variant());\n         intravisit::walk_foreign_item(self, i);\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        self.check_missing_stability(md.id, md.span, \"macro\");\n+        self.check_missing_stability(md.hir_id, md.span, \"macro\");\n     }\n }\n \n@@ -403,10 +396,14 @@ impl<'a, 'tcx> Index<'tcx> {\n             active_features: Default::default(),\n         };\n \n-        let ref active_lib_features = tcx.features().declared_lib_features;\n+        let active_lib_features = &tcx.features().declared_lib_features;\n+        let active_lang_features = &tcx.features().declared_lang_features;\n \n-        // Put the active features into a map for quick lookup\n-        index.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n+        // Put the active features into a map for quick lookup.\n+        index.active_features =\n+            active_lib_features.iter().map(|&(ref s, ..)| s.clone())\n+            .chain(active_lang_features.iter().map(|&(ref s, ..)| s.clone()))\n+            .collect();\n \n         {\n             let krate = tcx.hir().krate();\n@@ -441,7 +438,7 @@ impl<'a, 'tcx> Index<'tcx> {\n                 annotator.parent_stab = Some(stability);\n             }\n \n-            annotator.annotate(ast::CRATE_NODE_ID,\n+            annotator.annotate(hir::CRATE_HIR_ID,\n                                &krate.attrs,\n                                krate.span,\n                                AnnotationKind::Required,\n@@ -459,12 +456,6 @@ impl<'a, 'tcx> Index<'tcx> {\n     }\n }\n \n-pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_unstable_api_usage(tcx.hir().local_def_id(module));\n-    }\n-}\n-\n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors.\n fn check_mod_unstable_api_usage<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n@@ -563,9 +554,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// If `id` is `Some(_)`, this function will also check if the item at `def_id` has been\n     /// deprecated. If the item is indeed deprecated, we will emit a deprecation lint attached to\n     /// `id`.\n-    pub fn eval_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) -> EvalResult {\n+    pub fn eval_stability(self, def_id: DefId, id: Option<HirId>, span: Span) -> EvalResult {\n         let lint_deprecated = |def_id: DefId,\n-                               id: NodeId,\n+                               id: HirId,\n                                note: Option<Symbol>,\n                                suggestion: Option<Symbol>,\n                                message: &str,\n@@ -576,9 +567,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"{}\", message)\n             };\n \n-            let mut diag = self.struct_span_lint_node(lint, id, span, &msg);\n+            let mut diag = self.struct_span_lint_hir(lint, id, span, &msg);\n             if let Some(suggestion) = suggestion {\n-                if let hir::Node::Expr(_) = self.hir().get(id) {\n+                if let hir::Node::Expr(_) = self.hir().get_by_hir_id(id) {\n                     diag.span_suggestion(\n                         span,\n                         &msg,\n@@ -588,15 +579,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             diag.emit();\n-            if id == ast::DUMMY_NODE_ID {\n-                span_bug!(span, \"emitted a {} lint with dummy node id: {:?}\", lint.name, def_id);\n+            if id == hir::DUMMY_HIR_ID {\n+                span_bug!(span, \"emitted a {} lint with dummy HIR id: {:?}\", lint.name, def_id);\n             }\n         };\n \n         // Deprecated attributes apply in-crate and cross-crate.\n         if let Some(id) = id {\n             if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n-                let parent_def_id = self.hir().local_def_id(self.hir().get_parent(id));\n+                let parent_def_id = self.hir().local_def_id_from_hir_id(\n+                    self.hir().get_parent_item(id));\n                 let skip = self.lookup_deprecation_entry(parent_def_id)\n                                .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n@@ -709,7 +701,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n     /// not `None`, a deprecated lint attached to `id` will be emitted.\n-    pub fn check_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) {\n+    pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n         match self.eval_stability(def_id, id, span) {\n             EvalResult::Allow => {}\n             EvalResult::Deny { feature, reason, issue } => {\n@@ -763,13 +755,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span.is_dummy() { return }\n \n-                let def_id = self.tcx.hir().local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {\n                     Some(cnum) => cnum,\n                     None => return,\n                 };\n                 let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-                self.tcx.check_stability(def_id, Some(item.id), item.span);\n+                self.tcx.check_stability(def_id, Some(item.hir_id), item.span);\n             }\n \n             // For implementations of traits, check the stability of each item\n@@ -793,7 +785,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             // There's no good place to insert stability check for non-Copy unions,\n             // so semi-randomly perform it here in stability.rs\n             hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n-                let def_id = self.tcx.hir().local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let ty = self.tcx.type_of(def_id);\n \n@@ -817,7 +809,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &'tcx hir::Path, id: hir::HirId) {\n-        let id = self.tcx.hir().hir_to_node_id(id);\n         if let Some(def_id) = path.def.opt_def_id() {\n             self.tcx.check_stability(def_id, Some(id), path.span)\n         }\n@@ -843,7 +834,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             tcx,\n             access_levels,\n         };\n-        missing.check_missing_stability(ast::CRATE_NODE_ID, krate.span, \"crate\");\n+        missing.check_missing_stability(hir::CRATE_HIR_ID, krate.span, \"crate\");\n         intravisit::walk_crate(&mut missing, krate);\n         krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }\n@@ -924,8 +915,8 @@ fn unnecessary_stable_feature_lint<'a, 'tcx>(\n     feature: Symbol,\n     since: Symbol\n ) {\n-    tcx.lint_node(lint::builtin::STABLE_FEATURES,\n-        ast::CRATE_NODE_ID,\n+    tcx.lint_hir(lint::builtin::STABLE_FEATURES,\n+        hir::CRATE_HIR_ID,\n         span,\n         &format!(\"the feature `{}` has been stable since {} and no longer requires \\\n                   an attribute to enable\", feature, since));"}, {"sha": "d4ee60eee631004c85e04143d410b6f58f8cb95d", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -11,11 +11,12 @@ use std::iter;\n use crate::mir;\n use std::ops::{Deref, DerefMut};\n use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_macros::HashStable;\n use rustc_target::abi::HasDataLayout;\n \n /// Used by `check_bounds` to indicate whether the pointer needs to be just inbounds\n /// or also inbounds of a *live* allocation.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InboundsCheck {\n     Live,\n     MaybeDead,"}, {"sha": "819c65e2503260649b7d395ee412c10377207cef", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,10 +1,12 @@\n use std::{fmt, env};\n \n+use crate::hir;\n use crate::hir::map::definitions::DefPathData;\n use crate::mir;\n use crate::ty::{self, Ty, layout};\n use crate::ty::layout::{Size, Align, LayoutError};\n use rustc_target::spec::abi::Abi;\n+use rustc_macros::HashStable;\n \n use super::{RawConst, Pointer, InboundsCheck, ScalarMaybeUndef};\n \n@@ -14,10 +16,9 @@ use crate::ty::query::TyCtxtAt;\n use errors::DiagnosticBuilder;\n \n use syntax_pos::{Pos, Span};\n-use syntax::ast;\n use syntax::symbol::Symbol;\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable)]\n pub enum ErrorHandled {\n     /// Already reported a lint or an error for this evaluation.\n     Reported,\n@@ -46,11 +47,11 @@ pub struct ConstEvalErr<'tcx> {\n     pub stacktrace: Vec<FrameInfo<'tcx>>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct FrameInfo<'tcx> {\n     pub call_site: Span, // this span is in the caller!\n     pub instance: ty::Instance<'tcx>,\n-    pub lint_root: Option<ast::NodeId>,\n+    pub lint_root: Option<hir::HirId>,\n }\n \n impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n@@ -98,7 +99,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n     pub fn report_as_lint(&self,\n         tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n         message: &str,\n-        lint_root: ast::NodeId,\n+        lint_root: hir::HirId,\n     ) -> ErrorHandled {\n         let lint = self.struct_generic(\n             tcx,\n@@ -118,7 +119,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         &self,\n         tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n         message: &str,\n-        lint_root: Option<ast::NodeId>,\n+        lint_root: Option<hir::HirId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n         match self.error {\n             EvalErrorKind::Layout(LayoutError::Unknown(_)) |\n@@ -129,15 +130,15 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         }\n         trace!(\"reporting const eval failure at {:?}\", self.span);\n         let mut err = if let Some(lint_root) = lint_root {\n-            let node_id = self.stacktrace\n+            let hir_id = self.stacktrace\n                 .iter()\n                 .rev()\n                 .filter_map(|frame| frame.lint_root)\n                 .next()\n                 .unwrap_or(lint_root);\n-            tcx.struct_span_lint_node(\n+            tcx.struct_span_lint_hir(\n                 crate::rustc::lint::builtin::CONST_ERR,\n-                node_id,\n+                hir_id,\n                 tcx.span,\n                 message,\n             )\n@@ -209,7 +210,7 @@ impl<'tcx> From<EvalErrorKind<'tcx, u64>> for EvalError<'tcx> {\n \n pub type AssertMessage<'tcx> = EvalErrorKind<'tcx, mir::Operand<'tcx>>;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum EvalErrorKind<'tcx, O> {\n     /// This variant is used by machines to signal their own errors that do not\n     /// match an existing variant."}, {"sha": "9fb023156022a135e82507bc03af7fd7bfccdd29", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -34,13 +34,14 @@ use crate::rustc_serialize::{Encoder, Decodable, Encodable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n use rustc_data_structures::tiny_list::TinyList;\n+use rustc_macros::HashStable;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n use crate::ty::codec::TyDecoder;\n use std::sync::atomic::{AtomicU32, Ordering};\n use std::num::NonZeroU32;\n \n /// Uniquely identifies a specific constant or static.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GlobalId<'tcx> {\n     /// For a constant or static, the `Instance` of the item itself.\n     /// For a promoted global, the `Instance` of the function they belong to.\n@@ -258,7 +259,7 @@ impl fmt::Display for AllocId {\n     }\n }\n \n-#[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub enum AllocKind<'tcx> {\n     /// The alloc ID is used as a function pointer\n     Function(Instance<'tcx>),"}, {"sha": "9216cb494cef9ccae392230d9abbfcdb5f2de7e9", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,5 +1,6 @@\n use crate::mir;\n use crate::ty::layout::{self, HasDataLayout, Size};\n+use rustc_macros::HashStable;\n \n use super::{\n     AllocId, EvalResult, InboundsCheck,\n@@ -69,7 +70,8 @@ impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n ///\n /// Pointer is also generic over the `Tag` associated with each pointer,\n /// which is used to do provenance tracking during execution.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd,\n+         RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub struct Pointer<Tag=(),Id=AllocId> {\n     pub alloc_id: Id,\n     pub offset: Size,"}, {"sha": "9620ac95d86d10db78fba8978117e0b951156ad1", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,11 +1,12 @@\n use std::fmt;\n+use rustc_macros::HashStable;\n \n-use crate::ty::{Ty, layout::{HasDataLayout, Size}};\n+use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}};\n \n use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n /// Represents the result of a raw const operation, pre-validation.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub struct RawConst<'tcx> {\n     // the value lives here, at offset 0, and that allocation definitely is a `AllocKind::Memory`\n     // (so you can use `AllocMap::unwrap_memory`).\n@@ -15,8 +16,15 @@ pub struct RawConst<'tcx> {\n \n /// Represents a constant value in Rust. `Scalar` and `ScalarPair` are optimizations that\n /// match the `LocalState` optimizations for easy conversions between `Value` and `ConstValue`.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord,\n+         RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum ConstValue<'tcx> {\n+    /// A const generic parameter.\n+    Param(ParamConst),\n+\n+    /// Infer the value of the const.\n+    Infer(InferConst<'tcx>),\n+\n     /// Used only for types with `layout::abi::Scalar` ABI and ZSTs.\n     ///\n     /// Not using the enum `Value` to encode that this must not be `Undef`.\n@@ -43,6 +51,8 @@ impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n     pub fn try_to_scalar(&self) -> Option<Scalar> {\n         match *self {\n+            ConstValue::Param(_) |\n+            ConstValue::Infer(_) |\n             ConstValue::ByRef(..) |\n             ConstValue::Slice(..) => None,\n             ConstValue::Scalar(val) => Some(val),\n@@ -72,7 +82,8 @@ impl<'tcx> ConstValue<'tcx> {\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n /// of a simple value or a pointer into another `Allocation`\n-#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd,\n+         RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum Scalar<Tag=(), Id=AllocId> {\n     /// The raw bytes of a simple value.\n     Bits {"}, {"sha": "3a4422a62390bc8493425e695d4cc830ca00bf4b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 92, "deletions": 66, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::sync::MappedReadGuard;\n+use rustc_macros::HashStable;\n use crate::rustc_serialize::{self as serialize};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n@@ -27,7 +28,7 @@ use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::subst::{Subst, Substs};\n+use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::layout::VariantIdx;\n use crate::ty::{\n     self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n@@ -405,15 +406,15 @@ impl<'tcx> Mir<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Safety {\n     Safe,\n     /// Unsafe because of a PushUnsafeBlock\n     BuiltinUnsafe,\n     /// Unsafe because of an unsafe fn\n     FnUnsafe,\n     /// Unsafe because of an `unsafe` block\n-    ExplicitUnsafe(ast::NodeId),\n+    ExplicitUnsafe(hir::HirId),\n }\n \n impl_stable_hash_for!(struct Mir<'tcx> {\n@@ -451,7 +452,7 @@ impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub enum ClearCrossCrate<T> {\n     Clear,\n     Set(T),\n@@ -472,7 +473,7 @@ impl<T: serialize::Decodable> serialize::UseSpecializedDecodable for ClearCrossC\n /// Grouped information about the source code origin of a MIR entity.\n /// Intended to be inspected by diagnostics and debuginfo.\n /// Most passes can work with it as a whole, within a single function.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub struct SourceInfo {\n     /// Source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n@@ -485,7 +486,7 @@ pub struct SourceInfo {\n ///////////////////////////////////////////////////////////////////////////\n // Mutability and borrow kinds\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Mutability {\n     Mut,\n     Not,\n@@ -500,7 +501,8 @@ impl From<Mutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd,\n+         Ord, RustcEncodable, RustcDecodable, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     Shared,\n@@ -585,13 +587,14 @@ impl BorrowKind {\n \n newtype_index! {\n     pub struct Local {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"_{}\",\n         const RETURN_PLACE = 0,\n     }\n }\n \n /// Classifies locals into categories. See `Mir::local_kind`.\n-#[derive(PartialEq, Eq, Debug)]\n+#[derive(PartialEq, Eq, Debug, HashStable)]\n pub enum LocalKind {\n     /// User-declared variable binding\n     Var,\n@@ -721,7 +724,7 @@ impl_stable_hash_for!(struct BlockTailInfo { tail_result_is_ignored });\n ///\n /// This can be a binding declared by the user, a temporary inserted by the compiler, a function\n /// argument, or the return place.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct LocalDecl<'tcx> {\n     /// `let mut x` vs `let x`.\n     ///\n@@ -977,7 +980,7 @@ impl<'tcx> LocalDecl<'tcx> {\n }\n \n /// A closure capture, with its name and mode.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UpvarDecl {\n     pub debug_name: Name,\n \n@@ -995,6 +998,7 @@ pub struct UpvarDecl {\n \n newtype_index! {\n     pub struct BasicBlock {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"bb{}\",\n         const START_BLOCK = 0,\n     }\n@@ -1012,7 +1016,7 @@ impl BasicBlock {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct BasicBlockData<'tcx> {\n     /// List of statements in this block.\n     pub statements: Vec<Statement<'tcx>>,\n@@ -1034,13 +1038,13 @@ pub struct BasicBlockData<'tcx> {\n     pub is_cleanup: bool,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Terminator<'tcx> {\n     pub source_info: SourceInfo,\n     pub kind: TerminatorKind<'tcx>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum TerminatorKind<'tcx> {\n     /// block should have one successor in the graph; we jump there\n     Goto { target: BasicBlock },\n@@ -1723,7 +1727,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Statement<'tcx> {\n     pub source_info: SourceInfo,\n     pub kind: StatementKind<'tcx>,\n@@ -1749,7 +1753,7 @@ impl<'tcx> Statement<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n     Assign(Place<'tcx>, Box<Rvalue<'tcx>>),\n@@ -1808,7 +1812,7 @@ pub enum StatementKind<'tcx> {\n }\n \n /// `RetagKind` describes what kind of retag is to be performed.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, HashStable)]\n pub enum RetagKind {\n     /// The initial retag when entering a function\n     FnEntry,\n@@ -1821,7 +1825,7 @@ pub enum RetagKind {\n }\n \n /// The `FakeReadCause` describes the type of pattern why a `FakeRead` statement exists.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum FakeReadCause {\n     /// Inject a fake read of the borrowed input at the end of each guards\n     /// code.\n@@ -1894,8 +1898,16 @@ impl<'tcx> Debug for Statement<'tcx> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Place<'tcx> {\n+    Base(PlaceBase<'tcx>),\n+\n+    /// projection out of a place (access a field, deref a pointer, etc)\n+    Projection(Box<PlaceProjection<'tcx>>),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum PlaceBase<'tcx> {\n     /// local variable\n     Local(Local),\n \n@@ -1904,9 +1916,6 @@ pub enum Place<'tcx> {\n \n     /// Constant code promoted to an injected static\n     Promoted(Box<(Promoted, Ty<'tcx>)>),\n-\n-    /// projection out of a place (access a field, deref a pointer, etc)\n-    Projection(Box<PlaceProjection<'tcx>>),\n }\n \n /// The `DefId` of a static, along with its normalized type (which is\n@@ -1926,13 +1935,15 @@ impl_stable_hash_for!(struct Static<'tcx> {\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Place`. See the aliases\n /// `PlaceProjection` etc below.\n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Projection<'tcx, B, V, T> {\n     pub base: B,\n     pub elem: ProjectionElem<'tcx, V, T>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ProjectionElem<'tcx, V, T> {\n     Deref,\n     Field(Field, T),\n@@ -1989,11 +2000,14 @@ pub type ProjectionKind<'tcx> = ProjectionElem<'tcx, (), ()>;\n \n newtype_index! {\n     pub struct Field {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"field[{}]\"\n     }\n }\n \n impl<'tcx> Place<'tcx> {\n+    pub const RETURN_PLACE: Place<'tcx> = Place::Base(PlaceBase::Local(RETURN_PLACE));\n+\n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n         self.elem(ProjectionElem::Field(f, ty))\n     }\n@@ -2020,9 +2034,9 @@ impl<'tcx> Place<'tcx> {\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local(&self) -> Option<Local> {\n         match self {\n-            Place::Local(local) |\n+            Place::Base(PlaceBase::Local(local)) |\n             Place::Projection(box Projection {\n-                base: Place::Local(local),\n+                base: Place::Base(PlaceBase::Local(local)),\n                 elem: ProjectionElem::Deref,\n             }) => Some(*local),\n             _ => None,\n@@ -2032,9 +2046,9 @@ impl<'tcx> Place<'tcx> {\n     /// Finds the innermost `Local` from this `Place`.\n     pub fn base_local(&self) -> Option<Local> {\n         match self {\n-            Place::Local(local) => Some(*local),\n+            Place::Base(PlaceBase::Local(local)) => Some(*local),\n             Place::Projection(box Projection { base, elem: _ }) => base.base_local(),\n-            Place::Promoted(..) | Place::Static(..) => None,\n+            Place::Base(PlaceBase::Promoted(..)) | Place::Base(PlaceBase::Static(..)) => None,\n         }\n     }\n }\n@@ -2044,14 +2058,19 @@ impl<'tcx> Debug for Place<'tcx> {\n         use self::Place::*;\n \n         match *self {\n-            Local(id) => write!(fmt, \"{:?}\", id),\n-            Static(box self::Static { def_id, ty }) => write!(\n+            Base(PlaceBase::Local(id)) => write!(fmt, \"{:?}\", id),\n+            Base(PlaceBase::Static(box self::Static { def_id, ty })) => write!(\n                 fmt,\n                 \"({}: {:?})\",\n                 ty::tls::with(|tcx| tcx.item_path_str(def_id)),\n                 ty\n             ),\n-            Promoted(ref promoted) => write!(fmt, \"({:?}: {:?})\", promoted.0, promoted.1),\n+            Base(PlaceBase::Promoted(ref promoted)) => write!(\n+                fmt,\n+                \"({:?}: {:?})\",\n+                promoted.0,\n+                promoted.1\n+            ),\n             Projection(ref data) => match data.elem {\n                 ProjectionElem::Downcast(ref adt_def, index) => {\n                     write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].ident)\n@@ -2090,21 +2109,22 @@ impl<'tcx> Debug for Place<'tcx> {\n \n newtype_index! {\n     pub struct SourceScope {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"scope[{}]\",\n         const OUTERMOST_SOURCE_SCOPE = 0,\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SourceScopeData {\n     pub span: Span,\n     pub parent_scope: Option<SourceScope>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SourceScopeLocalData {\n-    /// A NodeId with lint levels equivalent to this scope's lint levels.\n-    pub lint_root: ast::NodeId,\n+    /// A HirId with lint levels equivalent to this scope's lint levels.\n+    pub lint_root: hir::HirId,\n     /// The unsafe block that contains this node.\n     pub safety: Safety,\n }\n@@ -2114,7 +2134,7 @@ pub struct SourceScopeLocalData {\n \n /// These are values that can appear inside an rvalue. They are intentionally\n /// limited to prevent rvalues from being nested in one another.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Operand<'tcx> {\n     /// Copy: The value must be available for use afterwards.\n     ///\n@@ -2151,7 +2171,7 @@ impl<'tcx> Operand<'tcx> {\n     pub fn function_handle<'a>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n+        substs: SubstsRef<'tcx>,\n         span: Span,\n     ) -> Self {\n         let ty = tcx.type_of(def_id).subst(tcx, substs);\n@@ -2176,7 +2196,7 @@ impl<'tcx> Operand<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n /// Rvalues\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Rvalue<'tcx> {\n     /// x (either a move or copy, depending on type of x)\n     Use(Operand<'tcx>),\n@@ -2212,7 +2232,7 @@ pub enum Rvalue<'tcx> {\n     Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum CastKind {\n     Misc,\n \n@@ -2225,6 +2245,9 @@ pub enum CastKind {\n     /// Converts safe fn() to unsafe fn()\n     UnsafeFnPointer,\n \n+    /// Coerces *mut T to *const T, preserving T.\n+    MutToConstPointer,\n+\n     /// \"Unsize\" -- convert a thin-or-fat pointer to a fat pointer.\n     /// codegen must figure out the details once full monomorphization\n     /// is known. For example, this could be used to cast from a\n@@ -2233,7 +2256,7 @@ pub enum CastKind {\n     Unsize,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AggregateKind<'tcx> {\n     /// The type is of the element\n     Array(Ty<'tcx>),\n@@ -2247,7 +2270,7 @@ pub enum AggregateKind<'tcx> {\n     Adt(\n         &'tcx AdtDef,\n         VariantIdx,\n-        &'tcx Substs<'tcx>,\n+        SubstsRef<'tcx>,\n         Option<UserTypeAnnotationIndex>,\n         Option<usize>,\n     ),\n@@ -2256,7 +2279,7 @@ pub enum AggregateKind<'tcx> {\n     Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum BinOp {\n     /// The `+` operator (addition)\n     Add,\n@@ -2304,15 +2327,15 @@ impl BinOp {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum NullOp {\n     /// Returns the size of a value of that type\n     SizeOf,\n     /// Creates a new uninitialized box for a value of that type\n     Box,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnOp {\n     /// The `!` operator for logical inversion\n     Not,\n@@ -2396,15 +2419,15 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }\n \n                     AggregateKind::Closure(def_id, _) => ty::tls::with(|tcx| {\n-                        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+                        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n-                                format!(\"[closure@{:?}]\", node_id)\n+                                format!(\"[closure@{:?}]\", hir_id)\n                             } else {\n-                                format!(\"[closure@{:?}]\", tcx.hir().span(node_id))\n+                                format!(\"[closure@{:?}]\", tcx.hir().span_by_hir_id(hir_id))\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            tcx.with_freevars(node_id, |freevars| {\n+                            tcx.with_freevars(hir_id, |freevars| {\n                                 for (freevar, place) in freevars.iter().zip(places) {\n                                     let var_name = tcx.hir().name(freevar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n@@ -2418,11 +2441,12 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }),\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n-                        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n-                            let name = format!(\"[generator@{:?}]\", tcx.hir().span(node_id));\n+                        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+                            let name = format!(\"[generator@{:?}]\",\n+                                               tcx.hir().span_by_hir_id(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            tcx.with_freevars(node_id, |freevars| {\n+                            tcx.with_freevars(hir_id, |freevars| {\n                                 for (freevar, place) in freevars.iter().zip(places) {\n                                     let var_name = tcx.hir().name(freevar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n@@ -2452,7 +2476,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// this does not necessarily mean that they are \"==\" in Rust -- in\n /// particular one must be wary of `NaN`!\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n@@ -2499,7 +2523,7 @@ pub struct Constant<'tcx> {\n /// The first will lead to the constraint `w: &'1 str` (for some\n /// inferred region `'1`). The second will lead to the constraint `w:\n /// &'static str`.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserTypeProjections<'tcx> {\n     pub(crate) contents: Vec<(UserTypeProjection<'tcx>, Span)>,\n }\n@@ -2585,7 +2609,7 @@ impl<'tcx> UserTypeProjections<'tcx> {\n /// * `let (x, _): T = ...` -- here, the `projs` vector would contain\n ///   `field[0]` (aka `.0`), indicating that the type of `s` is\n ///   determined by finding the type of the `.0` field from `T`.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserTypeProjection<'tcx> {\n     pub base: UserTypeAnnotationIndex,\n     pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n@@ -2655,6 +2679,7 @@ impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n \n newtype_index! {\n     pub struct Promoted {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"promoted[{}]\"\n     }\n }\n@@ -2777,7 +2802,7 @@ impl<'a, 'b> graph::GraphSuccessors<'b> for Mir<'a> {\n     type Iter = iter::Cloned<Successors<'b>>;\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd, HashStable)]\n pub struct Location {\n     /// the location is within this block\n     pub block: BasicBlock,\n@@ -2849,39 +2874,39 @@ impl Location {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n     General,\n     /// Permitted in const fn and regular fns.\n     GeneralAndConstFn,\n-    ExternStatic(ast::NodeId),\n-    BorrowPacked(ast::NodeId),\n+    ExternStatic(hir::HirId),\n+    BorrowPacked(hir::HirId),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n     pub description: InternedString,\n     pub details: InternedString,\n     pub kind: UnsafetyViolationKind,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyCheckResult {\n     /// Violations that are propagated *upwards* from this function\n     pub violations: Lrc<[UnsafetyViolation]>,\n     /// unsafe blocks in this function, along with whether they are used. This is\n     /// used for the \"unused_unsafe\" lint.\n-    pub unsafe_blocks: Lrc<[(ast::NodeId, bool)]>,\n+    pub unsafe_blocks: Lrc<[(hir::HirId, bool)]>,\n }\n \n /// The layout of generator state\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GeneratorLayout<'tcx> {\n     pub fields: Vec<LocalDecl<'tcx>>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct BorrowCheckResult<'gcx> {\n     pub closure_requirements: Option<ClosureRegionRequirements<'gcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n@@ -2937,7 +2962,7 @@ pub struct BorrowCheckResult<'gcx> {\n /// that case because the regions must be allocated in the global\n /// TyCtxt, and hence we cannot use `ReVar` (which is what we use\n /// internally within the rest of the NLL code).\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureRegionRequirements<'gcx> {\n     /// The number of external regions defined on the closure. In our\n     /// example above, it would be 3 -- one for `'static`, then `'1`\n@@ -2953,7 +2978,7 @@ pub struct ClosureRegionRequirements<'gcx> {\n \n /// Indicates an outlives constraint between a type or between two\n /// free-regions declared on the closure.\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureOutlivesRequirement<'tcx> {\n     // This region or type ...\n     pub subject: ClosureOutlivesSubject<'tcx>,\n@@ -2973,7 +2998,8 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n /// order of the category, thereby influencing diagnostic output.\n ///\n /// See also [rustc_mir::borrow_check::nll::constraints]\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ConstraintCategory {\n     Return,\n     Yield,\n@@ -3010,7 +3036,7 @@ pub enum ConstraintCategory {\n \n /// The subject of a ClosureOutlivesRequirement -- that is, the thing\n /// that must outlive some region.\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ClosureOutlivesSubject<'tcx> {\n     /// Subject is a type, typically a type parameter, but could also\n     /// be a projection. Indicates a requirement like `T: 'a` being"}, {"sha": "c75f7d7d15946a8d02448b8b4ed1e63d0fe47503", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,5 +1,5 @@\n use crate::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n-use syntax::ast::NodeId;\n+use crate::hir::HirId;\n use syntax::symbol::{Symbol, InternedString};\n use crate::ty::{Instance, TyCtxt};\n use crate::util::nodemap::FxHashMap;\n@@ -14,7 +14,7 @@ use std::hash::Hash;\n pub enum MonoItem<'tcx> {\n     Fn(Instance<'tcx>),\n     Static(DefId),\n-    GlobalAsm(NodeId),\n+    GlobalAsm(HirId),\n }\n \n impl<'tcx> MonoItem<'tcx> {"}, {"sha": "a6f153eaf6461e5c0772c8f18b7188f2bbfb82e8", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -4,7 +4,7 @@\n  */\n \n use crate::mir::*;\n-use crate::ty::subst::{Subst, Substs};\n+use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{self, AdtDef, Ty, TyCtxt};\n use crate::ty::layout::VariantIdx;\n use crate::hir;\n@@ -17,7 +17,7 @@ pub enum PlaceTy<'tcx> {\n \n     /// Downcast to a particular variant of an enum.\n     Downcast { adt_def: &'tcx AdtDef,\n-               substs: &'tcx Substs<'tcx>,\n+               substs: SubstsRef<'tcx>,\n                variant_index: VariantIdx },\n }\n \n@@ -158,10 +158,10 @@ impl<'tcx> Place<'tcx> {\n         where D: HasLocalDecls<'tcx>\n     {\n         match *self {\n-            Place::Local(index) =>\n+            Place::Base(PlaceBase::Local(index)) =>\n                 PlaceTy::Ty { ty: local_decls.local_decls()[index].ty },\n-            Place::Promoted(ref data) => PlaceTy::Ty { ty: data.1 },\n-            Place::Static(ref data) =>\n+            Place::Base(PlaceBase::Promoted(ref data)) => PlaceTy::Ty { ty: data.1 },\n+            Place::Base(PlaceBase::Static(ref data)) =>\n                 PlaceTy::Ty { ty: data.ty },\n             Place::Projection(ref proj) =>\n                 proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),"}, {"sha": "28e816f134365518cb7950834b7b9ef4c9083c2f", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,5 +1,5 @@\n use crate::hir::def_id::DefId;\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::SubstsRef;\n use crate::ty::{CanonicalUserTypeAnnotation, ClosureSubsts, GeneratorSubsts, Region, Ty};\n use crate::mir::*;\n use syntax_pos::Span;\n@@ -238,7 +238,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_substs(&mut self,\n-                            substs: & $($mutability)? &'tcx Substs<'tcx>,\n+                            substs: & $($mutability)? SubstsRef<'tcx>,\n                             _: Location) {\n                 self.super_substs(substs);\n             }\n@@ -733,13 +733,13 @@ macro_rules! make_mir_visitor {\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n                 match place {\n-                    Place::Local(local) => {\n+                    Place::Base(PlaceBase::Local(local)) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    Place::Static(static_) => {\n+                    Place::Base(PlaceBase::Static(static_)) => {\n                         self.visit_static(static_, context, location);\n                     }\n-                    Place::Promoted(promoted) => {\n+                    Place::Base(PlaceBase::Promoted(promoted)) => {\n                         self.visit_ty(& $($mutability)? promoted.1, TyContext::Location(location));\n                     },\n                     Place::Projection(proj) => {\n@@ -889,7 +889,7 @@ macro_rules! make_mir_visitor {\n             fn super_const(&mut self, _const: & $($mutability)? &'tcx ty::LazyConst<'tcx>) {\n             }\n \n-            fn super_substs(&mut self, _substs: & $($mutability)? &'tcx Substs<'tcx>) {\n+            fn super_substs(&mut self, _substs: & $($mutability)? SubstsRef<'tcx>) {\n             }\n \n             fn super_generator_substs(&mut self,"}, {"sha": "55c4b0e54b8223f4061f23f125aed699f3d0d31b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -11,6 +11,7 @@ use rustc_target::spec::{Target, TargetTriple};\n use crate::lint;\n use crate::middle::cstore;\n \n+use syntax;\n use syntax::ast::{self, IntTy, UintTy, MetaItemKind};\n use syntax::source_map::{FileName, FilePathMapping};\n use syntax::edition::{Edition, EDITION_NAME_LIST, DEFAULT_EDITION};\n@@ -499,6 +500,13 @@ impl Input {\n             Input::Str { ref mut input, .. } => Some(input),\n         }\n     }\n+\n+    pub fn source_name(&self) -> FileName {\n+        match *self {\n+            Input::File(ref ifile) => ifile.clone().into(),\n+            Input::Str { ref name, .. } => name.clone(),\n+        }\n+    }\n }\n \n #[derive(Clone, Hash)]\n@@ -809,6 +817,8 @@ macro_rules! options {\n             Some(\"crate=integer\");\n         pub const parse_unpretty: Option<&str> =\n             Some(\"`string` or `string=string`\");\n+        pub const parse_treat_err_as_bug: Option<&str> =\n+            Some(\"either no value or a number bigger than 0\");\n         pub const parse_lto: Option<&str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, \\\n                   `fat`, or omitted\");\n@@ -1015,6 +1025,13 @@ macro_rules! options {\n             }\n         }\n \n+        fn parse_treat_err_as_bug(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = s.parse().ok().filter(|&x| x != 0); slot.unwrap_or(0) != 0 }\n+                None => { *slot = Some(1); true }\n+            }\n+        }\n+\n         fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n             if v.is_some() {\n                 let mut bool_arg = None;\n@@ -1225,10 +1242,12 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n          Use with RUST_REGION_GRAPH=help for more info\"),\n     parse_only: bool = (false, parse_bool, [UNTRACKED],\n         \"parse only; do not compile, assemble, or link\"),\n+    dual_proc_macros: bool = (false, parse_bool, [TRACKED],\n+        \"load proc macros for both target and host, but only link to the target\"),\n     no_codegen: bool = (false, parse_bool, [TRACKED],\n         \"run all passes except codegen; no output\"),\n-    treat_err_as_bug: bool = (false, parse_bool, [TRACKED],\n-        \"treat all errors that occur as bugs\"),\n+    treat_err_as_bug: Option<usize> = (None, parse_treat_err_as_bug, [TRACKED],\n+        \"treat error number `val` that occurs as bug\"),\n     report_delayed_bugs: bool = (false, parse_bool, [TRACKED],\n         \"immediately print bugs registered with `delay_span_bug`\"),\n     external_macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n@@ -1398,9 +1417,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     crate_attr: Vec<String> = (Vec::new(), parse_string_push, [TRACKED],\n         \"inject the given attribute in the crate\"),\n     self_profile: bool = (false, parse_bool, [UNTRACKED],\n-        \"run the self profiler\"),\n-    profile_json: bool = (false, parse_bool, [UNTRACKED],\n-        \"output a json file with profiler results\"),\n+        \"run the self profiler and output the raw event data\"),\n     emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n         \"emits a section containing stack size metadata\"),\n     plt: Option<bool> = (None, parse_opt_bool, [TRACKED],\n@@ -1478,6 +1495,15 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     ret\n }\n \n+/// Converts the crate cfg! configuration from String to Symbol.\n+/// `rustc_interface::interface::Config` accepts this in the compiler configuration,\n+/// but the symbol interner is not yet set up then, so we must convert it later.\n+pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> ast::CrateConfig {\n+    cfg.into_iter()\n+       .map(|(a, b)| (Symbol::intern(&a), b.map(|b| Symbol::intern(&b))))\n+       .collect()\n+}\n+\n pub fn build_configuration(sess: &Session, mut user_cfg: ast::CrateConfig) -> ast::CrateConfig {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n@@ -1784,10 +1810,9 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> ast::CrateConfig {\n-    cfgspecs\n-        .into_iter()\n-        .map(|s| {\n+pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n+    syntax::with_globals(move || {\n+        let cfg = cfgspecs.into_iter().map(|s| {\n             let sess = parse::ParseSess::new(FilePathMapping::empty());\n             let filename = FileName::cfg_spec_source_code(&s);\n             let mut parser = parse::new_parser_from_source_str(&sess, filename, s.to_string());\n@@ -1819,8 +1844,11 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> ast::CrateConfig {\n             }\n \n             error!(r#\"expected `key` or `key=\"value\"`\"#);\n-        })\n-        .collect::<ast::CrateConfig>()\n+        }).collect::<ast::CrateConfig>();\n+        cfg.into_iter().map(|(a, b)| {\n+            (a.to_string(), b.map(|b| b.to_string()))\n+        }).collect()\n+    })\n }\n \n pub fn get_cmd_lint_options(matches: &getopts::Matches,\n@@ -1848,7 +1876,7 @@ pub fn get_cmd_lint_options(matches: &getopts::Matches,\n \n pub fn build_session_options_and_crate_config(\n     matches: &getopts::Matches,\n-) -> (Options, ast::CrateConfig) {\n+) -> (Options, FxHashSet<(String, Option<String>)>) {\n     let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n         Some(\"auto\") => ColorConfig::Auto,\n         Some(\"always\") => ColorConfig::Always,\n@@ -2574,7 +2602,11 @@ mod tests {\n     use getopts;\n     use crate::lint;\n     use crate::middle::cstore;\n-    use crate::session::config::{build_configuration, build_session_options_and_crate_config};\n+    use crate::session::config::{\n+        build_configuration,\n+        build_session_options_and_crate_config,\n+        to_crate_config\n+    };\n     use crate::session::config::{LtoCli, LinkerPluginLto};\n     use crate::session::build_session;\n     use crate::session::search_paths::SearchPath;\n@@ -2615,7 +2647,7 @@ mod tests {\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n             let sess = build_session(sessopts, None, registry);\n-            let cfg = build_configuration(&sess, cfg);\n+            let cfg = build_configuration(&sess, to_crate_config(cfg));\n             assert!(cfg.contains(&(Symbol::intern(\"test\"), None)));\n         });\n     }\n@@ -2633,7 +2665,7 @@ mod tests {\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n             let sess = build_session(sessopts, None, registry);\n-            let cfg = build_configuration(&sess, cfg);\n+            let cfg = build_configuration(&sess, to_crate_config(cfg));\n             let mut test_items = cfg.iter().filter(|&&(name, _)| name == \"test\");\n             assert!(test_items.next().is_some());\n             assert!(test_items.next().is_none());\n@@ -3207,7 +3239,7 @@ mod tests {\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n         opts = reference.clone();\n-        opts.debugging_opts.treat_err_as_bug = true;\n+        opts.debugging_opts.treat_err_as_bug = Some(1);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n         opts = reference.clone();"}, {"sha": "cf09d45ca38fc3556ac6d3760496ff8160848798", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -18,6 +18,7 @@ pub enum FileMatch {\n \n // A module for searching for libraries\n \n+#[derive(Clone)]\n pub struct FileSearch<'a> {\n     sysroot: &'a Path,\n     triple: &'a str,"}, {"sha": "75a0a8195bc2ef1dcd5b114e92eeecf36d5e3eac", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 94, "deletions": 110, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -34,7 +34,8 @@ use crate::util::profiling::SelfProfiler;\n \n use rustc_target::spec::{PanicStrategy, RelroLevel, Target, TargetTriple};\n use rustc_data_structures::flock;\n-use jobserver::Client;\n+use rustc_data_structures::jobserver;\n+use ::jobserver::Client;\n \n use std;\n use std::cell::{self, Cell, RefCell};\n@@ -43,7 +44,9 @@ use std::fmt;\n use std::io::Write;\n use std::path::PathBuf;\n use std::time::Duration;\n-use std::sync::mpsc;\n+use std::sync::{Arc, mpsc};\n+\n+use parking_lot::Mutex as PlMutex;\n \n mod code_stats;\n pub mod config;\n@@ -126,11 +129,8 @@ pub struct Session {\n     /// Used by `-Z profile-queries` in `util::common`.\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n-    /// Used by `-Z self-profile`.\n-    pub self_profiling_active: bool,\n-\n-    /// Used by `-Z self-profile`.\n-    pub self_profiling: Lock<SelfProfiler>,\n+    /// Used by -Z self-profile\n+    pub self_profiling: Option<Arc<PlMutex<SelfProfiler>>>,\n \n     /// Some measurements that are being gathered during compilation.\n     pub perf_stats: PerfStats,\n@@ -311,7 +311,7 @@ impl Session {\n     pub fn abort_if_errors(&self) {\n         self.diagnostic().abort_if_errors();\n     }\n-    pub fn compile_status(&self) -> Result<(), CompileIncomplete> {\n+    pub fn compile_status(&self) -> Result<(), ErrorReported> {\n         compile_result_from_err_count(self.err_count())\n     }\n     pub fn track_errors<F, T>(&self, f: F) -> Result<T, ErrorReported>\n@@ -833,27 +833,23 @@ impl Session {\n     #[inline(never)]\n     #[cold]\n     fn profiler_active<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n-        let mut profiler = self.self_profiling.borrow_mut();\n-        f(&mut profiler);\n+        match &self.self_profiling {\n+            None => bug!(\"profiler_active() called but there was no profiler active\"),\n+            Some(profiler) => {\n+                let mut p = profiler.lock();\n+\n+                f(&mut p);\n+            }\n+        }\n     }\n \n     #[inline(always)]\n     pub fn profiler<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n-        if unlikely!(self.self_profiling_active) {\n+        if unlikely!(self.self_profiling.is_some()) {\n             self.profiler_active(f)\n         }\n     }\n \n-    pub fn print_profiler_results(&self) {\n-        let mut profiler = self.self_profiling.borrow_mut();\n-        profiler.print_results(&self.opts);\n-    }\n-\n-    pub fn save_json_results(&self) {\n-        let profiler = self.self_profiling.borrow();\n-        profiler.save_results(&self.opts);\n-    }\n-\n     pub fn print_perf_stats(&self) {\n         println!(\n             \"Total time spent computing symbol hashes:      {}\",\n@@ -899,14 +895,14 @@ impl Session {\n \n     /// Returns the number of query threads that should be used for this\n     /// compilation\n-    pub fn threads_from_opts(opts: &config::Options) -> usize {\n-        opts.debugging_opts.threads.unwrap_or(::num_cpus::get())\n+    pub fn threads_from_count(query_threads: Option<usize>) -> usize {\n+        query_threads.unwrap_or(::num_cpus::get())\n     }\n \n     /// Returns the number of query threads that should be used for this\n     /// compilation\n     pub fn threads(&self) -> usize {\n-        Self::threads_from_opts(&self.opts)\n+        Self::threads_from_count(self.opts.debugging_opts.threads)\n     }\n \n     /// Returns the number of codegen units that should be used for this\n@@ -1023,16 +1019,67 @@ pub fn build_session(\n         local_crate_source_file,\n         registry,\n         Lrc::new(source_map::SourceMap::new(file_path_mapping)),\n-        None,\n+        DiagnosticOutput::Default,\n+        Default::default(),\n     )\n }\n \n+fn default_emitter(\n+    sopts: &config::Options,\n+    registry: errors::registry::Registry,\n+    source_map: &Lrc<source_map::SourceMap>,\n+    emitter_dest: Option<Box<dyn Write + Send>>,\n+) -> Box<dyn Emitter + sync::Send> {\n+    match (sopts.error_format, emitter_dest) {\n+        (config::ErrorOutputType::HumanReadable(color_config), None) => Box::new(\n+            EmitterWriter::stderr(\n+                color_config,\n+                Some(source_map.clone()),\n+                false,\n+                sopts.debugging_opts.teach,\n+            ).ui_testing(sopts.debugging_opts.ui_testing),\n+        ),\n+        (config::ErrorOutputType::HumanReadable(_), Some(dst)) => Box::new(\n+            EmitterWriter::new(dst, Some(source_map.clone()), false, false)\n+                .ui_testing(sopts.debugging_opts.ui_testing),\n+        ),\n+        (config::ErrorOutputType::Json(pretty), None) => Box::new(\n+            JsonEmitter::stderr(\n+                Some(registry),\n+                source_map.clone(),\n+                pretty,\n+            ).ui_testing(sopts.debugging_opts.ui_testing),\n+        ),\n+        (config::ErrorOutputType::Json(pretty), Some(dst)) => Box::new(\n+            JsonEmitter::new(\n+                dst,\n+                Some(registry),\n+                source_map.clone(),\n+                pretty,\n+            ).ui_testing(sopts.debugging_opts.ui_testing),\n+        ),\n+        (config::ErrorOutputType::Short(color_config), None) => Box::new(\n+            EmitterWriter::stderr(color_config, Some(source_map.clone()), true, false),\n+        ),\n+        (config::ErrorOutputType::Short(_), Some(dst)) => {\n+            Box::new(EmitterWriter::new(dst, Some(source_map.clone()), true, false))\n+        }\n+    }\n+}\n+\n+pub enum DiagnosticOutput {\n+    Default,\n+    Raw(Box<dyn Write + Send>),\n+    Emitter(Box<dyn Emitter + Send + sync::Send>)\n+}\n+\n pub fn build_session_with_source_map(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     registry: errors::registry::Registry,\n     source_map: Lrc<source_map::SourceMap>,\n-    emitter_dest: Option<Box<dyn Write + Send>>,\n+    diagnostics_output: DiagnosticOutput,\n+    lint_caps: FxHashMap<lint::LintId, lint::Level>,\n ) -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n     // normal diagnostic warnings, since the warning lint can also be denied and changed\n@@ -1054,42 +1101,13 @@ pub fn build_session_with_source_map(\n \n     let external_macro_backtrace = sopts.debugging_opts.external_macro_backtrace;\n \n-    let emitter: Box<dyn Emitter + sync::Send> =\n-        match (sopts.error_format, emitter_dest) {\n-            (config::ErrorOutputType::HumanReadable(color_config), None) => Box::new(\n-                EmitterWriter::stderr(\n-                    color_config,\n-                    Some(source_map.clone()),\n-                    false,\n-                    sopts.debugging_opts.teach,\n-                ).ui_testing(sopts.debugging_opts.ui_testing),\n-            ),\n-            (config::ErrorOutputType::HumanReadable(_), Some(dst)) => Box::new(\n-                EmitterWriter::new(dst, Some(source_map.clone()), false, false)\n-                    .ui_testing(sopts.debugging_opts.ui_testing),\n-            ),\n-            (config::ErrorOutputType::Json(pretty), None) => Box::new(\n-                JsonEmitter::stderr(\n-                    Some(registry),\n-                    source_map.clone(),\n-                    pretty,\n-                ).ui_testing(sopts.debugging_opts.ui_testing),\n-            ),\n-            (config::ErrorOutputType::Json(pretty), Some(dst)) => Box::new(\n-                JsonEmitter::new(\n-                    dst,\n-                    Some(registry),\n-                    source_map.clone(),\n-                    pretty,\n-                ).ui_testing(sopts.debugging_opts.ui_testing),\n-            ),\n-            (config::ErrorOutputType::Short(color_config), None) => Box::new(\n-                EmitterWriter::stderr(color_config, Some(source_map.clone()), true, false),\n-            ),\n-            (config::ErrorOutputType::Short(_), Some(dst)) => {\n-                Box::new(EmitterWriter::new(dst, Some(source_map.clone()), true, false))\n-            }\n-        };\n+    let emitter = match diagnostics_output {\n+        DiagnosticOutput::Default => default_emitter(&sopts, registry, &source_map, None),\n+        DiagnosticOutput::Raw(write) => {\n+            default_emitter(&sopts, registry, &source_map, Some(write))\n+        }\n+        DiagnosticOutput::Emitter(emitter) => emitter,\n+    };\n \n     let diagnostic_handler = errors::Handler::with_emitter_and_flags(\n         emitter,\n@@ -1103,15 +1121,20 @@ pub fn build_session_with_source_map(\n         },\n     );\n \n-    build_session_(sopts, local_crate_source_file, diagnostic_handler, source_map)\n+    build_session_(sopts, local_crate_source_file, diagnostic_handler, source_map, lint_caps)\n }\n \n-pub fn build_session_(\n+fn build_session_(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     span_diagnostic: errors::Handler,\n     source_map: Lrc<source_map::SourceMap>,\n+    driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n ) -> Session {\n+    let self_profiler =\n+        if sopts.debugging_opts.self_profile { Some(Arc::new(PlMutex::new(SelfProfiler::new()))) }\n+        else { None };\n+\n     let host_triple = TargetTriple::from_triple(config::host_triple());\n     let host = Target::search(&host_triple).unwrap_or_else(|e|\n         span_diagnostic\n@@ -1161,9 +1184,6 @@ pub fn build_session_(\n         CguReuseTracker::new_disabled()\n     };\n \n-    let self_profiling_active = sopts.debugging_opts.self_profile ||\n-                                sopts.debugging_opts.profile_json;\n-\n     let sess = Session {\n         target: target_cfg,\n         host,\n@@ -1192,8 +1212,7 @@ pub fn build_session_(\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,\n-        self_profiling_active,\n-        self_profiling: Lock::new(SelfProfiler::new()),\n+        self_profiling: self_profiler,\n         profile_channel: Lock::new(None),\n         perf_stats: PerfStats {\n             symbol_hash_time: Lock::new(Duration::from_secs(0)),\n@@ -1207,35 +1226,10 @@ pub fn build_session_(\n         optimization_fuel,\n         print_fuel_crate,\n         print_fuel,\n-        // Note that this is unsafe because it may misinterpret file descriptors\n-        // on Unix as jobserver file descriptors. We hopefully execute this near\n-        // the beginning of the process though to ensure we don't get false\n-        // positives, or in other words we try to execute this before we open\n-        // any file descriptors ourselves.\n-        //\n-        // Pick a \"reasonable maximum\" if we don't otherwise have\n-        // a jobserver in our environment, capping out at 32 so we\n-        // don't take everything down by hogging the process run queue.\n-        // The fixed number is used to have deterministic compilation\n-        // across machines.\n-        //\n-        // Also note that we stick this in a global because there could be\n-        // multiple `Session` instances in this process, and the jobserver is\n-        // per-process.\n-        jobserver: unsafe {\n-            static mut GLOBAL_JOBSERVER: *mut Client = 0 as *mut _;\n-            static INIT: std::sync::Once = std::sync::ONCE_INIT;\n-            INIT.call_once(|| {\n-                let client = Client::from_env().unwrap_or_else(|| {\n-                    Client::new(32).expect(\"failed to create jobserver\")\n-                });\n-                GLOBAL_JOBSERVER = Box::into_raw(Box::new(client));\n-            });\n-            (*GLOBAL_JOBSERVER).clone()\n-        },\n+        jobserver: jobserver::client(),\n         has_global_allocator: Once::new(),\n         has_panic_handler: Once::new(),\n-        driver_lint_caps: Default::default(),\n+        driver_lint_caps,\n     };\n \n     validate_commandline_args_with_session_available(&sess);\n@@ -1321,7 +1315,7 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n             Box::new(EmitterWriter::stderr(color_config, None, true, false))\n         }\n     };\n-    let handler = errors::Handler::with_emitter(true, false, emitter);\n+    let handler = errors::Handler::with_emitter(true, None, emitter);\n     handler.emit(&MultiSpan::new(), msg, errors::Level::Fatal);\n     errors::FatalError.raise();\n }\n@@ -1336,26 +1330,16 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n             Box::new(EmitterWriter::stderr(color_config, None, true, false))\n         }\n     };\n-    let handler = errors::Handler::with_emitter(true, false, emitter);\n+    let handler = errors::Handler::with_emitter(true, None, emitter);\n     handler.emit(&MultiSpan::new(), msg, errors::Level::Warning);\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum CompileIncomplete {\n-    Stopped,\n-    Errored(ErrorReported),\n-}\n-impl From<ErrorReported> for CompileIncomplete {\n-    fn from(err: ErrorReported) -> CompileIncomplete {\n-        CompileIncomplete::Errored(err)\n-    }\n-}\n-pub type CompileResult = Result<(), CompileIncomplete>;\n+pub type CompileResult = Result<(), ErrorReported>;\n \n pub fn compile_result_from_err_count(err_count: usize) -> CompileResult {\n     if err_count == 0 {\n         Ok(())\n     } else {\n-        Err(CompileIncomplete::Errored(ErrorReported))\n+        Err(ErrorReported)\n     }\n }"}, {"sha": "1b6a1739b0248ddaac32b58cf6675006708dee2b", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,4 +1,5 @@\n use std::path::{Path, PathBuf};\n+use rustc_macros::HashStable;\n use crate::session::{early_error, config};\n use crate::session::filesearch::make_target_lib_path;\n \n@@ -9,7 +10,7 @@ pub struct SearchPath {\n     pub files: Vec<PathBuf>,\n }\n \n-#[derive(Eq, PartialEq, Clone, Copy, Debug, PartialOrd, Ord, Hash)]\n+#[derive(Eq, PartialEq, Clone, Copy, Debug, PartialOrd, Ord, Hash, HashStable)]\n pub enum PathKind {\n     Native,\n     Crate,"}, {"sha": "e93351197fe4702c269de8bb3b21fdac02554dc7", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -631,7 +631,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         finished_map\n     }\n \n-    fn is_param_no_infer(&self, substs: &Substs<'_>) -> bool {\n+    fn is_param_no_infer(&self, substs: SubstsRef<'_>) -> bool {\n         return self.is_of_param(substs.type_at(0)) &&\n             !substs.types().any(|t| t.has_infer_types());\n     }"}, {"sha": "9b0a3820c859ce2fe7d13d928a91b4e0cae7af41", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -11,7 +11,7 @@ use syntax_pos::Span;\n use crate::traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext,\n              TraitEngine, Vtable};\n use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::subst::{Subst, Substs};\n+use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::fold::TypeFoldable;\n \n /// Attempts to resolve an obligation to a vtable. The result is\n@@ -82,7 +82,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// types.\n     pub fn subst_and_normalize_erasing_regions<T>(\n         self,\n-        param_substs: &Substs<'tcx>,\n+        param_substs: SubstsRef<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T\n     ) -> T"}, {"sha": "c7674ae7a28a248fc614ec3a885a2bda33d46212", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 56, "deletions": 16, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -389,7 +389,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         for param in generics.params.iter() {\n             let value = match param.kind {\n-                GenericParamDefKind::Type {..} => {\n+                GenericParamDefKind::Type { .. } |\n+                GenericParamDefKind::Const => {\n                     trait_ref.substs[param.index as usize].to_string()\n                 },\n                 GenericParamDefKind::Lifetime => continue,\n@@ -598,11 +599,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn report_selection_error(&self,\n-                                  obligation: &PredicateObligation<'tcx>,\n-                                  error: &SelectionError<'tcx>,\n-                                  fallback_has_occurred: bool)\n-    {\n+    pub fn report_selection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &SelectionError<'tcx>,\n+        fallback_has_occurred: bool,\n+    ) {\n         let span = obligation.cause.span;\n \n         let mut err = match *error {\n@@ -672,6 +674,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n                         self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n+                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n \n                         // Try to report a help message\n                         if !trait_ref.has_infer_types() &&\n@@ -760,7 +763,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n                         let closure_span = self.tcx.sess.source_map()\n                             .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n-                        let node_id = self.tcx.hir().as_local_node_id(closure_def_id).unwrap();\n+                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n                             self.tcx.sess, closure_span, E0525,\n                             \"expected a closure that implements the `{}` trait, \\\n@@ -779,8 +782,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         // a particular trait.\n                         if let Some(tables) = self.in_progress_tables {\n                             let tables = tables.borrow();\n-                            let closure_hir_id = self.tcx.hir().node_to_hir_id(node_id);\n-                            match (found_kind, tables.closure_kind_origins().get(closure_hir_id)) {\n+                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n                                 (ty::ClosureKind::FnOnce, Some((span, name))) => {\n                                     err.span_label(*span, format!(\n                                         \"closure is `FnOnce` because it moves the \\\n@@ -900,9 +902,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n     /// suggestion to borrow the initializer in order to use have a slice instead.\n-    fn suggest_borrow_on_unsized_slice(&self,\n-                                       code: &ObligationCauseCode<'tcx>,\n-                                       err: &mut DiagnosticBuilder<'tcx>) {\n+    fn suggest_borrow_on_unsized_slice(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+    ) {\n         if let &ObligationCauseCode::VariableType(node_id) = code {\n             let parent_node = self.tcx.hir().get_parent_node(node_id);\n             if let Some(Node::Local(ref local)) = self.tcx.hir().find(parent_node) {\n@@ -924,10 +928,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n     /// suggest removing these references until we reach a type that implements the trait.\n-    fn suggest_remove_reference(&self,\n-                                obligation: &PredicateObligation<'tcx>,\n-                                err: &mut DiagnosticBuilder<'tcx>,\n-                                trait_ref: &ty::Binder<ty::TraitRef<'tcx>>) {\n+    fn suggest_remove_reference(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n         let trait_ref = trait_ref.skip_binder();\n         let span = obligation.cause.span;\n \n@@ -969,6 +975,40 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn suggest_semicolon_removal(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(\n+            hir.hir_to_node_id(obligation.cause.body_id),\n+        );\n+        let node = hir.find(parent_node);\n+        if let Some(hir::Node::Item(hir::Item {\n+            node: hir::ItemKind::Fn(decl, _, _, body_id),\n+            ..\n+        })) = node {\n+            let body = hir.body(*body_id);\n+            if let hir::ExprKind::Block(blk, _) = &body.value.node {\n+                if decl.output.span().overlaps(span) && blk.expr.is_none() &&\n+                    \"()\" == &trait_ref.self_ty().to_string()\n+                {\n+                    // FIXME(estebank): When encountering a method with a trait\n+                    // bound not satisfied in the return type with a body that has\n+                    // no return, suggest removal of semicolon on last statement.\n+                    // Once that is added, close #54771.\n+                    if let Some(ref stmt) = blk.stmts.last() {\n+                        let sp = self.tcx.sess.source_map().end_point(stmt.span);\n+                        err.span_label(sp, \"consider removing this semicolon\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /// Given some node representing a fn-like thing in the HIR map,\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to"}, {"sha": "8c684c0775ee367cc4b9849410006eb9cbea5d59", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -275,6 +275,8 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                 self.selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n         }\n \n+        debug!(\"process_obligation: obligation = {:?}\", obligation);\n+\n         match obligation.predicate {\n             ty::Predicate::Trait(ref data) => {\n                 let trait_obligation = obligation.with(data.clone());"}, {"sha": "df127b934b0b11723f2de8ce6c4f8263cab2c930", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -27,9 +27,10 @@ use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::middle::region;\n use crate::mir::interpret::ErrorHandled;\n use rustc_data_structures::sync::Lrc;\n+use rustc_macros::HashStable;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::{InternalSubsts, SubstsRef};\n use crate::ty::{self, AdtKind, List, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n@@ -257,10 +258,10 @@ pub enum ObligationCauseCode<'tcx> {\n     ReturnNoExpression,\n \n     /// `return` with an expression\n-    ReturnType(ast::NodeId),\n+    ReturnType(hir::HirId),\n \n     /// Block implicit return\n-    BlockTailExpression(ast::NodeId),\n+    BlockTailExpression(hir::HirId),\n \n     /// #[feature(trivial_bounds)] is not enabled\n     TrivialBound,\n@@ -294,27 +295,27 @@ pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n /// are used for representing the trait system in the form of\n /// logic programming clauses. They are part of the interface\n /// for the chalk SLG solver.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum WhereClause<'tcx> {\n     Implemented(ty::TraitPredicate<'tcx>),\n     ProjectionEq(ty::ProjectionPredicate<'tcx>),\n     RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n     TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum WellFormed<'tcx> {\n     Trait(ty::TraitPredicate<'tcx>),\n     Ty(Ty<'tcx>),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum FromEnv<'tcx> {\n     Trait(ty::TraitPredicate<'tcx>),\n     Ty(Ty<'tcx>),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum DomainGoal<'tcx> {\n     Holds(WhereClause<'tcx>),\n     WellFormed(WellFormed<'tcx>),\n@@ -324,13 +325,13 @@ pub enum DomainGoal<'tcx> {\n \n pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum QuantifierKind {\n     Universal,\n     Existential,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum GoalKind<'tcx> {\n     Implies(Clauses<'tcx>, Goal<'tcx>),\n     And(Goal<'tcx>, Goal<'tcx>),\n@@ -376,7 +377,7 @@ impl<'tcx> GoalKind<'tcx> {\n \n /// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n /// Harrop Formulas\".\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum Clause<'tcx> {\n     Implies(ProgramClause<'tcx>),\n     ForAll(ty::Binder<ProgramClause<'tcx>>),\n@@ -400,7 +401,7 @@ pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n /// it with the reverse implication operator `:-` to emphasize the way\n /// that programs are actually solved (via backchaining, which starts\n /// with the goal to solve and proceeds from there).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub struct ProgramClause<'tcx> {\n     /// This goal will be considered true ...\n     pub goal: DomainGoal<'tcx>,\n@@ -412,15 +413,15 @@ pub struct ProgramClause<'tcx> {\n     pub category: ProgramClauseCategory,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum ProgramClauseCategory {\n     ImpliedBound,\n     WellFormed,\n     Other,\n }\n \n /// A set of clauses that we assume to be true.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub struct Environment<'tcx> {\n     pub clauses: Clauses<'tcx>,\n }\n@@ -435,7 +436,7 @@ impl Environment<'tcx> {\n }\n \n /// Something (usually a goal), along with an environment.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub struct InEnvironment<'tcx, G> {\n     pub environment: Environment<'tcx>,\n     pub goal: G,\n@@ -514,7 +515,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `VtableImplData`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n@@ -562,14 +563,14 @@ pub enum Vtable<'tcx, N> {\n /// is `Obligation`, as one might expect. During codegen, however, this\n /// is `()`, because codegen only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableImplData<'tcx, N> {\n     pub impl_def_id: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableGeneratorData<'tcx, N> {\n     pub generator_def_id: DefId,\n     pub substs: ty::GeneratorSubsts<'tcx>,\n@@ -578,7 +579,7 @@ pub struct VtableGeneratorData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n     pub substs: ty::ClosureSubsts<'tcx>,\n@@ -587,20 +588,20 @@ pub struct VtableClosureData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableBuiltinData<N> {\n     pub nested: Vec<N>\n }\n \n /// A vtable for some object-safe trait `Foo` automatically derived\n /// for the object type `Foo`.\n-#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableObjectData<'tcx, N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -613,16 +614,16 @@ pub struct VtableObjectData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableFnPointerData<'tcx, N> {\n     pub fn_ty: Ty<'tcx>,\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableTraitAliasData<'tcx, N> {\n     pub alias_def_id: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>,\n }\n \n@@ -963,7 +964,7 @@ fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                      key: (DefId, &'tcx Substs<'tcx>))\n+                                                      key: (DefId, SubstsRef<'tcx>))\n                                                       -> bool\n {\n     debug!(\"substitute_normalize_and_test_predicates(key={:?})\",\n@@ -983,7 +984,7 @@ fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n fn vtable_methods<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> Lrc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>\n+    -> Lrc<Vec<Option<(DefId, SubstsRef<'tcx>)>>>\n {\n     debug!(\"vtable_methods({:?})\", trait_ref);\n \n@@ -992,7 +993,7 @@ fn vtable_methods<'a, 'tcx>(\n             let trait_methods = tcx.associated_items(trait_ref.def_id())\n                 .filter(|item| item.kind == ty::AssociatedKind::Method);\n \n-            // Now list each method's DefId and Substs (for within its trait).\n+            // Now list each method's DefId and InternalSubsts (for within its trait).\n             // If the method can never be called from this object, produce None.\n             trait_methods.map(move |trait_method| {\n                 debug!(\"vtable_methods: trait_method={:?}\", trait_method);\n@@ -1007,10 +1008,11 @@ fn vtable_methods<'a, 'tcx>(\n                 // the method may have some early-bound lifetimes, add\n                 // regions for those\n                 let substs = trait_ref.map_bound(|trait_ref|\n-                    Substs::for_item(tcx, def_id, |param, _|\n+                    InternalSubsts::for_item(tcx, def_id, |param, _|\n                         match param.kind {\n                             GenericParamDefKind::Lifetime => tcx.types.re_erased.into(),\n-                            GenericParamDefKind::Type {..} => {\n+                            GenericParamDefKind::Type { .. } |\n+                            GenericParamDefKind::Const => {\n                                 trait_ref.substs[param.index as usize]\n                             }\n                         }"}, {"sha": "e7a5138e6893c5384875dd00dfb263e40a528c06", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -10,11 +10,12 @@\n \n use super::elaborate_predicates;\n \n+use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::lint;\n use crate::traits::{self, Obligation, ObligationCause};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable, Predicate, ToPredicate};\n-use crate::ty::subst::{Subst, Substs};\n+use crate::ty::subst::{Subst, InternalSubsts};\n use std::borrow::Cow;\n use std::iter::{self};\n use syntax::ast::{self, Name};\n@@ -129,7 +130,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                     // It's also hard to get a use site span, so we use the method definition span.\n                     self.lint_node_note(\n                         lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY,\n-                        ast::CRATE_NODE_ID,\n+                        hir::CRATE_HIR_ID,\n                         *span,\n                         &format!(\"the trait `{}` cannot be made into an object\",\n                                  self.item_path_str(trait_def_id)),\n@@ -309,7 +310,8 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if self.generics_of(method.def_id).own_counts().types != 0 {\n+        let own_counts = self.generics_of(method.def_id).own_counts();\n+        if own_counts.types + own_counts.consts != 0 {\n             return Some(MethodViolationCode::Generic);\n         }\n \n@@ -405,7 +407,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n     ) -> Ty<'tcx> {\n         debug!(\"receiver_for_self_ty({:?}, {:?}, {:?})\", receiver_ty, self_ty, method_def_id);\n-        let substs = Substs::for_item(self, method_def_id, |param, _| {\n+        let substs = InternalSubsts::for_item(self, method_def_id, |param, _| {\n             if param.index == 0 {\n                 self_ty.into()\n             } else {\n@@ -558,13 +560,17 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n             // U: Trait<Arg1, ..., ArgN>\n             let trait_predicate = {\n-                let substs = Substs::for_item(self, method.container.assert_trait(), |param, _| {\n-                    if param.index == 0 {\n-                        unsized_self_ty.into()\n-                    } else {\n-                        self.mk_param_from_def(param)\n-                    }\n-                });\n+                let substs = InternalSubsts::for_item(\n+                    self,\n+                    method.container.assert_trait(),\n+                    |param, _| {\n+                        if param.index == 0 {\n+                            unsized_self_ty.into()\n+                        } else {\n+                            self.mk_param_from_def(param)\n+                        }\n+                    },\n+                );\n \n                 ty::TraitRef {\n                     def_id: unsize_did,"}, {"sha": "c86fd0d52b901ce62fe3fb64dea452b8f73cb001", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -280,7 +280,8 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         let generics = tcx.generics_of(trait_ref.def_id);\n         let generic_map = generics.params.iter().filter_map(|param| {\n             let value = match param.kind {\n-                GenericParamDefKind::Type {..} => {\n+                GenericParamDefKind::Type { .. } |\n+                GenericParamDefKind::Const => {\n                     trait_ref.substs[param.index as usize].to_string()\n                 },\n                 GenericParamDefKind::Lifetime => return None"}, {"sha": "197bea1c3118998247d01369866e500ba97ab21d", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -17,15 +17,16 @@ use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::infer::type_variable::TypeVariableOrigin;\n use crate::mir::interpret::{GlobalId};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n+use rustc_macros::HashStable;\n use syntax::ast::Ident;\n-use crate::ty::subst::{Subst, Substs};\n+use crate::ty::subst::{Subst, InternalSubsts};\n use crate::ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::util::common::FN_OUTPUT_NAME;\n \n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n pub enum Reveal {\n     /// At type-checking time, we refuse to project any associated\n     /// type that is marked `default`. Non-`default` (\"final\") types\n@@ -401,7 +402,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n             let tcx = self.selcx.tcx().global_tcx();\n             if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n                 if substs.needs_infer() || substs.has_placeholders() {\n-                    let identity_substs = Substs::identity_for_item(tcx, def_id);\n+                    let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n                     if let Some(instance) = instance {\n                         let cid = GlobalId {\n@@ -1490,7 +1491,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     }\n     let substs = translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.node);\n     let ty = if let ty::AssociatedKind::Existential = assoc_ty.item.kind {\n-        let item_substs = Substs::identity_for_item(tcx, assoc_ty.item.def_id);\n+        let item_substs = InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n         tcx.mk_opaque(assoc_ty.item.def_id, item_substs)\n     } else {\n         tcx.type_of(assoc_ty.item.def_id)"}, {"sha": "8a30c18d6e5f7fc565b638e93973acdc4ae829c2", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -9,7 +9,7 @@ use crate::mir::interpret::GlobalId;\n use crate::traits::project::Normalized;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::ty::subst::{Subst, Substs};\n+use crate::ty::subst::{Subst, InternalSubsts};\n use crate::ty::{self, Ty, TyCtxt};\n \n use super::NoSolution;\n@@ -193,7 +193,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n             let tcx = self.infcx.tcx.global_tcx();\n             if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n                 if substs.needs_infer() || substs.has_placeholders() {\n-                    let identity_substs = Substs::identity_for_item(tcx, def_id);\n+                    let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n                     if let Some(instance) = instance {\n                         let cid = GlobalId {"}, {"sha": "e7cc9618080c2689f0196b84364dfcc4126612ec", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -34,7 +34,7 @@ use crate::middle::lang_items;\n use crate::mir::interpret::GlobalId;\n use crate::ty::fast_reject;\n use crate::ty::relate::TypeRelation;\n-use crate::ty::subst::{Subst, Substs};\n+use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n use crate::hir;\n@@ -1944,7 +1944,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 if let ty::FnSig {\n                     unsafety: hir::Unsafety::Normal,\n                     abi: Abi::Rust,\n-                    variadic: false,\n+                    c_variadic: false,\n                     ..\n                 } = self_ty.fn_sig(self.tcx()).skip_binder()\n                 {\n@@ -2944,7 +2944,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn vtable_impl(\n         &mut self,\n         impl_def_id: DefId,\n-        mut substs: Normalized<'tcx, &'tcx Substs<'tcx>>,\n+        mut substs: Normalized<'tcx, SubstsRef<'tcx>>,\n         cause: ObligationCause<'tcx>,\n         recursion_depth: usize,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -3538,7 +3538,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         impl_def_id: DefId,\n         obligation: &TraitObligation<'tcx>,\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n-    ) -> Normalized<'tcx, &'tcx Substs<'tcx>> {\n+    ) -> Normalized<'tcx, SubstsRef<'tcx>> {\n         match self.match_impl(impl_def_id, obligation, snapshot) {\n             Ok(substs) => substs,\n             Err(()) => {\n@@ -3556,7 +3556,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         impl_def_id: DefId,\n         obligation: &TraitObligation<'tcx>,\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n-    ) -> Result<Normalized<'tcx, &'tcx Substs<'tcx>>, ()> {\n+    ) -> Result<Normalized<'tcx, SubstsRef<'tcx>>, ()> {\n         let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n \n         // Before we create the substitutions and everything, first\n@@ -3761,7 +3761,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         recursion_depth: usize,\n         param_env: ty::ParamEnv<'tcx>,\n         def_id: DefId,         // of impl or trait\n-        substs: &Substs<'tcx>, // for impl or trait\n+        substs: SubstsRef<'tcx>,  // for impl or trait\n     ) -> Vec<PredicateObligation<'tcx>> {\n         debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);\n         let tcx = self.tcx();"}, {"sha": "a2924cb993fbf6f2039b5eeeb1e07663c3ea5a8b", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -20,7 +20,7 @@ use rustc_data_structures::sync::Lrc;\n use syntax_pos::DUMMY_SP;\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::ty::{self, TyCtxt, TypeFoldable};\n-use crate::ty::subst::{Subst, Substs};\n+use crate::ty::subst::{Subst, InternalSubsts, SubstsRef};\n \n use super::{SelectionContext, FulfillmentContext};\n use super::util::impl_trait_ref_and_oblig;\n@@ -73,9 +73,9 @@ pub struct OverlapError {\n pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                         param_env: ty::ParamEnv<'tcx>,\n                                         source_impl: DefId,\n-                                        source_substs: &'tcx Substs<'tcx>,\n+                                        source_substs: SubstsRef<'tcx>,\n                                         target_node: specialization_graph::Node)\n-                                        -> &'tcx Substs<'tcx> {\n+                                        -> SubstsRef<'tcx> {\n     debug!(\"translate_substs({:?}, {:?}, {:?}, {:?})\",\n            param_env, source_impl, source_substs, target_node);\n     let source_trait_ref = infcx.tcx\n@@ -114,9 +114,9 @@ pub fn find_associated_item<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     item: &ty::AssociatedItem,\n-    substs: &'tcx Substs<'tcx>,\n+    substs: SubstsRef<'tcx>,\n     impl_data: &super::VtableImplData<'tcx, ()>,\n-) -> (DefId, &'tcx Substs<'tcx>) {\n+) -> (DefId, SubstsRef<'tcx>) {\n     debug!(\"find_associated_item({:?}, {:?}, {:?}, {:?})\",\n            param_env, item, substs, impl_data);\n     assert!(!substs.needs_infer());\n@@ -214,7 +214,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        param_env: ty::ParamEnv<'tcx>,\n                                        source_trait_ref: ty::TraitRef<'tcx>,\n                                        target_impl: DefId)\n-                                       -> Result<&'tcx Substs<'tcx>, ()> {\n+                                       -> Result<SubstsRef<'tcx>, ()> {\n     debug!(\"fulfill_implication({:?}, trait_ref={:?} |- {:?} applies)\",\n            param_env, source_trait_ref, target_impl);\n \n@@ -334,9 +334,9 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(\n                         FutureCompatOverlapErrorKind::Issue33140 =>\n                             lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS,\n                     };\n-                    tcx.struct_span_lint_node(\n+                    tcx.struct_span_lint_hir(\n                         lint,\n-                        tcx.hir().as_local_node_id(impl_def_id).unwrap(),\n+                        tcx.hir().as_local_hir_id(impl_def_id).unwrap(),\n                         impl_span,\n                         &msg)\n                 } else {\n@@ -399,7 +399,7 @@ fn to_pretty_impl_header(tcx: TyCtxt<'_, '_, '_>, impl_def_id: DefId) -> Option<\n \n     let mut w = \"impl\".to_owned();\n \n-    let substs = Substs::identity_for_item(tcx, impl_def_id);\n+    let substs = InternalSubsts::identity_for_item(tcx, impl_def_id);\n \n     // FIXME: Currently only handles ?Sized.\n     //        Needs to support ?Move and ?DynSized when they are implemented."}, {"sha": "c3223f0cd6331d9c8c1088b9b51d58384294a033", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -3,7 +3,7 @@ use crate::hir::def_id::DefId;\n use crate::traits::specialize::specialization_graph::NodeItem;\n use crate::ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n use crate::ty::outlives::Component;\n-use crate::ty::subst::{Kind, Subst, Substs};\n+use crate::ty::subst::{Kind, Subst, SubstsRef};\n use crate::util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n@@ -358,7 +358,7 @@ impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<\n pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n                                                 param_env: ty::ParamEnv<'tcx>,\n                                                 impl_def_id: DefId,\n-                                                impl_substs: &Substs<'tcx>)\n+                                                impl_substs: SubstsRef<'tcx>,)\n                                                 -> (ty::TraitRef<'tcx>,\n                                                     Vec<PredicateObligation<'tcx>>)\n {"}, {"sha": "f9149ce0f6e6b2a43e0b84e124834754d45a23ff", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,7 +1,8 @@\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::SubstsRef;\n+use rustc_macros::HashStable;\n \n \n /// Represents coercing a value to a different type of value.\n@@ -44,13 +45,13 @@ use crate::ty::subst::Substs;\n ///    At some point, of course, `Box` should move out of the compiler, in which\n ///    case this is analogous to transforming a struct. E.g., Box<[i32; 4]> ->\n ///    Box<[i32]> is an `Adjust::Unsize` with the target `Box<[i32]>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Adjustment<'tcx> {\n     pub kind: Adjust<'tcx>,\n     pub target: Ty<'tcx>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Adjust<'tcx> {\n     /// Go from ! to any type.\n     NeverToAny,\n@@ -90,15 +91,15 @@ pub enum Adjust<'tcx> {\n /// call, with the signature `&'a T -> &'a U` or `&'a mut T -> &'a mut U`.\n /// The target type is `U` in both cases, with the region and mutability\n /// being those shared by both the receiver and the returned reference.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct OverloadedDeref<'tcx> {\n     pub region: ty::Region<'tcx>,\n     pub mutbl: hir::Mutability,\n }\n \n impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n     pub fn method_call(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, source: Ty<'tcx>)\n-                       -> (DefId, &'tcx Substs<'tcx>) {\n+                       -> (DefId, SubstsRef<'tcx>) {\n         let trait_def_id = match self.mutbl {\n             hir::MutImmutable => tcx.lang_items().deref_trait(),\n             hir::MutMutable => tcx.lang_items().deref_mut_trait()\n@@ -121,13 +122,13 @@ impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n /// new code via two-phase borrows, so we try to limit where we create two-phase\n /// capable mutable borrows.\n /// See #49434 for tracking.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AllowTwoPhase {\n     Yes,\n     No\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AutoBorrowMutability {\n     Mutable { allow_two_phase_borrow: AllowTwoPhase },\n     Immutable,\n@@ -142,7 +143,7 @@ impl From<AutoBorrowMutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AutoBorrow<'tcx> {\n     /// Converts from T to &T.\n     Ref(ty::Region<'tcx>, AutoBorrowMutability),\n@@ -157,7 +158,7 @@ pub enum AutoBorrow<'tcx> {\n /// This struct can be obtained via the `coerce_impl_info` query.\n /// Demanding this struct also has the side-effect of reporting errors\n /// for inappropriate impls.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct CoerceUnsizedInfo {\n     /// If this is a \"custom coerce\" impl, then what kind of custom\n     /// coercion is it? This applies to impls of `CoerceUnsized` for\n@@ -166,7 +167,7 @@ pub struct CoerceUnsizedInfo {\n     pub custom_kind: Option<CustomCoerceUnsized>\n }\n \n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum CustomCoerceUnsized {\n     /// Records the index of the field being coerced.\n     Struct(usize)"}, {"sha": "7ea5c73c5b749b9803cf53617e6b2e27946286ec", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -4,6 +4,7 @@\n use crate::ty::{self, Ty};\n \n use syntax::ast;\n+use rustc_macros::HashStable;\n \n /// Types that are represented as ints.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -32,7 +33,7 @@ pub enum CastTy<'tcx> {\n }\n \n /// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum CastKind {\n     CoercionCast,\n     PtrPtrCast,"}, {"sha": "3ab744ebaeb17d0541961cb90bf347054428f2d0", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -13,7 +13,7 @@ use crate::rustc_serialize::{Decodable, Decoder, Encoder, Encodable, opaque};\n use std::hash::Hash;\n use std::intrinsics;\n use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::SubstsRef;\n use crate::mir::interpret::Allocation;\n \n /// The shorthand encoding uses an enum's variant index `usize`\n@@ -185,7 +185,7 @@ pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n }\n \n #[inline]\n-pub fn decode_substs<'a, 'tcx, D>(decoder: &mut D) -> Result<&'tcx Substs<'tcx>, D::Error>\n+pub fn decode_substs<'a, 'tcx, D>(decoder: &mut D) -> Result<SubstsRef<'tcx>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {\n@@ -281,7 +281,7 @@ macro_rules! implement_ty_decoder {\n             use $crate::infer::canonical::CanonicalVarInfos;\n             use $crate::ty;\n             use $crate::ty::codec::*;\n-            use $crate::ty::subst::Substs;\n+            use $crate::ty::subst::SubstsRef;\n             use $crate::hir::def_id::{CrateNum};\n             use crate::rustc_serialize::{Decoder, SpecializedDecoder};\n             use std::borrow::Cow;\n@@ -344,9 +344,9 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx Substs<'tcx>>\n+            impl<$($typaram),*> SpecializedDecoder<SubstsRef<'tcx>>\n             for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n+                fn specialized_decode(&mut self) -> Result<SubstsRef<'tcx>, Self::Error> {\n                     decode_substs(self)\n                 }\n             }"}, {"sha": "e33d0a74ea013ab99c408b322d2239d84a705c15", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -67,10 +67,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n     /// only checks whether the function has a `const` modifier\n     fn is_const_fn_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n-        let node_id = tcx.hir().as_local_node_id(def_id)\n-                             .expect(\"Non-local call to local provider is_const_fn\");\n+        let hir_id = tcx.hir().as_local_hir_id(def_id)\n+                              .expect(\"Non-local call to local provider is_const_fn\");\n \n-        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir().get(node_id)) {\n+        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)) {\n             fn_like.constness() == hir::Constness::Const\n         } else {\n             false"}, {"sha": "5e4274fa1c8e5b66a302b2c3e9926146d78df791", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 188, "deletions": 177, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -21,8 +21,8 @@ use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n use crate::mir::{self, Mir, interpret, ProjectionKind};\n-use crate::mir::interpret::Allocation;\n-use crate::ty::subst::{Kind, Substs, Subst};\n+use crate::mir::interpret::{ConstValue, Allocation};\n+use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n use crate::traits;\n use crate::traits::{Clause, Clauses, GoalKind, Goal, Goals};\n@@ -31,16 +31,17 @@ use crate::ty::{TyS, TyKind, List};\n use crate::ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const, LazyConst};\n use crate::ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use crate::ty::RegionKind;\n-use crate::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n+use crate::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid, ConstVid};\n use crate::ty::TyKind::*;\n+use crate::ty::{InferConst, ParamConst};\n use crate::ty::GenericParamDefKind;\n use crate::ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n use crate::ty::query;\n use crate::ty::steal::Steal;\n use crate::ty::subst::{UserSubsts, UnpackedKind};\n use crate::ty::{BoundVar, BindingMode};\n use crate::ty::CanonicalPolyFnSig;\n-use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use errors::DiagnosticBuilder;\n use rustc_data_structures::interner::HashInterner;\n@@ -50,7 +51,7 @@ use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableVec};\n use arena::{TypedArena, SyncDroplessArena};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::sync::{self, Lrc, Lock, WorkerLocal};\n+use rustc_data_structures::sync::{Lrc, Lock, WorkerLocal};\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n@@ -59,13 +60,13 @@ use std::hash::{Hash, Hasher};\n use std::fmt;\n use std::mem;\n use std::ops::{Deref, Bound};\n-use std::ptr;\n use std::iter;\n use std::sync::mpsc;\n use std::sync::Arc;\n use std::marker::PhantomData;\n use rustc_target::spec::abi;\n-use syntax::ast::{self, NodeId};\n+use rustc_macros::HashStable;\n+use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n use syntax::edition::Edition;\n@@ -78,15 +79,13 @@ use crate::hir;\n pub struct AllArenas<'tcx> {\n     pub global: WorkerLocal<GlobalArenas<'tcx>>,\n     pub interner: SyncDroplessArena,\n-    global_ctxt: Option<GlobalCtxt<'tcx>>,\n }\n \n impl<'tcx> AllArenas<'tcx> {\n     pub fn new() -> Self {\n         AllArenas {\n             global: WorkerLocal::new(|_| GlobalArenas::default()),\n             interner: SyncDroplessArena::default(),\n-            global_ctxt: None,\n         }\n     }\n }\n@@ -118,7 +117,7 @@ pub struct CtxtInterners<'tcx> {\n     /// they're accessed quite often.\n     type_: InternedSet<'tcx, TyS<'tcx>>,\n     type_list: InternedSet<'tcx, List<Ty<'tcx>>>,\n-    substs: InternedSet<'tcx, Substs<'tcx>>,\n+    substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo>>,\n     region: InternedSet<'tcx, RegionKind>,\n     existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n@@ -171,7 +170,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n \n                 // Make sure we don't end up with inference\n                 // types/regions in the global interner\n-                if ptr::eq(local, global) {\n+                if ptr_eq(local, global) {\n                     bug!(\"Attempted to intern `{:?}` which contains \\\n                         inference types/regions in the global type context\",\n                         &ty_struct);\n@@ -318,14 +317,14 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n }\n \n /// All information necessary to validate and reveal an `impl Trait` or `existential Type`\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ResolvedOpaqueTy<'tcx> {\n     /// The revealed type as seen by this function.\n     pub concrete_type: Ty<'tcx>,\n     /// Generic parameters on the opaque type as passed by this function.\n     /// For `existential type Foo<A, B>; fn foo<T, U>() -> Foo<T, U> { .. }` this is `[T, U]`, not\n     /// `[A, B]`\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug)]\n@@ -352,7 +351,7 @@ pub struct TypeckTables<'tcx> {\n     /// of this node. This only applies to nodes that refer to entities\n     /// parameterized by type parameters, such as generic fns, types, or\n     /// other items.\n-    node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n+    node_substs: ItemLocalMap<SubstsRef<'tcx>>,\n \n     /// This will either store the canonicalized types provided by the user\n     /// or the substitutions that the user explicitly gave (if any) attached\n@@ -409,9 +408,9 @@ pub struct TypeckTables<'tcx> {\n     /// MIR construction and hence is not serialized to metadata.\n     fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n \n-    /// Maps a cast expression to its kind. This is keyed on the\n-    /// *from* expression of the cast, not the cast itself.\n-    cast_kinds: ItemLocalMap<ty::cast::CastKind>,\n+    /// For every coercion cast we add the HIR node ID of the cast\n+    /// expression to this set.\n+    coercion_casts: ItemLocalSet,\n \n     /// Set of trait imports actually used in the method resolution.\n     /// This is used for warning unused imports. During type\n@@ -456,7 +455,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             closure_kind_origins: Default::default(),\n             liberated_fn_sigs: Default::default(),\n             fru_field_types: Default::default(),\n-            cast_kinds: Default::default(),\n+            coercion_casts: Default::default(),\n             used_trait_imports: Lrc::new(Default::default()),\n             tainted_by_errors: false,\n             free_region_map: Default::default(),\n@@ -548,19 +547,19 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_types.get(&id.local_id).cloned()\n     }\n \n-    pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<'_, &'tcx Substs<'tcx>> {\n+    pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<'_, SubstsRef<'tcx>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n             data: &mut self.node_substs\n         }\n     }\n \n-    pub fn node_substs(&self, id: hir::HirId) -> &'tcx Substs<'tcx> {\n+    pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n         validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n-        self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| Substs::empty())\n+        self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n     }\n \n-    pub fn node_substs_opt(&self, id: hir::HirId) -> Option<&'tcx Substs<'tcx>> {\n+    pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n         validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n         self.node_substs.get(&id.local_id).cloned()\n     }\n@@ -718,19 +717,19 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n-    pub fn cast_kinds(&self) -> LocalTableInContext<'_, ty::cast::CastKind> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.cast_kinds\n-        }\n+    pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, hir_id, true);\n+        self.coercion_casts.contains(&hir_id.local_id)\n     }\n \n-    pub fn cast_kinds_mut(&mut self) -> LocalTableInContextMut<'_, ty::cast::CastKind> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.cast_kinds\n-        }\n+    pub fn set_coercion_cast(&mut self, id: ItemLocalId) {\n+        self.coercion_casts.insert(id);\n+    }\n+\n+    pub fn coercion_casts(&self) -> &ItemLocalSet {\n+        &self.coercion_casts\n     }\n+\n }\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n@@ -753,7 +752,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             ref liberated_fn_sigs,\n             ref fru_field_types,\n \n-            ref cast_kinds,\n+            ref coercion_casts,\n \n             ref used_trait_imports,\n             tainted_by_errors,\n@@ -798,7 +797,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             closure_kind_origins.hash_stable(hcx, hasher);\n             liberated_fn_sigs.hash_stable(hcx, hasher);\n             fru_field_types.hash_stable(hcx, hasher);\n-            cast_kinds.hash_stable(hcx, hasher);\n+            coercion_casts.hash_stable(hcx, hasher);\n             used_trait_imports.hash_stable(hcx, hasher);\n             tainted_by_errors.hash_stable(hcx, hasher);\n             free_region_map.hash_stable(hcx, hasher);\n@@ -810,6 +809,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n \n newtype_index! {\n     pub struct UserTypeAnnotationIndex {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"UserType({})\",\n         const START_INDEX = 0,\n     }\n@@ -819,7 +819,7 @@ newtype_index! {\n pub type CanonicalUserTypeAnnotations<'tcx> =\n     IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct CanonicalUserTypeAnnotation<'tcx> {\n     pub user_ty: CanonicalUserType<'tcx>,\n     pub span: Span,\n@@ -873,6 +873,18 @@ impl CanonicalUserType<'gcx> {\n                             }\n                             _ => false,\n                         },\n+\n+                        UnpackedKind::Const(ct) => match ct {\n+                            ty::LazyConst::Evaluated(ty::Const {\n+                                val: ConstValue::Infer(InferConst::Canonical(debruijn, b)),\n+                                ..\n+                            }) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(*debruijn, ty::INNERMOST);\n+                                cvar == *b\n+                            }\n+                            _ => false,\n+                        },\n                     }\n                 })\n             },\n@@ -883,7 +895,7 @@ impl CanonicalUserType<'gcx> {\n /// A user-given type annotation attached to a constant. These arise\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UserType<'tcx> {\n     Ty(Ty<'tcx>),\n \n@@ -1163,27 +1175,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns `true` if self is the same as self.global_tcx().\n     fn is_global(self) -> bool {\n-        ptr::eq(self.interners, &self.global_interners)\n+        ptr_eq(self.interners, &self.global_interners)\n     }\n \n     /// Creates a type context and call the closure with a `TyCtxt` reference\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n-    pub fn create_and_enter<F, R>(s: &'tcx Session,\n-                                  cstore: &'tcx CrateStoreDyn,\n-                                  local_providers: ty::query::Providers<'tcx>,\n-                                  extern_providers: ty::query::Providers<'tcx>,\n-                                  arenas: &'tcx mut AllArenas<'tcx>,\n-                                  resolutions: ty::Resolutions,\n-                                  hir: hir_map::Map<'tcx>,\n-                                  on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n-                                  crate_name: &str,\n-                                  tx: mpsc::Sender<Box<dyn Any + Send>>,\n-                                  output_filenames: &OutputFilenames,\n-                                  f: F) -> R\n-                                  where F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'tcx>) -> R\n-    {\n+    pub fn create_global_ctxt(\n+        s: &'tcx Session,\n+        cstore: &'tcx CrateStoreDyn,\n+        local_providers: ty::query::Providers<'tcx>,\n+        extern_providers: ty::query::Providers<'tcx>,\n+        arenas: &'tcx AllArenas<'tcx>,\n+        resolutions: ty::Resolutions,\n+        hir: hir_map::Map<'tcx>,\n+        on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n+        crate_name: &str,\n+        tx: mpsc::Sender<Box<dyn Any + Send>>,\n+        output_filenames: &OutputFilenames,\n+    ) -> GlobalCtxt<'tcx> {\n         let data_layout = TargetDataLayout::parse(&s.target.target).unwrap_or_else(|err| {\n             s.fatal(&err);\n         });\n@@ -1235,7 +1246,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                      Lrc::new(StableVec::new(v)));\n         }\n \n-        arenas.global_ctxt = Some(GlobalCtxt {\n+        GlobalCtxt {\n             sess: s,\n             cstore,\n             global_arenas: &arenas.global,\n@@ -1281,17 +1292,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n             tx_to_llvm_workers: Lock::new(tx),\n             output_filenames: Arc::new(output_filenames.clone()),\n-        });\n-\n-        let gcx = arenas.global_ctxt.as_ref().unwrap();\n-\n-        sync::assert_send_val(&gcx);\n-\n-        let r = tls::enter_global(gcx, f);\n-\n-        gcx.queries.record_computed_queries(s);\n-\n-        r\n+        }\n     }\n \n     pub fn consider_optimizing<T: Fn() -> String>(&self, msg: T) -> bool {\n@@ -1444,16 +1445,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // This method exercises the `in_scope_traits_map` query for all possible\n-    // values so that we have their fingerprints available in the DepGraph.\n-    // This is only required as long as we still use the old dependency tracking\n-    // which needs to have the fingerprints of all input nodes beforehand.\n-    pub fn precompute_in_scope_traits_hashes(self) {\n-        for &def_index in self.trait_map.keys() {\n-            self.in_scope_traits_map(def_index);\n-        }\n-    }\n-\n     pub fn serialize_query_result_cache<E>(self,\n                                            encoder: &mut E)\n                                            -> Result<(), E::Error>\n@@ -1609,10 +1600,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let node_id = self.hir()\n-            .as_local_node_id(suitable_region_binding_scope)\n+        let hir_id = self.hir()\n+            .as_local_hir_id(suitable_region_binding_scope)\n             .unwrap();\n-        let is_impl_item = match self.hir().find(node_id) {\n+        let is_impl_item = match self.hir().find_by_hir_id(hir_id) {\n             Some(Node::Item(..)) | Some(Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n@@ -1632,8 +1623,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         scope_def_id: DefId,\n     ) -> Option<Ty<'tcx>> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return None\n-        let node_id = self.hir().as_local_node_id(scope_def_id).unwrap();\n-        match self.hir().get(node_id) {\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id).unwrap();\n+        match self.hir().get_by_hir_id(hir_id) {\n             Node::Item(item) => {\n                 match item.node {\n                     ItemKind::Fn(..) => { /* type_of_def_id() will work */ }\n@@ -1733,7 +1724,7 @@ impl<'gcx> GlobalCtxt<'gcx> {\n /// A trait implemented for all X<'a> types which can be safely and\n /// efficiently converted to X<'tcx> as long as they are part of the\n /// provided TyCtxt<'tcx>.\n-/// This can be done, for example, for Ty<'tcx> or &'tcx Substs<'tcx>\n+/// This can be done, for example, for Ty<'tcx> or SubstsRef<'tcx>\n /// by looking them up in their respective interners.\n ///\n /// However, this is still not the best implementation as it does\n@@ -1807,7 +1798,7 @@ nop_list_lift!{Predicate<'a> => Predicate<'tcx>}\n nop_list_lift!{CanonicalVarInfo => CanonicalVarInfo}\n nop_list_lift!{ProjectionKind<'a> => ProjectionKind<'tcx>}\n \n-// this is the impl for `&'a Substs<'a>`\n+// this is the impl for `&'a InternalSubsts<'a>`\n nop_list_lift!{Kind<'a> => Kind<'tcx>}\n \n impl<'a, 'tcx> Lift<'tcx> for &'a mir::interpret::Allocation {\n@@ -1819,12 +1810,11 @@ impl<'a, 'tcx> Lift<'tcx> for &'a mir::interpret::Allocation {\n }\n \n pub mod tls {\n-    use super::{GlobalCtxt, TyCtxt};\n+    use super::{GlobalCtxt, TyCtxt, ptr_eq};\n \n     use std::fmt;\n     use std::mem;\n     use std::marker::PhantomData;\n-    use std::ptr;\n     use syntax_pos;\n     use crate::ty::query;\n     use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n@@ -1883,9 +1873,11 @@ pub mod tls {\n         rayon_core::tlv::get()\n     }\n \n-    /// A thread local variable which stores a pointer to the current ImplicitCtxt\n     #[cfg(not(parallel_compiler))]\n-    thread_local!(static TLV: Cell<usize> = Cell::new(0));\n+    thread_local! {\n+        /// A thread local variable which stores a pointer to the current ImplicitCtxt.\n+        static TLV: Cell<usize> = Cell::new(0);\n+    }\n \n     /// Sets TLV to `value` during the call to `f`.\n     /// It is restored to its previous value after.\n@@ -1974,38 +1966,37 @@ pub mod tls {\n     pub fn enter_global<'gcx, F, R>(gcx: &'gcx GlobalCtxt<'gcx>, f: F) -> R\n         where F: FnOnce(TyCtxt<'gcx, 'gcx, 'gcx>) -> R\n     {\n-        with_thread_locals(|| {\n-            // Update GCX_PTR to indicate there's a GlobalCtxt available\n-            GCX_PTR.with(|lock| {\n-                *lock.lock() = gcx as *const _ as usize;\n-            });\n-            // Set GCX_PTR back to 0 when we exit\n-            let _on_drop = OnDrop(move || {\n-                GCX_PTR.with(|lock| *lock.lock() = 0);\n-            });\n+        // Update GCX_PTR to indicate there's a GlobalCtxt available\n+        GCX_PTR.with(|lock| {\n+            *lock.lock() = gcx as *const _ as usize;\n+        });\n+        // Set GCX_PTR back to 0 when we exit\n+        let _on_drop = OnDrop(move || {\n+            GCX_PTR.with(|lock| *lock.lock() = 0);\n+        });\n \n-            let tcx = TyCtxt {\n-                gcx,\n-                interners: &gcx.global_interners,\n-                dummy: PhantomData,\n-            };\n-            let icx = ImplicitCtxt {\n-                tcx,\n-                query: None,\n-                diagnostics: None,\n-                layout_depth: 0,\n-                task_deps: None,\n-            };\n-            enter_context(&icx, |_| {\n-                f(tcx)\n-            })\n+        let tcx = TyCtxt {\n+            gcx,\n+            interners: &gcx.global_interners,\n+            dummy: PhantomData,\n+        };\n+        let icx = ImplicitCtxt {\n+            tcx,\n+            query: None,\n+            diagnostics: None,\n+            layout_depth: 0,\n+            task_deps: None,\n+        };\n+        enter_context(&icx, |_| {\n+            f(tcx)\n         })\n     }\n \n-    /// Stores a pointer to the GlobalCtxt if one is available.\n-    /// This is used to access the GlobalCtxt in the deadlock handler\n-    /// given to Rayon.\n-    scoped_thread_local!(pub static GCX_PTR: Lock<usize>);\n+    scoped_thread_local! {\n+        /// Stores a pointer to the GlobalCtxt if one is available.\n+        /// This is used to access the GlobalCtxt in the deadlock handler given to Rayon.\n+        pub static GCX_PTR: Lock<usize>\n+    }\n \n     /// Creates a TyCtxt and ImplicitCtxt based on the GCX_PTR thread local.\n     /// This is used in the deadlock handler.\n@@ -2067,7 +2058,7 @@ pub mod tls {\n     {\n         with_context(|context| {\n             unsafe {\n-                assert!(ptr::eq(context.tcx.gcx, tcx.gcx));\n+                assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n                 let context: &ImplicitCtxt<'_, '_, '_> = mem::transmute(context);\n                 f(context)\n             }\n@@ -2085,8 +2076,8 @@ pub mod tls {\n     {\n         with_context(|context| {\n             unsafe {\n-                assert!(ptr::eq(context.tcx.gcx, tcx.gcx));\n-                assert!(ptr::eq(context.tcx.interners, tcx.interners));\n+                assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n+                assert!(ptr_eq(context.tcx.interners, tcx.interners));\n                 let context: &ImplicitCtxt<'_, '_, '_> = mem::transmute(context);\n                 f(context)\n             }\n@@ -2124,15 +2115,19 @@ macro_rules! sty_debug_print {\n             #[derive(Copy, Clone)]\n             struct DebugStat {\n                 total: usize,\n-                region_infer: usize,\n+                lt_infer: usize,\n                 ty_infer: usize,\n-                both_infer: usize,\n+                ct_infer: usize,\n+                all_infer: usize,\n             }\n \n             pub fn go(tcx: TyCtxt<'_, '_, '_>) {\n                 let mut total = DebugStat {\n                     total: 0,\n-                    region_infer: 0, ty_infer: 0, both_infer: 0,\n+                    lt_infer: 0,\n+                    ty_infer: 0,\n+                    ct_infer: 0,\n+                    all_infer: 0,\n                 };\n                 $(let mut $variant = total;)*\n \n@@ -2143,31 +2138,35 @@ macro_rules! sty_debug_print {\n                         ty::Error => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n-                    let region = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let lt = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n                     let ty = t.flags.intersects(ty::TypeFlags::HAS_TY_INFER);\n+                    let ct = t.flags.intersects(ty::TypeFlags::HAS_CT_INFER);\n \n                     variant.total += 1;\n                     total.total += 1;\n-                    if region { total.region_infer += 1; variant.region_infer += 1 }\n+                    if lt { total.lt_infer += 1; variant.lt_infer += 1 }\n                     if ty { total.ty_infer += 1; variant.ty_infer += 1 }\n-                    if region && ty { total.both_infer += 1; variant.both_infer += 1 }\n+                    if ct { total.ct_infer += 1; variant.ct_infer += 1 }\n+                    if lt && ty && ct { total.all_infer += 1; variant.all_infer += 1 }\n                 }\n-                println!(\"Ty interner             total           ty region  both\");\n+                println!(\"Ty interner             total           ty lt ct all\");\n                 $(println!(\"    {:18}: {uses:6} {usespc:4.1}%, \\\n-                            {ty:4.1}% {region:5.1}% {both:4.1}%\",\n-                           stringify!($variant),\n-                           uses = $variant.total,\n-                           usespc = $variant.total as f64 * 100.0 / total.total as f64,\n-                           ty = $variant.ty_infer as f64 * 100.0  / total.total as f64,\n-                           region = $variant.region_infer as f64 * 100.0  / total.total as f64,\n-                           both = $variant.both_infer as f64 * 100.0  / total.total as f64);\n-                  )*\n+                            {ty:4.1}% {lt:5.1}% {ct:4.1}% {all:4.1}%\",\n+                    stringify!($variant),\n+                    uses = $variant.total,\n+                    usespc = $variant.total as f64 * 100.0 / total.total as f64,\n+                    ty = $variant.ty_infer as f64 * 100.0  / total.total as f64,\n+                    lt = $variant.lt_infer as f64 * 100.0  / total.total as f64,\n+                    ct = $variant.ct_infer as f64 * 100.0  / total.total as f64,\n+                    all = $variant.all_infer as f64 * 100.0  / total.total as f64);\n+                )*\n                 println!(\"                  total {uses:6}        \\\n-                          {ty:4.1}% {region:5.1}% {both:4.1}%\",\n-                         uses = total.total,\n-                         ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n-                         region = total.region_infer as f64 * 100.0  / total.total as f64,\n-                         both = total.both_infer as f64 * 100.0  / total.total as f64)\n+                          {ty:4.1}% {lt:5.1}% {ct:4.1}% {all:4.1}%\",\n+                    uses = total.total,\n+                    ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n+                    lt = total.lt_infer as f64 * 100.0  / total.total as f64,\n+                    ct = total.ct_infer as f64 * 100.0  / total.total as f64,\n+                    all = total.all_infer as f64 * 100.0  / total.total as f64)\n             }\n         }\n \n@@ -2183,7 +2182,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             Generator, GeneratorWitness, Dynamic, Closure, Tuple, Bound,\n             Param, Infer, UnnormalizedProjection, Projection, Opaque, Foreign);\n \n-        println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n+        println!(\"InternalSubsts interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n         println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n         println!(\"Allocation interner: #{}\", self.allocation_interner.borrow().len());\n@@ -2250,7 +2249,7 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, List<Canoni\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, Substs<'tcx>> {\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, InternalSubsts<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a [Kind<'lcx>] {\n         &self.0[..]\n     }\n@@ -2453,7 +2452,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.mk_fn_sig(\n                 params_iter,\n                 s.output(),\n-                s.variadic,\n+                s.c_variadic,\n                 hir::Unsafety::Normal,\n                 abi::Abi::Rust,\n             )\n@@ -2507,7 +2506,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_adt(self, def: &'tcx AdtDef, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_adt(self, def: &'tcx AdtDef, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         self.mk_ty(Adt(def, substs))\n     }\n@@ -2520,9 +2519,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n         let adt_def = self.adt_def(def_id);\n-        let substs = Substs::for_item(self, def_id, |param, substs| {\n+        let substs = InternalSubsts::for_item(self, def_id, |param, substs| {\n             match param.kind {\n-                GenericParamDefKind::Lifetime => bug!(),\n+                GenericParamDefKind::Lifetime |\n+                GenericParamDefKind::Const => {\n+                    bug!()\n+                }\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if param.index == 0 {\n                         ty.into()\n@@ -2613,7 +2615,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_fn_def(self, def_id: DefId,\n-                     substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+                     substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(FnDef(def_id, substs))\n     }\n \n@@ -2634,7 +2636,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn mk_projection(self,\n                          item_def_id: DefId,\n-                         substs: &'tcx Substs<'tcx>)\n+                         substs: SubstsRef<'tcx>)\n         -> Ty<'tcx> {\n             self.mk_ty(Projection(ProjectionTy {\n                 item_def_id,\n@@ -2663,10 +2665,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_var(self, v: TyVid) -> Ty<'tcx> {\n+    pub fn mk_ty_var(self, v: TyVid) -> Ty<'tcx> {\n         self.mk_infer(TyVar(v))\n     }\n \n+    #[inline]\n+    pub fn mk_const_var(self, v: ConstVid<'tcx>, ty: Ty<'tcx>) -> &'tcx LazyConst<'tcx> {\n+        self.mk_lazy_const(LazyConst::Evaluated(ty::Const {\n+            val: ConstValue::Infer(InferConst::Var(v)),\n+            ty,\n+        }))\n+    }\n+\n     #[inline]\n     pub fn mk_int_var(self, v: IntVid) -> Ty<'tcx> {\n         self.mk_infer(IntVar(v))\n@@ -2689,6 +2699,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(Param(ParamTy { idx: index, name: name }))\n     }\n \n+    #[inline]\n+    pub fn mk_const_param(\n+        self,\n+        index: u32,\n+        name: InternedString,\n+        ty: Ty<'tcx>\n+    ) -> &'tcx LazyConst<'tcx> {\n+        self.mk_lazy_const(LazyConst::Evaluated(ty::Const {\n+            val: ConstValue::Param(ParamConst { index, name }),\n+            ty,\n+        }))\n+    }\n+\n     #[inline]\n     pub fn mk_self_type(self) -> Ty<'tcx> {\n         self.mk_ty_param(0, keywords::SelfUpper.name().as_interned_str())\n@@ -2699,12 +2722,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             GenericParamDefKind::Lifetime => {\n                 self.mk_region(ty::ReEarlyBound(param.to_early_bound_region_data())).into()\n             }\n-            GenericParamDefKind::Type {..} => self.mk_ty_param(param.index, param.name).into(),\n+            GenericParamDefKind::Type { .. } => self.mk_ty_param(param.index, param.name).into(),\n+            GenericParamDefKind::Const => {\n+                self.mk_const_param(param.index, param.name, self.type_of(param.def_id)).into()\n+            }\n         }\n     }\n \n     #[inline]\n-    pub fn mk_opaque(self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_opaque(self, def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(Opaque(def_id, substs))\n     }\n \n@@ -2779,7 +2805,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn mk_fn_sig<I>(self,\n                         inputs: I,\n                         output: I::Item,\n-                        variadic: bool,\n+                        c_variadic: bool,\n                         unsafety: hir::Unsafety,\n                         abi: abi::Abi)\n         -> <I::Item as InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>::Output\n@@ -2788,7 +2814,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         inputs.chain(iter::once(output)).intern_with(|xs| ty::FnSig {\n             inputs_and_output: self.intern_type_list(xs),\n-            variadic, unsafety, abi\n+            c_variadic, unsafety, abi\n         })\n     }\n \n@@ -2817,7 +2843,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn mk_substs_trait(self,\n                      self_ty: Ty<'tcx>,\n                      rest: &[Kind<'tcx>])\n-                    -> &'tcx Substs<'tcx>\n+                    -> SubstsRef<'tcx>\n     {\n         self.mk_substs(iter::once(self_ty.into()).chain(rest.iter().cloned()))\n     }\n@@ -2838,14 +2864,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.struct_span_lint_hir(lint, hir_id, span.into(), msg).emit()\n     }\n \n-    pub fn lint_node<S: Into<MultiSpan>>(self,\n-                                         lint: &'static Lint,\n-                                         id: NodeId,\n-                                         span: S,\n-                                         msg: &str) {\n-        self.struct_span_lint_node(lint, id, span.into(), msg).emit()\n-    }\n-\n     pub fn lint_hir_note<S: Into<MultiSpan>>(self,\n                                              lint: &'static Lint,\n                                              hir_id: HirId,\n@@ -2859,16 +2877,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn lint_node_note<S: Into<MultiSpan>>(self,\n                                               lint: &'static Lint,\n-                                              id: NodeId,\n+                                              id: hir::HirId,\n                                               span: S,\n                                               msg: &str,\n                                               note: &str) {\n-        let mut err = self.struct_span_lint_node(lint, id, span.into(), msg);\n+        let mut err = self.struct_span_lint_hir(lint, id, span.into(), msg);\n         err.note(note);\n         err.emit()\n     }\n \n-    pub fn lint_level_at_node(self, lint: &'static Lint, mut id: NodeId)\n+    pub fn lint_level_at_node(self, lint: &'static Lint, mut id: hir::HirId)\n         -> (lint::Level, lint::LintSource)\n     {\n         // Right now we insert a `with_ignore` node in the dep graph here to\n@@ -2882,11 +2900,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.dep_graph.with_ignore(|| {\n             let sets = self.lint_levels(LOCAL_CRATE);\n             loop {\n-                let hir_id = self.hir().definitions().node_to_hir_id(id);\n-                if let Some(pair) = sets.level_and_source(lint, hir_id, self.sess) {\n+                if let Some(pair) = sets.level_and_source(lint, id, self.sess) {\n                     return pair\n                 }\n-                let next = self.hir().get_parent_node(id);\n+                let next = self.hir().get_parent_node_by_hir_id(id);\n                 if next == id {\n                     bug!(\"lint traversal reached the root of the crate\");\n                 }\n@@ -2902,23 +2919,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                                     msg: &str)\n         -> DiagnosticBuilder<'tcx>\n     {\n-        let node_id = self.hir().hir_to_node_id(hir_id);\n-        let (level, src) = self.lint_level_at_node(lint, node_id);\n+        let (level, src) = self.lint_level_at_node(lint, hir_id);\n         lint::struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n     }\n \n-    pub fn struct_span_lint_node<S: Into<MultiSpan>>(self,\n-                                                     lint: &'static Lint,\n-                                                     id: NodeId,\n-                                                     span: S,\n-                                                     msg: &str)\n-        -> DiagnosticBuilder<'tcx>\n-    {\n-        let (level, src) = self.lint_level_at_node(lint, id);\n-        lint::struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n-    }\n-\n-    pub fn struct_lint_node(self, lint: &'static Lint, id: NodeId, msg: &str)\n+    pub fn struct_lint_node(self, lint: &'static Lint, id: HirId, msg: &str)\n         -> DiagnosticBuilder<'tcx>\n     {\n         let (level, src) = self.lint_level_at_node(lint, id);\n@@ -2993,6 +2998,12 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     }\n }\n \n+// We are comparing types with different invariant lifetimes, so `ptr::eq`\n+// won't work for us.\n+fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n+    t as *const () == u as *const ()\n+}\n+\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     providers.in_scope_traits_map = |tcx, id| tcx.gcx.trait_map.get(&id).cloned();\n     providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).cloned();"}, {"sha": "64ceb9729ed15374b47619090ece88830606c6be", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,5 +1,6 @@\n-use crate::ty::subst::Substs;\n-use crate::ty::{self, Ty, TypeFlags, TypeFoldable};\n+use crate::ty::subst::{SubstsRef, UnpackedKind};\n+use crate::ty::{self, Ty, TypeFlags, TypeFoldable, InferConst};\n+use crate::mir::interpret::ConstValue;\n \n #[derive(Debug)]\n pub struct FlagComputation {\n@@ -232,6 +233,21 @@ impl FlagComputation {\n         }\n     }\n \n+    fn add_const(&mut self, c: &ty::LazyConst<'_>) {\n+        match c {\n+            ty::LazyConst::Unevaluated(_, substs) => self.add_substs(substs),\n+            // Only done to add the binder for the type. The type flags are\n+            // included in `Const::type_flags`.\n+            ty::LazyConst::Evaluated(ty::Const { ty, val }) => {\n+                self.add_ty(ty);\n+                if let ConstValue::Infer(InferConst::Canonical(debruijn, _)) = val {\n+                    self.add_binder(*debruijn)\n+                }\n+            }\n+        }\n+        self.add_flags(c.type_flags());\n+    }\n+\n     fn add_existential_projection(&mut self, projection: &ty::ExistentialProjection<'_>) {\n         self.add_substs(projection.substs);\n         self.add_ty(projection.ty);\n@@ -241,13 +257,13 @@ impl FlagComputation {\n         self.add_substs(projection_ty.substs);\n     }\n \n-    fn add_substs(&mut self, substs: &Substs<'_>) {\n-        for ty in substs.types() {\n-            self.add_ty(ty);\n-        }\n-\n-        for r in substs.regions() {\n-            self.add_region(r);\n+    fn add_substs(&mut self, substs: SubstsRef<'_>) {\n+        for kind in substs {\n+            match kind.unpack() {\n+                UnpackedKind::Type(ty) => self.add_ty(ty),\n+                UnpackedKind::Lifetime(lt) => self.add_region(lt),\n+                UnpackedKind::Const(ct) => self.add_const(ct),\n+            }\n         }\n     }\n }"}, {"sha": "7f77d037bb6a1a715711d8f81e4979720adbd130", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -91,7 +91,9 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }\n     fn needs_infer(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n+        self.has_type_flags(\n+            TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER | TypeFlags::HAS_CT_INFER\n+        )\n     }\n     fn has_placeholders(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_RE_PLACEHOLDER | TypeFlags::HAS_TY_PLACEHOLDER)\n@@ -117,7 +119,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     }\n \n     /// Indicates whether this value references only 'global'\n-    /// types/lifetimes that are the same regardless of what fn we are\n+    /// generic parameters that are the same regardless of what fn we are\n     /// in. This is used for caching.\n     fn is_global(&self) -> bool {\n         !self.has_type_flags(TypeFlags::HAS_FREE_LOCAL_NAMES)\n@@ -841,14 +843,13 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     fn visit_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> bool {\n-        if let ty::LazyConst::Unevaluated(..) = c {\n-            let projection_flags = TypeFlags::HAS_NORMALIZABLE_PROJECTION |\n-                TypeFlags::HAS_PROJECTION;\n-            if projection_flags.intersects(self.flags) {\n-                return true;\n-            }\n+        let flags = c.type_flags();\n+        debug!(\"HasTypeFlagsVisitor: c={:?} c.flags={:?} self.flags={:?}\", c, flags, self.flags);\n+        if flags.intersects(self.flags) {\n+            true\n+        } else {\n+            c.super_visit_with(self)\n         }\n-        c.super_visit_with(self)\n     }\n }\n "}, {"sha": "33ec9c874f9ef1e5e4f3ecd4907bb8ff7c87a22d", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,6 +1,6 @@\n use crate::ty::context::TyCtxt;\n use crate::ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n-use crate::ty::{self, DefId, Substs};\n+use crate::ty::{self, DefId, SubstsRef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::TyKind::*;\n \n@@ -108,21 +108,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn is_enum_variant_uninhabited_from(self,\n                                             module: DefId,\n                                             variant: &'tcx VariantDef,\n-                                            substs: &'tcx Substs<'tcx>)\n+                                            substs: SubstsRef<'tcx>)\n                                             -> bool\n     {\n         self.variant_inhabitedness_forest(variant, substs).contains(self, module)\n     }\n \n     pub fn is_variant_uninhabited_from_all_modules(self,\n                                                    variant: &'tcx VariantDef,\n-                                                   substs: &'tcx Substs<'tcx>)\n+                                                   substs: SubstsRef<'tcx>)\n                                                    -> bool\n     {\n         !self.variant_inhabitedness_forest(variant, substs).is_empty()\n     }\n \n-    fn variant_inhabitedness_forest(self, variant: &'tcx VariantDef, substs: &'tcx Substs<'tcx>)\n+    fn variant_inhabitedness_forest(self, variant: &'tcx VariantDef, substs: SubstsRef<'tcx>)\n                                     -> DefIdForest {\n         // Determine the ADT kind:\n         let adt_def_id = self.adt_def_id_of_variant(variant);\n@@ -138,7 +138,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     fn uninhabited_from(\n         &self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        substs: &'tcx Substs<'tcx>) -> DefIdForest\n+        substs: SubstsRef<'tcx>) -> DefIdForest\n     {\n         DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n             v.uninhabited_from(tcx, substs, self.adt_kind())\n@@ -151,7 +151,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     fn uninhabited_from(\n         &self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        substs: &'tcx Substs<'tcx>,\n+        substs: SubstsRef<'tcx>,\n         adt_kind: AdtKind) -> DefIdForest\n     {\n         let is_enum = match adt_kind {\n@@ -172,7 +172,7 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     fn uninhabited_from(\n         &self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        substs: &'tcx Substs<'tcx>,\n+        substs: SubstsRef<'tcx>,\n         is_enum: bool,\n     ) -> DefIdForest {\n         let data_uninhabitedness = move || {"}, {"sha": "e0b7bbc68e25e95da3f60f53b668ecb05cfb891a", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,20 +1,21 @@\n use crate::hir::Unsafety;\n use crate::hir::def_id::DefId;\n-use crate::ty::{self, Ty, PolyFnSig, TypeFoldable, Substs, TyCtxt};\n+use crate::ty::{self, Ty, PolyFnSig, TypeFoldable, SubstsRef, TyCtxt};\n use crate::traits;\n use rustc_target::spec::abi::Abi;\n+use rustc_macros::HashStable;\n use crate::util::ppaux;\n \n use std::fmt;\n use std::iter;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Instance<'tcx> {\n     pub def: InstanceDef<'tcx>,\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InstanceDef<'tcx> {\n     Item(DefId),\n     Intrinsic(DefId),\n@@ -65,7 +66,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n                 sig.map_bound(|sig| tcx.mk_fn_sig(\n                     iter::once(*env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n                     sig.output(),\n-                    sig.variadic,\n+                    sig.c_variadic,\n                     sig.unsafety,\n                     sig.abi\n                 ))\n@@ -203,7 +204,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n }\n \n impl<'a, 'b, 'tcx> Instance<'tcx> {\n-    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n+    pub fn new(def_id: DefId, substs: SubstsRef<'tcx>)\n                -> Instance<'tcx> {\n         assert!(!substs.has_escaping_bound_vars(),\n                 \"substs of instance {:?} not normalized for codegen: {:?}\",\n@@ -241,7 +242,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     pub fn resolve(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    param_env: ty::ParamEnv<'tcx>,\n                    def_id: DefId,\n-                   substs: &'tcx Substs<'tcx>) -> Option<Instance<'tcx>> {\n+                   substs: SubstsRef<'tcx>) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n         let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n             debug!(\" => associated item, attempting to find impl in param_env {:#?}\", param_env);\n@@ -293,7 +294,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     pub fn resolve_for_vtable(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               param_env: ty::ParamEnv<'tcx>,\n                               def_id: DefId,\n-                              substs: &'tcx Substs<'tcx>) -> Option<Instance<'tcx>> {\n+                              substs: SubstsRef<'tcx>) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n         let fn_sig = tcx.fn_sig(def_id);\n         let is_vtable_shim =\n@@ -338,7 +339,7 @@ fn resolve_associated_item<'a, 'tcx>(\n     trait_item: &ty::AssociatedItem,\n     param_env: ty::ParamEnv<'tcx>,\n     trait_id: DefId,\n-    rcvr_substs: &'tcx Substs<'tcx>,\n+    rcvr_substs: SubstsRef<'tcx>,\n ) -> Option<Instance<'tcx>> {\n     let def_id = trait_item.def_id;\n     debug!(\"resolve_associated_item(trait_item={:?}, \\"}, {"sha": "7d2b21b9aecdaed1f0c8e579f001907204ea2a22", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1176,25 +1176,27 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n     /// This is invoked by the `layout_raw` query to record the final\n     /// layout of each type.\n-    #[inline]\n+    #[inline(always)]\n     fn record_layout_for_printing(&self, layout: TyLayout<'tcx>) {\n-        // If we are running with `-Zprint-type-sizes`, record layouts for\n-        // dumping later. Ignore layouts that are done with non-empty\n-        // environments or non-monomorphic layouts, as the user only wants\n-        // to see the stuff resulting from the final codegen session.\n+        // If we are running with `-Zprint-type-sizes`, maybe record layouts\n+        // for dumping later.\n+        if self.tcx.sess.opts.debugging_opts.print_type_sizes {\n+            self.record_layout_for_printing_outlined(layout)\n+        }\n+    }\n+\n+    fn record_layout_for_printing_outlined(&self, layout: TyLayout<'tcx>) {\n+        // Ignore layouts that are done with non-empty environments or\n+        // non-monomorphic layouts, as the user only wants to see the stuff\n+        // resulting from the final codegen session.\n         if\n-            !self.tcx.sess.opts.debugging_opts.print_type_sizes ||\n             layout.ty.has_param_types() ||\n             layout.ty.has_self_ty() ||\n             !self.param_env.caller_bounds.is_empty()\n         {\n             return;\n         }\n \n-        self.record_layout_for_printing_outlined(layout)\n-    }\n-\n-    fn record_layout_for_printing_outlined(&self, layout: TyLayout<'tcx>) {\n         // (delay format until we actually need it)\n         let record = |kind, packed, opt_discr_size, variants| {\n             let type_desc = format!(\"{:?}\", layout.ty);"}, {"sha": "68bdae7d744c53b3724247d6f6b82852ec73ac96", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 132, "deletions": 98, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -5,11 +5,12 @@ pub use self::IntVarValue::*;\n pub use self::fold::TypeFoldable;\n \n use crate::hir::{map as hir_map, FreevarMap, GlobMap, TraitMap};\n-use crate::hir::Node;\n+use crate::hir::{HirId, Node};\n use crate::hir::def::{Def, CtorKind, ExportMap};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::hir::map::DefPathData;\n use rustc_data_structures::svh::Svh;\n+use rustc_macros::HashStable;\n use crate::ich::Fingerprint;\n use crate::ich::StableHashingContext;\n use crate::infer::canonical::Canonical;\n@@ -22,7 +23,7 @@ use crate::session::CrateDisambiguator;\n use crate::traits::{self, Reveal};\n use crate::ty;\n use crate::ty::layout::VariantIdx;\n-use crate::ty::subst::{Subst, Substs};\n+use crate::ty::subst::{Subst, InternalSubsts, SubstsRef};\n use crate::ty::util::{IntTypeExt, Discr};\n use crate::ty::walk::TypeWalker;\n use crate::util::captures::Captures;\n@@ -54,14 +55,14 @@ use crate::hir;\n \n pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar, DebruijnIndex, INNERMOST};\n pub use self::sty::{FnSig, GenSig, CanonicalPolyFnSig, PolyFnSig, PolyGenSig};\n-pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n+pub use self::sty::{InferTy, ParamTy, ParamConst, InferConst, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, UpvarSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TyKind, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const, LazyConst};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n-pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid};\n+pub use self::sty::{TyVid, IntVid, FloatVid, ConstVid, RegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind::*;\n@@ -71,7 +72,7 @@ pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, FreeRegionInfo, GlobalArenas, AllArenas, tls, keep_local};\n-pub use self::context::{Lift, TypeckTables, CtxtInterners};\n+pub use self::context::{Lift, TypeckTables, CtxtInterners, GlobalCtxt};\n pub use self::context::{\n     UserTypeAnnotationIndex, UserType, CanonicalUserType,\n     CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, ResolvedOpaqueTy,\n@@ -128,7 +129,7 @@ pub struct Resolutions {\n     pub extern_prelude: FxHashMap<Name, bool>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable)]\n pub enum AssociatedItemContainer {\n     TraitContainer(DefId),\n     ImplContainer(DefId),\n@@ -163,9 +164,10 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n pub struct AssociatedItem {\n     pub def_id: DefId,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub kind: AssociatedKind,\n     pub vis: Visibility,\n@@ -177,7 +179,7 @@ pub struct AssociatedItem {\n     pub method_has_self_argument: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AssociatedKind {\n     Const,\n     Method,\n@@ -225,7 +227,7 @@ impl AssociatedItem {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n     Public,\n@@ -260,7 +262,7 @@ impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl Visibility {\n-    pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: TyCtxt<'_, '_, '_>) -> Self {\n+    pub fn from_hir(visibility: &hir::Visibility, id: hir::HirId, tcx: TyCtxt<'_, '_, '_>) -> Self {\n         match visibility.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Crate(_) => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n@@ -271,7 +273,7 @@ impl Visibility {\n                 def => Visibility::Restricted(def.def_id()),\n             },\n             hir::VisibilityKind::Inherited => {\n-                Visibility::Restricted(tcx.hir().get_module_parent(id))\n+                Visibility::Restricted(tcx.hir().get_module_parent_by_hir_id(id))\n             }\n         }\n     }\n@@ -312,7 +314,7 @@ impl Visibility {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Hash, HashStable)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n@@ -326,13 +328,15 @@ pub enum Variance {\n /// HIR of every item in the local crate. Instead, use\n /// `tcx.variances_of()` to get the variance for a *particular*\n /// item.\n+#[derive(HashStable)]\n pub struct CrateVariancesMap {\n     /// For each item with generics, maps to a vector of the variance\n     /// of its generics. If an item has no generics, it will have no\n     /// entry.\n     pub variances: FxHashMap<DefId, Lrc<Vec<ty::Variance>>>,\n \n     /// An empty vector, useful for cloning.\n+    #[stable_hasher(ignore)]\n     pub empty_variance: Lrc<Vec<ty::Variance>>,\n }\n \n@@ -451,6 +455,8 @@ bitflags! {\n \n         const HAS_TY_PLACEHOLDER = 1 << 14;\n \n+        const HAS_CT_INFER = 1 << 15;\n+\n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n@@ -462,6 +468,7 @@ bitflags! {\n                                   TypeFlags::HAS_SELF.bits |\n                                   TypeFlags::HAS_TY_INFER.bits |\n                                   TypeFlags::HAS_RE_INFER.bits |\n+                                  TypeFlags::HAS_CT_INFER.bits |\n                                   TypeFlags::HAS_RE_PLACEHOLDER.bits |\n                                   TypeFlags::HAS_RE_EARLY_BOUND.bits |\n                                   TypeFlags::HAS_FREE_REGIONS.bits |\n@@ -715,21 +722,21 @@ impl<T> List<T> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n }\n \n /// Upvars do not get their own `NodeId`. Instead, we use the pair of\n /// the original var ID (that is, the root variable that is referenced\n /// by the upvar) and the ID of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UpvarId {\n     pub var_path: UpvarPath,\n     pub closure_expr_id: LocalDefId,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -777,7 +784,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Debug, Copy, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -788,7 +795,7 @@ pub enum UpvarCapture<'tcx> {\n     ByRef(UpvarBorrow<'tcx>),\n }\n \n-#[derive(PartialEq, Clone, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Copy, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -830,17 +837,18 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum GenericParamDefKind {\n     Lifetime,\n     Type {\n         has_default: bool,\n         object_lifetime_default: ObjectLifetimeDefault,\n         synthetic: Option<hir::SyntheticTyParamKind>,\n-    }\n+    },\n+    Const,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GenericParamDef {\n     pub name: InternedString,\n     pub def_id: DefId,\n@@ -880,20 +888,22 @@ impl GenericParamDef {\n pub struct GenericParamCount {\n     pub lifetimes: usize,\n     pub types: usize,\n+    pub consts: usize,\n }\n \n /// Information about the formal type/lifetime parameters associated\n /// with an item or method. Analogous to `hir::Generics`.\n ///\n /// The ordering of parameters is the same as in `Subst` (excluding child generics):\n /// `Self` (optionally), `Lifetime` params..., `Type` params...\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Generics {\n     pub parent: Option<DefId>,\n     pub parent_count: usize,\n     pub params: Vec<GenericParamDef>,\n \n     /// Reverse map to the `index` field of each `GenericParamDef`\n+    #[stable_hasher(ignore)]\n     pub param_def_id_to_index: FxHashMap<DefId, u32>,\n \n     pub has_self: bool,\n@@ -915,6 +925,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => own_counts.lifetimes += 1,\n                 GenericParamDefKind::Type { .. } => own_counts.types += 1,\n+                GenericParamDefKind::Const => own_counts.consts += 1,\n             };\n         }\n \n@@ -924,7 +935,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n     pub fn requires_monomorphization(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         for param in &self.params {\n             match param.kind {\n-                GenericParamDefKind::Type { .. } => return true,\n+                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => return true,\n                 GenericParamDefKind::Lifetime => {}\n             }\n         }\n@@ -944,7 +955,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n-                ty::GenericParamDefKind::Lifetime => param,\n+                GenericParamDefKind::Lifetime => param,\n                 _ => bug!(\"expected lifetime parameter, but found another generic parameter\")\n             }\n         } else {\n@@ -961,18 +972,35 @@ impl<'a, 'gcx, 'tcx> Generics {\n         if let Some(index) = param.idx.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n-                ty::GenericParamDefKind::Type {..} => param,\n+                GenericParamDefKind::Type { .. } => param,\n                 _ => bug!(\"expected type parameter, but found another generic parameter\")\n             }\n         } else {\n             tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n                .type_param(param, tcx)\n         }\n     }\n+\n+    /// Returns the `ConstParameterDef` associated with this `ParamConst`.\n+    pub fn const_param(&'tcx self,\n+                       param: &ParamConst,\n+                       tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                       -> &GenericParamDef {\n+        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n+            let param = &self.params[index as usize];\n+            match param.kind {\n+                GenericParamDefKind::Const => param,\n+                _ => bug!(\"expected const parameter, but found another generic parameter\")\n+            }\n+        } else {\n+            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n+                .const_param(param, tcx)\n+        }\n+    }\n }\n \n /// Bounds on generics.\n-#[derive(Clone, Default)]\n+#[derive(Clone, Default, HashStable)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n     pub predicates: Vec<(Predicate<'tcx>, Span)>,\n@@ -982,14 +1010,14 @@ impl<'tcx> serialize::UseSpecializedEncodable for GenericPredicates<'tcx> {}\n impl<'tcx> serialize::UseSpecializedDecodable for GenericPredicates<'tcx> {}\n \n impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n-    pub fn instantiate(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n+    pub fn instantiate(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: SubstsRef<'tcx>)\n                        -> InstantiatedPredicates<'tcx> {\n         let mut instantiated = InstantiatedPredicates::empty();\n         self.instantiate_into(tcx, &mut instantiated, substs);\n         instantiated\n     }\n \n-    pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n+    pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: SubstsRef<'tcx>)\n                            -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n             predicates: self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)).collect(),\n@@ -998,7 +1026,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n \n     fn instantiate_into(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                         instantiated: &mut InstantiatedPredicates<'tcx>,\n-                        substs: &Substs<'tcx>) {\n+                        substs: SubstsRef<'tcx>) {\n         if let Some(def_id) = self.parent {\n             tcx.predicates_of(def_id).instantiate_into(tcx, instantiated, substs);\n         }\n@@ -1035,7 +1063,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo: Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n@@ -1067,7 +1095,7 @@ pub enum Predicate<'tcx> {\n     Subtype(PolySubtypePredicate<'tcx>),\n \n     /// Constant initializer must evaluate successfully.\n-    ConstEvaluatable(DefId, &'tcx Substs<'tcx>),\n+    ConstEvaluatable(DefId, SubstsRef<'tcx>),\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -1076,13 +1104,15 @@ pub enum Predicate<'tcx> {\n /// HIR of every item in the local crate. Instead, use\n /// `tcx.inferred_outlives_of()` to get the outlives for a *particular*\n /// item.\n+#[derive(HashStable)]\n pub struct CratePredicatesMap<'tcx> {\n     /// For each struct with outlive bounds, maps to a vector of the\n     /// predicate of its outlive bounds. If an item has no outlives\n     /// bounds, it will have no entry.\n     pub predicates: FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n \n     /// An empty vector, useful for cloning.\n+    #[stable_hasher(ignore)]\n     pub empty_predicate: Lrc<Vec<ty::Predicate<'tcx>>>,\n }\n \n@@ -1186,7 +1216,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>\n }\n@@ -1214,7 +1244,8 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A: B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>,\n@@ -1224,7 +1255,7 @@ pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>,\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;\n pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<TypeOutlivesPredicate<'tcx>>;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SubtypePredicate<'tcx> {\n     pub a_is_expected: bool,\n     pub a: Ty<'tcx>,\n@@ -1244,7 +1275,7 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// equality between arbitrary types. Processing an instance of\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,\n@@ -1489,42 +1520,42 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-/// \"Universes\" are used during type- and trait-checking in the\n-/// presence of `for<..>` binders to control what sets of names are\n-/// visible. Universes are arranged into a tree: the root universe\n-/// contains names that are always visible. Each child then adds a new\n-/// set of names that are visible, in addition to those of its parent.\n-/// We say that the child universe \"extends\" the parent universe with\n-/// new names.\n-///\n-/// To make this more concrete, consider this program:\n-///\n-/// ```\n-/// struct Foo { }\n-/// fn bar<T>(x: T) {\n-///   let y: for<'a> fn(&'a u8, Foo) = ...;\n-/// }\n-/// ```\n-///\n-/// The struct name `Foo` is in the root universe U0. But the type\n-/// parameter `T`, introduced on `bar`, is in an extended universe U1\n-/// -- i.e., within `bar`, we can name both `T` and `Foo`, but outside\n-/// of `bar`, we cannot name `T`. Then, within the type of `y`, the\n-/// region `'a` is in a universe U2 that extends U1, because we can\n-/// name it inside the fn type but not outside.\n-///\n-/// Universes are used to do type- and trait-checking around these\n-/// \"forall\" binders (also called **universal quantification**). The\n-/// idea is that when, in the body of `bar`, we refer to `T` as a\n-/// type, we aren't referring to any type in particular, but rather a\n-/// kind of \"fresh\" type that is distinct from all other types we have\n-/// actually declared. This is called a **placeholder** type, and we\n-/// use universes to talk about this. In other words, a type name in\n-/// universe 0 always corresponds to some \"ground\" type that the user\n-/// declared, but a type name in a non-zero universe is a placeholder\n-/// type -- an idealized representative of \"types in general\" that we\n-/// use for checking generic functions.\n newtype_index! {\n+    /// \"Universes\" are used during type- and trait-checking in the\n+    /// presence of `for<..>` binders to control what sets of names are\n+    /// visible. Universes are arranged into a tree: the root universe\n+    /// contains names that are always visible. Each child then adds a new\n+    /// set of names that are visible, in addition to those of its parent.\n+    /// We say that the child universe \"extends\" the parent universe with\n+    /// new names.\n+    ///\n+    /// To make this more concrete, consider this program:\n+    ///\n+    /// ```\n+    /// struct Foo { }\n+    /// fn bar<T>(x: T) {\n+    ///   let y: for<'a> fn(&'a u8, Foo) = ...;\n+    /// }\n+    /// ```\n+    ///\n+    /// The struct name `Foo` is in the root universe U0. But the type\n+    /// parameter `T`, introduced on `bar`, is in an extended universe U1\n+    /// -- i.e., within `bar`, we can name both `T` and `Foo`, but outside\n+    /// of `bar`, we cannot name `T`. Then, within the type of `y`, the\n+    /// region `'a` is in a universe U2 that extends U1, because we can\n+    /// name it inside the fn type but not outside.\n+    ///\n+    /// Universes are used to do type- and trait-checking around these\n+    /// \"forall\" binders (also called **universal quantification**). The\n+    /// idea is that when, in the body of `bar`, we refer to `T` as a\n+    /// type, we aren't referring to any type in particular, but rather a\n+    /// kind of \"fresh\" type that is distinct from all other types we have\n+    /// actually declared. This is called a **placeholder** type, and we\n+    /// use universes to talk about this. In other words, a type name in\n+    /// universe 0 always corresponds to some \"ground\" type that the user\n+    /// declared, but a type name in a non-zero universe is a placeholder\n+    /// type -- an idealized representative of \"types in general\" that we\n+    /// use for checking generic functions.\n     pub struct UniverseIndex {\n         DEBUG_FORMAT = \"U{}\",\n     }\n@@ -1599,7 +1630,7 @@ pub type PlaceholderType = Placeholder<BoundVar>;\n /// When type checking, we use the `ParamEnv` to track\n /// details about the set of where-clauses that are in scope at this\n /// particular point.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n pub struct ParamEnv<'tcx> {\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n@@ -1734,13 +1765,14 @@ impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ParamEnvAnd<'gcx, T>\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub struct Destructor {\n     /// The `DefId` of the destructor method\n     pub did: DefId,\n }\n \n bitflags! {\n+    #[derive(HashStable)]\n     pub struct AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0;\n         const IS_ENUM             = 1 << 0;\n@@ -1761,6 +1793,7 @@ bitflags! {\n }\n \n bitflags! {\n+    #[derive(HashStable)]\n     pub struct VariantFlags: u32 {\n         const NO_VARIANT_FLAGS        = 0;\n         /// Indicates whether the field list of this variant is `#[non_exhaustive]`.\n@@ -1838,7 +1871,7 @@ impl_stable_hash_for!(struct VariantDef {\n     flags\n });\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum VariantDiscr {\n     /// Explicit value for this variant, i.e., `X = 123`.\n     /// The `DefId` corresponds to the embedded constant.\n@@ -1851,9 +1884,10 @@ pub enum VariantDiscr {\n     Relative(u32),\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, HashStable)]\n pub struct FieldDef {\n     pub did: DefId,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub vis: Visibility,\n }\n@@ -2261,7 +2295,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     ) -> Option<Discr<'tcx>> {\n         let param_env = ParamEnv::empty();\n         let repr_type = self.repr.discr_type();\n-        let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n+        let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), expr_did);\n         let instance = ty::Instance::new(expr_did, substs);\n         let cid = GlobalId {\n             instance,\n@@ -2463,7 +2497,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n }\n \n impl<'a, 'gcx, 'tcx> FieldDef {\n-    pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: SubstsRef<'tcx>) -> Ty<'tcx> {\n         tcx.type_of(self.did).subst(tcx, subst)\n     }\n }\n@@ -2474,7 +2508,8 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n ///\n /// You can get the environment type of a closure using\n /// `tcx.closure_env_ty()`.\n-#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub enum ClosureKind {\n     // Warning: Ordering is significant here! The ordering is chosen\n     // because the trait Fn is a subtrait of FnMut and so in turn, and\n@@ -2703,8 +2738,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssociatedItem> {\n-        let is_associated_item = if let Some(node_id) = self.hir().as_local_node_id(def_id) {\n-            match self.hir().get(node_id) {\n+        let is_associated_item = if let Some(hir_id) = self.hir().as_local_hir_id(def_id) {\n+            match self.hir().get_by_hir_id(hir_id) {\n                 Node::TraitItem(_) | Node::ImplItem(_) => true,\n                 _ => false,\n             }\n@@ -2727,7 +2762,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                            parent_vis: &hir::Visibility,\n                                            trait_item_ref: &hir::TraitItemRef)\n                                            -> AssociatedItem {\n-        let def_id = self.hir().local_def_id(trait_item_ref.id.node_id);\n+        let def_id = self.hir().local_def_id_from_hir_id(trait_item_ref.id.hir_id);\n         let (kind, has_self) = match trait_item_ref.kind {\n             hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n             hir::AssociatedItemKind::Method { has_self } => {\n@@ -2741,7 +2776,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ident: trait_item_ref.ident,\n             kind,\n             // Visibility of trait items is inherited from their traits.\n-            vis: Visibility::from_hir(parent_vis, trait_item_ref.id.node_id, self),\n+            vis: Visibility::from_hir(parent_vis, trait_item_ref.id.hir_id, self),\n             defaultness: trait_item_ref.defaultness,\n             def_id,\n             container: TraitContainer(parent_def_id),\n@@ -2753,7 +2788,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                           parent_def_id: DefId,\n                                           impl_item_ref: &hir::ImplItemRef)\n                                           -> AssociatedItem {\n-        let def_id = self.hir().local_def_id(impl_item_ref.id.node_id);\n+        let def_id = self.hir().local_def_id_from_hir_id(impl_item_ref.id.hir_id);\n         let (kind, has_self) = match impl_item_ref.kind {\n             hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n             hir::AssociatedItemKind::Method { has_self } => {\n@@ -2767,16 +2802,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ident: impl_item_ref.ident,\n             kind,\n             // Visibility of trait impl items doesn't matter.\n-            vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.node_id, self),\n+            vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.hir_id, self),\n             defaultness: impl_item_ref.defaultness,\n             def_id,\n             container: ImplContainer(parent_def_id),\n             method_has_self_argument: has_self\n         }\n     }\n \n-    pub fn field_index(self, node_id: NodeId, tables: &TypeckTables<'_>) -> usize {\n-        let hir_id = self.hir().node_to_hir_id(node_id);\n+    pub fn field_index(self, hir_id: hir::HirId, tables: &TypeckTables<'_>) -> usize {\n         tables.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n     }\n \n@@ -3026,10 +3060,10 @@ impl Iterator for AssociatedItemsIterator<'_, '_, '_> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n+    pub fn with_freevars<T, F>(self, fid: HirId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,\n     {\n-        let def_id = self.hir().local_def_id(fid);\n+        let def_id = self.hir().local_def_id_from_hir_id(fid);\n         match self.freevars(def_id) {\n             None => f(&[]),\n             Some(d) => f(&d),\n@@ -3038,13 +3072,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> AssociatedItem {\n-    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let parent_id = tcx.hir().get_parent(id);\n-    let parent_def_id = tcx.hir().local_def_id(parent_id);\n-    let parent_item = tcx.hir().expect_item(parent_id);\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let parent_id = tcx.hir().get_parent_item(id);\n+    let parent_def_id = tcx.hir().local_def_id_from_hir_id(parent_id);\n+    let parent_item = tcx.hir().expect_item_by_hir_id(parent_id);\n     match parent_item.node {\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n-            if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.node_id == id) {\n+            if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.hir_id == id) {\n                 let assoc_item = tcx.associated_item_from_impl_item_ref(parent_def_id,\n                                                                         impl_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n@@ -3053,7 +3087,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Asso\n         }\n \n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-            if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.node_id == id) {\n+            if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.hir_id == id) {\n                 let assoc_item = tcx.associated_item_from_trait_item_ref(parent_def_id,\n                                                                          &parent_item.vis,\n                                                                          trait_item_ref);\n@@ -3070,7 +3104,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Asso\n               parent_item.node)\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, HashStable)]\n pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n \n /// Calculates the `Sized` constraint.\n@@ -3107,13 +3141,13 @@ fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             trait_item_refs.iter()\n                            .map(|trait_item_ref| trait_item_ref.id)\n-                           .map(|id| tcx.hir().local_def_id(id.node_id))\n+                           .map(|id| tcx.hir().local_def_id_from_hir_id(id.hir_id))\n                            .collect()\n         }\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             impl_item_refs.iter()\n                           .map(|impl_item_ref| impl_item_ref.id)\n-                          .map(|id| tcx.hir().local_def_id(id.node_id))\n+                          .map(|id| tcx.hir().local_def_id_from_hir_id(id.hir_id))\n                           .collect()\n         }\n         hir::ItemKind::TraitAlias(..) => vec![],\n@@ -3141,8 +3175,8 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n \n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefId> {\n-    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n-        if let Node::Item(item) = tcx.hir().get(node_id) {\n+    if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+        if let Node::Item(item) = tcx.hir().get_by_hir_id(hir_id) {\n             if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n                 return exist_ty.impl_trait_fn;\n             }\n@@ -3303,7 +3337,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n /// rather, you should request the vector for a specific type via\n /// `tcx.inherent_impls(def_id)` so as to minimize your dependencies\n /// (constructing this map requires touching the entire crate).\n-#[derive(Clone, Debug, Default)]\n+#[derive(Clone, Debug, Default, HashStable)]\n pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Lrc<Vec<DefId>>>,\n }"}, {"sha": "6488c0db42bc571884599493cedb2fc3153c3dc2", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -9,7 +9,7 @@ use crate::traits::query::{\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n };\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::SubstsRef;\n use crate::ty::query::queries;\n use crate::ty::query::Query;\n use crate::ty::query::QueryCache;\n@@ -313,7 +313,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::erase_regions_ty<'tcx> {\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, (_, def_id): (DefId, DefId)) -> Cow<'static, str> {\n-        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         format!(\"computing the bounds for type parameter `{}`\",\n                 tcx.hir().ty_param_name(id)).into()\n     }\n@@ -369,6 +369,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::privacy_access_levels<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::check_private_in_public<'tcx> {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"checking for private elements in public interfaces\".into()\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::typeck_item_bodies<'tcx> {\n     fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n         \"type-checking all item bodies\".into()\n@@ -611,6 +617,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::extern_crate<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"running analysis passes on this crate\".into()\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::lint_levels<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n         \"computing the lint levels for items in this crate\".into()\n@@ -914,7 +926,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::optimized_mir<'tcx> {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_predicates<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: (DefId, &'tcx Substs<'tcx>)) -> Cow<'static, str> {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, key: (DefId, SubstsRef<'tcx>)) -> Cow<'static, str> {\n         format!(\"testing substituted normalized predicates:`{}`\", tcx.item_path_str(key.0)).into()\n     }\n }"}, {"sha": "8e68c9fa30431c13789630c95e6a37aa838f0f64", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -7,6 +7,7 @@ use std::{fmt, ptr};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{Lock, LockGuard, Lrc, Weak};\n use rustc_data_structures::OnDrop;\n+use rustc_data_structures::jobserver;\n use syntax_pos::Span;\n \n use crate::ty::tls;\n@@ -198,7 +199,11 @@ impl<'tcx> QueryLatch<'tcx> {\n             // we have to be in the `wait` call. This is ensured by the deadlock handler\n             // getting the self.info lock.\n             rayon_core::mark_blocked();\n+            jobserver::release_thread();\n             waiter.condvar.wait(&mut info);\n+            // Release the lock before we potentially block in `acquire_thread`\n+            mem::drop(info);\n+            jobserver::acquire_thread();\n         }\n     }\n "}, {"sha": "d353da801778d5999f6426caa0665af8da36bb6b", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -4,7 +4,7 @@ use crate::infer::canonical::Canonical;\n use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n use crate::traits;\n use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::SubstsRef;\n use crate::ty::fast_reject::SimplifiedType;\n use crate::mir;\n \n@@ -109,7 +109,7 @@ impl Key for (DefId, SimplifiedType) {\n     }\n }\n \n-impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n+impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }"}, {"sha": "8804ed22264ce061e405563eb69314afba67b06b", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -19,7 +19,7 @@ use crate::mir::interpret::{ConstEvalRawResult, ConstEvalResult};\n use crate::mir::mono::CodegenUnit;\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n-use crate::session::{CompileResult, CrateDisambiguator};\n+use crate::session::CrateDisambiguator;\n use crate::session::config::{EntryFnType, OutputFilenames, OptLevel};\n use crate::traits::{self, Vtable};\n use crate::traits::query::{\n@@ -36,8 +36,8 @@ use crate::traits::specialization_graph;\n use crate::traits::Clauses;\n use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt, AdtSizedConstraint};\n use crate::ty::steal::Steal;\n-use crate::ty::subst::Substs;\n use crate::ty::util::NeedsDrop;\n+use crate::ty::subst::SubstsRef;\n use crate::util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n use crate::util::common::{ErrorReported};\n use crate::util::profiling::ProfileCategory::*;\n@@ -99,6 +99,9 @@ pub use self::on_disk_cache::OnDiskCache;\n // as they will raise an fatal error on query cycles instead.\n define_queries! { <'tcx>\n     Other {\n+        /// Run analysis passes on the crate\n+        [] fn analysis: Analysis(CrateNum) -> Result<(), ErrorReported>,\n+\n         /// Records the type of every item.\n         [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n \n@@ -290,7 +293,8 @@ define_queries! { <'tcx>\n     },\n \n     TypeChecking {\n-        [] fn typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n+        [] fn typeck_item_bodies:\n+                typeck_item_bodies_dep_node(CrateNum) -> Result<(), ErrorReported>,\n \n         [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n     },\n@@ -346,8 +350,9 @@ define_queries! { <'tcx>\n         [] fn check_match: CheckMatch(DefId)\n             -> Result<(), ErrorReported>,\n \n-        /// Performs the privacy check and computes \"access levels\".\n+        /// Performs part of the privacy check and computes \"access levels\".\n         [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Lrc<AccessLevels>,\n+        [] fn check_private_in_public: CheckPrivateInPublic(CrateNum) -> (),\n     },\n \n     Other {\n@@ -393,7 +398,7 @@ define_queries! { <'tcx>\n \n     Other {\n         [] fn vtable_methods: vtable_methods_node(ty::PolyTraitRef<'tcx>)\n-                            -> Lrc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>,\n+                            -> Lrc<Vec<Option<(DefId, SubstsRef<'tcx>)>>>,\n     },\n \n     Codegen {\n@@ -493,9 +498,9 @@ define_queries! { <'tcx>\n \n     Codegen {\n         [] fn upstream_monomorphizations: UpstreamMonomorphizations(CrateNum)\n-            -> Lrc<DefIdMap<Lrc<FxHashMap<&'tcx Substs<'tcx>, CrateNum>>>>,\n+            -> Lrc<DefIdMap<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>>>,\n         [] fn upstream_monomorphizations_for: UpstreamMonomorphizationsFor(DefId)\n-            -> Option<Lrc<FxHashMap<&'tcx Substs<'tcx>, CrateNum>>>,\n+            -> Option<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>>,\n     },\n \n     Other {\n@@ -714,7 +719,7 @@ define_queries! { <'tcx>\n         >,\n \n         [] fn substitute_normalize_and_test_predicates:\n-            substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n+            substitute_normalize_and_test_predicates_node((DefId, SubstsRef<'tcx>)) -> bool,\n \n         [] fn method_autoderef_steps: MethodAutoderefSteps(\n             CanonicalTyGoal<'tcx>\n@@ -906,7 +911,7 @@ fn vtable_methods_node<'tcx>(trait_ref: ty::PolyTraitRef<'tcx>) -> DepConstructo\n     DepConstructor::VtableMethods{ trait_ref }\n }\n \n-fn substitute_normalize_and_test_predicates_node<'tcx>(key: (DefId, &'tcx Substs<'tcx>))\n+fn substitute_normalize_and_test_predicates_node<'tcx>(key: (DefId, SubstsRef<'tcx>))\n                                             -> DepConstructor<'tcx> {\n     DepConstructor::SubstituteNormalizeAndTestPredicates { key }\n }"}, {"sha": "e3276ba0bea7bc17822dff9393eb40205f8bd5eb", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1251,6 +1251,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n             force!(crate_inherent_impls_overlap_check, LOCAL_CRATE)\n         },\n         DepKind::PrivacyAccessLevels => { force!(privacy_access_levels, LOCAL_CRATE); }\n+        DepKind::CheckPrivateInPublic => { force!(check_private_in_public, LOCAL_CRATE); }\n         DepKind::MirBuilt => { force!(mir_built, def_id!()); }\n         DepKind::MirConstQualif => { force!(mir_const_qualif, def_id!()); }\n         DepKind::MirConst => { force!(mir_const, def_id!()); }\n@@ -1357,6 +1358,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::CrateHash => { force!(crate_hash, krate!()); }\n         DepKind::OriginalCrateName => { force!(original_crate_name, krate!()); }\n         DepKind::ExtraFileName => { force!(extra_filename, krate!()); }\n+        DepKind::Analysis => { force!(analysis, krate!()); }\n \n         DepKind::AllTraitImplementations => {\n             force!(all_trait_implementations, krate!());"}, {"sha": "3a31801b3be39f2c0728007f0319d6e89d810317", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -5,7 +5,7 @@\n //! subtyping, type equality, etc.\n \n use crate::hir::def_id::DefId;\n-use crate::ty::subst::{Kind, UnpackedKind, Substs};\n+use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::mir::interpret::GlobalId;\n@@ -50,9 +50,9 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n     /// accordingly.\n     fn relate_item_substs(&mut self,\n                           item_def_id: DefId,\n-                          a_subst: &'tcx Substs<'tcx>,\n-                          b_subst: &'tcx Substs<'tcx>)\n-                          -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+                          a_subst: SubstsRef<'tcx>,\n+                          b_subst: SubstsRef<'tcx>)\n+                          -> RelateResult<'tcx, SubstsRef<'tcx>>\n     {\n         debug!(\"relate_item_substs(item_def_id={:?}, a_subst={:?}, b_subst={:?})\",\n                item_def_id,\n@@ -123,9 +123,9 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n \n pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                                         variances: Option<&Vec<ty::Variance>>,\n-                                        a_subst: &'tcx Substs<'tcx>,\n-                                        b_subst: &'tcx Substs<'tcx>)\n-                                        -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+                                        a_subst: SubstsRef<'tcx>,\n+                                        b_subst: SubstsRef<'tcx>)\n+                                        -> RelateResult<'tcx, SubstsRef<'tcx>>\n     where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let tcx = relation.tcx();\n@@ -147,9 +147,9 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n     {\n         let tcx = relation.tcx();\n \n-        if a.variadic != b.variadic {\n+        if a.c_variadic != b.c_variadic {\n             return Err(TypeError::VariadicMismatch(\n-                expected_found(relation, &a.variadic, &b.variadic)));\n+                expected_found(relation, &a.c_variadic, &b.c_variadic)));\n         }\n         let unsafety = relation.relate(&a.unsafety, &b.unsafety)?;\n         let abi = relation.relate(&a.abi, &b.abi)?;\n@@ -171,7 +171,7 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n             });\n         Ok(ty::FnSig {\n             inputs_and_output: tcx.mk_type_list(inputs_and_output)?,\n-            variadic: a.variadic,\n+            c_variadic: a.c_variadic,\n             unsafety,\n             abi,\n         })\n@@ -624,11 +624,11 @@ impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx Substs<'tcx> {\n+impl<'tcx> Relate<'tcx> for SubstsRef<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &&'tcx Substs<'tcx>,\n-                           b: &&'tcx Substs<'tcx>)\n-                           -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+                           a: &SubstsRef<'tcx>,\n+                           b: &SubstsRef<'tcx>)\n+                           -> RelateResult<'tcx, SubstsRef<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relate_substs(relation, None, a, b)\n@@ -705,6 +705,9 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n             (UnpackedKind::Type(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n             }\n+            (UnpackedKind::Const(_), _) => {\n+                unimplemented!() // FIXME(const_generics)\n+            }\n         }\n     }\n }"}, {"sha": "f9eb336a4a3e2def619c58c7678b937e3d7fcc23", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -5,12 +5,13 @@\n \n use crate::mir::ProjectionKind;\n use crate::mir::interpret::ConstValue;\n-use crate::ty::{self, Lift, Ty, TyCtxt};\n+use crate::ty::{self, Lift, Ty, TyCtxt, ConstVid, InferConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use smallvec::SmallVec;\n use crate::mir::interpret;\n \n+use std::marker::PhantomData;\n use std::rc::Rc;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -49,6 +50,7 @@ CloneTypeFoldableAndLiftImpls! {\n     crate::ty::BoundRegion,\n     crate::ty::ClosureKind,\n     crate::ty::IntVarValue,\n+    crate::ty::ParamConst,\n     crate::ty::ParamTy,\n     crate::ty::UniverseIndex,\n     crate::ty::Variance,\n@@ -396,7 +398,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n         tcx.lift(&self.inputs_and_output).map(|x| {\n             ty::FnSig {\n                 inputs_and_output: x,\n-                variadic: self.variadic,\n+                c_variadic: self.c_variadic,\n                 unsafety: self.unsafety,\n                 abi: self.abi,\n             }\n@@ -503,6 +505,14 @@ impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n     type Lifted = ConstValue<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n+            ConstValue::Param(param) => Some(ConstValue::Param(param)),\n+            ConstValue::Infer(infer) => {\n+                Some(ConstValue::Infer(match infer {\n+                    InferConst::Var(vid) => InferConst::Var(vid.lift_to_tcx(tcx)?),\n+                    InferConst::Fresh(i) => InferConst::Fresh(i),\n+                    InferConst::Canonical(debrujin, var) => InferConst::Canonical(debrujin, var),\n+                }))\n+            }\n             ConstValue::Scalar(x) => Some(ConstValue::Scalar(x)),\n             ConstValue::Slice(x, y) => Some(ConstValue::Slice(x, y)),\n             ConstValue::ByRef(ptr, alloc) => Some(ConstValue::ByRef(\n@@ -512,6 +522,16 @@ impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ConstVid<'a> {\n+    type Lifted = ConstVid<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, _: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        Some(ConstVid {\n+            index: self.index,\n+            phantom: PhantomData,\n+        })\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n //\n@@ -832,7 +852,7 @@ BraceStructTypeFoldableImpl! {\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n-        inputs_and_output, variadic, unsafety, abi\n+        inputs_and_output, c_variadic, unsafety, abi\n     }\n }\n "}, {"sha": "39728cc8cd5cba9916b691439f4cf3e5b26567e4", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 175, "deletions": 78, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -7,7 +7,8 @@ use crate::mir::interpret::{ConstValue, truncate};\n use crate::middle::region;\n use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n-use crate::ty::subst::{Substs, Subst, Kind, UnpackedKind};\n+use rustc_macros::HashStable;\n+use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, Kind, UnpackedKind};\n use crate::ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n use crate::util::captures::Captures;\n@@ -16,6 +17,7 @@ use crate::mir::interpret::{Scalar, Pointer};\n use smallvec::SmallVec;\n use std::iter;\n use std::cmp::Ordering;\n+use std::marker::PhantomData;\n use rustc_target::spec::abi;\n use syntax::ast::{self, Ident};\n use syntax::symbol::{keywords, InternedString};\n@@ -24,14 +26,15 @@ use serialize;\n use self::InferTy::*;\n use self::TyKind::*;\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct TypeAndMut<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub mutbl: hir::Mutability,\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable, Copy)]\n+         RustcEncodable, RustcDecodable, Copy, HashStable)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n@@ -40,7 +43,7 @@ pub struct FreeRegion {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable, Copy)]\n+         RustcEncodable, RustcDecodable, Copy, HashStable)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(u32),\n@@ -81,7 +84,8 @@ impl BoundRegion {\n \n /// N.B., if you change this, you'll probably want to change the corresponding\n /// AST structure in `libsyntax/ast.rs` as well.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub enum TyKind<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n@@ -101,11 +105,11 @@ pub enum TyKind<'tcx> {\n \n     /// Structures, enumerations and unions.\n     ///\n-    /// Substs here, possibly against intuition, *may* contain `Param`s.\n+    /// InternalSubsts here, possibly against intuition, *may* contain `Param`s.\n     /// That is, even after substitution it is possible that there are type\n     /// variables. This happens when the `Adt` corresponds to an ADT\n     /// definition and not a concrete use of it.\n-    Adt(&'tcx AdtDef, &'tcx Substs<'tcx>),\n+    Adt(&'tcx AdtDef, SubstsRef<'tcx>),\n \n     /// An unsized FFI type that is opaque to Rust. Written as `extern type T`.\n     Foreign(DefId),\n@@ -136,7 +140,7 @@ pub enum TyKind<'tcx> {\n     /// fn foo() -> i32 { 1 }\n     /// let bar = foo; // bar: fn() -> i32 {foo}\n     /// ```\n-    FnDef(DefId, &'tcx Substs<'tcx>),\n+    FnDef(DefId, SubstsRef<'tcx>),\n \n     /// A pointer to a function. Written as `fn() -> i32`.\n     ///\n@@ -184,7 +188,7 @@ pub enum TyKind<'tcx> {\n     /// * or the `existential type` declaration\n     /// The substitutions are for the generics of the function in question.\n     /// After typeck, the concrete type can be found in the `types` map.\n-    Opaque(DefId, &'tcx Substs<'tcx>),\n+    Opaque(DefId, SubstsRef<'tcx>),\n \n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     Param(ParamTy),\n@@ -302,14 +306,15 @@ static_assert!(MEM_SIZE_OF_TY_KIND: ::std::mem::size_of::<TyKind<'_>>() == 24);\n ///\n /// It'd be nice to split this struct into ClosureSubsts and\n /// GeneratorSubsts, I believe. -nmatsakis\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n     /// concatenated with the types of the upvars.\n     ///\n     /// These are separated out because codegen wants to pass them around\n     /// when monomorphizing.\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n }\n \n /// Struct returned by `split()`. Note that these are subslices of the\n@@ -385,9 +390,10 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct GeneratorSubsts<'tcx> {\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n }\n \n struct SplitGeneratorSubsts<'tcx> {\n@@ -518,7 +524,8 @@ impl<'tcx> UpvarSubsts<'tcx> {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub enum ExistentialPredicate<'tcx> {\n     /// E.g., `Iterator`.\n     Trait(ExistentialTraitRef<'tcx>),\n@@ -669,14 +676,14 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n /// Note that a `TraitRef` introduces a level of region binding, to\n /// account for higher-ranked trait bounds like `T: for<'a> Foo<&'a U>`\n /// or higher-ranked object types.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n }\n \n impl<'tcx> TraitRef<'tcx> {\n-    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>) -> TraitRef<'tcx> {\n+    pub fn new(def_id: DefId, substs: SubstsRef<'tcx>) -> TraitRef<'tcx> {\n         TraitRef { def_id: def_id, substs: substs }\n     }\n \n@@ -685,7 +692,7 @@ impl<'tcx> TraitRef<'tcx> {\n     pub fn identity<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> TraitRef<'tcx> {\n         TraitRef {\n             def_id,\n-            substs: Substs::identity_for_item(tcx, def_id),\n+            substs: InternalSubsts::identity_for_item(tcx, def_id),\n         }\n     }\n \n@@ -704,7 +711,7 @@ impl<'tcx> TraitRef<'tcx> {\n \n     pub fn from_method(tcx: TyCtxt<'_, '_, 'tcx>,\n                        trait_id: DefId,\n-                       substs: &Substs<'tcx>)\n+                       substs: SubstsRef<'tcx>)\n                        -> ty::TraitRef<'tcx> {\n         let defs = tcx.generics_of(trait_id);\n \n@@ -739,10 +746,11 @@ impl<'tcx> PolyTraitRef<'tcx> {\n ///\n /// The substitutions don't include the erased `Self`, only trait\n /// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct ExistentialTraitRef<'tcx> {\n     pub def_id: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n@@ -912,10 +920,11 @@ impl<T> Binder<T> {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n \n     /// The `DefId` of the `TraitItem` for the associated type `N`.\n     ///\n@@ -957,7 +966,7 @@ impl<'a, 'tcx> ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GenSig<'tcx> {\n     pub yield_ty: Ty<'tcx>,\n     pub return_ty: Ty<'tcx>,\n@@ -977,13 +986,14 @@ impl<'tcx> PolyGenSig<'tcx> {\n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n-/// - `inputs` is the list of arguments and their modes.\n-/// - `output` is the return type.\n-/// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+/// - `inputs`: is the list of arguments and their modes.\n+/// - `output`: is the return type.\n+/// - `c_variadic`: indicates whether this is a C-variadic function.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct FnSig<'tcx> {\n     pub inputs_and_output: &'tcx List<Ty<'tcx>>,\n-    pub variadic: bool,\n+    pub c_variadic: bool,\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n }\n@@ -1016,8 +1026,8 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.output())\n     }\n-    pub fn variadic(&self) -> bool {\n-        self.skip_binder().variadic\n+    pub fn c_variadic(&self) -> bool {\n+        self.skip_binder().c_variadic\n     }\n     pub fn unsafety(&self) -> hir::Unsafety {\n         self.skip_binder().unsafety\n@@ -1030,7 +1040,8 @@ impl<'tcx> PolyFnSig<'tcx> {\n pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<FnSig<'tcx>>>;\n \n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ParamTy {\n     pub idx: u32,\n     pub name: InternedString,\n@@ -1061,46 +1072,67 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n }\n \n-/// A [De Bruijn index][dbi] is a standard means of representing\n-/// regions (and perhaps later types) in a higher-ranked setting. In\n-/// particular, imagine a type like this:\n-///\n-///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n-///     ^          ^            |        |         |\n-///     |          |            |        |         |\n-///     |          +------------+ 0      |         |\n-///     |                                |         |\n-///     +--------------------------------+ 1       |\n-///     |                                          |\n-///     +------------------------------------------+ 0\n-///\n-/// In this type, there are two binders (the outer fn and the inner\n-/// fn). We need to be able to determine, for any given region, which\n-/// fn type it is bound by, the inner or the outer one. There are\n-/// various ways you can do this, but a De Bruijn index is one of the\n-/// more convenient and has some nice properties. The basic idea is to\n-/// count the number of binders, inside out. Some examples should help\n-/// clarify what I mean.\n-///\n-/// Let's start with the reference type `&'b isize` that is the first\n-/// argument to the inner function. This region `'b` is assigned a De\n-/// Bruijn index of 0, meaning \"the innermost binder\" (in this case, a\n-/// fn). The region `'a` that appears in the second argument type (`&'a\n-/// isize`) would then be assigned a De Bruijn index of 1, meaning \"the\n-/// second-innermost binder\". (These indices are written on the arrays\n-/// in the diagram).\n-///\n-/// What is interesting is that De Bruijn index attached to a particular\n-/// variable will vary depending on where it appears. For example,\n-/// the final type `&'a char` also refers to the region `'a` declared on\n-/// the outermost fn. But this time, this reference is not nested within\n-/// any other binders (i.e., it is not an argument to the inner fn, but\n-/// rather the outer one). Therefore, in this case, it is assigned a\n-/// De Bruijn index of 0, because the innermost binder in that location\n-/// is the outer fn.\n-///\n-/// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n+#[derive(Copy, Clone, Hash, RustcEncodable, RustcDecodable,\n+         Eq, PartialEq, Ord, PartialOrd, HashStable)]\n+pub struct ParamConst {\n+    pub index: u32,\n+    pub name: InternedString,\n+}\n+\n+impl<'a, 'gcx, 'tcx> ParamConst {\n+    pub fn new(index: u32, name: InternedString) -> ParamConst {\n+        ParamConst { index, name }\n+    }\n+\n+    pub fn for_def(def: &ty::GenericParamDef) -> ParamConst {\n+        ParamConst::new(def.index, def.name)\n+    }\n+\n+    pub fn to_const(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx LazyConst<'tcx> {\n+        tcx.mk_const_param(self.index, self.name, ty)\n+    }\n+}\n+\n newtype_index! {\n+    /// A [De Bruijn index][dbi] is a standard means of representing\n+    /// regions (and perhaps later types) in a higher-ranked setting. In\n+    /// particular, imagine a type like this:\n+    ///\n+    ///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n+    ///     ^          ^            |        |         |\n+    ///     |          |            |        |         |\n+    ///     |          +------------+ 0      |         |\n+    ///     |                                |         |\n+    ///     +--------------------------------+ 1       |\n+    ///     |                                          |\n+    ///     +------------------------------------------+ 0\n+    ///\n+    /// In this type, there are two binders (the outer fn and the inner\n+    /// fn). We need to be able to determine, for any given region, which\n+    /// fn type it is bound by, the inner or the outer one. There are\n+    /// various ways you can do this, but a De Bruijn index is one of the\n+    /// more convenient and has some nice properties. The basic idea is to\n+    /// count the number of binders, inside out. Some examples should help\n+    /// clarify what I mean.\n+    ///\n+    /// Let's start with the reference type `&'b isize` that is the first\n+    /// argument to the inner function. This region `'b` is assigned a De\n+    /// Bruijn index of 0, meaning \"the innermost binder\" (in this case, a\n+    /// fn). The region `'a` that appears in the second argument type (`&'a\n+    /// isize`) would then be assigned a De Bruijn index of 1, meaning \"the\n+    /// second-innermost binder\". (These indices are written on the arrays\n+    /// in the diagram).\n+    ///\n+    /// What is interesting is that De Bruijn index attached to a particular\n+    /// variable will vary depending on where it appears. For example,\n+    /// the final type `&'a char` also refers to the region `'a` declared on\n+    /// the outermost fn. But this time, this reference is not nested within\n+    /// any other binders (i.e., it is not an argument to the inner fn, but\n+    /// rather the outer one). Therefore, in this case, it is assigned a\n+    /// De Bruijn index of 0, because the innermost binder in that location\n+    /// is the outer fn.\n+    ///\n+    /// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n     pub struct DebruijnIndex {\n         DEBUG_FORMAT = \"DebruijnIndex({})\",\n         const INNERMOST = 0,\n@@ -1120,7 +1152,7 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// These are regions that are stored behind a binder and must be substituted\n /// with some concrete region before being used. There are two kind of\n /// bound regions: early-bound, which are bound in an item's `Generics`,\n-/// and are substituted by a `Substs`, and late-bound, which are part of\n+/// and are substituted by a `InternalSubsts`, and late-bound, which are part of\n /// higher-ranked types (e.g., `for<'a> fn(&'a ())`), and are substituted by\n /// the likes of `liberate_late_bound_regions`. The distinction exists\n /// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n@@ -1229,6 +1261,12 @@ pub struct TyVid {\n     pub index: u32,\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub struct ConstVid<'tcx> {\n+    pub index: u32,\n+    pub phantom: PhantomData<&'tcx ()>,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct IntVid {\n     pub index: u32,\n@@ -1251,7 +1289,8 @@ impl Atom for RegionVid {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n@@ -1294,10 +1333,11 @@ impl From<BoundVar> for BoundTy {\n }\n \n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ExistentialProjection<'tcx> {\n     pub item_def_id: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n     pub ty: Ty<'tcx>,\n }\n \n@@ -2056,11 +2096,12 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable,\n+         Eq, PartialEq, Ord, PartialOrd, HashStable)]\n /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to `Evaluated` if the\n /// code is monomorphic enough for that.\n pub enum LazyConst<'tcx> {\n-    Unevaluated(DefId, &'tcx Substs<'tcx>),\n+    Unevaluated(DefId, SubstsRef<'tcx>),\n     Evaluated(Const<'tcx>),\n }\n \n@@ -2083,10 +2124,27 @@ impl<'tcx> LazyConst<'tcx> {\n     pub fn unwrap_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n         self.assert_usize(tcx).expect(\"expected `LazyConst` to contain a usize\")\n     }\n+\n+    pub fn type_flags(&self) -> TypeFlags {\n+        // FIXME(const_generics): incorporate substs flags.\n+        let flags = match self {\n+            LazyConst::Unevaluated(..) => {\n+                TypeFlags::HAS_NORMALIZABLE_PROJECTION | TypeFlags::HAS_PROJECTION\n+            }\n+            LazyConst::Evaluated(c) => {\n+                c.type_flags()\n+            }\n+        };\n+\n+        debug!(\"type_flags({:?}) = {:?}\", self, flags);\n+\n+        flags\n+    }\n }\n \n /// Typed constant value.\n-#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable,\n+         Eq, PartialEq, Ord, PartialOrd, HashStable)]\n pub struct Const<'tcx> {\n     pub ty: Ty<'tcx>,\n \n@@ -2198,6 +2256,45 @@ impl<'tcx> Const<'tcx> {\n         self.assert_usize(tcx).unwrap_or_else(||\n             bug!(\"expected constant usize, got {:#?}\", self))\n     }\n+\n+    pub fn type_flags(&self) -> TypeFlags {\n+        let mut flags = self.ty.flags;\n+\n+        match self.val {\n+            ConstValue::Param(_) => {\n+                flags |= TypeFlags::HAS_FREE_LOCAL_NAMES;\n+                flags |= TypeFlags::HAS_PARAMS;\n+            }\n+            ConstValue::Infer(infer) => {\n+                flags |= TypeFlags::HAS_FREE_LOCAL_NAMES;\n+                flags |= TypeFlags::HAS_CT_INFER;\n+                match infer {\n+                    InferConst::Fresh(_) |\n+                    InferConst::Canonical(_, _) => {}\n+                    InferConst::Var(_) => {\n+                        flags |= TypeFlags::KEEP_IN_LOCAL_TCX;\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        debug!(\"type_flags({:?}) = {:?}\", self, flags);\n+\n+        flags\n+    }\n }\n \n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx LazyConst<'tcx> {}\n+\n+/// An inference variable for a const, for use in const generics.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd,\n+         Ord, RustcEncodable, RustcDecodable, Hash, HashStable)]\n+pub enum InferConst<'tcx> {\n+    /// Infer the value of the const.\n+    Var(ConstVid<'tcx>),\n+    /// A fresh const variable. See `infer::freshen` for more details.\n+    Fresh(u32),\n+    /// Canonicalized const variable, used only when preparing a trait query.\n+    Canonical(DebruijnIndex, BoundVar),\n+}"}, {"sha": "38be19a71c48cbdba1c387a74bf602b770c66ab6", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 138, "deletions": 31, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -2,12 +2,14 @@\n \n use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;\n-use crate::ty::{self, Lift, List, Ty, TyCtxt};\n+use crate::ty::{self, Lift, List, Ty, TyCtxt, InferConst, ParamConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::mir::interpret::ConstValue;\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n use smallvec::SmallVec;\n+use rustc_macros::HashStable;\n \n use core::intrinsics;\n use std::cmp::Ordering;\n@@ -17,24 +19,26 @@ use std::mem;\n use std::num::NonZeroUsize;\n \n /// An entity in the Rust type system, which can be one of\n-/// several kinds (only types and lifetimes for now).\n+/// several kinds (types, lifetimes, and consts).\n /// To reduce memory usage, a `Kind` is a interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n-/// indicate the type (`Ty` or `Region`) it points to.\n+/// indicate the type (`Ty`, `Region`, or `Const`) it points to.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Kind<'tcx> {\n     ptr: NonZeroUsize,\n-    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>)>\n+    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>, &'tcx ty::LazyConst<'tcx>)>\n }\n \n const TAG_MASK: usize = 0b11;\n const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n+const CONST_TAG: usize = 0b10;\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Debug, RustcEncodable, RustcDecodable, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n pub enum UnpackedKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n+    Const(&'tcx ty::LazyConst<'tcx>),\n }\n \n impl<'tcx> UnpackedKind<'tcx> {\n@@ -50,6 +54,11 @@ impl<'tcx> UnpackedKind<'tcx> {\n                 assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n                 (TYPE_TAG, ty as *const _ as usize)\n             }\n+            UnpackedKind::Const(ct) => {\n+                // Ensure we can use the tag bits.\n+                assert_eq!(mem::align_of_val(ct) & TAG_MASK, 0);\n+                (CONST_TAG, ct as *const _ as usize)\n+            }\n         };\n \n         Kind {\n@@ -85,6 +94,12 @@ impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n     }\n }\n \n+impl<'tcx> From<&'tcx ty::LazyConst<'tcx>> for Kind<'tcx> {\n+    fn from(c: &'tcx ty::LazyConst<'tcx>) -> Kind<'tcx> {\n+        UnpackedKind::Const(c).pack()\n+    }\n+}\n+\n impl<'tcx> Kind<'tcx> {\n     #[inline]\n     pub fn unpack(self) -> UnpackedKind<'tcx> {\n@@ -93,6 +108,7 @@ impl<'tcx> Kind<'tcx> {\n             match ptr & TAG_MASK {\n                 REGION_TAG => UnpackedKind::Lifetime(&*((ptr & !TAG_MASK) as *const _)),\n                 TYPE_TAG => UnpackedKind::Type(&*((ptr & !TAG_MASK) as *const _)),\n+                CONST_TAG => UnpackedKind::Const(&*((ptr & !TAG_MASK) as *const _)),\n                 _ => intrinsics::unreachable()\n             }\n         }\n@@ -104,6 +120,7 @@ impl<'tcx> fmt::Debug for Kind<'tcx> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => write!(f, \"{:?}\", lt),\n             UnpackedKind::Type(ty) => write!(f, \"{:?}\", ty),\n+            UnpackedKind::Const(ct) => write!(f, \"{:?}\", ct),\n         }\n     }\n }\n@@ -113,6 +130,7 @@ impl<'tcx> fmt::Display for Kind<'tcx> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => write!(f, \"{}\", lt),\n             UnpackedKind::Type(ty) => write!(f, \"{}\", ty),\n+            UnpackedKind::Const(ct) => write!(f, \"{}\", ct),\n         }\n     }\n }\n@@ -122,8 +140,9 @@ impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n \n     fn lift_to_tcx<'cx, 'gcx>(&self, tcx: TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n-            UnpackedKind::Lifetime(a) => a.lift_to_tcx(tcx).map(|a| a.into()),\n-            UnpackedKind::Type(a) => a.lift_to_tcx(tcx).map(|a| a.into()),\n+            UnpackedKind::Lifetime(lt) => lt.lift_to_tcx(tcx).map(|lt| lt.into()),\n+            UnpackedKind::Type(ty) => ty.lift_to_tcx(tcx).map(|ty| ty.into()),\n+            UnpackedKind::Const(ct) => ct.lift_to_tcx(tcx).map(|ct| ct.into()),\n         }\n     }\n }\n@@ -133,13 +152,15 @@ impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => lt.fold_with(folder).into(),\n             UnpackedKind::Type(ty) => ty.fold_with(folder).into(),\n+            UnpackedKind::Const(ct) => ct.fold_with(folder).into(),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => lt.visit_with(visitor),\n             UnpackedKind::Type(ty) => ty.visit_with(visitor),\n+            UnpackedKind::Const(ct) => ct.visit_with(visitor),\n         }\n     }\n }\n@@ -157,26 +178,28 @@ impl<'tcx> Decodable for Kind<'tcx> {\n }\n \n /// A substitution mapping generic parameters to new values.\n-pub type Substs<'tcx> = List<Kind<'tcx>>;\n+pub type InternalSubsts<'tcx> = List<Kind<'tcx>>;\n+\n+pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;\n \n-impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n-    /// Creates a `Substs` that maps each generic parameter to itself.\n+impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n+    /// Creates a `InternalSubsts` that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n-                             -> &'tcx Substs<'tcx> {\n-        Substs::for_item(tcx, def_id, |param, _| {\n+                             -> SubstsRef<'tcx> {\n+        Self::for_item(tcx, def_id, |param, _| {\n             tcx.mk_param_from_def(param)\n         })\n     }\n \n-    /// Creates a `Substs` that maps each generic parameter to a higher-ranked\n+    /// Creates a `InternalSubsts` that maps each generic parameter to a higher-ranked\n     /// var bound at index `0`. For types, we use a `BoundVar` index equal to\n     /// the type parameter index. For regions, we use the `BoundRegion::BrNamed`\n     /// variant (which has a `DefId`).\n     pub fn bound_vars_for_item(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         def_id: DefId\n-    ) -> &'tcx Substs<'tcx> {\n-        Substs::for_item(tcx, def_id, |param, _| {\n+    ) -> SubstsRef<'tcx> {\n+        Self::for_item(tcx, def_id, |param, _| {\n             match param.kind {\n                 ty::GenericParamDefKind::Type { .. } => {\n                     tcx.mk_ty(\n@@ -193,36 +216,45 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                         ty::BoundRegion::BrNamed(param.def_id, param.name)\n                     )).into()\n                 }\n+\n+                ty::GenericParamDefKind::Const => {\n+                    tcx.mk_lazy_const(ty::LazyConst::Evaluated(ty::Const {\n+                        val: ConstValue::Infer(\n+                            InferConst::Canonical(ty::INNERMOST, ty::BoundVar::from(param.index))\n+                        ),\n+                        ty: tcx.type_of(def_id),\n+                    })).into()\n+                }\n             }\n         })\n     }\n \n-    /// Creates a `Substs` for generic parameter definitions,\n+    /// Creates a `InternalSubsts` for generic parameter definitions,\n     /// by calling closures to obtain each kind.\n-    /// The closures get to observe the `Substs` as they're\n+    /// The closures get to observe the `InternalSubsts` as they're\n     /// being built, which can be used to correctly\n     /// substitute defaults of generic parameters.\n     pub fn for_item<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                        def_id: DefId,\n                        mut mk_kind: F)\n-                       -> &'tcx Substs<'tcx>\n+                       -> SubstsRef<'tcx>\n     where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n     {\n         let defs = tcx.generics_of(def_id);\n         let count = defs.count();\n         let mut substs = SmallVec::with_capacity(count);\n-        Substs::fill_item(&mut substs, tcx, defs, &mut mk_kind);\n+        Self::fill_item(&mut substs, tcx, defs, &mut mk_kind);\n         tcx.intern_substs(&substs)\n     }\n \n     pub fn extend_to<F>(&self,\n                         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                         def_id: DefId,\n                         mut mk_kind: F)\n-                        -> &'tcx Substs<'tcx>\n+                        -> SubstsRef<'tcx>\n     where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n     {\n-        Substs::for_item(tcx, def_id, |param, substs| {\n+        Self::for_item(tcx, def_id, |param, substs| {\n             self.get(param.index as usize)\n                 .cloned()\n                 .unwrap_or_else(|| mk_kind(param, substs))\n@@ -237,9 +269,9 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     {\n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.generics_of(def_id);\n-            Substs::fill_item(substs, tcx, parent_defs, mk_kind);\n+            Self::fill_item(substs, tcx, parent_defs, mk_kind);\n         }\n-        Substs::fill_single(substs, defs, mk_kind)\n+        Self::fill_single(substs, defs, mk_kind)\n     }\n \n     fn fill_single<F>(substs: &mut SmallVec<[Kind<'tcx>; 8]>,\n@@ -281,6 +313,29 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         })\n     }\n \n+    #[inline]\n+    pub fn consts(&'a self) -> impl DoubleEndedIterator<Item = &'tcx ty::LazyConst<'tcx>> + 'a {\n+        self.iter().filter_map(|k| {\n+            if let UnpackedKind::Const(ct) = k.unpack() {\n+                Some(ct)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn non_erasable_generics(\n+        &'a self\n+    ) -> impl DoubleEndedIterator<Item = UnpackedKind<'tcx>> + 'a {\n+        self.iter().filter_map(|k| {\n+            match k.unpack() {\n+                UnpackedKind::Lifetime(_) => None,\n+                generic => Some(generic),\n+            }\n+        })\n+    }\n+\n     #[inline]\n     pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n         if let UnpackedKind::Type(ty) = self[i].unpack() {\n@@ -299,6 +354,15 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn const_at(&self, i: usize) -> &'tcx ty::LazyConst<'tcx> {\n+        if let UnpackedKind::Const(ct) = self[i].unpack() {\n+            ct\n+        } else {\n+            bug!(\"expected const for param #{} in {:?}\", i, self);\n+        }\n+    }\n+\n     #[inline]\n     pub fn type_for_def(&self, def: &ty::GenericParamDef) -> Kind<'tcx> {\n         self.type_at(def.index as usize).into()\n@@ -311,19 +375,19 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     /// parameters (e.g., method parameters) on top of that base.\n     pub fn rebase_onto(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                        source_ancestor: DefId,\n-                       target_substs: &Substs<'tcx>)\n-                       -> &'tcx Substs<'tcx> {\n+                       target_substs: SubstsRef<'tcx>)\n+                       -> SubstsRef<'tcx> {\n         let defs = tcx.generics_of(source_ancestor);\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.params.len()..]).cloned())\n     }\n \n     pub fn truncate_to(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, generics: &ty::Generics)\n-                       -> &'tcx Substs<'tcx> {\n+                       -> SubstsRef<'tcx> {\n         tcx.mk_substs(self.iter().take(generics.count()).cloned())\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let params: SmallVec<[_; 8]> = self.iter().map(|k| k.fold_with(folder)).collect();\n \n@@ -341,7 +405,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for SubstsRef<'tcx> {}\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n@@ -467,6 +531,21 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n \n         return t1;\n     }\n+\n+    fn fold_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+        if !c.needs_subst() {\n+            return c;\n+        }\n+\n+        if let ty::LazyConst::Evaluated(ty::Const {\n+            val: ConstValue::Param(p),\n+            ..\n+        }) = c {\n+            self.const_for_param(*p, c)\n+        } else {\n+            c.super_fold_with(self)\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n@@ -492,6 +571,34 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n         self.shift_vars_through_binders(ty)\n     }\n \n+    fn const_for_param(\n+        &self,\n+        p: ParamConst,\n+        source_cn: &'tcx ty::LazyConst<'tcx>\n+    ) -> &'tcx ty::LazyConst<'tcx> {\n+        // Look up the const in the substitutions. It really should be in there.\n+        let opt_cn = self.substs.get(p.index as usize).map(|k| k.unpack());\n+        let cn = match opt_cn {\n+            Some(UnpackedKind::Const(cn)) => cn,\n+            _ => {\n+                let span = self.span.unwrap_or(DUMMY_SP);\n+                span_bug!(\n+                    span,\n+                    \"Const parameter `{:?}` ({:?}/{}) out of range \\\n+                     when substituting (root type={:?}) substs={:?}\",\n+                    p,\n+                    source_cn,\n+                    p.index,\n+                    self.root_ty,\n+                    self.substs,\n+                );\n+            }\n+        };\n+\n+        // FIXME(const_generics): shift const through binders\n+        cn\n+    }\n+\n     /// It is sometimes necessary to adjust the De Bruijn indices during substitution. This occurs\n     /// when we are substituting a type with escaping bound vars into a context where we have\n     /// passed through binders. That's quite a mouthful. Let's see an example:\n@@ -560,10 +667,10 @@ pub type CanonicalUserSubsts<'tcx> = Canonical<'tcx, UserSubsts<'tcx>>;\n \n /// Stores the user-given substs to reach some fully qualified path\n /// (e.g., `<T>::Item` or `<T as Trait>::Item`).\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserSubsts<'tcx> {\n     /// The substitutions for the item as given by the user.\n-    pub substs: &'tcx Substs<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n \n     /// The self type, in the case of a `<T>::Item` path (when applied\n     /// to an inherent impl). See `UserSelfTy` below.\n@@ -601,7 +708,7 @@ BraceStructLiftImpl! {\n /// the impl (with the substs from `UserSubsts`) and apply those to\n /// the self type, giving `Foo<?A>`. Finally, we unify that with\n /// the self type here, which contains `?A` to be `&'static u32`\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserSelfTy<'tcx> {\n     pub impl_def_id: DefId,\n     pub self_ty: Ty<'tcx>,"}, {"sha": "b25a6c4f28c77f6ab9b6ce4f9e4a20aa7a6c8cb8", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -11,9 +11,13 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use rustc_data_structures::sync::Lrc;\n+use rustc_macros::HashStable;\n \n /// A trait's definition with type information.\n+#[derive(HashStable)]\n pub struct TraitDef {\n+    // We already have the def_path_hash below, no need to hash it twice\n+    #[stable_hasher(ignore)]\n     pub def_id: DefId,\n \n     pub unsafety: hir::Unsafety,"}, {"sha": "422f97b299646361e45f535da3f53aaca64dbc9d", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -4,18 +4,21 @@ use crate::hir::def::Def;\n use crate::hir::def_id::DefId;\n use crate::hir::map::DefPathData;\n use crate::hir::{self, Node};\n+use crate::mir::interpret::{sign_extend, truncate};\n use crate::ich::NodeIdHashingMode;\n use crate::traits::{self, ObligationCause};\n use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n-use crate::ty::subst::{Subst, Substs, UnpackedKind};\n+use crate::ty::subst::{Subst, InternalSubsts, SubstsRef, UnpackedKind};\n use crate::ty::query::TyCtxtAt;\n use crate::ty::TyKind::*;\n use crate::ty::layout::{Integer, IntegerExt};\n+use crate::mir::interpret::ConstValue;\n use crate::util::common::ErrorReported;\n use crate::middle::lang_items;\n \n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_macros::HashStable;\n use std::{cmp, fmt};\n use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n@@ -32,12 +35,12 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.ty.sty {\n             ty::Int(ity) => {\n-                let bits = ty::tls::with(|tcx| {\n-                    Integer::from_attr(&tcx, SignedInt(ity)).size().bits()\n+                let size = ty::tls::with(|tcx| {\n+                    Integer::from_attr(&tcx, SignedInt(ity)).size()\n                 });\n-                let x = self.val as i128;\n+                let x = self.val;\n                 // sign extend the raw representation to be an i128\n-                let x = (x << (128 - bits)) >> (128 - bits);\n+                let x = sign_extend(x, size) as i128;\n                 write!(fmt, \"{}\", x)\n             },\n             _ => write!(fmt, \"{}\", self.val),\n@@ -57,12 +60,12 @@ impl<'tcx> Discr<'tcx> {\n             _ => bug!(\"non integer discriminant\"),\n         };\n \n+        let size = int.size();\n         let bit_size = int.size().bits();\n         let shift = 128 - bit_size;\n         if signed {\n             let sext = |u| {\n-                let i = u as i128;\n-                (i << shift) >> shift\n+                sign_extend(u, size) as i128\n             };\n             let min = sext(1_u128 << (bit_size - 1));\n             let max = i128::max_value() >> shift;\n@@ -77,7 +80,7 @@ impl<'tcx> Discr<'tcx> {\n             };\n             // zero the upper bits\n             let val = val as u128;\n-            let val = (val << shift) >> shift;\n+            let val = truncate(val, size);\n             (Self {\n                 val: val as u128,\n                 ty: self.ty,\n@@ -494,8 +497,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }) => {\n                         !impl_generics.type_param(pt, self).pure_wrt_drop\n                     }\n-                    UnpackedKind::Lifetime(_) | UnpackedKind::Type(_) => {\n-                        // not a type or region param - this should be reported\n+                    UnpackedKind::Const(&ty::LazyConst::Evaluated(ty::Const {\n+                        val: ConstValue::Param(ref pc),\n+                        ..\n+                    })) => {\n+                        !impl_generics.const_param(pc, self).pure_wrt_drop\n+                    }\n+                    UnpackedKind::Lifetime(_) |\n+                    UnpackedKind::Type(_) |\n+                    UnpackedKind::Const(_) => {\n+                        // Not a type, const or region param: this should be reported\n                         // as an error.\n                         false\n                     }\n@@ -586,15 +597,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         Some(ty::Binder::bind(env_ty))\n     }\n \n-    /// Given the `DefId` of some item that has no type parameters, make\n+    /// Given the `DefId` of some item that has no type or const parameters, make\n     /// a suitable \"empty substs\" for it.\n-    pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self, item_def_id, |param, _| {\n+    pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> SubstsRef<'tcx> {\n+        InternalSubsts::for_item(self, item_def_id, |param, _| {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => self.types.re_erased.into(),\n-                GenericParamDefKind::Type {..} => {\n+                GenericParamDefKind::Type { .. } => {\n                     bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n                 }\n+                GenericParamDefKind::Const { .. } => {\n+                    bug!(\"empty_substs_for_def_id: {:?} has const parameters\", item_def_id)\n+                }\n             }\n         })\n     }\n@@ -633,7 +647,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn try_expand_impl_trait_type(\n         self,\n         def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n+        substs: SubstsRef<'tcx>,\n     ) -> Result<Ty<'tcx>, Ty<'tcx>> {\n         use crate::ty::fold::TypeFolder;\n \n@@ -652,7 +666,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             fn expand_opaque_ty(\n                 &mut self,\n                 def_id: DefId,\n-                substs: &'tcx Substs<'tcx>,\n+                substs: SubstsRef<'tcx>,\n             ) -> Option<Ty<'tcx>> {\n                 if self.found_recursion {\n                     None\n@@ -992,7 +1006,7 @@ fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ))\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, HashStable)]\n pub struct NeedsDrop(pub bool);\n \n fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "d9f309ae58e0357b3c03f1bb99921963b9287c1c", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -99,7 +99,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n                         (p.substs, Some(p.ty)),\n                     ty::ExistentialPredicate::AutoTrait(_) =>\n                         // Empty iterator\n-                        (ty::Substs::empty(), None),\n+                        (ty::InternalSubsts::empty(), None),\n                 };\n \n                 substs.types().rev().chain(opt_ty)"}, {"sha": "fa35416cdd4982fd50f11376e006635eb97d111e", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,7 +1,7 @@\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::InferCtxt;\n-use crate::ty::subst::Substs;\n+use crate::ty::subst::SubstsRef;\n use crate::traits;\n use crate::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use std::iter::once;\n@@ -432,7 +432,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n     fn nominal_obligations(&mut self,\n                            def_id: DefId,\n-                           substs: &Substs<'tcx>)\n+                           substs: SubstsRef<'tcx>)\n                            -> Vec<traits::PredicateObligation<'tcx>>\n     {\n         let predicates =\n@@ -482,8 +482,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         //\n         // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n         // am looking forward to the future here.\n-\n-        if !data.has_escaping_bound_vars() {\n+        if !data.has_escaping_bound_vars() && !region.has_escaping_bound_vars() {\n             let implicit_bounds =\n                 object_region_bounds(self.infcx.tcx, data);\n "}, {"sha": "5622fe434363a05fc1d289bbe74a315d78ca5976", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -12,6 +12,7 @@ use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n use syntax_pos::{SpanData};\n+use rustc_macros::HashStable;\n use crate::ty::TyCtxt;\n use crate::dep_graph::{DepNode};\n use lazy_static;\n@@ -22,7 +23,7 @@ pub const FN_OUTPUT_NAME: &str = \"Output\";\n \n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking.\n-#[derive(Clone, Copy, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));"}, {"sha": "a1398c69ff0c59ea69732cbe4f5c269c948f914e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 82, "deletions": 18, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,14 +1,15 @@\n use crate::hir::def_id::DefId;\n use crate::hir::map::definitions::DefPathData;\n use crate::middle::region;\n-use crate::ty::subst::{self, Subst};\n+use crate::ty::subst::{self, Subst, SubstsRef};\n use crate::ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use crate::ty::{Bool, Char, Adt};\n use crate::ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n use crate::ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n use crate::ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n use crate::ty::{Placeholder, UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind};\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind, ParamConst};\n+use crate::mir::interpret::ConstValue;\n use crate::util::nodemap::FxHashSet;\n \n use std::cell::Cell;\n@@ -360,7 +361,7 @@ impl PrintContext {\n     fn fn_sig<F: fmt::Write>(&mut self,\n                              f: &mut F,\n                              inputs: &[Ty<'_>],\n-                             variadic: bool,\n+                             c_variadic: bool,\n                              output: Ty<'_>)\n                              -> fmt::Result {\n         write!(f, \"(\")?;\n@@ -370,7 +371,7 @@ impl PrintContext {\n             for &ty in inputs {\n                 print!(f, self, write(\", \"), print_display(ty))?;\n             }\n-            if variadic {\n+            if c_variadic {\n                 write!(f, \", ...\")?;\n             }\n         }\n@@ -384,7 +385,7 @@ impl PrintContext {\n \n     fn parameterized<F: fmt::Write>(&mut self,\n                                     f: &mut F,\n-                                    substs: &subst::Substs<'_>,\n+                                    substs: SubstsRef<'_>,\n                                     did: DefId,\n                                     projections: &[ty::ProjectionPredicate<'_>])\n                                     -> fmt::Result {\n@@ -478,6 +479,7 @@ impl PrintContext {\n                         GenericParamDefKind::Type { has_default, .. } => {\n                             Some((param.def_id, has_default))\n                         }\n+                        GenericParamDefKind::Const => None, // FIXME(const_generics:defaults)\n                     }).peekable();\n                 let has_default = {\n                     let has_default = type_params.peek().map(|(_, has_default)| has_default);\n@@ -571,6 +573,14 @@ impl PrintContext {\n             )?;\n         }\n \n+        // FIXME(const_generics::defaults)\n+        let consts = substs.consts();\n+\n+        for ct in consts {\n+            start_or_continue(f, \"<\", \", \")?;\n+            ct.print_display(f, self)?;\n+        }\n+\n         start_or_continue(f, \"\", \">\")?;\n \n         // For values, also print their name and type parameters.\n@@ -692,7 +702,7 @@ pub fn identify_regions() -> bool {\n }\n \n pub fn parameterized<F: fmt::Write>(f: &mut F,\n-                                    substs: &subst::Substs<'_>,\n+                                    substs: SubstsRef<'_>,\n                                     did: DefId,\n                                     projections: &[ty::ProjectionPredicate<'_>])\n                                     -> fmt::Result {\n@@ -763,7 +773,8 @@ impl fmt::Debug for ty::GenericParamDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let type_name = match self.kind {\n             ty::GenericParamDefKind::Lifetime => \"Lifetime\",\n-            ty::GenericParamDefKind::Type {..} => \"Type\",\n+            ty::GenericParamDefKind::Type { .. } => \"Type\",\n+            ty::GenericParamDefKind::Const => \"Const\",\n         };\n         write!(f, \"{}({}, {:?}, {})\",\n                type_name,\n@@ -1074,10 +1085,10 @@ define_print! {\n             }\n \n             write!(f, \"fn\")?;\n-            cx.fn_sig(f, self.inputs(), self.variadic, self.output())\n+            cx.fn_sig(f, self.inputs(), self.c_variadic, self.output())\n         }\n         debug {\n-            write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n+            write!(f, \"({:?}; c_variadic: {})->{:?}\", self.inputs(), self.c_variadic, self.output())\n         }\n     }\n }\n@@ -1088,6 +1099,12 @@ impl fmt::Debug for ty::TyVid {\n     }\n }\n \n+impl<'tcx> fmt::Debug for ty::ConstVid<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}f\", self.index)\n+    }\n+}\n+\n impl fmt::Debug for ty::IntVid {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"_#{}i\", self.index)\n@@ -1290,7 +1307,7 @@ define_print! {\n                         Ok(())\n                     }\n                 }\n-                Foreign(def_id) => parameterized(f, subst::Substs::empty(), def_id, &[]),\n+                Foreign(def_id) => parameterized(f, subst::InternalSubsts::empty(), def_id, &[]),\n                 Projection(ref data) => data.print(f, cx),\n                 UnnormalizedProjection(ref data) => {\n                     write!(f, \"Unnormalized(\")?;\n@@ -1363,10 +1380,10 @@ define_print! {\n                         write!(f, \"[static generator\")?;\n                     }\n \n-                    if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n-                        write!(f, \"@{:?}\", tcx.hir().span(node_id))?;\n+                    if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+                        write!(f, \"@{:?}\", tcx.hir().span_by_hir_id(hir_id))?;\n                         let mut sep = \" \";\n-                        tcx.with_freevars(node_id, |freevars| {\n+                        tcx.with_freevars(hir_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                                 print!(f, cx,\n                                        write(\"{}{}:\",\n@@ -1399,14 +1416,14 @@ define_print! {\n                     let upvar_tys = substs.upvar_tys(did, tcx);\n                     write!(f, \"[closure\")?;\n \n-                    if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n+                    if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n                         if tcx.sess.opts.debugging_opts.span_free_formats {\n-                            write!(f, \"@{:?}\", node_id)?;\n+                            write!(f, \"@{:?}\", hir_id)?;\n                         } else {\n-                            write!(f, \"@{:?}\", tcx.hir().span(node_id))?;\n+                            write!(f, \"@{:?}\", tcx.hir().span_by_hir_id(hir_id))?;\n                         }\n                         let mut sep = \" \";\n-                        tcx.with_freevars(node_id, |freevars| {\n+                        tcx.with_freevars(hir_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                                 print!(f, cx,\n                                        write(\"{}{}:\",\n@@ -1448,7 +1465,12 @@ define_print! {\n                             write!(f, \"_\")?;\n                         }\n                         ty::LazyConst::Evaluated(c) => ty::tls::with(|tcx| {\n-                            write!(f, \"{}\", c.unwrap_usize(tcx))\n+                            match c.val {\n+                                ConstValue::Infer(..) => write!(f, \"_\"),\n+                                ConstValue::Param(ParamConst { name, .. }) =>\n+                                    write!(f, \"{}\", name),\n+                                _ => write!(f, \"{}\", c.unwrap_usize(tcx)),\n+                            }\n                         })?,\n                     }\n                     write!(f, \"]\")\n@@ -1472,6 +1494,37 @@ define_print! {\n     }\n }\n \n+define_print! {\n+    ('tcx) ConstValue<'tcx>, (self, f, cx) {\n+        display {\n+            match self {\n+                ConstValue::Infer(..) => write!(f, \"_\"),\n+                ConstValue::Param(ParamConst { name, .. }) => write!(f, \"{}\", name),\n+                _ => write!(f, \"{:?}\", self),\n+            }\n+        }\n+    }\n+}\n+\n+define_print! {\n+    ('tcx) ty::Const<'tcx>, (self, f, cx) {\n+        display {\n+            write!(f, \"{} : {}\", self.val, self.ty)\n+        }\n+    }\n+}\n+\n+define_print! {\n+    ('tcx) ty::LazyConst<'tcx>, (self, f, cx) {\n+        display {\n+            match self {\n+                ty::LazyConst::Unevaluated(..) => write!(f, \"_ : _\"),\n+                ty::LazyConst::Evaluated(c) => write!(f, \"{}\", c),\n+            }\n+        }\n+    }\n+}\n+\n define_print! {\n     () ty::ParamTy, (self, f, cx) {\n         display {\n@@ -1483,6 +1536,17 @@ define_print! {\n     }\n }\n \n+define_print! {\n+    () ty::ParamConst, (self, f, cx) {\n+        display {\n+            write!(f, \"{}\", self.name)\n+        }\n+        debug {\n+            write!(f, \"{}/#{}\", self.name, self.index)\n+        }\n+    }\n+}\n+\n define_print! {\n     ('tcx, T: Print + fmt::Debug, U: Print + fmt::Debug) ty::OutlivesPredicate<T, U>,\n     (self, f, cx) {"}, {"sha": "c134d48f987be5ded1c711a6b0f8786545d30c8a", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 290, "deletions": 337, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,10 +1,13 @@\n-use std::collections::{BTreeMap, HashMap};\n use std::fs;\n-use std::io::{self, Write};\n+use std::io::{BufWriter, Write};\n+use std::mem;\n+use std::process;\n use std::thread::ThreadId;\n-use std::time::Instant;\n+use std::time::{Duration, Instant, SystemTime};\n \n-use crate::session::config::{Options, OptLevel};\n+use crate::session::config::Options;\n+\n+use rustc_data_structures::fx::FxHashMap;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd)]\n pub enum ProfileCategory {\n@@ -19,170 +22,71 @@ pub enum ProfileCategory {\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n pub enum ProfilerEvent {\n-    QueryStart { query_name: &'static str, category: ProfileCategory, time: Instant },\n-    QueryEnd { query_name: &'static str, category: ProfileCategory, time: Instant },\n-    GenericActivityStart { category: ProfileCategory, time: Instant },\n-    GenericActivityEnd { category: ProfileCategory, time: Instant },\n-    QueryCacheHit { query_name: &'static str, category: ProfileCategory },\n-    QueryCount { query_name: &'static str, category: ProfileCategory, count: usize },\n-    IncrementalLoadResultStart { query_name: &'static str, time: Instant },\n-    IncrementalLoadResultEnd { query_name: &'static str, time: Instant },\n-    QueryBlockedStart { query_name: &'static str, category: ProfileCategory, time: Instant },\n-    QueryBlockedEnd { query_name: &'static str, category: ProfileCategory, time: Instant },\n+    QueryStart { query_name: &'static str, category: ProfileCategory, time: u64 },\n+    QueryEnd { query_name: &'static str, category: ProfileCategory, time: u64 },\n+    GenericActivityStart { category: ProfileCategory, time: u64 },\n+    GenericActivityEnd { category: ProfileCategory, time: u64 },\n+    IncrementalLoadResultStart { query_name: &'static str, time: u64 },\n+    IncrementalLoadResultEnd { query_name: &'static str, time: u64 },\n+    QueryCacheHit { query_name: &'static str, category: ProfileCategory, time: u64 },\n+    QueryCount { query_name: &'static str, category: ProfileCategory, count: usize, time: u64 },\n+    QueryBlockedStart { query_name: &'static str, category: ProfileCategory, time: u64 },\n+    QueryBlockedEnd { query_name: &'static str, category: ProfileCategory, time: u64 },\n }\n \n impl ProfilerEvent {\n-    fn is_start_event(&self) -> bool {\n+    fn timestamp(&self) -> u64 {\n         use self::ProfilerEvent::*;\n \n         match self {\n-            QueryStart { .. } |\n-            GenericActivityStart { .. } |\n-            IncrementalLoadResultStart { .. } |\n-            QueryBlockedStart { .. } => true,\n-\n-            QueryEnd { .. } |\n-            GenericActivityEnd { .. } |\n-            QueryCacheHit { .. } |\n-            QueryCount { .. } |\n-            IncrementalLoadResultEnd { .. } |\n-            QueryBlockedEnd { .. } => false,\n-        }\n-    }\n-}\n-\n-pub struct SelfProfiler {\n-    events: HashMap<ThreadId, Vec<ProfilerEvent>>,\n-}\n-\n-struct CategoryResultData {\n-    query_times: BTreeMap<&'static str, u64>,\n-    query_cache_stats: BTreeMap<&'static str, (u64, u64)>, //(hits, total)\n-}\n-\n-impl CategoryResultData {\n-    fn new() -> CategoryResultData {\n-        CategoryResultData {\n-            query_times: BTreeMap::new(),\n-            query_cache_stats: BTreeMap::new(),\n-        }\n-    }\n-\n-    fn total_time(&self) -> u64 {\n-        self.query_times.iter().map(|(_, time)| time).sum()\n-    }\n-\n-    fn total_cache_data(&self) -> (u64, u64) {\n-        let (mut hits, mut total) = (0, 0);\n-\n-        for (_, (h, t)) in &self.query_cache_stats {\n-            hits += h;\n-            total += t;\n+            QueryStart { time, .. } |\n+            QueryEnd { time, .. } |\n+            GenericActivityStart { time, .. } |\n+            GenericActivityEnd { time, .. } |\n+            QueryCacheHit { time, .. } |\n+            QueryCount { time, .. } |\n+            IncrementalLoadResultStart { time, .. } |\n+            IncrementalLoadResultEnd { time, .. } |\n+            QueryBlockedStart { time, .. } |\n+            QueryBlockedEnd { time, .. } => *time\n         }\n-\n-        (hits, total)\n     }\n }\n \n-impl Default for CategoryResultData {\n-    fn default() -> CategoryResultData {\n-        CategoryResultData::new()\n-    }\n-}\n-\n-struct CalculatedResults {\n-    categories: BTreeMap<ProfileCategory, CategoryResultData>,\n-    crate_name: Option<String>,\n-    optimization_level: OptLevel,\n-    incremental: bool,\n-    verbose: bool,\n+fn thread_id_to_u64(tid: ThreadId) -> u64 {\n+    unsafe { mem::transmute::<ThreadId, u64>(tid) }\n }\n \n-impl CalculatedResults {\n-    fn new() -> CalculatedResults {\n-        CalculatedResults {\n-            categories: BTreeMap::new(),\n-            crate_name: None,\n-            optimization_level: OptLevel::No,\n-            incremental: false,\n-            verbose: false,\n-        }\n-    }\n-\n-    fn consolidate(mut cr1: CalculatedResults, cr2: CalculatedResults) -> CalculatedResults {\n-        for (category, data) in cr2.categories {\n-            let cr1_data = cr1.categories.entry(category).or_default();\n-\n-            for (query, time) in data.query_times {\n-                *cr1_data.query_times.entry(query).or_default() += time;\n-            }\n-\n-            for (query, (hits, total)) in data.query_cache_stats {\n-                let (h, t) = cr1_data.query_cache_stats.entry(query).or_insert((0, 0));\n-                *h += hits;\n-                *t += total;\n-            }\n-        }\n-\n-        cr1\n-    }\n-\n-    fn total_time(&self) -> u64 {\n-        self.categories.iter().map(|(_, data)| data.total_time()).sum()\n-    }\n-\n-    fn with_options(mut self, opts: &Options) -> CalculatedResults {\n-        self.crate_name = opts.crate_name.clone();\n-        self.optimization_level = opts.optimize;\n-        self.incremental = opts.incremental.is_some();\n-        self.verbose = opts.debugging_opts.verbose;\n-\n-        self\n-    }\n-}\n-\n-fn time_between_ns(start: Instant, end: Instant) -> u64 {\n-    if start < end {\n-        let time = end - start;\n-        (time.as_secs() * 1_000_000_000) + (time.subsec_nanos() as u64)\n-    } else {\n-        debug!(\"time_between_ns: ignorning instance of end < start\");\n-        0\n-    }\n-}\n-\n-fn calculate_percent(numerator: u64, denominator: u64) -> f32 {\n-    if denominator > 0 {\n-        ((numerator as f32) / (denominator as f32)) * 100.0\n-    } else {\n-        0.0\n-    }\n+pub struct SelfProfiler {\n+    events: FxHashMap<ThreadId, Vec<ProfilerEvent>>,\n+    start_time: SystemTime,\n+    start_instant: Instant,\n }\n \n impl SelfProfiler {\n     pub fn new() -> SelfProfiler {\n-        let mut profiler = SelfProfiler {\n-            events: HashMap::new(),\n+        let profiler = SelfProfiler {\n+            events: Default::default(),\n+            start_time: SystemTime::now(),\n+            start_instant: Instant::now(),\n         };\n \n-        profiler.start_activity(ProfileCategory::Other);\n-\n         profiler\n     }\n \n     #[inline]\n     pub fn start_activity(&mut self, category: ProfileCategory) {\n         self.record(ProfilerEvent::GenericActivityStart {\n             category,\n-            time: Instant::now(),\n+            time: self.get_time_from_start(),\n         })\n     }\n \n     #[inline]\n     pub fn end_activity(&mut self, category: ProfileCategory) {\n         self.record(ProfilerEvent::GenericActivityEnd {\n             category,\n-            time: Instant::now(),\n+            time: self.get_time_from_start(),\n         })\n     }\n \n@@ -197,6 +101,7 @@ impl SelfProfiler {\n             query_name,\n             category,\n             count,\n+            time: self.get_time_from_start(),\n         })\n     }\n \n@@ -205,6 +110,7 @@ impl SelfProfiler {\n         self.record(ProfilerEvent::QueryCacheHit {\n             query_name,\n             category,\n+            time: self.get_time_from_start(),\n         })\n     }\n \n@@ -213,7 +119,7 @@ impl SelfProfiler {\n         self.record(ProfilerEvent::QueryStart {\n             query_name,\n             category,\n-            time: Instant::now(),\n+            time: self.get_time_from_start(),\n         });\n     }\n \n@@ -222,23 +128,23 @@ impl SelfProfiler {\n         self.record(ProfilerEvent::QueryEnd {\n             query_name,\n             category,\n-            time: Instant::now(),\n+            time: self.get_time_from_start(),\n         })\n     }\n \n     #[inline]\n     pub fn incremental_load_result_start(&mut self, query_name: &'static str) {\n         self.record(ProfilerEvent::IncrementalLoadResultStart {\n             query_name,\n-            time: Instant::now(),\n+            time: self.get_time_from_start(),\n         })\n     }\n \n     #[inline]\n     pub fn incremental_load_result_end(&mut self, query_name: &'static str) {\n         self.record(ProfilerEvent::IncrementalLoadResultEnd {\n             query_name,\n-            time: Instant::now(),\n+            time: self.get_time_from_start(),\n         })\n     }\n \n@@ -247,7 +153,7 @@ impl SelfProfiler {\n         self.record(ProfilerEvent::QueryBlockedStart {\n             query_name,\n             category,\n-            time: Instant::now(),\n+            time: self.get_time_from_start(),\n         })\n     }\n \n@@ -256,7 +162,7 @@ impl SelfProfiler {\n         self.record(ProfilerEvent::QueryBlockedEnd {\n             query_name,\n             category,\n-            time: Instant::now(),\n+            time: self.get_time_from_start(),\n         })\n     }\n \n@@ -268,208 +174,255 @@ impl SelfProfiler {\n         events.push(event);\n     }\n \n-    fn calculate_thread_results(events: &Vec<ProfilerEvent>) -> CalculatedResults {\n-        use self::ProfilerEvent::*;\n-\n-        assert!(\n-            events.last().map(|e| !e.is_start_event()).unwrap_or(true),\n-            \"there was an event running when calculate_reslts() was called\"\n-        );\n-\n-        let mut results = CalculatedResults::new();\n-\n-        //(event, child time to subtract)\n-        let mut query_stack = Vec::new();\n-\n-        for event in events {\n-            match event {\n-                QueryStart { .. } | GenericActivityStart { .. } => {\n-                    query_stack.push((event, 0));\n-                },\n-                QueryEnd { query_name, category, time: end_time } => {\n-                    let previous_query = query_stack.pop();\n-                    if let Some((QueryStart {\n-                                    query_name: p_query_name,\n-                                    time: start_time,\n-                                    category: _ }, child_time_to_subtract)) = previous_query {\n-                        assert_eq!(\n-                            p_query_name,\n-                            query_name,\n-                            \"Saw a query end but the previous query wasn't the corresponding start\"\n-                        );\n-\n-                        let time_ns = time_between_ns(*start_time, *end_time);\n-                        let self_time_ns = time_ns - child_time_to_subtract;\n-                        let result_data = results.categories.entry(*category).or_default();\n+    #[inline]\n+    fn get_time_from_start(&self) -> u64 {\n+        let duration = Instant::now() - self.start_instant;\n+        duration.as_nanos() as u64\n+    }\n \n-                        *result_data.query_times.entry(query_name).or_default() += self_time_ns;\n+    pub fn dump_raw_events(&self, opts: &Options) {\n+        use self::ProfilerEvent::*;\n \n-                        if let Some((_, child_time_to_subtract)) = query_stack.last_mut() {\n-                            *child_time_to_subtract += time_ns;\n-                        }\n-                    } else {\n-                        bug!(\"Saw a query end but the previous event wasn't a query start\");\n-                    }\n+        let pid = process::id();\n+\n+        let filename =\n+            format!(\"{}.profile_events.json\", opts.crate_name.clone().unwrap_or_default());\n+\n+        let mut file = BufWriter::new(fs::File::create(filename).unwrap());\n+\n+        let threads: Vec<_> =\n+            self.events\n+                .keys()\n+                .into_iter()\n+                .map(|tid| format!(\"{}\", thread_id_to_u64(*tid)))\n+                .collect();\n+\n+        write!(file,\n+            \"{{\\\n+                \\\"processes\\\": {{\\\n+                    \\\"{}\\\": {{\\\n+                        \\\"threads\\\": [{}],\\\n+                        \\\"crate_name\\\": \\\"{}\\\",\\\n+                        \\\"opt_level\\\": \\\"{:?}\\\",\\\n+                        \\\"incremental\\\": {}\\\n+                    }}\\\n+                }},\\\n+                \\\"events\\\": [\\\n+             \",\n+            pid,\n+            threads.join(\",\"),\n+            opts.crate_name.clone().unwrap_or_default(),\n+            opts.optimize,\n+            if opts.incremental.is_some() { \"true\" } else { \"false\" },\n+        ).unwrap();\n+\n+        let mut is_first = true;\n+        for (thread_id, events) in &self.events {\n+            let thread_id = thread_id_to_u64(*thread_id);\n+\n+            for event in events {\n+                if is_first {\n+                    is_first = false;\n+                } else {\n+                    writeln!(file, \",\").unwrap();\n                 }\n-                GenericActivityEnd { category, time: end_time } => {\n-                    let previous_event = query_stack.pop();\n-                    if let Some((GenericActivityStart {\n-                                    category: previous_category,\n-                                    time: start_time }, child_time_to_subtract)) = previous_event {\n-                        assert_eq!(\n-                            previous_category,\n-                            category,\n-                            \"Saw an end but the previous event wasn't the corresponding start\"\n-                        );\n-\n-                        let time_ns = time_between_ns(*start_time, *end_time);\n-                        let self_time_ns = time_ns - child_time_to_subtract;\n-                        let result_data = results.categories.entry(*category).or_default();\n-\n-                        *result_data.query_times\n-                            .entry(\"{time spent not running queries}\")\n-                            .or_default() += self_time_ns;\n-\n-                        if let Some((_, child_time_to_subtract)) = query_stack.last_mut() {\n-                            *child_time_to_subtract += time_ns;\n-                        }\n-                    } else {\n-                        bug!(\"Saw an activity end but the previous event wasn't an activity start\");\n-                    }\n-                },\n-                QueryCacheHit { category, query_name } => {\n-                    let result_data = results.categories.entry(*category).or_default();\n-\n-                    let (hits, total) =\n-                        result_data.query_cache_stats.entry(query_name).or_insert((0, 0));\n-                    *hits += 1;\n-                    *total += 1;\n-                },\n-                QueryCount { category, query_name, count } => {\n-                    let result_data = results.categories.entry(*category).or_default();\n-\n-                    let (_, totals) =\n-                        result_data.query_cache_stats.entry(query_name).or_insert((0, 0));\n-                    *totals += *count as u64;\n-                },\n-                //we don't summarize incremental load result events in the simple output mode\n-                IncrementalLoadResultStart { .. } | IncrementalLoadResultEnd { .. } => { },\n-                //we don't summarize parallel query blocking in the simple output mode\n-                QueryBlockedStart { .. } | QueryBlockedEnd { .. } => { },\n-            }\n-        }\n \n-        //normalize the times to ms\n-        for (_, data) in &mut results.categories {\n-            for (_, time) in &mut data.query_times {\n-                *time = *time / 1_000_000;\n-            }\n-        }\n-\n-        results\n-    }\n-\n-    fn get_results(&self, opts: &Options) -> CalculatedResults {\n-        self.events\n-            .iter()\n-            .map(|(_, r)| SelfProfiler::calculate_thread_results(r))\n-            .fold(CalculatedResults::new(), CalculatedResults::consolidate)\n-            .with_options(opts)\n-    }\n-\n-    pub fn print_results(&mut self, opts: &Options) {\n-        self.end_activity(ProfileCategory::Other);\n-\n-        let results = self.get_results(opts);\n-\n-        let total_time = results.total_time() as f32;\n-\n-        let out = io::stderr();\n-        let mut lock = out.lock();\n-\n-        let crate_name = results.crate_name.map(|n| format!(\" for {}\", n)).unwrap_or_default();\n-\n-        writeln!(lock, \"Self profiling results{}:\", crate_name).unwrap();\n-        writeln!(lock).unwrap();\n-\n-        writeln!(lock, \"| Phase                                     | Time (ms)      \\\n-                        | Time (%) | Queries        | Hits (%)\")\n-            .unwrap();\n-        writeln!(lock, \"| ----------------------------------------- | -------------- \\\n-                        | -------- | -------------- | --------\")\n-            .unwrap();\n-\n-        let mut categories: Vec<_> = results.categories.iter().collect();\n-        categories.sort_by_cached_key(|(_, d)| d.total_time());\n-\n-        for (category, data) in categories.iter().rev() {\n-            let (category_hits, category_total) = data.total_cache_data();\n-            let category_hit_percent = calculate_percent(category_hits, category_total);\n-\n-            writeln!(\n-                lock,\n-                \"| {0: <41} | {1: >14} | {2: >8.2} | {3: >14} | {4: >8}\",\n-                format!(\"{:?}\", category),\n-                data.total_time(),\n-                ((data.total_time() as f32) / total_time) * 100.0,\n-                category_total,\n-                format!(\"{:.2}\", category_hit_percent),\n-            ).unwrap();\n-\n-            //in verbose mode, show individual query data\n-            if results.verbose {\n-                //don't show queries that took less than 1ms\n-                let mut times: Vec<_> = data.query_times.iter().filter(|(_, t)| **t > 0).collect();\n-                times.sort_by(|(_, time1), (_, time2)| time2.cmp(time1));\n-\n-                for (query, time) in times {\n-                    let (hits, total) = data.query_cache_stats.get(query).unwrap_or(&(0, 0));\n-                    let hit_percent = calculate_percent(*hits, *total);\n-\n-                    writeln!(\n-                        lock,\n-                        \"| - {0: <39} | {1: >14} | {2: >8.2} | {3: >14} | {4: >8}\",\n-                        query,\n-                        time,\n-                        ((*time as f32) / total_time) * 100.0,\n-                        total,\n-                        format!(\"{:.2}\", hit_percent),\n-                    ).unwrap();\n+                let (secs, nanos) = {\n+                    let time = self.start_time + Duration::from_nanos(event.timestamp());\n+                    let time_since_unix =\n+                        time.duration_since(SystemTime::UNIX_EPOCH).unwrap_or_default();\n+                    (time_since_unix.as_secs(), time_since_unix.subsec_nanos())\n+                };\n+\n+                match event {\n+                    QueryStart { query_name, category, time: _ } =>\n+                        write!(file,\n+                            \"{{ \\\n+                                \\\"QueryStart\\\": {{ \\\n+                                    \\\"query_name\\\": \\\"{}\\\",\\\n+                                    \\\"category\\\": \\\"{:?}\\\",\\\n+                                    \\\"time\\\": {{\\\n+                                        \\\"secs\\\": {},\\\n+                                        \\\"nanos\\\": {}\\\n+                                    }},\\\n+                                    \\\"thread_id\\\": {}\\\n+                                }}\\\n+                            }}\",\n+                            query_name,\n+                            category,\n+                            secs,\n+                            nanos,\n+                            thread_id,\n+                        ).unwrap(),\n+                    QueryEnd { query_name, category, time: _ } =>\n+                        write!(file,\n+                            \"{{\\\n+                                \\\"QueryEnd\\\": {{\\\n+                                    \\\"query_name\\\": \\\"{}\\\",\\\n+                                    \\\"category\\\": \\\"{:?}\\\",\\\n+                                    \\\"time\\\": {{\\\n+                                        \\\"secs\\\": {},\\\n+                                        \\\"nanos\\\": {}\\\n+                                    }},\\\n+                                    \\\"thread_id\\\": {}\\\n+                                }}\\\n+                            }}\",\n+                            query_name,\n+                            category,\n+                            secs,\n+                            nanos,\n+                            thread_id,\n+                        ).unwrap(),\n+                    GenericActivityStart { category, time: _ } =>\n+                        write!(file,\n+                            \"{{\n+                                \\\"GenericActivityStart\\\": {{\\\n+                                    \\\"category\\\": \\\"{:?}\\\",\\\n+                                    \\\"time\\\": {{\\\n+                                        \\\"secs\\\": {},\\\n+                                        \\\"nanos\\\": {}\\\n+                                    }},\\\n+                                    \\\"thread_id\\\": {}\\\n+                                }}\\\n+                            }}\",\n+                            category,\n+                            secs,\n+                            nanos,\n+                            thread_id,\n+                        ).unwrap(),\n+                    GenericActivityEnd { category, time: _ } =>\n+                        write!(file,\n+                            \"{{\\\n+                                \\\"GenericActivityEnd\\\": {{\\\n+                                    \\\"category\\\": \\\"{:?}\\\",\\\n+                                    \\\"time\\\": {{\\\n+                                        \\\"secs\\\": {},\\\n+                                        \\\"nanos\\\": {}\\\n+                                    }},\\\n+                                    \\\"thread_id\\\": {}\\\n+                                }}\\\n+                            }}\",\n+                            category,\n+                            secs,\n+                            nanos,\n+                            thread_id,\n+                        ).unwrap(),\n+                    QueryCacheHit { query_name, category, time: _ } =>\n+                        write!(file,\n+                            \"{{\\\n+                                \\\"QueryCacheHit\\\": {{\\\n+                                    \\\"query_name\\\": \\\"{}\\\",\\\n+                                    \\\"category\\\": \\\"{:?}\\\",\\\n+                                    \\\"time\\\": {{\\\n+                                        \\\"secs\\\": {},\\\n+                                        \\\"nanos\\\": {}\\\n+                                    }},\\\n+                                    \\\"thread_id\\\": {}\\\n+                                }}\\\n+                            }}\",\n+                            query_name,\n+                            category,\n+                            secs,\n+                            nanos,\n+                            thread_id,\n+                        ).unwrap(),\n+                    QueryCount { query_name, category, count, time: _ } =>\n+                        write!(file,\n+                            \"{{\\\n+                                \\\"QueryCount\\\": {{\\\n+                                    \\\"query_name\\\": \\\"{}\\\",\\\n+                                    \\\"category\\\": \\\"{:?}\\\",\\\n+                                    \\\"count\\\": {},\\\n+                                    \\\"time\\\": {{\\\n+                                        \\\"secs\\\": {},\\\n+                                        \\\"nanos\\\": {}\\\n+                                    }},\\\n+                                    \\\"thread_id\\\": {}\\\n+                                }}\\\n+                            }}\",\n+                            query_name,\n+                            category,\n+                            count,\n+                            secs,\n+                            nanos,\n+                            thread_id,\n+                        ).unwrap(),\n+                    IncrementalLoadResultStart { query_name, time: _ } =>\n+                        write!(file,\n+                            \"{{\\\n+                                \\\"IncrementalLoadResultStart\\\": {{\\\n+                                    \\\"query_name\\\": \\\"{}\\\",\\\n+                                    \\\"time\\\": {{\\\n+                                        \\\"secs\\\": {},\\\n+                                        \\\"nanos\\\": {}\\\n+                                    }},\\\n+                                    \\\"thread_id\\\": {}\\\n+                                }}\\\n+                            }}\",\n+                            query_name,\n+                            secs,\n+                            nanos,\n+                            thread_id,\n+                        ).unwrap(),\n+                    IncrementalLoadResultEnd { query_name, time: _ } =>\n+                        write!(file,\n+                            \"{{\\\n+                                \\\"IncrementalLoadResultEnd\\\": {{\\\n+                                    \\\"query_name\\\": \\\"{}\\\",\\\n+                                    \\\"time\\\": {{\\\n+                                        \\\"secs\\\": {},\\\n+                                        \\\"nanos\\\": {}\\\n+                                    }},\\\n+                                    \\\"thread_id\\\": {}\\\n+                                }}\\\n+                            }}\",\n+                            query_name,\n+                            secs,\n+                            nanos,\n+                            thread_id,\n+                        ).unwrap(),\n+                    QueryBlockedStart { query_name, category, time: _ } =>\n+                        write!(file,\n+                            \"{{\\\n+                                \\\"QueryBlockedStart\\\": {{\\\n+                                    \\\"query_name\\\": \\\"{}\\\",\\\n+                                    \\\"category\\\": \\\"{:?}\\\",\\\n+                                    \\\"time\\\": {{\\\n+                                        \\\"secs\\\": {},\\\n+                                        \\\"nanos\\\": {}\\\n+                                    }},\\\n+                                    \\\"thread_id\\\": {}\\\n+                                }}\\\n+                            }}\",\n+                            query_name,\n+                            category,\n+                            secs,\n+                            nanos,\n+                            thread_id,\n+                        ).unwrap(),\n+                    QueryBlockedEnd { query_name, category, time: _ } =>\n+                        write!(file,\n+                            \"{{\\\n+                                \\\"QueryBlockedEnd\\\": {{\\\n+                                    \\\"query_name\\\": \\\"{}\\\",\\\n+                                    \\\"category\\\": \\\"{:?}\\\",\\\n+                                    \\\"time\\\": {{\\\n+                                        \\\"secs\\\": {},\\\n+                                        \\\"nanos\\\": {}\\\n+                                    }},\\\n+                                    \\\"thread_id\\\": {}\\\n+                                }}\\\n+                            }}\",\n+                            query_name,\n+                            category,\n+                            secs,\n+                            nanos,\n+                            thread_id,\n+                        ).unwrap()\n                 }\n             }\n         }\n \n-        writeln!(lock).unwrap();\n-        writeln!(lock, \"Optimization level: {:?}\", opts.optimize).unwrap();\n-        writeln!(lock, \"Incremental: {}\", if results.incremental { \"on\" } else { \"off\" }).unwrap();\n-    }\n-\n-    pub fn save_results(&self, opts: &Options) {\n-        let results = self.get_results(opts);\n-\n-        let compilation_options =\n-            format!(\"{{ \\\"optimization_level\\\": \\\"{:?}\\\", \\\"incremental\\\": {} }}\",\n-                    results.optimization_level,\n-                    if results.incremental { \"true\" } else { \"false\" });\n-\n-        let mut category_data = String::new();\n-\n-        for (category, data) in &results.categories {\n-            let (hits, total) = data.total_cache_data();\n-            let hit_percent = calculate_percent(hits, total);\n-\n-            category_data.push_str(&format!(\"{{ \\\"category\\\": \\\"{:?}\\\", \\\"time_ms\\\": {}, \\\n-                                                \\\"query_count\\\": {}, \\\"query_hits\\\": {} }}\",\n-                                            category,\n-                                            data.total_time(),\n-                                            total,\n-                                            format!(\"{:.2}\", hit_percent)));\n-        }\n-\n-        let json = format!(\"{{ \\\"category_data\\\": {}, \\\"compilation_options\\\": {} }}\",\n-                        category_data,\n-                        compilation_options);\n-\n-        fs::write(\"self_profiler_results.json\", json).unwrap();\n+        write!(file, \"] }}\").unwrap();\n     }\n }"}, {"sha": "1b0bcdd0b5b484d66df7246fe926c65692e42ad5", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -35,7 +35,6 @@\n #![deny(rust_2018_idioms)]\n \n #![feature(nll)]\n-#![feature(try_from)]\n // See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n #[allow(unused_extern_crates)]\n extern crate rustc_cratesio_shim;"}, {"sha": "d2d5c4fe85c90a8626418eb8bf82f028e4a68c14", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -17,7 +17,6 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt, RegionKind};\n-use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::Node;\n@@ -89,15 +88,14 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n-               consume_id: ast::NodeId,\n+               consume_id: hir::HirId,\n                consume_span: Span,\n                cmt: &mc::cmt_<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n \n-        let hir_id = self.tcx().hir().node_to_hir_id(consume_id);\n-        self.consume_common(hir_id.local_id, consume_span, cmt, mode);\n+        self.consume_common(consume_id.local_id, consume_span, cmt, mode);\n     }\n \n     fn matched_pat(&mut self,\n@@ -118,7 +116,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n+              borrow_id: hir::HirId,\n               borrow_span: Span,\n               cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n@@ -130,22 +128,21 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n-        let hir_id = self.tcx().hir().node_to_hir_id(borrow_id);\n         if let Some(lp) = opt_loan_path(cmt) {\n             let moved_value_use_kind = match loan_cause {\n                 euv::ClosureCapture(_) => MovedInCapture,\n                 _ => MovedInUse,\n             };\n-            self.check_if_path_is_moved(hir_id.local_id, borrow_span, moved_value_use_kind, &lp);\n+            self.check_if_path_is_moved(borrow_id.local_id, borrow_span, moved_value_use_kind, &lp);\n         }\n \n-        self.check_for_conflicting_loans(hir_id.local_id);\n+        self.check_for_conflicting_loans(borrow_id.local_id);\n \n         self.check_for_loans_across_yields(cmt, loan_region, borrow_span);\n     }\n \n     fn mutate(&mut self,\n-              assignment_id: ast::NodeId,\n+              assignment_id: hir::HirId,\n               assignment_span: Span,\n               assignee_cmt: &mc::cmt_<'tcx>,\n               mode: euv::MutateMode)\n@@ -176,24 +173,23 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                 }\n             }\n         }\n-        self.check_assignment(self.tcx().hir().node_to_hir_id(assignment_id).local_id,\n-                              assignment_span, assignee_cmt);\n+        self.check_assignment(assignment_id.local_id, assignment_span, assignee_cmt);\n     }\n \n-    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n+    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) { }\n }\n \n pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      dfcx_loans: &LoanDataFlow<'b, 'tcx>,\n                                      move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      body: &hir::Body) {\n-    debug!(\"check_loans(body id={})\", body.value.id);\n+    debug!(\"check_loans(body id={})\", body.value.hir_id);\n \n     let def_id = bccx.tcx.hir().body_owner_def_id(body.id());\n \n-    let node_id = bccx.tcx.hir().as_local_node_id(def_id).unwrap();\n-    let movable_generator = !match bccx.tcx.hir().get(node_id) {\n+    let hir_id = bccx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let movable_generator = !match bccx.tcx.hir().get_by_hir_id(hir_id) {\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n@@ -890,11 +886,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         // Check for reassignments to (immutable) local variables. This\n         // needs to be done here instead of in check_loans because we\n         // depend on move data.\n-        if let Categorization::Local(local_id) = assignee_cmt.cat {\n+        if let Categorization::Local(hir_id) = assignee_cmt.cat {\n             let lp = opt_loan_path(assignee_cmt).unwrap();\n             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 if assignee_cmt.mutbl.is_mutable() {\n-                    let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                     self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                 } else {\n                     self.bccx.report_reassigned_immutable_variable("}, {"sha": "a15d3d10adf0ecce96df3fa11b57a83f0b406135", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -11,7 +11,6 @@ use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::ty::{self, Ty};\n \n use std::rc::Rc;\n-use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir::*;\n use rustc::hir::Node;\n@@ -48,9 +47,9 @@ pub enum PatternSource<'tcx> {\n /// with a reference to the let\n fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n \n-    let parent = tcx.hir().get_parent_node(pat.id);\n+    let parent = tcx.hir().get_parent_node_by_hir_id(pat.hir_id);\n \n-    match tcx.hir().get(parent) {\n+    match tcx.hir().get_by_hir_id(parent) {\n         Node::Expr(ref e) => {\n             // the enclosing expression must be a `match` or something else\n             assert!(match e.node {\n@@ -67,11 +66,10 @@ fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> Patte\n \n pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              move_data: &MoveData<'tcx>,\n-                             var_id: ast::NodeId,\n+                             var_id: hir::HirId,\n                              var_ty: Ty<'tcx>) {\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n-    let hir_id = bccx.tcx.hir().node_to_hir_id(var_id);\n-    move_data.add_move(bccx.tcx, loan_path, hir_id.local_id, Declared);\n+    move_data.add_move(bccx.tcx, loan_path, var_id.local_id, Declared);\n }\n \n pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n@@ -100,7 +98,7 @@ pub fn gather_move_from_pat<'a, 'c, 'tcx: 'c>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                               cmt: &'c mc::cmt_<'tcx>) {\n     let source = get_pattern_source(bccx.tcx,move_pat);\n     let pat_span_path_opt = match move_pat.node {\n-        PatKind::Binding(_, _, _, ident, _) => {\n+        PatKind::Binding(_, _, ident, _) => {\n             Some(MovePlace {\n                      span: move_pat.span,\n                      name: ident.name,"}, {"sha": "0e08b62668ac8f7d72c99b71c144e97e21027286", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -104,8 +104,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             Categorization::Upvar(..) => {\n                 self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n             }\n-            Categorization::Local(local_id) => {\n-                let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n+            Categorization::Local(hir_id) => {\n                 self.bccx.tcx.mk_region(ty::ReScope(\n                     self.bccx.region_scope_tree.var_scope(hir_id.local_id)))\n             }"}, {"sha": "1e3364ecb9a3473998d2a280e54182bf76806352", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -68,7 +68,7 @@ struct GatherLoanCtxt<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n-               consume_id: ast::NodeId,\n+               consume_id: hir::HirId,\n                _consume_span: Span,\n                cmt: &mc::cmt_<'tcx>,\n                mode: euv::ConsumeMode) {\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n             euv::Move(move_reason) => {\n                 gather_moves::gather_move_from_expr(\n                     self.bccx, &self.move_data, &mut self.move_error_collector,\n-                    self.bccx.tcx.hir().node_to_hir_id(consume_id).local_id, cmt, move_reason);\n+                    consume_id.local_id, cmt, move_reason);\n             }\n             euv::Copy => { }\n         }\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n+              borrow_id: hir::HirId,\n               borrow_span: Span,\n               cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n@@ -126,8 +126,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n-        let hir_id = self.bccx.tcx.hir().node_to_hir_id(borrow_id);\n-        self.guarantee_valid(hir_id.local_id,\n+\n+        self.guarantee_valid(borrow_id.local_id,\n                              borrow_span,\n                              cmt,\n                              bk,\n@@ -136,22 +136,41 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn mutate(&mut self,\n-              assignment_id: ast::NodeId,\n+              assignment_id: hir::HirId,\n               assignment_span: Span,\n               assignee_cmt: &mc::cmt_<'tcx>,\n               _: euv::MutateMode)\n     {\n-        self.guarantee_assignment_valid(assignment_id,\n+        let node_id = self.bccx.tcx.hir().hir_to_node_id(assignment_id);\n+        self.guarantee_assignment_valid(node_id,\n                                         assignment_span,\n                                         assignee_cmt);\n     }\n \n-    fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n+    fn decl_without_init(&mut self, id: hir::HirId, _span: Span) {\n         let ty = self.bccx\n                      .tables\n-                     .node_type(self.bccx.tcx.hir().node_to_hir_id(id));\n+                     .node_type(id);\n         gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n+\n+    fn nested_body(&mut self, body_id: hir::BodyId) {\n+        debug!(\"nested_body(body_id={:?})\", body_id);\n+        // rust-lang/rust#58776: MIR and AST borrow check disagree on where\n+        // certain closure errors are reported. As such migrate borrowck has to\n+        // operate at the level of items, rather than bodies. Check if the\n+        // contained closure had any errors and set `signalled_any_error` if it\n+        // has.\n+        let bccx = self.bccx;\n+        if bccx.tcx.migrate_borrowck() {\n+            if let SignalledError::NoErrorsSeen = bccx.signalled_any_error.get() {\n+                let closure_def_id = bccx.tcx.hir().body_owner_def_id(body_id);\n+                debug!(\"checking closure: {:?}\", closure_def_id);\n+\n+                bccx.signalled_any_error.set(bccx.tcx.borrowck(closure_def_id).signalled_any_error);\n+            }\n+        }\n+    }\n }\n \n /// Implements the A-* rules in README.md.\n@@ -437,9 +456,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n         while let Some(current_path) = wrapped_path {\n             wrapped_path = match current_path.kind {\n-                LpVar(local_id) => {\n+                LpVar(hir_id) => {\n                     if !through_borrow {\n-                        let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                         self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                     }\n                     None"}, {"sha": "da065f9e05d9ed8f29ef155b9ee7a3b348f9bf0d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -83,9 +83,9 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n \n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n-    let owner_id = tcx.hir().as_local_node_id(owner_def_id).unwrap();\n+    let owner_id = tcx.hir().as_local_hir_id(owner_def_id).unwrap();\n \n-    match tcx.hir().get(owner_id) {\n+    match tcx.hir().get_by_hir_id(owner_id) {\n         Node::StructCtor(_) |\n         Node::Variant(_) => {\n             // We get invoked with anything that has MIR, but some of\n@@ -335,7 +335,7 @@ impl<'tcx> Hash for LoanPath<'tcx> {\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n pub enum LoanPathKind<'tcx> {\n-    LpVar(ast::NodeId),                         // `x` in README.md\n+    LpVar(hir::HirId),                          // `x` in README.md\n     LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n     LpDowncast(Rc<LoanPath<'tcx>>, DefId), // `x` downcast to particular enum variant\n     LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem<'tcx>)\n@@ -417,8 +417,7 @@ fn closure_to_block(closure_id: LocalDefId,\n impl<'a, 'tcx> LoanPath<'tcx> {\n     pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::Scope {\n         match self.kind {\n-            LpVar(local_id) => {\n-                let hir_id = bccx.tcx.hir().node_to_hir_id(local_id);\n+            LpVar(hir_id) => {\n                 bccx.region_scope_tree.var_scope(hir_id.local_id)\n             }\n             LpUpvar(upvar_id) => {\n@@ -682,8 +681,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                              Origin::Ast);\n                 let need_note = match lp.ty.sty {\n                     ty::Closure(id, _) => {\n-                        let node_id = self.tcx.hir().as_local_node_id(id).unwrap();\n-                        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n+                        let hir_id = self.tcx.hir().as_local_hir_id(id).unwrap();\n                         if let Some((span, name)) = self.tables.closure_kind_origins().get(hir_id) {\n                             err.span_note(*span, &format!(\n                                 \"closure cannot be invoked more than once because \\\n@@ -919,7 +917,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.note_immutability_blame(\n                     &mut db,\n                     err.cmt.immutability_blame(),\n-                    self.tcx.hir().hir_to_node_id(err.cmt.hir_id)\n+                    err.cmt.hir_id\n                 );\n                 db.emit();\n                 self.signal_error();\n@@ -1135,7 +1133,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.note_immutability_blame(\n             &mut err,\n             blame,\n-            self.tcx.hir().hir_to_node_id(cmt.hir_id)\n+            cmt.hir_id\n         );\n \n         if is_closure {\n@@ -1175,8 +1173,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n-        let pat = match self.tcx.hir().get(node_id) {\n+    fn local_binding_mode(&self, hir_id: hir::HirId) -> ty::BindingMode {\n+        let pat = match self.tcx.hir().get_by_hir_id(hir_id) {\n             Node::Binding(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n@@ -1192,16 +1190,16 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn local_ty(&self, node_id: ast::NodeId) -> (Option<&hir::Ty>, bool) {\n-        let parent = self.tcx.hir().get_parent_node(node_id);\n-        let parent_node = self.tcx.hir().get(parent);\n+    fn local_ty(&self, hir_id: hir::HirId) -> (Option<&hir::Ty>, bool) {\n+        let parent = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+        let parent_node = self.tcx.hir().get_by_hir_id(parent);\n \n         // The parent node is like a fn\n         if let Some(fn_like) = FnLikeNode::from_node(parent_node) {\n             // `nid`'s parent's `Body`\n             let fn_body = self.tcx.hir().body(fn_like.body());\n             // Get the position of `node_id` in the arguments list\n-            let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.id == node_id);\n+            let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.hir_id == hir_id);\n             if let Some(i) = arg_pos {\n                 // The argument's `Ty`\n                 (Some(&fn_like.decl().inputs[i]),\n@@ -1217,17 +1215,17 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn note_immutability_blame(&self,\n                                db: &mut DiagnosticBuilder<'_>,\n                                blame: Option<ImmutabilityBlame<'_>>,\n-                               error_node_id: ast::NodeId) {\n+                               error_hir_id: hir::HirId) {\n         match blame {\n             None => {}\n             Some(ImmutabilityBlame::ClosureEnv(_)) => {}\n-            Some(ImmutabilityBlame::ImmLocal(node_id)) => {\n-                self.note_immutable_local(db, error_node_id, node_id)\n+            Some(ImmutabilityBlame::ImmLocal(hir_id)) => {\n+                self.note_immutable_local(db, error_hir_id, hir_id)\n             }\n-            Some(ImmutabilityBlame::LocalDeref(node_id)) => {\n-                match self.local_binding_mode(node_id) {\n+            Some(ImmutabilityBlame::LocalDeref(hir_id)) => {\n+                match self.local_binding_mode(hir_id) {\n                     ty::BindByReference(..) => {\n-                        let let_span = self.tcx.hir().span(node_id);\n+                        let let_span = self.tcx.hir().span_by_hir_id(hir_id);\n                         let suggestion = suggest_ref_mut(self.tcx, let_span);\n                         if let Some(replace_str) = suggestion {\n                             db.span_suggestion(\n@@ -1244,7 +1242,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         }\n                     }\n                     ty::BindByValue(..) => {\n-                        if let (Some(local_ty), is_implicit_self) = self.local_ty(node_id) {\n+                        if let (Some(local_ty), is_implicit_self) = self.local_ty(hir_id) {\n                             if let Some(msg) =\n                                  self.suggest_mut_for_immutable(local_ty, is_implicit_self) {\n                                 db.span_label(local_ty.span, msg);\n@@ -1254,12 +1252,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n             Some(ImmutabilityBlame::AdtFieldDeref(_, field)) => {\n-                let node_id = match self.tcx.hir().as_local_node_id(field.did) {\n-                    Some(node_id) => node_id,\n+                let hir_id = match self.tcx.hir().as_local_hir_id(field.did) {\n+                    Some(hir_id) => hir_id,\n                     None => return\n                 };\n \n-                if let Node::Field(ref field) = self.tcx.hir().get(node_id) {\n+                if let Node::Field(ref field) = self.tcx.hir().get_by_hir_id(hir_id) {\n                     if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n                         db.span_label(field.ty.span, msg);\n                     }\n@@ -1273,12 +1271,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n      // not a mutable reference) or to avoid borrowing altogether\n     fn note_immutable_local(&self,\n                             db: &mut DiagnosticBuilder<'_>,\n-                            borrowed_node_id: ast::NodeId,\n-                            binding_node_id: ast::NodeId) {\n-        let let_span = self.tcx.hir().span(binding_node_id);\n-        if let ty::BindByValue(..) = self.local_binding_mode(binding_node_id) {\n+                            borrowed_hir_id: hir::HirId,\n+                            binding_hir_id: hir::HirId) {\n+        let let_span = self.tcx.hir().span_by_hir_id(binding_hir_id);\n+        if let ty::BindByValue(..) = self.local_binding_mode(binding_hir_id) {\n             if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(let_span) {\n-                let (ty, is_implicit_self) = self.local_ty(binding_node_id);\n+                let (ty, is_implicit_self) = self.local_ty(binding_hir_id);\n                 if is_implicit_self && snippet != \"self\" {\n                     // avoid suggesting `mut &self`.\n                     return\n@@ -1291,9 +1289,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     },\n                 )) = ty.map(|t| &t.node)\n                 {\n-                    let borrow_expr_id = self.tcx.hir().get_parent_node(borrowed_node_id);\n+                    let borrow_expr_id = self.tcx.hir().get_parent_node_by_hir_id(borrowed_hir_id);\n                     db.span_suggestion(\n-                        self.tcx.hir().span(borrow_expr_id),\n+                        self.tcx.hir().span_by_hir_id(borrow_expr_id),\n                         \"consider removing the `&mut`, as it is an \\\n                         immutable binding to a mutable reference\",\n                         snippet,\n@@ -1373,7 +1371,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let Categorization::Deref(..) = err.cmt.cat {\n                     db.span_label(*error_span, \"cannot borrow as mutable\");\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n-                    let span = self.tcx.hir().span(local_id);\n+                    let span = self.tcx.hir().span_by_hir_id(local_id);\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n                             db.span_label(*error_span, \"cannot reborrow mutably\");\n@@ -1401,7 +1399,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push_str(&self.tcx.hir().name_by_hir_id(id).as_str());\n             }\n             LpVar(id) => {\n-                out.push_str(&self.tcx.hir().name(id).as_str());\n+                out.push_str(&self.tcx.hir().name_by_hir_id(id).as_str());\n             }\n \n             LpDowncast(ref lp_base, variant_def_id) => {\n@@ -1512,7 +1510,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n@@ -1547,7 +1545,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_user_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_user_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {"}, {"sha": "49c9555a2c682d74f642016699c9e4116940b953", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -258,7 +258,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             val\n         };\n         match self.mode {\n-            PassMode::Ignore => {},\n+            PassMode::Ignore(_) => {}\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n@@ -422,7 +422,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n \n         let mut inputs = sig.inputs();\n         let extra_args = if sig.abi == RustCall {\n-            assert!(!sig.variadic && extra_args.is_empty());\n+            assert!(!sig.c_variadic && extra_args.is_empty());\n \n             match sig.inputs().last().unwrap().sty {\n                 ty::Tuple(ref tupled_arguments) => {\n@@ -435,7 +435,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 }\n             }\n         } else {\n-            assert!(sig.variadic || extra_args.is_empty());\n+            assert!(sig.c_variadic || extra_args.is_empty());\n             extra_args\n         };\n \n@@ -507,6 +507,14 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             }\n         };\n \n+        // Store the index of the last argument. This is useful for working with\n+        // C-compatible variadic arguments.\n+        let last_arg_idx = if sig.inputs().is_empty() {\n+            None\n+        } else {\n+            Some(sig.inputs().len() - 1)\n+        };\n+\n         let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n             let is_return = arg_idx.is_none();\n             let mut arg = mk_arg_type(ty, arg_idx);\n@@ -516,7 +524,30 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 // The same is true for s390x-unknown-linux-gnu\n                 // and sparc64-unknown-linux-gnu.\n                 if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n-                    arg.mode = PassMode::Ignore;\n+                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n+                }\n+            }\n+\n+            // If this is a C-variadic function, this is not the return value,\n+            // and there is one or more fixed arguments; ensure that the `VaList`\n+            // is ignored as an argument.\n+            if sig.c_variadic {\n+                match (last_arg_idx, arg_idx) {\n+                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n+                        let va_list_did = match cx.tcx.lang_items().va_list() {\n+                            Some(did) => did,\n+                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n+                        };\n+                        match ty.sty {\n+                            ty::Adt(def, _) if def.did == va_list_did => {\n+                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n+                                // so that it will be ignored.\n+                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n+                            },\n+                            _ => (),\n+                        }\n+                    }\n+                    _ => {}\n                 }\n             }\n \n@@ -558,7 +589,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             args: inputs.iter().chain(extra_args).enumerate().map(|(i, ty)| {\n                 arg_of(ty, Some(i))\n             }).collect(),\n-            variadic: sig.variadic,\n+            c_variadic: sig.c_variadic,\n             conv,\n         };\n         fn_ty.adjust_for_abi(cx, sig.abi);\n@@ -646,7 +677,9 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         );\n \n         let llreturn_ty = match self.ret.mode {\n-            PassMode::Ignore => cx.type_void(),\n+            PassMode::Ignore(IgnoreMode::Zst) => cx.type_void(),\n+            PassMode::Ignore(IgnoreMode::CVarArgs) =>\n+                bug!(\"`va_list` should never be a return type\"),\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 self.ret.layout.immediate_llvm_type(cx)\n             }\n@@ -664,7 +697,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             }\n \n             let llarg_ty = match arg.mode {\n-                PassMode::Ignore => continue,\n+                PassMode::Ignore(_) => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_llvm_type(cx),\n                 PassMode::Pair(..) => {\n                     llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 0, true));\n@@ -684,7 +717,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             llargument_tys.push(llarg_ty);\n         }\n \n-        if self.variadic {\n+        if self.c_variadic {\n             cx.type_variadic_func(&llargument_tys, llreturn_ty)\n         } else {\n             cx.type_func(&llargument_tys, llreturn_ty)\n@@ -733,7 +766,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n-                PassMode::Ignore => {}\n+                PassMode::Ignore(_) => {}\n                 PassMode::Direct(ref attrs) |\n                 PassMode::Indirect(ref attrs, None) => apply(attrs),\n                 PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n@@ -780,7 +813,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n-                PassMode::Ignore => {}\n+                PassMode::Ignore(_) => {}\n                 PassMode::Direct(ref attrs) |\n                 PassMode::Indirect(ref attrs, None) => apply(attrs),\n                 PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {"}, {"sha": "6c175ff4247cadf6e90aa97aa9532dbb45f04f51", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -698,7 +698,6 @@ fn link_natively(sess: &Session,\n     }\n \n     if sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\" {\n-        wasm::rewrite_imports(&out_filename, &codegen_results.crate_info.wasm_imports);\n         wasm::add_producer_section(\n             &out_filename,\n             &sess.edition().to_string(),"}, {"sha": "f90bb89fbe87d66c6f8516af5a32508b3b5ba43b", "filename": "src/librustc_codegen_llvm/back/wasm.rs", "status": "modified", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -2,116 +2,11 @@ use std::fs;\n use std::path::Path;\n use std::str;\n \n-use rustc_data_structures::fx::FxHashMap;\n use serialize::leb128;\n \n // https://webassembly.github.io/spec/core/binary/modules.html#binary-importsec\n-const WASM_IMPORT_SECTION_ID: u8 = 2;\n const WASM_CUSTOM_SECTION_ID: u8 = 0;\n \n-const WASM_EXTERNAL_KIND_FUNCTION: u8 = 0;\n-const WASM_EXTERNAL_KIND_TABLE: u8 = 1;\n-const WASM_EXTERNAL_KIND_MEMORY: u8 = 2;\n-const WASM_EXTERNAL_KIND_GLOBAL: u8 = 3;\n-\n-/// Rewrite the module imports are listed from in a wasm module given the field\n-/// name to module name mapping in `import_map`.\n-///\n-/// LLVM 6 which we're using right now doesn't have the ability to configure the\n-/// module a wasm symbol is import from. Rather all imported symbols come from\n-/// the bland `\"env\"` module unconditionally. Furthermore we'd *also* need\n-/// support in LLD for preserving these import modules, which it unfortunately\n-/// currently does not.\n-///\n-/// This function is intended as a hack for now where we manually rewrite the\n-/// wasm output by LLVM to have the correct import modules listed. The\n-/// `#[link(wasm_import_module = \"...\")]` attribute in Rust translates to the\n-/// module that each symbol is imported from, so here we manually go through the\n-/// wasm file, decode it, rewrite imports, and then rewrite the wasm module.\n-///\n-/// Support for this was added to LLVM in\n-/// https://github.com/llvm-mirror/llvm/commit/0f32e1365, although support still\n-/// needs to be added, tracked at https://bugs.llvm.org/show_bug.cgi?id=37168\n-pub fn rewrite_imports(path: &Path, import_map: &FxHashMap<String, String>) {\n-    if import_map.is_empty() {\n-        return\n-    }\n-\n-    let wasm = fs::read(path).expect(\"failed to read wasm output\");\n-    let mut ret = WasmEncoder::new();\n-    ret.data.extend(&wasm[..8]);\n-\n-    // skip the 8 byte wasm/version header\n-    for (id, raw) in WasmSections(WasmDecoder::new(&wasm[8..])) {\n-        ret.byte(id);\n-        if id == WASM_IMPORT_SECTION_ID {\n-            info!(\"rewriting import section\");\n-            let data = rewrite_import_section(\n-                &mut WasmDecoder::new(raw),\n-                import_map,\n-            );\n-            ret.bytes(&data);\n-        } else {\n-            info!(\"carry forward section {}, {} bytes long\", id, raw.len());\n-            ret.bytes(raw);\n-        }\n-    }\n-\n-    fs::write(path, &ret.data).expect(\"failed to write wasm output\");\n-\n-    fn rewrite_import_section(\n-        wasm: &mut WasmDecoder<'_>,\n-        import_map: &FxHashMap<String, String>,\n-    )\n-        -> Vec<u8>\n-    {\n-        let mut dst = WasmEncoder::new();\n-        let n = wasm.u32();\n-        dst.u32(n);\n-        info!(\"rewriting {} imports\", n);\n-        for _ in 0..n {\n-            rewrite_import_entry(wasm, &mut dst, import_map);\n-        }\n-        return dst.data\n-    }\n-\n-    fn rewrite_import_entry(wasm: &mut WasmDecoder<'_>,\n-                            dst: &mut WasmEncoder,\n-                            import_map: &FxHashMap<String, String>) {\n-        // More info about the binary format here is available at:\n-        // https://webassembly.github.io/spec/core/binary/modules.html#import-section\n-        //\n-        // Note that you can also find the whole point of existence of this\n-        // function here, where we map the `module` name to a different one if\n-        // we've got one listed.\n-        let module = wasm.str();\n-        let field = wasm.str();\n-        let new_module = if module == \"env\" {\n-            import_map.get(field).map(|s| &**s).unwrap_or(module)\n-        } else {\n-            module\n-        };\n-        info!(\"import rewrite ({} => {}) / {}\", module, new_module, field);\n-        dst.str(new_module);\n-        dst.str(field);\n-        let kind = wasm.byte();\n-        dst.byte(kind);\n-        match kind {\n-            WASM_EXTERNAL_KIND_FUNCTION => dst.u32(wasm.u32()),\n-            WASM_EXTERNAL_KIND_TABLE => {\n-                dst.byte(wasm.byte()); // element_type\n-                dst.limits(wasm.limits());\n-            }\n-            WASM_EXTERNAL_KIND_MEMORY => dst.limits(wasm.limits()),\n-            WASM_EXTERNAL_KIND_GLOBAL => {\n-                dst.byte(wasm.byte()); // content_type\n-                dst.bool(wasm.bool()); // mutable\n-            }\n-            b => panic!(\"unknown kind: {}\", b),\n-        }\n-    }\n-}\n-\n /// Adds or augment the existing `producers` section to encode information about\n /// the Rust compiler used to produce the wasm file.\n pub fn add_producer_section(\n@@ -266,15 +161,6 @@ impl<'a> WasmDecoder<'a> {\n         let len = self.u32();\n         str::from_utf8(self.skip(len as usize)).unwrap()\n     }\n-\n-    fn bool(&mut self) -> bool {\n-        self.byte() == 1\n-    }\n-\n-    fn limits(&mut self) -> (u32, Option<u32>) {\n-        let has_max = self.bool();\n-        (self.u32(), if has_max { Some(self.u32()) } else { None })\n-    }\n }\n \n struct WasmEncoder {\n@@ -302,16 +188,4 @@ impl WasmEncoder {\n     fn str(&mut self, val: &str) {\n         self.bytes(val.as_bytes())\n     }\n-\n-    fn bool(&mut self, b: bool) {\n-        self.byte(b as u8);\n-    }\n-\n-    fn limits(&mut self, limits: (u32, Option<u32>)) {\n-        self.bool(limits.1.is_some());\n-        self.u32(limits.0);\n-        if let Some(c) = limits.1 {\n-            self.u32(c);\n-        }\n-    }\n }"}, {"sha": "2d732adcb91381650d7114fd298098fb75e04cfb", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -113,7 +113,7 @@ pub fn get_fn(\n         unsafe {\n             llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n \n-            let is_generic = instance.substs.types().next().is_some();\n+            let is_generic = instance.substs.non_erasable_generics().next().is_some();\n \n             if is_generic {\n                 // This is a monomorphization. Its expected visibility depends"}, {"sha": "8c83e9ef538e5dfc40481dac5cd7ae5f76f55d82", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -213,10 +213,10 @@ impl CodegenCx<'ll, 'tcx> {\n \n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n \n-        let g = if let Some(id) = self.tcx.hir().as_local_node_id(def_id) {\n+        let g = if let Some(id) = self.tcx.hir().as_local_hir_id(def_id) {\n \n             let llty = self.layout_of(ty).llvm_type(self);\n-            let (g, attrs) = match self.tcx.hir().get(id) {\n+            let (g, attrs) = match self.tcx.hir().get_by_hir_id(id) {\n                 Node::Item(&hir::Item {\n                     ref attrs, span, node: hir::ItemKind::Static(..), ..\n                 }) => {"}, {"sha": "daccfc9b242f924da3e63444abd4c2c1b029334a", "filename": "src/librustc_codegen_llvm/debuginfo/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,21 +1,21 @@\n //! # Debug Info Module\n //!\n //! This module serves the purpose of generating debug symbols. We use LLVM's\n-//! [source level debugging](http://!llvm.org/docs/SourceLevelDebugging.html)\n+//! [source level debugging](https://llvm.org/docs/SourceLevelDebugging.html)\n //! features for generating the debug information. The general principle is\n //! this:\n //!\n //! Given the right metadata in the LLVM IR, the LLVM code generator is able to\n //! create DWARF debug symbols for the given code. The\n-//! [metadata](http://!llvm.org/docs/LangRef.html#metadata-type) is structured\n+//! [metadata](https://llvm.org/docs/LangRef.html#metadata-type) is structured\n //! much like DWARF *debugging information entries* (DIE), representing type\n //! information such as datatype layout, function signatures, block layout,\n //! variable location and scope information, etc. It is the purpose of this\n //! module to generate correct metadata and insert it into the LLVM IR.\n //!\n //! As the exact format of metadata trees may change between different LLVM\n //! versions, we now use LLVM\n-//! [DIBuilder](http://!llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n+//! [DIBuilder](https://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n //! to create metadata where possible. This will hopefully ease the adaption of\n //! this module to future LLVM versions.\n //!"}, {"sha": "c0869bb889afaba430b916ab5278f651bd076079", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -15,7 +15,7 @@ use crate::llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DISubprogram, D\n     DISPFlags, DILexicalBlock};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n-use rustc::ty::subst::{Substs, UnpackedKind};\n+use rustc::ty::subst::{SubstsRef, UnpackedKind};\n \n use crate::abi::Abi;\n use crate::common::CodegenCx;\n@@ -399,7 +399,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         fn get_template_parameters<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n             generics: &ty::Generics,\n-            substs: &Substs<'tcx>,\n+            substs: SubstsRef<'tcx>,\n             file_metadata: &'ll DIFile,\n             name_to_append_suffix_to: &mut String,\n         ) -> &'ll DIArray {"}, {"sha": "8b218ab39d99b520d60a3faa078b6d05d736d6ff", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -2,7 +2,7 @@\n \n use crate::common::CodegenCx;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty};\n use rustc_codegen_ssa::traits::*;\n \n@@ -143,7 +143,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.pop();\n             }\n \n-            if sig.variadic {\n+            if sig.c_variadic {\n                 if !sig.inputs().is_empty() {\n                     output.push_str(\", ...\");\n                 } else {\n@@ -193,13 +193,13 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         }\n     }\n \n-    // Pushes the type parameters in the given `Substs` to the output string.\n+    // Pushes the type parameters in the given `InternalSubsts` to the output string.\n     // This ignores region parameters, since they can't reliably be\n     // reconstructed for items from non-local crates. For local crates, this\n     // would be possible but with inlining and LTO we have to use the least\n     // common denominator - otherwise we would run into conflicts.\n     fn push_type_params<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                  substs: &Substs<'tcx>,\n+                                  substs: SubstsRef<'tcx>,\n                                   output: &mut String) {\n         if substs.types().next().is_none() {\n             return;"}, {"sha": "3268af396a2f4f475c2353b3ed76ea66083c8ec9", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "7b2b9ec24ea0f2d964b43e9d17e05b785d3a9907", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "7f0cdb9f580088b1b49f0e0ee1d08596f42afcb7", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "7aceaea4510ceb156246f1cea7cafcb110b548fc", "filename": "src/librustc_codegen_llvm/va_arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fva_arg.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "4702e34aa19e7fabe00b33304e339b3a47ea8d68", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "336f41b784a81cf3793ec6c213e684e4bfaf35bc", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "c84b38cde81853f39aae0869024b6f26e700c361", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "39ce15e4772967b9e4512738022deef64f54ad47", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "4744dd6302fb3200f1527371a04f35d19eaa598c", "filename": "src/librustc_codegen_ssa/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcallee.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "fec41936a238432314336d6f149669c70f51b5e0", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "facae9a9797065e843d8ee724e7c11ac5cfa0c1e", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "35fd30f34ad24e2a248224ff8fc6e73ce99cb3f7", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 783, "deletions": 632, "changes": 1415, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "349c9132842b893947cd5434e4edc2f364d68d47", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "bc77097425bd1350e30352d0c0591e19327f37f3", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 86, "deletions": 12, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "55a1eb016e0d0db1224b41b5b068d5440b80dd14", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "0408ccf039f340093dde20b6a4979e4cdebde86d", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "b8131671320e1ed86db2e444e59d8d7ac26aba7a", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "97729e8aeb35fce44b4e627120dcdcc16be7a1e5", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "48159d7979923803c69477df5ebae4877cf74fe0", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "a9e0eadb198a86f1fedea63c7b47f3763a6ede4d", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "cd5278989778ffac031c05d1b92e47883a5a808f", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "29bcb4f2e6446d0f0fcba81296a7a36a09d3443a", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "5de5c297c30e51acbec5875733e4dae6eed2e199", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "c495268154664ee7a4987030b5c5b87cc6f856aa", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "6002bf69b7069871ee9d75e4ab57c0d7edd81b83", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "278dcdf2bee42a49b830690e37bc00fa493388b2", "filename": "src/librustc_data_structures/box_region.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbox_region.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "359b89f683dc4ea7cc9f4da87e0579aa0862f2c5", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "48ac8125a0d66ff22d4d0d8f9a2377ccf9337c1c", "filename": "src/librustc_data_structures/jobserver.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Fjobserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Fjobserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fjobserver.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "a1d7ab8856daa4606e023dcabb62b136737a3511", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "029e7267c8247d40e0e5c91e4292a57966aef2ee", "filename": "src/librustc_data_structures/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fmacros.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "73247c1469efd78c0554a9e3c8ce8da82578a8af", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "52f23f4893eeb23e320e1a12776166722960f53d", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "a77e497af7b8720f1bcee109eaa9b24cacdfe28f", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "b998b77a76b9c4c3ba7fdfd744becfa4be588ae6", "filename": "src/librustc_driver/driver.rs", "status": "removed", "additions": 0, "deletions": 1686, "changes": 1686, "blob_url": "https://github.com/rust-lang/rust/blob/5c7ec6c421af26666d3ec1c5fe022d099133951c/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7ec6c421af26666d3ec1c5fe022d099133951c/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5c7ec6c421af26666d3ec1c5fe022d099133951c"}, {"sha": "c7b6f37fe29db8ddf1126995298dcb6b3bf38027", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 272, "deletions": 711, "changes": 983, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "3182b2ce30c6d52b1347297a464c68364213ae93", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 124, "deletions": 385, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "f98939eb40a8e45147178677ce410dd7e1ccfac2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 46, "deletions": 93, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "c8d47339fb36572432369715402c1a2a1fb7503b", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "7c7698ddd3d7397e98a7978be053af234a8a2604", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "df971ec5bdb85c9d0740a3afc5eef44f3db05a31", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "1f69d617c83b71949f40dcfc468e24a64d62fb0a", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "fe75bbc36c3b1eea28fdf0cd7d93ff8c9bea65c9", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "2794b6c556ff24652aa081903f5f0fdbac9a67c7", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "255a3899d1183e23b9e5af9c0acd011e5a6997fc", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "bf404140f18d5c39af7c683c7cc5952c93f305aa", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "294e23dc6177c74b7eba6a8bc50d8e910766f60f", "filename": "src/librustc_interface/Cargo.toml", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "ec6b26afb8c50400718d2bc8bc0054b03b55d180", "filename": "src/librustc_interface/interface.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "6a931c249b5bff312563b4f79be32683bf90aa5d", "filename": "src/librustc_interface/lib.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "d61ccd5605b60a276b3c14ee826bfd9e13dc7851", "filename": "src/librustc_interface/passes.rs", "status": "added", "additions": 1038, "deletions": 0, "changes": 1038, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "8ed03efd1a784ab8ca39ba712178d54d2e07e36d", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "previous_filename": "src/librustc_driver/proc_macro_decls.rs"}, {"sha": "eb13a5668f927f7d680349ad8628971e2c7f8896", "filename": "src/librustc_interface/profile/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fprofile%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "previous_filename": "src/librustc_driver/profile/mod.rs"}, {"sha": "95c4ea6ff23478ffd6868c06238be7d7e94d5190", "filename": "src/librustc_interface/profile/trace.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "previous_filename": "src/librustc_driver/profile/trace.rs"}, {"sha": "57ced0464d9fa1fd51f4530ea0237a4464b58176", "filename": "src/librustc_interface/queries.rs", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "0f858d632060e7cc39e1e65c139f0698b3dd4326", "filename": "src/librustc_interface/util.rs", "status": "added", "additions": 859, "deletions": 0, "changes": 859, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "7a7c49e46042807254be6805529bc44d0cf2656e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 113, "deletions": 54, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "73a32f6d2003a40f2ffadf2ab59436ff0dd5b168", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "fa18dd1eb8ddbd062f37ed2fdafe019ead86019c", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "4ad1a00afe97c2fec84f4a4f92dd4e0a987ad68c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "86b8b276eafe5930d35cb7c427705892690c0c6d", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "2fe51a22fb4845463e49754264e764309949e278", "filename": "src/librustc_macros/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2FCargo.toml?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "6d7590c7d1cd3928b4ecaaa7dec467fe895b0796", "filename": "src/librustc_macros/src/hash_stable.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "cad31264b05a415c16628077e0eb079194b74a64", "filename": "src/librustc_macros/src/lib.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "36d9bf9f50dd59b7c2a48e704102e3fa27f3cb1d", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 86, "deletions": 33, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "67a249e605ecc8e4ddb002df2ed1edbd8cfd7930", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "6fe00a4ad2ff2607090912870fbc4bc2875e4aac", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "ce0618d4599e714153e12ac551aee4331095632b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "284f6796145a8a3487460ede44b661cd3e8e1c0d", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "8343171b99f4b6f38d5195592c7e123312429dd0", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "81878c4f687b6df0797527264ad082f2c71e679c", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "23898387cba4677680027793ec6fce3d0108b455", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "afeea9947b5e3ecb149f9f42ecc1c0f7cdd13410", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "cbef7a7f6c481326bbc90bf6e6b1f27289ca6633", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "fe07cc0698a0a0e4f17c6f8e201e3919fa4f75f2", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "0bdf44c2ae0493ee2b3c50ec032143497ec12b05", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 32, "deletions": 50, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "bd4bf67d0b154b3856c71fcae5c4dd8b9fffa462", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "65703adfdff70c603e6d2f2e94f8061a4e157799", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "375dd6e97f1a29511f3a418fb587719687cd16cd", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "17f8c23f4fddc0cdf43c686e97f8f3bc0558a725", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "aafbff35776475a91d47624ba015b9b078e59906", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "2d3800dd1dda86d28f87e2a8d312e39825ab71e6", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "fdede054e15f304516dffe2c3c5d9f233c6363b7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "f0d3a0d2986e53bda4a3ae1b9e3aae5a0bc1c37d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "2101447965a15f705d92b5a89a40dfdca51204fe", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "0a0a88e694260c19dfa6ec995913d99e0fb10717", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "bef159e996b8778a60902d2a71d7c7116a992f5c", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "b9f9d83161b79649a7cb9b9a885b104c69113006", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/liveness_map.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5c7ec6c421af26666d3ec1c5fe022d099133951c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7ec6c421af26666d3ec1c5fe022d099133951c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs?ref=5c7ec6c421af26666d3ec1c5fe022d099133951c"}, {"sha": "9b8940098852c1bcb1f71aac390a8e31f57eadd3", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "960e75048fa1614d112fb2ec9d1a5da4862b320b", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "f0df7070e6b5ab41799f5d965dd014ab0849b719", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "5b444ab9690ca7dcb76be567974639aa7097b78f", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 282, "deletions": 42, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "4d9a3775b31230f83d94404ca73ff902d17a5cc7", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "9e0bb93c33a5d5fd0362875adc49b7e8b8c035c5", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "c05ee3cf65b36447f48fb53fd11322dbfdd9c8f7", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "1d18ada1fb69c97dad8b7ace197d65bf6d729d5b", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "384fd5c9987b8a325103bec4fa2c79fd473c37bd", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "b102bced0e335e18822f3a7d7019d464ae5297e3", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "cba5039122a76a080b444f70ec151d0757383f98", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "e354a2ee8160b47f1f17c40b8561df9eb14e82e4", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "20b95c363f5f7f9b875dff9127386cbf74079958", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "f1a82ecef1b1d60a7b7be427fe186b1bbe3290c7", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "cba771f27065d93cd6649f94ee44bfccfd3a2a43", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "c8c30ac3ce4d075a0c2238e1193a844a4a2a2695", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "4d0418beea4dd72bd6c4c7ced88835573452e64b", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "9527a23279570a060ec8fe07c23998b993f9fb9f", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "d3731e7c1274e3bfd5e4cf703937beab8a2af00c", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "d60a0941b5979048653a32b293a469049daf40a9", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "2692c24806ff7c861371e34b83c0f5691f98eba2", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "c8e48dea1f34c2cb04bad10d663d71728a97272b", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "4189e3e7ddbb6f92bca0a4eed7b2a7da65068396", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "365cb508b09253958b0b4a1543735b7c9a285235", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "f78c82a93020ce3bb7bf891864c93e47b079f00c", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "da9cc118f55215aedc3cbb48105b78f539a96b62", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "b9c8879b3c36429c5317bbba2607b3b536acecf1", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "b47aff3a4f8557ea19bd6174bcf53ff83193fcf0", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "4dcfb3f1a7fc32a9d01dda14d6bc64848ab451b3", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "03f8ac67436173ccac325789f812a2bd4f0aa444", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "7a9140bce6288f3faef7fe6f1bcd2b5a3463da1f", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "97f84675f94bf19d540efc7cbed7cbc84fc6bb4e", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "f58e61915e8c99d120db8bc72a714f97e62da050", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c"}]}