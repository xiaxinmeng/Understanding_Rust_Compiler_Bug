{"sha": "27a540db4709307928f5f5ca0e4b7f3e1ac947c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3YTU0MGRiNDcwOTMwNzkyOGY1ZjVjYTBlNGI3ZjNlMWFjOTQ3Yzk=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-12-01T04:44:40Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-03T02:34:18Z"}, "message": "Factor out a mess", "tree": {"sha": "093047844923f6db7158c27cd39fe8468a433252", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/093047844923f6db7158c27cd39fe8468a433252"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27a540db4709307928f5f5ca0e4b7f3e1ac947c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27a540db4709307928f5f5ca0e4b7f3e1ac947c9", "html_url": "https://github.com/rust-lang/rust/commit/27a540db4709307928f5f5ca0e4b7f3e1ac947c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27a540db4709307928f5f5ca0e4b7f3e1ac947c9/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16184d3e165018fa5b78f5f99cfc844e5af33bd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/16184d3e165018fa5b78f5f99cfc844e5af33bd6", "html_url": "https://github.com/rust-lang/rust/commit/16184d3e165018fa5b78f5f99cfc844e5af33bd6"}], "stats": {"total": 70, "additions": 39, "deletions": 31}, "files": [{"sha": "2c878fe16b58d0a57f379c7e51bbaf4f04a834d3", "filename": "src/expr.rs", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/27a540db4709307928f5f5ca0e4b7f3e1ac947c9/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27a540db4709307928f5f5ca0e4b7f3e1ac947c9/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=27a540db4709307928f5f5ca0e4b7f3e1ac947c9", "patch": "@@ -2042,42 +2042,27 @@ where\n                 tactic = DefinitiveListTactic::Horizontal;\n             } else {\n                 tactic = default_tactic();\n-                let is_simple_enough =\n-                    tactic == DefinitiveListTactic::Vertical && is_every_args_simple(args);\n-                if is_simple_enough\n-                    && FORMAT_LIKE_WHITELIST\n-                        .iter()\n-                        .find(|s| **s == callee_str)\n-                        .is_some()\n-                {\n-                    let args_tactic = definitive_tactic(\n-                        &item_vec[1..],\n-                        ListTactic::HorizontalVertical,\n-                        Separator::Comma,\n-                        nested_shape.width,\n-                    );\n-                    tactic = if args_tactic == DefinitiveListTactic::Horizontal {\n-                        DefinitiveListTactic::FormatCall\n-                    } else {\n-                        default_tactic()\n-                    };\n-                } else if is_simple_enough && item_vec.len() >= 2\n-                    && WRITE_LIKE_WHITELIST\n-                        .iter()\n-                        .find(|s| **s == callee_str)\n-                        .is_some()\n-                {\n+\n+                // For special-case macros, we may want to use different tactics.\n+                let maybe_args_offset = maybe_get_args_offset(callee_str, args);\n+\n+                if tactic == DefinitiveListTactic::Vertical && maybe_args_offset.is_some() {\n+                    let args_offset = maybe_args_offset.unwrap();\n                     let args_tactic = definitive_tactic(\n-                        &item_vec[2..],\n+                        &item_vec[args_offset..],\n                         ListTactic::HorizontalVertical,\n                         Separator::Comma,\n                         nested_shape.width,\n                     );\n-                    tactic = if args_tactic == DefinitiveListTactic::Horizontal {\n-                        DefinitiveListTactic::WriteCall\n-                    } else {\n-                        default_tactic()\n-                    };\n+\n+                    // Every argument is simple and fits on a single line.\n+                    if args_tactic == DefinitiveListTactic::Horizontal {\n+                        tactic = if args_offset == 1 {\n+                            DefinitiveListTactic::FormatCall\n+                        } else {\n+                            DefinitiveListTactic::WriteCall\n+                        };\n+                    }\n                 }\n             }\n         }\n@@ -2111,6 +2096,29 @@ fn is_every_args_simple<T: ToExpr>(lists: &[&T]) -> bool {\n         .all(|arg| arg.to_expr().map_or(false, is_simple_arg))\n }\n \n+/// In case special-case style is required, returns an offset from which we start horizontal layout.\n+fn maybe_get_args_offset<T: ToExpr>(callee_str: &str, args: &[&T]) -> Option<usize> {\n+    if FORMAT_LIKE_WHITELIST\n+        .iter()\n+        .find(|s| **s == callee_str)\n+        .is_some()\n+        && args.len() >= 1\n+        && is_every_args_simple(args)\n+    {\n+        Some(1)\n+    } else if WRITE_LIKE_WHITELIST\n+        .iter()\n+        .find(|s| **s == callee_str)\n+        .is_some()\n+        && args.len() >= 2\n+        && is_every_args_simple(args)\n+    {\n+        Some(2)\n+    } else {\n+        None\n+    }\n+}\n+\n /// Returns a shape for the last argument which is going to be overflowed.\n fn last_arg_shape<T>(\n     lists: &[&T],"}]}