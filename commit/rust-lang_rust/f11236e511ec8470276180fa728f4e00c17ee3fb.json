{"sha": "f11236e511ec8470276180fa728f4e00c17ee3fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMTIzNmU1MTFlYzg0NzAyNzYxODBmYTcyOGY0ZTAwYzE3ZWUzZmI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-17T17:06:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-17T17:06:10Z"}, "message": "Merge #4019\n\n4019: Add two more tests for associated types r=matklad a=flodiebold\n\n\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "9370da68d85534f89c168a10bb245cde73ce8fe4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9370da68d85534f89c168a10bb245cde73ce8fe4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f11236e511ec8470276180fa728f4e00c17ee3fb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJemeICCRBK7hj4Ov3rIwAAdHIIAFFPG1DrIb0xkPYvt6x2V3Jg\nN1NTvrH6eFaeVKZKl1pw/HRwcwS8AvQ0Mtkhl5dlEVPAmL7RQF5Dz6sj/+qxpk1B\nP/r88lb54wr3iXzo1uvLwtFrMt10QhyNn/VtZ3TNumXeui+vmte/qIcS+HNdgSWZ\nalTAwaCVI8B3u3h3DQcFOw1WSG0FM/Nkzc2znBGHsQtftrKdcQFcd/sowtudNrCI\nH5JwUTPMCT9N2XV0An9GEP4bA+hSti9TpvucCBqxZlrguEv5Pw+AsWrYVSYAg9Q+\nQ2XSIcVvgXhgU7JkM+p9yI23Bj0wxqXC5jobbUY4Y3s6f3I/+PpBB9FImjUALn4=\n=LLxy\n-----END PGP SIGNATURE-----\n", "payload": "tree 9370da68d85534f89c168a10bb245cde73ce8fe4\nparent 690a0b249eee6537953350be28a0ca11fa96b12a\nparent fbd95785a6746a8bf100a0417b592f5fa35df882\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1587143170 +0000\ncommitter GitHub <noreply@github.com> 1587143170 +0000\n\nMerge #4019\n\n4019: Add two more tests for associated types r=matklad a=flodiebold\n\n\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f11236e511ec8470276180fa728f4e00c17ee3fb", "html_url": "https://github.com/rust-lang/rust/commit/f11236e511ec8470276180fa728f4e00c17ee3fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f11236e511ec8470276180fa728f4e00c17ee3fb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "690a0b249eee6537953350be28a0ca11fa96b12a", "url": "https://api.github.com/repos/rust-lang/rust/commits/690a0b249eee6537953350be28a0ca11fa96b12a", "html_url": "https://github.com/rust-lang/rust/commit/690a0b249eee6537953350be28a0ca11fa96b12a"}, {"sha": "fbd95785a6746a8bf100a0417b592f5fa35df882", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd95785a6746a8bf100a0417b592f5fa35df882", "html_url": "https://github.com/rust-lang/rust/commit/fbd95785a6746a8bf100a0417b592f5fa35df882"}], "stats": {"total": 174, "additions": 174, "deletions": 0}, "files": [{"sha": "dc517fc4a6a472ad5805848dea0d66a980cd52d7", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/f11236e511ec8470276180fa728f4e00c17ee3fb/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11236e511ec8470276180fa728f4e00c17ee3fb/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=f11236e511ec8470276180fa728f4e00c17ee3fb", "patch": "@@ -2204,3 +2204,177 @@ fn test(x: Box<dyn Trait>) {\n     );\n     assert_eq!(t, \"()\");\n }\n+\n+#[test]\n+fn string_to_owned() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct String {}\n+pub trait ToOwned {\n+    type Owned;\n+    fn to_owned(&self) -> Self::Owned;\n+}\n+impl ToOwned for str {\n+    type Owned = String;\n+}\n+fn test() {\n+    \"foo\".to_owned()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"String\");\n+}\n+\n+#[test]\n+fn iterator_chain() {\n+    assert_snapshot!(\n+        infer(r#\"\n+//- /main.rs\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+#[lang = \"fn_mut\"]\n+trait FnMut<Args>: FnOnce<Args> { }\n+\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+pub trait Iterator {\n+    type Item;\n+\n+    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F>\n+    where\n+        F: FnMut(Self::Item) -> Option<B>,\n+    { loop {} }\n+\n+    fn for_each<F>(self, f: F)\n+    where\n+        F: FnMut(Self::Item),\n+    { loop {} }\n+}\n+\n+pub trait IntoIterator {\n+    type Item;\n+    type IntoIter: Iterator<Item = Self::Item>;\n+    fn into_iter(self) -> Self::IntoIter;\n+}\n+\n+pub struct FilterMap<I, F> { }\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> IntoIterator for I {\n+    type Item = I::Item;\n+    type IntoIter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n+struct Vec<T> {}\n+impl<T> Vec<T> {\n+    fn new() -> Self { loop {} }\n+}\n+\n+impl<T> IntoIterator for Vec<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+}\n+\n+pub struct IntoIter<T> { }\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+}\n+\n+fn main() {\n+    Vec::<i32>::new().into_iter()\n+      .filter_map(|x| if x > 0 { Some(x as u32) } else { None })\n+      .for_each(|y| { y; });\n+}\n+\"#),\n+        @r###\"\n+    [240; 244) 'self': Self\n+    [246; 247) 'f': F\n+    [331; 342) '{ loop {} }': FilterMap<Self, F>\n+    [333; 340) 'loop {}': !\n+    [338; 340) '{}': ()\n+    [363; 367) 'self': Self\n+    [369; 370) 'f': F\n+    [419; 430) '{ loop {} }': ()\n+    [421; 428) 'loop {}': !\n+    [426; 428) '{}': ()\n+    [539; 543) 'self': Self\n+    [868; 872) 'self': I\n+    [879; 899) '{     ...     }': I\n+    [889; 893) 'self': I\n+    [958; 969) '{ loop {} }': Vec<T>\n+    [960; 967) 'loop {}': !\n+    [965; 967) '{}': ()\n+    [1156; 1287) '{     ... }); }': ()\n+    [1162; 1177) 'Vec::<i32>::new': fn new<i32>() -> Vec<i32>\n+    [1162; 1179) 'Vec::<...:new()': Vec<i32>\n+    [1162; 1191) 'Vec::<...iter()': IntoIter<i32>\n+    [1162; 1256) 'Vec::<...one })': FilterMap<IntoIter<i32>, |i32| -> Option<u32>>\n+    [1162; 1284) 'Vec::<... y; })': ()\n+    [1210; 1255) '|x| if...None }': |i32| -> Option<u32>\n+    [1211; 1212) 'x': i32\n+    [1214; 1255) 'if x >...None }': Option<u32>\n+    [1217; 1218) 'x': i32\n+    [1217; 1222) 'x > 0': bool\n+    [1221; 1222) '0': i32\n+    [1223; 1241) '{ Some...u32) }': Option<u32>\n+    [1225; 1229) 'Some': Some<u32>(u32) -> Option<u32>\n+    [1225; 1239) 'Some(x as u32)': Option<u32>\n+    [1230; 1231) 'x': i32\n+    [1230; 1238) 'x as u32': u32\n+    [1247; 1255) '{ None }': Option<u32>\n+    [1249; 1253) 'None': Option<u32>\n+    [1273; 1283) '|y| { y; }': |u32| -> ()\n+    [1274; 1275) 'y': u32\n+    [1277; 1283) '{ y; }': ()\n+    [1279; 1280) 'y': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn nested_assoc() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct Bar;\n+struct Foo;\n+\n+trait A {\n+    type OutputA;\n+}\n+\n+impl A for Bar {\n+    type OutputA = Foo;\n+}\n+\n+trait B {\n+    type Output;\n+    fn foo() -> Self::Output;\n+}\n+\n+impl<T:A> B for T {\n+    type Output = T::OutputA;\n+    fn foo() -> Self::Output { loop {} }\n+}\n+\n+fn main() {\n+    Bar::foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"Foo\");\n+}"}]}