{"sha": "532b013b28adcaa6710f4ba263990debff50d860", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMmIwMTNiMjhhZGNhYTY3MTBmNGJhMjYzOTkwZGViZmY1MGQ4NjA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-26T12:47:52Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-18T23:26:27Z"}, "message": "Rename `ModuleS` -> `ModuleData`.", "tree": {"sha": "e993b4effa6951d21a0862ac80e222347e19426e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e993b4effa6951d21a0862ac80e222347e19426e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/532b013b28adcaa6710f4ba263990debff50d860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/532b013b28adcaa6710f4ba263990debff50d860", "html_url": "https://github.com/rust-lang/rust/commit/532b013b28adcaa6710f4ba263990debff50d860", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/532b013b28adcaa6710f4ba263990debff50d860/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa19274b72f0f1f2a4481cdf9114e30c1b5f336d", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa19274b72f0f1f2a4481cdf9114e30c1b5f336d", "html_url": "https://github.com/rust-lang/rust/commit/aa19274b72f0f1f2a4481cdf9114e30c1b5f336d"}], "stats": {"total": 36, "additions": 18, "deletions": 18}, "files": [{"sha": "2930e57422bfd867b508f06d024c0e30e1566f86", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/532b013b28adcaa6710f4ba263990debff50d860/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532b013b28adcaa6710f4ba263990debff50d860/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=532b013b28adcaa6710f4ba263990debff50d860", "patch": "@@ -16,7 +16,7 @@\n use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n-use {Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n+use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n use {Resolver, ResolverArenas};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use {resolve_error, resolve_struct_error, ResolutionError};\n@@ -261,12 +261,12 @@ impl<'b> Resolver<'b> {\n \n             ItemKind::Mod(..) => {\n                 let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                let module = self.arenas.alloc_module(ModuleS {\n+                let module = self.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n                     normal_ancestor_id: Some(item.id),\n-                    ..ModuleS::new(Some(parent), ModuleKind::Def(def, ident.name))\n+                    ..ModuleData::new(Some(parent), ModuleKind::Def(def, ident.name))\n                 });\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.module_map.insert(item.id, module);\n@@ -493,9 +493,9 @@ impl<'b> Resolver<'b> {\n         let macros_only = self.session.cstore.dep_kind(cnum).macros_only();\n         let arenas = self.arenas;\n         *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n-            arenas.alloc_module(ModuleS {\n+            arenas.alloc_module(ModuleData {\n                 populated: Cell::new(false),\n-                ..ModuleS::new(None, ModuleKind::Def(Def::Mod(def_id), keywords::Invalid.name()))\n+                ..ModuleData::new(None, ModuleKind::Def(Def::Mod(def_id), keywords::Invalid.name()))\n             })\n         })\n     }"}, {"sha": "d87e04f7b97f9e7b6c694a35ac1ab5cab82794df", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/532b013b28adcaa6710f4ba263990debff50d860/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532b013b28adcaa6710f4ba263990debff50d860/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=532b013b28adcaa6710f4ba263990debff50d860", "patch": "@@ -774,7 +774,7 @@ enum ModuleKind {\n }\n \n /// One node in the tree of modules.\n-pub struct ModuleS<'a> {\n+pub struct ModuleData<'a> {\n     parent: Option<Module<'a>>,\n     kind: ModuleKind,\n \n@@ -802,11 +802,11 @@ pub struct ModuleS<'a> {\n     populated: Cell<bool>,\n }\n \n-pub type Module<'a> = &'a ModuleS<'a>;\n+pub type Module<'a> = &'a ModuleData<'a>;\n \n-impl<'a> ModuleS<'a> {\n+impl<'a> ModuleData<'a> {\n     fn new(parent: Option<Module<'a>>, kind: ModuleKind) -> Self {\n-        ModuleS {\n+        ModuleData {\n             parent: parent,\n             kind: kind,\n             normal_ancestor_id: None,\n@@ -859,7 +859,7 @@ impl<'a> ModuleS<'a> {\n     }\n }\n \n-impl<'a> fmt::Debug for ModuleS<'a> {\n+impl<'a> fmt::Debug for ModuleData<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{:?}\", self.def())\n     }\n@@ -1116,7 +1116,7 @@ pub struct Resolver<'a> {\n }\n \n pub struct ResolverArenas<'a> {\n-    modules: arena::TypedArena<ModuleS<'a>>,\n+    modules: arena::TypedArena<ModuleData<'a>>,\n     local_modules: RefCell<Vec<Module<'a>>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n@@ -1126,7 +1126,7 @@ pub struct ResolverArenas<'a> {\n }\n \n impl<'a> ResolverArenas<'a> {\n-    fn alloc_module(&'a self, module: ModuleS<'a>) -> Module<'a> {\n+    fn alloc_module(&'a self, module: ModuleData<'a>) -> Module<'a> {\n         let module = self.modules.alloc(module);\n         if module.def_id().map(|def_id| def_id.is_local()).unwrap_or(true) {\n             self.local_modules.borrow_mut().push(module);\n@@ -1206,10 +1206,10 @@ impl<'a> Resolver<'a> {\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def = Def::Mod(DefId::local(CRATE_DEF_INDEX));\n-        let graph_root = arenas.alloc_module(ModuleS {\n+        let graph_root = arenas.alloc_module(ModuleData {\n             normal_ancestor_id: Some(CRATE_NODE_ID),\n             no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n-            ..ModuleS::new(None, ModuleKind::Def(root_def, keywords::Invalid.name()))\n+            ..ModuleData::new(None, ModuleKind::Def(root_def, keywords::Invalid.name()))\n         });\n         let mut module_map = NodeMap();\n         module_map.insert(CRATE_NODE_ID, graph_root);\n@@ -1327,17 +1327,17 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn new_module(&self, parent: Module<'a>, kind: ModuleKind, local: bool) -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS {\n+        self.arenas.alloc_module(ModuleData {\n             normal_ancestor_id: if local { self.current_module.normal_ancestor_id } else { None },\n             populated: Cell::new(local),\n-            ..ModuleS::new(Some(parent), kind)\n+            ..ModuleData::new(Some(parent), kind)\n         })\n     }\n \n     fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n                   -> bool /* true if an error was reported */ {\n         // track extern crates for unused_extern_crate lint\n-        if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleS::def_id) {\n+        if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleData::def_id) {\n             self.used_crates.insert(krate);\n         }\n \n@@ -2403,7 +2403,7 @@ impl<'a> Resolver<'a> {\n                             });\n                         }\n                     }\n-                    let msg = if module.and_then(ModuleS::def) == self.graph_root.def() {\n+                    let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n                             self.lookup_candidates(ident.name, TypeNS, is_mod).candidates;"}]}