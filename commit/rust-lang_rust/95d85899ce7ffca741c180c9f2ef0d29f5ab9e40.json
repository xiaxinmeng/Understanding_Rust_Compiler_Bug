{"sha": "95d85899ce7ffca741c180c9f2ef0d29f5ab9e40", "node_id": "C_kwDOAAsO6NoAKDk1ZDg1ODk5Y2U3ZmZjYTc0MWMxODBjOWYyZWYwZDI5ZjVhYjllNDA", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-06-13T01:07:38Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-06-14T00:15:59Z"}, "message": "Add more measurements to the CGU debug printing.\n\nFor example, we go from this:\n```\nFINAL (4059 items, total_size=232342; 16 CGUs, max_size=39608,\nmin_size=5468, max_size/min_size=7.2):\n- CGU[0] regex.f2ff11e98f8b05c7-cgu.0 (318 items, size=39608):\n  - fn ...\n  - fn ...\n```\nto this:\n```\nFINAL\n- unique items: 2726 (1459 root + 1267 inlined), unique size: 201214 (146046 root + 55168 inlined)\n- placed items: 4059 (1459 root + 2600 inlined), placed size: 232342 (146046 root + 86296 inlined)\n- placed/unique items ratio: 1.49, placed/unique size ratio: 1.15\n- CGUs: 16, mean size: 14521.4, sizes: [39608, 31122, 20318, 20236, 16268, 13777, 12310, 10531, 10205, 9810, 9250, 9065 (x2), 7785, 7524, 5468]\n\n- CGU[0]\n  - regex.f2ff11e98f8b05c7-cgu.0, size: 39608\n  - items: 318, mean size: 124.6, sizes: [28395, 3418, 558, 485, 259, 228, 176, 166, 146, 118, 117 (x3), 114 (x5), 113 (x3), 101, 84, 82, 77, 76, 72, 71 (x2), 66, 65, 62, 61, 59 (x2), 57, 55, 54 (x2), 53 (x4), 52 (x5), 51 (x4), 50, 48, 47, 46, 45 (x3), 44, 43 (x5), 42, 40, 38 (x4), 37, 35, 34 (x2), 32 (x2), 31, 30, 28 (x2), 27 (x2), 26 (x3), 24 (x2), 23 (x3), 22 (x2), 21, 20, 16 (x4), 15, 13 (x7), 12 (x3), 11 (x6), 10, 9 (x2), 8 (x4), 7 (x8), 6 (x38), 5 (x21), 4 (x7), 3 (x45), 2 (x63), 1 (x13)]\n  - fn ...\n  - fn ...\n```\nThis is a lot more information, distinguishing between root items and\ninlined items, showing how much duplication there is of inlined items,\nplus the full range of sizes for CGUs and items within CGUs. All of\nwhich is really helpful when analyzing this stuff and trying different\nCGU formation algorithms.", "tree": {"sha": "b171344ab9fcd76abb2914888629ab15216034fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b171344ab9fcd76abb2914888629ab15216034fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95d85899ce7ffca741c180c9f2ef0d29f5ab9e40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95d85899ce7ffca741c180c9f2ef0d29f5ab9e40", "html_url": "https://github.com/rust-lang/rust/commit/95d85899ce7ffca741c180c9f2ef0d29f5ab9e40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95d85899ce7ffca741c180c9f2ef0d29f5ab9e40/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51821515b3ccd7dd8f42ffd6a2eee536dcf7ddb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/51821515b3ccd7dd8f42ffd6a2eee536dcf7ddb0", "html_url": "https://github.com/rust-lang/rust/commit/51821515b3ccd7dd8f42ffd6a2eee536dcf7ddb0"}], "stats": {"total": 157, "additions": 134, "deletions": 23}, "files": [{"sha": "f0c9605da1d1321290ae5c272983b6a046aee5ef", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "modified", "additions": 134, "deletions": 23, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/95d85899ce7ffca741c180c9f2ef0d29f5ab9e40/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d85899ce7ffca741c180c9f2ef0d29f5ab9e40/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=95d85899ce7ffca741c180c9f2ef0d29f5ab9e40", "patch": "@@ -129,6 +129,11 @@ struct PlacedRootMonoItems<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n \n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+\n+    /// These must be obtained when the iterator in `partition` runs. They\n+    /// can't be obtained later because some inlined functions might not be\n+    /// reachable.\n+    unique_inlined_stats: (usize, usize),\n }\n \n // The output CGUs are sorted by name.\n@@ -147,7 +152,7 @@ where\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n-    let PlacedRootMonoItems { mut codegen_units, internalization_candidates } = {\n+    let PlacedRootMonoItems { mut codegen_units, internalization_candidates, unique_inlined_stats } = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n         place_root_mono_items(cx, mono_items)\n     };\n@@ -156,15 +161,15 @@ where\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"INITIAL PARTITIONING\", &codegen_units);\n+    debug_dump(tcx, \"ROOTS\", &codegen_units, unique_inlined_stats);\n \n     // Merge until we have at most `max_cgu_count` codegen units.\n     // `merge_codegen_units` is responsible for updating the CGU size\n     // estimates.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n         merge_codegen_units(cx, &mut codegen_units);\n-        debug_dump(tcx, \"POST MERGING\", &codegen_units);\n+        debug_dump(tcx, \"MERGE\", &codegen_units, unique_inlined_stats);\n     }\n \n     // In the next step, we use the inlining map to determine which additional\n@@ -180,7 +185,7 @@ where\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"POST INLINING\", &codegen_units);\n+    debug_dump(tcx, \"INLINE\", &codegen_units, unique_inlined_stats);\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n     // more freedom to optimize.\n@@ -224,7 +229,7 @@ where\n     // Ensure CGUs are sorted by name, so that we get deterministic results.\n     assert!(codegen_units.is_sorted_by(|a, b| Some(a.name().as_str().cmp(b.name().as_str()))));\n \n-    debug_dump(tcx, \"FINAL\", &codegen_units);\n+    debug_dump(tcx, \"FINAL\", &codegen_units, unique_inlined_stats);\n \n     codegen_units\n }\n@@ -250,10 +255,16 @@ where\n     let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n     let cgu_name_cache = &mut FxHashMap::default();\n \n+    let mut num_unique_inlined_items = 0;\n+    let mut unique_inlined_items_size = 0;\n     for mono_item in mono_items {\n         match mono_item.instantiation_mode(cx.tcx) {\n             InstantiationMode::GloballyShared { .. } => {}\n-            InstantiationMode::LocalCopy => continue,\n+            InstantiationMode::LocalCopy => {\n+                num_unique_inlined_items += 1;\n+                unique_inlined_items_size += mono_item.size_estimate(cx.tcx);\n+                continue;\n+            }\n         }\n \n         let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n@@ -298,7 +309,11 @@ where\n     let mut codegen_units: Vec<_> = codegen_units.into_values().collect();\n     codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n \n-    PlacedRootMonoItems { codegen_units, internalization_candidates }\n+    PlacedRootMonoItems {\n+        codegen_units,\n+        internalization_candidates,\n+        unique_inlined_stats: (num_unique_inlined_items, unique_inlined_items_size),\n+    }\n }\n \n // This function requires the CGUs to be sorted by name on input, and ensures\n@@ -812,31 +827,91 @@ fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibilit\n     }\n }\n \n-fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n+fn debug_dump<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'tcx>,\n+    label: &str,\n+    cgus: &[CodegenUnit<'tcx>],\n+    (unique_inlined_items, unique_inlined_size): (usize, usize),\n+) {\n     let dump = move || {\n         use std::fmt::Write;\n \n-        let num_cgus = cgus.len();\n-        let num_items: usize = cgus.iter().map(|cgu| cgu.items().len()).sum();\n-        let total_size: usize = cgus.iter().map(|cgu| cgu.size_estimate()).sum();\n-        let max_size = cgus.iter().map(|cgu| cgu.size_estimate()).max().unwrap();\n-        let min_size = cgus.iter().map(|cgu| cgu.size_estimate()).min().unwrap();\n-        let max_min_size_ratio = max_size as f64 / min_size as f64;\n+        let mut num_cgus = 0;\n+        let mut all_cgu_sizes = Vec::new();\n+\n+        // Note: every unique root item is placed exactly once, so the number\n+        // of unique root items always equals the number of placed root items.\n+\n+        let mut root_items = 0;\n+        // unique_inlined_items is passed in above.\n+        let mut placed_inlined_items = 0;\n+\n+        let mut root_size = 0;\n+        // unique_inlined_size is passed in above.\n+        let mut placed_inlined_size = 0;\n+\n+        for cgu in cgus.iter() {\n+            num_cgus += 1;\n+            all_cgu_sizes.push(cgu.size_estimate());\n+\n+            for (item, _) in cgu.items() {\n+                match item.instantiation_mode(tcx) {\n+                    InstantiationMode::GloballyShared { .. } => {\n+                        root_items += 1;\n+                        root_size += item.size_estimate(tcx);\n+                    }\n+                    InstantiationMode::LocalCopy => {\n+                        placed_inlined_items += 1;\n+                        placed_inlined_size += item.size_estimate(tcx);\n+                    }\n+                }\n+            }\n+        }\n+\n+        all_cgu_sizes.sort_unstable_by_key(|&n| cmp::Reverse(n));\n+\n+        let unique_items = root_items + unique_inlined_items;\n+        let placed_items = root_items + placed_inlined_items;\n+        let items_ratio = placed_items as f64 / unique_items as f64;\n+\n+        let unique_size = root_size + unique_inlined_size;\n+        let placed_size = root_size + placed_inlined_size;\n+        let size_ratio = placed_size as f64 / unique_size as f64;\n+\n+        let mean_cgu_size = placed_size as f64 / num_cgus as f64;\n+\n+        assert_eq!(placed_size, all_cgu_sizes.iter().sum::<usize>());\n \n         let s = &mut String::new();\n+        let _ = writeln!(s, \"{label}\");\n         let _ = writeln!(\n             s,\n-            \"{label} ({num_items} items, total_size={total_size}; {num_cgus} CGUs, \\\n-             max_size={max_size}, min_size={min_size}, max_size/min_size={max_min_size_ratio:.1}):\"\n+            \"- unique items: {unique_items} ({root_items} root + {unique_inlined_items} inlined), \\\n+               unique size: {unique_size} ({root_size} root + {unique_inlined_size} inlined)\\n\\\n+             - placed items: {placed_items} ({root_items} root + {placed_inlined_items} inlined), \\\n+               placed size: {placed_size} ({root_size} root + {placed_inlined_size} inlined)\\n\\\n+             - placed/unique items ratio: {items_ratio:.2}, \\\n+               placed/unique size ratio: {size_ratio:.2}\\n\\\n+             - CGUs: {num_cgus}, mean size: {mean_cgu_size:.1}, sizes: {}\",\n+            list(&all_cgu_sizes),\n         );\n+        let _ = writeln!(s);\n+\n         for (i, cgu) in cgus.iter().enumerate() {\n+            let name = cgu.name();\n+            let size = cgu.size_estimate();\n             let num_items = cgu.items().len();\n-            let _ = writeln!(\n-                s,\n-                \"- CGU[{i}] {} ({num_items} items, size={}):\",\n-                cgu.name(),\n-                cgu.size_estimate()\n-            );\n+            let mean_size = size as f64 / num_items as f64;\n+\n+            let mut placed_item_sizes: Vec<_> =\n+                cgu.items().iter().map(|(item, _)| item.size_estimate(tcx)).collect();\n+            placed_item_sizes.sort_unstable_by_key(|&n| cmp::Reverse(n));\n+            let sizes = list(&placed_item_sizes);\n+\n+            let _ = writeln!(s, \"- CGU[{i}]\");\n+            let _ = writeln!(s, \"  - {name}, size: {size}\");\n+            let _ =\n+                writeln!(s, \"  - items: {num_items}, mean size: {mean_size:.1}, sizes: {sizes}\",);\n \n             for (item, linkage) in cgu.items_in_deterministic_order(tcx) {\n                 let symbol_name = item.symbol_name(tcx).name;\n@@ -852,7 +927,43 @@ fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<\n             let _ = writeln!(s);\n         }\n \n-        std::mem::take(s)\n+        return std::mem::take(s);\n+\n+        // Converts a slice to a string, capturing repetitions to save space.\n+        // E.g. `[4, 4, 4, 3, 2, 1, 1, 1, 1, 1]` -> \"[4 (x3), 3, 2, 1 (x5)]\".\n+        fn list(ns: &[usize]) -> String {\n+            let mut v = Vec::new();\n+            if ns.is_empty() {\n+                return \"[]\".to_string();\n+            }\n+\n+            let mut elem = |curr, curr_count| {\n+                if curr_count == 1 {\n+                    v.push(format!(\"{curr}\"));\n+                } else {\n+                    v.push(format!(\"{curr} (x{curr_count})\"));\n+                }\n+            };\n+\n+            let mut curr = ns[0];\n+            let mut curr_count = 1;\n+\n+            for &n in &ns[1..] {\n+                if n != curr {\n+                    elem(curr, curr_count);\n+                    curr = n;\n+                    curr_count = 1;\n+                } else {\n+                    curr_count += 1;\n+                }\n+            }\n+            elem(curr, curr_count);\n+\n+            let mut s = \"[\".to_string();\n+            s.push_str(&v.join(\", \"));\n+            s.push_str(\"]\");\n+            s\n+        }\n     };\n \n     debug!(\"{}\", dump());"}]}