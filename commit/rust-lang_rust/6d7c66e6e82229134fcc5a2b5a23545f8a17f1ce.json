{"sha": "6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkN2M2NmU2ZTgyMjI5MTM0ZmNjNWEyYjVhMjM1NDVmOGExN2YxY2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-21T19:46:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-03T09:34:59Z"}, "message": "Introduce a \"liberated fn sigs\" map so that we have easy access to this\ninformation when constructing MIR.", "tree": {"sha": "b8107ccf92cc18b283ef11248d84864421a83e03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8107ccf92cc18b283ef11248d84864421a83e03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce", "html_url": "https://github.com/rust-lang/rust/commit/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fffe0757086b8f381226cb5ddcb6c129a815b96d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fffe0757086b8f381226cb5ddcb6c129a815b96d", "html_url": "https://github.com/rust-lang/rust/commit/fffe0757086b8f381226cb5ddcb6c129a815b96d"}], "stats": {"total": 77, "additions": 53, "deletions": 24}, "files": [{"sha": "a8f045074bd72df54be8268e51073161ca0cc27e", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce", "patch": "@@ -121,6 +121,13 @@ pub struct Tables<'tcx> {\n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n     pub closure_kinds: DefIdMap<ty::ClosureKind>,\n+\n+    /// For each fn, records the \"liberated\" types of its arguments\n+    /// and return type. Liberated means that all bound regions\n+    /// (including late-bound regions) are replaced with free\n+    /// equivalents. This table is not used in trans (since regions\n+    /// are erased there) and hence is not serialized to metadata.\n+    pub liberated_fn_sigs: NodeMap<ty::FnSig<'tcx>>,\n }\n \n impl<'tcx> Tables<'tcx> {\n@@ -133,6 +140,7 @@ impl<'tcx> Tables<'tcx> {\n             upvar_capture_map: FnvHashMap(),\n             closure_tys: DefIdMap(),\n             closure_kinds: DefIdMap(),\n+            liberated_fn_sigs: NodeMap(),\n         }\n     }\n "}, {"sha": "dc2b2b75ab6d15f166d12e81efcc46357152e481", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce", "patch": "@@ -164,11 +164,6 @@ pub struct Inherited<'a, 'tcx: 'a> {\n \n     tables: &'a RefCell<ty::Tables<'tcx>>,\n \n-    // A mapping from each fn's id to its signature, with all bound\n-    // regions replaced with free ones. Unlike the other tables, this\n-    // one is never copied into the tcx: it is only used by regionck.\n-    fn_sig_map: RefCell<NodeMap<Vec<Ty<'tcx>>>>,\n-\n     // When we process a call like `c()` where `c` is a closure type,\n     // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n     // `FnOnce` closure. In that case, we defer full resolution of the\n@@ -314,7 +309,6 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env), true),\n             locals: RefCell::new(NodeMap()),\n             tables: tables,\n-            fn_sig_map: RefCell::new(NodeMap()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n         }\n@@ -620,22 +614,13 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         ccx: ccx\n     };\n \n-    // Remember return type so that regionck can access it later.\n-    let mut fn_sig_tys: Vec<Ty> =\n-        arg_tys.iter()\n-        .cloned()\n-        .collect();\n-\n     if let ty::FnConverging(ret_ty) = ret_ty {\n         fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::ReturnType);\n-        fn_sig_tys.push(ret_ty); // FIXME(#25759) just take implied bounds from the arguments\n     }\n \n-    debug!(\"fn-sig-map: fn_id={} fn_sig_tys={:?}\",\n-           fn_id,\n-           fn_sig_tys);\n+    debug!(\"fn-sig-map: fn_id={} fn_sig={:?}\", fn_id, fn_sig);\n \n-    inherited.fn_sig_map.borrow_mut().insert(fn_id, fn_sig_tys);\n+    inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig.clone());\n \n     {\n         let mut visit = GatherLocalsVisitor { fcx: &fcx, };"}, {"sha": "3cdc9b559446eee1003ebe4644eb1ff2ada5ce53", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce", "patch": "@@ -284,19 +284,32 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         // When we enter a function, we can derive\n         debug!(\"visit_fn_body(id={})\", id);\n \n-        let fn_sig_map = self.fcx.inh.fn_sig_map.borrow();\n-        let fn_sig = match fn_sig_map.get(&id) {\n-            Some(f) => f,\n-            None => {\n-                self.tcx().sess.bug(\n-                    &format!(\"No fn-sig entry for id={}\", id));\n+        let fn_sig = {\n+            let fn_sig_map = &self.infcx().tables.borrow().liberated_fn_sigs;\n+            match fn_sig_map.get(&id) {\n+                Some(f) => f.clone(),\n+                None => {\n+                    self.tcx().sess.bug(\n+                        &format!(\"No fn-sig entry for id={}\", id));\n+                }\n             }\n         };\n \n         let old_region_bounds_pairs_len = self.region_bound_pairs.len();\n \n+        // Collect the types from which we create inferred bounds.\n+        // For the return type, if diverging, substitute `bool` just\n+        // because it will have no effect.\n+        //\n+        // FIXME(#25759) return types should not be implied bounds\n+        let fn_sig_tys: Vec<_> =\n+            fn_sig.inputs.iter()\n+                         .cloned()\n+                         .chain(Some(fn_sig.output.unwrap_or(self.tcx().types.bool)))\n+                         .collect();\n+\n         let old_body_id = self.set_body_id(body.id);\n-        self.relate_free_regions(&fn_sig[..], body.id, span);\n+        self.relate_free_regions(&fn_sig_tys[..], body.id, span);\n         link_fn_args(self,\n                      self.tcx().region_maps.node_extent(body.id),\n                      &fn_decl.inputs[..]);"}, {"sha": "cfab28f923e0942f3463a8d9dfd811b30616f07c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=6d7c66e6e82229134fcc5a2b5a23545f8a17f1ce", "patch": "@@ -43,6 +43,7 @@ pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &hir::Expr) {\n     wbcx.visit_expr(e);\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_closures();\n+    wbcx.visit_liberated_fn_sigs();\n }\n \n pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n@@ -63,6 +64,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     }\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_closures();\n+    wbcx.visit_liberated_fn_sigs();\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -361,6 +363,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n+    fn visit_liberated_fn_sigs(&self) {\n+        for (&node_id, fn_sig) in self.fcx.inh.tables.borrow().liberated_fn_sigs.iter() {\n+            let fn_sig = self.resolve(fn_sig, ResolvingFnSig(node_id));\n+            self.tcx().tables.borrow_mut().liberated_fn_sigs.insert(node_id, fn_sig.clone());\n+        }\n+    }\n+\n     fn resolve<T:TypeFoldable<'tcx>>(&self, t: &T, reason: ResolveReason) -> T {\n         t.fold_with(&mut Resolver::new(self.fcx, reason))\n     }\n@@ -376,6 +385,7 @@ enum ResolveReason {\n     ResolvingPattern(Span),\n     ResolvingUpvar(ty::UpvarId),\n     ResolvingClosure(DefId),\n+    ResolvingFnSig(ast::NodeId),\n }\n \n impl ResolveReason {\n@@ -387,6 +397,9 @@ impl ResolveReason {\n             ResolvingUpvar(upvar_id) => {\n                 tcx.expr_span(upvar_id.closure_expr_id)\n             }\n+            ResolvingFnSig(id) => {\n+                tcx.map.span(id)\n+            }\n             ResolvingClosure(did) => {\n                 if let Some(node_id) = tcx.map.as_local_node_id(did) {\n                     tcx.expr_span(node_id)\n@@ -463,6 +476,16 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                     span_err!(self.tcx.sess, span, E0196,\n                               \"cannot determine a type for this closure\")\n                 }\n+\n+                ResolvingFnSig(id) => {\n+                    // any failures here should also fail when\n+                    // resolving the patterns, closure types, or\n+                    // something else.\n+                    let span = self.reason.span(self.tcx);\n+                    self.tcx.sess.delay_span_bug(\n+                        span,\n+                        &format!(\"cannot resolve some aspect of fn sig for {:?}\", id));\n+                }\n             }\n         }\n     }"}]}