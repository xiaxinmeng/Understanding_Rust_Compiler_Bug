{"sha": "e564fc7f6b02e917407b3aa6235fc0727afdaf2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NjRmYzdmNmIwMmU5MTc0MDdiM2FhNjIzNWZjMDcyN2FmZGFmMmM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-20T08:55:10Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-20T08:55:10Z"}, "message": "core::rt: Don't directly create scheduler types in I/O tests\n\nThere are some better abstractions for this now", "tree": {"sha": "283bcb636323ac0b546d6bb17975b78572c16ea6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/283bcb636323ac0b546d6bb17975b78572c16ea6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e564fc7f6b02e917407b3aa6235fc0727afdaf2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e564fc7f6b02e917407b3aa6235fc0727afdaf2c", "html_url": "https://github.com/rust-lang/rust/commit/e564fc7f6b02e917407b3aa6235fc0727afdaf2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e564fc7f6b02e917407b3aa6235fc0727afdaf2c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a7561be4d2046a6a6b78ae5dab2e6fd3ba8db82", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a7561be4d2046a6a6b78ae5dab2e6fd3ba8db82", "html_url": "https://github.com/rust-lang/rust/commit/1a7561be4d2046a6a6b78ae5dab2e6fd3ba8db82"}], "stats": {"total": 103, "additions": 50, "deletions": 53}, "files": [{"sha": "dfc058d6eba5cdf1bc21b85a0e85d9b1a8772e52", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e564fc7f6b02e917407b3aa6235fc0727afdaf2c/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e564fc7f6b02e917407b3aa6235fc0727afdaf2c/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=e564fc7f6b02e917407b3aa6235fc0727afdaf2c", "patch": "@@ -28,6 +28,22 @@ pub fn run_in_newsched_task(f: ~fn()) {\n     }\n }\n \n+/// Create a new task and run it right now\n+pub fn spawn_immediately(f: ~fn()) {\n+    use cell::Cell;\n+    use super::*;\n+    use super::sched::*;\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Task::new(&mut sched.stack_pool, f);\n+    do sched.switch_running_tasks_and_then(task) |task| {\n+        let task = Cell(task);\n+        do local_sched::borrow |sched| {\n+            sched.task_queue.push_front(task.take());\n+        }\n+    }\n+}\n+\n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n     unsafe {"}, {"sha": "d3953b7a797abdde3ea6cf86754798c39adc5f63", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 34, "deletions": 53, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e564fc7f6b02e917407b3aa6235fc0727afdaf2c/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e564fc7f6b02e917407b3aa6235fc0727afdaf2c/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=e564fc7f6b02e917407b3aa6235fc0727afdaf2c", "patch": "@@ -22,7 +22,7 @@ use super::sched::{Scheduler, local_sched};\n #[cfg(test)] use uint;\n #[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use super::sched::Task;\n-#[cfg(test)] use super::test::next_test_port;\n+#[cfg(test)] use super::test::*;\n \n pub struct UvEventLoop {\n     uvio: UvIoFactory\n@@ -336,35 +336,21 @@ impl Stream for UvStream {\n \n #[test]\n fn test_simple_io_no_connect() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let addr = Ipv4(127, 0, 0, 1, next_test_port());\n-            let maybe_chan = io.connect(addr);\n-            assert!(maybe_chan.is_none());\n-        };\n-        sched.task_queue.push_back(task);\n-        sched.run();\n+    do run_in_newsched_task {\n+        let io = unsafe { local_sched::unsafe_borrow_io() };\n+        let addr = Ipv4(127, 0, 0, 1, next_test_port());\n+        let maybe_chan = io.connect(addr);\n+        assert!(maybe_chan.is_none());\n     }\n }\n \n #[test]\n fn test_simple_tcp_server_and_client() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n+    do run_in_newsched_task {\n         let addr = Ipv4(127, 0, 0, 1, next_test_port());\n \n-        let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n-                let mut stream = io.connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n-            }\n-        };\n-\n-        let server_task = ~do Task::new(&mut sched.stack_pool) {\n+        // Start the server first so it's listening when we connect\n+        do spawn_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n                 let mut listener = io.bind(addr).unwrap();\n@@ -379,32 +365,25 @@ fn test_simple_tcp_server_and_client() {\n                 stream.close();\n                 listener.close();\n             }\n-        };\n+        }\n \n-        // Start the server first so it listens before the client connects\n-        sched.task_queue.push_back(server_task);\n-        sched.task_queue.push_back(client_task);\n-        sched.run();\n+        do spawn_immediately {\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = io.connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.close();\n+            }\n+        }\n     }\n }\n \n #[test] #[ignore(reason = \"busted\")]\n fn test_read_and_block() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n+    do run_in_newsched_task {\n         let addr = Ipv4(127, 0, 0, 1, next_test_port());\n \n-        let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.close();\n-        };\n-\n-        let server_task = ~do Task::new(&mut sched.stack_pool) {\n+        do spawn_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut listener = io.bind(addr).unwrap();\n             let mut stream = listener.listen().unwrap();\n@@ -440,22 +419,27 @@ fn test_read_and_block() {\n \n             stream.close();\n             listener.close();\n-        };\n+        }\n+\n+        do spawn_immediately {\n+            let io = unsafe { local_sched::unsafe_borrow_io() };\n+            let mut stream = io.connect(addr).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.close();\n+        }\n \n-        // Start the server first so it listens before the client connects\n-        sched.task_queue.push_back(server_task);\n-        sched.task_queue.push_back(client_task);\n-        sched.run();\n     }\n }\n \n #[test] #[ignore(reason = \"needs server\")]\n fn test_read_read_read() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n+    do run_in_newsched_task {\n         let addr = Ipv4(127, 0, 0, 1, next_test_port());\n \n-        let client_task = ~do Task::new(&mut sched.stack_pool) {\n+        do spawn_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut stream = io.connect(addr).unwrap();\n             let mut buf = [0, .. 2048];\n@@ -467,9 +451,6 @@ fn test_read_read_read() {\n             }\n             rtdebug_!(\"read %u bytes total\", total_bytes_read as uint);\n             stream.close();\n-        };\n-\n-        sched.task_queue.push_back(client_task);\n-        sched.run();\n+        }\n     }\n }"}]}