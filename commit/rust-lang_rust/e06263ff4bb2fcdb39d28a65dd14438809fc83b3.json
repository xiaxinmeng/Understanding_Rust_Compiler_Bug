{"sha": "e06263ff4bb2fcdb39d28a65dd14438809fc83b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNjI2M2ZmNGJiMmZjZGIzOWQyOGE2NWRkMTQ0Mzg4MDlmYzgzYjM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-22T01:26:43Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-22T01:27:29Z"}, "message": "rustc: Reference count the function context in typechecking so that passing it around via objects isn't as costly", "tree": {"sha": "4536329f7a788d57e13da7fff48930565041f314", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4536329f7a788d57e13da7fff48930565041f314"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e06263ff4bb2fcdb39d28a65dd14438809fc83b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e06263ff4bb2fcdb39d28a65dd14438809fc83b3", "html_url": "https://github.com/rust-lang/rust/commit/e06263ff4bb2fcdb39d28a65dd14438809fc83b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e06263ff4bb2fcdb39d28a65dd14438809fc83b3/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3504f4a4bf492886aa6cc7b2eae5d8e0100e9d51", "url": "https://api.github.com/repos/rust-lang/rust/commits/3504f4a4bf492886aa6cc7b2eae5d8e0100e9d51", "html_url": "https://github.com/rust-lang/rust/commit/3504f4a4bf492886aa6cc7b2eae5d8e0100e9d51"}], "stats": {"total": 43, "additions": 21, "deletions": 22}, "files": [{"sha": "9f7093ace135d48eee219df3cf47944299540127", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e06263ff4bb2fcdb39d28a65dd14438809fc83b3/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e06263ff4bb2fcdb39d28a65dd14438809fc83b3/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e06263ff4bb2fcdb39d28a65dd14438809fc83b3", "patch": "@@ -513,7 +513,7 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n \n // Type unification\n \n-fn unify(&fn_ctxt fcx, @ty.t expected, @ty.t actual) -> unify_result {\n+fn unify(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> unify_result {\n     // Wraps the given type in an appropriate cname.\n     //\n     // TODO: This doesn't do anything yet. We should carry the cname up from\n@@ -530,7 +530,7 @@ fn unify(&fn_ctxt fcx, @ty.t expected, @ty.t actual) -> unify_result {\n         ret ures_err(terr_mismatch, expected, actual);\n     }\n \n-    fn unify_step(&fn_ctxt fcx, &hashmap[int,@ty.t] bindings, @ty.t expected,\n+    fn unify_step(&@fn_ctxt fcx, &hashmap[int,@ty.t] bindings, @ty.t expected,\n                   @ty.t actual) -> unify_result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n@@ -877,7 +877,7 @@ fn unify(&fn_ctxt fcx, @ty.t expected, @ty.t actual) -> unify_result {\n \n // Requires that the two types unify, and prints an error message if they\n // don't. Returns the unified type.\n-fn demand(&fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual) -> @ty.t {\n+fn demand(&@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual) -> @ty.t {\n     alt (unify(fcx, expected, actual)) {\n         case (ures_ok(?ty)) {\n             ret ty;\n@@ -897,7 +897,7 @@ fn demand(&fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual) -> @ty.t {\n }\n \n // Returns true if the two types unify and false if they don't.\n-fn are_compatible(&fn_ctxt fcx, @ty.t expected, @ty.t actual) -> bool {\n+fn are_compatible(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> bool {\n     alt (unify(fcx, expected, actual)) {\n         case (ures_ok(_))        { ret true;  }\n         case (ures_err(_, _, _)) { ret false; }\n@@ -909,7 +909,7 @@ fn are_compatible(&fn_ctxt fcx, @ty.t expected, @ty.t actual) -> bool {\n //\n // TODO: enforce this via a predicate.\n \n-fn demand_pat(&fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n+fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n     auto p_1 = ast.pat_wild(ast.ann_none);  // FIXME: typestate botch\n \n     alt (pat.node) {\n@@ -970,7 +970,7 @@ fn demand_pat(&fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n // TODO: propagate the types downward. This makes the typechecker quadratic,\n //       but we can mitigate that if expected == actual == unified.\n \n-fn demand_expr(&fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n+fn demand_expr(&@fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n     // FIXME: botch to work around typestate bug in rustboot\n     let vec[@ast.expr] v = vec();\n     auto e_1 = ast.expr_vec(v, ast.ann_none);\n@@ -1112,7 +1112,7 @@ fn demand_expr(&fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n }\n \n // Type unification over typed blocks.\n-fn demand_block(&fn_ctxt fcx, @ty.t expected, &ast.block bloc) -> ast.block {\n+fn demand_block(&@fn_ctxt fcx, @ty.t expected, &ast.block bloc) -> ast.block {\n     alt (bloc.node.expr) {\n         case (some[@ast.expr](?e_0)) {\n             auto e_1 = demand_expr(fcx, expected, e_0);\n@@ -1130,7 +1130,7 @@ fn demand_block(&fn_ctxt fcx, @ty.t expected, &ast.block bloc) -> ast.block {\n \n // Writeback: the phase that writes inferred types back into the AST.\n \n-fn writeback_local(&fn_ctxt fcx, &span sp, @ast.local local)\n+fn writeback_local(&@fn_ctxt fcx, &span sp, @ast.local local)\n         -> @ast.decl {\n     if (!fcx.locals.contains_key(local.id)) {\n         fcx.ccx.sess.span_err(sp, \"unable to determine type of local: \"\n@@ -1141,11 +1141,11 @@ fn writeback_local(&fn_ctxt fcx, &span sp, @ast.local local)\n     ret @fold.respan[ast.decl_](sp, ast.decl_local(local_wb));\n }\n \n-fn writeback(&fn_ctxt fcx, &ast.block block) -> ast.block {\n-    auto fld = fold.new_identity_fold[fn_ctxt]();\n+fn writeback(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n+    auto fld = fold.new_identity_fold[@fn_ctxt]();\n     auto f = writeback_local;\n     fld = @rec(fold_decl_local = f with *fld);\n-    ret fold.fold_block[fn_ctxt](fcx, fld, block);\n+    ret fold.fold_block[@fn_ctxt](fcx, fld, block);\n }\n \n // AST fragment checking\n@@ -1165,7 +1165,7 @@ fn check_lit(@ast.lit lit) -> @ty.t {\n     ret plain_ty(sty);\n }\n \n-fn check_pat(&fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n+fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n     auto new_pat;\n     alt (pat.node) {\n         case (ast.pat_wild(_)) {\n@@ -1227,7 +1227,7 @@ fn check_pat(&fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n     ret @fold.respan[ast.pat_](pat.span, new_pat);\n }\n \n-fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n+fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     alt (expr.node) {\n         case (ast.expr_lit(?lit, _)) {\n             auto ty = check_lit(lit);\n@@ -1711,8 +1711,7 @@ fn next_ty_var(@crate_ctxt ccx) -> @ty.t {\n     ret t;\n }\n \n-fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n-        -> @ast.stmt {\n+fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n     alt (stmt.node) {\n         case (ast.stmt_decl(?decl)) {\n             alt (decl.node) {\n@@ -1800,7 +1799,7 @@ fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n     fail;\n }\n \n-fn check_block(&fn_ctxt fcx, &ast.block block) -> ast.block {\n+fn check_block(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n     let vec[@ast.stmt] stmts = vec();\n     for (@ast.stmt s in block.node.stmts) {\n         append[@ast.stmt](stmts, check_stmt(fcx, s));\n@@ -1824,9 +1823,9 @@ fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n     // FIXME: this is kinda a kludge; we manufacture a fake \"function context\"\n     // for checking the initializer expression.\n     auto rty = ann_to_type(ann);\n-    let fn_ctxt fcx = rec(ret_ty = rty,\n-                          locals = @common.new_def_hash[@ty.t](),\n-                          ccx = ccx);\n+    let @fn_ctxt fcx = @rec(ret_ty = rty,\n+                            locals = @common.new_def_hash[@ty.t](),\n+                            ccx = ccx);\n     auto e_ = check_expr(fcx, e);\n     // FIXME: necessary? Correct sequence?\n     demand_expr(fcx, rty, e_);\n@@ -1848,9 +1847,9 @@ fn check_fn(&@crate_ctxt ccx, ast.effect effect,\n         auto input_ty = ast_ty_to_ty_crate(ccx, arg.ty);\n         local_ty_table.insert(arg.id, input_ty);\n     }\n-    let fn_ctxt fcx = rec(ret_ty = ast_ty_to_ty_crate(ccx, output),\n-                          locals = local_ty_table,\n-                          ccx = ccx);\n+    let @fn_ctxt fcx = @rec(ret_ty = ast_ty_to_ty_crate(ccx, output),\n+                            locals = local_ty_table,\n+                            ccx = ccx);\n \n     // TODO: Make sure the type of the block agrees with the function type.\n     auto block_t = check_block(fcx, body);"}]}