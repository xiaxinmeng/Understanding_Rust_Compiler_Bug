{"sha": "c29559d28acb34884769c884703c2c5de3397d2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyOTU1OWQyOGFjYjM0ODg0NzY5Yzg4NDcwM2MyYzVkZTMzOTdkMmI=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-04-01T20:45:00Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-04-05T16:52:58Z"}, "message": "Moved coretest::str tests into collectiontest::str", "tree": {"sha": "e731f359053d242acf0c6a689d6f16909325996c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e731f359053d242acf0c6a689d6f16909325996c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c29559d28acb34884769c884703c2c5de3397d2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c29559d28acb34884769c884703c2c5de3397d2b", "html_url": "https://github.com/rust-lang/rust/commit/c29559d28acb34884769c884703c2c5de3397d2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c29559d28acb34884769c884703c2c5de3397d2b/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c04f22a667123b39f16452af6fa65c82b2f8c0a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c04f22a667123b39f16452af6fa65c82b2f8c0a2", "html_url": "https://github.com/rust-lang/rust/commit/c04f22a667123b39f16452af6fa65c82b2f8c0a2"}], "stats": {"total": 752, "additions": 376, "deletions": 376}, "files": [{"sha": "0d5b4a14dbf7295eae285159c00279e5ed22d446", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 375, "deletions": 1, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/c29559d28acb34884769c884703c2c5de3397d2b/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c29559d28acb34884769c884703c2c5de3397d2b/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=c29559d28acb34884769c884703c2c5de3397d2b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -1506,6 +1506,278 @@ fn test_str_from_utf8() {\n     assert_eq!(from_utf8(xs), Err(Utf8Error::TooShort));\n }\n \n+#[test]\n+fn test_pattern_deref_forward() {\n+    let data = \"aabcdaa\";\n+    assert!(data.contains(\"bcd\"));\n+    assert!(data.contains(&\"bcd\"));\n+    assert!(data.contains(&\"bcd\".to_string()));\n+}\n+\n+#[test]\n+fn test_empty_match_indices() {\n+    let data = \"a\u00e4\u4e2d!\";\n+    let vec: Vec<_> = data.match_indices(\"\").collect();\n+    assert_eq!(vec, [(0, 0), (1, 1), (3, 3), (6, 6), (7, 7)]);\n+}\n+\n+#[test]\n+fn test_bool_from_str() {\n+    assert_eq!(\"true\".parse().ok(), Some(true));\n+    assert_eq!(\"false\".parse().ok(), Some(false));\n+    assert_eq!(\"not even a boolean\".parse::<bool>().ok(), None);\n+}\n+\n+fn check_contains_all_substrings(s: &str) {\n+    assert!(s.contains(\"\"));\n+    for i in 0..s.len() {\n+        for j in i+1..s.len() + 1 {\n+            assert!(s.contains(&s[i..j]));\n+        }\n+    }\n+}\n+\n+#[test]\n+fn strslice_issue_16589() {\n+    assert!(\"bananas\".contains(\"nana\"));\n+\n+    // prior to the fix for #16589, x.contains(\"abcdabcd\") returned false\n+    // test all substrings for good measure\n+    check_contains_all_substrings(\"012345678901234567890123456789bcdabcdabcd\");\n+}\n+\n+#[test]\n+fn strslice_issue_16878() {\n+    assert!(!\"1234567ah012345678901ah\".contains(\"hah\"));\n+    assert!(!\"00abc01234567890123456789abc\".contains(\"bcabc\"));\n+}\n+\n+\n+#[test]\n+fn test_strslice_contains() {\n+    let x = \"There are moments, Jeeves, when one asks oneself, 'Do trousers matter?'\";\n+    check_contains_all_substrings(x);\n+}\n+\n+#[test]\n+fn test_rsplitn_char_iterator() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let mut split: Vec<&str> = data.rsplitn(4, ' ').collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == ' ').collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    // Unicode\n+    let mut split: Vec<&str> = data.rsplitn(4, '\u00e4').collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == '\u00e4').collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+}\n+\n+#[test]\n+fn test_split_char_iterator() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.split(' ').collect();\n+    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n+    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    // Unicode\n+    let split: Vec<&str> = data.split('\u00e4').collect();\n+    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n+    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+}\n+\n+#[test]\n+fn test_rev_split_char_iterator_no_trailing() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let mut split: Vec<&str> = data.split('\\n').rev().collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+\n+    let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+}\n+\n+#[test]\n+fn test_utf16_code_units() {\n+    use unicode::str::Utf16Encoder;\n+    assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\u{1F4A9}'].into_iter()).collect::<Vec<u16>>(),\n+               [0xE9, 0xD83D, 0xDCA9])\n+}\n+\n+#[test]\n+fn starts_with_in_unicode() {\n+    assert!(!\"\u251c\u2500\u2500 Cargo.toml\".starts_with(\"# \"));\n+}\n+\n+#[test]\n+fn starts_short_long() {\n+    assert!(!\"\".starts_with(\"##\"));\n+    assert!(!\"##\".starts_with(\"####\"));\n+    assert!(\"####\".starts_with(\"##\"));\n+    assert!(!\"##\u00e4\".starts_with(\"####\"));\n+    assert!(\"####\u00e4\".starts_with(\"##\"));\n+    assert!(!\"##\".starts_with(\"####\u00e4\"));\n+    assert!(\"##\u00e4##\".starts_with(\"##\u00e4\"));\n+\n+    assert!(\"\".starts_with(\"\"));\n+    assert!(\"\u00e4\".starts_with(\"\"));\n+    assert!(\"#\u00e4\".starts_with(\"\"));\n+    assert!(\"##\u00e4\".starts_with(\"\"));\n+    assert!(\"\u00e4###\".starts_with(\"\"));\n+    assert!(\"#\u00e4##\".starts_with(\"\"));\n+    assert!(\"##\u00e4#\".starts_with(\"\"));\n+}\n+\n+#[test]\n+fn contains_weird_cases() {\n+    assert!(\"* \\t\".contains(' '));\n+    assert!(!\"* \\t\".contains('?'));\n+    assert!(!\"* \\t\".contains('\\u{1F4A9}'));\n+}\n+\n+#[test]\n+fn trim_ws() {\n+    assert_eq!(\" \\t  a \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n+                    \"a \\t  \");\n+    assert_eq!(\" \\t  a \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n+               \" \\t  a\");\n+    assert_eq!(\" \\t  a \\t  \".trim_matches(|c: char| c.is_whitespace()),\n+                    \"a\");\n+    assert_eq!(\" \\t   \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n+                         \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n+               \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_matches(|c: char| c.is_whitespace()),\n+               \"\");\n+}\n+\n+mod pattern {\n+    use std::str::pattern::Pattern;\n+    use std::str::pattern::{Searcher, ReverseSearcher};\n+    use std::str::pattern::SearchStep::{self, Match, Reject, Done};\n+\n+    macro_rules! make_test {\n+        ($name:ident, $p:expr, $h:expr, [$($e:expr,)*]) => {\n+            mod $name {\n+                use std::str::pattern::SearchStep::{Match, Reject};\n+                use super::{cmp_search_to_vec};\n+                #[test]\n+                fn fwd() {\n+                    cmp_search_to_vec(false, $p, $h, vec![$($e),*]);\n+                }\n+                #[test]\n+                fn bwd() {\n+                    cmp_search_to_vec(true, $p, $h, vec![$($e),*]);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn cmp_search_to_vec<'a, P: Pattern<'a>>(rev: bool, pat: P, haystack: &'a str,\n+                                             right: Vec<SearchStep>)\n+    where P::Searcher: ReverseSearcher<'a>\n+    {\n+        let mut searcher = pat.into_searcher(haystack);\n+        let mut v = vec![];\n+        loop {\n+            match if !rev {searcher.next()} else {searcher.next_back()} {\n+                Match(a, b) => v.push(Match(a, b)),\n+                Reject(a, b) => v.push(Reject(a, b)),\n+                Done => break,\n+            }\n+        }\n+        if rev {\n+            v.reverse();\n+        }\n+        assert_eq!(v, right);\n+    }\n+\n+    make_test!(str_searcher_ascii_haystack, \"bb\", \"abbcbbd\", [\n+        Reject(0, 1),\n+        Match (1, 3),\n+        Reject(3, 4),\n+        Match (4, 6),\n+        Reject(6, 7),\n+    ]);\n+    make_test!(str_searcher_empty_needle_ascii_haystack, \"\", \"abbcbbd\", [\n+        Match(0, 0),\n+        Match(1, 1),\n+        Match(2, 2),\n+        Match(3, 3),\n+        Match(4, 4),\n+        Match(5, 5),\n+        Match(6, 6),\n+        Match(7, 7),\n+    ]);\n+    make_test!(str_searcher_mulibyte_haystack, \" \", \"\u251c\u2500\u2500\", [\n+        Reject(0, 3),\n+        Reject(3, 6),\n+        Reject(6, 9),\n+    ]);\n+    make_test!(str_searcher_empty_needle_mulibyte_haystack, \"\", \"\u251c\u2500\u2500\", [\n+        Match(0, 0),\n+        Match(3, 3),\n+        Match(6, 6),\n+        Match(9, 9),\n+    ]);\n+    make_test!(str_searcher_empty_needle_empty_haystack, \"\", \"\", [\n+        Match(0, 0),\n+    ]);\n+    make_test!(str_searcher_nonempty_needle_empty_haystack, \"\u251c\", \"\", [\n+    ]);\n+    make_test!(char_searcher_ascii_haystack, 'b', \"abbcbbd\", [\n+        Reject(0, 1),\n+        Match (1, 2),\n+        Match (2, 3),\n+        Reject(3, 4),\n+        Match (4, 5),\n+        Match (5, 6),\n+        Reject(6, 7),\n+    ]);\n+    make_test!(char_searcher_mulibyte_haystack, ' ', \"\u251c\u2500\u2500\", [\n+        Reject(0, 3),\n+        Reject(3, 6),\n+        Reject(6, 9),\n+    ]);\n+    make_test!(char_searcher_short_haystack, '\\u{1F4A9}', \"* \\t\", [\n+        Reject(0, 1),\n+        Reject(1, 2),\n+        Reject(2, 3),\n+    ]);\n+\n+}\n+\n mod bench {\n     use test::{Bencher, black_box};\n \n@@ -1693,4 +1965,106 @@ malesuada sollicitudin quam eu fermentum.\";\n             assert!(haystack.contains(needle));\n         })\n     }\n+\n+    macro_rules! make_test_inner {\n+        ($s:ident, $code:expr, $name:ident, $str:expr) => {\n+            #[bench]\n+            fn $name(bencher: &mut Bencher) {\n+                let mut $s = $str;\n+                black_box(&mut $s);\n+                bencher.iter(|| $code);\n+            }\n+        }\n+    }\n+\n+    macro_rules! make_test {\n+        ($name:ident, $s:ident, $code:expr) => {\n+            mod $name {\n+                use test::Bencher;\n+                use test::black_box;\n+\n+                // Short strings: 65 bytes each\n+                make_test_inner!($s, $code, short_ascii,\n+                    \"Mary had a little lamb, Little lamb Mary had a littl lamb, lamb!\");\n+                make_test_inner!($s, $code, short_mixed,\n+                    \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lam!\");\n+                make_test_inner!($s, $code, short_pile_of_poo,\n+                    \"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9!\");\n+                make_test_inner!($s, $code, long_lorem_ipsum,\"\\\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n+ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n+eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n+sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n+tempus vel, gravida nec quam.\n+\n+In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n+sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n+diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n+lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n+eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n+interdum. Curabitur ut nisi justo.\n+\n+Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n+mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n+lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n+est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n+felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n+ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n+feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n+Aliquam sit amet placerat lorem.\n+\n+Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n+mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n+Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n+lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n+suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n+cursus accumsan.\n+\n+Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n+feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n+vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n+leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n+malesuada sollicitudin quam eu fermentum!\");\n+            }\n+        }\n+    }\n+\n+    make_test!(chars_count, s, s.chars().count());\n+\n+    make_test!(contains_bang_str, s, s.contains(\"!\"));\n+    make_test!(contains_bang_char, s, s.contains('!'));\n+\n+    make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n+\n+    make_test!(split_a_str, s, s.split(\"a\").count());\n+\n+    make_test!(trim_ascii_char, s, {\n+        use std::ascii::AsciiExt;\n+        s.trim_matches(|c: char| c.is_ascii())\n+    });\n+    make_test!(trim_left_ascii_char, s, {\n+        use std::ascii::AsciiExt;\n+        s.trim_left_matches(|c: char| c.is_ascii())\n+    });\n+    make_test!(trim_right_ascii_char, s, {\n+        use std::ascii::AsciiExt;\n+        s.trim_right_matches(|c: char| c.is_ascii())\n+    });\n+\n+    make_test!(find_underscore_char, s, s.find('_'));\n+    make_test!(rfind_underscore_char, s, s.rfind('_'));\n+    make_test!(find_underscore_str, s, s.find(\"_\"));\n+\n+    make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n+    make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n+    make_test!(find_zzz_str, s, s.find(\"\\u{1F4A4}\"));\n+\n+    make_test!(split_space_char, s, s.split(' ').count());\n+    make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n+\n+    make_test!(splitn_space_char, s, s.splitn(10, ' ').count());\n+    make_test!(rsplitn_space_char, s, s.rsplitn(10, ' ').count());\n+\n+    make_test!(split_space_str, s, s.split(\" \").count());\n+    make_test!(split_ad_str, s, s.split(\"ad\").count());\n }"}, {"sha": "b7d9ba4463d98b0d9a4e2db1fee7398cfa2b99ef", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 1, "deletions": 375, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/c29559d28acb34884769c884703c2c5de3397d2b/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c29559d28acb34884769c884703c2c5de3397d2b/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=c29559d28acb34884769c884703c2c5de3397d2b", "patch": "@@ -8,378 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[test]\n-fn test_pattern_deref_forward() {\n-    let data = \"aabcdaa\";\n-    assert!(data.contains(\"bcd\"));\n-    assert!(data.contains(&\"bcd\"));\n-    assert!(data.contains(&\"bcd\".to_string()));\n-}\n-\n-#[test]\n-fn test_empty_match_indices() {\n-    let data = \"a\u00e4\u4e2d!\";\n-    let vec: Vec<_> = data.match_indices(\"\").collect();\n-    assert_eq!(vec, [(0, 0), (1, 1), (3, 3), (6, 6), (7, 7)]);\n-}\n-\n-#[test]\n-fn test_bool_from_str() {\n-    assert_eq!(\"true\".parse().ok(), Some(true));\n-    assert_eq!(\"false\".parse().ok(), Some(false));\n-    assert_eq!(\"not even a boolean\".parse::<bool>().ok(), None);\n-}\n-\n-fn check_contains_all_substrings(s: &str) {\n-    assert!(s.contains(\"\"));\n-    for i in 0..s.len() {\n-        for j in i+1..s.len() + 1 {\n-            assert!(s.contains(&s[i..j]));\n-        }\n-    }\n-}\n-\n-#[test]\n-fn strslice_issue_16589() {\n-    assert!(\"bananas\".contains(\"nana\"));\n-\n-    // prior to the fix for #16589, x.contains(\"abcdabcd\") returned false\n-    // test all substrings for good measure\n-    check_contains_all_substrings(\"012345678901234567890123456789bcdabcdabcd\");\n-}\n-\n-#[test]\n-fn strslice_issue_16878() {\n-    assert!(!\"1234567ah012345678901ah\".contains(\"hah\"));\n-    assert!(!\"00abc01234567890123456789abc\".contains(\"bcabc\"));\n-}\n-\n-\n-#[test]\n-fn test_strslice_contains() {\n-    let x = \"There are moments, Jeeves, when one asks oneself, 'Do trousers matter?'\";\n-    check_contains_all_substrings(x);\n-}\n-\n-#[test]\n-fn test_rsplitn_char_iterator() {\n-    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-    let mut split: Vec<&str> = data.rsplitn(4, ' ').collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == ' ').collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    // Unicode\n-    let mut split: Vec<&str> = data.rsplitn(4, '\u00e4').collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == '\u00e4').collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-}\n-\n-#[test]\n-fn test_split_char_iterator() {\n-    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-    let split: Vec<&str> = data.split(' ').collect();\n-    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n-    rsplit.reverse();\n-    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n-    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n-    rsplit.reverse();\n-    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    // Unicode\n-    let split: Vec<&str> = data.split('\u00e4').collect();\n-    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-    let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n-    rsplit.reverse();\n-    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-    let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n-    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-    let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n-    rsplit.reverse();\n-    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-}\n-\n-#[test]\n-fn test_rev_split_char_iterator_no_trailing() {\n-    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-    let mut split: Vec<&str> = data.split('\\n').rev().collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n-\n-    let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n-}\n-\n-#[test]\n-fn test_utf16_code_units() {\n-    use unicode::str::Utf16Encoder;\n-    assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\u{1F4A9}'].into_iter()).collect::<Vec<u16>>(),\n-               [0xE9, 0xD83D, 0xDCA9])\n-}\n-\n-#[test]\n-fn starts_with_in_unicode() {\n-    assert!(!\"\u251c\u2500\u2500 Cargo.toml\".starts_with(\"# \"));\n-}\n-\n-#[test]\n-fn starts_short_long() {\n-    assert!(!\"\".starts_with(\"##\"));\n-    assert!(!\"##\".starts_with(\"####\"));\n-    assert!(\"####\".starts_with(\"##\"));\n-    assert!(!\"##\u00e4\".starts_with(\"####\"));\n-    assert!(\"####\u00e4\".starts_with(\"##\"));\n-    assert!(!\"##\".starts_with(\"####\u00e4\"));\n-    assert!(\"##\u00e4##\".starts_with(\"##\u00e4\"));\n-\n-    assert!(\"\".starts_with(\"\"));\n-    assert!(\"\u00e4\".starts_with(\"\"));\n-    assert!(\"#\u00e4\".starts_with(\"\"));\n-    assert!(\"##\u00e4\".starts_with(\"\"));\n-    assert!(\"\u00e4###\".starts_with(\"\"));\n-    assert!(\"#\u00e4##\".starts_with(\"\"));\n-    assert!(\"##\u00e4#\".starts_with(\"\"));\n-}\n-\n-#[test]\n-fn contains_weird_cases() {\n-    assert!(\"* \\t\".contains(' '));\n-    assert!(!\"* \\t\".contains('?'));\n-    assert!(!\"* \\t\".contains('\\u{1F4A9}'));\n-}\n-\n-#[test]\n-fn trim_ws() {\n-    assert_eq!(\" \\t  a \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n-                    \"a \\t  \");\n-    assert_eq!(\" \\t  a \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n-               \" \\t  a\");\n-    assert_eq!(\" \\t  a \\t  \".trim_matches(|c: char| c.is_whitespace()),\n-                    \"a\");\n-    assert_eq!(\" \\t   \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n-                         \"\");\n-    assert_eq!(\" \\t   \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n-               \"\");\n-    assert_eq!(\" \\t   \\t  \".trim_matches(|c: char| c.is_whitespace()),\n-               \"\");\n-}\n-\n-mod pattern {\n-    use std::str::pattern::Pattern;\n-    use std::str::pattern::{Searcher, ReverseSearcher};\n-    use std::str::pattern::SearchStep::{self, Match, Reject, Done};\n-\n-    macro_rules! make_test {\n-        ($name:ident, $p:expr, $h:expr, [$($e:expr,)*]) => {\n-            mod $name {\n-                use std::str::pattern::SearchStep::{Match, Reject};\n-                use super::{cmp_search_to_vec};\n-                #[test]\n-                fn fwd() {\n-                    cmp_search_to_vec(false, $p, $h, vec![$($e),*]);\n-                }\n-                #[test]\n-                fn bwd() {\n-                    cmp_search_to_vec(true, $p, $h, vec![$($e),*]);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn cmp_search_to_vec<'a, P: Pattern<'a>>(rev: bool, pat: P, haystack: &'a str,\n-                                             right: Vec<SearchStep>)\n-    where P::Searcher: ReverseSearcher<'a>\n-    {\n-        let mut searcher = pat.into_searcher(haystack);\n-        let mut v = vec![];\n-        loop {\n-            match if !rev {searcher.next()} else {searcher.next_back()} {\n-                Match(a, b) => v.push(Match(a, b)),\n-                Reject(a, b) => v.push(Reject(a, b)),\n-                Done => break,\n-            }\n-        }\n-        if rev {\n-            v.reverse();\n-        }\n-        assert_eq!(v, right);\n-    }\n-\n-    make_test!(str_searcher_ascii_haystack, \"bb\", \"abbcbbd\", [\n-        Reject(0, 1),\n-        Match (1, 3),\n-        Reject(3, 4),\n-        Match (4, 6),\n-        Reject(6, 7),\n-    ]);\n-    make_test!(str_searcher_empty_needle_ascii_haystack, \"\", \"abbcbbd\", [\n-        Match(0, 0),\n-        Match(1, 1),\n-        Match(2, 2),\n-        Match(3, 3),\n-        Match(4, 4),\n-        Match(5, 5),\n-        Match(6, 6),\n-        Match(7, 7),\n-    ]);\n-    make_test!(str_searcher_mulibyte_haystack, \" \", \"\u251c\u2500\u2500\", [\n-        Reject(0, 3),\n-        Reject(3, 6),\n-        Reject(6, 9),\n-    ]);\n-    make_test!(str_searcher_empty_needle_mulibyte_haystack, \"\", \"\u251c\u2500\u2500\", [\n-        Match(0, 0),\n-        Match(3, 3),\n-        Match(6, 6),\n-        Match(9, 9),\n-    ]);\n-    make_test!(str_searcher_empty_needle_empty_haystack, \"\", \"\", [\n-        Match(0, 0),\n-    ]);\n-    make_test!(str_searcher_nonempty_needle_empty_haystack, \"\u251c\", \"\", [\n-    ]);\n-    make_test!(char_searcher_ascii_haystack, 'b', \"abbcbbd\", [\n-        Reject(0, 1),\n-        Match (1, 2),\n-        Match (2, 3),\n-        Reject(3, 4),\n-        Match (4, 5),\n-        Match (5, 6),\n-        Reject(6, 7),\n-    ]);\n-    make_test!(char_searcher_mulibyte_haystack, ' ', \"\u251c\u2500\u2500\", [\n-        Reject(0, 3),\n-        Reject(3, 6),\n-        Reject(6, 9),\n-    ]);\n-    make_test!(char_searcher_short_haystack, '\\u{1F4A9}', \"* \\t\", [\n-        Reject(0, 1),\n-        Reject(1, 2),\n-        Reject(2, 3),\n-    ]);\n-\n-}\n-\n-mod bench {\n-    macro_rules! make_test_inner {\n-        ($s:ident, $code:expr, $name:ident, $str:expr) => {\n-            #[bench]\n-            fn $name(bencher: &mut Bencher) {\n-                let mut $s = $str;\n-                black_box(&mut $s);\n-                bencher.iter(|| $code);\n-            }\n-        }\n-    }\n-\n-    macro_rules! make_test {\n-        ($name:ident, $s:ident, $code:expr) => {\n-            mod $name {\n-                use test::Bencher;\n-                use test::black_box;\n-\n-                // Short strings: 65 bytes each\n-                make_test_inner!($s, $code, short_ascii,\n-                    \"Mary had a little lamb, Little lamb Mary had a littl lamb, lamb!\");\n-                make_test_inner!($s, $code, short_mixed,\n-                    \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lam!\");\n-                make_test_inner!($s, $code, short_pile_of_poo,\n-                    \"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9!\");\n-                make_test_inner!($s, $code, long_lorem_ipsum,\"\\\n-Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n-ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n-eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n-sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n-tempus vel, gravida nec quam.\n-\n-In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n-sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n-diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n-lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n-eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n-interdum. Curabitur ut nisi justo.\n-\n-Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n-mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n-lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n-est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n-felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n-ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n-feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n-Aliquam sit amet placerat lorem.\n-\n-Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n-mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n-Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n-lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n-suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n-cursus accumsan.\n-\n-Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n-feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n-vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n-leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n-malesuada sollicitudin quam eu fermentum!\");\n-            }\n-        }\n-    }\n-\n-    make_test!(chars_count, s, s.chars().count());\n-\n-    make_test!(contains_bang_str, s, s.contains(\"!\"));\n-    make_test!(contains_bang_char, s, s.contains('!'));\n-\n-    make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n-\n-    make_test!(split_a_str, s, s.split(\"a\").count());\n-\n-    make_test!(trim_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_matches(|c: char| c.is_ascii())\n-    });\n-    make_test!(trim_left_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_left_matches(|c: char| c.is_ascii())\n-    });\n-    make_test!(trim_right_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_right_matches(|c: char| c.is_ascii())\n-    });\n-\n-    make_test!(find_underscore_char, s, s.find('_'));\n-    make_test!(rfind_underscore_char, s, s.rfind('_'));\n-    make_test!(find_underscore_str, s, s.find(\"_\"));\n-\n-    make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n-    make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n-    make_test!(find_zzz_str, s, s.find(\"\\u{1F4A4}\"));\n-\n-    make_test!(split_space_char, s, s.split(' ').count());\n-    make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n-\n-    make_test!(splitn_space_char, s, s.splitn(10, ' ').count());\n-    make_test!(rsplitn_space_char, s, s.rsplitn(10, ' ').count());\n-\n-    make_test!(split_space_str, s, s.split(\" \").count());\n-    make_test!(split_ad_str, s, s.split(\"ad\").count());\n-}\n+// All `str` tests live in libcollectiontest::str"}]}