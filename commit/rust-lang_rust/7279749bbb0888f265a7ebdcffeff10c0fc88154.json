{"sha": "7279749bbb0888f265a7ebdcffeff10c0fc88154", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNzk3NDliYmIwODg4ZjI2NWE3ZWJkY2ZmZWZmMTBjMGZjODgxNTQ=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-03-14T03:52:58Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-03-14T03:54:19Z"}, "message": "Simpify mbe bindings builder", "tree": {"sha": "33d104885858015505256bdb6ce65e26ba010778", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33d104885858015505256bdb6ce65e26ba010778"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7279749bbb0888f265a7ebdcffeff10c0fc88154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7279749bbb0888f265a7ebdcffeff10c0fc88154", "html_url": "https://github.com/rust-lang/rust/commit/7279749bbb0888f265a7ebdcffeff10c0fc88154", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7279749bbb0888f265a7ebdcffeff10c0fc88154/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7808982952999ed8499b70c77ceaec265e0c1807", "url": "https://api.github.com/repos/rust-lang/rust/commits/7808982952999ed8499b70c77ceaec265e0c1807", "html_url": "https://github.com/rust-lang/rust/commit/7808982952999ed8499b70c77ceaec265e0c1807"}], "stats": {"total": 120, "additions": 57, "deletions": 63}, "files": [{"sha": "2c69e896850dc70743990e3f636e9574ca96c7dd", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 57, "deletions": 63, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/7279749bbb0888f265a7ebdcffeff10c0fc88154/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7279749bbb0888f265a7ebdcffeff10c0fc88154/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=7279749bbb0888f265a7ebdcffeff10c0fc88154", "patch": "@@ -162,9 +162,9 @@ struct BindingsBuilder {\n impl BindingsBuilder {\n     fn alloc(&mut self) -> BindingsIdx {\n         let idx = self.nodes.len();\n-        self.nodes.push(Vec::with_capacity(8));\n+        self.nodes.push(Vec::new());\n         let nidx = self.nested.len();\n-        self.nested.push(Vec::with_capacity(8));\n+        self.nested.push(Vec::new());\n         BindingsIdx(idx, nidx)\n     }\n \n@@ -182,11 +182,8 @@ impl BindingsBuilder {\n             if len < 4 {\n                 target.push(target[idx].clone())\n             } else {\n-                let mut item = Vec::with_capacity(8);\n-                item.push(LinkNode::Parent { idx, len });\n-                target.push(item);\n+                target.push(vec![LinkNode::Parent { idx, len }]);\n             }\n-\n             new_idx\n         }\n     }\n@@ -212,19 +209,22 @@ impl BindingsBuilder {\n     fn push_default(&mut self, idx: &mut BindingsIdx) {\n         self.nested[idx.1].push(LinkNode::Node(idx.0));\n         let new_idx = self.nodes.len();\n-        self.nodes.push(Vec::with_capacity(8));\n+        self.nodes.push(Vec::new());\n         idx.0 = new_idx;\n     }\n \n     fn build(self, idx: &BindingsIdx) -> Bindings {\n         let mut bindings = Bindings::default();\n-        self.build_recur(&mut bindings, self.nodes[idx.0].clone());\n+        self.build_inner(&mut bindings, &self.nodes[idx.0]);\n         bindings\n     }\n \n-    fn build_recur(&self, bindings: &mut Bindings, nodes: Vec<LinkNode<Rc<BindingKind>>>) {\n-        for cmd in self.flatten_nodes(nodes) {\n-            match &*cmd {\n+    fn build_inner(&self, bindings: &mut Bindings, link_nodes: &Vec<LinkNode<Rc<BindingKind>>>) {\n+        let mut nodes = Vec::new();\n+        self.collect_nodes(&link_nodes, &mut nodes);\n+\n+        for cmd in nodes {\n+            match &**cmd {\n                 BindingKind::Empty(name) => {\n                     bindings.push_empty(name);\n                 }\n@@ -234,10 +234,11 @@ impl BindingsBuilder {\n                 BindingKind::Fragment(name, fragment) => {\n                     bindings.inner.insert(name.clone(), Binding::Fragment(fragment.clone()));\n                 }\n-                BindingKind::Nested(idx, list) => {\n-                    let list = self.flatten_nested(*idx, *list);\n+                BindingKind::Nested(idx, nested_idx) => {\n+                    let mut nested_nodes = Vec::new();\n+                    self.collect_nested(*idx, *nested_idx, &mut nested_nodes);\n \n-                    for (idx, iter) in list.enumerate() {\n+                    for (idx, iter) in nested_nodes.into_iter().enumerate() {\n                         for (key, value) in &iter.inner {\n                             let bindings = bindings\n                                 .inner\n@@ -258,62 +259,55 @@ impl BindingsBuilder {\n         }\n     }\n \n-    fn flatten_nested_ref(&self, id: usize, len: usize) -> Vec<Vec<LinkNode<Rc<BindingKind>>>> {\n-        self.nested[id]\n-            .iter()\n-            .take(len)\n-            .map(|it| match it {\n-                LinkNode::Node(id) => vec![self.nodes[*id].clone()],\n-                LinkNode::Parent { idx, len } => self.flatten_nested_ref(*idx, *len),\n-            })\n-            .flatten()\n-            .collect()\n+    fn collect_nested_ref<'a>(\n+        &'a self,\n+        id: usize,\n+        len: usize,\n+        nested_refs: &mut Vec<&'a Vec<LinkNode<Rc<BindingKind>>>>,\n+    ) {\n+        self.nested[id].iter().take(len).for_each(|it| match it {\n+            LinkNode::Node(id) => nested_refs.push(&self.nodes[*id]),\n+            LinkNode::Parent { idx, len } => self.collect_nested_ref(*idx, *len, nested_refs),\n+        });\n     }\n \n-    fn flatten_nested<'a>(\n-        &'a self,\n-        idx: usize,\n-        list: usize,\n-    ) -> impl Iterator<Item = Bindings> + 'a {\n-        let last = self.nodes[idx].clone();\n-        self.nested[list]\n-            .iter()\n-            .map(move |it| match *it {\n-                LinkNode::Node(idx) => vec![self.nodes[idx].clone()],\n-                LinkNode::Parent { idx, len } => self.flatten_nested_ref(idx, len),\n-            })\n-            .flatten()\n-            .chain(std::iter::once(last))\n-            .map(move |iter| {\n-                let mut child_bindings = Bindings::default();\n-                self.build_recur(&mut child_bindings, iter);\n-                child_bindings\n-            })\n+    fn collect_nested(&self, idx: usize, nested_idx: usize, nested: &mut Vec<Bindings>) {\n+        let last = &self.nodes[idx];\n+        let mut nested_refs = Vec::new();\n+        self.nested[nested_idx].iter().for_each(|it| match *it {\n+            LinkNode::Node(idx) => nested_refs.push(&self.nodes[idx]),\n+            LinkNode::Parent { idx, len } => self.collect_nested_ref(idx, len, &mut nested_refs),\n+        });\n+        nested_refs.push(last);\n+\n+        nested_refs.into_iter().for_each(|iter| {\n+            let mut child_bindings = Bindings::default();\n+            self.build_inner(&mut child_bindings, &iter);\n+            nested.push(child_bindings)\n+        })\n     }\n \n-    fn flatten_nodes_ref(&self, id: usize, len: usize) -> Vec<Rc<BindingKind>> {\n-        self.nodes[id]\n-            .iter()\n-            .take(len)\n-            .map(|it| match it {\n-                LinkNode::Node(it) => vec![it.clone()],\n-                LinkNode::Parent { idx, len } => self.flatten_nodes_ref(*idx, *len),\n-            })\n-            .flatten()\n-            .collect()\n+    fn collect_nodes_ref<'a>(\n+        &'a self,\n+        id: usize,\n+        len: usize,\n+        nodes: &mut Vec<&'a Rc<BindingKind>>,\n+    ) {\n+        self.nodes[id].iter().take(len).for_each(|it| match it {\n+            LinkNode::Node(it) => nodes.push(it),\n+            LinkNode::Parent { idx, len } => self.collect_nodes_ref(*idx, *len, nodes),\n+        });\n     }\n \n-    fn flatten_nodes<'a>(\n+    fn collect_nodes<'a>(\n         &'a self,\n-        nodes: Vec<LinkNode<Rc<BindingKind>>>,\n-    ) -> impl Iterator<Item = Rc<BindingKind>> + 'a {\n-        nodes\n-            .into_iter()\n-            .map(move |it| match it {\n-                LinkNode::Node(it) => vec![it],\n-                LinkNode::Parent { idx, len } => self.flatten_nodes_ref(idx, len),\n-            })\n-            .flatten()\n+        link_nodes: &'a Vec<LinkNode<Rc<BindingKind>>>,\n+        nodes: &mut Vec<&'a Rc<BindingKind>>,\n+    ) {\n+        link_nodes.into_iter().for_each(|it| match it {\n+            LinkNode::Node(it) => nodes.push(it),\n+            LinkNode::Parent { idx, len } => self.collect_nodes_ref(*idx, *len, nodes),\n+        });\n     }\n }\n "}]}