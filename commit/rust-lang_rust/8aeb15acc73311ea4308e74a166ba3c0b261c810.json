{"sha": "8aeb15acc73311ea4308e74a166ba3c0b261c810", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZWIxNWFjYzczMzExZWE0MzA4ZTc0YTE2NmJhM2MwYjI2MWM4MTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-02T02:03:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-02T02:03:27Z"}, "message": "Auto merge of #35894 - jseyfried:new_import_semantics, r=nrc\n\nImplement RFC 1560 behind `#![feature(item_like_imports)]`\n\nThis implements https://github.com/rust-lang/rfcs/pull/1560 (cc #35120) behind the `item_like_imports` feature gate.\n\nThe [RFC text](https://github.com/rust-lang/rfcs/blob/master/text/1560-name-resolution.md#changes-to-name-resolution-rules) describes the changes to name resolution enabled by `#![feature(item_like_imports)` in detail. To summarize,\n - Items and named imports shadow glob imports.\n - Multiple globs can import the same name if the name is unused or the imports are shadowed.\n - Multiple globs can import the same name if the imports are of the same item (following re-exports).\n  - The visibility of such a name is the maximum visibility of the imports.\n  - Equivalently, adding a glob import will never reduce the visibility of a name, nor will removing one increase it.\n - Non-prelude private imports can be used wherever we currently allow private items to be used.\n  - Prelude-imported names are unaffected, i.e. they continue to be usable only in lexical scopes.\n - Globs import all visible names, not just public names.\n  - Equivalently, glob importing from an ancestor module imports all of the ancestor's names, and glob importing from other modules is unchanged.\n\nr? @nrc", "tree": {"sha": "2b1cc7b3cc199c1e94e13f2a3b1f9681f97b9d7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b1cc7b3cc199c1e94e13f2a3b1f9681f97b9d7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8aeb15acc73311ea4308e74a166ba3c0b261c810", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8aeb15acc73311ea4308e74a166ba3c0b261c810", "html_url": "https://github.com/rust-lang/rust/commit/8aeb15acc73311ea4308e74a166ba3c0b261c810", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8aeb15acc73311ea4308e74a166ba3c0b261c810/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "497d67d708e5e54344efc10f9c16ea83b215da9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/497d67d708e5e54344efc10f9c16ea83b215da9e", "html_url": "https://github.com/rust-lang/rust/commit/497d67d708e5e54344efc10f9c16ea83b215da9e"}, {"sha": "90ce504c1c3dc014ca8e0aa91e21c46569a9d4ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/90ce504c1c3dc014ca8e0aa91e21c46569a9d4ab", "html_url": "https://github.com/rust-lang/rust/commit/90ce504c1c3dc014ca8e0aa91e21c46569a9d4ab"}], "stats": {"total": 728, "additions": 508, "deletions": 220}, "files": [{"sha": "3e9b37f0a95a713dcbec1414b417ef8185a4463c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8aeb15acc73311ea4308e74a166ba3c0b261c810", "patch": "@@ -26,6 +26,8 @@ use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty::{self, VariantKind};\n \n+use std::cell::Cell;\n+\n use syntax::ast::Name;\n use syntax::attr;\n use syntax::parse::token;\n@@ -81,7 +83,6 @@ impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item) {\n         let parent = self.current_module;\n-        let parent_vis = self.current_vis;\n         let name = item.ident.name;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n@@ -177,7 +178,10 @@ impl<'b> Resolver<'b> {\n                         }\n                     }\n                     ViewPathGlob(_) => {\n-                        let subclass = GlobImport { is_prelude: is_prelude };\n+                        let subclass = GlobImport {\n+                            is_prelude: is_prelude,\n+                            max_vis: Cell::new(ty::Visibility::PrivateExternal),\n+                        };\n                         let span = view_path.span;\n                         self.add_import_directive(module_path, subclass, span, item.id, vis);\n                     }\n@@ -204,7 +208,7 @@ impl<'b> Resolver<'b> {\n             ItemKind::Mod(..) => {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), false);\n+                let module = self.new_module(parent_link, Some(def), Some(item.id));\n                 module.no_implicit_prelude.set({\n                     parent.no_implicit_prelude.get() ||\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n@@ -214,7 +218,6 @@ impl<'b> Resolver<'b> {\n \n                 // Descend into the module.\n                 self.current_module = module;\n-                self.current_vis = ty::Visibility::Restricted(item.id);\n             }\n \n             ItemKind::ForeignMod(..) => {}\n@@ -243,7 +246,7 @@ impl<'b> Resolver<'b> {\n             ItemKind::Enum(ref enum_definition, _) => {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), false);\n+                let module = self.new_module(parent_link, Some(def), parent.normal_ancestor_id);\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n \n                 for variant in &(*enum_definition).variants {\n@@ -285,7 +288,8 @@ impl<'b> Resolver<'b> {\n                 // Add all the items within to a new module.\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Trait(def_id);\n-                let module_parent = self.new_module(parent_link, Some(def), false);\n+                let module_parent =\n+                    self.new_module(parent_link, Some(def), parent.normal_ancestor_id);\n                 self.define(parent, name, TypeNS, (module_parent, sp, vis));\n \n                 // Add the names of all the items to the trait info.\n@@ -312,7 +316,6 @@ impl<'b> Resolver<'b> {\n \n         visit::walk_item(&mut BuildReducedGraphVisitor { resolver: self }, item);\n         self.current_module = parent;\n-        self.current_vis = parent_vis;\n     }\n \n     // Constructs the reduced graph for one variant. Variants exist in the\n@@ -363,7 +366,7 @@ impl<'b> Resolver<'b> {\n                    block_id);\n \n             let parent_link = BlockParentLink(parent, block_id);\n-            let new_module = self.new_module(parent_link, None, false);\n+            let new_module = self.new_module(parent_link, None, parent.normal_ancestor_id);\n             self.module_map.insert(block_id, new_module);\n             self.current_module = new_module; // Descend into the block.\n         }\n@@ -395,7 +398,7 @@ impl<'b> Resolver<'b> {\n                 debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n                        name, vis);\n                 let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), true);\n+                let module = self.new_module(parent_link, Some(def), None);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::Variant(_, variant_id) => {\n@@ -437,7 +440,7 @@ impl<'b> Resolver<'b> {\n                 }\n \n                 let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), true);\n+                let module = self.new_module(parent_link, Some(def), None);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {"}, {"sha": "1224c694a4e6e6e218083c67c031c996a8fccc99", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 163, "deletions": 145, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8aeb15acc73311ea4308e74a166ba3c0b261c810", "patch": "@@ -65,7 +65,7 @@ use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{PathSegment, PathParameters, QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n \n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n use errors::DiagnosticBuilder;\n \n use std::cell::{Cell, RefCell};\n@@ -459,7 +459,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err\n         }\n         ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, name, binding) => {\n-            let shadows_what = PathResolution::new(binding.def().unwrap()).kind_name();\n+            let shadows_what = PathResolution::new(binding.def()).kind_name();\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0530,\n@@ -739,7 +739,7 @@ impl<'a> LexicalScopeBinding<'a> {\n     fn local_def(self) -> LocalDef {\n         match self {\n             LexicalScopeBinding::LocalDef(local_def) => local_def,\n-            LexicalScopeBinding::Item(binding) => LocalDef::from_def(binding.def().unwrap()),\n+            LexicalScopeBinding::Item(binding) => LocalDef::from_def(binding.def()),\n         }\n     }\n \n@@ -749,10 +749,6 @@ impl<'a> LexicalScopeBinding<'a> {\n             _ => None,\n         }\n     }\n-\n-    fn module(self) -> Option<Module<'a>> {\n-        self.item().and_then(NameBinding::module)\n-    }\n }\n \n /// The link from a module up to its nearest parent node.\n@@ -768,6 +764,9 @@ pub struct ModuleS<'a> {\n     parent_link: ParentLink<'a>,\n     def: Option<Def>,\n \n+    // The node id of the closest normal module (`mod`) ancestor (including this module).\n+    normal_ancestor_id: Option<NodeId>,\n+\n     // If the module is an extern crate, `def` is root of the external crate and `extern_crate_id`\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n     extern_crate_id: Option<NodeId>,\n@@ -791,17 +790,19 @@ pub struct ModuleS<'a> {\n pub type Module<'a> = &'a ModuleS<'a>;\n \n impl<'a> ModuleS<'a> {\n-    fn new(parent_link: ParentLink<'a>, def: Option<Def>, external: bool) -> Self {\n+    fn new(parent_link: ParentLink<'a>, def: Option<Def>, normal_ancestor_id: Option<NodeId>)\n+           -> Self {\n         ModuleS {\n             parent_link: parent_link,\n             def: def,\n+            normal_ancestor_id: normal_ancestor_id,\n             extern_crate_id: None,\n             resolutions: RefCell::new(FnvHashMap()),\n             no_implicit_prelude: Cell::new(false),\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n-            populated: Cell::new(!external),\n+            populated: Cell::new(normal_ancestor_id.is_some()),\n         }\n     }\n \n@@ -829,6 +830,13 @@ impl<'a> ModuleS<'a> {\n             _ => false,\n         }\n     }\n+\n+    fn parent(&self) -> Option<&'a Self> {\n+        match self.parent_link {\n+            ModuleParentLink(parent, _) | BlockParentLink(parent, _) => Some(parent),\n+            NoParentLink => None,\n+        }\n+    }\n }\n \n impl<'a> fmt::Debug for ModuleS<'a> {\n@@ -863,32 +871,35 @@ enum NameBindingKind<'a> {\n         binding: &'a NameBinding<'a>,\n         directive: &'a ImportDirective<'a>,\n     },\n+    Ambiguity {\n+        b1: &'a NameBinding<'a>,\n+        b2: &'a NameBinding<'a>,\n+    }\n }\n \n #[derive(Clone, Debug)]\n struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n \n impl<'a> NameBinding<'a> {\n-    fn module(&self) -> Option<Module<'a>> {\n+    fn module(&self) -> Result<Module<'a>, bool /* true if an error has already been reported */> {\n         match self.kind {\n-            NameBindingKind::Module(module) => Some(module),\n-            NameBindingKind::Def(_) => None,\n+            NameBindingKind::Module(module) => Ok(module),\n             NameBindingKind::Import { binding, .. } => binding.module(),\n+            NameBindingKind::Def(Def::Err) => Err(true),\n+            NameBindingKind::Def(_) => Err(false),\n+            NameBindingKind::Ambiguity { ..  } => Err(false),\n         }\n     }\n \n-    fn def(&self) -> Option<Def> {\n+    fn def(&self) -> Def {\n         match self.kind {\n-            NameBindingKind::Def(def) => Some(def),\n-            NameBindingKind::Module(module) => module.def,\n+            NameBindingKind::Def(def) => def,\n+            NameBindingKind::Module(module) => module.def.unwrap(),\n             NameBindingKind::Import { binding, .. } => binding.def(),\n+            NameBindingKind::Ambiguity { .. } => Def::Err,\n         }\n     }\n \n-    fn is_pseudo_public(&self) -> bool {\n-        self.pseudo_vis() == ty::Visibility::Public\n-    }\n-\n     // We sometimes need to treat variants as `pub` for backwards compatibility\n     fn pseudo_vis(&self) -> ty::Visibility {\n         if self.is_variant() { ty::Visibility::Public } else { self.vis }\n@@ -902,7 +913,7 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_extern_crate(&self) -> bool {\n-        self.module().and_then(|module| module.extern_crate_id).is_some()\n+        self.module().ok().and_then(|module| module.extern_crate_id).is_some()\n     }\n \n     fn is_import(&self) -> bool {\n@@ -915,16 +926,25 @@ impl<'a> NameBinding<'a> {\n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { directive, .. } => directive.is_glob(),\n+            NameBindingKind::Ambiguity { .. } => true,\n             _ => false,\n         }\n     }\n \n     fn is_importable(&self) -> bool {\n-        match self.def().unwrap() {\n+        match self.def() {\n             Def::AssociatedConst(..) | Def::Method(..) | Def::AssociatedTy(..) => false,\n             _ => true,\n         }\n     }\n+\n+    fn ambiguity(&self) -> Option<(&'a NameBinding<'a>, &'a NameBinding<'a>)> {\n+        match self.kind {\n+            NameBindingKind::Ambiguity { b1, b2 } => Some((b1, b2)),\n+            NameBindingKind::Import { binding, .. } => binding.ambiguity(),\n+            _ => None,\n+        }\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -987,10 +1007,6 @@ pub struct Resolver<'a> {\n     // The module that represents the current item scope.\n     current_module: Module<'a>,\n \n-    // The visibility of `pub(self)` items in the current scope.\n-    // Equivalently, the visibility required for an item to be accessible from the current scope.\n-    current_vis: ty::Visibility,\n-\n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n     value_ribs: Vec<Rib<'a>>,\n@@ -1047,8 +1063,11 @@ pub struct Resolver<'a> {\n     pub maybe_unused_trait_imports: NodeSet,\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n+    ambiguity_errors: Vec<(Span, Name, &'a NameBinding<'a>)>,\n \n     arenas: &'a ResolverArenas<'a>,\n+    dummy_binding: &'a NameBinding<'a>,\n+    new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1083,15 +1102,12 @@ impl<'a> ResolverArenas<'a> {\n }\n \n impl<'a> ty::NodeIdTree for Resolver<'a> {\n-    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n-        let ancestor = self.definitions.local_def_id(ancestor);\n-        let mut module = *self.module_map.get(&node).unwrap();\n-        while module.def_id() != Some(ancestor) {\n-            let module_parent = match self.get_nearest_normal_module_parent(module) {\n-                Some(parent) => parent,\n+    fn is_descendant_of(&self, mut node: NodeId, ancestor: NodeId) -> bool {\n+        while node != ancestor {\n+            node = match self.module_map[&node].parent() {\n+                Some(parent) => parent.normal_ancestor_id.unwrap(),\n                 None => return false,\n-            };\n-            module = module_parent;\n+            }\n         }\n         true\n     }\n@@ -1101,7 +1117,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         match self.resolve_crate_relative_path(path.span, &path.segments, namespace) {\n-            Ok(binding) => binding.def().unwrap(),\n+            Ok(binding) => binding.def(),\n             Err(true) => Def::Err,\n             Err(false) => {\n                 let path_name = &format!(\"{}\", path);\n@@ -1154,7 +1170,7 @@ impl<'a> Resolver<'a> {\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n         let graph_root =\n-            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false);\n+            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), Some(CRATE_NODE_ID));\n         let graph_root = arenas.alloc_module(graph_root);\n         let mut module_map = NodeMap();\n         module_map.insert(CRATE_NODE_ID, graph_root);\n@@ -1177,7 +1193,6 @@ impl<'a> Resolver<'a> {\n             indeterminate_imports: Vec::new(),\n \n             current_module: graph_root,\n-            current_vis: ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n             value_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n             type_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n             label_ribs: Vec::new(),\n@@ -1203,8 +1218,15 @@ impl<'a> Resolver<'a> {\n             maybe_unused_trait_imports: NodeSet(),\n \n             privacy_errors: Vec::new(),\n+            ambiguity_errors: Vec::new(),\n \n             arenas: arenas,\n+            dummy_binding: arenas.alloc_name_binding(NameBinding {\n+                kind: NameBindingKind::Def(Def::Err),\n+                span: DUMMY_SP,\n+                vis: ty::Visibility::Public,\n+            }),\n+            new_import_semantics: session.features.borrow().item_like_imports,\n         }\n     }\n \n@@ -1221,21 +1243,23 @@ impl<'a> Resolver<'a> {\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         self.current_module = self.graph_root;\n-        self.current_vis = ty::Visibility::Restricted(ast::CRATE_NODE_ID);\n         visit::walk_crate(self, krate);\n \n         check_unused::check_crate(self, krate);\n-        self.report_privacy_errors();\n+        self.report_errors();\n     }\n \n-    fn new_module(&self, parent_link: ParentLink<'a>, def: Option<Def>, external: bool)\n+    fn new_module(&self,\n+                  parent_link: ParentLink<'a>,\n+                  def: Option<Def>,\n+                  normal_ancestor_id: Option<NodeId>)\n                   -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS::new(parent_link, def, external))\n+        self.arenas.alloc_module(ModuleS::new(parent_link, def, normal_ancestor_id))\n     }\n \n     fn new_extern_crate_module(&self, parent_link: ParentLink<'a>, def: Def, local_node_id: NodeId)\n                                -> Module<'a> {\n-        let mut module = ModuleS::new(parent_link, Some(def), false);\n+        let mut module = ModuleS::new(parent_link, Some(def), Some(local_node_id));\n         module.extern_crate_id = Some(local_node_id);\n         self.arenas.modules.alloc(module)\n     }\n@@ -1244,16 +1268,24 @@ impl<'a> Resolver<'a> {\n         match ns { ValueNS => &mut self.value_ribs, TypeNS => &mut self.type_ribs }\n     }\n \n-    fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n+    fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n+                  -> bool /* true if an error was reported */ {\n         // track extern crates for unused_extern_crate lint\n-        if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleS::def_id) {\n+        if let Some(DefId { krate, .. }) = binding.module().ok().and_then(ModuleS::def_id) {\n             self.used_crates.insert(krate);\n         }\n \n         if let NameBindingKind::Import { directive, .. } = binding.kind {\n             self.used_imports.insert((directive.id, ns));\n             self.add_to_glob_map(directive.id, name);\n         }\n+\n+        if binding.ambiguity().is_some() {\n+            self.ambiguity_errors.push((span, name, binding));\n+            return true;\n+        }\n+\n+        false\n     }\n \n     fn add_to_glob_map(&mut self, id: NodeId, name: Name) {\n@@ -1262,6 +1294,18 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn expect_module(&mut self, name: Name, binding: &'a NameBinding<'a>, span: Option<Span>)\n+                     -> ResolveResult<Module<'a>> {\n+        match binding.module() {\n+            Ok(module) => Success(module),\n+            Err(true) => Failed(None),\n+            Err(false) => {\n+                let msg = format!(\"Not a module `{}`\", name);\n+                Failed(span.map(|span| (span, msg)))\n+            }\n+        }\n+    }\n+\n     /// Resolves the given module path from the given root `search_module`.\n     fn resolve_module_path_from_root(&mut self,\n                                      mut search_module: Module<'a>,\n@@ -1291,7 +1335,7 @@ impl<'a> Resolver<'a> {\n         while index < module_path_len {\n             let name = module_path[index];\n             match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n-                Failed(None) => {\n+                Failed(_) => {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n                     let msg = if \"???\" == &module_name {\n@@ -1318,7 +1362,6 @@ impl<'a> Resolver<'a> {\n \n                     return Failed(span.map(|span| (span, msg)));\n                 }\n-                Failed(err) => return Failed(err),\n                 Indeterminate => {\n                     debug!(\"(resolving module path for import) module resolution is \\\n                             indeterminate: {}\",\n@@ -1328,11 +1371,9 @@ impl<'a> Resolver<'a> {\n                 Success(binding) => {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n-                    if let Some(module_def) = binding.module() {\n-                        search_module = module_def;\n-                    } else {\n-                        let msg = format!(\"Not a module `{}`\", name);\n-                        return Failed(span.map(|span| (span, msg)));\n+                    match self.expect_module(name, binding, span) {\n+                        Success(module) => search_module = module,\n+                        result @ _ => return result,\n                     }\n                 }\n             }\n@@ -1385,13 +1426,20 @@ impl<'a> Resolver<'a> {\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n                         let ident = ast::Ident::with_empty_ctxt(module_path[0]);\n-                        match self.resolve_ident_in_lexical_scope(ident, TypeNS, span)\n-                                  .and_then(LexicalScopeBinding::module) {\n-                            None => return Failed(None),\n-                            Some(containing_module) => {\n-                                search_module = containing_module;\n-                                start_index = 1;\n+                        let lexical_binding =\n+                            self.resolve_ident_in_lexical_scope(ident, TypeNS, span);\n+                        if let Some(binding) = lexical_binding.and_then(LexicalScopeBinding::item) {\n+                            match self.expect_module(ident.name, binding, span) {\n+                                Success(containing_module) => {\n+                                    search_module = containing_module;\n+                                    start_index = 1;\n+                                }\n+                                result @ _ => return result,\n                             }\n+                        } else {\n+                            let msg =\n+                                format!(\"Use of undeclared type or module `{}`\", ident.name);\n+                            return Failed(span.map(|span| (span, msg)));\n                         }\n                     }\n                 }\n@@ -1474,35 +1522,6 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    /// Returns the nearest normal module parent of the given module.\n-    fn get_nearest_normal_module_parent(&self, mut module: Module<'a>) -> Option<Module<'a>> {\n-        loop {\n-            match module.parent_link {\n-                NoParentLink => return None,\n-                ModuleParentLink(new_module, _) |\n-                BlockParentLink(new_module, _) => {\n-                    let new_module = new_module;\n-                    if new_module.is_normal() {\n-                        return Some(new_module);\n-                    }\n-                    module = new_module;\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Returns the nearest normal module parent of the given module, or the\n-    /// module itself if it is a normal module.\n-    fn get_nearest_normal_module_parent_or_self(&self, module: Module<'a>) -> Module<'a> {\n-        if module.is_normal() {\n-            return module;\n-        }\n-        match self.get_nearest_normal_module_parent(module) {\n-            None => module,\n-            Some(new_module) => new_module,\n-        }\n-    }\n-\n     /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n@@ -1515,22 +1534,20 @@ impl<'a> Resolver<'a> {\n             \"super\" => 0,\n             _ => return Success(NoPrefixFound),\n         };\n+\n         let mut containing_module =\n-            self.get_nearest_normal_module_parent_or_self(self.current_module);\n+            self.module_map[&self.current_module.normal_ancestor_id.unwrap()];\n \n         // Now loop through all the `super`s we find.\n         while i < module_path.len() && \"super\" == module_path[i].as_str() {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    module_to_string(&containing_module));\n-            match self.get_nearest_normal_module_parent(containing_module) {\n-                None => {\n-                    let msg = \"There are too many initial `super`s.\".into();\n-                    return Failed(span.map(|span| (span, msg)));\n-                }\n-                Some(new_module) => {\n-                    containing_module = new_module;\n-                    i += 1;\n-                }\n+            if let Some(parent) = containing_module.parent() {\n+                containing_module = self.module_map[&parent.normal_ancestor_id.unwrap()];\n+                i += 1;\n+            } else {\n+                let msg = \"There are too many initial `super`s.\".into();\n+                return Failed(span.map(|span| (span, msg)));\n             }\n         }\n \n@@ -1565,14 +1582,12 @@ impl<'a> Resolver<'a> {\n         if let Some(module) = module {\n             // Move down in the graph.\n             let orig_module = replace(&mut self.current_module, module);\n-            let orig_vis = replace(&mut self.current_vis, ty::Visibility::Restricted(id));\n             self.value_ribs.push(Rib::new(ModuleRibKind(module)));\n             self.type_ribs.push(Rib::new(ModuleRibKind(module)));\n \n             f(self);\n \n             self.current_module = orig_module;\n-            self.current_vis = orig_vis;\n             self.value_ribs.pop();\n             self.type_ribs.pop();\n         } else {\n@@ -1697,7 +1712,7 @@ impl<'a> Resolver<'a> {\n                                                                    &prefix.segments,\n                                                                    TypeNS) {\n                                 Ok(binding) => {\n-                                    let def = binding.def().unwrap();\n+                                    let def = binding.def();\n                                     self.record_def(item.id, PathResolution::new(def));\n                                 }\n                                 Err(true) => self.record_def(item.id, err_path_resolution()),\n@@ -2313,14 +2328,15 @@ impl<'a> Resolver<'a> {\n                     // entity, then fall back to a fresh binding.\n                     let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS, None)\n                                       .and_then(LexicalScopeBinding::item);\n-                    let resolution = binding.and_then(NameBinding::def).and_then(|def| {\n+                    let resolution = binding.map(NameBinding::def).and_then(|def| {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n                                              bmode != BindingMode::ByValue(Mutability::Immutable);\n                         match def {\n                             Def::Struct(..) | Def::Variant(..) |\n                             Def::Const(..) | Def::AssociatedConst(..) if !always_binding => {\n                                 // A constant, unit variant, etc pattern.\n-                                self.record_use(ident.node.name, ValueNS, binding.unwrap());\n+                                let name = ident.node.name;\n+                                self.record_use(name, ValueNS, binding.unwrap(), ident.span);\n                                 Some(PathResolution::new(def))\n                             }\n                             Def::Struct(..) | Def::Variant(..) |\n@@ -2447,7 +2463,7 @@ impl<'a> Resolver<'a> {\n \n         if path.global {\n             let binding = self.resolve_crate_relative_path(span, segments, namespace);\n-            return binding.map(|binding| mk_res(binding.def().unwrap()));\n+            return binding.map(|binding| mk_res(binding.def()));\n         }\n \n         // Try to find a path to an item in a module.\n@@ -2485,7 +2501,7 @@ impl<'a> Resolver<'a> {\n         let unqualified_def = resolve_identifier_with_fallback(self, None);\n         let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n         match (qualified_binding, unqualified_def) {\n-            (Ok(binding), Some(ref ud)) if binding.def().unwrap() == ud.def => {\n+            (Ok(binding), Some(ref ud)) if binding.def() == ud.def => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2495,7 +2511,7 @@ impl<'a> Resolver<'a> {\n             _ => {}\n         }\n \n-        qualified_binding.map(|binding| mk_res(binding.def().unwrap()))\n+        qualified_binding.map(|binding| mk_res(binding.def()))\n     }\n \n     // Resolve a single identifier\n@@ -2618,16 +2634,9 @@ impl<'a> Resolver<'a> {\n         let containing_module;\n         match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n             Failed(err) => {\n-                let (span, msg) = match err {\n-                    Some((span, msg)) => (span, msg),\n-                    None => {\n-                        let msg = format!(\"Use of undeclared type or module `{}`\",\n-                                          names_to_string(&module_path));\n-                        (span, msg)\n-                    }\n-                };\n-\n-                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                if let Some((span, msg)) = err {\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                }\n                 return Err(true);\n             }\n             Indeterminate => return Err(false),\n@@ -2655,16 +2664,9 @@ impl<'a> Resolver<'a> {\n         let containing_module;\n         match self.resolve_module_path_from_root(root_module, &module_path, 0, Some(span)) {\n             Failed(err) => {\n-                let (span, msg) = match err {\n-                    Some((span, msg)) => (span, msg),\n-                    None => {\n-                        let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          names_to_string(&module_path));\n-                        (span, msg)\n-                    }\n-                };\n-\n-                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                if let Some((span, msg)) = err {\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                }\n                 return Err(true);\n             }\n \n@@ -3118,15 +3120,15 @@ impl<'a> Resolver<'a> {\n                     let mut collected_traits = Vec::new();\n                     module.for_each_child(|name, ns, binding| {\n                         if ns != TypeNS { return }\n-                        if let Some(Def::Trait(_)) = binding.def() {\n+                        if let Def::Trait(_) = binding.def() {\n                             collected_traits.push((name, binding));\n                         }\n                     });\n                     *traits = Some(collected_traits.into_boxed_slice());\n                 }\n \n                 for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-                    let trait_def_id = binding.def().unwrap().def_id();\n+                    let trait_def_id = binding.def().def_id();\n                     if this.trait_item_map.contains_key(&(name, trait_def_id)) {\n                         let mut import_id = None;\n                         if let NameBindingKind::Import { directive, .. } = binding.kind {\n@@ -3185,8 +3187,8 @@ impl<'a> Resolver<'a> {\n                 if name_binding.is_import() { return; }\n \n                 // collect results based on the filter function\n-                if let Some(def) = name_binding.def() {\n-                    if name == lookup_name && ns == namespace && filter_fn(def) {\n+                if name == lookup_name && ns == namespace {\n+                    if filter_fn(name_binding.def()) {\n                         // create the path\n                         let ident = ast::Ident::with_empty_ctxt(name);\n                         let params = PathParameters::none();\n@@ -3216,7 +3218,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 // collect submodules to explore\n-                if let Some(module) = name_binding.module() {\n+                if let Ok(module) = name_binding.module() {\n                     // form the path\n                     let path_segments = match module.parent_link {\n                         NoParentLink => path_segments.clone(),\n@@ -3263,23 +3265,23 @@ impl<'a> Resolver<'a> {\n             ast::Visibility::Public => return ty::Visibility::Public,\n             ast::Visibility::Crate(_) => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n             ast::Visibility::Restricted { ref path, id } => (path, id),\n-            ast::Visibility::Inherited => return self.current_vis,\n+            ast::Visibility::Inherited => {\n+                return ty::Visibility::Restricted(self.current_module.normal_ancestor_id.unwrap());\n+            }\n         };\n \n         let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier.name).collect();\n         let mut path_resolution = err_path_resolution();\n         let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, Some(path.span)) {\n             Success(module) => {\n-                let def = module.def.unwrap();\n-                path_resolution = PathResolution::new(def);\n-                ty::Visibility::Restricted(self.definitions.as_local_node_id(def.def_id()).unwrap())\n-            }\n-            Failed(Some((span, msg))) => {\n-                self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n-                ty::Visibility::Public\n+                path_resolution = PathResolution::new(module.def.unwrap());\n+                ty::Visibility::Restricted(module.normal_ancestor_id.unwrap())\n             }\n-            _ => {\n-                self.session.span_err(path.span, \"unresolved module path\");\n+            Indeterminate => unreachable!(),\n+            Failed(err) => {\n+                if let Some((span, msg)) = err {\n+                    self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n+                }\n                 ty::Visibility::Public\n             }\n         };\n@@ -3292,12 +3294,28 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn is_accessible(&self, vis: ty::Visibility) -> bool {\n-        vis.is_at_least(self.current_vis, self)\n+        vis.is_accessible_from(self.current_module.normal_ancestor_id.unwrap(), self)\n+    }\n+\n+    fn is_accessible_from(&self, vis: ty::Visibility, module: Module<'a>) -> bool {\n+        vis.is_accessible_from(module.normal_ancestor_id.unwrap(), self)\n     }\n \n-    fn report_privacy_errors(&self) {\n-        if self.privacy_errors.len() == 0 { return }\n+    fn report_errors(&self) {\n         let mut reported_spans = FnvHashSet();\n+\n+        for &(span, name, binding) in &self.ambiguity_errors {\n+            if !reported_spans.insert(span) { continue }\n+            let (b1, b2) = binding.ambiguity().unwrap();\n+            let msg1 = format!(\"`{}` could resolve to the name imported here\", name);\n+            let msg2 = format!(\"`{}` could also resolve to the name imported here\", name);\n+            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n+                .span_note(b1.span, &msg1)\n+                .span_note(b2.span, &msg2)\n+                .note(&format!(\"Consider adding an explicit import of `{}` to disambiguate\", name))\n+                .emit();\n+        }\n+\n         for &PrivacyError(span, name, binding) in &self.privacy_errors {\n             if !reported_spans.insert(span) { continue }\n             if binding.is_extern_crate() {\n@@ -3306,7 +3324,7 @@ impl<'a> Resolver<'a> {\n                 let msg = format!(\"extern crate `{}` is private\", name);\n                 self.session.add_lint(lint::builtin::INACCESSIBLE_EXTERN_CRATE, node_id, span, msg);\n             } else {\n-                let def = binding.def().unwrap();\n+                let def = binding.def();\n                 self.session.span_err(span, &format!(\"{} `{}` is private\", def.kind_name(), name));\n             }\n         }\n@@ -3339,9 +3357,9 @@ impl<'a> Resolver<'a> {\n         let msg = {\n             let kind = match (ns, old_binding.module()) {\n                 (ValueNS, _) => \"a value\",\n-                (TypeNS, Some(module)) if module.extern_crate_id.is_some() => \"an extern crate\",\n-                (TypeNS, Some(module)) if module.is_normal() => \"a module\",\n-                (TypeNS, Some(module)) if module.is_trait() => \"a trait\",\n+                (TypeNS, Ok(module)) if module.extern_crate_id.is_some() => \"an extern crate\",\n+                (TypeNS, Ok(module)) if module.is_normal() => \"a module\",\n+                (TypeNS, Ok(module)) if module.is_trait() => \"a trait\",\n                 (TypeNS, _) => \"a type\",\n             };\n             format!(\"{} named `{}` has already been {} in this {}\","}, {"sha": "875d6745f6b2e26f7c5da2d45d0a0f5052a570db", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 128, "deletions": 60, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8aeb15acc73311ea4308e74a166ba3c0b261c810", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::def::*;\n \n use syntax::ast::{NodeId, Name};\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n \n@@ -52,7 +52,11 @@ pub enum ImportDirectiveSubclass<'a> {\n         value_result: Cell<Result<&'a NameBinding<'a>, Determinacy>>,\n         type_result: Cell<Result<&'a NameBinding<'a>, Determinacy>>,\n     },\n-    GlobImport { is_prelude: bool },\n+    GlobImport {\n+        is_prelude: bool,\n+        max_vis: Cell<ty::Visibility>, // The visibility of the greatest reexport.\n+        // n.b. `max_vis` is only used in `finalize_import` to check for reexport errors.\n+    },\n }\n \n impl<'a> ImportDirectiveSubclass<'a> {\n@@ -167,16 +171,20 @@ impl<'a> Resolver<'a> {\n             _ => return Failed(None), // This happens when there is a cycle of imports\n         };\n \n+        let new_import_semantics = self.new_import_semantics;\n         let is_disallowed_private_import = |binding: &NameBinding| {\n-            !allow_private_imports && !binding.is_pseudo_public() && binding.is_import()\n+            !new_import_semantics && !allow_private_imports && // disallowed\n+            binding.vis != ty::Visibility::Public && binding.is_import() // non-`pub` import\n         };\n \n         if let Some(span) = record_used {\n             if let Some(binding) = resolution.binding {\n                 if is_disallowed_private_import(binding) {\n                     return Failed(None);\n                 }\n-                self.record_use(name, ns, binding);\n+                if self.record_use(name, ns, binding, span) {\n+                    return Success(self.dummy_binding);\n+                }\n                 if !self.is_accessible(binding.vis) {\n                     self.privacy_errors.push(PrivacyError(span, name, binding));\n                 }\n@@ -274,7 +282,7 @@ impl<'a> Resolver<'a> {\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n-            GlobImport { is_prelude: true } => {}\n+            GlobImport { is_prelude: true, .. } => {}\n             GlobImport { .. } => self.current_module.globs.borrow_mut().push(directive),\n         }\n     }\n@@ -283,13 +291,26 @@ impl<'a> Resolver<'a> {\n     // return the corresponding binding defined by the import directive.\n     fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n               -> NameBinding<'a> {\n+        let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n+                     !directive.is_glob() && binding.is_extern_crate() { // c.f. `PRIVATE_IN_PUBLIC`\n+            directive.vis.get()\n+        } else {\n+            binding.pseudo_vis()\n+        };\n+\n+        if let GlobImport { ref max_vis, .. } = directive.subclass {\n+            if vis == directive.vis.get() || vis.is_at_least(max_vis.get(), self) {\n+                max_vis.set(vis)\n+            }\n+        }\n+\n         NameBinding {\n             kind: NameBindingKind::Import {\n                 binding: binding,\n                 directive: directive,\n             },\n             span: directive.span,\n-            vis: directive.vis.get(),\n+            vis: vis,\n         }\n     }\n \n@@ -299,10 +320,28 @@ impl<'a> Resolver<'a> {\n         where T: ToNameBinding<'a>\n     {\n         let binding = self.arenas.alloc_name_binding(binding.to_name_binding());\n-        self.update_resolution(module, name, ns, |_, resolution| {\n+        self.update_resolution(module, name, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {\n-                    resolution.duplicate_globs.push(binding);\n+                    if !this.new_import_semantics || !old_binding.is_glob_import() {\n+                        resolution.duplicate_globs.push(binding);\n+                    } else if binding.def() != old_binding.def() {\n+                        resolution.binding = Some(this.arenas.alloc_name_binding(NameBinding {\n+                            kind: NameBindingKind::Ambiguity {\n+                                b1: old_binding,\n+                                b2: binding,\n+                            },\n+                            vis: if old_binding.vis.is_at_least(binding.vis, this) {\n+                                old_binding.vis\n+                            } else {\n+                                binding.vis\n+                            },\n+                            span: old_binding.span,\n+                        }));\n+                    } else if !old_binding.vis.is_at_least(binding.vis, this) {\n+                        // We are glob-importing the same item but with greater visibility.\n+                        resolution.binding = Some(binding);\n+                    }\n                 } else if old_binding.is_glob_import() {\n                     resolution.duplicate_globs.push(old_binding);\n                     resolution.binding = Some(binding);\n@@ -324,23 +363,29 @@ impl<'a> Resolver<'a> {\n     {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n-        let (new_binding, t) = {\n+        let (binding, t) = {\n             let mut resolution = &mut *self.resolution(module, name, ns).borrow_mut();\n-            let was_known = resolution.binding().is_some();\n+            let old_binding = resolution.binding();\n \n             let t = f(self, resolution);\n \n-            if was_known { return t; }\n             match resolution.binding() {\n-                Some(binding) => (binding, t),\n+                _ if !self.new_import_semantics && old_binding.is_some() => return t,\n                 None => return t,\n+                Some(binding) => match old_binding {\n+                    Some(old_binding) if old_binding as *const _ == binding as *const _ => return t,\n+                    _ => (binding, t),\n+                }\n             }\n         };\n \n-        // Define `new_binding` in `module`s glob importers.\n-        if new_binding.is_importable() && new_binding.is_pseudo_public() {\n-            for directive in module.glob_importers.borrow_mut().iter() {\n-                let imported_binding = self.import(new_binding, directive);\n+        // Define `binding` in `module`s glob importers.\n+        for directive in module.glob_importers.borrow_mut().iter() {\n+            if match self.new_import_semantics {\n+                true => self.is_accessible_from(binding.vis, directive.parent),\n+                false => binding.vis == ty::Visibility::Public,\n+            } {\n+                let imported_binding = self.import(binding, directive);\n                 let _ = self.try_define(directive.parent, name, ns, imported_binding);\n             }\n         }\n@@ -381,14 +426,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     // remain or unsuccessfully when no forward progress in resolving imports\n     // is made.\n \n-    fn set_current_module(&mut self, module: Module<'b>) {\n-        self.current_module = module;\n-        self.current_vis = ty::Visibility::Restricted({\n-            let normal_module = self.get_nearest_normal_module_parent_or_self(module);\n-            self.definitions.as_local_node_id(normal_module.def_id().unwrap()).unwrap()\n-        });\n-    }\n-\n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n     fn resolve_imports(&mut self) {\n@@ -424,7 +461,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 errors = true;\n                 let (span, help) = match err {\n                     Some((span, msg)) => (span, msg),\n-                    None => (import.span, String::new()),\n+                    None => continue,\n                 };\n \n                 // If the error is a single failed import then create a \"fake\" import\n@@ -450,13 +487,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     // failed resolution\n     fn import_dummy_binding(&mut self, directive: &'b ImportDirective<'b>) {\n         if let SingleImport { target, .. } = directive.subclass {\n-            let dummy_binding = self.arenas.alloc_name_binding(NameBinding {\n-                kind: NameBindingKind::Def(Def::Err),\n-                span: DUMMY_SP,\n-                vis: ty::Visibility::Public,\n-            });\n+            let dummy_binding = self.dummy_binding;\n             let dummy_binding = self.import(dummy_binding, directive);\n-\n             let _ = self.try_define(directive.parent, target, ValueNS, dummy_binding.clone());\n             let _ = self.try_define(directive.parent, target, TypeNS, dummy_binding);\n         }\n@@ -472,7 +504,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                names_to_string(&directive.module_path),\n                module_to_string(self.current_module));\n \n-        self.set_current_module(directive.parent);\n+        self.current_module = directive.parent;\n \n         let module = if let Some(module) = directive.imported_module.get() {\n             module\n@@ -548,7 +580,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     }\n \n     fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n-        self.set_current_module(directive.parent);\n+        self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n         let module_result = self.resolve_module_path(&module_path, DontUseLexicalScope, Some(span));\n@@ -566,12 +598,23 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 let msg = \"Cannot glob-import a module into itself.\".into();\n                 return Failed(Some((directive.span, msg)));\n             }\n-            GlobImport { .. } => return Success(()),\n+            GlobImport { is_prelude, ref max_vis } => {\n+                if !is_prelude &&\n+                   max_vis.get() != ty::Visibility::PrivateExternal && // Allow empty globs.\n+                   !max_vis.get().is_at_least(directive.vis.get(), self) {\n+                    let msg = \"A non-empty glob must import something with the glob's visibility\";\n+                    self.session.span_err(directive.span, msg);\n+                }\n+                return Success(());\n+            }\n         };\n \n         for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n             if let Ok(binding) = result {\n-                self.record_use(name, ns, binding);\n+                if self.record_use(name, ns, binding, directive.span) {\n+                    self.resolution(module, name, ns).borrow_mut().binding =\n+                        Some(self.dummy_binding);\n+                }\n             }\n         }\n \n@@ -608,22 +651,44 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n         }\n \n+        let session = self.session;\n+        let reexport_error = || {\n+            let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n+            let note_msg =\n+                format!(\"consider marking `{}` as `pub` in the imported module\", name);\n+            struct_span_err!(session, directive.span, E0364, \"{}\", &msg)\n+                .span_note(directive.span, &note_msg)\n+                .emit();\n+        };\n+\n+        let extern_crate_lint = || {\n+            let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n+                               (error E0364), consider declaring with `pub`\",\n+                               name);\n+            session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n+        };\n+\n         match (value_result, type_result) {\n+            // With `#![feature(item_like_imports)]`, all namespaces\n+            // must be re-exported with extra visibility for an error to occur.\n+            (Ok(value_binding), Ok(type_binding)) if self.new_import_semantics => {\n+                let vis = directive.vis.get();\n+                if !value_binding.pseudo_vis().is_at_least(vis, self) &&\n+                   !type_binding.pseudo_vis().is_at_least(vis, self) {\n+                    reexport_error();\n+                } else if type_binding.is_extern_crate() &&\n+                          !type_binding.vis.is_at_least(vis, self) {\n+                    extern_crate_lint();\n+                }\n+            }\n+\n             (Ok(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis.get(), self) => {\n-                let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n-                let note_msg =\n-                    format!(\"consider marking `{}` as `pub` in the imported module\", name);\n-                struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n-                    .span_note(directive.span, &note_msg)\n-                    .emit();\n+                reexport_error();\n             }\n \n             (_, Ok(binding)) if !binding.pseudo_vis().is_at_least(directive.vis.get(), self) => {\n                 if binding.is_extern_crate() {\n-                    let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n-                                       (error E0364), consider declaring with `pub`\",\n-                                       name);\n-                    self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n+                    extern_crate_lint();\n                 } else {\n                     struct_span_err!(self.session, directive.span, E0365,\n                                      \"`{}` is private, and cannot be reexported\", name)\n@@ -639,9 +704,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let def = match type_result.ok().and_then(NameBinding::def) {\n+        let def = match type_result.ok().map(NameBinding::def) {\n             Some(def) => def,\n-            None => value_result.ok().and_then(NameBinding::def).unwrap(),\n+            None => value_result.ok().map(NameBinding::def).unwrap(),\n         };\n         let path_resolution = PathResolution::new(def);\n         self.def_map.insert(directive.id, path_resolution);\n@@ -656,11 +721,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         if let Some(Def::Trait(_)) = module.def {\n             self.session.span_err(directive.span, \"items in traits are not importable.\");\n-        }\n-\n-        if module.def_id() == directive.parent.def_id()  {\n             return;\n-        } else if let GlobImport { is_prelude: true } = directive.subclass {\n+        } else if module.def_id() == directive.parent.def_id()  {\n+            return;\n+        } else if let GlobImport { is_prelude: true, .. } = directive.subclass {\n             self.prelude = Some(module);\n             return;\n         }\n@@ -674,7 +738,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n-            if binding.is_importable() && binding.is_pseudo_public() {\n+            if binding.pseudo_vis() == ty::Visibility::Public ||\n+               self.new_import_semantics && self.is_accessible(binding.vis) {\n                 let imported_binding = self.import(binding, directive);\n                 let _ = self.try_define(directive.parent, name, ns, imported_binding);\n             }\n@@ -702,20 +767,23 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             };\n \n             // Report conflicts\n-            for duplicate_glob in resolution.duplicate_globs.iter() {\n-                // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n-                if !binding.is_import() {\n-                    if let NameBindingKind::Import { binding, .. } = duplicate_glob.kind {\n-                        if binding.is_import() { continue }\n+            if !self.new_import_semantics {\n+                for duplicate_glob in resolution.duplicate_globs.iter() {\n+                    // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n+                    if !binding.is_import() {\n+                        if let NameBindingKind::Import { binding, .. } = duplicate_glob.kind {\n+                            if binding.is_import() { continue }\n+                        }\n                     }\n-                }\n \n-                self.report_conflict(module, name, ns, duplicate_glob, binding);\n+                    self.report_conflict(module, name, ns, duplicate_glob, binding);\n+                }\n             }\n \n             if binding.vis == ty::Visibility::Public &&\n                (binding.is_import() || binding.is_extern_crate()) {\n-                if let Some(def) = binding.def() {\n+                let def = binding.def();\n+                if def != Def::Err {\n                     reexports.push(Export { name: name, def_id: def.def_id() });\n                 }\n             }"}, {"sha": "02c44c3a56d7e61e31c8820535a54aebe5332de4", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8aeb15acc73311ea4308e74a166ba3c0b261c810", "patch": "@@ -285,7 +285,10 @@ declare_features! (\n \n     // Allows the sysV64 ABI to be specified on all platforms\n     // instead of just the platforms on which it is the C ABI\n-    (active, abi_sysv64, \"1.13.0\", Some(36167))\n+    (active, abi_sysv64, \"1.13.0\", Some(36167)),\n+\n+    // Use the import semantics from RFC 1560.\n+    (active, item_like_imports, \"1.13.0\", Some(35120))\n );\n \n declare_features! ("}, {"sha": "6987d06ef12c3b40d0a504345ad8cc173e00cd79", "filename": "src/test/compile-fail/bad-module.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-module.rs?ref=8aeb15acc73311ea4308e74a166ba3c0b261c810", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: failed to resolve. Use of undeclared type or module `thing`\n+fn main() {\n+    let foo = thing::len(Vec::new());\n+    //~^ ERROR failed to resolve. Use of undeclared type or module `thing`\n \n-fn main() { let foo = thing::len(Vec::new()); }\n+    let foo = foo::bar::baz();\n+    //~^ ERROR failed to resolve. Use of undeclared type or module `foo`\n+}"}, {"sha": "fb61bb8e489bec7b3e9ccb80f251ea8fcc423f29", "filename": "src/test/compile-fail/imports/duplicate.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs?ref=8aeb15acc73311ea4308e74a166ba3c0b261c810", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(item_like_imports)]\n+\n+mod a {\n+    pub fn foo() {}\n+}\n+\n+mod b {\n+    pub fn foo() {}\n+}\n+\n+mod c {\n+    pub use a::foo;\n+}\n+\n+mod d {\n+    use a::foo; //~ NOTE previous import\n+    use a::foo; //~ ERROR `foo` has already been imported\n+                //~| NOTE already imported\n+}\n+\n+mod e {\n+    pub use a::*;\n+    pub use c::*; // ok\n+}\n+\n+mod f {\n+    pub use a::*; //~ NOTE `foo` could resolve to the name imported here\n+    pub use b::*; //~ NOTE `foo` could also resolve to the name imported here\n+}\n+\n+mod g {\n+    pub use a::*; //~ NOTE `foo` could resolve to the name imported here\n+    pub use f::*; //~ NOTE `foo` could also resolve to the name imported here\n+}\n+\n+fn main() {\n+    e::foo();\n+    f::foo(); //~ ERROR `foo` is ambiguous\n+              //~| NOTE Consider adding an explicit import of `foo` to disambiguate\n+    g::foo(); //~ ERROR `foo` is ambiguous\n+              //~| NOTE Consider adding an explicit import of `foo` to disambiguate\n+}\n+\n+mod ambiguous_module_errors {\n+    pub mod m1 { pub use super::m1 as foo; }\n+    pub mod m2 { pub use super::m2 as foo; }\n+\n+    use self::m1::*; //~ NOTE\n+                     //~| NOTE\n+    use self::m2::*; //~ NOTE\n+                     //~| NOTE\n+\n+    use self::foo::bar; //~ ERROR `foo` is ambiguous\n+                        //~| NOTE\n+\n+    fn f() {\n+        foo::bar(); //~ ERROR `foo` is ambiguous\n+                    //~| NOTE\n+    }\n+}"}, {"sha": "fc46b23351adf071f8e5893c71285ad495340452", "filename": "src/test/compile-fail/imports/reexports.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Fcompile-fail%2Fimports%2Freexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Fcompile-fail%2Fimports%2Freexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Freexports.rs?ref=8aeb15acc73311ea4308e74a166ba3c0b261c810", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(item_like_imports)]\n+\n+mod a {\n+    fn foo() {}\n+    mod foo {}\n+\n+    mod a {\n+        pub use super::foo; //~ ERROR cannot be reexported\n+        pub use super::*; //~ ERROR must import something with the glob's visibility\n+    }\n+}\n+\n+mod b {\n+    pub fn foo() {}\n+    mod foo { pub struct S; }\n+\n+    pub mod a {\n+        pub use super::foo; // This is OK since the value `foo` is visible enough.\n+        fn f(_: foo::S) {} // `foo` is imported in the type namespace (but not `pub` reexported).\n+    }\n+\n+    pub mod b {\n+        pub use super::*; // This is also OK since the value `foo` is visible enough.\n+        fn f(_: foo::S) {} // Again, the module `foo` is imported (but not `pub` reexported).\n+    }\n+}\n+\n+mod c {\n+    // Test that `foo` is not reexported.\n+    use b::a::foo::S; //~ ERROR `foo`\n+    use b::b::foo::S as T; //~ ERROR `foo`\n+}\n+\n+fn main() {}"}, {"sha": "c987d9f2f4e1b0c185530d6b4c560c258c7b59db", "filename": "src/test/compile-fail/task-rng-isnt-sendable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs?ref=8aeb15acc73311ea4308e74a166ba3c0b261c810", "patch": "@@ -10,10 +10,10 @@\n \n // ensure that the ThreadRng isn't/doesn't become accidentally sendable.\n \n-use std::rand; //~ ERROR: module `rand` is private\n+use std::__rand::ThreadRng;\n \n fn test_send<S: Send>() {}\n \n pub fn main() {\n-    test_send::<rand::ThreadRng>();\n+    test_send::<ThreadRng>(); //~ ERROR std::marker::Send` is not satisfied\n }"}, {"sha": "9851dfe0262f8ce28a17fd645ed78a9bbd0f7740", "filename": "src/test/run-pass/imports.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Frun-pass%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Frun-pass%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimports.rs?ref=8aeb15acc73311ea4308e74a166ba3c0b261c810", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty : (#23623) problems when ending with // comments\n+\n+#![feature(item_like_imports)]\n+#![allow(unused)]\n+\n+// Like other items, private imports can be imported and used non-lexically in paths.\n+mod a {\n+    use a as foo;\n+    use self::foo::foo as bar;\n+\n+    mod b {\n+        use super::bar;\n+    }\n+}\n+\n+mod foo { pub fn f() {} }\n+mod bar { pub fn f() {} }\n+\n+pub fn f() -> bool { true }\n+\n+// Items and explicit imports shadow globs.\n+fn g() {\n+    use foo::*;\n+    use bar::*;\n+    fn f() -> bool { true }\n+    let _: bool = f();\n+}\n+\n+fn h() {\n+    use foo::*;\n+    use bar::*;\n+    use f;\n+    let _: bool = f();\n+}\n+\n+// Here, there appears to be shadowing but isn't because of namespaces.\n+mod b {\n+    use foo::*; // This imports `f` in the value namespace.\n+    use super::b as f; // This imports `f` only in the type namespace,\n+    fn test() { self::f(); } // so the glob isn't shadowed.\n+}\n+\n+// Here, there is shadowing in one namespace, but not the other.\n+mod c {\n+    mod test {\n+        pub fn f() {}\n+        pub mod f {}\n+    }\n+    use self::test::*; // This glob-imports `f` in both namespaces.\n+    mod f { pub fn f() {} } // This shadows the glob only in the value namespace.\n+\n+    fn test() {\n+        self::f(); // Check that the glob-imported value isn't shadowed.\n+        self::f::f(); // Check that the glob-imported module is shadowed.\n+    }\n+}\n+\n+// Unused names can be ambiguous.\n+mod d {\n+    pub use foo::*; // This imports `f` in the value namespace.\n+    pub use bar::*; // This also imports `f` in the value namespace.\n+}\n+\n+mod e {\n+    pub use d::*; // n.b. Since `e::f` is not used, this is not considered to be a use of `d::f`.\n+}\n+\n+fn main() {}"}]}