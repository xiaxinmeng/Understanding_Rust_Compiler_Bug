{"sha": "8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNTBlMjk1ZmEyZjNlNTUwZTFjOWMxOWUxYTljYWRiNjMyM2ZmNDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-02T10:18:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-02T10:18:59Z"}, "message": "Auto merge of #34611 - Manishearth:rollup, r=Manishearth\n\nRollup of 7 pull requests\n\n- Successful merges: #34531, #34545, #34551, #34566, #34567, #34574, #34583\n- Failed merges:", "tree": {"sha": "14a69746e8efb85c86b6be4ce79a2908b61b5769", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14a69746e8efb85c86b6be4ce79a2908b61b5769"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "html_url": "https://github.com/rust-lang/rust/commit/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b59647fae4c8d1748d922ef30a872c7b2b5410d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b59647fae4c8d1748d922ef30a872c7b2b5410d", "html_url": "https://github.com/rust-lang/rust/commit/2b59647fae4c8d1748d922ef30a872c7b2b5410d"}, {"sha": "adda4e41beb1d9821fb5efaa90897c81c87b47c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/adda4e41beb1d9821fb5efaa90897c81c87b47c8", "html_url": "https://github.com/rust-lang/rust/commit/adda4e41beb1d9821fb5efaa90897c81c87b47c8"}], "stats": {"total": 596, "additions": 432, "deletions": 164}, "files": [{"sha": "9463b0e849856b1fee2cd76b69193cc19ca88d79", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -119,7 +119,7 @@ $ make && make install\n If you\u2019d like to build the documentation, it\u2019s almost the same:\n \n ```sh\n-./configure\n+$ ./configure\n $ make docs\n ```\n "}, {"sha": "ff0941a97dce1e3fcbfde7bdf64e79dca66ffc33", "filename": "src/bootstrap/build/cc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcc.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -90,6 +90,7 @@ fn set_compiler(cfg: &mut gcc::Config,\n         // compiler already takes into account the triple in question.\n         t if t.contains(\"android\") => {\n             if let Some(ndk) = config.and_then(|c| c.ndk.as_ref()) {\n+                let target = target.replace(\"armv7\", \"arm\");\n                 let compiler = format!(\"{}-{}\", target, gnu_compiler);\n                 cfg.compiler(ndk.join(\"bin\").join(compiler));\n             }"}, {"sha": "0a096f8e4de417aea9560ad28f3e5c3f6a3503c4", "filename": "src/bootstrap/build/check.rs", "status": "modified", "additions": 117, "deletions": 11, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcheck.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -23,6 +23,9 @@ use build_helper::output;\n use bootstrap::{dylib_path, dylib_path_var};\n \n use build::{Build, Compiler, Mode};\n+use build::util;\n+\n+const ADB_TEST_DIR: &'static str = \"/data/tmp\";\n \n /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n ///\n@@ -88,6 +91,7 @@ pub fn compiletest(build: &Build,\n                    target: &str,\n                    mode: &str,\n                    suite: &str) {\n+    println!(\"Check compiletest {} ({} -> {})\", suite, compiler.host, target);\n     let mut cmd = build.tool_cmd(compiler, \"compiletest\");\n \n     // compiletest currently has... a lot of arguments, so let's just pass all\n@@ -105,21 +109,23 @@ pub fn compiletest(build: &Build,\n     cmd.arg(\"--host\").arg(compiler.host);\n     cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(&build.config.build));\n \n-    let mut flags = format!(\"-Crpath\");\n+    let mut flags = vec![\"-Crpath\".to_string()];\n     if build.config.rust_optimize_tests {\n-        flags.push_str(\" -O\");\n+        flags.push(\"-O\".to_string());\n     }\n     if build.config.rust_debuginfo_tests {\n-        flags.push_str(\" -g\");\n+        flags.push(\"-g\".to_string());\n     }\n \n-    cmd.arg(\"--host-rustcflags\").arg(&flags);\n-\n-    let linkflag = format!(\"-Lnative={}\", build.test_helpers_out(target).display());\n-    cmd.arg(\"--target-rustcflags\").arg(format!(\"{} {}\", flags, linkflag));\n+    let mut hostflags = build.rustc_flags(&compiler.host);\n+    hostflags.extend(flags.clone());\n+    cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n \n-    // FIXME: needs android support\n-    cmd.arg(\"--android-cross-path\").arg(\"\");\n+    let mut targetflags = build.rustc_flags(&target);\n+    targetflags.extend(flags);\n+    targetflags.push(format!(\"-Lnative={}\",\n+                             build.test_helpers_out(target).display()));\n+    cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n \n     // FIXME: CFG_PYTHON should probably be detected more robustly elsewhere\n     let python_default = \"python\";\n@@ -180,6 +186,16 @@ pub fn compiletest(build: &Build,\n     }\n     build.add_bootstrap_key(compiler, &mut cmd);\n \n+    cmd.arg(\"--adb-path\").arg(\"adb\");\n+    cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n+    if target.contains(\"android\") {\n+        // Assume that cc for this target comes from the android sysroot\n+        cmd.arg(\"--android-cross-path\")\n+           .arg(build.cc(target).parent().unwrap().parent().unwrap());\n+    } else {\n+        cmd.arg(\"--android-cross-path\").arg(\"\");\n+    }\n+\n     build.run(&mut cmd);\n }\n \n@@ -302,7 +318,97 @@ pub fn krate(build: &Build,\n     let mut dylib_path = dylib_path();\n     dylib_path.insert(0, build.sysroot_libdir(compiler, target));\n     cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n-    cargo.args(&build.flags.args);\n \n-    build.run(&mut cargo);\n+    if target.contains(\"android\") {\n+        build.run(cargo.arg(\"--no-run\"));\n+        krate_android(build, compiler, target, mode);\n+    } else {\n+        cargo.args(&build.flags.args);\n+        build.run(&mut cargo);\n+    }\n+}\n+\n+fn krate_android(build: &Build,\n+                 compiler: &Compiler,\n+                 target: &str,\n+                 mode: Mode) {\n+    let mut tests = Vec::new();\n+    let out_dir = build.cargo_out(compiler, mode, target);\n+    find_tests(&out_dir, target, &mut tests);\n+    find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n+\n+    for test in tests {\n+        build.run(Command::new(\"adb\").arg(\"push\").arg(&test).arg(ADB_TEST_DIR));\n+\n+        let test_file_name = test.file_name().unwrap().to_string_lossy();\n+        let log = format!(\"{}/check-stage{}-T-{}-H-{}-{}.log\",\n+                          ADB_TEST_DIR,\n+                          compiler.stage,\n+                          target,\n+                          compiler.host,\n+                          test_file_name);\n+        let program = format!(\"(cd {dir}; \\\n+                                LD_LIBRARY_PATH=./{target} ./{test} \\\n+                                    --logfile {log} \\\n+                                    {args})\",\n+                              dir = ADB_TEST_DIR,\n+                              target = target,\n+                              test = test_file_name,\n+                              log = log,\n+                              args = build.flags.args.join(\" \"));\n+\n+        let output = output(Command::new(\"adb\").arg(\"shell\").arg(&program));\n+        println!(\"{}\", output);\n+        build.run(Command::new(\"adb\")\n+                          .arg(\"pull\")\n+                          .arg(&log)\n+                          .arg(build.out.join(\"tmp\")));\n+        build.run(Command::new(\"adb\").arg(\"shell\").arg(\"rm\").arg(&log));\n+        if !output.contains(\"result: ok\") {\n+            panic!(\"some tests failed\");\n+        }\n+    }\n+}\n+\n+fn find_tests(dir: &Path,\n+              target: &str,\n+              dst: &mut Vec<PathBuf>) {\n+    for e in t!(dir.read_dir()).map(|e| t!(e)) {\n+        let file_type = t!(e.file_type());\n+        if !file_type.is_file() {\n+            continue\n+        }\n+        let filename = e.file_name().into_string().unwrap();\n+        if (target.contains(\"windows\") && filename.ends_with(\".exe\")) ||\n+           (!target.contains(\"windows\") && !filename.contains(\".\")) {\n+            dst.push(e.path());\n+        }\n+    }\n+}\n+\n+pub fn android_copy_libs(build: &Build,\n+                         compiler: &Compiler,\n+                         target: &str) {\n+    println!(\"Android copy libs to emulator ({})\", target);\n+    build.run(Command::new(\"adb\").arg(\"remount\"));\n+    build.run(Command::new(\"adb\").args(&[\"shell\", \"rm\", \"-r\", ADB_TEST_DIR]));\n+    build.run(Command::new(\"adb\").args(&[\"shell\", \"mkdir\", ADB_TEST_DIR]));\n+    build.run(Command::new(\"adb\")\n+                      .arg(\"push\")\n+                      .arg(build.src.join(\"src/etc/adb_run_wrapper.sh\"))\n+                      .arg(ADB_TEST_DIR));\n+\n+    let target_dir = format!(\"{}/{}\", ADB_TEST_DIR, target);\n+    build.run(Command::new(\"adb\").args(&[\"shell\", \"mkdir\", &target_dir[..]]));\n+\n+    for f in t!(build.sysroot_libdir(compiler, target).read_dir()) {\n+        let f = t!(f);\n+        let name = f.file_name().into_string().unwrap();\n+        if util::is_dylib(&name) {\n+            build.run(Command::new(\"adb\")\n+                              .arg(\"push\")\n+                              .arg(f.path())\n+                              .arg(&target_dir));\n+        }\n+    }\n }"}, {"sha": "498196e9b6dfc12454274e75cd695c2ad2a04b65", "filename": "src/bootstrap/build/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fconfig.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -368,13 +368,13 @@ impl Config {\n                     target.ndk = Some(PathBuf::from(value));\n                 }\n                 \"CFG_I686_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = \"i686-linux-androideabi\".to_string();\n+                    let target = \"i686-linux-android\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n                     target.ndk = Some(PathBuf::from(value));\n                 }\n                 \"CFG_AARCH64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = \"aarch64-linux-androideabi\".to_string();\n+                    let target = \"aarch64-linux-android\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n                     target.ndk = Some(PathBuf::from(value));"}, {"sha": "6eed7eaf206f4631f584604a5aefa11d70329041", "filename": "src/bootstrap/build/dist.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fdist.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -135,7 +135,6 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n \n     // Prepare the overlay which is part of the tarball but won't actually be\n     // installed\n-    t!(fs::create_dir_all(&overlay));\n     let cp = |file: &str| {\n         install(&build.src.join(file), &overlay, 0o644);\n     };\n@@ -199,7 +198,6 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n \n         // Copy runtime DLLs needed by the compiler\n         if libdir != \"bin\" {\n-            t!(fs::create_dir_all(image.join(libdir)));\n             for entry in t!(src.join(libdir).read_dir()).map(|e| t!(e)) {\n                 let name = entry.file_name();\n                 if let Some(s) = name.to_str() {\n@@ -221,7 +219,6 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n         let cp = |file: &str| {\n             install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n         };\n-        t!(fs::create_dir_all(&image.join(\"share/doc/rust\")));\n         cp(\"COPYRIGHT\");\n         cp(\"LICENSE-APACHE\");\n         cp(\"LICENSE-MIT\");\n@@ -289,6 +286,7 @@ pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n \n fn install(src: &Path, dstdir: &Path, perms: u32) {\n     let dst = dstdir.join(src.file_name().unwrap());\n+    t!(fs::create_dir_all(dstdir));\n     t!(fs::copy(src, &dst));\n     chmod(&dst, perms);\n }"}, {"sha": "195d1bc90c655fb191f832aeaa46c6bf8e3eb45a", "filename": "src/bootstrap/build/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -128,6 +128,7 @@ pub struct Build {\n ///\n /// These entries currently correspond to the various output directories of the\n /// build system, with each mod generating output in a different directory.\n+#[derive(Clone, Copy)]\n pub enum Mode {\n     /// This cargo is going to build the standard library, placing output in the\n     /// \"stageN-std\" directory.\n@@ -383,8 +384,7 @@ impl Build {\n                                        \"ui\", \"ui\");\n                 }\n                 CheckDebuginfo { compiler } => {\n-                    if target.target.contains(\"msvc\") ||\n-                       target.target.contains(\"android\") {\n+                    if target.target.contains(\"msvc\") {\n                         // nothing to do\n                     } else if target.target.contains(\"apple\") {\n                         check::compiletest(self, &compiler, target.target,\n@@ -434,8 +434,14 @@ impl Build {\n                                            target.target);\n                 }\n \n+                AndroidCopyLibs { compiler } => {\n+                    check::android_copy_libs(self, &compiler, target.target);\n+                }\n+\n+                // pseudo-steps\n                 Dist { .. } |\n-                Doc { .. } | // pseudo-steps\n+                Doc { .. } |\n+                CheckTarget { .. } |\n                 Check { .. } => {}\n             }\n         }"}, {"sha": "f6030cfd090d223e314bd93592a04d5e4bca7d62", "filename": "src/bootstrap/build/native.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fnative.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -49,6 +49,8 @@ pub fn llvm(build: &Build, target: &str) {\n         return\n     }\n \n+    println!(\"Building LLVM for {}\", target);\n+\n     let _ = fs::remove_dir_all(&dst.join(\"build\"));\n     t!(fs::create_dir_all(&dst.join(\"build\")));\n     let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n@@ -167,8 +169,10 @@ pub fn compiler_rt(build: &Build, target: &str) {\n             \"arm\" if target.contains(\"eabihf\") => \"armhf\",\n             _ => arch,\n         };\n-        let target = format!(\"clang_rt.builtins-{}{}\", builtins_arch, os_extra);\n-        (\"linux\".to_string(), target.clone(), target)\n+        let target = format!(\"clang_rt.builtins-{}\", builtins_arch);\n+        (\"linux\".to_string(),\n+         target.clone(),\n+         format!(\"{}{}\", target, os_extra))\n     } else if target.contains(\"apple-darwin\") {\n         let builtins_arch = match arch {\n             \"i686\" => \"i386\","}, {"sha": "5eced00e13973e35109cb32856aa732b16cd9696", "filename": "src/bootstrap/build/sanity.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fsanity.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -139,6 +139,10 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n \");\n             }\n         }\n+\n+        if target.contains(\"arm-linux-android\") {\n+            need_cmd(\"adb\".as_ref());\n+        }\n     }\n \n     for host in build.flags.host.iter() {"}, {"sha": "7cbbd6740a2657a5cbbfda23eea3a572fb30d936", "filename": "src/bootstrap/build/step.rs", "status": "modified", "additions": 87, "deletions": 31, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fbuild%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fstep.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -102,6 +102,7 @@ macro_rules! targets {\n             // Steps for running tests. The 'check' target is just a pseudo\n             // target to depend on a bunch of others.\n             (check, Check { stage: u32, compiler: Compiler<'a> }),\n+            (check_target, CheckTarget { stage: u32, compiler: Compiler<'a> }),\n             (check_linkcheck, CheckLinkcheck { stage: u32 }),\n             (check_cargotest, CheckCargoTest { stage: u32 }),\n             (check_tidy, CheckTidy { stage: u32 }),\n@@ -138,6 +139,9 @@ macro_rules! targets {\n             (dist_mingw, DistMingw { _dummy: () }),\n             (dist_rustc, DistRustc { stage: u32 }),\n             (dist_std, DistStd { compiler: Compiler<'a> }),\n+\n+            // Misc targets\n+            (android_copy_libs, AndroidCopyLibs { compiler: Compiler<'a> }),\n         }\n     }\n }\n@@ -382,37 +386,80 @@ impl<'a> Step<'a> {\n                      self.doc_error_index(stage)]\n             }\n             Source::Check { stage, compiler } => {\n-                vec![\n+                // Check is just a pseudo step which means check all targets,\n+                // so just depend on checking all targets.\n+                build.config.target.iter().map(|t| {\n+                    self.target(t).check_target(stage, compiler)\n+                }).collect()\n+            }\n+            Source::CheckTarget { stage, compiler } => {\n+                // CheckTarget here means run all possible test suites for this\n+                // target. Most of the time, however, we can't actually run\n+                // anything if we're not the build triple as we could be cross\n+                // compiling.\n+                //\n+                // As a result, the base set of targets here is quite stripped\n+                // down from the standard set of targets. These suites have\n+                // their own internal logic to run in cross-compiled situations\n+                // if they'll run at all. For example compiletest knows that\n+                // when testing Android targets we ship artifacts to the\n+                // emulator.\n+                //\n+                // When in doubt the rule of thumb for adding to this list is\n+                // \"should this test suite run on the android bot?\"\n+                let mut base = vec![\n                     self.check_rpass(compiler),\n-                    self.check_rpass_full(compiler),\n                     self.check_rfail(compiler),\n-                    self.check_rfail_full(compiler),\n-                    self.check_cfail(compiler),\n-                    self.check_cfail_full(compiler),\n-                    self.check_pfail(compiler),\n-                    self.check_incremental(compiler),\n-                    self.check_ui(compiler),\n                     self.check_crate_std(compiler),\n                     self.check_crate_test(compiler),\n-                    self.check_crate_rustc(compiler),\n-                    self.check_codegen(compiler),\n-                    self.check_codegen_units(compiler),\n                     self.check_debuginfo(compiler),\n-                    self.check_rustdoc(compiler),\n-                    self.check_pretty(compiler),\n-                    self.check_pretty_rpass(compiler),\n-                    self.check_pretty_rpass_full(compiler),\n-                    self.check_pretty_rfail(compiler),\n-                    self.check_pretty_rfail_full(compiler),\n-                    self.check_pretty_rpass_valgrind(compiler),\n-                    self.check_rpass_valgrind(compiler),\n-                    self.check_error_index(compiler),\n-                    self.check_docs(compiler),\n-                    self.check_rmake(compiler),\n-                    self.check_linkcheck(stage),\n-                    self.check_tidy(stage),\n                     self.dist(stage),\n-                ]\n+                ];\n+\n+                // If we're testing the build triple, then we know we can\n+                // actually run binaries and such, so we run all possible tests\n+                // that we know about.\n+                if self.target == build.config.build {\n+                    base.extend(vec![\n+                        // docs-related\n+                        self.check_docs(compiler),\n+                        self.check_error_index(compiler),\n+                        self.check_rustdoc(compiler),\n+\n+                        // UI-related\n+                        self.check_cfail(compiler),\n+                        self.check_pfail(compiler),\n+                        self.check_ui(compiler),\n+\n+                        // codegen-related\n+                        self.check_incremental(compiler),\n+                        self.check_codegen(compiler),\n+                        self.check_codegen_units(compiler),\n+\n+                        // misc compiletest-test suites\n+                        self.check_rpass_full(compiler),\n+                        self.check_rfail_full(compiler),\n+                        self.check_cfail_full(compiler),\n+                        self.check_pretty_rpass_full(compiler),\n+                        self.check_pretty_rfail_full(compiler),\n+                        self.check_rpass_valgrind(compiler),\n+                        self.check_rmake(compiler),\n+\n+                        // crates\n+                        self.check_crate_rustc(compiler),\n+\n+                        // pretty\n+                        self.check_pretty(compiler),\n+                        self.check_pretty_rpass(compiler),\n+                        self.check_pretty_rfail(compiler),\n+                        self.check_pretty_rpass_valgrind(compiler),\n+\n+                        // misc\n+                        self.check_linkcheck(stage),\n+                        self.check_tidy(stage),\n+                    ]);\n+                }\n+                return base\n             }\n             Source::CheckLinkcheck { stage } => {\n                 vec![self.tool_linkchecker(stage), self.doc(stage)]\n@@ -437,16 +484,20 @@ impl<'a> Step<'a> {\n             Source::CheckCFail { compiler } |\n             Source::CheckRPassValgrind { compiler } |\n             Source::CheckRPass { compiler } => {\n-                vec![\n+                let mut base = vec![\n                     self.libtest(compiler),\n-                    self.tool_compiletest(compiler.stage),\n+                    self.target(compiler.host).tool_compiletest(compiler.stage),\n                     self.test_helpers(()),\n-                ]\n+                ];\n+                if self.target.contains(\"android\") {\n+                    base.push(self.android_copy_libs(compiler));\n+                }\n+                base\n             }\n             Source::CheckDebuginfo { compiler } => {\n                 vec![\n                     self.libtest(compiler),\n-                    self.tool_compiletest(compiler.stage),\n+                    self.target(compiler.host).tool_compiletest(compiler.stage),\n                     self.test_helpers(()),\n                     self.debugger_scripts(compiler.stage),\n                 ]\n@@ -459,13 +510,14 @@ impl<'a> Step<'a> {\n             Source::CheckPrettyRPassValgrind { compiler } |\n             Source::CheckRMake { compiler } => {\n                 vec![self.librustc(compiler),\n-                     self.tool_compiletest(compiler.stage)]\n+                     self.target(compiler.host).tool_compiletest(compiler.stage)]\n             }\n             Source::CheckDocs { compiler } => {\n                 vec![self.libstd(compiler)]\n             }\n             Source::CheckErrorIndex { compiler } => {\n-                vec![self.libstd(compiler), self.tool_error_index(compiler.stage)]\n+                vec![self.libstd(compiler),\n+                     self.target(compiler.host).tool_error_index(compiler.stage)]\n             }\n             Source::CheckCrateStd { compiler } => {\n                 vec![self.libtest(compiler)]\n@@ -529,6 +581,10 @@ impl<'a> Step<'a> {\n                 }\n                 return base\n             }\n+\n+            Source::AndroidCopyLibs { compiler } => {\n+                vec![self.libtest(compiler)]\n+            }\n         }\n     }\n }"}, {"sha": "c657785d78b6e31f094536b736f7275289c0039a", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -25,6 +25,11 @@ all:\n clean:\n \t$(Q)$(BOOTSTRAP) --clean\n \n+rustc-stage1:\n+\t$(Q)$(BOOTSTRAP) --step libtest --stage 1\n+rustc-stage2:\n+\t$(Q)$(BOOTSTRAP) --step libtest --stage 2\n+\n docs: doc\n doc:\n \t$(Q)$(BOOTSTRAP) --step doc"}, {"sha": "462e50a72cc48738313b7695d4b25542c68c449c", "filename": "src/libstd/path.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -1057,7 +1057,6 @@ impl PathBuf {\n         self._push(path.as_ref())\n     }\n \n-    #[allow(deprecated)]\n     fn _push(&mut self, path: &Path) {\n         // in general, a separator is needed if the rightmost byte is not a separator\n         let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep_byte(*c)).unwrap_or(false);"}, {"sha": "e01bd2a93aacdfcb9b806a0af3e5960fdff47d12", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -34,6 +34,27 @@ thread_local! {\n     static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new())\n }\n \n+enum AttrError {\n+    MultipleItem(InternedString),\n+    UnknownMetaItem(InternedString),\n+    MissingSince,\n+    MissingFeature,\n+    MultipleStabilityLevels,\n+}\n+\n+fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n+    match error {\n+        AttrError::MultipleItem(item) => span_err!(diag, span, E0538,\n+                                                   \"multiple '{}' items\", item),\n+        AttrError::UnknownMetaItem(item) => span_err!(diag, span, E0541,\n+                                                      \"unknown meta item '{}'\", item),\n+        AttrError::MissingSince => span_err!(diag, span, E0542, \"missing 'since'\"),\n+        AttrError::MissingFeature => span_err!(diag, span, E0546, \"missing 'feature'\"),\n+        AttrError::MultipleStabilityLevels => span_err!(diag, span, E0544,\n+                                                        \"multiple stability levels\"),\n+    }\n+}\n+\n pub fn mark_used(attr: &Attribute) {\n     let AttrId(id) = attr.node.id;\n     USED_ATTRS.with(|slot| {\n@@ -303,10 +324,10 @@ pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Inte\n             if let s@Some(_) = attr.value_str() {\n                 s\n             } else {\n-                diag.struct_span_err(attr.span,\n-                                     \"export_name attribute has invalid format\")\n-                    .help(\"use #[export_name=\\\"*\\\"]\")\n-                    .emit();\n+                struct_span_err!(diag, attr.span, E0533,\n+                                 \"export_name attribute has invalid format\")\n+                                .help(\"use #[export_name=\\\"*\\\"]\")\n+                                .emit();\n                 None\n             }\n         } else {\n@@ -339,14 +360,16 @@ pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> In\n             MetaItemKind::List(ref n, ref items) if n == \"inline\" => {\n                 mark_used(attr);\n                 if items.len() != 1 {\n-                    diagnostic.map(|d|{ d.span_err(attr.span, \"expected one argument\"); });\n+                    diagnostic.map(|d|{ span_err!(d, attr.span, E0534, \"expected one argument\"); });\n                     InlineAttr::None\n                 } else if contains_name(&items[..], \"always\") {\n                     InlineAttr::Always\n                 } else if contains_name(&items[..], \"never\") {\n                     InlineAttr::Never\n                 } else {\n-                    diagnostic.map(|d|{ d.span_err((*items[0]).span, \"invalid argument\"); });\n+                    diagnostic.map(|d| {\n+                        span_err!(d, (*items[0]).span, E0535, \"invalid argument\");\n+                    });\n                     InlineAttr::None\n                 }\n             }\n@@ -374,13 +397,13 @@ pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n             mis.iter().all(|mi| cfg_matches(cfgs, &mi, sess, features)),\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n-                sess.span_diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n+                span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n                 return false;\n             }\n             !cfg_matches(cfgs, &mis[0], sess, features)\n         }\n         ast::MetaItemKind::List(ref pred, _) => {\n-            sess.span_diagnostic.span_err(cfg.span, &format!(\"invalid predicate `{}`\", pred));\n+            span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", pred);\n             false\n         },\n         ast::MetaItemKind::Word(_) | ast::MetaItemKind::NameValue(..) => {\n@@ -446,23 +469,23 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n         if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n                 if item.is_some() {\n-                    diagnostic.span_err(meta.span, &format!(\"multiple '{}' items\",\n-                                                             meta.name()));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n                     *item = Some(v);\n                     true\n                 } else {\n-                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                    span_err!(diagnostic, meta.span, E0539, \"incorrect meta item\");\n                     false\n                 }\n             };\n \n             match tag {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n-                        diagnostic.span_err(item_sp, \"multiple rustc_deprecated attributes\");\n+                        span_err!(diagnostic, item_sp, E0540,\n+                                  \"multiple rustc_deprecated attributes\");\n                         break\n                     }\n \n@@ -473,8 +496,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             \"since\" => if !get(meta, &mut since) { continue 'outer },\n                             \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n                             _ => {\n-                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                        meta.name()));\n+                                handle_errors(diagnostic, meta.span,\n+                                              AttrError::UnknownMetaItem(meta.name()));\n                                 continue 'outer\n                             }\n                         }\n@@ -488,18 +511,18 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _) => {\n-                            diagnostic.span_err(attr.span(), \"missing 'since'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n                             continue\n                         }\n                         _ => {\n-                            diagnostic.span_err(attr.span(), \"missing 'reason'\");\n+                            span_err!(diagnostic, attr.span(), E0543, \"missing 'reason'\");\n                             continue\n                         }\n                     }\n                 }\n                 \"unstable\" => {\n                     if stab.is_some() {\n-                        diagnostic.span_err(item_sp, \"multiple stability levels\");\n+                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n                         break\n                     }\n \n@@ -512,8 +535,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n                             \"issue\" => if !get(meta, &mut issue) { continue 'outer },\n                             _ => {\n-                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                        meta.name()));\n+                                handle_errors(diagnostic, meta.span,\n+                                              AttrError::UnknownMetaItem(meta.name()));\n                                 continue 'outer\n                             }\n                         }\n@@ -528,7 +551,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                         if let Ok(issue) = issue.parse() {\n                                             issue\n                                         } else {\n-                                            diagnostic.span_err(attr.span(), \"incorrect 'issue'\");\n+                                            span_err!(diagnostic, attr.span(), E0545,\n+                                                      \"incorrect 'issue'\");\n                                             continue\n                                         }\n                                     }\n@@ -538,18 +562,18 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _, _) => {\n-                            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n                             continue\n                         }\n                         _ => {\n-                            diagnostic.span_err(attr.span(), \"missing 'issue'\");\n+                            span_err!(diagnostic, attr.span(), E0547, \"missing 'issue'\");\n                             continue\n                         }\n                     }\n                 }\n                 \"stable\" => {\n                     if stab.is_some() {\n-                        diagnostic.span_err(item_sp, \"multiple stability levels\");\n+                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n                         break\n                     }\n \n@@ -560,8 +584,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             \"feature\" => if !get(meta, &mut feature) { continue 'outer },\n                             \"since\" => if !get(meta, &mut since) { continue 'outer },\n                             _ => {\n-                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                        meta.name()));\n+                                handle_errors(diagnostic, meta.span,\n+                                              AttrError::UnknownMetaItem(meta.name()));\n                                 continue 'outer\n                             }\n                         }\n@@ -578,19 +602,19 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _) => {\n-                            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n                             continue\n                         }\n                         _ => {\n-                            diagnostic.span_err(attr.span(), \"missing 'since'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n                             continue\n                         }\n                     }\n                 }\n                 _ => unreachable!()\n             }\n         } else {\n-            diagnostic.span_err(attr.span(), \"incorrect stability attribute type\");\n+            span_err!(diagnostic, attr.span(), E0548, \"incorrect stability attribute type\");\n             continue\n         }\n     }\n@@ -603,8 +627,9 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n             }\n             stab.rustc_depr = Some(rustc_depr);\n         } else {\n-            diagnostic.span_err(item_sp, \"rustc_deprecated attribute must be paired with \\\n-                                          either stable or unstable attribute\");\n+            span_err!(diagnostic, item_sp, E0549,\n+                      \"rustc_deprecated attribute must be paired with \\\n+                       either stable or unstable attribute\");\n         }\n     }\n \n@@ -627,22 +652,21 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         mark_used(attr);\n \n         if depr.is_some() {\n-            diagnostic.span_err(item_sp, \"multiple deprecated attributes\");\n+            span_err!(diagnostic, item_sp, E0550, \"multiple deprecated attributes\");\n             break\n         }\n \n         depr = if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n                 if item.is_some() {\n-                    diagnostic.span_err(meta.span, &format!(\"multiple '{}' items\",\n-                                                             meta.name()));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n                     *item = Some(v);\n                     true\n                 } else {\n-                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                    span_err!(diagnostic, meta.span, E0551, \"incorrect meta item\");\n                     false\n                 }\n             };\n@@ -654,8 +678,8 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n                     \"since\" => if !get(meta, &mut since) { continue 'outer },\n                     \"note\" => if !get(meta, &mut note) { continue 'outer },\n                     _ => {\n-                        diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                meta.name()));\n+                        handle_errors(diagnostic, meta.span,\n+                                      AttrError::UnknownMetaItem(meta.name()));\n                         continue 'outer\n                     }\n                 }\n@@ -689,7 +713,7 @@ pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n \n         if !set.insert(name.clone()) {\n             panic!(diagnostic.span_fatal(meta.span,\n-                                  &format!(\"duplicate meta item `{}`\", name)));\n+                                         &format!(\"duplicate meta item `{}`\", name)));\n         }\n     }\n }\n@@ -718,8 +742,8 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                                 Some(ity) => Some(ReprInt(item.span, ity)),\n                                 None => {\n                                     // Not a word we recognize\n-                                    diagnostic.span_err(item.span,\n-                                                        \"unrecognized representation hint\");\n+                                    span_err!(diagnostic, item.span, E0552,\n+                                              \"unrecognized representation hint\");\n                                     None\n                                 }\n                             }\n@@ -731,7 +755,8 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                         }\n                     }\n                     // Not a word:\n-                    _ => diagnostic.span_err(item.span, \"unrecognized enum representation hint\")\n+                    _ => span_err!(diagnostic, item.span, E0553,\n+                                   \"unrecognized enum representation hint\"),\n                 }\n             }\n         }"}, {"sha": "eb30657bd56ead7a804b8fd7b22c9c10fe6051ed", "filename": "src/libsyntax/diagnostic_list.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+// Error messages for EXXXX errors.\n+// Each message should start and end with a new line, and be wrapped to 80 characters.\n+// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n+register_long_diagnostics! {\n+\n+E0533: r##\"\n+```compile_fail,E0533\n+#[export_name]\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\"##,\n+\n+}\n+\n+register_diagnostics! {\n+    E0534, // expected one argument\n+    E0535, // invalid argument\n+    E0536, // expected 1 cfg-pattern\n+    E0537, // invalid predicate\n+    E0538, // multiple [same] items\n+    E0539, // incorrect meta item\n+    E0540, // multiple rustc_deprecated attributes\n+    E0541, // unknown meta item\n+    E0542, // missing 'since'\n+    E0543, // missing 'reason'\n+    E0544, // multiple stability levels\n+    E0545, // incorrect 'issue'\n+    E0546, // missing 'feature'\n+    E0547, // missing 'issue'\n+    E0548, // incorrect stability attribute type\n+    E0549, // rustc_deprecated attribute must be paired with either stable or unstable attribute\n+    E0550, // multiple deprecated attributes\n+    E0551, // incorrect meta item\n+    E0552, // unrecognized representation hint\n+    E0553, // unrecognized enum representation hint\n+    E0554, // #[feature] may not be used on the [] release channel\n+    E0555, // malformed feature attribute, expected #![feature(...)]\n+    E0556, // malformed feature, expected just one word\n+    E0557, // feature has been removed\n+}"}, {"sha": "27485ee65fcc037640e5309d2534d583e47e91da", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -1103,17 +1103,16 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n \n         match attr.meta_item_list() {\n             None => {\n-                span_handler.span_err(attr.span, \"malformed feature attribute, \\\n-                                                  expected #![feature(...)]\");\n+                span_err!(span_handler, attr.span, E0555,\n+                          \"malformed feature attribute, expected #![feature(...)]\");\n             }\n             Some(list) => {\n                 for mi in list {\n                     let name = match mi.node {\n                         ast::MetaItemKind::Word(ref word) => (*word).clone(),\n                         _ => {\n-                            span_handler.span_err(mi.span,\n-                                                  \"malformed feature, expected just \\\n-                                                   one word\");\n+                            span_err!(span_handler, mi.span, E0556,\n+                                      \"malformed feature, expected just one word\");\n                             continue\n                         }\n                     };\n@@ -1123,7 +1122,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n                     }\n                     else if let Some(&(_, _, _)) = REMOVED_FEATURES.iter()\n                         .find(|& &(n, _, _)| name == n) {\n-                        span_handler.span_err(mi.span, \"feature has been removed\");\n+                        span_err!(span_handler, mi.span, E0557, \"feature has been removed\");\n                     }\n                     else if let Some(&(_, _, _)) = ACCEPTED_FEATURES.iter()\n                         .find(|& &(n, _, _)| name == n) {\n@@ -1179,9 +1178,9 @@ fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,\n         for attr in &krate.attrs {\n             if attr.check_name(\"feature\") {\n                 let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n-                let ref msg = format!(\"#[feature] may not be used on the {} release channel\",\n-                                      release_channel);\n-                span_handler.span_err(attr.span, msg);\n+                span_err!(span_handler, attr.span, E0554,\n+                          \"#[feature] may not be used on the {} release channel\",\n+                          release_channel);\n             }\n         }\n     }"}, {"sha": "8febf1c49ec2badeb618ed632b4c661168da73d4", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -33,6 +33,7 @@\n #![feature(str_escape)]\n #![feature(unicode)]\n #![feature(question_mark)]\n+#![feature(rustc_diagnostic_macros)]\n \n extern crate serialize;\n extern crate term;\n@@ -66,6 +67,18 @@ macro_rules! panictry {\n     })\n }\n \n+#[macro_use]\n+pub mod diagnostics {\n+    #[macro_use]\n+    pub mod macros;\n+    pub mod plugin;\n+    pub mod metadata;\n+}\n+\n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostic_list;\n+\n pub mod util {\n     pub mod interner;\n     pub mod lev_distance;\n@@ -80,12 +93,6 @@ pub mod util {\n     pub use self::thin_vec::ThinVec;\n }\n \n-pub mod diagnostics {\n-    pub mod macros;\n-    pub mod plugin;\n-    pub mod metadata;\n-}\n-\n pub mod json;\n \n pub mod syntax {\n@@ -130,3 +137,5 @@ pub mod ext {\n         pub mod macro_rules;\n     }\n }\n+\n+// __build_diagnostic_array! { libsyntax, DIAGNOSTICS }"}, {"sha": "d35f2cbb584c767958051215f4ad1dc1e962ed9b", "filename": "src/test/compile-fail/stability-attribute-sanity.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -15,83 +15,84 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n mod bogus_attribute_types_1 {\n-    #[stable(feature = \"a\", since = \"a\", reason)] //~ ERROR unknown meta item 'reason'\n+    #[stable(feature = \"a\", since = \"a\", reason)] //~ ERROR unknown meta item 'reason' [E0541]\n     fn f1() { }\n \n-    #[stable(feature = \"a\", since)] //~ ERROR incorrect meta item\n+    #[stable(feature = \"a\", since)] //~ ERROR incorrect meta item [E0539]\n     fn f2() { }\n \n-    #[stable(feature, since = \"a\")] //~ ERROR incorrect meta item\n+    #[stable(feature, since = \"a\")] //~ ERROR incorrect meta item [E0539]\n     fn f3() { }\n \n-    #[stable(feature = \"a\", since(b))] //~ ERROR incorrect meta item\n+    #[stable(feature = \"a\", since(b))] //~ ERROR incorrect meta item [E0539]\n     fn f5() { }\n \n-    #[stable(feature(b), since = \"a\")] //~ ERROR incorrect meta item\n+    #[stable(feature(b), since = \"a\")] //~ ERROR incorrect meta item [E0539]\n     fn f6() { }\n }\n \n mod bogus_attribute_types_2 {\n-    #[unstable] //~ ERROR incorrect stability attribute type\n+    #[unstable] //~ ERROR incorrect stability attribute type [E0548]\n     fn f1() { }\n \n-    #[unstable = \"a\"] //~ ERROR incorrect stability attribute type\n+    #[unstable = \"a\"] //~ ERROR incorrect stability attribute type [E0548]\n     fn f2() { }\n \n-    #[stable] //~ ERROR incorrect stability attribute type\n+    #[stable] //~ ERROR incorrect stability attribute type [E0548]\n     fn f3() { }\n \n-    #[stable = \"a\"] //~ ERROR incorrect stability attribute type\n+    #[stable = \"a\"] //~ ERROR incorrect stability attribute type [E0548]\n     fn f4() { }\n \n     #[stable(feature = \"a\", since = \"b\")]\n-    #[rustc_deprecated] //~ ERROR incorrect stability attribute type\n+    #[rustc_deprecated] //~ ERROR incorrect stability attribute type [E0548]\n     fn f5() { }\n \n     #[stable(feature = \"a\", since = \"b\")]\n-    #[rustc_deprecated = \"a\"] //~ ERROR incorrect stability attribute type\n+    #[rustc_deprecated = \"a\"] //~ ERROR incorrect stability attribute type [E0548]\n     fn f6() { }\n }\n \n mod missing_feature_names {\n-    #[unstable(issue = \"0\")] //~ ERROR missing 'feature'\n+    #[unstable(issue = \"0\")] //~ ERROR missing 'feature' [E0546]\n     fn f1() { }\n \n-    #[unstable(feature = \"a\")] //~ ERROR missing 'issue'\n+    #[unstable(feature = \"a\")] //~ ERROR missing 'issue' [E0547]\n     fn f2() { }\n \n-    #[stable(since = \"a\")] //~ ERROR missing 'feature'\n+    #[stable(since = \"a\")] //~ ERROR missing 'feature' [E0546]\n     fn f3() { }\n }\n \n mod missing_version {\n-    #[stable(feature = \"a\")] //~ ERROR missing 'since'\n+    #[stable(feature = \"a\")] //~ ERROR missing 'since' [E0542]\n     fn f1() { }\n \n     #[stable(feature = \"a\", since = \"b\")]\n-    #[rustc_deprecated(reason = \"a\")] //~ ERROR missing 'since'\n+    #[rustc_deprecated(reason = \"a\")] //~ ERROR missing 'since' [E0542]\n     fn f2() { }\n }\n \n #[unstable(feature = \"a\", issue = \"0\")]\n-#[stable(feature = \"a\", since = \"b\")]\n-fn multiple1() { } //~ ERROR multiple stability levels\n+#[stable(feature = \"a\", since = \"b\")] //~ ERROR multiple stability levels [E0544]\n+fn multiple1() { }\n \n #[unstable(feature = \"a\", issue = \"0\")]\n-#[unstable(feature = \"a\", issue = \"0\")]\n-fn multiple2() { } //~ ERROR multiple stability levels\n+#[unstable(feature = \"a\", issue = \"0\")] //~ ERROR multiple stability levels [E0544]\n+fn multiple2() { }\n \n #[stable(feature = \"a\", since = \"b\")]\n-#[stable(feature = \"a\", since = \"b\")]\n-fn multiple3() { } //~ ERROR multiple stability levels\n+#[stable(feature = \"a\", since = \"b\")] //~ ERROR multiple stability levels [E0544]\n+fn multiple3() { }\n \n #[stable(feature = \"a\", since = \"b\")]\n #[rustc_deprecated(since = \"b\", reason = \"text\")]\n #[rustc_deprecated(since = \"b\", reason = \"text\")]\n-fn multiple4() { } //~ ERROR multiple rustc_deprecated attributes\n+fn multiple4() { } //~ ERROR multiple rustc_deprecated attributes [E0540]\n //~^ ERROR Invalid stability or deprecation version found\n \n #[rustc_deprecated(since = \"a\", reason = \"text\")]\n-fn deprecated_without_unstable_or_stable() { } //~ ERROR rustc_deprecated attribute must be paired\n+fn deprecated_without_unstable_or_stable() { }\n+//~^ ERROR rustc_deprecated attribute must be paired with either stable or unstable attribute\n \n fn main() { }"}, {"sha": "577da5c5af11d2b012eed6d4f860731c3050a452", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -1012,8 +1012,7 @@ actual:\\n\\\n \n         // Parse the JSON output from the compiler and extract out the messages.\n         let actual_errors = json::parse_output(&file_name, &proc_res.stderr, &proc_res);\n-        let mut unexpected = 0;\n-        let mut not_found = 0;\n+        let mut unexpected = Vec::new();\n         let mut found = vec![false; expected_errors.len()];\n         for actual_error in &actual_errors {\n             let opt_index =\n@@ -1045,12 +1044,13 @@ actual:\\n\\\n                                      .map_or(String::from(\"message\"),\n                                              |k| k.to_string()),\n                                      actual_error.msg));\n-                        unexpected += 1;\n+                        unexpected.push(actual_error.clone());\n                     }\n                 }\n             }\n         }\n \n+        let mut not_found = Vec::new();\n         // anything not yet found is a problem\n         for (index, expected_error) in expected_errors.iter().enumerate() {\n             if !found[index] {\n@@ -1062,18 +1062,22 @@ actual:\\n\\\n                              .map_or(\"message\".into(),\n                                      |k| k.to_string()),\n                              expected_error.msg));\n-                not_found += 1;\n+                not_found.push(expected_error.clone());\n             }\n         }\n \n-        if unexpected > 0 || not_found > 0 {\n+        if unexpected.len() > 0 || not_found.len() > 0 {\n             self.error(\n                 &format!(\"{} unexpected errors found, {} expected errors not found\",\n-                         unexpected, not_found));\n+                         unexpected.len(), not_found.len()));\n             print!(\"status: {}\\ncommand: {}\\n\",\n                    proc_res.status, proc_res.cmdline);\n-            println!(\"actual errors (from JSON output): {:#?}\\n\", actual_errors);\n-            println!(\"expected errors (from test file): {:#?}\\n\", expected_errors);\n+            if unexpected.len() > 0 {\n+                println!(\"unexpected errors (from JSON output): {:#?}\\n\", unexpected);\n+            }\n+            if not_found.len() > 0 {\n+                println!(\"not found errors (from test file): {:#?}\\n\", not_found);\n+            }\n             panic!();\n         }\n     }"}, {"sha": "80c37d5597592de4e873a4876f1b274219c8e837", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "patch": "@@ -138,22 +138,6 @@ fn check(cache: &mut Cache,\n         return None;\n     }\n \n-    if file.ends_with(\"std/sys/ext/index.html\") {\n-        return None;\n-    }\n-\n-    if let Some(file) = file.to_str() {\n-        // FIXME(#31948)\n-        if file.contains(\"ParseFloatError\") {\n-            return None;\n-        }\n-        // weird reexports, but this module is on its way out, so chalk it up to\n-        // \"rustdoc weirdness\" and move on from there\n-        if file.contains(\"scoped_tls\") {\n-            return None;\n-        }\n-    }\n-\n     let mut parser = UrlParser::new();\n     parser.base_url(base);\n \n@@ -170,12 +154,24 @@ fn check(cache: &mut Cache,\n \n     // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n     with_attrs_in_source(&contents, \" href\", |url, i| {\n+        // Ignore external URLs\n+        if url.starts_with(\"http:\") || url.starts_with(\"https:\") ||\n+           url.starts_with(\"javascript:\") || url.starts_with(\"ftp:\") ||\n+           url.starts_with(\"irc:\") || url.starts_with(\"data:\") {\n+            return;\n+        }\n         // Once we've plucked out the URL, parse it using our base url and\n-        // then try to extract a file path. If either of these fail then we\n-        // just keep going.\n+        // then try to extract a file path.\n         let (parsed_url, path) = match url_to_file_path(&parser, url) {\n             Some((url, path)) => (url, PathBuf::from(path)),\n-            None => return,\n+            None => {\n+                *errors = true;\n+                println!(\"{}:{}: invalid link - {}\",\n+                         pretty_file.display(),\n+                         i + 1,\n+                         url);\n+                return;\n+            }\n         };\n \n         // Alright, if we've found a file name then this file had better\n@@ -197,10 +193,11 @@ fn check(cache: &mut Cache,\n                 Ok(res) => res,\n                 Err(LoadError::IOError(err)) => panic!(format!(\"{}\", err)),\n                 Err(LoadError::BrokenRedirect(target, _)) => {\n-                    print!(\"{}:{}: broken redirect to {}\",\n-                           pretty_file.display(),\n-                           i + 1,\n-                           target.display());\n+                    *errors = true;\n+                    println!(\"{}:{}: broken redirect to {}\",\n+                             pretty_file.display(),\n+                             i + 1,\n+                             target.display());\n                     return;\n                 }\n                 Err(LoadError::IsRedirect) => unreachable!(),"}]}