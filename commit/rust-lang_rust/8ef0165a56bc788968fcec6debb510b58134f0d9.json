{"sha": "8ef0165a56bc788968fcec6debb510b58134f0d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZjAxNjVhNTZiYzc4ODk2OGZjZWM2ZGViYjUxMGI1ODEzNGYwZDk=", "commit": {"author": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-07-02T18:10:32Z"}, "committer": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-07-02T22:31:08Z"}, "message": "collections::bitv: clean up and unit test `BitvSet::is_subset`", "tree": {"sha": "0c50a05adbcb3a00f42850366c95bfdd6f52cd96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c50a05adbcb3a00f42850366c95bfdd6f52cd96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ef0165a56bc788968fcec6debb510b58134f0d9", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ef0165a56bc788968fcec6debb510b58134f0d9", "html_url": "https://github.com/rust-lang/rust/commit/8ef0165a56bc788968fcec6debb510b58134f0d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ef0165a56bc788968fcec6debb510b58134f0d9/comments", "author": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78b674152ed09f2e7f30f0080171b43e11f56f31", "url": "https://api.github.com/repos/rust-lang/rust/commits/78b674152ed09f2e7f30f0080171b43e11f56f31", "html_url": "https://github.com/rust-lang/rust/commit/78b674152ed09f2e7f30f0080171b43e11f56f31"}], "stats": {"total": 91, "additions": 36, "deletions": 55}, "files": [{"sha": "6d7c91ccfee775931a47c4d4afa8095d69a2cec0", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 36, "deletions": 55, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8ef0165a56bc788968fcec6debb510b58134f0d9/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef0165a56bc788968fcec6debb510b58134f0d9/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=8ef0165a56bc788968fcec6debb510b58134f0d9", "patch": "@@ -15,7 +15,7 @@ use core::prelude::*;\n use core::cmp;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{Map, Take, Zip};\n+use core::iter::Take;\n use core::ops;\n use core::slice;\n use core::uint;\n@@ -825,23 +825,16 @@ impl Set<uint> for BitvSet {\n         self.intersection(other).count() > 0\n     }\n \n+    #[inline]\n     fn is_subset(&self, other: &BitvSet) -> bool {\n-        for (_, w1, w2) in self.commons(other) {\n-            if w1 & w2 != w1 {\n-                return false;\n-            }\n-        }\n-        /* If anything is not ours, then everything is not ours so we're\n-           definitely a subset in that case. Otherwise if there's any stray\n-           ones that 'other' doesn't have, we're not a subset. */\n-        for (mine, _, w) in self.outliers(other) {\n-            if !mine {\n-                return true;\n-            } else if w != 0 {\n-                return false;\n-            }\n-        }\n-        return true;\n+        let &BitvSet(ref self_bitv) = self;\n+        let &BitvSet(ref other_bitv) = other;\n+\n+        // Check that `self` intersect `other` is self\n+        self_bitv.mask_words(0).zip(other_bitv.mask_words(0))\n+                               .all(|((_, w1), (_, w2))| w1 & w2 == w1) &&\n+        // Check that `self` setminus `other` is empty\n+        self_bitv.mask_words(other_bitv.storage.len()).all(|(_, w)| w == 0)\n     }\n \n     #[inline]\n@@ -883,44 +876,6 @@ impl MutableSet<uint> for BitvSet {\n     }\n }\n \n-impl BitvSet {\n-    /// Visits each of the words that the two bit vectors (`self` and `other`)\n-    /// both have in common. The three yielded arguments are (bit location,\n-    /// w1, w2) where the bit location is the number of bits offset so far,\n-    /// and w1/w2 are the words coming from the two vectors self, other.\n-    fn commons<'a>(&'a self, other: &'a BitvSet)\n-        -> Map<((uint, uint), (uint, uint)), (uint, uint, uint),\n-               Zip<MaskWords<'a>, MaskWords<'a>>> {\n-        let &BitvSet(ref self_bitv) = self;\n-        let &BitvSet(ref other_bitv) = other;\n-        self_bitv.mask_words(0).zip(other_bitv.mask_words(0))\n-            .map(|((i, w1), (_, w2))| (i * uint::BITS, w1, w2))\n-    }\n-\n-    /// Visits each word in `self` or `other` that extends beyond the other. This\n-    /// will only iterate through one of the vectors, and it only iterates\n-    /// over the portion that doesn't overlap with the other one.\n-    ///\n-    /// The yielded arguments are a `bool`, the bit offset, and a word. The `bool`\n-    /// is true if the word comes from `self`, and `false` if it comes from\n-    /// `other`.\n-    fn outliers<'a>(&'a self, other: &'a BitvSet)\n-        -> Map<(uint, uint), (bool, uint, uint), MaskWords<'a>> {\n-        let slen = self.capacity() / uint::BITS;\n-        let olen = other.capacity() / uint::BITS;\n-        let &BitvSet(ref self_bitv) = self;\n-        let &BitvSet(ref other_bitv) = other;\n-\n-        if olen < slen {\n-            self_bitv.mask_words(olen)\n-                .map(|(i, w)| (true, i * uint::BITS, w))\n-        } else {\n-            other_bitv.mask_words(slen)\n-                .map(|(i, w)| (false, i * uint::BITS, w))\n-        }\n-    }\n-}\n-\n pub struct BitPositions<'a> {\n     set: &'a BitvSet,\n     next_idx: uint\n@@ -1594,6 +1549,32 @@ mod tests {\n         assert_eq!(i, expected.len());\n     }\n \n+    #[test]\n+    fn test_bitv_set_subset() {\n+        let mut set1 = BitvSet::new();\n+        let mut set2 = BitvSet::new();\n+\n+        assert!(set1.is_subset(&set2)); //  {}  {}\n+        set2.insert(100);\n+        assert!(set1.is_subset(&set2)); //  {}  { 1 }\n+        set2.insert(200);\n+        assert!(set1.is_subset(&set2)); //  {}  { 1, 2 }\n+        set1.insert(200);\n+        assert!(set1.is_subset(&set2)); //  { 2 }  { 1, 2 }\n+        set1.insert(300);\n+        assert!(!set1.is_subset(&set2)); // { 2, 3 }  { 1, 2 }\n+        set2.insert(300);\n+        assert!(set1.is_subset(&set2)); // { 2, 3 }  { 1, 2, 3 }\n+        set2.insert(400);\n+        assert!(set1.is_subset(&set2)); // { 2, 3 }  { 1, 2, 3, 4 }\n+        set2.remove(&100);\n+        assert!(set1.is_subset(&set2)); // { 2, 3 }  { 2, 3, 4 }\n+        set2.remove(&300);\n+        assert!(!set1.is_subset(&set2)); // { 2, 3 }  { 2, 4 }\n+        set1.remove(&300);\n+        assert!(set1.is_subset(&set2)); // { 2 }  { 2, 4 }\n+    }\n+\n     #[test]\n     fn test_bitv_remove() {\n         let mut a = BitvSet::new();"}]}