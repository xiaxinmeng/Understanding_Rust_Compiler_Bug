{"sha": "ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "node_id": "C_kwDOAAsO6NoAKGZmODQzYWM5YWViMmZmZjlkYmZhZTgwZDA4MDFiMTZmNGY2NzZlNWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-14T08:16:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-14T08:16:58Z"}, "message": "Auto merge of #10350 - J-ZhengLi:issue_10272, r=xFrednet\n\nenhance [`ifs_same_cond`] to warn same immutable method calls as well\n\nfixes: #10272\n\n---\n\nchangelog: Enhancement: [`ifs_same_cond`]: Now also detects immutable method calls.\n[#10350](https://github.com/rust-lang/rust-clippy/pull/10350)\n<!-- changelog_checked -->", "tree": {"sha": "f186fc1cc9200aa4dadd93cb89526cd14e43635a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f186fc1cc9200aa4dadd93cb89526cd14e43635a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "html_url": "https://github.com/rust-lang/rust/commit/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "945e42fc1162f51b9ea859cc97cdd848ed1724f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/945e42fc1162f51b9ea859cc97cdd848ed1724f7", "html_url": "https://github.com/rust-lang/rust/commit/945e42fc1162f51b9ea859cc97cdd848ed1724f7"}, {"sha": "011bb463370aceee33d7f00a39d87ae8fc856a1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/011bb463370aceee33d7f00a39d87ae8fc856a1c", "html_url": "https://github.com/rust-lang/rust/commit/011bb463370aceee33d7f00a39d87ae8fc856a1c"}], "stats": {"total": 254, "additions": 196, "deletions": 58}, "files": [{"sha": "9ed6627b7413094be364db1e7c472cdbbfec87f7", "filename": "book/src/lint_configuration.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/book%2Fsrc%2Flint_configuration.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/book%2Fsrc%2Flint_configuration.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flint_configuration.md?ref=ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "patch": "@@ -519,6 +519,7 @@ for the generic parameters for determining interior mutability\n **Default Value:** `[\"bytes::Bytes\"]` (`Vec<String>`)\n \n * [mutable_key_type](https://rust-lang.github.io/rust-clippy/master/index.html#mutable_key_type)\n+* [ifs_same_cond](https://rust-lang.github.io/rust-clippy/master/index.html#ifs_same_cond)\n \n \n ### allow-mixed-uninlined-format-args"}, {"sha": "970f50049935ce1919804db5b7c3ad2d5c6aabc3", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "patch": "@@ -1,18 +1,20 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_then};\n use clippy_utils::source::{first_line_of_span, indent_of, reindent_multiline, snippet, snippet_opt};\n-use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::ty::{is_interior_mut_ty, needs_ordered_drop};\n use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{\n-    capture_local_usage, eq_expr_value, get_enclosing_block, hash_expr, hash_stmt, if_sequence, is_else_clause,\n-    is_lint_allowed, path_to_local, search_same, ContainsName, HirEqInterExpr, SpanlessEq,\n+    capture_local_usage, def_path_def_ids, eq_expr_value, find_binding_init, get_enclosing_block, hash_expr, hash_stmt,\n+    if_sequence, is_else_clause, is_lint_allowed, path_to_local, search_same, ContainsName, HirEqInterExpr, SpanlessEq,\n };\n use core::iter;\n use core::ops::ControlFlow;\n use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefIdSet;\n use rustc_hir::intravisit;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, HirIdSet, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_middle::query::Key;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::walk_chain;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{BytePos, Span, Symbol};\n@@ -159,18 +161,40 @@ declare_clippy_lint! {\n     \"`if` statement with shared code in all blocks\"\n }\n \n-declare_lint_pass!(CopyAndPaste => [\n+pub struct CopyAndPaste {\n+    ignore_interior_mutability: Vec<String>,\n+    ignored_ty_ids: DefIdSet,\n+}\n+\n+impl CopyAndPaste {\n+    pub fn new(ignore_interior_mutability: Vec<String>) -> Self {\n+        Self {\n+            ignore_interior_mutability,\n+            ignored_ty_ids: DefIdSet::new(),\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(CopyAndPaste => [\n     IFS_SAME_COND,\n     SAME_FUNCTIONS_IN_IF_CONDITION,\n     IF_SAME_THEN_ELSE,\n     BRANCHES_SHARING_CODE\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n+    fn check_crate(&mut self, cx: &LateContext<'tcx>) {\n+        for ignored_ty in &self.ignore_interior_mutability {\n+            let path: Vec<&str> = ignored_ty.split(\"::\").collect();\n+            for id in def_path_def_ids(cx, path.as_slice()) {\n+                self.ignored_ty_ids.insert(id);\n+            }\n+        }\n+    }\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if !expr.span.from_expansion() && matches!(expr.kind, ExprKind::If(..)) && !is_else_clause(cx.tcx, expr) {\n             let (conds, blocks) = if_sequence(expr);\n-            lint_same_cond(cx, &conds);\n+            lint_same_cond(cx, &conds, &self.ignored_ty_ids);\n             lint_same_fns_in_if_cond(cx, &conds);\n             let all_same =\n                 !is_lint_allowed(cx, IF_SAME_THEN_ELSE, expr.hir_id) && lint_if_same_then_else(cx, &conds, &blocks);\n@@ -547,9 +571,39 @@ fn check_for_warn_of_moved_symbol(cx: &LateContext<'_>, symbols: &[(HirId, Symbo\n     })\n }\n \n+fn method_caller_is_mutable(cx: &LateContext<'_>, caller_expr: &Expr<'_>, ignored_ty_ids: &DefIdSet) -> bool {\n+    let caller_ty = cx.typeck_results().expr_ty(caller_expr);\n+    // Check if given type has inner mutability and was not set to ignored by the configuration\n+    let is_inner_mut_ty = is_interior_mut_ty(cx, caller_ty)\n+        && !matches!(caller_ty.ty_adt_id(), Some(adt_id) if ignored_ty_ids.contains(&adt_id));\n+\n+    is_inner_mut_ty\n+        || caller_ty.is_mutable_ptr()\n+        // `find_binding_init` will return the binding iff its not mutable\n+        || path_to_local(caller_expr)\n+            .and_then(|hid| find_binding_init(cx, hid))\n+            .is_none()\n+}\n+\n /// Implementation of `IFS_SAME_COND`.\n-fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n-    for (i, j) in search_same(conds, |e| hash_expr(cx, e), |lhs, rhs| eq_expr_value(cx, lhs, rhs)) {\n+fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>], ignored_ty_ids: &DefIdSet) {\n+    for (i, j) in search_same(\n+        conds,\n+        |e| hash_expr(cx, e),\n+        |lhs, rhs| {\n+            // Ignore eq_expr side effects iff one of the expressin kind is a method call\n+            // and the caller is not a mutable, including inner mutable type.\n+            if let ExprKind::MethodCall(_, caller, _, _) = lhs.kind {\n+                if method_caller_is_mutable(cx, caller, ignored_ty_ids) {\n+                    false\n+                } else {\n+                    SpanlessEq::new(cx).eq_expr(lhs, rhs)\n+                }\n+            } else {\n+                eq_expr_value(cx, lhs, rhs)\n+            }\n+        },\n+    ) {\n         span_lint_and_note(\n             cx,\n             IFS_SAME_COND,"}, {"sha": "bde84686cc1b9a116e59931a4da56b283b6b575d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "patch": "@@ -656,7 +656,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(empty_enum::EmptyEnum));\n     store.register_late_pass(|_| Box::new(invalid_upcast_comparisons::InvalidUpcastComparisons));\n     store.register_late_pass(|_| Box::new(regex::Regex));\n-    store.register_late_pass(|_| Box::new(copies::CopyAndPaste));\n+    let ignore_interior_mutability = conf.ignore_interior_mutability.clone();\n+    store.register_late_pass(move |_| Box::new(copies::CopyAndPaste::new(ignore_interior_mutability.clone())));\n     store.register_late_pass(|_| Box::new(copy_iterator::CopyIterator));\n     store.register_late_pass(|_| Box::new(format::UselessFormat));\n     store.register_late_pass(|_| Box::new(swap::Swap));"}, {"sha": "309f67521a3b4f0323ee3c2f48e45ecfab0dfee1", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 13, "deletions": 47, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::is_interior_mut_ty;\n use clippy_utils::{def_path_def_ids, trait_ref_of_method};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::TypeVisitableExt;\n-use rustc_middle::ty::{Adt, Array, Ref, Slice, Tuple, Ty};\n+use rustc_middle::query::Key;\n+use rustc_middle::ty::{Adt, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n@@ -153,53 +154,18 @@ impl MutableKeyType {\n             let is_keyed_type = [sym::HashMap, sym::BTreeMap, sym::HashSet, sym::BTreeSet]\n                 .iter()\n                 .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did()));\n-            if is_keyed_type && self.is_interior_mutable_type(cx, substs.type_at(0)) {\n-                span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n+            if !is_keyed_type {\n+                return;\n             }\n-        }\n-    }\n \n-    /// Determines if a type contains interior mutability which would affect its implementation of\n-    /// [`Hash`] or [`Ord`].\n-    fn is_interior_mutable_type<'tcx>(&self, cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-        match *ty.kind() {\n-            Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || self.is_interior_mutable_type(cx, inner_ty),\n-            Slice(inner_ty) => self.is_interior_mutable_type(cx, inner_ty),\n-            Array(inner_ty, size) => {\n-                size.try_eval_target_usize(cx.tcx, cx.param_env)\n-                    .map_or(true, |u| u != 0)\n-                    && self.is_interior_mutable_type(cx, inner_ty)\n-            },\n-            Tuple(fields) => fields.iter().any(|ty| self.is_interior_mutable_type(cx, ty)),\n-            Adt(def, substs) => {\n-                // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n-                // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n-                // because they have no impl for `Hash` or `Ord`.\n-                let def_id = def.did();\n-                let is_std_collection = [\n-                    sym::Option,\n-                    sym::Result,\n-                    sym::LinkedList,\n-                    sym::Vec,\n-                    sym::VecDeque,\n-                    sym::BTreeMap,\n-                    sym::BTreeSet,\n-                    sym::Rc,\n-                    sym::Arc,\n-                ]\n-                .iter()\n-                .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def_id));\n-                let is_box = Some(def_id) == cx.tcx.lang_items().owned_box();\n-                if is_std_collection || is_box || self.ignore_mut_def_ids.contains(&def_id) {\n-                    // The type is mutable if any of its type parameters are\n-                    substs.types().any(|ty| self.is_interior_mutable_type(cx, ty))\n-                } else {\n-                    !ty.has_escaping_bound_vars()\n-                        && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                        && !ty.is_freeze(cx.tcx, cx.param_env)\n-                }\n-            },\n-            _ => false,\n+            let subst_ty = substs.type_at(0);\n+            // Determines if a type contains interior mutability which would affect its implementation of\n+            // [`Hash`] or [`Ord`].\n+            if is_interior_mut_ty(cx, subst_ty)\n+                && !matches!(subst_ty.ty_adt_id(), Some(adt_id) if self.ignore_mut_def_ids.contains(&adt_id))\n+            {\n+                span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n+            }\n         }\n     }\n }"}, {"sha": "8ba252425a3d0a5dcb49e0df076e2790617b98a0", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "patch": "@@ -437,7 +437,7 @@ define_Conf! {\n     ///\n     /// The maximum size of the `Err`-variant in a `Result` returned from a function\n     (large_error_threshold: u64 = 128),\n-    /// Lint: MUTABLE_KEY_TYPE.\n+    /// Lint: MUTABLE_KEY_TYPE, IFS_SAME_COND.\n     ///\n     /// A list of paths to types that should be treated like `Arc`, i.e. ignored but\n     /// for the generic parameters for determining interior mutability"}, {"sha": "f1c6f1dddd8a5d57f0627826cf495bdec23bc801", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "patch": "@@ -1121,3 +1121,47 @@ pub fn make_normalized_projection<'tcx>(\n     }\n     helper(tcx, param_env, make_projection(tcx, container_id, assoc_ty, substs)?)\n }\n+\n+/// Check if given type has inner mutability such as [`std::cell::Cell`] or [`std::cell::RefCell`]\n+/// etc.\n+pub fn is_interior_mut_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match *ty.kind() {\n+        ty::Ref(_, inner_ty, mutbl) => mutbl == Mutability::Mut || is_interior_mut_ty(cx, inner_ty),\n+        ty::Slice(inner_ty) => is_interior_mut_ty(cx, inner_ty),\n+        ty::Array(inner_ty, size) => {\n+            size.try_eval_target_usize(cx.tcx, cx.param_env)\n+                .map_or(true, |u| u != 0)\n+                && is_interior_mut_ty(cx, inner_ty)\n+        },\n+        ty::Tuple(fields) => fields.iter().any(|ty| is_interior_mut_ty(cx, ty)),\n+        ty::Adt(def, substs) => {\n+            // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n+            // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n+            // because they have no impl for `Hash` or `Ord`.\n+            let def_id = def.did();\n+            let is_std_collection = [\n+                sym::Option,\n+                sym::Result,\n+                sym::LinkedList,\n+                sym::Vec,\n+                sym::VecDeque,\n+                sym::BTreeMap,\n+                sym::BTreeSet,\n+                sym::Rc,\n+                sym::Arc,\n+            ]\n+            .iter()\n+            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def_id));\n+            let is_box = Some(def_id) == cx.tcx.lang_items().owned_box();\n+            if is_std_collection || is_box {\n+                // The type is mutable if any of its type parameters are\n+                substs.types().any(|ty| is_interior_mut_ty(cx, ty))\n+            } else {\n+                !ty.has_escaping_bound_vars()\n+                    && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n+                    && !ty.is_freeze(cx.tcx, cx.param_env)\n+            }\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "90a36ecd92022c69911f71162a5036ffc11c0492", "filename": "tests/ui-toml/ifs_same_cond/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/tests%2Fui-toml%2Fifs_same_cond%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/tests%2Fui-toml%2Fifs_same_cond%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fifs_same_cond%2Fclippy.toml?ref=ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "patch": "@@ -0,0 +1 @@\n+ignore-interior-mutability = [\"std::cell::Cell\"]"}, {"sha": "d623ac7e0200820de7ee1d5e62d02d91efaba023", "filename": "tests/ui-toml/ifs_same_cond/ifs_same_cond.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.rs?ref=ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "patch": "@@ -0,0 +1,18 @@\n+#![warn(clippy::ifs_same_cond)]\n+#![allow(clippy::if_same_then_else, clippy::comparison_chain)]\n+\n+fn main() {}\n+\n+fn issue10272() {\n+    use std::cell::Cell;\n+\n+    // Because the `ignore-interior-mutability` configuration\n+    // is set to ignore for `std::cell::Cell`, the following `get()` calls\n+    // should trigger warning\n+    let x = Cell::new(true);\n+    if x.get() {\n+    } else if !x.take() {\n+    } else if x.get() {\n+    } else {\n+    }\n+}"}, {"sha": "2841f62bc94ab1e10914223a7d7bfdf0533c4b17", "filename": "tests/ui-toml/ifs_same_cond/ifs_same_cond.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fifs_same_cond%2Fifs_same_cond.stderr?ref=ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "patch": "@@ -0,0 +1,15 @@\n+error: this `if` has the same condition as a previous `if`\n+  --> $DIR/ifs_same_cond.rs:15:15\n+   |\n+LL |     } else if x.get() {\n+   |               ^^^^^^^\n+   |\n+note: same as this\n+  --> $DIR/ifs_same_cond.rs:13:8\n+   |\n+LL |     if x.get() {\n+   |        ^^^^^^^\n+   = note: `-D clippy::ifs-same-cond` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "9ce9a87626a79f4cfaa0610a92f03a1472c5815f", "filename": "tests/ui/ifs_same_cond.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/tests%2Fui%2Fifs_same_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/tests%2Fui%2Fifs_same_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fifs_same_cond.rs?ref=ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "patch": "@@ -43,4 +43,30 @@ fn ifs_same_cond() {\n     }\n }\n \n+fn issue10272() {\n+    let a = String::from(\"ha\");\n+    if a.contains(\"ah\") {\n+    } else if a.contains(\"ah\") {\n+        // Trigger this lint\n+    } else if a.contains(\"ha\") {\n+    } else if a == \"wow\" {\n+    }\n+\n+    let p: *mut i8 = std::ptr::null_mut();\n+    if p.is_null() {\n+    } else if p.align_offset(0) == 0 {\n+    } else if p.is_null() {\n+        // ok, p is mutable pointer\n+    } else {\n+    }\n+\n+    let x = std::cell::Cell::new(true);\n+    if x.get() {\n+    } else if !x.take() {\n+    } else if x.get() {\n+        // ok, x is interior mutable type\n+    } else {\n+    }\n+}\n+\n fn main() {}"}, {"sha": "9519f6904cb1ebf913631f26f7fb0a9203cc96a9", "filename": "tests/ui/ifs_same_cond.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/tests%2Fui%2Fifs_same_cond.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e/tests%2Fui%2Fifs_same_cond.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fifs_same_cond.stderr?ref=ff843ac9aeb2fff9dbfae80d0801b16f4f676e5e", "patch": "@@ -35,5 +35,17 @@ note: same as this\n LL |     if 2 * a == 1 {\n    |        ^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: this `if` has the same condition as a previous `if`\n+  --> $DIR/ifs_same_cond.rs:49:15\n+   |\n+LL |     } else if a.contains(\"ah\") {\n+   |               ^^^^^^^^^^^^^^^^\n+   |\n+note: same as this\n+  --> $DIR/ifs_same_cond.rs:48:8\n+   |\n+LL |     if a.contains(\"ah\") {\n+   |        ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n "}]}