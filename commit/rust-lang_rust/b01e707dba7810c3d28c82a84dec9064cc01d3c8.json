{"sha": "b01e707dba7810c3d28c82a84dec9064cc01d3c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMWU3MDdkYmE3ODEwYzNkMjhjODJhODRkZWM5MDY0Y2MwMWQzYzg=", "commit": {"author": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2018-12-31T13:30:37Z"}, "committer": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2019-01-01T08:09:32Z"}, "message": "doc parser input", "tree": {"sha": "ba077a6b5d135c3cf2b4c996db4a6a48b9a60463", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba077a6b5d135c3cf2b4c996db4a6a48b9a60463"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b01e707dba7810c3d28c82a84dec9064cc01d3c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b01e707dba7810c3d28c82a84dec9064cc01d3c8", "html_url": "https://github.com/rust-lang/rust/commit/b01e707dba7810c3d28c82a84dec9064cc01d3c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b01e707dba7810c3d28c82a84dec9064cc01d3c8/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea7b569e1b133b6c19ef60c9cb2b2fd6b79847da", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea7b569e1b133b6c19ef60c9cb2b2fd6b79847da", "html_url": "https://github.com/rust-lang/rust/commit/ea7b569e1b133b6c19ef60c9cb2b2fd6b79847da"}], "stats": {"total": 40, "additions": 30, "deletions": 10}, "files": [{"sha": "ce321aecb3717b5b48ed2a5bbde36ec019859d6f", "filename": "crates/ra_syntax/src/parser_impl.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b01e707dba7810c3d28c82a84dec9064cc01d3c8/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01e707dba7810c3d28c82a84dec9064cc01d3c8/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs?ref=b01e707dba7810c3d28c82a84dec9064cc01d3c8", "patch": "@@ -64,7 +64,6 @@ pub(crate) fn parse_with<S: Sink>(\n /// the public API of the `Parser`.\n pub(crate) struct ParserImpl<'t> {\n     inp: &'t ParserInput<'t>,\n-\n     pos: InputPosition,\n     events: Vec<Event>,\n     steps: Cell<u32>,\n@@ -74,7 +73,6 @@ impl<'t> ParserImpl<'t> {\n     pub(crate) fn new(inp: &'t ParserInput<'t>) -> ParserImpl<'t> {\n         ParserImpl {\n             inp,\n-\n             pos: InputPosition::new(),\n             events: Vec::new(),\n             steps: Cell::new(0),\n@@ -89,7 +87,9 @@ impl<'t> ParserImpl<'t> {\n     pub(super) fn next2(&self) -> Option<(SyntaxKind, SyntaxKind)> {\n         let c1 = self.inp.kind(self.pos);\n         let c2 = self.inp.kind(self.pos + 1);\n-        if self.inp.start(self.pos + 1) == self.inp.start(self.pos) + self.inp.len(self.pos) {\n+        if self.inp.token_start_at(self.pos + 1)\n+            == self.inp.token_start_at(self.pos) + self.inp.len(self.pos)\n+        {\n             Some((c1, c2))\n         } else {\n             None\n@@ -100,9 +100,10 @@ impl<'t> ParserImpl<'t> {\n         let c1 = self.inp.kind(self.pos);\n         let c2 = self.inp.kind(self.pos + 1);\n         let c3 = self.inp.kind(self.pos + 2);\n-        if self.inp.start(self.pos + 1) == self.inp.start(self.pos) + self.inp.len(self.pos)\n-            && self.inp.start(self.pos + 2)\n-                == self.inp.start(self.pos + 1) + self.inp.len(self.pos + 1)\n+        if self.inp.token_start_at(self.pos + 1)\n+            == self.inp.token_start_at(self.pos) + self.inp.len(self.pos)\n+            && self.inp.token_start_at(self.pos + 2)\n+                == self.inp.token_start_at(self.pos + 1) + self.inp.len(self.pos + 1)\n         {\n             Some((c1, c2, c3))\n         } else {"}, {"sha": "083a7aa152c53f9c3fba4bc481b2519f8c47b8e0", "filename": "crates/ra_syntax/src/parser_impl/input.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b01e707dba7810c3d28c82a84dec9064cc01d3c8/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01e707dba7810c3d28c82a84dec9064cc01d3c8/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs?ref=b01e707dba7810c3d28c82a84dec9064cc01d3c8", "patch": "@@ -4,11 +4,26 @@ use std::ops::{Add, AddAssign};\n \n pub(crate) struct ParserInput<'t> {\n     text: &'t str,\n+    /// start position of each token(expect whitespace and comment)\n+    /// ```non-rust\n+    ///  struct Foo;\n+    /// ^------^---\n+    /// |      |  ^-\n+    /// 0      7  10\n+    /// ```\n+    /// (token, start_offset): `[(struct, 0), (Foo, 7), (;, 10)]`\n     start_offsets: Vec<TextUnit>,\n-    tokens: Vec<Token>, // non-whitespace tokens\n+    /// non-whitespace/comment tokens\n+    /// ```non-rust\n+    /// struct Foo {}\n+    /// ^^^^^^ ^^^ ^^\n+    /// ```\n+    /// tokens: `[struct, Foo, {, }]`\n+    tokens: Vec<Token>,\n }\n \n impl<'t> ParserInput<'t> {\n+    /// Generate input from tokens(expect comment and whitespace).\n     pub fn new(text: &'t str, raw_tokens: &'t [Token]) -> ParserInput<'t> {\n         let mut tokens = Vec::new();\n         let mut start_offsets = Vec::new();\n@@ -28,6 +43,7 @@ impl<'t> ParserInput<'t> {\n         }\n     }\n \n+    /// Get the syntax kind of token at given input position.\n     pub fn kind(&self, pos: InputPosition) -> SyntaxKind {\n         let idx = pos.0 as usize;\n         if !(idx < self.tokens.len()) {\n@@ -36,23 +52,26 @@ impl<'t> ParserInput<'t> {\n         self.tokens[idx].kind\n     }\n \n-    pub fn len(&self, pos: InputPosition) -> TextUnit {\n+    /// Get the length of a token at given input position.\n+    pub fn token_len(&self, pos: InputPosition) -> TextUnit {\n         let idx = pos.0 as usize;\n         if !(idx < self.tokens.len()) {\n             return 0.into();\n         }\n         self.tokens[idx].len\n     }\n \n-    pub fn start(&self, pos: InputPosition) -> TextUnit {\n+    /// Get the start position of a taken at given input position.\n+    pub fn token_start_at(&self, pos: InputPosition) -> TextUnit {\n         let idx = pos.0 as usize;\n         if !(idx < self.tokens.len()) {\n             return 0.into();\n         }\n         self.start_offsets[idx]\n     }\n \n-    pub fn text(&self, pos: InputPosition) -> &'t str {\n+    /// Get the raw text of a toen at given input position.\n+    pub fn token_text(&self, pos: InputPosition) -> &'t str {\n         let idx = pos.0 as usize;\n         if !(idx < self.tokens.len()) {\n             return \"\";"}]}