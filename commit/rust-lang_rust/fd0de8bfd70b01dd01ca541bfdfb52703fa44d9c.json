{"sha": "fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMGRlOGJmZDcwYjAxZGQwMWNhNTQxYmZkZmI1MjcwM2ZhNDRkOWM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-22T22:33:50Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-22T22:34:01Z"}, "message": "doc: Split out task tutorail. Add links to sub-tutorials", "tree": {"sha": "62e7e2e37a386a71bebca0464350b47f75f20d57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62e7e2e37a386a71bebca0464350b47f75f20d57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c", "html_url": "https://github.com/rust-lang/rust/commit/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6caafaa9ea44d404733af6f9a907b6295dccc966", "url": "https://api.github.com/repos/rust-lang/rust/commits/6caafaa9ea44d404733af6f9a907b6295dccc966", "html_url": "https://github.com/rust-lang/rust/commit/6caafaa9ea44d404733af6f9a907b6295dccc966"}], "stats": {"total": 488, "additions": 237, "deletions": 251}, "files": [{"sha": "9f3ecddefe13f1d79eaa250cac9c80caae602fd8", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c/configure", "raw_url": "https://github.com/rust-lang/rust/raw/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c", "patch": "@@ -508,6 +508,7 @@ do\n     make_dir $h/test/doc-tutorial-ffi\n     make_dir $h/test/doc-tutorial-macros\n     make_dir $h/test/doc-tutorial-borrowed-ptr\n+    make_dir $h/test/doc-tutorial-tasks\n     make_dir $h/test/doc-ref\n done\n "}, {"sha": "2f540ef9ee6d68c62fd9e6c8a30899ffe73a2069", "filename": "doc/tutorial-tasks.md", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c", "patch": "@@ -0,0 +1,173 @@\n+% Tasks and communication in Rust\n+\n+Rust supports a system of lightweight tasks, similar to what is found\n+in Erlang or other actor systems. Rust tasks communicate via messages\n+and do not share data. However, it is possible to send data without\n+copying it by making use of [the exchange heap](#unique-boxes), which\n+allow the sending task to release ownership of a value, so that the\n+receiving task can keep on using it.\n+\n+> ***Note:*** As Rust evolves, we expect the task API to grow and\n+> change somewhat.  The tutorial documents the API as it exists today.\n+\n+# Spawning a task\n+\n+Spawning a task is done using the various spawn functions in the\n+module `task`.  Let's begin with the simplest one, `task::spawn()`:\n+\n+~~~~\n+use task::spawn;\n+use io::println;\n+\n+let some_value = 22;\n+\n+do spawn {\n+    println(~\"This executes in the child task.\");\n+    println(fmt!(\"%d\", some_value));\n+}\n+~~~~\n+\n+The argument to `task::spawn()` is a [unique\n+closure](#unique-closures) of type `fn~()`, meaning that it takes no\n+arguments and generates no return value. The effect of `task::spawn()`\n+is to fire up a child task that will execute the closure in parallel\n+with the creator.\n+\n+# Communication\n+\n+Now that we have spawned a child task, it would be nice if we could\n+communicate with it. This is done using *pipes*. Pipes are simply a\n+pair of endpoints, with one for sending messages and another for\n+receiving messages. The easiest way to create a pipe is to use\n+`pipes::stream`.  Imagine we wish to perform two expensive\n+computations in parallel.  We might write something like:\n+\n+~~~~\n+use task::spawn;\n+use pipes::{stream, Port, Chan};\n+\n+let (chan, port) = stream();\n+\n+do spawn {\n+    let result = some_expensive_computation();\n+    chan.send(result);\n+}\n+\n+some_other_expensive_computation();\n+let result = port.recv();\n+\n+# fn some_expensive_computation() -> int { 42 }\n+# fn some_other_expensive_computation() {}\n+~~~~\n+\n+Let's walk through this code line-by-line.  The first line creates a\n+stream for sending and receiving integers:\n+\n+~~~~ {.ignore}\n+# use pipes::stream;\n+let (chan, port) = stream();\n+~~~~\n+\n+This port is where we will receive the message from the child task\n+once it is complete.  The channel will be used by the child to send a\n+message to the port.  The next statement actually spawns the child:\n+\n+~~~~\n+# use task::{spawn};\n+# use comm::{Port, Chan};\n+# fn some_expensive_computation() -> int { 42 }\n+# let port = Port();\n+# let chan = port.chan();\n+do spawn {\n+    let result = some_expensive_computation();\n+    chan.send(result);\n+}\n+~~~~\n+\n+This child will perform the expensive computation send the result\n+over the channel.  (Under the hood, `chan` was captured by the\n+closure that forms the body of the child task.  This capture is\n+allowed because channels are sendable.)\n+\n+Finally, the parent continues by performing\n+some other expensive computation and then waiting for the child's result\n+to arrive on the port:\n+\n+~~~~\n+# use pipes::{stream, Port, Chan};\n+# fn some_other_expensive_computation() {}\n+# let (chan, port) = stream::<int>();\n+# chan.send(0);\n+some_other_expensive_computation();\n+let result = port.recv();\n+~~~~\n+\n+# Creating a task with a bi-directional communication path\n+\n+A very common thing to do is to spawn a child task where the parent\n+and child both need to exchange messages with each other. The\n+function `std::comm::DuplexStream()` supports this pattern.  We'll\n+look briefly at how it is used.\n+\n+To see how `spawn_conversation()` works, we will create a child task\n+that receives `uint` messages, converts them to a string, and sends\n+the string in response.  The child terminates when `0` is received.\n+Here is the function that implements the child task:\n+\n+~~~~\n+# use std::comm::DuplexStream;\n+# use pipes::{Port, Chan};\n+fn stringifier(channel: &DuplexStream<~str, uint>) {\n+    let mut value: uint;\n+    loop {\n+        value = channel.recv();\n+        channel.send(uint::to_str(value, 10u));\n+        if value == 0u { break; }\n+    }\n+}\n+~~~~\n+\n+The implementation of `DuplexStream` supports both sending and\n+receiving. The `stringifier` function takes a `DuplexStream` that can\n+send strings (the first type parameter) and receive `uint` messages\n+(the second type parameter). The body itself simply loops, reading\n+from the channel and then sending its response back.  The actual\n+response itself is simply the strified version of the received value,\n+`uint::to_str(value)`.\n+\n+Here is the code for the parent task:\n+\n+~~~~\n+# use std::comm::DuplexStream;\n+# use pipes::{Port, Chan};\n+# use task::spawn;\n+# fn stringifier(channel: &DuplexStream<~str, uint>) {\n+#     let mut value: uint;\n+#     loop {\n+#         value = channel.recv();\n+#         channel.send(uint::to_str(value, 10u));\n+#         if value == 0u { break; }\n+#     }\n+# }\n+# fn main() {\n+\n+let (from_child, to_child) = DuplexStream();\n+\n+do spawn || {\n+    stringifier(&to_child);\n+};\n+\n+from_child.send(22u);\n+assert from_child.recv() == ~\"22\";\n+\n+from_child.send(23u);\n+from_child.send(0u);\n+\n+assert from_child.recv() == ~\"23\";\n+assert from_child.recv() == ~\"0\";\n+\n+# }\n+~~~~\n+\n+The parent task first calls `DuplexStream` to create a pair of bidirectional endpoints. It then uses `task::spawn` to create the child task, which captures one end of the communication channel.  As a result, both parent\n+and child can send and receive data to and from the other."}, {"sha": "f97fbbed1961cfc9342468ab4504fac02ba6f3e9", "filename": "doc/tutorial.md", "status": "modified", "additions": 26, "deletions": 251, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c", "patch": "@@ -7,9 +7,11 @@\n This is a tutorial for the Rust programming language. It assumes the\n reader is familiar with the basic concepts of programming, and has\n programmed in one or more other languages before. It will often make\n-comparisons to other languages in the C family. The tutorial covers\n-the whole language, though not with the depth and precision of the\n-[language reference](rust.html).\n+comparisons to other languages in the C family. This tutorial covers\n+the fundamentals of the language, including the syntax, the type\n+system and memory model, and generics.\n+[Additional tutorials](#what-next) cover specific language features in\n+greater depth.\n \n ## Language overview\n \n@@ -2078,257 +2080,30 @@ This makes it possible to rebind a variable without actually mutating\n it, which is mostly useful for destructuring (which can rebind, but\n not assign).\n \n-# Tasks\n+# What next?\n \n-Rust supports a system of lightweight tasks, similar to what is found\n-in Erlang or other actor systems. Rust tasks communicate via messages\n-and do not share data. However, it is possible to send data without\n-copying it by making use of [the exchange heap](#unique-boxes), which\n-allow the sending task to release ownership of a value, so that the\n-receiving task can keep on using it.\n+Now that you know the essentials, check out any of the additional\n+tutorials on individual topics.\n \n-> ***Note:*** As Rust evolves, we expect the task API to grow and\n-> change somewhat.  The tutorial documents the API as it exists today.\n+* [Borrowed pointers][borrow]\n+* [Tasks and communication][tasks]\n+* [Macros][macros]\n+* [The foreign function interface][ffi]\n \n-## Spawning a task\n+There is further documentation on the [wiki], including articles about\n+[unit testing] in Rust, [documenting][rustdoc] and [packaging][cargo]\n+Rust code, and a discussion of the [attributes] used to apply metada\n+to code.\n \n-Spawning a task is done using the various spawn functions in the\n-module `task`.  Let's begin with the simplest one, `task::spawn()`:\n+[borrow]: tutorial-borrowed-ptr.html\n+[tasks]: tutorial-tasks.html\n+[macros]: tutorial-macros.html\n+[ffi]: tutorial-ffi.html\n \n-~~~~\n-use task::spawn;\n-use io::println;\n-\n-let some_value = 22;\n-\n-do spawn {\n-    println(~\"This executes in the child task.\");\n-    println(fmt!(\"%d\", some_value));\n-}\n-~~~~\n-\n-The argument to `task::spawn()` is a [unique\n-closure](#unique-closures) of type `fn~()`, meaning that it takes no\n-arguments and generates no return value. The effect of `task::spawn()`\n-is to fire up a child task that will execute the closure in parallel\n-with the creator.\n-\n-## Communication\n-\n-Now that we have spawned a child task, it would be nice if we could\n-communicate with it. This is done using *pipes*. Pipes are simply a\n-pair of endpoints, with one for sending messages and another for\n-receiving messages. The easiest way to create a pipe is to use\n-`pipes::stream`.  Imagine we wish to perform two expensive\n-computations in parallel.  We might write something like:\n-\n-~~~~\n-use task::spawn;\n-use pipes::{stream, Port, Chan};\n-\n-let (chan, port) = stream();\n-\n-do spawn {\n-    let result = some_expensive_computation();\n-    chan.send(result);\n-}\n-\n-some_other_expensive_computation();\n-let result = port.recv();\n-\n-# fn some_expensive_computation() -> int { 42 }\n-# fn some_other_expensive_computation() {}\n-~~~~\n-\n-Let's walk through this code line-by-line.  The first line creates a\n-stream for sending and receiving integers:\n-\n-~~~~ {.ignore}\n-# use pipes::stream;\n-let (chan, port) = stream();\n-~~~~\n-\n-This port is where we will receive the message from the child task\n-once it is complete.  The channel will be used by the child to send a\n-message to the port.  The next statement actually spawns the child:\n-\n-~~~~\n-# use task::{spawn};\n-# use comm::{Port, Chan};\n-# fn some_expensive_computation() -> int { 42 }\n-# let port = Port();\n-# let chan = port.chan();\n-do spawn {\n-    let result = some_expensive_computation();\n-    chan.send(result);\n-}\n-~~~~\n-\n-This child will perform the expensive computation send the result\n-over the channel.  (Under the hood, `chan` was captured by the\n-closure that forms the body of the child task.  This capture is\n-allowed because channels are sendable.)\n-\n-Finally, the parent continues by performing\n-some other expensive computation and then waiting for the child's result\n-to arrive on the port:\n-\n-~~~~\n-# use pipes::{stream, Port, Chan};\n-# fn some_other_expensive_computation() {}\n-# let (chan, port) = stream::<int>();\n-# chan.send(0);\n-some_other_expensive_computation();\n-let result = port.recv();\n-~~~~\n-\n-## Creating a task with a bi-directional communication path\n-\n-A very common thing to do is to spawn a child task where the parent\n-and child both need to exchange messages with each other. The\n-function `std::comm::DuplexStream()` supports this pattern.  We'll\n-look briefly at how it is used.\n-\n-To see how `spawn_conversation()` works, we will create a child task\n-that receives `uint` messages, converts them to a string, and sends\n-the string in response.  The child terminates when `0` is received.\n-Here is the function that implements the child task:\n-\n-~~~~\n-# use std::comm::DuplexStream;\n-# use pipes::{Port, Chan};\n-fn stringifier(channel: &DuplexStream<~str, uint>) {\n-    let mut value: uint;\n-    loop {\n-        value = channel.recv();\n-        channel.send(uint::to_str(value, 10u));\n-        if value == 0u { break; }\n-    }\n-}\n-~~~~\n-\n-The implementation of `DuplexStream` supports both sending and\n-receiving. The `stringifier` function takes a `DuplexStream` that can\n-send strings (the first type parameter) and receive `uint` messages\n-(the second type parameter). The body itself simply loops, reading\n-from the channel and then sending its response back.  The actual\n-response itself is simply the strified version of the received value,\n-`uint::to_str(value)`.\n-\n-Here is the code for the parent task:\n-\n-~~~~\n-# use std::comm::DuplexStream;\n-# use pipes::{Port, Chan};\n-# use task::spawn;\n-# fn stringifier(channel: &DuplexStream<~str, uint>) {\n-#     let mut value: uint;\n-#     loop {\n-#         value = channel.recv();\n-#         channel.send(uint::to_str(value, 10u));\n-#         if value == 0u { break; }\n-#     }\n-# }\n-# fn main() {\n-\n-let (from_child, to_child) = DuplexStream();\n-\n-do spawn || {\n-    stringifier(&to_child);\n-};\n-\n-from_child.send(22u);\n-assert from_child.recv() == ~\"22\";\n-\n-from_child.send(23u);\n-from_child.send(0u);\n-\n-assert from_child.recv() == ~\"23\";\n-assert from_child.recv() == ~\"0\";\n-\n-# }\n-~~~~\n-\n-The parent task first calls `DuplexStream` to create a pair of bidirectional endpoints. It then uses `task::spawn` to create the child task, which captures one end of the communication channel.  As a result, both parent\n-and child can send and receive data to and from the other.\n-\n-# Testing\n-\n-The Rust language has a facility for testing built into the language.\n-Tests can be interspersed with other code, and annotated with the\n-`#[test]` attribute.\n-\n-~~~~{.xfail-test}\n-# // FIXME: xfailed because test_twice is a #[test] function it's not\n-# // getting compiled\n-extern mod std;\n-\n-fn twice(x: int) -> int { x + x }\n-\n-#[test]\n-fn test_twice() {\n-    let mut i = -100;\n-    while i < 100 {\n-        assert twice(i) == 2 * i;\n-        i += 1;\n-    }\n-}\n-~~~~\n-\n-When you compile the program normally, the `test_twice` function will\n-not be included. To compile and run such tests, compile with the\n-`--test` flag, and then run the result:\n-\n-~~~~ {.notrust}\n-> rustc --test twice.rs\n-> ./twice\n-running 1 tests\n-test test_twice ... ok\n-result: ok. 1 passed; 0 failed; 0 ignored\n-~~~~\n-\n-Or, if we change the file to fail, for example by replacing `x + x`\n-with `x + 1`:\n-\n-~~~~ {.notrust}\n-running 1 tests\n-test test_twice ... FAILED\n-failures:\n-    test_twice\n-result: FAILED. 0 passed; 1 failed; 0 ignored\n-~~~~\n-\n-You can pass a command-line argument to a program compiled with\n-`--test` to run only the tests whose name matches the given string. If\n-we had, for example, test functions `test_twice`, `test_once_1`, and\n-`test_once_2`, running our program with `./twice test_once` would run\n-the latter two, and running it with `./twice test_once_2` would run\n-only the last.\n-\n-To indicate that a test is supposed to fail instead of pass, you can\n-give it a `#[should_fail]` attribute.\n-\n-~~~~\n-extern mod std;\n-\n-fn divide(a: float, b: float) -> float {\n-    if b == 0f { fail; }\n-    a / b\n-}\n-\n-#[test]\n-#[should_fail]\n-fn divide_by_zero() { divide(1f, 0f); }\n-\n-# fn main() { }\n-~~~~\n-\n-To disable a test completely, add an `#[ignore]` attribute. Running a\n-test runner (the program compiled with `--test`) with an `--ignored`\n-command-line flag will cause it to also run the tests labelled as\n-ignored.\n+[wiki]: https://github.com/mozilla/rust/wiki/Docs\n+[unit testing]: https://github.com/mozilla/rust/wiki/Doc-unit-testing\n+[rustdoc]: https://github.com/mozilla/rust/wiki/Doc-using-rustdoc\n+[cargo]: https://github.com/mozilla/rust/wiki/Doc-using-cargo-to-manage-packages\n+[attributes]: https://github.com/mozilla/rust/wiki/Doc-attributes\n \n-A program compiled as a test runner will have the configuration flag\n-`test` defined, so that you can add code that won't be included in a\n-normal compile with the `#[cfg(test)]` attribute (for a full explanation\n-of attributes, see the [language reference](rust.html)).\n+[pound-rust]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust"}, {"sha": "9b2f00923c7a8f3b32bb45c636508c5419d80bf1", "filename": "mk/docs.mk", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c", "patch": "@@ -113,6 +113,16 @@ doc/tutorial-borrowed-ptr.html: tutorial-borrowed-ptr.md doc/version_info.html d\n \t   --include-before-body=doc/version_info.html \\\n            --output=$@\n \n+DOCS += doc/tutorial-tasks.html\n+doc/tutorial-tasks.html: tutorial-tasks.md doc/version_info.html doc/rust.css\n+\t@$(call E, pandoc: $@)\n+\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n+          $(CFG_PANDOC) --standalone --toc \\\n+           --section-divs --number-sections \\\n+           --from=markdown --to=html --css=rust.css \\\n+\t   --include-before-body=doc/version_info.html \\\n+           --output=$@\n+\n   endif\n endif\n "}, {"sha": "d8457a4f49744f3faaf8dd69b1c73683cca2a3f6", "filename": "mk/tests.mk", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=fd0de8bfd70b01dd01ca541bfdfb52703fa44d9c", "patch": "@@ -179,6 +179,11 @@ doc-tutorial-borrowed-ptr-extract$(1):\n \t$$(Q)rm -f $(1)/test/doc-tutorial-borrowed-ptr/*.rs\n \t$$(Q)$$(EXTRACT_TESTS) $$(S)doc/tutorial-borrowed-ptr.md $(1)/test/doc-tutorial-borrowed-ptr\n \n+doc-tutorial-tasks-extract$(1):\n+\t@$$(call E, extract: tutorial-tasks tests)\n+\t$$(Q)rm -f $(1)/test/doc-tutorial-tasks/*.rs\n+\t$$(Q)$$(EXTRACT_TESTS) $$(S)doc/tutorial-tasks.md $(1)/test/doc-tutorial-tasks\n+\n doc-ref-extract$(1):\n \t@$$(call E, extract: ref tests)\n \t$$(Q)rm -f $(1)/test/doc-ref/*.rs\n@@ -229,6 +234,7 @@ check-stage$(1)-T-$(2)-H-$(3):     \t\t\t\t\\\n     check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-ffi  \\\n     check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-macros  \\\n     check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-borrowed-ptr  \\\n+    check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-tasks  \\\n     check-stage$(1)-T-$(2)-H-$(3)-doc-ref\n \n check-stage$(1)-T-$(2)-H-$(3)-core:\t\t\t\t\\\n@@ -298,6 +304,9 @@ check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-macros: \\\n check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-borrowed-ptr: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-borrowed-ptr-dummy\n \n+check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-tasks: \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-tasks-dummy\n+\n check-stage$(1)-T-$(2)-H-$(3)-doc-ref: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-doc-ref-dummy\n \n@@ -485,6 +494,12 @@ DOC_TUTORIAL_BORROWED_PTR_ARGS$(1)-T-$(2)-H-$(3) :=\t\\\n         --build-base $(3)/test/doc-tutorial-borrowed-ptr/ \\\n         --mode run-pass\n \n+DOC_TUTORIAL_TASKS_ARGS$(1)-T-$(2)-H-$(3) :=\t\\\n+\t\t$$(CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3))\t\\\n+        --src-base $(3)/test/doc-tutorial-tasks/\t\\\n+        --build-base $(3)/test/doc-tutorial-tasks/ \\\n+        --mode run-pass\n+\n DOC_REF_ARGS$(1)-T-$(2)-H-$(3) :=\t\t\t\\\n \t\t$$(CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3))\t\\\n         --src-base $(3)/test/doc-ref/\t\t\t\\\n@@ -611,6 +626,14 @@ check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-borrowed-ptr-dummy:       \\\n                 $$(DOC_TUTORIAL_BORROWED_PTR_ARGS$(1)-T-$(2)-H-$(3)) \\\n \t\t--logfile tmp/check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-borrowed-ptr.log\n \n+check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-tasks-dummy:       \\\n+\t        $$(TEST_SREQ$(1)_T_$(2)_H_$(3))\t\t\\\n+                doc-tutorial-tasks-extract$(3)\n+\t@$$(call E, run doc-tutorial-tasks: $$<)\n+\t$$(Q)$$(call CFG_RUN_CTEST,$(1),$$<,$(3)) \\\n+                $$(DOC_TUTORIAL_TASKS_ARGS$(1)-T-$(2)-H-$(3)) \\\n+\t\t--logfile tmp/check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-tasks.log\n+\n check-stage$(1)-T-$(2)-H-$(3)-doc-ref-dummy:            \\\n \t        $$(TEST_SREQ$(1)_T_$(2)_H_$(3))\t\t\\\n                 doc-ref-extract$(3)\n@@ -748,6 +771,9 @@ check-stage$(1)-H-$(2)-doc-tutorial-macros:\t\t\t\\\n check-stage$(1)-H-$(2)-doc-tutorial-borrowed-ptr:\t\t\\\n \t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n \t check-stage$(1)-T-$$(target)-H-$(2)-doc-tutorial-borrowed-ptr)\n+check-stage$(1)-H-$(2)-doc-tutorial-tasks:\t\t\\\n+\t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n+\t check-stage$(1)-T-$$(target)-H-$(2)-doc-tutorial-tasks)\n check-stage$(1)-H-$(2)-doc-ref:\t\t\t\t\\\n \t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n \t check-stage$(1)-T-$$(target)-H-$(2)-doc-ref)\n@@ -859,6 +885,7 @@ check-stage$(1)-doc-tutorial: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-tutorial\n check-stage$(1)-doc-tutorial-ffi: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-tutorial-ffi\n check-stage$(1)-doc-tutorial-macros: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-tutorial-macros\n check-stage$(1)-doc-tutorial-borrowed-ptr: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-tutorial-borrowed-ptr\n+check-stage$(1)-doc-tutorial-tasks: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-tutorial-tasks\n check-stage$(1)-doc-ref: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-ref\n \n endef"}]}