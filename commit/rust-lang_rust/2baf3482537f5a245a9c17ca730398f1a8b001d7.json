{"sha": "2baf3482537f5a245a9c17ca730398f1a8b001d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYWYzNDgyNTM3ZjVhMjQ1YTljMTdjYTczMDM5OGYxYThiMDAxZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-21T21:18:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-21T21:18:30Z"}, "message": "Auto merge of #24162 - pnkfelix:fsk-detect-duplicate-loop-labels, r=nikomatsakis\n\nCheck for duplicate loop labels in function bodies.\r\n\r\nSee also: http://internals.rust-lang.org/t/psa-rejecting-duplicate-loop-labels/1833\r\n\r\nThe change, which we are putting in as future-proofing in preparation for future potential additions to the language (namely labeling arbitrary blocks and using those labels in borrow expressions), means that code like this will start emitting warnings:\r\n\r\n```rust\r\nfn main() {\r\n    { 'a: loop { break; } }\r\n    { 'a: loop { break; } }\r\n}\r\n```\r\n\r\nTo make the above code compile without warnings, write this instead:\r\n\r\n```rust\r\nfn main() {\r\n    { 'a: loop { break; } }\r\n    { 'b: loop { break; } }\r\n}\r\n```\r\n\r\nSince this change is only introducing a new warnings, this change is non-breaking.\r\n\r\nFix #21633", "tree": {"sha": "9a7bd217a5bd3a2d48ed9b9d672b293242f79939", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a7bd217a5bd3a2d48ed9b9d672b293242f79939"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2baf3482537f5a245a9c17ca730398f1a8b001d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2baf3482537f5a245a9c17ca730398f1a8b001d7", "html_url": "https://github.com/rust-lang/rust/commit/2baf3482537f5a245a9c17ca730398f1a8b001d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2baf3482537f5a245a9c17ca730398f1a8b001d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7397bdc9c516f3f714ad4974ecdd27f567d03d05", "url": "https://api.github.com/repos/rust-lang/rust/commits/7397bdc9c516f3f714ad4974ecdd27f567d03d05", "html_url": "https://github.com/rust-lang/rust/commit/7397bdc9c516f3f714ad4974ecdd27f567d03d05"}, {"sha": "2b3cd40f829e256bf54729e7fd0a3b8ceb4c2925", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3cd40f829e256bf54729e7fd0a3b8ceb4c2925", "html_url": "https://github.com/rust-lang/rust/commit/2b3cd40f829e256bf54729e7fd0a3b8ceb4c2925"}], "stats": {"total": 504, "additions": 489, "deletions": 15}, "files": [{"sha": "6f40e17855a78255779a033ee4015b32323672f7", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 201, "deletions": 12, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -24,6 +24,7 @@ use middle::region;\n use middle::subst;\n use middle::ty;\n use std::fmt;\n+use std::mem::replace;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n@@ -70,6 +71,9 @@ struct LifetimeContext<'a> {\n \n     // I'm sorry.\n     trait_ref_hack: bool,\n+\n+    // List of labels in the function/method currently under analysis.\n+    labels_in_fn: Vec<(ast::Ident, Span)>,\n }\n \n enum ScopeChain<'a> {\n@@ -97,13 +101,18 @@ pub fn krate(sess: &Session, krate: &ast::Crate, def_map: &DefMap) -> NamedRegio\n         scope: &ROOT_SCOPE,\n         def_map: def_map,\n         trait_ref_hack: false,\n+        labels_in_fn: vec![],\n     }, krate);\n     sess.abort_if_errors();\n     named_region_map\n }\n \n impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n+        // Items save/restore the set of labels. This way innner items\n+        // can freely reuse names, be they loop labels or lifetimes.\n+        let saved = replace(&mut self.labels_in_fn, vec![]);\n+\n         // Items always introduce a new root scope\n         self.with(RootScope, |_, this| {\n             match item.node {\n@@ -137,23 +146,26 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 }\n             }\n         });\n+\n+        // Done traversing the item; restore saved set of labels.\n+        replace(&mut self.labels_in_fn, saved);\n     }\n \n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n                 b: &'v ast::Block, s: Span, _: ast::NodeId) {\n         match fk {\n             visit::FkItemFn(_, generics, _, _, _) => {\n                 self.visit_early_late(subst::FnSpace, generics, |this| {\n-                    visit::walk_fn(this, fk, fd, b, s)\n+                    this.walk_fn(fk, fd, b, s)\n                 })\n             }\n             visit::FkMethod(_, sig, _) => {\n                 self.visit_early_late(subst::FnSpace, &sig.generics, |this| {\n-                    visit::walk_fn(this, fk, fd, b, s)\n+                    this.walk_fn(fk, fd, b, s)\n                 })\n             }\n             visit::FkFnBlock(..) => {\n-                visit::walk_fn(self, fk, fd, b, s)\n+                self.walk_fn(fk, fd, b, s)\n             }\n         }\n     }\n@@ -190,13 +202,19 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        // We reset the labels on every trait item, so that different\n+        // methods in an impl can reuse label names.\n+        let saved = replace(&mut self.labels_in_fn, vec![]);\n+\n         if let ast::MethodTraitItem(ref sig, None) = trait_item.node {\n             self.visit_early_late(\n                 subst::FnSpace, &sig.generics,\n                 |this| visit::walk_trait_item(this, trait_item))\n         } else {\n             visit::walk_trait_item(self, trait_item);\n         }\n+\n+        replace(&mut self.labels_in_fn, saved);\n     }\n \n     fn visit_block(&mut self, b: &ast::Block) {\n@@ -286,7 +304,170 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq)]\n+enum ShadowKind { Label, Lifetime }\n+struct Original { kind: ShadowKind, span: Span }\n+struct Shadower { kind: ShadowKind, span: Span }\n+\n+fn original_label(span: Span) -> Original {\n+    Original { kind: ShadowKind::Label, span: span }\n+}\n+fn shadower_label(span: Span) -> Shadower {\n+    Shadower { kind: ShadowKind::Label, span: span }\n+}\n+fn original_lifetime(l: &ast::Lifetime) -> Original {\n+    Original { kind: ShadowKind::Lifetime, span: l.span }\n+}\n+fn shadower_lifetime(l: &ast::Lifetime) -> Shadower {\n+    Shadower { kind: ShadowKind::Lifetime, span: l.span }\n+}\n+\n+impl ShadowKind {\n+    fn desc(&self) -> &'static str {\n+        match *self {\n+            ShadowKind::Label => \"label\",\n+            ShadowKind::Lifetime => \"lifetime\",\n+        }\n+    }\n+}\n+\n+fn signal_shadowing_problem(\n+    sess: &Session, name: ast::Name, orig: Original, shadower: Shadower) {\n+    if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n+        // lifetime/lifetime shadowing is an error\n+        sess.span_err(shadower.span,\n+                      &format!(\"{} name `{}` shadows a \\\n+                                {} name that is already in scope\",\n+                               shadower.kind.desc(), name, orig.kind.desc()));\n+    } else {\n+        // shadowing involving a label is only a warning, due to issues with\n+        // labels and lifetimes not being macro-hygienic.\n+        sess.span_warn(shadower.span,\n+                      &format!(\"{} name `{}` shadows a \\\n+                                {} name that is already in scope\",\n+                               shadower.kind.desc(), name, orig.kind.desc()));\n+    }\n+    sess.span_note(orig.span,\n+                   &format!(\"shadowed {} `{}` declared here\",\n+                            orig.kind.desc(), name));\n+}\n+\n+// Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n+// if one of the label shadows a lifetime or another label.\n+fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v ast::Block) {\n+\n+    struct GatherLabels<'a> {\n+        sess: &'a Session,\n+        scope: Scope<'a>,\n+        labels_in_fn: &'a mut Vec<(ast::Ident, Span)>,\n+    }\n+\n+    let mut gather = GatherLabels {\n+        sess: ctxt.sess,\n+        scope: ctxt.scope,\n+        labels_in_fn: &mut ctxt.labels_in_fn,\n+    };\n+    gather.visit_block(b);\n+    return;\n+\n+    impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n+        fn visit_expr(&mut self, ex: &'v ast::Expr) {\n+            if let Some(label) = expression_label(ex) {\n+                for &(prior, prior_span) in &self.labels_in_fn[..] {\n+                    // FIXME (#24278): non-hygienic comparision\n+                    if label.name == prior.name {\n+                        signal_shadowing_problem(self.sess,\n+                                                 label.name,\n+                                                 original_label(prior_span),\n+                                                 shadower_label(ex.span));\n+                    }\n+                }\n+\n+                check_if_label_shadows_lifetime(self.sess,\n+                                                self.scope,\n+                                                label,\n+                                                ex.span);\n+\n+                self.labels_in_fn.push((label, ex.span));\n+            }\n+            visit::walk_expr(self, ex)\n+        }\n+\n+        fn visit_item(&mut self, _: &ast::Item) {\n+            // do not recurse into items defined in the block\n+        }\n+    }\n+\n+    fn expression_label(ex: &ast::Expr) -> Option<ast::Ident> {\n+        match ex.node {\n+            ast::ExprWhile(_, _, Some(label))       |\n+            ast::ExprWhileLet(_, _, _, Some(label)) |\n+            ast::ExprForLoop(_, _, _, Some(label))  |\n+            ast::ExprLoop(_, Some(label))          => Some(label),\n+            _ => None,\n+        }\n+    }\n+\n+    fn check_if_label_shadows_lifetime<'a>(sess: &'a Session,\n+                                           mut scope: Scope<'a>,\n+                                           label: ast::Ident,\n+                                           label_span: Span) {\n+        loop {\n+            match *scope {\n+                BlockScope(_, s) => { scope = s; }\n+                RootScope => { return; }\n+\n+                EarlyScope(_, lifetimes, s) |\n+                LateScope(lifetimes, s) => {\n+                    for lifetime_def in lifetimes {\n+                        // FIXME (#24278): non-hygienic comparision\n+                        if label.name == lifetime_def.lifetime.name {\n+                            signal_shadowing_problem(\n+                                sess,\n+                                label.name,\n+                                original_lifetime(&lifetime_def.lifetime),\n+                                shadower_label(label_span));\n+                            return;\n+                        }\n+                    }\n+                    scope = s;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl<'a> LifetimeContext<'a> {\n+    // This is just like visit::walk_fn, except that it extracts the\n+    // labels of the function body and swaps them in before visiting\n+    // the function body itself.\n+    fn walk_fn<'b>(&mut self,\n+                   fk: visit::FnKind,\n+                   fd: &ast::FnDecl,\n+                   fb: &'b ast::Block,\n+                   _span: Span) {\n+        match fk {\n+            visit::FkItemFn(_, generics, _, _, _) => {\n+                visit::walk_fn_decl(self, fd);\n+                self.visit_generics(generics);\n+            }\n+            visit::FkMethod(_, sig, _) => {\n+                visit::walk_fn_decl(self, fd);\n+                self.visit_generics(&sig.generics);\n+                self.visit_explicit_self(&sig.explicit_self);\n+            }\n+            visit::FkFnBlock(..) => {\n+                visit::walk_fn_decl(self, fd);\n+            }\n+        }\n+\n+        // After inpsecting the decl, add all labels from the body to\n+        // `self.labels_in_fn`.\n+        extract_labels(self, fb);\n+\n+        self.visit_block(fb);\n+    }\n+\n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n         F: FnOnce(Scope, &mut LifetimeContext),\n     {\n@@ -297,6 +478,7 @@ impl<'a> LifetimeContext<'a> {\n             scope: &wrap_scope,\n             def_map: self.def_map,\n             trait_ref_hack: self.trait_ref_hack,\n+            labels_in_fn: self.labels_in_fn.clone(),\n         };\n         debug!(\"entering scope {:?}\", this.scope);\n         f(self.scope, &mut this);\n@@ -494,6 +676,17 @@ impl<'a> LifetimeContext<'a> {\n                                         mut old_scope: Scope,\n                                         lifetime: &ast::Lifetime)\n     {\n+        for &(label, label_span) in &self.labels_in_fn {\n+            // FIXME (#24278): non-hygienic comparision\n+            if lifetime.name == label.name {\n+                signal_shadowing_problem(self.sess,\n+                                         lifetime.name,\n+                                         original_label(label_span),\n+                                         shadower_lifetime(&lifetime));\n+                return;\n+            }\n+        }\n+\n         loop {\n             match *old_scope {\n                 BlockScope(_, s) => {\n@@ -507,15 +700,11 @@ impl<'a> LifetimeContext<'a> {\n                 EarlyScope(_, lifetimes, s) |\n                 LateScope(lifetimes, s) => {\n                     if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n-                        self.sess.span_err(\n-                            lifetime.span,\n-                            &format!(\"lifetime name `{}` shadows another \\\n-                                     lifetime name that is already in scope\",\n-                                     token::get_name(lifetime.name)));\n-                        self.sess.span_note(\n-                            lifetime_def.span,\n-                            &format!(\"shadowed lifetime `{}` declared here\",\n-                                     token::get_name(lifetime.name)));\n+                        signal_shadowing_problem(\n+                            self.sess,\n+                            lifetime.name,\n+                            original_lifetime(&lifetime_def),\n+                            shadower_lifetime(&lifetime));\n                         return;\n                     }\n "}, {"sha": "f0792c145d2a20ff4850aece15fe3602eafc547d", "filename": "src/test/compile-fail/loop-labeled-break-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Floop-labeled-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Floop-labeled-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floop-labeled-break-value.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -16,6 +16,6 @@ fn main() {\n         let _: i32 = 'inner: loop { break 'inner }; //~ ERROR mismatched types\n     }\n     loop {\n-        let _: i32 = 'inner: loop { loop { break 'inner } }; //~ ERROR mismatched types\n+        let _: i32 = 'inner2: loop { loop { break 'inner2 } }; //~ ERROR mismatched types\n     }\n }"}, {"sha": "68627ecaa718f3485dcde3893ed6a313840aadb2", "filename": "src/test/compile-fail/loops-reject-duplicate-labels-2.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Floops-reject-duplicate-labels-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Floops-reject-duplicate-labels-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floops-reject-duplicate-labels-2.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+// ignore-tidy-linelength\n+\n+// Issue #21633: reject duplicate loop labels in function bodies.\n+//\n+// This is testing the generalization (to the whole function body)\n+// discussed here:\n+// http://internals.rust-lang.org/t/psa-rejecting-duplicate-loop-labels/1833\n+\n+pub fn foo() {\n+    { 'fl: for _ in 0..10 { break; } }   //~ NOTE shadowed label `'fl` declared here\n+    { 'fl: loop { break; } }             //~ WARN label name `'fl` shadows a label name that is already in scope\n+\n+    { 'lf: loop { break; } }             //~ NOTE shadowed label `'lf` declared here\n+    { 'lf: for _ in 0..10 { break; } }   //~ WARN label name `'lf` shadows a label name that is already in scope\n+\n+    { 'wl: while 2 > 1 { break; } }      //~ NOTE shadowed label `'wl` declared here\n+    { 'wl: loop { break; } }             //~ WARN label name `'wl` shadows a label name that is already in scope\n+\n+    { 'lw: loop { break; } }             //~ NOTE shadowed label `'lw` declared here\n+    { 'lw: while 2 > 1 { break; } }      //~ WARN label name `'lw` shadows a label name that is already in scope\n+\n+    { 'fw: for _ in 0..10 { break; } }   //~ NOTE shadowed label `'fw` declared here\n+    { 'fw: while 2 > 1 { break; } }      //~ WARN label name `'fw` shadows a label name that is already in scope\n+\n+    { 'wf: while 2 > 1 { break; } }      //~ NOTE shadowed label `'wf` declared here\n+    { 'wf: for _ in 0..10 { break; } }   //~ WARN label name `'wf` shadows a label name that is already in scope\n+\n+    { 'tl: while let Some(_) = None::<i32> { break; } } //~ NOTE shadowed label `'tl` declared here\n+    { 'tl: loop { break; } }             //~ WARN label name `'tl` shadows a label name that is already in scope\n+\n+    { 'lt: loop { break; } }             //~ NOTE shadowed label `'lt` declared here\n+    { 'lt: while let Some(_) = None::<i32> { break; } }\n+                                        //~^ WARN label name `'lt` shadows a label name that is already in scope\n+}\n+\n+#[rustc_error]\n+pub fn main() { //~ ERROR compilation successful\n+    foo();\n+}"}, {"sha": "15446bf642d4d52fd14611c836dc2f1ac5b29f6e", "filename": "src/test/compile-fail/loops-reject-duplicate-labels.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Floops-reject-duplicate-labels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Floops-reject-duplicate-labels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floops-reject-duplicate-labels.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+// ignore-tidy-linelength\n+\n+// Issue #21633: reject duplicate loop labels in function bodies.\n+// This is testing the exact cases that are in the issue description.\n+\n+fn foo() {\n+    'fl: for _ in 0..10 { break; } //~ NOTE shadowed label `'fl` declared here\n+    'fl: loop { break; }           //~ WARN label name `'fl` shadows a label name that is already in scope\n+\n+    'lf: loop { break; }           //~ NOTE shadowed label `'lf` declared here\n+    'lf: for _ in 0..10 { break; } //~ WARN label name `'lf` shadows a label name that is already in scope\n+\n+    'wl: while 2 > 1 { break; }    //~ NOTE shadowed label `'wl` declared here\n+    'wl: loop { break; }           //~ WARN label name `'wl` shadows a label name that is already in scope\n+\n+    'lw: loop { break; }           //~ NOTE shadowed label `'lw` declared here\n+    'lw: while 2 > 1 { break; }    //~ WARN label name `'lw` shadows a label name that is already in scope\n+\n+    'fw: for _ in 0..10 { break; } //~ NOTE shadowed label `'fw` declared here\n+    'fw: while 2 > 1 { break; }    //~ WARN label name `'fw` shadows a label name that is already in scope\n+\n+    'wf: while 2 > 1 { break; }    //~ NOTE shadowed label `'wf` declared here\n+    'wf: for _ in 0..10 { break; } //~ WARN label name `'wf` shadows a label name that is already in scope\n+\n+    'tl: while let Some(_) = None::<i32> { break; } //~ NOTE shadowed label `'tl` declared here\n+    'tl: loop { break; }           //~ WARN label name `'tl` shadows a label name that is already in scope\n+\n+    'lt: loop { break; }           //~ NOTE shadowed label `'lt` declared here\n+    'lt: while let Some(_) = None::<i32> { break; }\n+                                  //~^ WARN label name `'lt` shadows a label name that is already in scope\n+}\n+\n+// Note however that it is okay for the same label to be reused in\n+// different methods of one impl, as illustrated here.\n+\n+struct S;\n+impl S {\n+    fn m1(&self) { 'okay: loop { break 'okay; } }\n+    fn m2(&self) { 'okay: loop { break 'okay; } }\n+}\n+\n+#[rustc_error]\n+pub fn main() { //~ ERROR compilation successful\n+    let s = S;\n+    s.m1();\n+    s.m2();\n+    foo();\n+}"}, {"sha": "bbdd0774ed936d7337533045b4e59cfa8118f3af", "filename": "src/test/compile-fail/loops-reject-labels-shadowing-lifetimes.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Floops-reject-labels-shadowing-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Floops-reject-labels-shadowing-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floops-reject-labels-shadowing-lifetimes.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -0,0 +1,120 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #21633: reject duplicate loop labels in function bodies.\n+// This is testing interaction between lifetime-params and labels.\n+\n+#![feature(rustc_attrs)]\n+\n+#![allow(dead_code, unused_variables)]\n+\n+fn foo() {\n+    fn foo<'a>() { //~ NOTE shadowed lifetime `'a` declared here\n+        'a: loop { break 'a; }\n+        //~^ WARN label name `'a` shadows a lifetime name that is already in scope\n+    }\n+\n+    struct Struct<'b, 'c> { _f: &'b i8, _g: &'c i8 }\n+    enum Enum<'d, 'e> { A(&'d i8), B(&'e i8) }\n+\n+    impl<'d, 'e> Struct<'d, 'e> {\n+        fn meth_okay() {\n+            'a: loop { break 'a; }\n+            'b: loop { break 'b; }\n+            'c: loop { break 'c; }\n+        }\n+    }\n+\n+    impl <'d, 'e> Enum<'d, 'e> {\n+        fn meth_okay() {\n+            'a: loop { break 'a; }\n+            'b: loop { break 'b; }\n+            'c: loop { break 'c; }\n+        }\n+    }\n+\n+    impl<'bad, 'c> Struct<'bad, 'c> { //~ NOTE shadowed lifetime `'bad` declared here\n+        fn meth_bad(&self) {\n+            'bad: loop { break 'bad; }\n+            //~^ WARN label name `'bad` shadows a lifetime name that is already in scope\n+        }\n+    }\n+\n+    impl<'b, 'bad> Struct<'b, 'bad> { //~ NOTE shadowed lifetime `'bad` declared here\n+        fn meth_bad2(&self) {\n+            'bad: loop { break 'bad; }\n+            //~^ WARN label name `'bad` shadows a lifetime name that is already in scope\n+        }\n+    }\n+\n+    impl<'b, 'c> Struct<'b, 'c> {\n+        fn meth_bad3<'bad>(x: &'bad i8) { //~ NOTE shadowed lifetime `'bad` declared here\n+            'bad: loop { break 'bad; }\n+            //~^ WARN label name `'bad` shadows a lifetime name that is already in scope\n+        }\n+\n+        fn meth_bad4<'a,'bad>(x: &'a i8, y: &'bad i8) {\n+            //~^ NOTE shadowed lifetime `'bad` declared here\n+            'bad: loop { break 'bad; }\n+            //~^ WARN label name `'bad` shadows a lifetime name that is already in scope\n+        }\n+    }\n+\n+    impl <'bad, 'e> Enum<'bad, 'e> { //~ NOTE shadowed lifetime `'bad` declared here\n+        fn meth_bad(&self) {\n+            'bad: loop { break 'bad; }\n+            //~^ WARN label name `'bad` shadows a lifetime name that is already in scope\n+        }\n+    }\n+    impl <'d, 'bad> Enum<'d, 'bad> { //~ NOTE shadowed lifetime `'bad` declared here\n+        fn meth_bad2(&self) {\n+            'bad: loop { break 'bad; }\n+            //~^ WARN label name `'bad` shadows a lifetime name that is already in scope\n+        }\n+    }\n+    impl <'d, 'e> Enum<'d, 'e> {\n+        fn meth_bad3<'bad>(x: &'bad i8) { //~ NOTE shadowed lifetime `'bad` declared here\n+            'bad: loop { break 'bad; }\n+            //~^ WARN label name `'bad` shadows a lifetime name that is already in scope\n+        }\n+\n+        fn meth_bad4<'a,'bad>(x: &'bad i8) { //~ NOTE shadowed lifetime `'bad` declared here\n+            'bad: loop { break 'bad; }\n+            //~^ WARN label name `'bad` shadows a lifetime name that is already in scope\n+        }\n+    }\n+\n+    trait HasDefaultMethod1<'bad> { //~ NOTE shadowed lifetime `'bad` declared here\n+        fn meth_okay() {\n+            'c: loop { break 'c; }\n+        }\n+        fn meth_bad(&self) {\n+            'bad: loop { break 'bad; }\n+            //~^ WARN label name `'bad` shadows a lifetime name that is already in scope\n+        }\n+    }\n+    trait HasDefaultMethod2<'a,'bad> { //~ NOTE shadowed lifetime `'bad` declared here\n+        fn meth_bad(&self) {\n+            'bad: loop { break 'bad; }\n+            //~^ WARN label name `'bad` shadows a lifetime name that is already in scope\n+        }\n+    }\n+    trait HasDefaultMethod3<'a,'b> {\n+        fn meth_bad<'bad>(&self) { //~ NOTE shadowed lifetime `'bad` declared here\n+            'bad: loop { break 'bad; }\n+            //~^ WARN label name `'bad` shadows a lifetime name that is already in scope\n+        }\n+    }\n+}\n+\n+#[rustc_error]\n+pub fn main() { //~ ERROR compilation successful\n+    foo();\n+}"}, {"sha": "2344d251c9a69ddd8bd8176026b2fb3d36c6a362", "filename": "src/test/compile-fail/loops-reject-lifetime-shadowing-label.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Floops-reject-lifetime-shadowing-label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Floops-reject-lifetime-shadowing-label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floops-reject-lifetime-shadowing-label.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#![allow(dead_code, unused_variables)]\n+\n+// Issue #21633:  reject duplicate loop labels in function bodies.\n+//\n+// Test rejection of lifetimes in *expressions* that shadow loop labels.\n+\n+fn foo() {\n+    // Reusing lifetime `'a` in function item is okay.\n+    fn foo<'a>(x: &'a i8) -> i8 { *x }\n+\n+    // So is reusing `'a` in struct item\n+    struct S1<'a> { x: &'a i8 } impl<'a> S1<'a> { fn m(&self) {} }\n+    // and a method item\n+    struct S2; impl S2 { fn m<'a>(&self) {} }\n+\n+    let z = 3_i8;\n+\n+    'a: loop { //~ NOTE shadowed label `'a` declared here\n+        let b = Box::new(|x: &i8| *x) as Box<for <'a> Fn(&'a i8) -> i8>;\n+        //~^ WARN lifetime name `'a` shadows a label name that is already in scope\n+        assert_eq!((*b)(&z), z);\n+        break 'a;\n+    }\n+}\n+\n+#[rustc_error]\n+pub fn main() { //~ ERROR compilation successful\n+    foo();\n+}"}, {"sha": "8cbab5f8308098d149bbce068fe189bee1f8b88e", "filename": "src/test/compile-fail/shadowed-lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Fshadowed-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Fcompile-fail%2Fshadowed-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadowed-lifetime.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -15,14 +15,14 @@ struct Foo<'a>(&'a isize);\n impl<'a> Foo<'a> {\n     //~^ NOTE shadowed lifetime `'a` declared here\n     fn shadow_in_method<'a>(&'a self) -> &'a isize {\n-        //~^ ERROR lifetime name `'a` shadows another lifetime name that is already in scope\n+        //~^ ERROR lifetime name `'a` shadows a lifetime name that is already in scope\n         self.0\n     }\n \n     fn shadow_in_type<'b>(&'b self) -> &'b isize {\n         //~^ NOTE shadowed lifetime `'b` declared here\n         let x: for<'b> fn(&'b isize) = panic!();\n-        //~^ ERROR lifetime name `'b` shadows another lifetime name that is already in scope\n+        //~^ ERROR lifetime name `'b` shadows a lifetime name that is already in scope\n         self.0\n     }\n "}, {"sha": "5b45f1e0d392896a8176dfa12ed08e7d905202cc", "filename": "src/test/run-pass/hygienic-labels-in-let.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -10,6 +10,14 @@\n \n // ignore-pretty: pprust doesn't print hygiene output\n \n+// Test that labels injected by macros do not break hygiene.  This\n+// checks cases where the macros invocations are under the rhs of a\n+// let statement.\n+\n+// Issue #24278: The label/lifetime shadowing checker from #24162\n+// conservatively ignores hygiene, and thus issues warnings that are\n+// both true- and false-positives for this test.\n+\n macro_rules! loop_x {\n     ($e: expr) => {\n         // $e shouldn't be able to interact with this 'x"}, {"sha": "a5882f022920fb227a7528cf1fb6bc752b8cd825", "filename": "src/test/run-pass/hygienic-labels.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Frun-pass%2Fhygienic-labels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Frun-pass%2Fhygienic-labels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygienic-labels.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that labels injected by macros do not break hygiene.\n+\n+// Issue #24278: The label/lifetime shadowing checker from #24162\n+// conservatively ignores hygiene, and thus issues warnings that are\n+// both true- and false-positives for this test.\n \n macro_rules! loop_x {\n     ($e: expr) => {"}]}