{"sha": "9b4e61255c4112c774194e62728b4d575abfff26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNGU2MTI1NWM0MTEyYzc3NDE5NGU2MjcyOGI0ZDU3NWFiZmZmMjY=", "commit": {"author": {"name": "Giacomo Stevanato", "email": "giaco.stevanato@gmail.com", "date": "2021-02-03T11:45:55Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-02-20T20:44:17Z"}, "message": "Document BinaryHeap unsafe functions", "tree": {"sha": "a8fb38e5e9c3cbe5472aec4d61b32d6742b12936", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8fb38e5e9c3cbe5472aec4d61b32d6742b12936"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b4e61255c4112c774194e62728b4d575abfff26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b4e61255c4112c774194e62728b4d575abfff26", "html_url": "https://github.com/rust-lang/rust/commit/9b4e61255c4112c774194e62728b4d575abfff26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b4e61255c4112c774194e62728b4d575abfff26/comments", "author": {"login": "SkiFire13", "id": 9020423, "node_id": "MDQ6VXNlcjkwMjA0MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/9020423?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SkiFire13", "html_url": "https://github.com/SkiFire13", "followers_url": "https://api.github.com/users/SkiFire13/followers", "following_url": "https://api.github.com/users/SkiFire13/following{/other_user}", "gists_url": "https://api.github.com/users/SkiFire13/gists{/gist_id}", "starred_url": "https://api.github.com/users/SkiFire13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SkiFire13/subscriptions", "organizations_url": "https://api.github.com/users/SkiFire13/orgs", "repos_url": "https://api.github.com/users/SkiFire13/repos", "events_url": "https://api.github.com/users/SkiFire13/events{/privacy}", "received_events_url": "https://api.github.com/users/SkiFire13/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "html_url": "https://github.com/rust-lang/rust/commit/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404"}], "stats": {"total": 162, "additions": 113, "deletions": 49}, "files": [{"sha": "87184f90d571a89897ff6b500602fc80e984be3f", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 113, "deletions": 49, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/9b4e61255c4112c774194e62728b4d575abfff26/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4e61255c4112c774194e62728b4d575abfff26/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=9b4e61255c4112c774194e62728b4d575abfff26", "patch": "@@ -275,7 +275,8 @@ impl<T: Ord + fmt::Debug> fmt::Debug for PeekMut<'_, T> {\n impl<T: Ord> Drop for PeekMut<'_, T> {\n     fn drop(&mut self) {\n         if self.sift {\n-            self.heap.sift_down(0);\n+            // SAFETY: PeekMut is only instantiated for non-empty heaps.\n+            unsafe { self.heap.sift_down(0) };\n         }\n     }\n }\n@@ -431,7 +432,8 @@ impl<T: Ord> BinaryHeap<T> {\n         self.data.pop().map(|mut item| {\n             if !self.is_empty() {\n                 swap(&mut item, &mut self.data[0]);\n-                self.sift_down_to_bottom(0);\n+                // SAFETY: !self.is_empty() means that self.len() > 0\n+                unsafe { self.sift_down_to_bottom(0) };\n             }\n             item\n         })\n@@ -473,7 +475,9 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n         self.data.push(item);\n-        self.sift_up(0, old_len);\n+        // SAFETY: Since we pushed a new item it means that\n+        //  old_len = self.len() - 1 < self.len()\n+        unsafe { self.sift_up(0, old_len) };\n     }\n \n     /// Consumes the `BinaryHeap` and returns a vector in sorted\n@@ -506,7 +510,10 @@ impl<T: Ord> BinaryHeap<T> {\n                 let ptr = self.data.as_mut_ptr();\n                 ptr::swap(ptr, ptr.add(end));\n             }\n-            self.sift_down_range(0, end);\n+            // SAFETY: `end` goes from `self.len() - 1` to 1 (both included) so:\n+            //  0 < 1 <= end <= self.len() - 1 < self.len()\n+            //  Which means 0 < end and end < self.len().\n+            unsafe { self.sift_down_range(0, end) };\n         }\n         self.into_vec()\n     }\n@@ -519,78 +526,135 @@ impl<T: Ord> BinaryHeap<T> {\n     // the hole is filled back at the end of its scope, even on panic.\n     // Using a hole reduces the constant factor compared to using swaps,\n     // which involves twice as many moves.\n-    fn sift_up(&mut self, start: usize, pos: usize) -> usize {\n-        unsafe {\n-            // Take out the value at `pos` and create a hole.\n-            let mut hole = Hole::new(&mut self.data, pos);\n-\n-            while hole.pos() > start {\n-                let parent = (hole.pos() - 1) / 2;\n-                if hole.element() <= hole.get(parent) {\n-                    break;\n-                }\n-                hole.move_to(parent);\n+\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < self.len()`.\n+    unsafe fn sift_up(&mut self, start: usize, pos: usize) -> usize {\n+        // Take out the value at `pos` and create a hole.\n+        // SAFETY: The caller guarantees that pos < self.len()\n+        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n+\n+        while hole.pos() > start {\n+            let parent = (hole.pos() - 1) / 2;\n+\n+            // SAFETY: hole.pos() > start >= 0, which means hole.pos() > 0\n+            //  and so hole.pos() - 1 can't underflow.\n+            //  This guarantees that parent < hole.pos() so\n+            //  it's a valid index and also != hole.pos().\n+            if hole.element() <= unsafe { hole.get(parent) } {\n+                break;\n             }\n-            hole.pos()\n+\n+            // SAFETY: Same as above\n+            unsafe { hole.move_to(parent) };\n         }\n+\n+        hole.pos()\n     }\n \n     /// Take an element at `pos` and move it down the heap,\n     /// while its children are larger.\n-    fn sift_down_range(&mut self, pos: usize, end: usize) {\n-        unsafe {\n-            let mut hole = Hole::new(&mut self.data, pos);\n-            let mut child = 2 * pos + 1;\n-            while child < end - 1 {\n-                // compare with the greater of the two children\n-                child += (hole.get(child) <= hole.get(child + 1)) as usize;\n-                // if we are already in order, stop.\n-                if hole.element() >= hole.get(child) {\n-                    return;\n-                }\n-                hole.move_to(child);\n-                child = 2 * hole.pos() + 1;\n-            }\n-            if child == end - 1 && hole.element() < hole.get(child) {\n-                hole.move_to(child);\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < end <= self.len()`.\n+    unsafe fn sift_down_range(&mut self, pos: usize, end: usize) {\n+        // SAFETY: The caller guarantees that pos < end <= self.len().\n+        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n+        let mut child = 2 * hole.pos() + 1;\n+\n+        // Loop invariant: child == 2 * hole.pos() + 1.\n+        while child < end - 1 {\n+            // compare with the greater of the two children\n+            // SAFETY: child < end - 1 < self.len() and\n+            //  child + 1 < end <= self.len(), so they're valid indexes.\n+            //  child == 2 * hole.pos() + 1 != hole.pos() and\n+            //  child + 1 == 2 * hole.pos() + 2 != hole.pos().\n+            child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;\n+\n+            // if we are already in order, stop.\n+            // SAFETY: child is now either the old child or the old child+1\n+            //  We already proven that both are < self.len() and != hole.pos()\n+            if hole.element() >= unsafe { hole.get(child) } {\n+                return;\n             }\n+\n+            // SAFETY: same as above.\n+            unsafe { hole.move_to(child) };\n+            child = 2 * hole.pos() + 1;\n+        }\n+\n+        // SAFETY: && short circuit, which means that in the\n+        //  second condition it's already true that child == end - 1 < self.len().\n+        if child == end - 1 && hole.element() < unsafe { hole.get(child) } {\n+            // SAFETY: child is already proven to be a valid index and\n+            //  child == 2 * hole.pos() + 1 != hole.pos().\n+            unsafe { hole.move_to(child) };\n         }\n     }\n \n-    fn sift_down(&mut self, pos: usize) {\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < self.len()`.\n+    unsafe fn sift_down(&mut self, pos: usize) {\n         let len = self.len();\n-        self.sift_down_range(pos, len);\n+        // SAFETY: pos < len is guaranteed by the caller and\n+        //  obviously len = self.len() <= self.len().\n+        unsafe { self.sift_down_range(pos, len) };\n     }\n \n     /// Take an element at `pos` and move it all the way down the heap,\n     /// then sift it up to its position.\n     ///\n     /// Note: This is faster when the element is known to be large / should\n     /// be closer to the bottom.\n-    fn sift_down_to_bottom(&mut self, mut pos: usize) {\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < self.len()`.\n+    unsafe fn sift_down_to_bottom(&mut self, mut pos: usize) {\n         let end = self.len();\n         let start = pos;\n-        unsafe {\n-            let mut hole = Hole::new(&mut self.data, pos);\n-            let mut child = 2 * pos + 1;\n-            while child < end - 1 {\n-                child += (hole.get(child) <= hole.get(child + 1)) as usize;\n-                hole.move_to(child);\n-                child = 2 * hole.pos() + 1;\n-            }\n-            if child == end - 1 {\n-                hole.move_to(child);\n-            }\n-            pos = hole.pos;\n+\n+        // SAFETY: The caller guarantees that pos < self.len().\n+        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n+        let mut child = 2 * hole.pos() + 1;\n+\n+        // Loop invariant: child == 2 * hole.pos() + 1.\n+        while child < end - 1 {\n+            // SAFETY: child < end - 1 < self.len() and\n+            //  child + 1 < end <= self.len(), so they're valid indexes.\n+            //  child == 2 * hole.pos() + 1 != hole.pos() and\n+            //  child + 1 == 2 * hole.pos() + 2 != hole.pos().\n+            child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;\n+\n+            // SAFETY: Same as above\n+            unsafe { hole.move_to(child) };\n+            child = 2 * hole.pos() + 1;\n         }\n-        self.sift_up(start, pos);\n+\n+        if child == end - 1 {\n+            // SAFETY: child == end - 1 < self.len(), so it's a valid index\n+            //  and child == 2 * hole.pos() + 1 != hole.pos().\n+            unsafe { hole.move_to(child) };\n+        }\n+        pos = hole.pos();\n+        drop(hole);\n+\n+        // SAFETY: pos is the position in the hole and was already proven\n+        //  to be a valid index.\n+        unsafe { self.sift_up(start, pos) };\n     }\n \n     fn rebuild(&mut self) {\n         let mut n = self.len() / 2;\n         while n > 0 {\n             n -= 1;\n-            self.sift_down(n);\n+            // SAFETY: n starts from self.len() / 2 and goes down to 0.\n+            //  The only case when !(n < self.len()) is if\n+            //  self.len() == 0, but it's ruled out by the loop condition.\n+            unsafe { self.sift_down(n) };\n         }\n     }\n "}]}