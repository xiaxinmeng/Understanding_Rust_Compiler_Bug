{"sha": "594c3865499533860c2d44ee5c01f7802d8e86bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NGMzODY1NDk5NTMzODYwYzJkNDRlZTVjMDFmNzgwMmQ4ZTg2YmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-07T09:30:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:04:51Z"}, "message": "dump out causal information for \"free region\" errors\n\nThe result is not especially illuminating, but that's ok.", "tree": {"sha": "c60011dc99aed0db0df928f4e88e78c8c1f3641f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c60011dc99aed0db0df928f4e88e78c8c1f3641f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/594c3865499533860c2d44ee5c01f7802d8e86bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/594c3865499533860c2d44ee5c01f7802d8e86bb", "html_url": "https://github.com/rust-lang/rust/commit/594c3865499533860c2d44ee5c01f7802d8e86bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/594c3865499533860c2d44ee5c01f7802d8e86bb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39b0e49ebda225e18b0d918c5cf488eeb4977629", "url": "https://api.github.com/repos/rust-lang/rust/commits/39b0e49ebda225e18b0d918c5cf488eeb4977629", "html_url": "https://github.com/rust-lang/rust/commit/39b0e49ebda225e18b0d918c5cf488eeb4977629"}], "stats": {"total": 120, "additions": 111, "deletions": 9}, "files": [{"sha": "6e0372f009ecefc17af6d0e4ab37cb1e42565469", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/594c3865499533860c2d44ee5c01f7802d8e86bb/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594c3865499533860c2d44ee5c01f7802d8e86bb/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=594c3865499533860c2d44ee5c01f7802d8e86bb", "patch": "@@ -1190,6 +1190,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"choose which RELRO level to use\"),\n     nll: bool = (false, parse_bool, [UNTRACKED],\n                  \"run the non-lexical lifetimes MIR pass\"),\n+    nll_dump_cause: bool = (false, parse_bool, [UNTRACKED],\n+                 \"dump cause information when reporting errors from NLL\"),\n     trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"generate a graphical HTML report of time spent in trans and LLVM\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],"}, {"sha": "384be3d79d12120c322ff09d71572e1c640ec9b6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 90, "deletions": 7, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/594c3865499533860c2d44ee5c01f7802d8e86bb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594c3865499533860c2d44ee5c01f7802d8e86bb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=594c3865499533860c2d44ee5c01f7802d8e86bb", "patch": "@@ -21,6 +21,7 @@ use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegi\n use rustc::traits::ObligationCause;\n use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_errors::DiagnosticBuilder;\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -101,7 +102,7 @@ pub(crate) enum Cause {\n     LiveOther(Location),\n \n     /// part of the initial set of values for a universally quantified region\n-    UniversalRegion,\n+    UniversalRegion(RegionVid),\n \n     /// Element E was added to R because there was some\n     /// outlives obligation `R: R1 @ P` and `R1` contained `E`.\n@@ -300,11 +301,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             // Add all nodes in the CFG to liveness constraints\n             for point_index in self.elements.all_point_indices() {\n-                self.liveness_constraints.add(variable, point_index, &Cause::UniversalRegion);\n+                self.liveness_constraints.add(\n+                    variable,\n+                    point_index,\n+                    &Cause::UniversalRegion(variable),\n+                );\n             }\n \n             // Add `end(X)` into the set for X.\n-            self.liveness_constraints.add(variable, variable, &Cause::UniversalRegion);\n+            self.liveness_constraints\n+                .add(variable, variable, &Cause::UniversalRegion(variable));\n         }\n     }\n \n@@ -406,7 +412,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         self.check_type_tests(infcx, mir, outlives_requirements.as_mut());\n \n-        self.check_universal_regions(infcx, outlives_requirements.as_mut());\n+        self.check_universal_regions(infcx, mir, outlives_requirements.as_mut());\n \n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n@@ -782,6 +788,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_regions<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n         // The universal regions are always found in a prefix of the\n@@ -794,7 +801,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // they did not grow too large, accumulating any requirements\n         // for our caller into the `outlives_requirements` vector.\n         for (fr, _) in universal_definitions {\n-            self.check_universal_region(infcx, fr, &mut propagated_outlives_requirements);\n+            self.check_universal_region(infcx, mir, fr, &mut propagated_outlives_requirements);\n         }\n     }\n \n@@ -809,6 +816,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_region<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n@@ -865,13 +873,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Note: in this case, we use the unapproximated regions\n             // to report the error. This gives better error messages\n             // in some cases.\n-            self.report_error(infcx, longer_fr, shorter_fr, blame_span);\n+            self.report_error(infcx, mir, longer_fr, shorter_fr, blame_span);\n         }\n     }\n \n+    /// Report an error because the universal region `fr` was required to outlive\n+    /// `outlived_fr` but it is not known to do so. For example:\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+    /// ```\n+    ///\n+    /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n     fn report_error(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n         blame_span: Span,\n@@ -888,10 +905,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             None => format!(\"free region `{:?}`\", outlived_fr),\n         };\n \n-        infcx.tcx.sess.span_err(\n+        let mut diag = infcx.tcx.sess.struct_span_err(\n             blame_span,\n             &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n         );\n+\n+        // Find out why `fr` had to outlive `outlived_fr`...\n+        let inferred_values = self.inferred_values.as_ref().unwrap();\n+        if let Some(cause) = inferred_values.cause(fr, outlived_fr) {\n+            cause.label_diagnostic(mir, &mut diag);\n+        }\n+\n+        diag.emit();\n     }\n \n     /// Tries to finds a good span to blame for the fact that `fr1`\n@@ -1129,3 +1154,61 @@ impl CauseExt for Rc<Cause> {\n         }\n     }\n }\n+\n+impl Cause {\n+    pub(crate) fn label_diagnostic(&self, mir: &Mir<'_>, diag: &mut DiagnosticBuilder<'_>) {\n+        // The cause information is pretty messy. Only dump it as an\n+        // internal debugging aid if -Znll-dump-cause is given.\n+        let nll_dump_cause = ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.nll_dump_cause);\n+        if !nll_dump_cause {\n+            return;\n+        }\n+\n+        let mut string = String::new();\n+        self.push_diagnostic_string(mir, &mut string);\n+        diag.note(&string);\n+    }\n+\n+    fn push_diagnostic_string(&self, mir: &Mir<'_>, string: &mut String) {\n+        match self {\n+            Cause::LiveVar(local, location) => {\n+                string.push_str(&format!(\"because `{:?}` is live at {:?}\", local, location));\n+            }\n+\n+            Cause::DropVar(local, location) => {\n+                string.push_str(&format!(\n+                    \"because `{:?}` is dropped at {:?}\",\n+                    local,\n+                    location\n+                ));\n+            }\n+\n+            Cause::LiveOther(location) => {\n+                string.push_str(&format!(\n+                    \"because of a general liveness constraint at {:?}\",\n+                    location\n+                ));\n+            }\n+\n+            Cause::UniversalRegion(region_vid) => {\n+                string.push_str(&format!(\n+                    \"because `{:?}` is universally quantified\",\n+                    region_vid\n+                ));\n+            }\n+\n+            Cause::Outlives {\n+                original_cause,\n+                constraint_location,\n+                constraint_span: _,\n+            } => {\n+                string.push_str(&format!(\n+                    \"because of an outlives relation created at `{:?}`\\n\",\n+                    constraint_location\n+                ));\n+\n+                original_cause.push_diagnostic_string(mir, string);\n+            }\n+        }\n+    }\n+}"}, {"sha": "b2b2ca1182d0340dff8dfefc9d2b822d0e174a11", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/594c3865499533860c2d44ee5c01f7802d8e86bb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594c3865499533860c2d44ee5c01f7802d8e86bb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=594c3865499533860c2d44ee5c01f7802d8e86bb", "patch": "@@ -261,8 +261,11 @@ impl RegionValues {\n         }\n     }\n \n-    /// Adds all the universal regions outlived by `from_region` to\n-    /// `to_region`.\n+    /// Adds `elem` to `to_region` because of a relation:\n+    ///\n+    ///     to_region: from_region @ constraint_location\n+    ///\n+    /// that was added by the cod at `constraint_span`.\n     pub(super) fn add_due_to_outlives<T: ToElementIndex>(\n         &mut self,\n         from_region: RegionVid,\n@@ -418,4 +421,18 @@ impl RegionValues {\n             ));\n         }\n     }\n+\n+    /// Given a region `r` that contains the element `elem`, returns the `Cause`\n+    /// that tells us *why* `elem` is found in that region.\n+    ///\n+    /// Returns None if cause tracking is disabled or `elem` is not\n+    /// actually found in `r`.\n+    pub(super) fn cause<T: ToElementIndex>(&self, r: RegionVid, elem: T) -> Option<Rc<Cause>> {\n+        let index = self.elements.index(elem);\n+        if let Some(causes) = &self.causes {\n+            causes.get(&(r, index)).cloned()\n+        } else {\n+            None\n+        }\n+    }\n }"}]}