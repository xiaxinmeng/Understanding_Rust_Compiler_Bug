{"sha": "b4abed64769ddc62198b044d7f7210bb38eda458", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YWJlZDY0NzY5ZGRjNjIxOThiMDQ0ZDdmNzIxMGJiMzhlZGE0NTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-02T20:23:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-02T20:23:45Z"}, "message": "Auto merge of #26738 - dotdash:trans_args, r=luqmana\n\nThe current split between create_datums_for_fn_args, copy_args_to_allocas and\r\nstore_arg involves a detour via rvalue datums which cause additional work in\r\nform of insertvalue/extractvalue pairs for fat pointer arguments, and an extra\r\nalloca and memcpy for tupled args in rust-call functions.\r\n\r\nBy merging those three functions into just one that actually covers the whole\r\nprocess of creating the final argument datums, we can skip all that.  Also,\r\nthis allows to easily merge in the handling of rust-call functions, allowing to\r\nmake create_datum_for_fn_args_under_call_abi obsolete.\r\n\r\ncc #26600 -- The insertvalue instructions kicked us off of fast-isel.", "tree": {"sha": "def5a4ed06ff8727b1889a678498db1265f6bfbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/def5a4ed06ff8727b1889a678498db1265f6bfbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4abed64769ddc62198b044d7f7210bb38eda458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4abed64769ddc62198b044d7f7210bb38eda458", "html_url": "https://github.com/rust-lang/rust/commit/b4abed64769ddc62198b044d7f7210bb38eda458", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4abed64769ddc62198b044d7f7210bb38eda458/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb379ef05cfdf5c61ec992c578682814c990b264", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb379ef05cfdf5c61ec992c578682814c990b264", "html_url": "https://github.com/rust-lang/rust/commit/fb379ef05cfdf5c61ec992c578682814c990b264"}, {"sha": "a04784f7f9fd7f45a59d0d69de0f326881f55f43", "url": "https://api.github.com/repos/rust-lang/rust/commits/a04784f7f9fd7f45a59d0d69de0f326881f55f43", "html_url": "https://github.com/rust-lang/rust/commit/a04784f7f9fd7f45a59d0d69de0f326881f55f43"}], "stats": {"total": 300, "additions": 113, "deletions": 187}, "files": [{"sha": "c2397ec31cffab8abaa9adf1d79e6b71d594ad8b", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 50, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b4abed64769ddc62198b044d7f7210bb38eda458/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4abed64769ddc62198b044d7f7210bb38eda458/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=b4abed64769ddc62198b044d7f7210bb38eda458", "patch": "@@ -215,7 +215,7 @@ use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{self, Ty};\n-use session::config::{NoDebugInfo, FullDebugInfo};\n+use session::config::NoDebugInfo;\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n use util::ppaux;\n@@ -1600,54 +1600,6 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-/// Generates code for argument patterns like `fn foo(<pat>: T)`.\n-/// Creates entries in the `lllocals` map for each of the bindings\n-/// in `pat`.\n-///\n-/// # Arguments\n-///\n-/// - `pat` is the argument pattern\n-/// - `llval` is a pointer to the argument value (in other words,\n-///   if the argument type is `T`, then `llval` is a `T*`). In some\n-///   cases, this code may zero out the memory `llval` points at.\n-pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             pat: &ast::Pat,\n-                             arg: Datum<'tcx, Rvalue>,\n-                             arg_scope: cleanup::ScopeId)\n-                             -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"match::store_arg\");\n-\n-    match simple_identifier(&*pat) {\n-        Some(ident) => {\n-            // Generate nicer LLVM for the common case of fn a pattern\n-            // like `x: T`\n-            let arg_ty = node_id_type(bcx, pat.id);\n-            if type_of::arg_is_indirect(bcx.ccx(), arg_ty)\n-                && bcx.sess().opts.debuginfo != FullDebugInfo {\n-                // Don't copy an indirect argument to an alloca, the caller\n-                // already put it in a temporary alloca and gave it up, unless\n-                // we emit extra-debug-info, which requires local allocas :(.\n-                let arg_val = arg.add_clean(bcx.fcx, arg_scope);\n-                bcx.fcx.lllocals.borrow_mut()\n-                   .insert(pat.id, Datum::new(arg_val, arg_ty, Lvalue));\n-                bcx\n-            } else {\n-                mk_binding_alloca(\n-                    bcx, pat.id, ident.name, arg_scope, arg,\n-                    |arg, bcx, llval, _| arg.store_to(bcx, llval))\n-            }\n-        }\n-\n-        None => {\n-            // General path. Copy out the values that are used in the\n-            // pattern.\n-            let arg = unpack_datum!(\n-                bcx, arg.to_lvalue_datum_in_scope(bcx, \"__arg\", arg_scope));\n-            bind_irrefutable_pat(bcx, pat, arg.val, arg_scope)\n-        }\n-    }\n-}\n-\n fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                        p_id: ast::NodeId,\n                                        name: ast::Name,\n@@ -1687,7 +1639,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n /// - bcx: starting basic block context\n /// - pat: the irrefutable pattern being matched.\n /// - val: the value being matched -- must be an lvalue (by ref, with cleanup)\n-fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     pat: &ast::Pat,\n                                     val: ValueRef,\n                                     cleanup_scope: cleanup::ScopeId)"}, {"sha": "edb61b0d3cf384cfb8aaf882a05e452c8e65c290", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 99, "deletions": 120, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/b4abed64769ddc62198b044d7f7210bb38eda458/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4abed64769ddc62198b044d7f7210bb38eda458/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=b4abed64769ddc62198b044d7f7210bb38eda458", "patch": "@@ -40,10 +40,11 @@ use middle::cfg;\n use middle::infer;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n+use middle::pat_util::simple_identifier;\n use middle::subst::Substs;\n use middle::ty::{self, Ty, HasTypeFlags};\n use rustc::ast_map;\n-use session::config::{self, NoDebugInfo};\n+use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use trans::_match;\n use trans::adt;\n@@ -1035,6 +1036,13 @@ pub fn alloca_no_lifetime(cx: Block, ty: Type, name: &str) -> ValueRef {\n     Alloca(cx, ty, name)\n }\n \n+pub fn set_value_name(val: ValueRef, name: &str) {\n+    unsafe {\n+        let name = CString::new(name).unwrap();\n+        llvm::LLVMSetValueName(val, name.as_ptr());\n+    }\n+}\n+\n // Creates the alloca slot which holds the pointer to the slot for the final return value\n pub fn make_return_slot_pointer<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                                           output_type: Ty<'tcx>) -> ValueRef {\n@@ -1297,78 +1305,70 @@ pub fn arg_kind<'a, 'tcx>(cx: &FunctionContext<'a, 'tcx>, t: Ty<'tcx>)\n     }\n }\n \n-// work around bizarre resolve errors\n-pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n-\n-// create_datums_for_fn_args: creates rvalue datums for each of the\n-// incoming function arguments. These will later be stored into\n-// appropriate lvalue datums.\n-pub fn create_datums_for_fn_args<'a, 'tcx>(bcx: Block<'a, 'tcx>,\n-                                           arg_tys: &[Ty<'tcx>])\n-                                           -> Vec<RvalueDatum<'tcx>> {\n+// create_datums_for_fn_args: creates lvalue datums for each of the\n+// incoming function arguments.\n+pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n+                                           args: &[ast::Arg],\n+                                           arg_tys: &[Ty<'tcx>],\n+                                           has_tupled_arg: bool,\n+                                           arg_scope: cleanup::CustomScopeIndex)\n+                                           -> Block<'a, 'tcx> {\n     let _icx = push_ctxt(\"create_datums_for_fn_args\");\n     let fcx = bcx.fcx;\n+    let arg_scope_id = cleanup::CustomScope(arg_scope);\n \n     // Return an array wrapping the ValueRefs that we get from `get_param` for\n     // each argument into datums.\n-    let mut i = fcx.arg_offset() as c_uint;\n-    arg_tys.iter().map(|&arg_ty| {\n-        if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-            let llty = type_of::type_of(bcx.ccx(), arg_ty);\n-            let data = get_param(fcx.llfn, i);\n-            let extra = get_param(fcx.llfn, i + 1);\n-            let fat_ptr = expr::make_fat_ptr(bcx, llty, data, extra);\n-            i += 2;\n-            datum::Datum::new(fat_ptr, arg_ty, datum::Rvalue { mode: datum::ByValue })\n-        } else {\n-            let llarg = get_param(fcx.llfn, i);\n-            i += 1;\n-            datum::Datum::new(llarg, arg_ty, arg_kind(fcx, arg_ty))\n-        }\n-    }).collect()\n-}\n-\n-/// Creates rvalue datums for each of the incoming function arguments and\n-/// tuples the arguments. These will later be stored into appropriate lvalue\n-/// datums.\n-///\n-/// FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n-fn create_datums_for_fn_args_under_call_abi<'blk, 'tcx>(\n-        mut bcx: Block<'blk, 'tcx>,\n-        arg_scope: cleanup::CustomScopeIndex,\n-        arg_tys: &[Ty<'tcx>])\n-        -> Vec<RvalueDatum<'tcx>> {\n-    let mut result = Vec::new();\n-    let mut idx = bcx.fcx.arg_offset() as c_uint;\n+    //\n+    // For certain mode/type combinations, the raw llarg values are passed\n+    // by value.  However, within the fn body itself, we want to always\n+    // have all locals and arguments be by-ref so that we can cancel the\n+    // cleanup and for better interaction with LLVM's debug info.  So, if\n+    // the argument would be passed by value, we store it into an alloca.\n+    // This alloca should be optimized away by LLVM's mem-to-reg pass in\n+    // the event it's not truly needed.\n+    let mut idx = fcx.arg_offset() as c_uint;\n     for (i, &arg_ty) in arg_tys.iter().enumerate() {\n-        if i < arg_tys.len() - 1 {\n-            // Regular argument.\n-            result.push(if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-                let llty = type_of::type_of(bcx.ccx(), arg_ty);\n-                let data = get_param(bcx.fcx.llfn, idx);\n-                let extra = get_param(bcx.fcx.llfn, idx + 1);\n+        let arg_datum = if !has_tupled_arg || i < arg_tys.len() - 1 {\n+            if type_of::arg_is_indirect(bcx.ccx(), arg_ty)\n+                    && bcx.sess().opts.debuginfo != FullDebugInfo {\n+                // Don't copy an indirect argument to an alloca, the caller\n+                // already put it in a temporary alloca and gave it up, unless\n+                // we emit extra-debug-info, which requires local allocas :(.\n+                let llarg = get_param(fcx.llfn, idx);\n+                idx += 1;\n+                bcx.fcx.schedule_lifetime_end(arg_scope_id, llarg);\n+                bcx.fcx.schedule_drop_mem(arg_scope_id, llarg, arg_ty);\n+\n+                datum::Datum::new(llarg, arg_ty, datum::Lvalue)\n+            } else if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n+                let data = get_param(fcx.llfn, idx);\n+                let extra = get_param(fcx.llfn, idx + 1);\n                 idx += 2;\n-                let fat_ptr = expr::make_fat_ptr(bcx, llty, data, extra);\n-                datum::Datum::new(fat_ptr, arg_ty, datum::Rvalue { mode: datum::ByValue })\n+                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n+                                                        arg_scope_id, (data, extra),\n+                                                        |(data, extra), bcx, dst| {\n+                    Store(bcx, data, expr::get_dataptr(bcx, dst));\n+                    Store(bcx, extra, expr::get_len(bcx, dst));\n+                    bcx\n+                }))\n             } else {\n-                let val = get_param(bcx.fcx.llfn, idx);\n+                let llarg = get_param(fcx.llfn, idx);\n                 idx += 1;\n-                datum::Datum::new(val, arg_ty, arg_kind(bcx.fcx, arg_ty))\n-            });\n-\n-            continue\n-        }\n-\n-        // This is the last argument. Tuple it.\n-        match arg_ty.sty {\n-            ty::TyTuple(ref tupled_arg_tys) => {\n-                let tuple_args_scope_id = cleanup::CustomScope(arg_scope);\n-                let tuple =\n+                let tmp = datum::Datum::new(llarg, arg_ty, arg_kind(fcx, arg_ty));\n+                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n+                                                           arg_scope_id, tmp,\n+                                                           |tmp, bcx, dst| tmp.store_to(bcx, dst)))\n+            }\n+        } else {\n+            // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n+            match arg_ty.sty {\n+                ty::TyTuple(ref tupled_arg_tys) => {\n                     unpack_datum!(bcx,\n                                   datum::lvalue_scratch_datum(bcx,\n                                                               arg_ty,\n                                                               \"tupled_args\",\n-                                                              tuple_args_scope_id,\n+                                                              arg_scope_id,\n                                                               (),\n                                                               |(),\n                                                                mut bcx,\n@@ -1392,46 +1392,27 @@ fn create_datums_for_fn_args_under_call_abi<'blk, 'tcx>(\n                             };\n                         }\n                         bcx\n-                    }));\n-                let tuple = unpack_datum!(bcx,\n-                                          tuple.to_expr_datum()\n-                                               .to_rvalue_datum(bcx,\n-                                                                \"argtuple\"));\n-                result.push(tuple);\n-            }\n-            _ => {\n-                bcx.tcx().sess.bug(\"last argument of a function with \\\n-                                    `rust-call` ABI isn't a tuple?!\")\n+                    }))\n+                }\n+                _ => {\n+                    bcx.tcx().sess.bug(\"last argument of a function with \\\n+                                        `rust-call` ABI isn't a tuple?!\")\n+                }\n             }\n         };\n \n-    }\n-\n-    result\n-}\n-\n-fn copy_args_to_allocas<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    arg_scope: cleanup::CustomScopeIndex,\n-                                    args: &[ast::Arg],\n-                                    arg_datums: Vec<RvalueDatum<'tcx>>)\n-                                    -> Block<'blk, 'tcx> {\n-    debug!(\"copy_args_to_allocas\");\n-\n-    let _icx = push_ctxt(\"copy_args_to_allocas\");\n-    let mut bcx = bcx;\n-\n-    let arg_scope_id = cleanup::CustomScope(arg_scope);\n-\n-    for (i, arg_datum) in arg_datums.into_iter().enumerate() {\n-        // For certain mode/type combinations, the raw llarg values are passed\n-        // by value.  However, within the fn body itself, we want to always\n-        // have all locals and arguments be by-ref so that we can cancel the\n-        // cleanup and for better interaction with LLVM's debug info.  So, if\n-        // the argument would be passed by value, we store it into an alloca.\n-        // This alloca should be optimized away by LLVM's mem-to-reg pass in\n-        // the event it's not truly needed.\n-\n-        bcx = _match::store_arg(bcx, &*args[i].pat, arg_datum, arg_scope_id);\n+        let pat = &*args[i].pat;\n+        bcx = if let Some(ident) = simple_identifier(&*pat) {\n+            // Generate nicer LLVM for the common case of fn a pattern\n+            // like `x: T`\n+            set_value_name(arg_datum.val, &bcx.name(ident.name));\n+            bcx.fcx.lllocals.borrow_mut().insert(pat.id, arg_datum);\n+            bcx\n+        } else {\n+            // General path. Copy out the values that are used in the\n+            // pattern.\n+            _match::bind_irrefutable_pat(bcx, pat, arg_datum.val, arg_scope_id)\n+        };\n         debuginfo::create_argument_metadata(bcx, &args[i]);\n     }\n \n@@ -1578,34 +1559,20 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         decl.inputs.iter()\n                    .map(|arg| node_id_type(bcx, arg.id))\n                    .collect::<Vec<_>>();\n-    let monomorphized_arg_types = match closure_env {\n-        closure::ClosureEnv::NotClosure => {\n-            monomorphized_arg_types\n-        }\n-\n-        // Tuple up closure argument types for the \"rust-call\" ABI.\n-        closure::ClosureEnv::Closure(_) => {\n-            vec![ccx.tcx().mk_tup(monomorphized_arg_types)]\n-        }\n-    };\n     for monomorphized_arg_type in &monomorphized_arg_types {\n         debug!(\"trans_closure: monomorphized_arg_type: {:?}\",\n                monomorphized_arg_type);\n     }\n     debug!(\"trans_closure: function lltype: {}\",\n            bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n \n-    let arg_datums = match closure_env {\n-        closure::ClosureEnv::NotClosure if abi == RustCall => {\n-            create_datums_for_fn_args_under_call_abi(bcx, arg_scope, &monomorphized_arg_types[..])\n-        }\n-        _ => {\n-            let arg_tys = untuple_arguments_if_necessary(ccx, &monomorphized_arg_types, abi);\n-            create_datums_for_fn_args(bcx, &arg_tys)\n-        }\n+    let has_tupled_arg = match closure_env {\n+        closure::ClosureEnv::NotClosure => abi == RustCall,\n+        _ => false\n     };\n \n-    bcx = copy_args_to_allocas(bcx, arg_scope, &decl.inputs, arg_datums);\n+    bcx = create_datums_for_fn_args(bcx, &decl.inputs, &monomorphized_arg_types,\n+                                    has_tupled_arg, arg_scope);\n \n     bcx = closure_env.load(bcx, cleanup::CustomScope(arg_scope));\n \n@@ -1806,18 +1773,30 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     let arg_tys = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_args());\n \n-    let arg_datums = create_datums_for_fn_args(bcx, &arg_tys[..]);\n-\n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n         let repr = adt::represent_type(ccx, result_ty.unwrap());\n-        for (i, arg_datum) in arg_datums.into_iter().enumerate() {\n+        let mut llarg_idx = fcx.arg_offset() as c_uint;\n+        for (i, arg_ty) in arg_tys.into_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx,\n                                                  &*repr,\n                                                  dest,\n                                                  disr,\n                                                  i);\n-            arg_datum.store_to(bcx, lldestptr);\n+            if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n+                Store(bcx, get_param(fcx.llfn, llarg_idx), expr::get_dataptr(bcx, lldestptr));\n+                Store(bcx, get_param(fcx.llfn, llarg_idx + 1), expr::get_len(bcx, lldestptr));\n+                llarg_idx += 2;\n+            } else {\n+                let arg = get_param(fcx.llfn, llarg_idx);\n+                llarg_idx += 1;\n+\n+                if arg_is_indirect(ccx, arg_ty) {\n+                    memcpy_ty(bcx, lldestptr, arg, arg_ty);\n+                } else {\n+                    store_ty(bcx, arg, lldestptr, arg_ty);\n+                }\n+            }\n         }\n         adt::trans_set_discr(bcx, &*repr, dest, disr);\n     }"}, {"sha": "d7ce50082f1d3fea0f9d4d833899ff46592b9507", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4abed64769ddc62198b044d7f7210bb38eda458/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4abed64769ddc62198b044d7f7210bb38eda458/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=b4abed64769ddc62198b044d7f7210bb38eda458", "patch": "@@ -291,9 +291,6 @@ pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n     GEPi(bcx, fat_ptr, &[0, abi::FAT_PTR_ADDR])\n }\n \n-pub fn make_fat_ptr(bcx: Block, ty: Type, data: ValueRef, extra: ValueRef) -> ValueRef {\n-    InsertValue(bcx, InsertValue(bcx, C_undef(ty), data, 0), extra, 1)\n-}\n pub fn copy_fat_ptr(bcx: Block, src_ptr: ValueRef, dst_ptr: ValueRef) {\n     Store(bcx, Load(bcx, get_dataptr(bcx, src_ptr)), get_dataptr(bcx, dst_ptr));\n     Store(bcx, Load(bcx, get_len(bcx, src_ptr)), get_len(bcx, dst_ptr));"}, {"sha": "4359a8d270da260c7283fc320cf2b21be8338fbd", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b4abed64769ddc62198b044d7f7210bb38eda458/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4abed64769ddc62198b044d7f7210bb38eda458/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=b4abed64769ddc62198b044d7f7210bb38eda458", "patch": "@@ -54,17 +54,11 @@ pub fn type_of_explicit_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-/// Yields the types of the \"real\" arguments for this function. For most\n-/// functions, these are simply the types of the arguments. For functions with\n-/// the `RustCall` ABI, however, this untuples the arguments of the function.\n-pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                inputs: &[Ty<'tcx>],\n-                                                abi: abi::Abi)\n-                                                -> Vec<Ty<'tcx>> {\n-    if abi != abi::RustCall {\n-        return inputs.iter().cloned().collect()\n-    }\n-\n+/// Yields the types of the \"real\" arguments for a function using the `RustCall`\n+/// ABI by untupling the arguments of the function.\n+pub fn untuple_arguments<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                   inputs: &[Ty<'tcx>])\n+                                   -> Vec<Ty<'tcx>> {\n     if inputs.is_empty() {\n         return Vec::new()\n     }\n@@ -78,7 +72,7 @@ pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     match inputs[inputs.len() - 1].sty {\n         ty::TyTuple(ref tupled_arguments) => {\n-            debug!(\"untuple_arguments_if_necessary(): untupling arguments\");\n+            debug!(\"untuple_arguments(): untupling arguments\");\n             for &tupled_argument in tupled_arguments {\n                 result.push(tupled_argument);\n             }\n@@ -108,7 +102,11 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let mut atys: Vec<Type> = Vec::new();\n \n     // First, munge the inputs, if this has the `rust-call` ABI.\n-    let inputs = untuple_arguments_if_necessary(cx, &sig.inputs, abi);\n+    let inputs = &if abi == abi::RustCall {\n+        untuple_arguments(cx, &sig.inputs)\n+    } else {\n+        sig.inputs\n+    };\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n@@ -136,7 +134,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     // ... then explicit args.\n-    for input in &inputs {\n+    for input in inputs {\n         let arg_ty = type_of_explicit_arg(cx, input);\n \n         if type_is_fat_ptr(cx.tcx(), input) {"}]}