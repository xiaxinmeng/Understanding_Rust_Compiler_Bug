{"sha": "32b45248067e9f54446db2d096f80d82be51209a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyYjQ1MjQ4MDY3ZTlmNTQ0NDZkYjJkMDk2ZjgwZDgyYmU1MTIwOWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-26T23:54:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:44Z"}, "message": "Convert middle::trans_common to istrs. Issue #855", "tree": {"sha": "5315882a8d0e6205cdd409bdc36120c4ff398604", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5315882a8d0e6205cdd409bdc36120c4ff398604"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32b45248067e9f54446db2d096f80d82be51209a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32b45248067e9f54446db2d096f80d82be51209a", "html_url": "https://github.com/rust-lang/rust/commit/32b45248067e9f54446db2d096f80d82be51209a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32b45248067e9f54446db2d096f80d82be51209a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcdbdaf2ab35b9e74c38b71e4760867a795ca623", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcdbdaf2ab35b9e74c38b71e4760867a795ca623", "html_url": "https://github.com/rust-lang/rust/commit/fcdbdaf2ab35b9e74c38b71e4760867a795ca623"}], "stats": {"total": 90, "additions": 46, "deletions": 44}, "files": [{"sha": "1b12c318163728ea7c1dc2ecc88d47497035f003", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32b45248067e9f54446db2d096f80d82be51209a/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b45248067e9f54446db2d096f80d82be51209a/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=32b45248067e9f54446db2d096f80d82be51209a", "patch": "@@ -490,16 +490,15 @@ fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: ty::t, name: &istr)\n \n fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &[istr],\n                                         flav: &istr) -> istr {\n-    ret mangle(path +\n-               istr::from_estrs([ccx.names.next(istr::to_estr(flav))]));\n+    ret mangle(path + [ccx.names.next(flav)]);\n }\n \n fn mangle_internal_name_by_path(_ccx: &@crate_ctxt, path: &[istr]) -> istr {\n     ret mangle(path);\n }\n \n fn mangle_internal_name_by_seq(ccx: &@crate_ctxt, flav: &istr) -> istr {\n-    ret istr::from_estr(ccx.names.next(istr::to_estr(flav)));\n+    ret ccx.names.next(flav);\n }\n //\n // Local Variables:"}, {"sha": "d84105656d2c6dd2e0c9ed637e67b2ec00094323", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b45248067e9f54446db2d096f80d82be51209a/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b45248067e9f54446db2d096f80d82be51209a/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=32b45248067e9f54446db2d096f80d82be51209a", "patch": "@@ -248,7 +248,7 @@ fn s_float(_tcx: &ty_ctxt) -> u8 {\n }\n \n fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n-    let llshapetablesty = trans_common::T_named_struct(\"shapes\");\n+    let llshapetablesty = trans_common::T_named_struct(~\"shapes\");\n     let llshapetables = istr::as_buf(~\"shapes\", { |buf|\n         lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n     });"}, {"sha": "a5fb80433bdd57680aca5d63fee11b2b0cfca667", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/32b45248067e9f54446db2d096f80d82be51209a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b45248067e9f54446db2d096f80d82be51209a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=32b45248067e9f54446db2d096f80d82be51209a", "patch": "@@ -2492,7 +2492,7 @@ fn trans_lit_istr(cx: &@block_ctxt, s: str) -> result {\n     let llvecptr = alloc_res.llptr;\n     let llfirsteltptr = alloc_res.llfirsteltptr;\n \n-    let llcstr = C_cstr(bcx_ccx(cx), s);\n+    let llcstr = C_cstr(bcx_ccx(cx), istr::from_estr(s));\n \n     // FIXME: We need to avoid this memmove\n     bcx = call_memmove(bcx, llfirsteltptr, llcstr, C_uint(veclen)).bcx;\n@@ -2523,16 +2523,16 @@ fn trans_crate_lit(cx: &@crate_ctxt, lit: &ast::lit) -> ValueRef {\n         }\n         ret C_integral(t, i as uint, s);\n       }\n-      ast::lit_float(fs) { ret C_float(fs); }\n+      ast::lit_float(fs) { ret C_float(istr::from_estr(fs)); }\n       ast::lit_mach_float(tm, s) {\n         let t = T_float();\n         alt tm { ast::ty_f32. { t = T_f32(); } ast::ty_f64. { t = T_f64(); } }\n-        ret C_floating(s, t);\n+        ret C_floating(istr::from_estr(s), t);\n       }\n       ast::lit_char(c) { ret C_integral(T_char(), c as uint, False); }\n       ast::lit_bool(b) { ret C_bool(b); }\n       ast::lit_nil. { ret C_nil(); }\n-      ast::lit_str(s, ast::sk_rc.) { ret C_str(cx, s); }\n+      ast::lit_str(s, ast::sk_rc.) { ret C_str(cx, istr::from_estr(s)); }\n       ast::lit_str(s, ast::sk_unique.) {\n         cx.sess.span_unimpl(lit.span, \"unique string in this context\");\n       }\n@@ -4317,7 +4317,8 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         let ccx = bcx_ccx(cx);\n         let llfnty: TypeRef =\n             type_of_fn_from_ty(ccx, e.span, node_id_type(ccx, e.id), 0u);\n-        let sub_cx = extend_path(cx.fcx.lcx, ccx.names.next(\"anon\"));\n+        let sub_cx = extend_path(cx.fcx.lcx,\n+                                 istr::to_estr(ccx.names.next(~\"anon\")));\n         let s = mangle_internal_name_by_path(ccx,\n                                              istr::from_estrs(sub_cx.path));\n         let llfn = decl_internal_fastcall_fn(ccx.llmod,\n@@ -4632,7 +4633,7 @@ fn trans_fail_expr(cx: &@block_ctxt, sp_opt: &option::t<span>,\n \n fn trans_fail(cx: &@block_ctxt, sp_opt: &option::t<span>, fail_str: &str) ->\n    result {\n-    let V_fail_str = C_cstr(bcx_ccx(cx), fail_str);\n+    let V_fail_str = C_cstr(bcx_ccx(cx), istr::from_estr(fail_str));\n     ret trans_fail_value(cx, sp_opt, V_fail_str);\n }\n \n@@ -4643,10 +4644,10 @@ fn trans_fail_value(cx: &@block_ctxt, sp_opt: &option::t<span>,\n     alt sp_opt {\n       some(sp) {\n         let loc = bcx_ccx(cx).sess.lookup_pos(sp.lo);\n-        V_filename = C_cstr(bcx_ccx(cx), loc.filename);\n+        V_filename = C_cstr(bcx_ccx(cx), istr::from_estr(loc.filename));\n         V_line = loc.line as int;\n       }\n-      none. { V_filename = C_cstr(bcx_ccx(cx), \"<runtime>\"); V_line = 0; }\n+      none. { V_filename = C_cstr(bcx_ccx(cx), ~\"<runtime>\"); V_line = 0; }\n     }\n     let V_str = bld::PointerCast(cx, V_fail_str, T_ptr(T_i8()));\n     V_filename = bld::PointerCast(cx, V_filename, T_ptr(T_i8()));\n@@ -4924,12 +4925,12 @@ fn trans_stmt(cx: &@block_ctxt, s: &ast::stmt) -> result {\n // next three functions instead.\n fn new_block_ctxt(cx: &@fn_ctxt, parent: &block_parent, kind: block_kind,\n                   name: &str) -> @block_ctxt {\n-    let s = \"\";\n+    let s = ~\"\";\n     if cx.lcx.ccx.sess.get_opts().save_temps ||\n            cx.lcx.ccx.sess.get_opts().debuginfo {\n-        s = cx.lcx.ccx.names.next(name);\n+        s = cx.lcx.ccx.names.next(istr::from_estr(name));\n     }\n-    let llbb: BasicBlockRef = istr::as_buf(istr::from_estr(s), { |buf|\n+    let llbb: BasicBlockRef = istr::as_buf(s, { |buf|\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n     ret @{llbb: llbb,\n@@ -6325,7 +6326,7 @@ fn create_module_map(ccx: &@crate_ctxt) -> ValueRef {\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n     let elts: [ValueRef] = [];\n     for each item: @{key: istr, val: ValueRef} in ccx.module_data.items() {\n-        let elt = C_struct([p2i(C_cstr(ccx, istr::to_estr(item.key))),\n+        let elt = C_struct([p2i(C_cstr(ccx, item.key)),\n                             p2i(item.val)]);\n         elts += [elt];\n     }\n@@ -6370,7 +6371,8 @@ fn create_crate_map(ccx: &@crate_ctxt) -> ValueRef {\n \n fn write_metadata(cx: &@crate_ctxt, crate: &@ast::crate) {\n     if !cx.sess.get_opts().library { ret; }\n-    let llmeta = C_postr(metadata::encoder::encode_metadata(cx, crate));\n+    let llmeta = C_postr(\n+        istr::from_estr(metadata::encoder::encode_metadata(cx, crate)));\n     let llconst = trans_common::C_struct([llmeta]);\n     let llglobal = istr::as_buf(~\"rust_metadata\", { |buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)"}, {"sha": "e4c842bdf4f3ab2e040e5d01b1516faf9f29e463", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/32b45248067e9f54446db2d096f80d82be51209a/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b45248067e9f54446db2d096f80d82be51209a/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=32b45248067e9f54446db2d096f80d82be51209a", "patch": "@@ -63,8 +63,8 @@ import trans::type_of_fn_full;\n import trans::drop_ty;\n \n obj namegen(mutable i: int) {\n-    fn next(prefix: str) -> str {\n-        i += 1; ret prefix + istr::to_estr(int::str(i));\n+    fn next(prefix: &istr) -> istr {\n+        i += 1; ret prefix + int::str(i);\n     }\n }\n \n@@ -438,13 +438,15 @@ fn rslt(bcx: @block_ctxt, val: ValueRef) -> result {\n     ret {bcx: bcx, val: val};\n }\n \n-fn ty_str(tn: type_names, t: TypeRef) -> str {\n-    ret istr::to_estr(lib::llvm::type_to_str(tn, t));\n+fn ty_str(tn: type_names, t: TypeRef) -> istr {\n+    ret lib::llvm::type_to_str(tn, t);\n }\n \n fn val_ty(v: ValueRef) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n \n-fn val_str(tn: type_names, v: ValueRef) -> str { ret ty_str(tn, val_ty(v)); }\n+fn val_str(tn: type_names, v: ValueRef) -> istr {\n+    ret ty_str(tn, val_ty(v));\n+}\n \n // Returns the nth element of the given LLVM structure type.\n fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n@@ -551,9 +553,9 @@ fn T_struct(elts: &[TypeRef]) -> TypeRef {\n                              False);\n }\n \n-fn T_named_struct(name: &str) -> TypeRef {\n+fn T_named_struct(name: &istr) -> TypeRef {\n     let c = llvm::LLVMGetGlobalContext();\n-    ret istr::as_buf(istr::from_estr(name), { |buf|\n+    ret istr::as_buf(name, { |buf|\n         llvm::LLVMStructCreateNamed(c, buf)\n     });\n }\n@@ -570,14 +572,14 @@ fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n // existing objects, use ccx.rust_object_type.  Calling\n // T_rust_object() again will return a different one.\n fn T_rust_object() -> TypeRef {\n-    let t = T_named_struct(\"rust_object\");\n+    let t = T_named_struct(~\"rust_object\");\n     let e = T_ptr(T_empty_struct());\n     set_struct_body(t, [e, e]);\n     ret t;\n }\n \n fn T_task() -> TypeRef {\n-    let t = T_named_struct(\"task\");\n+    let t = T_named_struct(~\"task\");\n \n      // Refcount\n      // Delegate pointer\n@@ -633,7 +635,7 @@ fn T_copy_glue_fn(cx: &crate_ctxt) -> TypeRef {\n }\n \n fn T_tydesc(taskptr_type: TypeRef) -> TypeRef {\n-    let tydesc = T_named_struct(\"tydesc\");\n+    let tydesc = T_named_struct(~\"tydesc\");\n     let tydescpp = T_ptr(T_ptr(tydesc));\n     let pvoid = T_ptr(T_i8());\n     let glue_fn_ty =\n@@ -817,14 +819,14 @@ fn C_integral(t: TypeRef, u: uint, sign_extend: Bool) -> ValueRef {\n     ret llvm::LLVMRustConstSmallInt(t, u, sign_extend);\n }\n \n-fn C_float(s: &str) -> ValueRef {\n-    ret istr::as_buf(istr::from_estr(s), { |buf|\n+fn C_float(s: &istr) -> ValueRef {\n+    ret istr::as_buf(s, { |buf|\n         llvm::LLVMConstRealOfString(T_float(), buf)\n     });\n }\n \n-fn C_floating(s: &str, t: TypeRef) -> ValueRef {\n-    ret istr::as_buf(istr::from_estr(s), { |buf|\n+fn C_floating(s: &istr, t: TypeRef) -> ValueRef {\n+    ret istr::as_buf(s, { |buf|\n         llvm::LLVMConstRealOfString(t, buf)\n     });\n }\n@@ -850,11 +852,11 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i, False); }\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-fn C_cstr(cx: &@crate_ctxt, s: &str) -> ValueRef {\n-    let sc = istr::as_buf(istr::from_estr(s), { |buf|\n-        llvm::LLVMConstString(buf, str::byte_len(s), False)\n+fn C_cstr(cx: &@crate_ctxt, s: &istr) -> ValueRef {\n+    let sc = istr::as_buf(s, { |buf|\n+        llvm::LLVMConstString(buf, istr::byte_len(s), False)\n     });\n-    let g = istr::as_buf(istr::from_estr(cx.names.next(\"str\")), { |buf|\n+    let g = istr::as_buf(cx.names.next(~\"str\"), { |buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf)\n     });\n     llvm::LLVMSetInitializer(g, sc);\n@@ -865,19 +867,19 @@ fn C_cstr(cx: &@crate_ctxt, s: &str) -> ValueRef {\n \n \n // A rust boxed-and-length-annotated string.\n-fn C_str(cx: &@crate_ctxt, s: &str) -> ValueRef {\n+fn C_str(cx: &@crate_ctxt, s: &istr) -> ValueRef {\n     let len =\n-        str::byte_len(s); // 'alloc'\n+        istr::byte_len(s); // 'alloc'\n                           // 'fill'\n                           // 'pad'\n \n-    let cstr = istr::as_buf(istr::from_estr(s), { |buf|\n+    let cstr = istr::as_buf(s, { |buf|\n         llvm::LLVMConstString(buf, len, False)\n     });\n     let box =\n         C_struct([C_int(abi::const_refcount as int), C_int(len + 1u as int),\n                   C_int(len + 1u as int), C_int(0), cstr]);\n-    let g = istr::as_buf(istr::from_estr(cx.names.next(\"str\")), { |buf|\n+    let g = istr::as_buf(cx.names.next(~\"str\"), { |buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(box), buf)\n     });\n     llvm::LLVMSetInitializer(g, box);\n@@ -887,9 +889,9 @@ fn C_str(cx: &@crate_ctxt, s: &str) -> ValueRef {\n }\n \n // Returns a Plain Old LLVM String:\n-fn C_postr(s: &str) -> ValueRef {\n-    ret istr::as_buf(istr::from_estr(s), { |buf|\n-        llvm::LLVMConstString(buf, str::byte_len(s), False)\n+fn C_postr(s: &istr) -> ValueRef {\n+    ret istr::as_buf(s, { |buf|\n+        llvm::LLVMConstString(buf, istr::byte_len(s), False)\n     });\n }\n \n@@ -922,8 +924,7 @@ fn C_bytes(bytes: &[u8]) -> ValueRef {\n \n fn C_shape(ccx: &@crate_ctxt, bytes: &[u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n-    let llglobal = istr::as_buf(\n-        istr::from_estr(ccx.names.next(\"shape\")), { |buf|\n+    let llglobal = istr::as_buf(ccx.names.next(~\"shape\"), { |buf|\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n     });\n     llvm::LLVMSetInitializer(llglobal, llshape);"}]}