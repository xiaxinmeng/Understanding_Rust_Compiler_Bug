{"sha": "9de451c6d67129dc34e10d05f5bcb7983897aa2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZTQ1MWM2ZDY3MTI5ZGMzNGUxMGQwNWY1YmNiNzk4Mzg5N2FhMmI=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-05-10T01:07:30Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-10T21:43:59Z"}, "message": "Only include generator saved locals in the variants that need them", "tree": {"sha": "3897e653164940eabd0deba508317c466a5de4a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3897e653164940eabd0deba508317c466a5de4a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9de451c6d67129dc34e10d05f5bcb7983897aa2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9de451c6d67129dc34e10d05f5bcb7983897aa2b", "html_url": "https://github.com/rust-lang/rust/commit/9de451c6d67129dc34e10d05f5bcb7983897aa2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9de451c6d67129dc34e10d05f5bcb7983897aa2b/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "786875824ca6281b87bafb0edff099a3a05f73ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/786875824ca6281b87bafb0edff099a3a05f73ae", "html_url": "https://github.com/rust-lang/rust/commit/786875824ca6281b87bafb0edff099a3a05f73ae"}], "stats": {"total": 82, "additions": 48, "deletions": 34}, "files": [{"sha": "073beafcf1fa1fc42fc1766a023256b1863c5949", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9de451c6d67129dc34e10d05f5bcb7983897aa2b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de451c6d67129dc34e10d05f5bcb7983897aa2b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=9de451c6d67129dc34e10d05f5bcb7983897aa2b", "patch": "@@ -401,9 +401,9 @@ fn locals_live_across_suspend_points(\n     movable: bool,\n ) -> (\n     liveness::LiveVarSet,\n+    Vec<BitSet<GeneratorSavedLocal>>,\n     IndexVec<GeneratorSavedLocal, BitSet<GeneratorSavedLocal>>,\n     FxHashMap<BasicBlock, liveness::LiveVarSet>,\n-    BitSet<BasicBlock>,\n ) {\n     let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let def_id = source.def_id();\n@@ -447,13 +447,10 @@ fn locals_live_across_suspend_points(\n     );\n \n     let mut storage_liveness_map = FxHashMap::default();\n-\n-    let mut suspending_blocks = BitSet::new_empty(body.basic_blocks().len());\n+    let mut live_locals_at_suspension_points = Vec::new();\n \n     for (block, data) in body.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n-            suspending_blocks.insert(block);\n-\n             let loc = Location {\n                 block: block,\n                 statement_index: data.statements.len(),\n@@ -494,16 +491,25 @@ fn locals_live_across_suspend_points(\n             // and their storage is live (the `storage_liveness` variable)\n             storage_liveness.intersect(&liveness.outs[block]);\n \n+            // The generator argument is ignored\n+            storage_liveness.remove(self_arg());\n+\n             let live_locals = storage_liveness;\n \n-            // Add the locals life at this suspension point to the set of locals which live across\n+            // Add the locals live at this suspension point to the set of locals which live across\n             // any suspension points\n             set.union(&live_locals);\n+\n+            live_locals_at_suspension_points.push(live_locals);\n         }\n     }\n \n-    // The generator argument is ignored\n-    set.remove(self_arg());\n+    // Renumber our liveness_map bitsets to include only the locals we are\n+    // saving.\n+    let live_locals_at_suspension_points = live_locals_at_suspension_points\n+        .iter()\n+        .map(|live_locals| renumber_bitset(&live_locals, &set))\n+        .collect();\n \n     let storage_conflicts = compute_storage_conflicts(\n         body,\n@@ -512,7 +518,7 @@ fn locals_live_across_suspend_points(\n         storage_live,\n         storage_live_analysis);\n \n-    (set, storage_conflicts, storage_liveness_map, suspending_blocks)\n+    (set, live_locals_at_suspension_points, storage_conflicts, storage_liveness_map)\n }\n \n /// For every saved local, looks for which locals are StorageLive at the same\n@@ -611,7 +617,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         FxHashMap<BasicBlock, liveness::LiveVarSet>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n-    let (live_locals, storage_conflicts, storage_liveness, suspending_blocks) =\n+    let (live_locals, live_locals_at_suspension_points, storage_conflicts, storage_liveness) =\n         locals_live_across_suspend_points(tcx, body, source, movable);\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n@@ -641,38 +647,46 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let dummy_local = LocalDecl::new_internal(tcx.mk_unit(), body.span);\n \n-    // Gather live locals and their indices replacing values in body.local_decls with a dummy\n-    // to avoid changing local indices\n-    let live_decls = live_locals.iter().map(|local| {\n+    // Gather live locals and their indices replacing values in body.local_decls\n+    // with a dummy to avoid changing local indices.\n+    let mut locals = IndexVec::<GeneratorSavedLocal, _>::new();\n+    let mut tys = IndexVec::<GeneratorSavedLocal, _>::new();\n+    let mut decls = IndexVec::<GeneratorSavedLocal, _>::new();\n+    for (idx, local) in live_locals.iter().enumerate() {\n         let var = mem::replace(&mut body.local_decls[local], dummy_local.clone());\n-        (local, var)\n-    });\n+        locals.push(local);\n+        tys.push(var.ty);\n+        decls.push(var);\n+        debug!(\"generator saved local {:?} => {:?}\", GeneratorSavedLocal::from(idx), local);\n+    }\n \n-    // For now we will access everything via variant #3, leaving empty variants\n-    // for the UNRESUMED, RETURNED, and POISONED states.\n-    // If there were a yield-less generator without a variant #3, it would not\n-    // have any vars to remap, so we would never use this.\n-    let variant_index = VariantIdx::new(3);\n+    // Leave empty variants for the UNRESUMED, RETURNED, and POISONED states.\n+    const RESERVED_VARIANTS: usize = 3;\n \n+    // Build the generator variant field list.\n     // Create a map from local indices to generator struct indices.\n-    // We also create a vector of the LocalDecls of these locals.\n+    let mut variant_fields: IndexVec<VariantIdx, IndexVec<Field, GeneratorSavedLocal>> =\n+        iter::repeat(IndexVec::new()).take(RESERVED_VARIANTS).collect();\n     let mut remap = FxHashMap::default();\n-    let mut decls = IndexVec::new();\n-    for (idx, (local, var)) in live_decls.enumerate() {\n-        remap.insert(local, (var.ty, variant_index, idx));\n-        decls.push(var);\n+    for (suspension_point_idx, live_locals) in live_locals_at_suspension_points.iter().enumerate() {\n+        let variant_index = VariantIdx::from(RESERVED_VARIANTS + suspension_point_idx);\n+        let mut fields = IndexVec::new();\n+        for (idx, saved_local) in live_locals.iter().enumerate() {\n+            fields.push(saved_local);\n+            // Note that if a field is included in multiple variants, it will be\n+            // added overwritten here. That's fine; fields do not move around\n+            // inside generators, so it doesn't matter which variant index we\n+            // access them by.\n+            remap.insert(locals[saved_local], (tys[saved_local], variant_index, idx));\n+        }\n+        variant_fields.push(fields);\n     }\n-    debug!(\"generator saved local mappings: {:?}\", decls);\n-    let field_tys = decls.iter().map(|field| field.ty).collect::<IndexVec<_, _>>();\n-\n-    // Put every var in each variant, for now.\n-    let all_vars = (0..field_tys.len()).map(GeneratorSavedLocal::from).collect();\n-    let empty_variants = iter::repeat(IndexVec::new()).take(3);\n-    let state_variants = iter::repeat(all_vars).take(suspending_blocks.count());\n+    debug!(\"generator variant_fields = {:?}\", variant_fields);\n+    debug!(\"generator storage_conflicts = {:?}\", storage_conflicts);\n \n     let layout = GeneratorLayout {\n-        field_tys,\n-        variant_fields: empty_variants.chain(state_variants).collect(),\n+        field_tys: tys,\n+        variant_fields,\n         storage_conflicts,\n         __local_debuginfo_codegen_only_do_not_use: decls,\n     };"}]}