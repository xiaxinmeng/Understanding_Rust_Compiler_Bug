{"sha": "e4f9ddb878992a9a4edd2667423c29b129ce4301", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZjlkZGI4Nzg5OTJhOWE0ZWRkMjY2NzQyM2MyOWIxMjljZTQzMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-10T07:54:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-10T07:54:18Z"}, "message": "Auto merge of #24180 - huonw:optimise-max-etc, r=alexcrichton\n\nThe main change in this patch is removing the use of `Option` inside the\r\ninner loops of those functions to avoid comparisons where one branch\r\nwill only trigger on the first pass through the loop.\r\n\r\nThe included benchmarks go from:\r\n\r\n    test bench_max    ... bench:       372 ns/iter (+/- 118)\r\n    test bench_max_by ... bench:       428 ns/iter (+/- 33)\r\n    test bench_max_by2 ... bench:      7128 ns/iter (+/- 326)\r\n\r\nto:\r\n\r\n    test bench_max    ... bench:       317 ns/iter (+/- 64)\r\n    test bench_max_by ... bench:       356 ns/iter (+/- 270)\r\n    test bench_max_by2 ... bench:      1387 ns/iter (+/- 183)\r\n\r\nProblem noticed in http://www.reddit.com/r/rust/comments/31syce/using_iterators_to_find_the_index_of_the_min_or/", "tree": {"sha": "c95263ad9c6feb991f36107f84a4b7a402d36e08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c95263ad9c6feb991f36107f84a4b7a402d36e08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4f9ddb878992a9a4edd2667423c29b129ce4301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f9ddb878992a9a4edd2667423c29b129ce4301", "html_url": "https://github.com/rust-lang/rust/commit/e4f9ddb878992a9a4edd2667423c29b129ce4301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4f9ddb878992a9a4edd2667423c29b129ce4301/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b95d8bed8afff7262ec5623677e320bf63d2230", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b95d8bed8afff7262ec5623677e320bf63d2230", "html_url": "https://github.com/rust-lang/rust/commit/6b95d8bed8afff7262ec5623677e320bf63d2230"}, {"sha": "c2258d6d042353bfa6daad6008bcd3c0af3f13de", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2258d6d042353bfa6daad6008bcd3c0af3f13de", "html_url": "https://github.com/rust-lang/rust/commit/c2258d6d042353bfa6daad6008bcd3c0af3f13de"}], "stats": {"total": 124, "additions": 88, "deletions": 36}, "files": [{"sha": "527a7297f85b9912142b20e9a459228acf7c20bc", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 57, "deletions": 36, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e4f9ddb878992a9a4edd2667423c29b129ce4301/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f9ddb878992a9a4edd2667423c29b129ce4301/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e4f9ddb878992a9a4edd2667423c29b129ce4301", "patch": "@@ -744,12 +744,12 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        self.fold(None, |max, y| {\n-            match max {\n-                None    => Some(y),\n-                Some(x) => Some(cmp::max(x, y))\n-            }\n-        })\n+        select_fold1(self,\n+                     |_| (),\n+                     // switch to y even if it is only equal, to preserve\n+                     // stability.\n+                     |_, x, _, y| *x <= *y)\n+            .map(|(_, x)| x)\n     }\n \n     /// Consumes the entire iterator to return the minimum element.\n@@ -767,12 +767,12 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        self.fold(None, |min, y| {\n-            match min {\n-                None    => Some(y),\n-                Some(x) => Some(cmp::min(x, y))\n-            }\n-        })\n+        select_fold1(self,\n+                     |_| (),\n+                     // only switch to y if it is strictly smaller, to\n+                     // preserve stability.\n+                     |_, x, _, y| *x > *y)\n+            .map(|(_, x)| x)\n     }\n \n     /// `min_max` finds the minimum and maximum elements in the iterator.\n@@ -870,21 +870,16 @@ pub trait Iterator {\n     #[inline]\n     #[unstable(feature = \"core\",\n                reason = \"may want to produce an Ordering directly; see #15311\")]\n-    fn max_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n+    fn max_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where\n         Self: Sized,\n         F: FnMut(&Self::Item) -> B,\n     {\n-        self.fold(None, |max: Option<(Self::Item, B)>, y| {\n-            let y_val = f(&y);\n-            match max {\n-                None             => Some((y, y_val)),\n-                Some((x, x_val)) => if y_val >= x_val {\n-                    Some((y, y_val))\n-                } else {\n-                    Some((x, x_val))\n-                }\n-            }\n-        }).map(|(x, _)| x)\n+        select_fold1(self,\n+                     f,\n+                     // switch to y even if it is only equal, to preserve\n+                     // stability.\n+                     |x_p, _, y_p, _| x_p <= y_p)\n+            .map(|(_, x)| x)\n     }\n \n     /// Return the element that gives the minimum value from the\n@@ -904,21 +899,16 @@ pub trait Iterator {\n     #[inline]\n     #[unstable(feature = \"core\",\n                reason = \"may want to produce an Ordering directly; see #15311\")]\n-    fn min_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n+    fn min_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where\n         Self: Sized,\n         F: FnMut(&Self::Item) -> B,\n     {\n-        self.fold(None, |min: Option<(Self::Item, B)>, y| {\n-            let y_val = f(&y);\n-            match min {\n-                None             => Some((y, y_val)),\n-                Some((x, x_val)) => if x_val <= y_val {\n-                    Some((x, x_val))\n-                } else {\n-                    Some((y, y_val))\n-                }\n-            }\n-        }).map(|(x, _)| x)\n+        select_fold1(self,\n+                     f,\n+                     // only switch to y if it is strictly smaller, to\n+                     // preserve stability.\n+                     |x_p, _, y_p, _| x_p > y_p)\n+            .map(|(_, x)| x)\n     }\n \n     /// Change the direction of the iterator\n@@ -1066,6 +1056,37 @@ pub trait Iterator {\n     }\n }\n \n+/// Select an element from an iterator based on the given projection\n+/// and \"comparison\" function.\n+///\n+/// This is an idiosyncratic helper to try to factor out the\n+/// commonalities of {max,min}{,_by}. In particular, this avoids\n+/// having to implement optimisations several times.\n+#[inline]\n+fn select_fold1<I,B, FProj, FCmp>(mut it: I,\n+                                  mut f_proj: FProj,\n+                                  mut f_cmp: FCmp) -> Option<(B, I::Item)>\n+    where I: Iterator,\n+          FProj: FnMut(&I::Item) -> B,\n+          FCmp: FnMut(&B, &I::Item, &B, &I::Item) -> bool\n+{\n+    // start with the first element as our selection. This avoids\n+    // having to use `Option`s inside the loop, translating to a\n+    // sizeable performance gain (6x in one case).\n+    it.next().map(|mut sel| {\n+        let mut sel_p = f_proj(&sel);\n+\n+        for x in it {\n+            let x_p = f_proj(&x);\n+            if f_cmp(&sel_p,  &sel, &x_p, &x) {\n+                sel = x;\n+                sel_p = x_p;\n+            }\n+        }\n+        (sel_p, sel)\n+    })\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n     type Item = I::Item;"}, {"sha": "a56820c61ccbb061adfc1a264465114707c6993d", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e4f9ddb878992a9a4edd2667423c29b129ce4301/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f9ddb878992a9a4edd2667423c29b129ce4301/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=e4f9ddb878992a9a4edd2667423c29b129ce4301", "patch": "@@ -901,3 +901,34 @@ fn bench_multiple_take(b: &mut Bencher) {\n         }\n     });\n }\n+\n+fn scatter(x: i32) -> i32 { (x * 31) % 127 }\n+\n+#[bench]\n+fn bench_max_by(b: &mut Bencher) {\n+    b.iter(|| {\n+        let it = 0..100;\n+        it.max_by(|&x| scatter(x))\n+    })\n+}\n+\n+// http://www.reddit.com/r/rust/comments/31syce/using_iterators_to_find_the_index_of_the_min_or/\n+#[bench]\n+fn bench_max_by2(b: &mut Bencher) {\n+    fn max_index_iter(array: &[i32]) -> usize {\n+        array.iter().enumerate().max_by(|&(_, item)| item).unwrap().0\n+    }\n+\n+    let mut data = vec![0i32; 1638];\n+    data[514] = 9999;\n+\n+    b.iter(|| max_index_iter(&data));\n+}\n+\n+#[bench]\n+fn bench_max(b: &mut Bencher) {\n+    b.iter(|| {\n+        let it = 0..100;\n+        it.map(scatter).max()\n+    })\n+}"}]}