{"sha": "8ea8cd29190cae7ea50dc939ad63b0e8bc650373", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYThjZDI5MTkwY2FlN2VhNTBkYzkzOWFkNjNiMGU4YmM2NTAzNzM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-05T16:08:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-11T06:42:26Z"}, "message": "update for ptr provenance", "tree": {"sha": "58e8d03fe41268ea0dff5039a2dd9b5adb45c445", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58e8d03fe41268ea0dff5039a2dd9b5adb45c445"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ea8cd29190cae7ea50dc939ad63b0e8bc650373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ea8cd29190cae7ea50dc939ad63b0e8bc650373", "html_url": "https://github.com/rust-lang/rust/commit/8ea8cd29190cae7ea50dc939ad63b0e8bc650373", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ea8cd29190cae7ea50dc939ad63b0e8bc650373/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15a00043ba9741878a75c998e9daa7d64fca4edc", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a00043ba9741878a75c998e9daa7d64fca4edc", "html_url": "https://github.com/rust-lang/rust/commit/15a00043ba9741878a75c998e9daa7d64fca4edc"}], "stats": {"total": 122, "additions": 113, "deletions": 9}, "files": [{"sha": "b7338d4d52143380ff8010cab67f3c774cc294ab", "filename": "src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ea8cd29190cae7ea50dc939ad63b0e8bc650373/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea8cd29190cae7ea50dc939ad63b0e8bc650373/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=8ea8cd29190cae7ea50dc939ad63b0e8bc650373", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                         _ => {\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n-                            assert!(mplace.extra.is_none());\n+                            assert!(mplace.meta.is_none());\n                             self.memory.write_repeat(mplace.ptr, 0, dest.layout.size)?;\n                         }\n                     }\n@@ -410,7 +410,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                         _ => {\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n-                            assert!(mplace.extra.is_none());\n+                            assert!(mplace.meta.is_none());\n                             self.memory.mark_definedness(mplace.ptr.to_ptr()?, dest.layout.size, false)?;\n                         }\n                     }"}, {"sha": "81a2ceead0a623b191cf45d47586eb5a90e95306", "filename": "src/lib.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8ea8cd29190cae7ea50dc939ad63b0e8bc650373/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea8cd29190cae7ea50dc939ad63b0e8bc650373/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=8ea8cd29190cae7ea50dc939ad63b0e8bc650373", "patch": "@@ -13,6 +13,9 @@ extern crate rustc_mir;\n extern crate rustc_target;\n extern crate syntax;\n \n+use std::collections::HashMap;\n+use std::borrow::Cow;\n+\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::hir::def_id::DefId;\n@@ -21,11 +24,10 @@ use rustc::mir;\n use syntax::ast::Mutability;\n use syntax::attr;\n \n-use std::collections::HashMap;\n \n pub use rustc::mir::interpret::*;\n pub use rustc_mir::interpret::*;\n-pub use rustc_mir::interpret;\n+pub use rustc_mir::interpret::{self, AllocMap}; // resolve ambiguity\n \n mod fn_call;\n mod operator;\n@@ -34,13 +36,15 @@ mod helpers;\n mod tls;\n mod locks;\n mod range_map;\n+mod mono_hash_map;\n \n use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n use tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n use range_map::RangeMap;\n use helpers::FalibleScalarExt;\n+use mono_hash_map::MonoHashMap;\n \n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -231,8 +235,11 @@ pub struct Evaluator<'tcx> {\n impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryData = ();\n     type MemoryKinds = MiriMemoryKind;\n+    type PointerTag = (); // still WIP\n \n-    const MUT_STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::MutStatic);\n+    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<()>)>;\n+\n+    const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::MutStatic);\n     const ENFORCE_VALIDITY: bool = false; // this is still WIP\n \n     /// Returns Ok() when the function was handled, fail otherwise\n@@ -308,7 +315,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn find_foreign_static(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n-    ) -> EvalResult<'tcx, &'tcx Allocation> {\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation>> {\n         let attrs = tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n             Some(name) => name.as_str(),\n@@ -319,14 +326,13 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             \"__cxa_thread_atexit_impl\" => {\n                 // This should be all-zero, pointer-sized\n                 let data = vec![0; tcx.data_layout.pointer_size.bytes() as usize];\n-                let alloc = Allocation::from_bytes(&data[..], tcx.data_layout.pointer_align);\n-                tcx.intern_const_alloc(alloc)\n+                Allocation::from_bytes(&data[..], tcx.data_layout.pointer_align)\n             }\n             _ => return err!(Unimplemented(\n                     format!(\"can't access foreign static: {}\", link_name),\n                 )),\n         };\n-        Ok(alloc)\n+        Ok(Cow::Owned(alloc))\n     }\n \n     fn validation_op(\n@@ -344,4 +350,11 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         // We are not interested in detecting loops\n         Ok(())\n     }\n+\n+    fn static_with_default_tag(\n+        alloc: &'_ Allocation\n+    ) -> Cow<'_, Allocation<Self::PointerTag>> {\n+        let alloc = alloc.clone();\n+        Cow::Owned(alloc)\n+    }\n }"}, {"sha": "76ca7ac6a133af839382a16598ef70f1e904f999", "filename": "src/mono_hash_map.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8ea8cd29190cae7ea50dc939ad63b0e8bc650373/src%2Fmono_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea8cd29190cae7ea50dc939ad63b0e8bc650373/src%2Fmono_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_hash_map.rs?ref=8ea8cd29190cae7ea50dc939ad63b0e8bc650373", "patch": "@@ -0,0 +1,91 @@\n+//! This is a \"monotonic HashMap\": A HashMap that, when shared, can be pushed to but not\n+//! otherwise mutated.  We also Box items in the map. This means we can safely provide\n+//! shared references into existing items in the HashMap, because they will not be dropped\n+//! (from being removed) or moved (because they are boxed).\n+//! The API is is completely tailored to what `memory.rs` needs. It is still in\n+//! a separate file to minimize the amount of code that has to care about the unsafety.\n+\n+use std::collections::hash_map::Entry;\n+use std::cell::RefCell;\n+use std::hash::Hash;\n+use std::borrow::Borrow;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use super::AllocMap;\n+\n+#[derive(Debug, Clone)]\n+pub struct MonoHashMap<K: Hash + Eq, V>(RefCell<FxHashMap<K, Box<V>>>);\n+\n+impl<K: Hash + Eq, V> Default for MonoHashMap<K, V> {\n+    fn default() -> Self {\n+        MonoHashMap(RefCell::new(Default::default()))\n+    }\n+}\n+\n+impl<K: Hash + Eq, V> AllocMap<K, V> for MonoHashMap<K, V> {\n+    #[inline(always)]\n+    fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n+        where K: Borrow<Q>\n+    {\n+        self.0.get_mut().contains_key(k)\n+    }\n+\n+    #[inline(always)]\n+    fn insert(&mut self, k: K, v: V) -> Option<V>\n+    {\n+        self.0.get_mut().insert(k, Box::new(v)).map(|x| *x)\n+    }\n+\n+    #[inline(always)]\n+    fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n+        where K: Borrow<Q>\n+    {\n+        self.0.get_mut().remove(k).map(|x| *x)\n+    }\n+\n+    #[inline(always)]\n+    fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n+        self.0.borrow()\n+            .iter()\n+            .filter_map(move |(k, v)| f(k, &*v))\n+            .collect()\n+    }\n+\n+    /// The most interesting method: Providing a shared ref without\n+    /// holding the `RefCell` open, and inserting new data if the key\n+    /// is not used yet.\n+    /// `vacant` is called if the key is not found in the map;\n+    /// if it returns a reference, that is used directly, if it\n+    /// returns owned data, that is put into the map and returned.\n+    #[inline(always)]\n+    fn get_or<E>(\n+        &self,\n+        k: K,\n+        vacant: impl FnOnce() -> Result<V, E>\n+    ) -> Result<&V, E> {\n+        let val: *const V = match self.0.borrow_mut().entry(k) {\n+            Entry::Occupied(entry) => &**entry.get(),\n+            Entry::Vacant(entry) => &**entry.insert(Box::new(vacant()?)),\n+        };\n+        // This is safe because `val` points into a `Box`, that we know will not move and\n+        // will also not be dropped as long as the shared reference `self` is live.\n+        unsafe { Ok(&*val) }\n+    }\n+\n+    #[inline(always)]\n+    fn get_mut_or<E>(\n+        &mut self,\n+        k: K,\n+        vacant: impl FnOnce() -> Result<V, E>\n+    ) -> Result<&mut V, E>\n+    {\n+        match self.0.get_mut().entry(k) {\n+            Entry::Occupied(e) => Ok(e.into_mut()),\n+            Entry::Vacant(e) => {\n+                let v = vacant()?;\n+                Ok(e.insert(Box::new(v)))\n+            }\n+        }\n+    }\n+}"}]}