{"sha": "2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYjA5ZWI1ODU2OWY1YTBlNTU0NGM2MjU2MTczZDRiNmI4ZmZjZjI=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-01-07T22:38:13Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-07T23:17:18Z"}, "message": "Add sufficient import support to compile some simple single-crate programs.\n\nThis is likely not the final solution. It does repetitive work and doesn't produce\nerrors for invalid but unused imports. In any case, I think it is a useful step.", "tree": {"sha": "ae9a24f0e04bf84f69cc61acbb15d1d7b72ceb86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae9a24f0e04bf84f69cc61acbb15d1d7b72ceb86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2", "html_url": "https://github.com/rust-lang/rust/commit/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/comments", "author": null, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c61793b5aeef3ab3e8fe876fb94dd9c8c4410c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c61793b5aeef3ab3e8fe876fb94dd9c8c4410c6", "html_url": "https://github.com/rust-lang/rust/commit/3c61793b5aeef3ab3e8fe876fb94dd9c8c4410c6"}], "stats": {"total": 175, "additions": 138, "deletions": 37}, "files": [{"sha": "60f87e8e4b2f61a0a54511ef679a604f4486096c", "filename": "src/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2", "patch": "@@ -437,6 +437,8 @@ TEST_XFAILS_RUSTC := $(filter-out \\\n                         int.rs \\\n                         i32-sub.rs \\\n                         i8-incr.rs \\\n+                        import2.rs \\\n+                        import3.rs \\\n                         item-name-overload.rs \\\n                         large-records.rs \\\n                         lazy-init.rs \\"}, {"sha": "5dc0c4d2916ccab0979f5c9382824182c70cec4a", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2", "patch": "@@ -36,7 +36,6 @@ tag def {\n     def_ty_arg(def_id);\n     def_binding(def_id);\n     def_use(def_id);\n-    def_import(def_id);\n }\n \n type crate = spanned[crate_];"}, {"sha": "6679fc5f3443bbe5dbdcd17824db5af35b0f74c0", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2", "patch": "@@ -781,14 +781,14 @@ fn fold_mod[ENV](&ENV e, ast_fold[ENV] fld, &ast._mod m) -> ast._mod {\n     let vec[@item] items = vec();\n     auto index = m.index;\n \n-    for (@item i in m.items) {\n-        append[@item](items, fold_item[ENV](e, fld, i));\n-    }\n-\n     for (@view_item vi in m.view_items) {\n         append[@view_item](view_items, fold_view_item[ENV](e, fld, vi));\n     }\n \n+    for (@item i in m.items) {\n+        append[@item](items, fold_item[ENV](e, fld, i));\n+    }\n+\n     ret fld.fold_mod(e, rec(view_items=view_items, items=items, index=index));\n  }\n "}, {"sha": "808637e748c1dc2a7176def106948b6b9a0c1e82", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 111, "deletions": 32, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2", "patch": "@@ -24,66 +24,139 @@ tag scope {\n type env = rec(list[scope] scopes,\n                session.session sess);\n \n-fn lookup_name(&env e, ast.ident i) -> option.t[def] {\n+// A simple wrapper over defs that stores a bit more information about modules\n+// and uses so that we can use the regular lookup_name when resolving imports.\n+tag def_wrap {\n+    def_wrap_use(@ast.view_item);\n+    def_wrap_mod(@ast.item);\n+    def_wrap_other(def);\n+}\n+\n+fn unwrap_def(option.t[def_wrap] d_) -> option.t[def] {\n+    alt (d_) {\n+        case (none[def_wrap]) {\n+            ret none[def];\n+        }\n+        case (some[def_wrap](?d)) {\n+            alt (d) {\n+                case (def_wrap_use(?it)) {\n+                    alt (it.node) {\n+                        case (ast.view_item_use(_, _, ?id)) {\n+                            ret some[def](ast.def_use(id));\n+                        }\n+                    }\n+                    fail;\n+                }\n+                case (def_wrap_mod(?i)) {\n+                    alt (i.node) {\n+                        case (ast.item_mod(_, _, ?id)) {\n+                            ret some[def](ast.def_mod(id));\n+                        }\n+                    }\n+                    fail;\n+                }\n+                case (def_wrap_other(?d)) {\n+                    ret some[def](d);\n+                }\n+            }\n+        }\n+    }\n+    fail;\n+}\n+\n+// Follow the path of an import and return what it ultimately points to.\n+\n+fn find_final_def(&env e, vec[ident] idents) -> option.t[def_wrap] {\n+    auto len = _vec.len[ident](idents);\n+    auto first = idents.(0);\n+    if (len == 1u) {\n+        ret lookup_name(e, first);\n+    }\n+    auto d_ = lookup_name(e, first);\n+    alt (d_) {\n+        case (none[def_wrap]) {\n+            ret d_;\n+        }\n+        case (some[def_wrap](?d)) {\n+            alt(d) {\n+                case (def_wrap_mod(?i)) {\n+                    auto new_env = update_env_for_item(e, i);\n+                    auto new_idents = _vec.slice[ident](idents, 1u, len);\n+                    ret find_final_def(new_env, new_idents);\n+                }\n+            }\n+        }\n+    }\n+    fail;\n+}\n+\n+fn lookup_name(&env e, ast.ident i) -> option.t[def_wrap] {\n \n     // log \"resolving name \" + i;\n \n-    fn found_def_item(@ast.item i) -> option.t[def] {\n+    fn found_def_item(@ast.item i) -> option.t[def_wrap] {\n         alt (i.node) {\n             case (ast.item_const(_, _, _, ?id, _)) {\n-                ret some[def](ast.def_const(id));\n+                ret some[def_wrap](def_wrap_other(ast.def_const(id)));\n             }\n             case (ast.item_fn(_, _, _, ?id, _)) {\n-                ret some[def](ast.def_fn(id));\n+                ret some[def_wrap](def_wrap_other(ast.def_fn(id)));\n             }\n             case (ast.item_mod(_, _, ?id)) {\n-                ret some[def](ast.def_mod(id));\n+                ret some[def_wrap](def_wrap_mod(i));\n             }\n             case (ast.item_ty(_, _, _, ?id, _)) {\n-                ret some[def](ast.def_ty(id));\n+                ret some[def_wrap](def_wrap_other(ast.def_ty(id)));\n             }\n             case (ast.item_tag(_, _, _, ?id)) {\n-                ret some[def](ast.def_ty(id));\n+                ret some[def_wrap](def_wrap_other(ast.def_ty(id)));\n             }\n             case (ast.item_obj(_, _, _, ?id, _)) {\n-                ret some[def](ast.def_obj(id));\n+                ret some[def_wrap](def_wrap_other(ast.def_obj(id)));\n             }\n         }\n     }\n \n-    fn found_decl_stmt(@ast.stmt s) -> option.t[def] {\n+    fn found_decl_stmt(@ast.stmt s) -> option.t[def_wrap] {\n         alt (s.node) {\n             case (ast.stmt_decl(?d)) {\n                 alt (d.node) {\n                     case (ast.decl_local(?loc)) {\n-                        ret some[def](ast.def_local(loc.id));\n+                        auto t = ast.def_local(loc.id);\n+                        ret some[def_wrap](def_wrap_other(t));\n                     }\n                     case (ast.decl_item(?it)) {\n                         ret found_def_item(it);\n                     }\n                 }\n             }\n         }\n-        ret none[def];\n+        ret none[def_wrap];\n     }\n \n-    fn found_def_view(@ast.view_item i) -> option.t[def] {\n+    fn found_def_view(&env e, @ast.view_item i) -> option.t[def_wrap] {\n         alt (i.node) {\n             case (ast.view_item_use(_, _, ?id)) {\n-                ret some[def](ast.def_use(id));\n+                ret some[def_wrap](def_wrap_use(i));\n             }\n-            case (ast.view_item_import(_,?id)) {\n-                ret some[def](ast.def_import(id));\n+            case (ast.view_item_import(?idents,_)) {\n+                auto d = find_final_def(e, idents);\n+                alt (d) {\n+                    case (some[def_wrap](_)) {\n+                        ret d;\n+                    }\n+                }\n             }\n         }\n+        fail;\n     }\n \n-    fn check_mod(ast.ident i, ast._mod m) -> option.t[def] {\n+    fn check_mod(&env e, ast.ident i, ast._mod m) -> option.t[def_wrap] {\n         alt (m.index.find(i)) {\n             case (some[ast.mod_index_entry](?ent)) {\n                 alt (ent) {\n                     case (ast.mie_view_item(?ix)) {\n-                        ret found_def_view(m.view_items.(ix));\n+                        ret found_def_view(e, m.view_items.(ix));\n                     }\n                     case (ast.mie_item(?ix)) {\n                         ret found_def_item(m.items.(ix));\n@@ -92,7 +165,8 @@ fn lookup_name(&env e, ast.ident i) -> option.t[def] {\n                         alt (m.items.(item_idx).node) {\n                             case (ast.item_tag(_, ?variants, _, ?tid)) {\n                                 auto vid = variants.(variant_idx).id;\n-                                ret some[def](ast.def_variant(tid, vid));\n+                                auto t = ast.def_variant(tid, vid);\n+                                ret some[def_wrap](def_wrap_other(t));\n                             }\n                             case (_) {\n                                 log \"tag item not actually a tag\";\n@@ -104,45 +178,49 @@ fn lookup_name(&env e, ast.ident i) -> option.t[def] {\n             }\n             case (none[ast.mod_index_entry]) { /* fall through */ }\n         }\n-        ret none[def];\n+        ret none[def_wrap];\n     }\n \n \n-    fn in_scope(ast.ident i, &scope s) -> option.t[def] {\n+    fn in_scope(ast.ident i, env e, &scope s) -> option.t[def_wrap] {\n         alt (s) {\n \n             case (scope_crate(?c)) {\n-                ret check_mod(i, c.node.module);\n+                ret check_mod(e, i, c.node.module);\n             }\n \n             case (scope_item(?it)) {\n                 alt (it.node) {\n                     case (ast.item_fn(_, ?f, ?ty_params, _, _)) {\n                         for (ast.arg a in f.inputs) {\n                             if (_str.eq(a.ident, i)) {\n-                                ret some[def](ast.def_arg(a.id));\n+                                auto t = ast.def_arg(a.id);\n+                                ret some[def_wrap](def_wrap_other(t));\n                             }\n                         }\n                         for (ast.ty_param tp in ty_params) {\n                             if (_str.eq(tp.ident, i)) {\n-                                ret some[def](ast.def_ty_arg(tp.id));\n+                                auto t = ast.def_ty_arg(tp.id);\n+                                ret some[def_wrap](def_wrap_other(t));\n                             }\n                         }\n                     }\n                     case (ast.item_obj(_, ?ob, ?ty_params, _, _)) {\n                         for (ast.obj_field f in ob.fields) {\n                             if (_str.eq(f.ident, i)) {\n-                                ret some[def](ast.def_obj_field(f.id));\n+                                auto t = ast.def_obj_field(f.id);\n+                                ret some[def_wrap](def_wrap_other(t));\n                             }\n                         }\n                         for (ast.ty_param tp in ty_params) {\n                             if (_str.eq(tp.ident, i)) {\n-                                ret some[def](ast.def_ty_arg(tp.id));\n+                                auto t = ast.def_ty_arg(tp.id);\n+                                ret some[def_wrap](def_wrap_other(t));\n                             }\n                         }\n                     }\n                     case (ast.item_mod(_, ?m, _)) {\n-                        ret check_mod(i, m);\n+                        ret check_mod(e, i, m);\n                     }\n                     case (_) { /* fall through */ }\n                 }\n@@ -160,22 +238,23 @@ fn lookup_name(&env e, ast.ident i) -> option.t[def] {\n             case (scope_arm(?a)) {\n                 alt (a.index.find(i)) {\n                     case (some[ast.def_id](?did)) {\n-                        ret some[def](ast.def_binding(did));\n+                        auto t = ast.def_binding(did);\n+                        ret some[def_wrap](def_wrap_other(t));\n                     }\n                     case (_) { /* fall through */  }\n                 }\n             }\n         }\n-        ret none[def];\n+        ret none[def_wrap];\n     }\n \n-    ret std.list.find[scope,def](e.scopes, bind in_scope(i, _));\n+    ret std.list.find[scope,def_wrap](e.scopes, bind in_scope(i, e, _));\n }\n \n fn fold_pat_tag(&env e, &span sp, ident i, vec[@ast.pat] args,\n                 option.t[ast.variant_def] old_def, ann a) -> @ast.pat {\n     auto new_def;\n-    alt (lookup_name(e, i)) {\n+    alt (unwrap_def(lookup_name(e, i))) {\n         case (some[def](?d)) {\n             alt (d) {\n                 case (ast.def_variant(?did, ?vid)) {\n@@ -203,7 +282,7 @@ fn fold_expr_name(&env e, &span sp, &ast.name n,\n         e.sess.unimpl(\"resolving name expr with ty params\");\n     }\n \n-    auto d_ = lookup_name(e, n.node.ident);\n+    auto d_ = unwrap_def(lookup_name(e, n.node.ident));\n \n     alt (d_) {\n         case (some[def](_)) {\n@@ -232,7 +311,7 @@ fn fold_ty_path(&env e, &span sp, ast.path p,\n         e.sess.unimpl(\"resolving path ty with ty params\");\n     }\n \n-    auto d_ = lookup_name(e, n.node.ident);\n+    auto d_ = unwrap_def(lookup_name(e, n.node.ident));\n \n     alt (d_) {\n         case (some[def](_)) {"}, {"sha": "31b49aeab1847f8438af4fc304d67bd07403813f", "filename": "src/test/run-pass/import2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2Ftest%2Frun-pass%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2Ftest%2Frun-pass%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport2.rs?ref=2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2", "patch": "@@ -0,0 +1,9 @@\n+import zed.bar;\n+mod zed {\n+  fn bar() {\n+    log \"bar\";\n+  }\n+}\n+fn main(vec[str] args) {\n+  bar();\n+}"}, {"sha": "559c6ee9ea97c153cf359e46597dc7dad4f8f12d", "filename": "src/test/run-pass/import3.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2Ftest%2Frun-pass%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2/src%2Ftest%2Frun-pass%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport3.rs?ref=2fb09eb58569f5a0e5544c6256173d4b6b8ffcf2", "patch": "@@ -0,0 +1,12 @@\n+import zed.bar;\n+import baz.zed;\n+mod baz {\n+  mod zed {\n+    fn bar() {\n+      log \"bar2\";\n+    }\n+  }\n+}\n+fn main(vec[str] args) {\n+  bar();\n+}"}]}