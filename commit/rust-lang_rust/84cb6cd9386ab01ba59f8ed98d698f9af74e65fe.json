{"sha": "84cb6cd9386ab01ba59f8ed98d698f9af74e65fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0Y2I2Y2Q5Mzg2YWIwMWJhNTlmOGVkOThkNjk4ZjlhZjc0ZTY1ZmU=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-25T01:59:15Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-19T07:31:51Z"}, "message": "Remove rt::{local, local_data, thread_local_storage}", "tree": {"sha": "ec382494b3e6e7c678540aaecb966a3c8d19ae4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec382494b3e6e7c678540aaecb966a3c8d19ae4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84cb6cd9386ab01ba59f8ed98d698f9af74e65fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84cb6cd9386ab01ba59f8ed98d698f9af74e65fe", "html_url": "https://github.com/rust-lang/rust/commit/84cb6cd9386ab01ba59f8ed98d698f9af74e65fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84cb6cd9386ab01ba59f8ed98d698f9af74e65fe/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "html_url": "https://github.com/rust-lang/rust/commit/cac133c9a86a4687755aeb44908e3fbb2bb35fc2"}], "stats": {"total": 700, "additions": 176, "deletions": 524}, "files": [{"sha": "a87bc3d27662e6c90c4197858e0c5cb14fb0f590", "filename": "src/libstd/rt/local_ptr.rs", "status": "removed", "additions": 0, "deletions": 404, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "patch": "@@ -1,404 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Access to a single thread-local pointer.\n-//!\n-//! The runtime will use this for storing Box<Task>.\n-//!\n-//! FIXME: Add runtime checks for usage of inconsistent pointer types.\n-//! and for overwriting an existing pointer.\n-\n-#![allow(dead_code)]\n-\n-use core::prelude::*;\n-\n-use mem;\n-use boxed::Box;\n-\n-#[cfg(any(windows, // mingw-w32 doesn't like thread_local things\n-          target_os = \"android\", // see #10686\n-          target_os = \"ios\"))]\n-pub use self::native::{init, cleanup, put, take, try_take, unsafe_take, exists,\n-                       unsafe_borrow, try_unsafe_borrow};\n-\n-#[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\")))]\n-pub use self::compiled::{init, cleanup, put, take, try_take, unsafe_take, exists,\n-                         unsafe_borrow, try_unsafe_borrow};\n-\n-/// Encapsulates a borrowed value. When this value goes out of scope, the\n-/// pointer is returned.\n-pub struct Borrowed<T> {\n-    val: *const (),\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for Borrowed<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            if self.val.is_null() {\n-                rtabort!(\"Aiee, returning null borrowed object!\");\n-            }\n-            let val: Box<T> = mem::transmute(self.val);\n-            put::<T>(val);\n-            rtassert!(exists());\n-        }\n-    }\n-}\n-\n-impl<T> Deref<T> for Borrowed<T> {\n-    fn deref<'a>(&'a self) -> &'a T {\n-        unsafe { &*(self.val as *const T) }\n-    }\n-}\n-\n-impl<T> DerefMut<T> for Borrowed<T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        unsafe { &mut *(self.val as *mut T) }\n-    }\n-}\n-\n-/// Borrow the thread-local value from thread-local storage.\n-/// While the value is borrowed it is not available in TLS.\n-///\n-/// # Safety note\n-///\n-/// Does not validate the pointer type.\n-#[inline]\n-pub unsafe fn borrow<T>() -> Borrowed<T> {\n-    let val: *const () = mem::transmute(take::<T>());\n-    Borrowed {\n-        val: val,\n-    }\n-}\n-\n-/// Compiled implementation of accessing the runtime local pointer. This is\n-/// implemented using LLVM's thread_local attribute which isn't necessarily\n-/// working on all platforms. This implementation is faster, however, so we use\n-/// it wherever possible.\n-#[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\")))]\n-pub mod compiled {\n-    use core::prelude::*;\n-\n-    use boxed::Box;\n-    use mem;\n-\n-    #[cfg(test)]\n-    pub use realstd::rt::shouldnt_be_public::RT_TLS_PTR;\n-\n-    #[cfg(not(test))]\n-    #[thread_local]\n-    pub static mut RT_TLS_PTR: *mut u8 = 0 as *mut u8;\n-\n-    pub fn init() {}\n-\n-    pub unsafe fn cleanup() {}\n-\n-    // Rationale for all of these functions being inline(never)\n-    //\n-    // The #[thread_local] annotation gets propagated all the way through to\n-    // LLVM, meaning the global is specially treated by LLVM to lower it to an\n-    // efficient sequence of instructions. This also involves dealing with fun\n-    // stuff in object files and whatnot. Regardless, it turns out this causes\n-    // trouble with green threads and lots of optimizations turned on. The\n-    // following case study was done on Linux x86_64, but I would imagine that\n-    // other platforms are similar.\n-    //\n-    // On Linux, the instruction sequence for loading the tls pointer global\n-    // looks like:\n-    //\n-    //      mov %fs:0x0, %rax\n-    //      mov -0x8(%rax), %rbx\n-    //\n-    // This code leads me to believe that (%fs:0x0) is a table, and then the\n-    // table contains the TLS values for the process. Hence, the slot at offset\n-    // -0x8 is the task TLS pointer. This leads us to the conclusion that this\n-    // table is the actual thread local part of each thread. The kernel sets up\n-    // the fs segment selector to point at the right region of memory for each\n-    // thread.\n-    //\n-    // Optimizations lead me to believe that this code is lowered to these\n-    // instructions in the LLVM codegen passes, because you'll see code like\n-    // this when everything is optimized:\n-    //\n-    //      mov %fs:0x0, %r14\n-    //      mov -0x8(%r14), %rbx\n-    //      // do something with %rbx, the rust Task pointer\n-    //\n-    //      ... // <- do more things\n-    //\n-    //      mov -0x8(%r14), %rbx\n-    //      // do something else with %rbx\n-    //\n-    // Note that the optimization done here is that the first load is not\n-    // duplicated during the lower instructions. This means that the %fs:0x0\n-    // memory location is only dereferenced once.\n-    //\n-    // Normally, this is actually a good thing! With green threads, however,\n-    // it's very possible for the code labeled \"do more things\" to context\n-    // switch to another thread. If this happens, then we *must* re-load %fs:0x0\n-    // because it's changed (we're on a different thread). If we don't re-load\n-    // the table location, then we'll be reading the original thread's TLS\n-    // values, not our thread's TLS values.\n-    //\n-    // Hence, we never inline these functions. By never inlining, we're\n-    // guaranteed that loading the table is a local decision which is forced to\n-    // *always* happen.\n-\n-    /// Give a pointer to thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline(never)] // see comments above\n-    pub unsafe fn put<T>(sched: Box<T>) {\n-        RT_TLS_PTR = mem::transmute(sched)\n-    }\n-\n-    /// Take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline(never)] // see comments above\n-    pub unsafe fn take<T>() -> Box<T> {\n-        let ptr = RT_TLS_PTR;\n-        rtassert!(!ptr.is_null());\n-        let ptr: Box<T> = mem::transmute(ptr);\n-        // can't use `as`, due to type not matching with `cfg(test)`\n-        RT_TLS_PTR = mem::transmute(0u);\n-        ptr\n-    }\n-\n-    /// Optionally take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline(never)] // see comments above\n-    pub unsafe fn try_take<T>() -> Option<Box<T>> {\n-        let ptr = RT_TLS_PTR;\n-        if ptr.is_null() {\n-            None\n-        } else {\n-            let ptr: Box<T> = mem::transmute(ptr);\n-            // can't use `as`, due to type not matching with `cfg(test)`\n-            RT_TLS_PTR = mem::transmute(0u);\n-            Some(ptr)\n-        }\n-    }\n-\n-    /// Take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    /// Leaves the old pointer in TLS for speed.\n-    #[inline(never)] // see comments above\n-    pub unsafe fn unsafe_take<T>() -> Box<T> {\n-        mem::transmute(RT_TLS_PTR)\n-    }\n-\n-    /// Check whether there is a thread-local pointer installed.\n-    #[inline(never)] // see comments above\n-    pub fn exists() -> bool {\n-        unsafe {\n-            RT_TLS_PTR.is_not_null()\n-        }\n-    }\n-\n-    #[inline(never)] // see comments above\n-    pub unsafe fn unsafe_borrow<T>() -> *mut T {\n-        if RT_TLS_PTR.is_null() {\n-            rtabort!(\"thread-local pointer is null. bogus!\");\n-        }\n-        RT_TLS_PTR as *mut T\n-    }\n-\n-    #[inline(never)] // see comments above\n-    pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n-        if RT_TLS_PTR.is_null() {\n-            None\n-        } else {\n-            Some(RT_TLS_PTR as *mut T)\n-        }\n-    }\n-}\n-\n-/// Native implementation of having the runtime thread-local pointer. This\n-/// implementation uses the `thread_local_storage` module to provide a\n-/// thread-local value.\n-pub mod native {\n-    use core::prelude::*;\n-\n-    use boxed::Box;\n-    use mem;\n-    use ptr;\n-    use rt::thread_local_storage as tls;\n-\n-    static mut RT_TLS_KEY: tls::Key = -1;\n-\n-    /// Initialize the TLS key. Other ops will fail if this isn't executed\n-    /// first.\n-    pub fn init() {\n-        unsafe {\n-            tls::create(&mut RT_TLS_KEY);\n-        }\n-    }\n-\n-    pub unsafe fn cleanup() {\n-        rtassert!(RT_TLS_KEY != -1);\n-        tls::destroy(RT_TLS_KEY);\n-    }\n-\n-    /// Give a pointer to thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline]\n-    pub unsafe fn put<T>(sched: Box<T>) {\n-        let key = tls_key();\n-        let void_ptr: *mut u8 = mem::transmute(sched);\n-        tls::set(key, void_ptr);\n-    }\n-\n-    /// Take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline]\n-    pub unsafe fn take<T>() -> Box<T> {\n-        let key = tls_key();\n-        let void_ptr: *mut u8 = tls::get(key);\n-        if void_ptr.is_null() {\n-            rtabort!(\"thread-local pointer is null. bogus!\");\n-        }\n-        let ptr: Box<T> = mem::transmute(void_ptr);\n-        tls::set(key, ptr::null_mut());\n-        return ptr;\n-    }\n-\n-    /// Optionally take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    #[inline]\n-    pub unsafe fn try_take<T>() -> Option<Box<T>> {\n-        match maybe_tls_key() {\n-            Some(key) => {\n-                let void_ptr: *mut u8 = tls::get(key);\n-                if void_ptr.is_null() {\n-                    None\n-                } else {\n-                    let ptr: Box<T> = mem::transmute(void_ptr);\n-                    tls::set(key, ptr::null_mut());\n-                    Some(ptr)\n-                }\n-            }\n-            None => None\n-        }\n-    }\n-\n-    /// Take ownership of a pointer from thread-local storage.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// Does not validate the pointer type.\n-    /// Leaves the old pointer in TLS for speed.\n-    #[inline]\n-    pub unsafe fn unsafe_take<T>() -> Box<T> {\n-        let key = tls_key();\n-        let void_ptr: *mut u8 = tls::get(key);\n-        if void_ptr.is_null() {\n-            rtabort!(\"thread-local pointer is null. bogus!\");\n-        }\n-        let ptr: Box<T> = mem::transmute(void_ptr);\n-        return ptr;\n-    }\n-\n-    /// Check whether there is a thread-local pointer installed.\n-    pub fn exists() -> bool {\n-        unsafe {\n-            match maybe_tls_key() {\n-                Some(key) => tls::get(key).is_not_null(),\n-                None => false\n-            }\n-        }\n-    }\n-\n-    /// Borrow a mutable reference to the thread-local value\n-    ///\n-    /// # Safety Note\n-    ///\n-    /// Because this leaves the value in thread-local storage it is possible\n-    /// For the Scheduler pointer to be aliased\n-    pub unsafe fn unsafe_borrow<T>() -> *mut T {\n-        let key = tls_key();\n-        let void_ptr = tls::get(key);\n-        if void_ptr.is_null() {\n-            rtabort!(\"thread-local pointer is null. bogus!\");\n-        }\n-        void_ptr as *mut T\n-    }\n-\n-    pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n-        match maybe_tls_key() {\n-            Some(key) => {\n-                let void_ptr = tls::get(key);\n-                if void_ptr.is_null() {\n-                    None\n-                } else {\n-                    Some(void_ptr as *mut T)\n-                }\n-            }\n-            None => None\n-        }\n-    }\n-\n-    #[inline]\n-    fn tls_key() -> tls::Key {\n-        match maybe_tls_key() {\n-            Some(key) => key,\n-            None => rtabort!(\"runtime tls key not initialized\")\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(test))]\n-    pub fn maybe_tls_key() -> Option<tls::Key> {\n-        unsafe {\n-            // NB: This is a little racy because, while the key is\n-            // initialized under a mutex and it's assumed to be initialized\n-            // in the Scheduler ctor by any thread that needs to use it,\n-            // we are not accessing the key under a mutex.  Threads that\n-            // are not using the new Scheduler but still *want to check*\n-            // whether they are running under a new Scheduler may see a 0\n-            // value here that is in the process of being initialized in\n-            // another thread. I think this is fine since the only action\n-            // they could take if it was initialized would be to check the\n-            // thread-local value and see that it's not set.\n-            if RT_TLS_KEY != -1 {\n-                return Some(RT_TLS_KEY);\n-            } else {\n-                return None;\n-            }\n-        }\n-    }\n-\n-    #[inline] #[cfg(test)]\n-    pub fn maybe_tls_key() -> Option<tls::Key> {\n-        use rt;\n-        unsafe {\n-            mem::transmute(::realstd::rt::shouldnt_be_public::maybe_tls_key())\n-        }\n-    }\n-}"}, {"sha": "8ef7ac43a30efe8d4c5a2f59dd5c26f56f7ea26a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84cb6cd9386ab01ba59f8ed98d698f9af74e65fe/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84cb6cd9386ab01ba59f8ed98d698f9af74e65fe/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=84cb6cd9386ab01ba59f8ed98d698f9af74e65fe", "patch": "@@ -75,13 +75,15 @@ pub mod mutex;\n pub mod thread;\n pub mod exclusive;\n pub mod util;\n+<<<<<<< HEAD\n+=======\n+pub mod task;\n+>>>>>>> Remove rt::{local, local_data, thread_local_storage}\n pub mod unwind;\n \n mod args;\n mod at_exit_imp;\n mod libunwind;\n-mod local_ptr;\n-mod thread_local_storage;\n \n /// The default error code of the rust runtime if the main task panics instead\n /// of exiting cleanly.\n@@ -98,8 +100,7 @@ pub fn init(argc: int, argv: *const *const u8) {\n     // Need to propagate the unsafety to `start`.\n     unsafe {\n         args::init(argc, argv);\n-        sys::thread::guard::init();\n-        sys::stack_overflow::init();\n+        thread::init();\n         unwind::register(failure::on_fail);\n     }\n }\n@@ -203,7 +204,7 @@ pub fn at_exit(f: proc():Send) {\n /// undefined behavior.\n pub unsafe fn cleanup() {\n     args::cleanup();\n-    sys::stack_overflow::cleanup();\n+    thread::cleanup();\n }\n \n // FIXME: these probably shouldn't be public..."}, {"sha": "9eb7048f1e699d31a5d09eb02b5f03e13fecb283", "filename": "src/libstd/rt/thread.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/84cb6cd9386ab01ba59f8ed98d698f9af74e65fe/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84cb6cd9386ab01ba59f8ed98d698f9af74e65fe/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=84cb6cd9386ab01ba59f8ed98d698f9af74e65fe", "patch": "@@ -0,0 +1,170 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Native os-thread management\n+//!\n+//! This modules contains bindings necessary for managing OS-level threads.\n+//! These functions operate outside of the rust runtime, creating threads\n+//! which are not used for scheduling in any way.\n+\n+#![allow(non_camel_case_types)]\n+\n+use core::prelude::*;\n+\n+use boxed::Box;\n+use mem;\n+use sys::stack_overflow;\n+use sys::thread as imp;\n+\n+pub unsafe fn init() {\n+    imp::guard::init();\n+    stack_overflow::init();\n+}\n+\n+pub unsafe fn cleanup() {\n+    stack_overflow::cleanup();\n+}\n+\n+/// This struct represents a native thread's state. This is used to join on an\n+/// existing thread created in the join-able state.\n+pub struct Thread<T> {\n+    native: imp::rust_thread,\n+    joined: bool,\n+    packet: Box<Option<T>>,\n+}\n+\n+static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n+\n+/// Returns the last writable byte of the main thread's stack next to the guard\n+/// page. Must be called from the main thread.\n+pub fn main_guard_page() -> uint {\n+    unsafe {\n+        imp::guard::main()\n+    }\n+}\n+\n+/// Returns the last writable byte of the current thread's stack next to the\n+/// guard page. Must not be called from the main thread.\n+pub fn current_guard_page() -> uint {\n+    unsafe {\n+        imp::guard::current()\n+    }\n+}\n+\n+// There are two impl blocks b/c if T were specified at the top then it's just a\n+// pain to specify a type parameter on Thread::spawn (which doesn't need the\n+// type parameter).\n+impl Thread<()> {\n+    /// Starts execution of a new OS thread.\n+    ///\n+    /// This function will not wait for the thread to join, but a handle to the\n+    /// thread will be returned.\n+    ///\n+    /// Note that the handle returned is used to acquire the return value of the\n+    /// procedure `main`. The `join` function will wait for the thread to finish\n+    /// and return the value that `main` generated.\n+    ///\n+    /// Also note that the `Thread` returned will *always* wait for the thread\n+    /// to finish executing. This means that even if `join` is not explicitly\n+    /// called, when the `Thread` falls out of scope its destructor will block\n+    /// waiting for the OS thread.\n+    pub fn start<T: Send>(main: proc():Send -> T) -> Thread<T> {\n+        Thread::start_stack(DEFAULT_STACK_SIZE, main)\n+    }\n+\n+    /// Performs the same functionality as `start`, but specifies an explicit\n+    /// stack size for the new thread.\n+    pub fn start_stack<T: Send>(stack: uint, main: proc():Send -> T) -> Thread<T> {\n+\n+        // We need the address of the packet to fill in to be stable so when\n+        // `main` fills it in it's still valid, so allocate an extra box to do\n+        // so.\n+        let packet = box None;\n+        let packet2: *mut Option<T> = unsafe {\n+            *mem::transmute::<&Box<Option<T>>, *const *mut Option<T>>(&packet)\n+        };\n+        let main = proc() unsafe { *packet2 = Some(main()); };\n+        let native = unsafe { imp::create(stack, box main) };\n+\n+        Thread {\n+            native: native,\n+            joined: false,\n+            packet: packet,\n+        }\n+    }\n+\n+    /// This will spawn a new thread, but it will not wait for the thread to\n+    /// finish, nor is it possible to wait for the thread to finish.\n+    ///\n+    /// This corresponds to creating threads in the 'detached' state on unix\n+    /// systems. Note that platforms may not keep the main program alive even if\n+    /// there are detached thread still running around.\n+    pub fn spawn(main: proc():Send) {\n+        Thread::spawn_stack(DEFAULT_STACK_SIZE, main)\n+    }\n+\n+    /// Performs the same functionality as `spawn`, but explicitly specifies a\n+    /// stack size for the new thread.\n+    pub fn spawn_stack(stack: uint, main: proc():Send) {\n+        unsafe {\n+            let handle = imp::create(stack, box main);\n+            imp::detach(handle);\n+        }\n+    }\n+\n+    /// Relinquishes the CPU slot that this OS-thread is currently using,\n+    /// allowing another thread to run for awhile.\n+    pub fn yield_now() {\n+        unsafe { imp::yield_now(); }\n+    }\n+}\n+\n+impl<T: Send> Thread<T> {\n+    /// Wait for this thread to finish, returning the result of the thread's\n+    /// calculation.\n+    pub fn join(mut self) -> T {\n+        assert!(!self.joined);\n+        unsafe { imp::join(self.native) };\n+        self.joined = true;\n+        assert!(self.packet.is_some());\n+        self.packet.take().unwrap()\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for Thread<T> {\n+    fn drop(&mut self) {\n+        // This is required for correctness. If this is not done then the thread\n+        // would fill in a return box which no longer exists.\n+        if !self.joined {\n+            unsafe { imp::join(self.native) };\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::Thread;\n+\n+    #[test]\n+    fn smoke() { Thread::start(proc (){}).join(); }\n+\n+    #[test]\n+    fn data() { assert_eq!(Thread::start(proc () { 1i }).join(), 1); }\n+\n+    #[test]\n+    fn detached() { Thread::spawn(proc () {}) }\n+\n+    #[test]\n+    fn small_stacks() {\n+        assert_eq!(42i, Thread::start_stack(0, proc () 42i).join());\n+        assert_eq!(42i, Thread::start_stack(1, proc () 42i).join());\n+    }\n+}"}, {"sha": "ee6ad8a4e08e80e42d52dc9597bc9360c24a739e", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "patch": "@@ -1,115 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(dead_code)]\n-\n-#[cfg(unix)] use libc::c_int;\n-#[cfg(unix)] use ptr::null;\n-#[cfg(windows)] use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n-\n-#[cfg(unix)]\n-pub type Key = pthread_key_t;\n-\n-#[cfg(unix)]\n-pub unsafe fn create(key: &mut Key) {\n-    assert!(pthread_key_create(key, null()) == 0);\n-}\n-\n-#[cfg(unix)]\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    assert!(pthread_setspecific(key, value) == 0);\n-}\n-\n-#[cfg(unix)]\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    pthread_getspecific(key)\n-}\n-\n-#[cfg(unix)]\n-pub unsafe fn destroy(key: Key) {\n-    assert!(pthread_key_delete(key) == 0);\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-#[allow(non_camel_case_types)] // foreign type\n-type pthread_key_t = ::libc::c_ulong;\n-\n-#[cfg(any(target_os=\"linux\",\n-          target_os=\"freebsd\",\n-          target_os=\"dragonfly\",\n-          target_os=\"android\",\n-          target_os = \"ios\"))]\n-#[allow(non_camel_case_types)] // foreign type\n-type pthread_key_t = ::libc::c_uint;\n-\n-#[cfg(unix)]\n-extern {\n-    fn pthread_key_create(key: *mut pthread_key_t, dtor: *const u8) -> c_int;\n-    fn pthread_key_delete(key: pthread_key_t) -> c_int;\n-    fn pthread_getspecific(key: pthread_key_t) -> *mut u8;\n-    fn pthread_setspecific(key: pthread_key_t, value: *mut u8) -> c_int;\n-}\n-\n-#[cfg(windows)]\n-pub type Key = DWORD;\n-\n-#[cfg(windows)]\n-pub unsafe fn create(key: &mut Key) {\n-    static TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n-    *key = TlsAlloc();\n-    assert!(*key != TLS_OUT_OF_INDEXES);\n-}\n-\n-#[cfg(windows)]\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    assert!(0 != TlsSetValue(key, value as *mut ::libc::c_void))\n-}\n-\n-#[cfg(windows)]\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    TlsGetValue(key) as *mut u8\n-}\n-\n-#[cfg(windows)]\n-pub unsafe fn destroy(key: Key) {\n-    assert!(TlsFree(key) != 0);\n-}\n-\n-#[cfg(windows)]\n-#[allow(non_snake_case)]\n-extern \"system\" {\n-    fn TlsAlloc() -> DWORD;\n-    fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n-    fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n-    fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-    use super::*;\n-\n-    #[test]\n-    fn tls_smoke_test() {\n-        use mem::transmute;\n-        unsafe {\n-            let mut key = 0;\n-            let value = box 20i;\n-            create(&mut key);\n-            set(key, transmute(value));\n-            let value: Box<int> = transmute(get(key));\n-            assert_eq!(value, box 20i);\n-            let value = box 30i;\n-            set(key, transmute(value));\n-            let value: Box<int> = transmute(get(key));\n-            assert_eq!(value, box 30i);\n-        }\n-    }\n-}"}]}