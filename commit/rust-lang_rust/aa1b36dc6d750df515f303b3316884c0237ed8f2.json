{"sha": "aa1b36dc6d750df515f303b3316884c0237ed8f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMWIzNmRjNmQ3NTBkZjUxNWYzMDNiMzMxNjg4NGMwMjM3ZWQ4ZjI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-13T22:04:04Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-13T22:04:04Z"}, "message": "Downmap the token in attribute inputs when expanding speculatively", "tree": {"sha": "d76354a2b56fe57f5b71e599304675a30db400e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d76354a2b56fe57f5b71e599304675a30db400e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa1b36dc6d750df515f303b3316884c0237ed8f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1b36dc6d750df515f303b3316884c0237ed8f2", "html_url": "https://github.com/rust-lang/rust/commit/aa1b36dc6d750df515f303b3316884c0237ed8f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa1b36dc6d750df515f303b3316884c0237ed8f2/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b907652ee76c150afaf8b599bb985d502d2afae", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b907652ee76c150afaf8b599bb985d502d2afae", "html_url": "https://github.com/rust-lang/rust/commit/2b907652ee76c150afaf8b599bb985d502d2afae"}], "stats": {"total": 177, "additions": 155, "deletions": 22}, "files": [{"sha": "3526778b68f6e273918cb95e965bcfec002d22cd", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/aa1b36dc6d750df515f303b3316884c0237ed8f2/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1b36dc6d750df515f303b3316884c0237ed8f2/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=aa1b36dc6d750df515f303b3316884c0237ed8f2", "patch": "@@ -258,12 +258,23 @@ fn test_proc_macros(proc_macros: &[String]) -> (Vec<ProcMacro>, String) {\n pub fn identity(_attr: TokenStream, item: TokenStream) -> TokenStream {\n     item\n }\n+#[proc_macro_attribute]\n+pub fn input_replace(attr: TokenStream, _item: TokenStream) -> TokenStream {\n+    attr\n+}\n \"#;\n-    let proc_macros = std::array::IntoIter::new([ProcMacro {\n-        name: \"identity\".into(),\n-        kind: crate::ProcMacroKind::Attr,\n-        expander: Arc::new(IdentityProcMacroExpander),\n-    }])\n+    let proc_macros = std::array::IntoIter::new([\n+        ProcMacro {\n+            name: \"identity\".into(),\n+            kind: crate::ProcMacroKind::Attr,\n+            expander: Arc::new(IdentityProcMacroExpander),\n+        },\n+        ProcMacro {\n+            name: \"input_replace\".into(),\n+            kind: crate::ProcMacroKind::Attr,\n+            expander: Arc::new(AttributeInputReplaceProcMacroExpander),\n+        },\n+    ])\n     .filter(|pm| proc_macros.iter().any(|name| name == &pm.name))\n     .collect();\n     (proc_macros, source.into())\n@@ -308,8 +319,9 @@ impl From<Fixture> for FileMeta {\n     }\n }\n \n+// Identity mapping\n #[derive(Debug)]\n-pub struct IdentityProcMacroExpander;\n+struct IdentityProcMacroExpander;\n impl ProcMacroExpander for IdentityProcMacroExpander {\n     fn expand(\n         &self,\n@@ -320,3 +332,19 @@ impl ProcMacroExpander for IdentityProcMacroExpander {\n         Ok(subtree.clone())\n     }\n }\n+\n+// Pastes the attribute input as its output\n+#[derive(Debug)]\n+struct AttributeInputReplaceProcMacroExpander;\n+impl ProcMacroExpander for AttributeInputReplaceProcMacroExpander {\n+    fn expand(\n+        &self,\n+        _: &Subtree,\n+        attrs: Option<&Subtree>,\n+        _: &Env,\n+    ) -> Result<Subtree, ProcMacroExpansionError> {\n+        attrs\n+            .cloned()\n+            .ok_or_else(|| ProcMacroExpansionError::Panic(\"Expected attribute input\".into()))\n+    }\n+}"}, {"sha": "e1ff646b8b7bf29e75bf26b68dfb14f1c9909ec8", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/aa1b36dc6d750df515f303b3316884c0237ed8f2/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1b36dc6d750df515f303b3316884c0237ed8f2/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=aa1b36dc6d750df515f303b3316884c0237ed8f2", "patch": "@@ -5,7 +5,7 @@ use std::sync::Arc;\n use base_db::{salsa, SourceDatabase};\n use itertools::Itertools;\n use limit::Limit;\n-use mbe::{ExpandError, ExpandResult};\n+use mbe::{syntax_node_to_token_tree, ExpandError, ExpandResult};\n use syntax::{\n     algo::diff,\n     ast::{self, AttrsOwner, NameOwner},\n@@ -146,24 +146,57 @@ pub fn expand_speculative(\n ) -> Option<(SyntaxNode, SyntaxToken)> {\n     let loc = db.lookup_intern_macro(actual_macro_call);\n     let macro_def = db.macro_def(loc.def)?;\n+    let token_range = token_to_map.text_range();\n \n-    // Fetch token id in the speculative args\n+    // Build the subtree and token mapping for the speculative args\n     let censor = censor_for_macro_input(&loc, &speculative_args);\n-    let (tt, args_tmap) = mbe::syntax_node_to_token_tree_censored(&speculative_args, censor);\n-    let range = token_to_map.text_range().checked_sub(speculative_args.text_range().start())?;\n-    let token_id = args_tmap.token_by_range(range)?;\n-\n-    let speculative_expansion = if let MacroDefKind::ProcMacro(expander, ..) = loc.def.kind {\n-        let attr_arg = match &loc.kind {\n-            // FIXME make attr arg speculative as well\n-            MacroCallKind::Attr { attr_args, .. } => {\n-                let mut attr_args = attr_args.0.clone();\n-                mbe::Shift::new(&tt).shift_all(&mut attr_args);\n-                Some(attr_args)\n+    let (mut tt, spec_args_tmap) =\n+        mbe::syntax_node_to_token_tree_censored(&speculative_args, censor);\n+\n+    let (attr_arg, token_id) = match loc.kind {\n+        MacroCallKind::Attr { invoc_attr_index, .. } => {\n+            // Attributes may have an input token tree, build the subtree and map for this as well\n+            // then try finding a token id for our token if it is inside this input subtree.\n+            let item = ast::Item::cast(speculative_args.clone())?;\n+            let attr = item.attrs().nth(invoc_attr_index as usize)?;\n+            match attr.token_tree() {\n+                Some(token_tree) => {\n+                    let (mut tree, map) = syntax_node_to_token_tree(attr.token_tree()?.syntax());\n+                    tree.delimiter = None;\n+\n+                    let shift = mbe::Shift::new(&tt);\n+                    shift.shift_all(&mut tree);\n+\n+                    let token_id = if token_tree.syntax().text_range().contains_range(token_range) {\n+                        let attr_input_start =\n+                            token_tree.left_delimiter_token()?.text_range().start();\n+                        let range = token_range.checked_sub(attr_input_start)?;\n+                        let token_id = shift.shift(map.token_by_range(range)?);\n+                        Some(token_id)\n+                    } else {\n+                        None\n+                    };\n+                    (Some(tree), token_id)\n+                }\n+                _ => (None, None),\n             }\n-            _ => None,\n-        };\n+        }\n+        _ => (None, None),\n+    };\n+    let token_id = match token_id {\n+        Some(token_id) => token_id,\n+        // token wasn't inside an attribute input so it has to be in the general macro input\n+        None => {\n+            let range = token_range.checked_sub(speculative_args.text_range().start())?;\n+            let token_id = spec_args_tmap.token_by_range(range)?;\n+            macro_def.map_id_down(token_id)\n+        }\n+    };\n \n+    // Do the actual expansion, we need to directly expand the proc macro due to the attribute args\n+    // Otherwise the expand query will fetch the non speculative attribute args and pass those instead.\n+    let speculative_expansion = if let MacroDefKind::ProcMacro(expander, ..) = loc.def.kind {\n+        tt.delimiter = None;\n         expander.expand(db, loc.krate, &tt, attr_arg.as_ref())\n     } else {\n         macro_def.expand(db, actual_macro_call, &tt)\n@@ -173,7 +206,6 @@ pub fn expand_speculative(\n     let (node, rev_tmap) =\n         token_tree_to_syntax_node(&speculative_expansion.value, expand_to).ok()?;\n \n-    let token_id = macro_def.map_id_down(token_id);\n     let range = rev_tmap.first_range_by_token(token_id, token_to_map.kind())?;\n     let token = node.syntax_node().covering_element(range).into_token()?;\n     Some((node.syntax_node(), token))"}, {"sha": "1ec952d49c980dec318d574da3c3cf7461908b7a", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa1b36dc6d750df515f303b3316884c0237ed8f2/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1b36dc6d750df515f303b3316884c0237ed8f2/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=aa1b36dc6d750df515f303b3316884c0237ed8f2", "patch": "@@ -183,6 +183,7 @@ impl<'a> CompletionContext<'a> {\n         );\n         Some(ctx)\n     }\n+\n     fn expand_and_fill(\n         &mut self,\n         mut original_file: SyntaxNode,\n@@ -191,6 +192,7 @@ impl<'a> CompletionContext<'a> {\n         mut fake_ident_token: SyntaxToken,\n     ) {\n         loop {\n+            // Expand attributes\n             if let (Some(actual_item), Some(item_with_fake_ident)) = (\n                 find_node_at_offset::<ast::Item>(&original_file, offset),\n                 find_node_at_offset::<ast::Item>(&speculative_file, offset),\n@@ -219,6 +221,7 @@ impl<'a> CompletionContext<'a> {\n                 }\n             }\n \n+            // Expand fn-like macro calls\n             if let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n                 find_node_at_offset::<ast::MacroCall>(&original_file, offset),\n                 find_node_at_offset::<ast::MacroCall>(&speculative_file, offset),"}, {"sha": "73fc293526f7afc5ca8d51483799834d00b0f5c4", "filename": "crates/ide_completion/src/tests/proc_macros.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/aa1b36dc6d750df515f303b3316884c0237ed8f2/crates%2Fide_completion%2Fsrc%2Ftests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1b36dc6d750df515f303b3316884c0237ed8f2/crates%2Fide_completion%2Fsrc%2Ftests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fproc_macros.rs?ref=aa1b36dc6d750df515f303b3316884c0237ed8f2", "patch": "@@ -73,3 +73,73 @@ fn main() {\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn complete_dot_in_attr_input() {\n+    check(\n+        r#\"\n+//- proc_macros: input_replace\n+pub struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+#[proc_macros::input_replace(\n+    fn suprise() {\n+        Foo.$0\n+    }\n+)]\n+fn main() {}\n+\"#,\n+        expect![[r#\"\n+            me foo() fn(&self)\n+            sn ref   &expr\n+            sn refm  &mut expr\n+            sn match match expr {}\n+            sn box   Box::new(expr)\n+            sn ok    Ok(expr)\n+            sn err   Err(expr)\n+            sn some  Some(expr)\n+            sn dbg   dbg!(expr)\n+            sn dbgr  dbg!(&expr)\n+            sn call  function(expr)\n+            sn let   let\n+            sn letm  let mut\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn complete_dot_in_attr_input2() {\n+    check(\n+        r#\"\n+//- proc_macros: input_replace\n+pub struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+#[proc_macros::input_replace(\n+    fn suprise() {\n+        Foo.f$0\n+    }\n+)]\n+fn main() {}\n+\"#,\n+        expect![[r#\"\n+            me foo() fn(&self)\n+            sn ref   &expr\n+            sn refm  &mut expr\n+            sn match match expr {}\n+            sn box   Box::new(expr)\n+            sn ok    Ok(expr)\n+            sn err   Err(expr)\n+            sn some  Some(expr)\n+            sn dbg   dbg!(expr)\n+            sn dbgr  dbg!(&expr)\n+            sn call  function(expr)\n+            sn let   let\n+            sn letm  let mut\n+        \"#]],\n+    )\n+}"}]}