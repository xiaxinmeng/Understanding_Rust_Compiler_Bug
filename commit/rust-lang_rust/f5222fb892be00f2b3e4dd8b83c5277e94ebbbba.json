{"sha": "f5222fb892be00f2b3e4dd8b83c5277e94ebbbba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MjIyZmI4OTJiZTAwZjJiM2U0ZGQ4YjgzYzUyNzdlOTRlYmJiYmE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-05-12T04:09:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-05-19T17:53:07Z"}, "message": "std: Implement aborting stubs for MSVC unwinding\n\nAt this time unwinding support is not implemented for MSVC as\n`libgcc_s_seh-1.dll` is not available by default (and this is used on MinGW),\nbut this should be investigated soon. For now this change is just aimed at\ngetting the compiler far enough to bootstrap everything instead of successfully\nrunning tests.\n\nThis commit refactors the `std::rt::unwind` module a bit to prepare for SEH\nsupport eventually by moving all GCC-specific functionality to its own submodule\nand defining the interface needed.", "tree": {"sha": "8f749c5bfaddcceb20e2d48fd2aee391bb38e3a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f749c5bfaddcceb20e2d48fd2aee391bb38e3a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5222fb892be00f2b3e4dd8b83c5277e94ebbbba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5222fb892be00f2b3e4dd8b83c5277e94ebbbba", "html_url": "https://github.com/rust-lang/rust/commit/f5222fb892be00f2b3e4dd8b83c5277e94ebbbba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5222fb892be00f2b3e4dd8b83c5277e94ebbbba/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "847c8520b14e3ae9aec26a33f70750a071d3f18d", "url": "https://api.github.com/repos/rust-lang/rust/commits/847c8520b14e3ae9aec26a33f70750a071d3f18d", "html_url": "https://github.com/rust-lang/rust/commit/847c8520b14e3ae9aec26a33f70750a071d3f18d"}], "stats": {"total": 717, "additions": 389, "deletions": 328}, "files": [{"sha": "39b32a3f08e4970f72f3fd7fa3bf128688a09c55", "filename": "src/libstd/rt/unwind/gcc.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/f5222fb892be00f2b3e4dd8b83c5277e94ebbbba/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5222fb892be00f2b3e4dd8b83c5277e94ebbbba/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs?ref=f5222fb892be00f2b3e4dd8b83c5277e94ebbbba", "patch": "@@ -0,0 +1,342 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use any::Any;\n+use boxed;\n+use libc::c_void;\n+use rt::libunwind as uw;\n+\n+struct Exception {\n+    uwe: uw::_Unwind_Exception,\n+    cause: Option<Box<Any + Send + 'static>>,\n+}\n+\n+pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n+    let exception: Box<_> = box Exception {\n+        uwe: uw::_Unwind_Exception {\n+            exception_class: rust_exception_class(),\n+            exception_cleanup: exception_cleanup,\n+            private: [0; uw::unwinder_private_data_size],\n+        },\n+        cause: Some(data),\n+    };\n+    let exception_param = boxed::into_raw(exception) as *mut uw::_Unwind_Exception;\n+    let error = uw::_Unwind_RaiseException(exception_param);\n+    rtabort!(\"Could not unwind stack, error = {}\", error as isize);\n+\n+    extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n+                                exception: *mut uw::_Unwind_Exception) {\n+        rtdebug!(\"exception_cleanup()\");\n+        unsafe {\n+            let _: Box<Exception> = Box::from_raw(exception as *mut Exception);\n+        }\n+    }\n+}\n+\n+pub unsafe fn cleanup(ptr: *mut c_void) -> Box<Any + Send + 'static> {\n+    let my_ep = ptr as *mut Exception;\n+    rtdebug!(\"caught {}\", (*my_ep).uwe.exception_class);\n+    let cause = (*my_ep).cause.take();\n+    uw::_Unwind_DeleteException(ptr as *mut _);\n+    cause.unwrap()\n+}\n+\n+// Rust's exception class identifier.  This is used by personality routines to\n+// determine whether the exception was thrown by their own runtime.\n+fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n+    // M O Z \\0  R U S T -- vendor, language\n+    0x4d4f5a_00_52555354\n+}\n+\n+// We could implement our personality routine in pure Rust, however exception\n+// info decoding is tedious.  More importantly, personality routines have to\n+// handle various platform quirks, which are not fun to maintain.  For this\n+// reason, we attempt to reuse personality routine of the C language:\n+// __gcc_personality_v0.\n+//\n+// Since C does not support exception catching, __gcc_personality_v0 simply\n+// always returns _URC_CONTINUE_UNWIND in search phase, and always returns\n+// _URC_INSTALL_CONTEXT (i.e. \"invoke cleanup code\") in cleanup phase.\n+//\n+// This is pretty close to Rust's exception handling approach, except that Rust\n+// does have a single \"catch-all\" handler at the bottom of each thread's stack.\n+// So we have two versions of the personality routine:\n+// - rust_eh_personality, used by all cleanup landing pads, which never catches,\n+//   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n+// - rust_eh_personality_catch, used only by rust_try(), which always catches.\n+//\n+// Note, however, that for implementation simplicity, rust_eh_personality_catch\n+// lacks code to install a landing pad, so in order to obtain exception object\n+// pointer (which it needs to return upstream), rust_try() employs another trick:\n+// it calls into the nested rust_try_inner(), whose landing pad does not resume\n+// unwinds.  Instead, it extracts the exception pointer and performs a \"normal\"\n+// return.\n+//\n+// See also: rt/rust_try.ll\n+\n+#[cfg(all(not(target_arch = \"arm\"),\n+          not(all(windows, target_arch = \"x86_64\")),\n+          not(test)))]\n+pub mod eabi {\n+    use rt::libunwind as uw;\n+    use libc::c_int;\n+\n+    extern \"C\" {\n+        fn __gcc_personality_v0(version: c_int,\n+                                actions: uw::_Unwind_Action,\n+                                exception_class: uw::_Unwind_Exception_Class,\n+                                ue_header: *mut uw::_Unwind_Exception,\n+                                context: *mut uw::_Unwind_Context)\n+            -> uw::_Unwind_Reason_Code;\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // referenced from rust_try.ll\n+    #[allow(private_no_mangle_fns)]\n+    extern fn rust_eh_personality(\n+        version: c_int,\n+        actions: uw::_Unwind_Action,\n+        exception_class: uw::_Unwind_Exception_Class,\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        unsafe {\n+            __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                                 context)\n+        }\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        _version: c_int,\n+        actions: uw::_Unwind_Action,\n+        _exception_class: uw::_Unwind_Exception_Class,\n+        _ue_header: *mut uw::_Unwind_Exception,\n+        _context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+\n+        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+            uw::_URC_HANDLER_FOUND // catch!\n+        }\n+        else { // cleanup phase\n+            uw::_URC_INSTALL_CONTEXT\n+        }\n+    }\n+}\n+\n+// iOS on armv7 is using SjLj exceptions and therefore requires to use\n+// a specialized personality routine: __gcc_personality_sj0\n+\n+#[cfg(all(target_os = \"ios\", target_arch = \"arm\", not(test)))]\n+pub mod eabi {\n+    use rt::libunwind as uw;\n+    use libc::c_int;\n+\n+    extern \"C\" {\n+        fn __gcc_personality_sj0(version: c_int,\n+                                actions: uw::_Unwind_Action,\n+                                exception_class: uw::_Unwind_Exception_Class,\n+                                ue_header: *mut uw::_Unwind_Exception,\n+                                context: *mut uw::_Unwind_Context)\n+            -> uw::_Unwind_Reason_Code;\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality(\n+        version: c_int,\n+        actions: uw::_Unwind_Action,\n+        exception_class: uw::_Unwind_Exception_Class,\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        unsafe {\n+            __gcc_personality_sj0(version, actions, exception_class, ue_header,\n+                                  context)\n+        }\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        _version: c_int,\n+        actions: uw::_Unwind_Action,\n+        _exception_class: uw::_Unwind_Exception_Class,\n+        _ue_header: *mut uw::_Unwind_Exception,\n+        _context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+            uw::_URC_HANDLER_FOUND // catch!\n+        }\n+        else { // cleanup phase\n+            unsafe {\n+                __gcc_personality_sj0(_version, actions, _exception_class, _ue_header,\n+                                      _context)\n+            }\n+        }\n+    }\n+}\n+\n+\n+// ARM EHABI uses a slightly different personality routine signature,\n+// but otherwise works the same.\n+#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(test)))]\n+pub mod eabi {\n+    use rt::libunwind as uw;\n+    use libc::c_int;\n+\n+    extern \"C\" {\n+        fn __gcc_personality_v0(state: uw::_Unwind_State,\n+                                ue_header: *mut uw::_Unwind_Exception,\n+                                context: *mut uw::_Unwind_Context)\n+            -> uw::_Unwind_Reason_Code;\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // referenced from rust_try.ll\n+    #[allow(private_no_mangle_fns)]\n+    extern \"C\" fn rust_eh_personality(\n+        state: uw::_Unwind_State,\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        unsafe {\n+            __gcc_personality_v0(state, ue_header, context)\n+        }\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        state: uw::_Unwind_State,\n+        _ue_header: *mut uw::_Unwind_Exception,\n+        _context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        if (state as c_int & uw::_US_ACTION_MASK as c_int)\n+                           == uw::_US_VIRTUAL_UNWIND_FRAME as c_int { // search phase\n+            uw::_URC_HANDLER_FOUND // catch!\n+        }\n+        else { // cleanup phase\n+            uw::_URC_INSTALL_CONTEXT\n+        }\n+    }\n+}\n+\n+// Win64 SEH (see http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx)\n+//\n+// This looks a bit convoluted because rather than implementing a native SEH\n+// handler, GCC reuses the same personality routine as for the other\n+// architectures by wrapping it with an \"API translator\" layer\n+// (_GCC_specific_handler).\n+\n+#[cfg(all(windows, target_arch = \"x86_64\", not(test)))]\n+#[doc(hidden)]\n+#[allow(non_camel_case_types, non_snake_case)]\n+pub mod eabi {\n+    pub use self::EXCEPTION_DISPOSITION::*;\n+    use rt::libunwind as uw;\n+    use libc::{c_void, c_int};\n+\n+    #[repr(C)]\n+    pub struct EXCEPTION_RECORD;\n+    #[repr(C)]\n+    pub struct CONTEXT;\n+    #[repr(C)]\n+    pub struct DISPATCHER_CONTEXT;\n+\n+    #[repr(C)]\n+    #[derive(Copy, Clone)]\n+    pub enum EXCEPTION_DISPOSITION {\n+        ExceptionContinueExecution,\n+        ExceptionContinueSearch,\n+        ExceptionNestedException,\n+        ExceptionCollidedUnwind\n+    }\n+\n+    type _Unwind_Personality_Fn =\n+        extern \"C\" fn(\n+            version: c_int,\n+            actions: uw::_Unwind_Action,\n+            exception_class: uw::_Unwind_Exception_Class,\n+            ue_header: *mut uw::_Unwind_Exception,\n+            context: *mut uw::_Unwind_Context\n+        ) -> uw::_Unwind_Reason_Code;\n+\n+    extern \"C\" {\n+        fn __gcc_personality_seh0(\n+            exceptionRecord: *mut EXCEPTION_RECORD,\n+            establisherFrame: *mut c_void,\n+            contextRecord: *mut CONTEXT,\n+            dispatcherContext: *mut DISPATCHER_CONTEXT\n+        ) -> EXCEPTION_DISPOSITION;\n+\n+        fn _GCC_specific_handler(\n+            exceptionRecord: *mut EXCEPTION_RECORD,\n+            establisherFrame: *mut c_void,\n+            contextRecord: *mut CONTEXT,\n+            dispatcherContext: *mut DISPATCHER_CONTEXT,\n+            personality: _Unwind_Personality_Fn\n+        ) -> EXCEPTION_DISPOSITION;\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // referenced from rust_try.ll\n+    #[allow(private_no_mangle_fns)]\n+    extern \"C\" fn rust_eh_personality(\n+        exceptionRecord: *mut EXCEPTION_RECORD,\n+        establisherFrame: *mut c_void,\n+        contextRecord: *mut CONTEXT,\n+        dispatcherContext: *mut DISPATCHER_CONTEXT\n+    ) -> EXCEPTION_DISPOSITION\n+    {\n+        unsafe {\n+            __gcc_personality_seh0(exceptionRecord, establisherFrame,\n+                                   contextRecord, dispatcherContext)\n+        }\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        exceptionRecord: *mut EXCEPTION_RECORD,\n+        establisherFrame: *mut c_void,\n+        contextRecord: *mut CONTEXT,\n+        dispatcherContext: *mut DISPATCHER_CONTEXT\n+    ) -> EXCEPTION_DISPOSITION\n+    {\n+        extern \"C\" fn inner(\n+                _version: c_int,\n+                actions: uw::_Unwind_Action,\n+                _exception_class: uw::_Unwind_Exception_Class,\n+                _ue_header: *mut uw::_Unwind_Exception,\n+                _context: *mut uw::_Unwind_Context\n+            ) -> uw::_Unwind_Reason_Code\n+        {\n+            if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+                uw::_URC_HANDLER_FOUND // catch!\n+            }\n+            else { // cleanup phase\n+                uw::_URC_INSTALL_CONTEXT\n+            }\n+        }\n+\n+        unsafe {\n+            _GCC_specific_handler(exceptionRecord, establisherFrame,\n+                                  contextRecord, dispatcherContext,\n+                                  inner)\n+        }\n+    }\n+}\n+"}, {"sha": "9cbe6c4048324c38af0bc3a423328b6b99e7b1dc", "filename": "src/libstd/rt/unwind/mod.rs", "status": "renamed", "additions": 17, "deletions": 328, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/f5222fb892be00f2b3e4dd8b83c5277e94ebbbba/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5222fb892be00f2b3e4dd8b83c5277e94ebbbba/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fmod.rs?ref=f5222fb892be00f2b3e4dd8b83c5277e94ebbbba", "patch": "@@ -57,6 +57,9 @@\n //!\n //! Currently Rust uses unwind runtime provided by libgcc.\n \n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n use prelude::v1::*;\n \n use any::Any;\n@@ -71,12 +74,13 @@ use mem;\n use sync::atomic::{self, Ordering};\n use sys_common::mutex::{Mutex, MUTEX_INIT};\n \n-use rt::libunwind as uw;\n-\n-struct Exception {\n-    uwe: uw::_Unwind_Exception,\n-    cause: Option<Box<Any + Send + 'static>>,\n-}\n+// The actual unwinding implementation is cfg'd here, and we've got two current\n+// implementations. One goes through SEH on Windows and the other goes through\n+// libgcc via the libunwind-like API.\n+#[cfg(target_env = \"msvc\")] #[path = \"seh.rs\"] #[doc(hidden)]\n+pub mod imp;\n+#[cfg(not(target_env = \"msvc\"))] #[path = \"gcc.rs\"] #[doc(hidden)]\n+pub mod imp;\n \n pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: u32);\n \n@@ -97,6 +101,10 @@ static CALLBACK_CNT: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n \n thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n \n+#[link(name = \"rustrt_native\", kind = \"static\")]\n+#[cfg(not(test))]\n+extern {}\n+\n /// Invoke a closure, capturing the cause of panic if one occurs.\n ///\n /// This function will return `Ok(())` if the closure did not panic, and will\n@@ -127,29 +135,21 @@ pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n     return if ep.is_null() {\n         Ok(())\n     } else {\n-        let my_ep = ep as *mut Exception;\n-        rtdebug!(\"caught {}\", (*my_ep).uwe.exception_class);\n-        let cause = (*my_ep).cause.take();\n-        uw::_Unwind_DeleteException(ep);\n-        Err(cause.unwrap())\n+        Err(imp::cleanup(ep))\n     };\n \n     extern fn try_fn<F: FnOnce()>(opt_closure: *mut c_void) {\n         let opt_closure = opt_closure as *mut Option<F>;\n         unsafe { (*opt_closure).take().unwrap()(); }\n     }\n \n-    #[link(name = \"rustrt_native\", kind = \"static\")]\n-    #[cfg(not(test))]\n-    extern {}\n-\n     extern {\n         // Rust's try-catch\n         // When f(...) returns normally, the return value is null.\n         // When f(...) throws, the return value is a pointer to the caught\n         // exception object.\n         fn rust_try(f: extern fn(*mut c_void),\n-                    data: *mut c_void) -> *mut uw::_Unwind_Exception;\n+                    data: *mut c_void) -> *mut c_void;\n     }\n }\n \n@@ -164,319 +164,8 @@ pub fn panicking() -> bool {\n #[allow(private_no_mangle_fns)]\n fn rust_panic(cause: Box<Any + Send + 'static>) -> ! {\n     rtdebug!(\"begin_unwind()\");\n-\n     unsafe {\n-        let exception: Box<_> = box Exception {\n-            uwe: uw::_Unwind_Exception {\n-                exception_class: rust_exception_class(),\n-                exception_cleanup: exception_cleanup,\n-                private: [0; uw::unwinder_private_data_size],\n-            },\n-            cause: Some(cause),\n-        };\n-        let exception_param = boxed::into_raw(exception) as *mut uw::_Unwind_Exception;\n-        let error = uw::_Unwind_RaiseException(exception_param);\n-        rtabort!(\"Could not unwind stack, error = {}\", error as isize)\n-    }\n-\n-    extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n-                                exception: *mut uw::_Unwind_Exception) {\n-        rtdebug!(\"exception_cleanup()\");\n-        unsafe {\n-            let _: Box<Exception> = Box::from_raw(exception as *mut Exception);\n-        }\n-    }\n-}\n-\n-// Rust's exception class identifier.  This is used by personality routines to\n-// determine whether the exception was thrown by their own runtime.\n-fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n-    // M O Z \\0  R U S T -- vendor, language\n-    0x4d4f5a_00_52555354\n-}\n-\n-// We could implement our personality routine in pure Rust, however exception\n-// info decoding is tedious.  More importantly, personality routines have to\n-// handle various platform quirks, which are not fun to maintain.  For this\n-// reason, we attempt to reuse personality routine of the C language:\n-// __gcc_personality_v0.\n-//\n-// Since C does not support exception catching, __gcc_personality_v0 simply\n-// always returns _URC_CONTINUE_UNWIND in search phase, and always returns\n-// _URC_INSTALL_CONTEXT (i.e. \"invoke cleanup code\") in cleanup phase.\n-//\n-// This is pretty close to Rust's exception handling approach, except that Rust\n-// does have a single \"catch-all\" handler at the bottom of each thread's stack.\n-// So we have two versions of the personality routine:\n-// - rust_eh_personality, used by all cleanup landing pads, which never catches,\n-//   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n-// - rust_eh_personality_catch, used only by rust_try(), which always catches.\n-//\n-// Note, however, that for implementation simplicity, rust_eh_personality_catch\n-// lacks code to install a landing pad, so in order to obtain exception object\n-// pointer (which it needs to return upstream), rust_try() employs another trick:\n-// it calls into the nested rust_try_inner(), whose landing pad does not resume\n-// unwinds.  Instead, it extracts the exception pointer and performs a \"normal\"\n-// return.\n-//\n-// See also: rt/rust_try.ll\n-\n-#[cfg(all(not(target_arch = \"arm\"),\n-          not(all(windows, target_arch = \"x86_64\")),\n-          not(test)))]\n-#[doc(hidden)]\n-pub mod eabi {\n-    use rt::libunwind as uw;\n-    use libc::c_int;\n-\n-    extern \"C\" {\n-        fn __gcc_personality_v0(version: c_int,\n-                                actions: uw::_Unwind_Action,\n-                                exception_class: uw::_Unwind_Exception_Class,\n-                                ue_header: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-            -> uw::_Unwind_Reason_Code;\n-    }\n-\n-    #[lang = \"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    #[allow(private_no_mangle_fns)]\n-    extern fn rust_eh_personality(\n-        version: c_int,\n-        actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_v0(version, actions, exception_class, ue_header,\n-                                 context)\n-        }\n-    }\n-\n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n-        _version: c_int,\n-        actions: uw::_Unwind_Action,\n-        _exception_class: uw::_Unwind_Exception_Class,\n-        _ue_header: *mut uw::_Unwind_Exception,\n-        _context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-\n-        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n-        }\n-        else { // cleanup phase\n-            uw::_URC_INSTALL_CONTEXT\n-        }\n-    }\n-}\n-\n-// iOS on armv7 is using SjLj exceptions and therefore requires to use\n-// a specialized personality routine: __gcc_personality_sj0\n-\n-#[cfg(all(target_os = \"ios\", target_arch = \"arm\", not(test)))]\n-#[doc(hidden)]\n-pub mod eabi {\n-    use rt::libunwind as uw;\n-    use libc::c_int;\n-\n-    extern \"C\" {\n-        fn __gcc_personality_sj0(version: c_int,\n-                                actions: uw::_Unwind_Action,\n-                                exception_class: uw::_Unwind_Exception_Class,\n-                                ue_header: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-            -> uw::_Unwind_Reason_Code;\n-    }\n-\n-    #[lang = \"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality(\n-        version: c_int,\n-        actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_sj0(version, actions, exception_class, ue_header,\n-                                  context)\n-        }\n-    }\n-\n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n-        _version: c_int,\n-        actions: uw::_Unwind_Action,\n-        _exception_class: uw::_Unwind_Exception_Class,\n-        _ue_header: *mut uw::_Unwind_Exception,\n-        _context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n-        }\n-        else { // cleanup phase\n-            unsafe {\n-                __gcc_personality_sj0(_version, actions, _exception_class, _ue_header,\n-                                      _context)\n-            }\n-        }\n-    }\n-}\n-\n-\n-// ARM EHABI uses a slightly different personality routine signature,\n-// but otherwise works the same.\n-#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(test)))]\n-#[doc(hidden)]\n-pub mod eabi {\n-    use rt::libunwind as uw;\n-    use libc::c_int;\n-\n-    extern \"C\" {\n-        fn __gcc_personality_v0(state: uw::_Unwind_State,\n-                                ue_header: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-            -> uw::_Unwind_Reason_Code;\n-    }\n-\n-    #[lang = \"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    #[allow(private_no_mangle_fns)]\n-    extern \"C\" fn rust_eh_personality(\n-        state: uw::_Unwind_State,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_v0(state, ue_header, context)\n-        }\n-    }\n-\n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n-        state: uw::_Unwind_State,\n-        _ue_header: *mut uw::_Unwind_Exception,\n-        _context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        if (state as c_int & uw::_US_ACTION_MASK as c_int)\n-                           == uw::_US_VIRTUAL_UNWIND_FRAME as c_int { // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n-        }\n-        else { // cleanup phase\n-            uw::_URC_INSTALL_CONTEXT\n-        }\n-    }\n-}\n-\n-// Win64 SEH (see http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx)\n-//\n-// This looks a bit convoluted because rather than implementing a native SEH handler,\n-// GCC reuses the same personality routine as for the other architectures by wrapping it\n-// with an \"API translator\" layer (_GCC_specific_handler).\n-\n-#[cfg(all(windows, target_arch = \"x86_64\", not(test)))]\n-#[doc(hidden)]\n-#[allow(non_camel_case_types, non_snake_case)]\n-pub mod eabi {\n-    pub use self::EXCEPTION_DISPOSITION::*;\n-    use rt::libunwind as uw;\n-    use libc::{c_void, c_int};\n-\n-    #[repr(C)]\n-    pub struct EXCEPTION_RECORD;\n-    #[repr(C)]\n-    pub struct CONTEXT;\n-    #[repr(C)]\n-    pub struct DISPATCHER_CONTEXT;\n-\n-    #[repr(C)]\n-    #[derive(Copy, Clone)]\n-    pub enum EXCEPTION_DISPOSITION {\n-        ExceptionContinueExecution,\n-        ExceptionContinueSearch,\n-        ExceptionNestedException,\n-        ExceptionCollidedUnwind\n-    }\n-\n-    type _Unwind_Personality_Fn =\n-        extern \"C\" fn(\n-            version: c_int,\n-            actions: uw::_Unwind_Action,\n-            exception_class: uw::_Unwind_Exception_Class,\n-            ue_header: *mut uw::_Unwind_Exception,\n-            context: *mut uw::_Unwind_Context\n-        ) -> uw::_Unwind_Reason_Code;\n-\n-    extern \"C\" {\n-        fn __gcc_personality_seh0(\n-            exceptionRecord: *mut EXCEPTION_RECORD,\n-            establisherFrame: *mut c_void,\n-            contextRecord: *mut CONTEXT,\n-            dispatcherContext: *mut DISPATCHER_CONTEXT\n-        ) -> EXCEPTION_DISPOSITION;\n-\n-        fn _GCC_specific_handler(\n-            exceptionRecord: *mut EXCEPTION_RECORD,\n-            establisherFrame: *mut c_void,\n-            contextRecord: *mut CONTEXT,\n-            dispatcherContext: *mut DISPATCHER_CONTEXT,\n-            personality: _Unwind_Personality_Fn\n-        ) -> EXCEPTION_DISPOSITION;\n-    }\n-\n-    #[lang = \"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    #[allow(private_no_mangle_fns)]\n-    extern \"C\" fn rust_eh_personality(\n-        exceptionRecord: *mut EXCEPTION_RECORD,\n-        establisherFrame: *mut c_void,\n-        contextRecord: *mut CONTEXT,\n-        dispatcherContext: *mut DISPATCHER_CONTEXT\n-    ) -> EXCEPTION_DISPOSITION\n-    {\n-        unsafe {\n-            __gcc_personality_seh0(exceptionRecord, establisherFrame,\n-                                   contextRecord, dispatcherContext)\n-        }\n-    }\n-\n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n-        exceptionRecord: *mut EXCEPTION_RECORD,\n-        establisherFrame: *mut c_void,\n-        contextRecord: *mut CONTEXT,\n-        dispatcherContext: *mut DISPATCHER_CONTEXT\n-    ) -> EXCEPTION_DISPOSITION\n-    {\n-        extern \"C\" fn inner(\n-                _version: c_int,\n-                actions: uw::_Unwind_Action,\n-                _exception_class: uw::_Unwind_Exception_Class,\n-                _ue_header: *mut uw::_Unwind_Exception,\n-                _context: *mut uw::_Unwind_Context\n-            ) -> uw::_Unwind_Reason_Code\n-        {\n-            if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n-                uw::_URC_HANDLER_FOUND // catch!\n-            }\n-            else { // cleanup phase\n-                uw::_URC_INSTALL_CONTEXT\n-            }\n-        }\n-\n-        unsafe {\n-            _GCC_specific_handler(exceptionRecord, establisherFrame,\n-                                  contextRecord, dispatcherContext,\n-                                  inner)\n-        }\n+        imp::panic(cause)\n     }\n }\n ", "previous_filename": "src/libstd/rt/unwind.rs"}, {"sha": "a72c1debe14e0eeb506bba1ec60a2d39b1f7d410", "filename": "src/libstd/rt/unwind/seh.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f5222fb892be00f2b3e4dd8b83c5277e94ebbbba/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5222fb892be00f2b3e4dd8b83c5277e94ebbbba/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fseh.rs?ref=f5222fb892be00f2b3e4dd8b83c5277e94ebbbba", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use any::Any;\n+use intrinsics;\n+use libc::c_void;\n+\n+pub unsafe fn panic(_data: Box<Any + Send + 'static>) -> ! {\n+    intrinsics::abort();\n+}\n+\n+pub unsafe fn cleanup(_ptr: *mut c_void) -> Box<Any + Send + 'static> {\n+    intrinsics::abort();\n+}\n+\n+#[lang = \"eh_personality\"]\n+#[no_mangle]\n+pub extern fn rust_eh_personality() {}\n+\n+#[no_mangle]\n+pub extern fn rust_eh_personality_catch() {}"}]}