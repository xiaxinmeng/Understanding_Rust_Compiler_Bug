{"sha": "9d5965a5e899b03a34a94bcecfbc58c893b238e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNTk2NWE1ZTg5OWIwM2EzNGE5NGJjZWNmYmM1OGM4OTNiMjM4ZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-20T14:10:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-20T14:10:09Z"}, "message": "Auto merge of #34694 - mathphreak:master, r=alexcrichton\n\nAdd IpAddr common methods\n\nPer https://github.com/rust-lang/rfcs/pull/1668#issuecomment-230867962 no RFC is needed here.\n\nThe generated documentation for these methods is being weird. It shows a deprecation message referencing #27709 for each of them even though two of the referenced methods were stabilized as part of that issue. I don't know how best to address that.", "tree": {"sha": "937ed69600b35be3bddf506a05dcdb558e40d877", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/937ed69600b35be3bddf506a05dcdb558e40d877"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d5965a5e899b03a34a94bcecfbc58c893b238e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d5965a5e899b03a34a94bcecfbc58c893b238e7", "html_url": "https://github.com/rust-lang/rust/commit/9d5965a5e899b03a34a94bcecfbc58c893b238e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d5965a5e899b03a34a94bcecfbc58c893b238e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a63e3fac8fdf5187b155624aca622597ca9d344d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a63e3fac8fdf5187b155624aca622597ca9d344d", "html_url": "https://github.com/rust-lang/rust/commit/a63e3fac8fdf5187b155624aca622597ca9d344d"}, {"sha": "58da5dd51eebe700a2ac8cf4f0b10dec6d1b6ca9", "url": "https://api.github.com/repos/rust-lang/rust/commits/58da5dd51eebe700a2ac8cf4f0b10dec6d1b6ca9", "html_url": "https://github.com/rust-lang/rust/commit/58da5dd51eebe700a2ac8cf4f0b10dec6d1b6ca9"}], "stats": {"total": 121, "additions": 121, "deletions": 0}, "files": [{"sha": "2a8bd0c88beb6f535d2a53d81b839d3eb9cab951", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/9d5965a5e899b03a34a94bcecfbc58c893b238e7/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d5965a5e899b03a34a94bcecfbc58c893b238e7/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=9d5965a5e899b03a34a94bcecfbc58c893b238e7", "patch": "@@ -59,6 +59,66 @@ pub enum Ipv6MulticastScope {\n     Global\n }\n \n+impl IpAddr {\n+    /// Returns true for the special 'unspecified' address ([IPv4], [IPv6]).\n+    /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_unspecified\n+    /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_unspecified\n+    #[unstable(feature=\"ip\", issue=\"27709\",\n+               reason=\"recently added and depends on unstable Ipv4Addr.is_unspecified()\")]\n+    pub fn is_unspecified(&self) -> bool {\n+        match *self {\n+            IpAddr::V4(ref a) => a.is_unspecified(),\n+            IpAddr::V6(ref a) => a.is_unspecified(),\n+        }\n+    }\n+\n+    /// Returns true if this is a loopback address ([IPv4], [IPv6]).\n+    /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_loopback\n+    /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_loopback\n+    #[unstable(feature=\"ip\", reason=\"recently added\", issue=\"27709\")]\n+    pub fn is_loopback(&self) -> bool {\n+        match *self {\n+            IpAddr::V4(ref a) => a.is_loopback(),\n+            IpAddr::V6(ref a) => a.is_loopback(),\n+        }\n+    }\n+\n+    /// Returns true if the address appears to be globally routable ([IPv4], [IPv6]).\n+    /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_global\n+    /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_global\n+    #[unstable(feature=\"ip\", issue=\"27709\",\n+               reason=\"recently added and depends on unstable Ip{v4,v6}Addr.is_global()\")]\n+    pub fn is_global(&self) -> bool {\n+        match *self {\n+            IpAddr::V4(ref a) => a.is_global(),\n+            IpAddr::V6(ref a) => a.is_global(),\n+        }\n+    }\n+\n+    /// Returns true if this is a multicast address ([IPv4], [IPv6]).\n+    /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_multicast\n+    /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_multicast\n+    #[unstable(feature=\"ip\", reason=\"recently added\", issue=\"27709\")]\n+    pub fn is_multicast(&self) -> bool {\n+        match *self {\n+            IpAddr::V4(ref a) => a.is_multicast(),\n+            IpAddr::V6(ref a) => a.is_multicast(),\n+        }\n+    }\n+\n+    /// Returns true if this address is in a range designated for documentation ([IPv4], [IPv6]).\n+    /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_documentation\n+    /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_documentation\n+    #[unstable(feature=\"ip\", issue=\"27709\",\n+               reason=\"recently added and depends on unstable Ipv6Addr.is_documentation()\")]\n+    pub fn is_documentation(&self) -> bool {\n+        match *self {\n+            IpAddr::V4(ref a) => a.is_documentation(),\n+            IpAddr::V6(ref a) => a.is_documentation(),\n+        }\n+    }\n+}\n+\n impl Ipv4Addr {\n     /// Creates a new IPv4 address from four eight-bit octets.\n     ///\n@@ -760,6 +820,67 @@ mod tests {\n                    None);\n     }\n \n+    #[test]\n+    fn ip_properties() {\n+        fn check4(octets: &[u8; 4], unspec: bool, loopback: bool,\n+                  global: bool, multicast: bool, documentation: bool) {\n+            let ip = IpAddr::V4(Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3]));\n+            assert_eq!(ip.is_unspecified(), unspec);\n+            assert_eq!(ip.is_loopback(), loopback);\n+            assert_eq!(ip.is_global(), global);\n+            assert_eq!(ip.is_multicast(), multicast);\n+            assert_eq!(ip.is_documentation(), documentation);\n+        }\n+\n+        fn check6(str_addr: &str, unspec: bool, loopback: bool,\n+                  global: bool, u_doc: bool, mcast: bool) {\n+            let ip = IpAddr::V6(str_addr.parse().unwrap());\n+            assert_eq!(ip.is_unspecified(), unspec);\n+            assert_eq!(ip.is_loopback(), loopback);\n+            assert_eq!(ip.is_global(), global);\n+            assert_eq!(ip.is_documentation(), u_doc);\n+            assert_eq!(ip.is_multicast(), mcast);\n+        }\n+\n+        //     address                unspec loopbk global multicast doc\n+        check4(&[0, 0, 0, 0],         true,  false, false,  false,   false);\n+        check4(&[0, 0, 0, 1],         false, false, true,   false,   false);\n+        check4(&[0, 1, 0, 0],         false, false, true,   false,   false);\n+        check4(&[10, 9, 8, 7],        false, false, false,  false,   false);\n+        check4(&[127, 1, 2, 3],       false, true,  false,  false,   false);\n+        check4(&[172, 31, 254, 253],  false, false, false,  false,   false);\n+        check4(&[169, 254, 253, 242], false, false, false,  false,   false);\n+        check4(&[192, 0, 2, 183],     false, false, false,  false,   true);\n+        check4(&[192, 1, 2, 183],     false, false, true,   false,   false);\n+        check4(&[192, 168, 254, 253], false, false, false,  false,   false);\n+        check4(&[198, 51, 100, 0],    false, false, false,  false,   true);\n+        check4(&[203, 0, 113, 0],     false, false, false,  false,   true);\n+        check4(&[203, 2, 113, 0],     false, false, true,   false,   false);\n+        check4(&[224, 0, 0, 0],       false, false, true,   true,    false);\n+        check4(&[239, 255, 255, 255], false, false, true,   true,    false);\n+        check4(&[255, 255, 255, 255], false, false, false,  false,   false);\n+\n+        //     address                            unspec loopbk global doc    mcast\n+        check6(\"::\",                              true,  false, false, false, false);\n+        check6(\"::1\",                             false, true,  false, false, false);\n+        check6(\"::0.0.0.2\",                       false, false, true,  false, false);\n+        check6(\"1::\",                             false, false, true,  false, false);\n+        check6(\"fc00::\",                          false, false, false, false, false);\n+        check6(\"fdff:ffff::\",                     false, false, false, false, false);\n+        check6(\"fe80:ffff::\",                     false, false, false, false, false);\n+        check6(\"febf:ffff::\",                     false, false, false, false, false);\n+        check6(\"fec0::\",                          false, false, false, false, false);\n+        check6(\"ff01::\",                          false, false, false, false, true);\n+        check6(\"ff02::\",                          false, false, false, false, true);\n+        check6(\"ff03::\",                          false, false, false, false, true);\n+        check6(\"ff04::\",                          false, false, false, false, true);\n+        check6(\"ff05::\",                          false, false, false, false, true);\n+        check6(\"ff08::\",                          false, false, false, false, true);\n+        check6(\"ff0e::\",                          false, false, true,  false, true);\n+        check6(\"2001:db8:85a3::8a2e:370:7334\",    false, false, false, true,  false);\n+        check6(\"102:304:506:708:90a:b0c:d0e:f10\", false, false, true,  false, false);\n+    }\n+\n     #[test]\n     fn ipv4_properties() {\n         fn check(octets: &[u8; 4], unspec: bool, loopback: bool,"}]}