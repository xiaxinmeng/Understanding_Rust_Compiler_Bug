{"sha": "0a45b1303cafc39458ffd3944dcf74c8b4200df6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNDViMTMwM2NhZmMzOTQ1OGZmZDM5NDRkY2Y3NGM4YjQyMDBkZjY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-30T20:04:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-30T20:04:40Z"}, "message": "Rollup merge of #74915 - alexcrichton:allow-failing-canonicalize, r=Mark-Simulacrum\n\nrustc: Ignore fs::canonicalize errors in metadata\n\nThis commit updates the metadata location logic to ignore errors when\ncalling `fs::canonicalize`. Canonicalization was added historically so\nmultiple `-L` paths to the same directory don't print errors about\nmultiple candidates (since rustc can deduplicate same-named paths), but\ncanonicalization doesn't work on all filesystems. Cargo, for example,\nalways uses this sort of fallback where it will opportunitistically try\nto canonicalize but fall back to using the input path if it otherwise\ndoesn't work.\n\nIf rustc is run on a filesystem that doesn't support canonicalization\nthen the effect of this change will be that `-L` paths which logically\npoint to the same directory will cause errors, but that's a rare enough\noccurrence it shouldn't cause much issue in practice. Otherwise rustc\ndoesn't work at all today on those sorts of filesystem where\ncanonicalization isn't supported!", "tree": {"sha": "6c8eba3632788e9533700ca7d33cd9df9060c886", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c8eba3632788e9533700ca7d33cd9df9060c886"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a45b1303cafc39458ffd3944dcf74c8b4200df6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfIyfYCRBK7hj4Ov3rIwAAdHIIAFBOAzHXQNQf7tsG9TdT2rJQ\nUHkjEs7eroQdlYx3+/37r5Bu/cWLqyulO1Gtu7crMFIOGR4GC7dm6XOlw+FYmCeK\n1whoO8XUYicNwTGF8KaAhdS2v6dFIzP5Z09MRbZDootZoiN3tcl+WOj6Btn7gLVW\nXbsZnOCQvgfLmMTAG6F1mzdVYXHpeK7ADAUXrlelUVC+0gxzN8UNVWt5x9b8Tjjs\n+UHFpjWagj0fmgh5w+P06jovXf4MJTZpPyqmki3NmooMa0Uhkm8jEocUK1Ngne/A\nsJP/k3xomzvKzB+ahP1rrVcAZF3YEW0j5jtqA35upjbZy72DJylO5VOMXhcwFeE=\n=g9Ir\n-----END PGP SIGNATURE-----\n", "payload": "tree 6c8eba3632788e9533700ca7d33cd9df9060c886\nparent 2c6c764d9a37b0954afe8d005c8566dcbf12380d\nparent cd8bdb5eb9a7440fa64500218f43b04429e64fc1\nauthor Manish Goregaokar <manishsmail@gmail.com> 1596139480 -0700\ncommitter GitHub <noreply@github.com> 1596139480 -0700\n\nRollup merge of #74915 - alexcrichton:allow-failing-canonicalize, r=Mark-Simulacrum\n\nrustc: Ignore fs::canonicalize errors in metadata\n\nThis commit updates the metadata location logic to ignore errors when\ncalling `fs::canonicalize`. Canonicalization was added historically so\nmultiple `-L` paths to the same directory don't print errors about\nmultiple candidates (since rustc can deduplicate same-named paths), but\ncanonicalization doesn't work on all filesystems. Cargo, for example,\nalways uses this sort of fallback where it will opportunitistically try\nto canonicalize but fall back to using the input path if it otherwise\ndoesn't work.\n\nIf rustc is run on a filesystem that doesn't support canonicalization\nthen the effect of this change will be that `-L` paths which logically\npoint to the same directory will cause errors, but that's a rare enough\noccurrence it shouldn't cause much issue in practice. Otherwise rustc\ndoesn't work at all today on those sorts of filesystem where\ncanonicalization isn't supported!\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a45b1303cafc39458ffd3944dcf74c8b4200df6", "html_url": "https://github.com/rust-lang/rust/commit/0a45b1303cafc39458ffd3944dcf74c8b4200df6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a45b1303cafc39458ffd3944dcf74c8b4200df6/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c6c764d9a37b0954afe8d005c8566dcbf12380d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c6c764d9a37b0954afe8d005c8566dcbf12380d", "html_url": "https://github.com/rust-lang/rust/commit/2c6c764d9a37b0954afe8d005c8566dcbf12380d"}, {"sha": "cd8bdb5eb9a7440fa64500218f43b04429e64fc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd8bdb5eb9a7440fa64500218f43b04429e64fc1", "html_url": "https://github.com/rust-lang/rust/commit/cd8bdb5eb9a7440fa64500218f43b04429e64fc1"}], "stats": {"total": 70, "additions": 31, "deletions": 39}, "files": [{"sha": "a4ccc8c74c8499721d75a09b124b2ab83bffdd16", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a45b1303cafc39458ffd3944dcf74c8b4200df6/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a45b1303cafc39458ffd3944dcf74c8b4200df6/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=0a45b1303cafc39458ffd3944dcf74c8b4200df6", "patch": "@@ -248,9 +248,9 @@ impl<'a> CrateLoader<'a> {\n                 // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n                 if let Some(mut files) = entry.files() {\n                     if files.any(|l| {\n-                        let l = fs::canonicalize(l).ok();\n-                        source.dylib.as_ref().map(|p| &p.0) == l.as_ref()\n-                            || source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n+                        let l = fs::canonicalize(l).unwrap_or(l.clone().into());\n+                        source.dylib.as_ref().map(|p| &p.0) == Some(&l)\n+                            || source.rlib.as_ref().map(|p| &p.0) == Some(&l)\n                     }) {\n                         ret = Some(cnum);\n                     }"}, {"sha": "8828b318d1ea6bb6d5fcac44707ee06f4b044391", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0a45b1303cafc39458ffd3944dcf74c8b4200df6/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a45b1303cafc39458ffd3944dcf74c8b4200df6/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=0a45b1303cafc39458ffd3944dcf74c8b4200df6", "patch": "@@ -426,20 +426,17 @@ impl<'a> CrateLocator<'a> {\n             info!(\"lib candidate: {}\", spf.path.display());\n \n             let (rlibs, rmetas, dylibs) = candidates.entry(hash.to_string()).or_default();\n-            fs::canonicalize(&spf.path)\n-                .map(|p| {\n-                    if seen_paths.contains(&p) {\n-                        return FileDoesntMatch;\n-                    };\n-                    seen_paths.insert(p.clone());\n-                    match found_kind {\n-                        CrateFlavor::Rlib => rlibs.insert(p, kind),\n-                        CrateFlavor::Rmeta => rmetas.insert(p, kind),\n-                        CrateFlavor::Dylib => dylibs.insert(p, kind),\n-                    };\n-                    FileMatches\n-                })\n-                .unwrap_or(FileDoesntMatch)\n+            let path = fs::canonicalize(&spf.path).unwrap_or_else(|_| spf.path.clone());\n+            if seen_paths.contains(&path) {\n+                return FileDoesntMatch;\n+            };\n+            seen_paths.insert(path.clone());\n+            match found_kind {\n+                CrateFlavor::Rlib => rlibs.insert(path, kind),\n+                CrateFlavor::Rmeta => rmetas.insert(path, kind),\n+                CrateFlavor::Dylib => dylibs.insert(path, kind),\n+            };\n+            FileMatches\n         });\n         self.rejected_via_kind.extend(staticlibs);\n \n@@ -688,12 +685,13 @@ impl<'a> CrateLocator<'a> {\n                     && file.ends_with(&self.target.options.dll_suffix)\n             {\n                 // Make sure there's at most one rlib and at most one dylib.\n+                let loc = fs::canonicalize(&loc).unwrap_or_else(|_| loc.clone());\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n-                    rlibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                    rlibs.insert(loc, PathKind::ExternFlag);\n                 } else if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rmeta\") {\n-                    rmetas.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                    rmetas.insert(loc, PathKind::ExternFlag);\n                 } else {\n-                    dylibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                    dylibs.insert(loc, PathKind::ExternFlag);\n                 }\n             } else {\n                 self.rejected_via_filename"}, {"sha": "504490d938cfa576d77287643df8fe06111a7ffb", "filename": "src/librustc_session/filesearch.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0a45b1303cafc39458ffd3944dcf74c8b4200df6/src%2Flibrustc_session%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a45b1303cafc39458ffd3944dcf74c8b4200df6/src%2Flibrustc_session%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Ffilesearch.rs?ref=0a45b1303cafc39458ffd3944dcf74c8b4200df6", "patch": "@@ -117,28 +117,22 @@ pub fn make_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n \n pub fn get_or_default_sysroot() -> PathBuf {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n-    fn canonicalize(path: Option<PathBuf>) -> Option<PathBuf> {\n-        path.and_then(|path| {\n-            match fs::canonicalize(&path) {\n-                // See comments on this target function, but the gist is that\n-                // gcc chokes on verbatim paths which fs::canonicalize generates\n-                // so we try to avoid those kinds of paths.\n-                Ok(canon) => Some(fix_windows_verbatim_for_gcc(&canon)),\n-                Err(e) => panic!(\"failed to get realpath: {}\", e),\n-            }\n-        })\n+    fn canonicalize(path: PathBuf) -> PathBuf {\n+        let path = fs::canonicalize(&path).unwrap_or(path);\n+        // See comments on this target function, but the gist is that\n+        // gcc chokes on verbatim paths which fs::canonicalize generates\n+        // so we try to avoid those kinds of paths.\n+        fix_windows_verbatim_for_gcc(&path)\n     }\n \n     match env::current_exe() {\n-        Ok(exe) => match canonicalize(Some(exe)) {\n-            Some(mut p) => {\n-                p.pop();\n-                p.pop();\n-                p\n-            }\n-            None => panic!(\"can't determine value for sysroot\"),\n-        },\n-        Err(ref e) => panic!(format!(\"failed to get current_exe: {}\", e)),\n+        Ok(exe) => {\n+            let mut p = canonicalize(exe);\n+            p.pop();\n+            p.pop();\n+            p\n+        }\n+        Err(e) => panic!(\"failed to get current_exe: {}\", e),\n     }\n }\n "}]}