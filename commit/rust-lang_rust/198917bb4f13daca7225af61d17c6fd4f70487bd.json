{"sha": "198917bb4f13daca7225af61d17c6fd4f70487bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ODkxN2JiNGYxM2RhY2E3MjI1YWY2MWQxN2M2ZmQ0ZjcwNDg3YmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-08T12:00:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-08T12:00:22Z"}, "message": "Auto merge of #41745 - oli-obk:diagnostics, r=jonathandturner\n\nRemove need for &format!(...) or &&\"\" dances in `span_label` calls\n\nThese were always a thorn in my eye. Note that this will monomorphize to two impls, one for `String` and one for `&str`. But I think that cost is worth the ergonomics at the call sites that can be seen throughout this PR.", "tree": {"sha": "4d6b198ad0e356961a8b64603caa847a81b86b68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d6b198ad0e356961a8b64603caa847a81b86b68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/198917bb4f13daca7225af61d17c6fd4f70487bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/198917bb4f13daca7225af61d17c6fd4f70487bd", "html_url": "https://github.com/rust-lang/rust/commit/198917bb4f13daca7225af61d17c6fd4f70487bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/198917bb4f13daca7225af61d17c6fd4f70487bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70198a0a44633c7c9d14fce2159c1f750491287b", "url": "https://api.github.com/repos/rust-lang/rust/commits/70198a0a44633c7c9d14fce2159c1f750491287b", "html_url": "https://github.com/rust-lang/rust/commit/70198a0a44633c7c9d14fce2159c1f750491287b"}, {"sha": "dd87eabd83296baa4c2214d2cf3aeef24f753ba7", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd87eabd83296baa4c2214d2cf3aeef24f753ba7", "html_url": "https://github.com/rust-lang/rust/commit/dd87eabd83296baa4c2214d2cf3aeef24f753ba7"}], "stats": {"total": 610, "additions": 305, "deletions": 305}, "files": [{"sha": "f553c03d09bd680e683243f3bc57a1171640dd22", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -43,7 +43,7 @@ impl<'a> CheckAttrVisitor<'a> {\n     fn check_inline(&self, attr: &ast::Attribute, target: Target) {\n         if target != Target::Fn {\n             struct_span_err!(self.sess, attr.span, E0518, \"attribute should be applied to function\")\n-                .span_label(attr.span, &format!(\"requires a function\"))\n+                .span_label(attr.span, \"requires a function\")\n                 .emit();\n         }\n     }\n@@ -123,7 +123,7 @@ impl<'a> CheckAttrVisitor<'a> {\n                 _ => continue,\n             };\n             struct_span_err!(self.sess, attr.span, E0517, \"{}\", message)\n-                .span_label(attr.span, &format!(\"requires {}\", label))\n+                .span_label(attr.span, format!(\"requires {}\", label))\n                 .emit();\n         }\n         if conflicting_reprs > 1 {"}, {"sha": "4c27bade0f7215e06cc36936f9b232ca96cc5bb8", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -668,9 +668,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        diag.span_label(span, &terr);\n+        diag.span_label(span, terr.to_string());\n         if let Some((sp, msg)) = secondary_span {\n-            diag.span_label(sp, &msg);\n+            diag.span_label(sp, msg);\n         }\n \n         self.note_error_origin(diag, &cause);"}, {"sha": "6f3e84247f797ddbfdadfd43ffa73d341fbedff7", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -680,12 +680,12 @@ pub trait LintContext<'tcx>: Sized {\n                                                             \"{}({}) overruled by outer forbid({})\",\n                                                             level.as_str(), lint_name,\n                                                             lint_name);\n-                    diag_builder.span_label(span, &format!(\"overruled by previous forbid\"));\n+                    diag_builder.span_label(span, \"overruled by previous forbid\");\n                     match now_source {\n                         LintSource::Default => &mut diag_builder,\n                         LintSource::Node(_, forbid_source_span) => {\n                             diag_builder.span_label(forbid_source_span,\n-                                                    &format!(\"`forbid` level set here\"))\n+                                                    \"`forbid` level set here\")\n                         },\n                         LintSource::CommandLine(_) => {\n                             diag_builder.note(\"`forbid` lint level was set on command line\")"}, {"sha": "3bbaf5c9299f8945e301378c874a15cd57473c52", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n     {\n         match self.description() {\n             ConstEvalErrDescription::Simple(message) => {\n-                diag.span_label(self.span, &message);\n+                diag.span_label(self.span, message);\n             }\n         }\n "}, {"sha": "e03948db3683187e542d3fba3f4dc993a6264109", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n                     struct_span_err!(\n                         self.tcx.sess, span, E0133,\n                         \"{} requires unsafe function or block\", description)\n-                        .span_label(span, &description)\n+                        .span_label(span, description)\n                         .emit();\n                 }\n             }"}, {"sha": "24748b6cf65b8aab05159071a883fcd4821885b4", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -128,8 +128,8 @@ fn find_item(item: &Item, ctxt: &mut EntryContext, at_root: bool) {\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0137,\n                           \"multiple functions with a #[main] attribute\")\n-                .span_label(item.span, &format!(\"additional #[main] function\"))\n-                .span_label(ctxt.attr_main_fn.unwrap().1, &format!(\"first #[main] function\"))\n+                .span_label(item.span, \"additional #[main] function\")\n+                .span_label(ctxt.attr_main_fn.unwrap().1, \"first #[main] function\")\n                 .emit();\n             }\n         },\n@@ -141,8 +141,8 @@ fn find_item(item: &Item, ctxt: &mut EntryContext, at_root: bool) {\n                     ctxt.session, item.span, E0138,\n                     \"multiple 'start' functions\")\n                     .span_label(ctxt.start_fn.unwrap().1,\n-                                &format!(\"previous `start` function here\"))\n-                    .span_label(item.span, &format!(\"multiple `start` functions\"))\n+                                \"previous `start` function here\")\n+                    .span_label(item.span, \"multiple `start` functions\")\n                     .emit();\n             }\n         },"}, {"sha": "a759a9061f8428874475d8a2f61be1e8426d6057", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n                     struct_span_err!(self.infcx.tcx.sess, span, E0591,\n                                      \"`{}` is zero-sized and can't be transmuted to `{}`\",\n                                      from, to)\n-                        .span_note(span, &format!(\"cast with `as` to a pointer instead\"))\n+                        .span_note(span, \"cast with `as` to a pointer instead\")\n                         .emit();\n                     return;\n                 }\n@@ -126,7 +126,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n                   from, skeleton_string(from, sk_from),\n                   to, skeleton_string(to, sk_to))\n             .span_label(span,\n-                &format!(\"transmuting between {} and {}\",\n+                format!(\"transmuting between {} and {}\",\n                     skeleton_string(from, sk_from),\n                     skeleton_string(to, sk_to)))\n             .emit();"}, {"sha": "67b8dfb2d8e0ca5df51ed05ee7b7db783d6df48a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -574,9 +574,9 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n                                         {} name that is already in scope\",\n                                        shadower.kind.desc(), name, orig.kind.desc()))\n     };\n-    err.span_label(orig.span, &\"first declared here\");\n+    err.span_label(orig.span, \"first declared here\");\n     err.span_label(shadower.span,\n-                   &format!(\"lifetime {} already in scope\", name));\n+                   format!(\"lifetime {} already in scope\", name));\n     err.emit();\n }\n \n@@ -919,7 +919,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         } else {\n             struct_span_err!(self.sess, lifetime_ref.span, E0261,\n                 \"use of undeclared lifetime name `{}`\", lifetime_ref.name)\n-                .span_label(lifetime_ref.span, &format!(\"undeclared lifetime\"))\n+                .span_label(lifetime_ref.span, \"undeclared lifetime\")\n                 .emit();\n         }\n     }\n@@ -1328,7 +1328,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         } else {\n             format!(\"expected lifetime parameter\")\n         };\n-        err.span_label(span, &msg);\n+        err.span_label(span, msg);\n \n         if let Some(params) = error {\n             if lifetime_refs.len() == 1 {\n@@ -1438,7 +1438,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     let mut err = struct_span_err!(self.sess, lifetime.span, E0262,\n                                   \"invalid lifetime parameter name: `{}`\", lifetime.name);\n                     err.span_label(lifetime.span,\n-                                   &format!(\"{} is a reserved lifetime name\", lifetime.name));\n+                                   format!(\"{} is a reserved lifetime name\", lifetime.name));\n                     err.emit();\n                 }\n             }\n@@ -1452,9 +1452,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                      \"lifetime name `{}` declared twice in the same scope\",\n                                      lifetime_j.lifetime.name)\n                         .span_label(lifetime_j.lifetime.span,\n-                                    &format!(\"declared twice\"))\n+                                    \"declared twice\")\n                         .span_label(lifetime_i.lifetime.span,\n-                                   &format!(\"previous declaration here\"))\n+                                   \"previous declaration here\")\n                         .emit();\n                 }\n             }"}, {"sha": "152e3353994b3b32315d8591d4e482f2792b461d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -484,12 +484,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some(trait_item_span) = self.tcx.hir.span_if_local(trait_item_def_id) {\n             let span = self.tcx.sess.codemap().def_span(trait_item_span);\n-            err.span_label(span, &format!(\"definition of `{}` from trait\", item_name));\n+            err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n         }\n \n         err.span_label(\n             error_span,\n-            &format!(\"impl has extra requirement {}\", requirement));\n+            format!(\"impl has extra requirement {}\", requirement));\n \n         if let Some(node_id) = lint_id {\n             self.tcx.sess.add_lint_diagnostic(EXTRA_REQUIREMENT_IN_IMPL,\n@@ -582,7 +582,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         }\n \n                         err.span_label(span,\n-                                       &format!(\"{}the trait `{}` is not implemented for `{}`\",\n+                                       format!(\"{}the trait `{}` is not implemented for `{}`\",\n                                                 pre_message,\n                                                 trait_ref,\n                                                 trait_ref.self_ty()));\n@@ -738,11 +738,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             expected_ref,\n             found_ref);\n \n-        err.span_label(span, &format!(\"{}\", type_error));\n+        err.span_label(span, format!(\"{}\", type_error));\n \n         if let Some(sp) = found_span {\n-            err.span_label(span, &format!(\"requires `{}`\", found_ref));\n-            err.span_label(sp, &format!(\"implements `{}`\", expected_ref));\n+            err.span_label(span, format!(\"requires `{}`\", found_ref));\n+            err.span_label(sp, format!(\"implements `{}`\", expected_ref));\n         }\n \n         err\n@@ -765,12 +765,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             if expected == 1 { \"\" } else { \"s\" },\n             if expected == 1 { \"is\" } else { \"are\" });\n \n-        err.span_label(span, &format!(\"expected {} that takes {} argument{}\",\n+        err.span_label(span, format!(\"expected {} that takes {} argument{}\",\n                                       if is_closure { \"closure\" } else { \"function\" },\n                                       expected,\n                                       if expected == 1 { \"\" } else { \"s\" }));\n         if let Some(span) = found_span {\n-            err.span_label(span, &format!(\"takes {} argument{}\",\n+            err.span_label(span, format!(\"takes {} argument{}\",\n                                           found,\n                                           if found == 1 { \"\" } else { \"s\" }));\n         }\n@@ -789,7 +789,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let mut err = struct_span_err!(self.sess, span, E0072,\n                                        \"recursive type `{}` has infinite size\",\n                                        self.item_path_str(type_def_id));\n-        err.span_label(span, &format!(\"recursive type has infinite size\"));\n+        err.span_label(span, \"recursive type has infinite size\");\n         err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n                            at some point to make `{}` representable\",\n                           self.item_path_str(type_def_id)));\n@@ -808,7 +808,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.sess, span, E0038,\n             \"the trait `{}` cannot be made into an object\",\n             trait_str);\n-        err.span_label(span, &format!(\"the trait `{}` cannot be made into an object\", trait_str));\n+        err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n \n         let mut reported_violations = FxHashSet();\n         for violation in violations {\n@@ -1043,7 +1043,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        \"type annotations needed\");\n \n         for (target_span, label_message) in labels {\n-            err.span_label(target_span, &label_message);\n+            err.span_label(target_span, label_message);\n         }\n \n         err.emit();"}, {"sha": "82a4c1e1e626a9e45defaddbae224a31d0641d7b", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -181,7 +181,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let mut err =\n                 struct_span_err!(self.sess, span, E0391,\n                                  \"unsupported cyclic reference between types/traits detected\");\n-            err.span_label(span, &format!(\"cyclic reference\"));\n+            err.span_label(span, \"cyclic reference\");\n \n             err.span_note(stack[0].0, &format!(\"the cycle begins when {}...\",\n                                                stack[0].1.describe(self)));"}, {"sha": "adabbe11f5ecc80cceb5a27fb56adb816003573c", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -469,13 +469,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                                   nl, new_loan_msg);\n                     err.span_label(\n                             old_loan.span,\n-                            &format!(\"first mutable borrow occurs here{}\", old_loan_msg));\n+                            format!(\"first mutable borrow occurs here{}\", old_loan_msg));\n                     err.span_label(\n                             new_loan.span,\n-                            &format!(\"second mutable borrow occurs here{}\", new_loan_msg));\n+                            format!(\"second mutable borrow occurs here{}\", new_loan_msg));\n                     err.span_label(\n                             previous_end_span,\n-                            &format!(\"first borrow ends here\"));\n+                            \"first borrow ends here\");\n                     err\n                 }\n \n@@ -486,13 +486,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                      nl);\n                     err.span_label(\n                             old_loan.span,\n-                            &format!(\"first closure is constructed here\"));\n+                            \"first closure is constructed here\");\n                     err.span_label(\n                             new_loan.span,\n-                            &format!(\"second closure is constructed here\"));\n+                            \"second closure is constructed here\");\n                     err.span_label(\n                             previous_end_span,\n-                            &format!(\"borrow from first closure ends here\"));\n+                            \"borrow from first closure ends here\");\n                     err\n                 }\n \n@@ -503,13 +503,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                                    nl, ol_pronoun, old_loan_msg);\n                     err.span_label(\n                             new_loan.span,\n-                            &format!(\"closure construction occurs here{}\", new_loan_msg));\n+                            format!(\"closure construction occurs here{}\", new_loan_msg));\n                     err.span_label(\n                             old_loan.span,\n-                            &format!(\"borrow occurs here{}\", old_loan_msg));\n+                            format!(\"borrow occurs here{}\", old_loan_msg));\n                     err.span_label(\n                             previous_end_span,\n-                            &format!(\"borrow ends here\"));\n+                            \"borrow ends here\");\n                     err\n                 }\n \n@@ -520,13 +520,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                                    nl, new_loan_msg, new_loan.kind.to_user_str());\n                     err.span_label(\n                             new_loan.span,\n-                            &format!(\"borrow occurs here{}\", new_loan_msg));\n+                            format!(\"borrow occurs here{}\", new_loan_msg));\n                     err.span_label(\n                             old_loan.span,\n-                            &format!(\"closure construction occurs here{}\", old_loan_msg));\n+                            format!(\"closure construction occurs here{}\", old_loan_msg));\n                     err.span_label(\n                             previous_end_span,\n-                            &format!(\"borrow from closure ends here\"));\n+                            \"borrow from closure ends here\");\n                     err\n                 }\n \n@@ -542,17 +542,17 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                                    old_loan_msg);\n                     err.span_label(\n                             new_loan.span,\n-                            &format!(\"{} borrow occurs here{}\",\n+                            format!(\"{} borrow occurs here{}\",\n                                      new_loan.kind.to_user_str(),\n                                      new_loan_msg));\n                     err.span_label(\n                             old_loan.span,\n-                            &format!(\"{} borrow occurs here{}\",\n+                            format!(\"{} borrow occurs here{}\",\n                                      old_loan.kind.to_user_str(),\n                                      old_loan_msg));\n                     err.span_label(\n                             previous_end_span,\n-                            &format!(\"{} borrow ends here\",\n+                            format!(\"{} borrow ends here\",\n                                      old_loan.kind.to_user_str()));\n                     err\n                 }\n@@ -562,7 +562,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 euv::ClosureCapture(span) => {\n                     err.span_label(\n                         span,\n-                        &format!(\"borrow occurs due to use of `{}` in closure\", nl));\n+                        format!(\"borrow occurs due to use of `{}` in closure\", nl));\n                 }\n                 _ => { }\n             }\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 euv::ClosureCapture(span) => {\n                     err.span_label(\n                         span,\n-                        &format!(\"previous borrow occurs due to use of `{}` in closure\",\n+                        format!(\"previous borrow occurs due to use of `{}` in closure\",\n                                  ol));\n                 }\n                 _ => { }\n@@ -633,11 +633,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                  \"cannot use `{}` because it was mutably borrowed\",\n                                  &self.bccx.loan_path_to_string(copy_path))\n                     .span_label(loan_span,\n-                               &format!(\"borrow of `{}` occurs here\",\n+                               format!(\"borrow of `{}` occurs here\",\n                                        &self.bccx.loan_path_to_string(&loan_path))\n                                )\n                     .span_label(span,\n-                               &format!(\"use of borrowed `{}`\",\n+                               format!(\"use of borrowed `{}`\",\n                                         &self.bccx.loan_path_to_string(&loan_path)))\n                     .emit();\n             }\n@@ -662,12 +662,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                          &self.bccx.loan_path_to_string(move_path));\n                         err.span_label(\n                             loan_span,\n-                            &format!(\"borrow of `{}` occurs here\",\n+                            format!(\"borrow of `{}` occurs here\",\n                                     &self.bccx.loan_path_to_string(&loan_path))\n                             );\n                         err.span_label(\n                             span,\n-                            &format!(\"move into closure occurs here\")\n+                            \"move into closure occurs here\"\n                             );\n                         err\n                     }\n@@ -679,12 +679,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                          &self.bccx.loan_path_to_string(move_path));\n                         err.span_label(\n                             loan_span,\n-                            &format!(\"borrow of `{}` occurs here\",\n+                            format!(\"borrow of `{}` occurs here\",\n                                     &self.bccx.loan_path_to_string(&loan_path))\n                             );\n                         err.span_label(\n                             span,\n-                            &format!(\"move out of `{}` occurs here\",\n+                            format!(\"move out of `{}` occurs here\",\n                                 &self.bccx.loan_path_to_string(move_path))\n                             );\n                         err\n@@ -857,10 +857,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                          \"cannot assign to `{}` because it is borrowed\",\n                          self.bccx.loan_path_to_string(loan_path))\n             .span_label(loan.span,\n-                       &format!(\"borrow of `{}` occurs here\",\n+                       format!(\"borrow of `{}` occurs here\",\n                                self.bccx.loan_path_to_string(loan_path)))\n             .span_label(span,\n-                       &format!(\"assignment to borrowed `{}` occurs here\",\n+                       format!(\"assignment to borrowed `{}` occurs here\",\n                                self.bccx.loan_path_to_string(loan_path)))\n             .emit();\n     }"}, {"sha": "1ee6d565d0d7debd0718f06e5382d62f7b3cc776", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -94,7 +94,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &Vec<Move\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n             err.span_label(bccx.tcx.hir.span(upvar_id.var_id),\n-                           &\"captured outer variable\");\n+                           \"captured outer variable\");\n         }\n         err.emit();\n \n@@ -147,7 +147,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              move_from.descriptive_string(bccx.tcx));\n             err.span_label(\n                 move_from.span,\n-                &format!(\"cannot move out of {}\", move_from.descriptive_string(bccx.tcx))\n+                format!(\"cannot move out of {}\", move_from.descriptive_string(bccx.tcx))\n                 );\n             err\n         }\n@@ -160,7 +160,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                                    \"cannot move out of type `{}`, \\\n                                                     a non-copy array\",\n                                                    b.ty);\n-                    err.span_label(move_from.span, &format!(\"cannot move out of here\"));\n+                    err.span_label(move_from.span, \"cannot move out of here\");\n                     err\n                 }\n                 (_, Kind::Pattern) => {\n@@ -177,7 +177,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                                    \"cannot move out of type `{}`, \\\n                                                    which implements the `Drop` trait\",\n                                                    b.ty);\n-                    err.span_label(move_from.span, &format!(\"cannot move out of here\"));\n+                    err.span_label(move_from.span, \"cannot move out of here\");\n                     err\n                 },\n                 _ => {\n@@ -198,12 +198,12 @@ fn note_move_destination(mut err: DiagnosticBuilder,\n     if is_first_note {\n         err.span_label(\n             move_to_span,\n-            &format!(\"hint: to prevent move, use `ref {0}` or `ref mut {0}`\",\n+            format!(\"hint: to prevent move, use `ref {0}` or `ref mut {0}`\",\n                      pat_name));\n         err\n     } else {\n         err.span_label(move_to_span,\n-                      &format!(\"...and here (use `ref {0}` or `ref mut {0}`)\",\n+                      format!(\"...and here (use `ref {0}` or `ref mut {0}`)\",\n                                pat_name));\n         err\n     }"}, {"sha": "7eb73a87532eb9b427878d81eb3d25dfeef358be", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     \"{} of possibly uninitialized variable: `{}`\",\n                     verb,\n                     self.loan_path_to_string(lp))\n-                .span_label(use_span, &format!(\"use of possibly uninitialized `{}`\",\n+                .span_label(use_span, format!(\"use of possibly uninitialized `{}`\",\n                     self.loan_path_to_string(lp)))\n                 .emit();\n                 return;\n@@ -616,12 +616,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         err = if use_span == move_span {\n             err.span_label(\n                 use_span,\n-                &format!(\"value moved{} here in previous iteration of loop\",\n+                format!(\"value moved{} here in previous iteration of loop\",\n                          move_note));\n             err\n         } else {\n-            err.span_label(use_span, &format!(\"value {} here after move\", verb_participle))\n-               .span_label(move_span, &format!(\"value moved{} here\", move_note));\n+            err.span_label(use_span, format!(\"value {} here after move\", verb_participle))\n+               .span_label(move_span, format!(\"value moved{} here\", move_note));\n             err\n         };\n \n@@ -657,9 +657,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             self.tcx.sess, span, E0384,\n             \"re-assignment of immutable variable `{}`\",\n             self.loan_path_to_string(lp));\n-        err.span_label(span, &format!(\"re-assignment of immutable variable\"));\n+        err.span_label(span, \"re-assignment of immutable variable\");\n         if span != assign.span {\n-            err.span_label(assign.span, &format!(\"first assignment to `{}`\",\n+            err.span_label(assign.span, format!(\"first assignment to `{}`\",\n                                               self.loan_path_to_string(lp)));\n         }\n         err.emit();\n@@ -821,7 +821,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess, span, E0389,\n                     \"{} in a `&` reference\", prefix);\n-                err.span_label(span, &\"assignment into an immutable reference\");\n+                err.span_label(span, \"assignment into an immutable reference\");\n                 err\n             }\n         };\n@@ -914,7 +914,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         }\n                         db.span_label(\n                             let_span,\n-                            &format!(\"consider changing this to `mut {}`\", snippet)\n+                            format!(\"consider changing this to `mut {}`\", snippet)\n                         );\n                     }\n                 }\n@@ -927,7 +927,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         if let Ok(snippet) = snippet {\n                             db.span_label(\n                                 let_span,\n-                                &format!(\"consider changing this to `{}`\",\n+                                format!(\"consider changing this to `{}`\",\n                                          snippet.replace(\"ref \", \"ref mut \"))\n                             );\n                         }\n@@ -936,7 +936,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         if let (Some(local_ty), is_implicit_self) = self.local_ty(node_id) {\n                             if let Some(msg) =\n                                  self.suggest_mut_for_immutable(local_ty, is_implicit_self) {\n-                                db.span_label(local_ty.span, &msg);\n+                                db.span_label(local_ty.span, msg);\n                             }\n                         }\n                     }\n@@ -950,7 +950,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 if let hir_map::Node::NodeField(ref field) = self.tcx.hir.get(node_id) {\n                     if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n-                        db.span_label(field.ty.span, &msg);\n+                        db.span_label(field.ty.span, msg);\n                     }\n                 }\n             }\n@@ -975,10 +975,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                           which is owned by the current function\",\n                          cmt_path_or_string)\n             .span_label(capture_span,\n-                       &format!(\"{} is borrowed here\",\n+                       format!(\"{} is borrowed here\",\n                                 cmt_path_or_string))\n             .span_label(err.span,\n-                       &format!(\"may outlive borrowed value {}\",\n+                       format!(\"may outlive borrowed value {}\",\n                                 cmt_path_or_string))\n             .span_suggestion(err.span,\n                              &format!(\"to force the closure to take ownership of {} \\\n@@ -1029,15 +1029,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         match db.span.primary_span() {\n                             Some(primary) => {\n                                 db.span = MultiSpan::from_span(s);\n-                                db.span_label(primary, &format!(\"capture occurs here\"));\n-                                db.span_label(s, &\"does not live long enough\");\n+                                db.span_label(primary, \"capture occurs here\");\n+                                db.span_label(s, \"does not live long enough\");\n                                 true\n                             }\n                             None => false\n                         }\n                     }\n                     _ => {\n-                        db.span_label(error_span, &\"does not live long enough\");\n+                        db.span_label(error_span, \"does not live long enough\");\n                         false\n                     }\n                 };\n@@ -1049,37 +1049,37 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     (Some(s1), Some(s2)) if s1 == s2 => {\n                         if !is_closure {\n                             db.span = MultiSpan::from_span(s1);\n-                            db.span_label(error_span, &value_msg);\n+                            db.span_label(error_span, value_msg);\n                             let msg = match opt_loan_path(&err.cmt) {\n                                 None => value_kind.to_string(),\n                                 Some(lp) => {\n                                     format!(\"`{}`\", self.loan_path_to_string(&lp))\n                                 }\n                             };\n                             db.span_label(s1,\n-                                          &format!(\"{} dropped here while still borrowed\", msg));\n+                                          format!(\"{} dropped here while still borrowed\", msg));\n                         } else {\n-                            db.span_label(s1, &format!(\"{} dropped before borrower\", value_kind));\n+                            db.span_label(s1, format!(\"{} dropped before borrower\", value_kind));\n                         }\n                         db.note(\"values in a scope are dropped in the opposite order \\\n                                 they are created\");\n                     }\n                     (Some(s1), Some(s2)) if !is_closure => {\n                         db.span = MultiSpan::from_span(s2);\n-                        db.span_label(error_span, &value_msg);\n+                        db.span_label(error_span, value_msg);\n                         let msg = match opt_loan_path(&err.cmt) {\n                             None => value_kind.to_string(),\n                             Some(lp) => {\n                                 format!(\"`{}`\", self.loan_path_to_string(&lp))\n                             }\n                         };\n-                        db.span_label(s2, &format!(\"{} dropped here while still borrowed\", msg));\n-                        db.span_label(s1, &format!(\"{} needs to live until here\", value_kind));\n+                        db.span_label(s2, format!(\"{} dropped here while still borrowed\", msg));\n+                        db.span_label(s1, format!(\"{} needs to live until here\", value_kind));\n                     }\n                     _ => {\n                         match sub_span {\n                             Some(s) => {\n-                                db.span_label(s, &format!(\"{} needs to live until here\",\n+                                db.span_label(s, format!(\"{} needs to live until here\",\n                                                           value_kind));\n                             }\n                             None => {\n@@ -1092,7 +1092,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         }\n                         match super_span {\n                             Some(s) => {\n-                                db.span_label(s, &format!(\"{} only lives until here\", value_kind));\n+                                db.span_label(s, format!(\"{} only lives until here\", value_kind));\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n@@ -1162,23 +1162,23 @@ before rustc 1.16, this temporary lived longer - see issue #39283 \\\n             }\n             _ => {\n                 if let Categorization::Deref(..) = err.cmt.cat {\n-                    db.span_label(*error_span, &\"cannot borrow as mutable\");\n+                    db.span_label(*error_span, \"cannot borrow as mutable\");\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n                     let span = self.tcx.hir.span(local_id);\n                     if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n-                            db.span_label(*error_span, &format!(\"cannot reborrow mutably\"));\n-                            db.span_label(*error_span, &format!(\"try removing `&mut` here\"));\n+                            db.span_label(*error_span, \"cannot reborrow mutably\");\n+                            db.span_label(*error_span, \"try removing `&mut` here\");\n                         } else {\n-                            db.span_label(*error_span, &format!(\"cannot borrow mutably\"));\n+                            db.span_label(*error_span, \"cannot borrow mutably\");\n                         }\n                     } else {\n-                        db.span_label(*error_span, &format!(\"cannot borrow mutably\"));\n+                        db.span_label(*error_span, \"cannot borrow mutably\");\n                     }\n                 } else if let Categorization::Interior(ref cmt, _) = err.cmt.cat {\n                     if let mc::MutabilityCategory::McImmutable = cmt.mutbl {\n                         db.span_label(*error_span,\n-                                      &\"cannot mutably borrow immutable field\");\n+                                      \"cannot mutably borrow immutable field\");\n                     }\n                 }\n             }"}, {"sha": "cd31290eb554c0fdce766f290657f32defc79bb6", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 \"refutable pattern in {}: `{}` not covered\",\n                 origin, pattern_string\n             );\n-            diag.span_label(pat.span, &format!(\"pattern `{}` not covered\", pattern_string));\n+            diag.span_label(pat.span, format!(\"pattern `{}` not covered\", pattern_string));\n             diag.emit();\n         });\n     }\n@@ -328,7 +328,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                 let span = first_pat.0.span;\n                                 struct_span_err!(cx.tcx.sess, span, E0162,\n                                                 \"irrefutable if-let pattern\")\n-                                    .span_label(span, &format!(\"irrefutable pattern\"))\n+                                    .span_label(span, \"irrefutable pattern\")\n                                     .emit();\n                                 printed_if_let_err = true;\n                             }\n@@ -355,7 +355,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                 1 => {\n                                     struct_span_err!(cx.tcx.sess, span, E0165,\n                                                      \"irrefutable while-let pattern\")\n-                                        .span_label(span, &format!(\"irrefutable pattern\"))\n+                                        .span_label(span, \"irrefutable pattern\")\n                                         .emit();\n                                 },\n                                 _ => bug!(),\n@@ -369,7 +369,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                             diagnostic.set_span(pat.span);\n                             // if we had a catchall pattern, hint at that\n                             if let Some(catchall) = catchall {\n-                                diagnostic.span_label(pat.span, &\"this is an unreachable pattern\");\n+                                diagnostic.span_label(pat.span, \"this is an unreachable pattern\");\n                                 diagnostic.span_note(catchall, \"this pattern matches any value\");\n                             }\n                             cx.tcx.sess.add_lint_diagnostic(lint::builtin::UNREACHABLE_PATTERNS,\n@@ -426,7 +426,7 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                         \"refutable pattern in `for` loop binding: \\\n                                 `{}` not covered\",\n                                 pattern_string)\n-                        .span_label(sp, &format!(\"pattern `{}` not covered\", pattern_string))\n+                        .span_label(sp, format!(\"pattern `{}` not covered\", pattern_string))\n                         .emit();\n                 },\n                 _ => {\n@@ -453,7 +453,7 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     create_e0004(cx.tcx.sess, sp,\n                                  format!(\"non-exhaustive patterns: {} not covered\",\n                                          joined_patterns))\n-                        .span_label(sp, &label_text)\n+                        .span_label(sp, label_text)\n                         .emit();\n                 },\n             }\n@@ -485,18 +485,18 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n         if sub.map_or(false, |p| p.contains_bindings()) {\n             struct_span_err!(cx.tcx.sess, p.span, E0007,\n                              \"cannot bind by-move with sub-bindings\")\n-                .span_label(p.span, &format!(\"binds an already bound by-move value by moving it\"))\n+                .span_label(p.span, \"binds an already bound by-move value by moving it\")\n                 .emit();\n         } else if has_guard {\n             struct_span_err!(cx.tcx.sess, p.span, E0008,\n                       \"cannot bind by-move into a pattern guard\")\n-                .span_label(p.span, &format!(\"moves value into pattern guard\"))\n+                .span_label(p.span, \"moves value into pattern guard\")\n                 .emit();\n         } else if by_ref_span.is_some() {\n             struct_span_err!(cx.tcx.sess, p.span, E0009,\n                             \"cannot bind by-move and by-ref in the same pattern\")\n-                    .span_label(p.span, &format!(\"by-move pattern here\"))\n-                    .span_label(by_ref_span.unwrap(), &format!(\"both by-ref and by-move used\"))\n+                    .span_label(p.span, \"by-move pattern here\")\n+                    .span_label(by_ref_span.unwrap(), \"both by-ref and by-move used\")\n                     .emit();\n         }\n     };\n@@ -546,7 +546,7 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n             ty::MutBorrow => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0301,\n                           \"cannot mutably borrow in a pattern guard\")\n-                    .span_label(span, &format!(\"borrowed mutably in pattern guard\"))\n+                    .span_label(span, \"borrowed mutably in pattern guard\")\n                     .emit();\n             }\n             ty::ImmBorrow | ty::UniqueImmBorrow => {}\n@@ -557,7 +557,7 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n         match mode {\n             MutateMode::JustWrite | MutateMode::WriteAndRead => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")\n-                    .span_label(span, &format!(\"assignment in pattern guard\"))\n+                    .span_label(span, \"assignment in pattern guard\")\n                     .emit();\n             }\n             MutateMode::Init => {}\n@@ -588,7 +588,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n                 if !self.bindings_allowed {\n                     struct_span_err!(self.cx.tcx.sess, pat.span, E0303,\n                                      \"pattern bindings are not allowed after an `@`\")\n-                        .span_label(pat.span,  &format!(\"not allowed after `@`\"))\n+                        .span_label(pat.span,  \"not allowed after `@`\")\n                         .emit();\n                 }\n "}, {"sha": "0822f7134998572349e5c5cecb70fbfcf559bd00", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -114,9 +114,8 @@ impl Diagnostic {\n     /// all, and you just supplied a `Span` to create the diagnostic,\n     /// then the snippet will just include that `Span`, which is\n     /// called the primary span.\n-    pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n-                      -> &mut Self {\n-        self.span.push_span_label(span, format!(\"{}\", label));\n+    pub fn span_label<T: Into<String>>(&mut self, span: Span, label: T) -> &mut Self {\n+        self.span.push_span_label(span, label.into());\n         self\n     }\n "}, {"sha": "a9c2bbeba2aa4ba0486eb4db917c7dcd883be258", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -112,8 +112,10 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// all, and you just supplied a `Span` to create the diagnostic,\n     /// then the snippet will just include that `Span`, which is\n     /// called the primary span.\n-    forward!(pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n-                               -> &mut Self);\n+    pub fn span_label<T: Into<String>>(&mut self, span: Span, label: T) -> &mut Self {\n+        self.diagnostic.span_label(span, label);\n+        self\n+    }\n \n     forward!(pub fn note_expected_found(&mut self,\n                                         label: &fmt::Display,"}, {"sha": "39fe2188f68d1f5756015404d19c0b49999e7003", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                     None => {\n                         self.tcx.sess.span_fatal(\n                             attr.span,\n-                            &format!(\"missing DepNode variant\"));\n+                            \"missing DepNode variant\");\n                     }\n                 };\n                 self.then_this_would_need.push((attr.span,\n@@ -201,7 +201,7 @@ fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         for &(target_span, _, _, _) in then_this_would_need {\n             tcx.sess.span_err(\n                 target_span,\n-                &format!(\"no #[rustc_if_this_changed] annotation detected\"));\n+                \"no #[rustc_if_this_changed] annotation detected\");\n \n         }\n         return;\n@@ -219,7 +219,7 @@ fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             } else {\n                 tcx.sess.span_err(\n                     target_span,\n-                    &format!(\"OK\"));\n+                    \"OK\");\n             }\n         }\n     }"}, {"sha": "5facfe36efdb93c8b452b186e50b15526f23e1e3", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -383,7 +383,7 @@ fn check_config(tcx: TyCtxt, attr: &Attribute) -> bool {\n \n     tcx.sess.span_fatal(\n         attr.span,\n-        &format!(\"no cfg attribute\"));\n+        \"no cfg attribute\");\n }\n \n fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> ast::Name {"}, {"sha": "93ff609a280ae1d4b0d24431dcadef941b32b6a2", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -215,7 +215,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedUnsafe {\n                 let mut db = cx.struct_span_lint(UNUSED_UNSAFE, blk.span,\n                                                  \"unnecessary `unsafe` block\");\n \n-                db.span_label(blk.span, &\"unnecessary `unsafe` block\");\n+                db.span_label(blk.span, \"unnecessary `unsafe` block\");\n                 if let Some((kind, id)) = is_enclosed(cx, blk.id) {\n                     db.span_note(cx.tcx.hir.span(id),\n                                  &format!(\"because it's nested under this `unsafe` {}\", kind));"}, {"sha": "325511c9787e1b62655b9c47a0047bd4c1f7201c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -88,7 +88,7 @@ fn register_native_lib(sess: &Session,\n             Some(span) => {\n                 struct_span_err!(sess, span, E0454,\n                                  \"#[link(name = \\\"\\\")] given with empty name\")\n-                    .span_label(span, &format!(\"empty name given\"))\n+                    .span_label(span, \"empty name given\")\n                     .emit();\n             }\n             None => {\n@@ -1029,7 +1029,7 @@ impl<'a> CrateLoader<'a> {\n                 Some(k) => {\n                     struct_span_err!(self.sess, m.span, E0458,\n                               \"unknown kind: `{}`\", k)\n-                        .span_label(m.span, &format!(\"unknown kind\")).emit();\n+                        .span_label(m.span, \"unknown kind\").emit();\n                     cstore::NativeUnknown\n                 }\n                 None => cstore::NativeUnknown\n@@ -1042,7 +1042,7 @@ impl<'a> CrateLoader<'a> {\n                 None => {\n                     struct_span_err!(self.sess, m.span, E0459,\n                                      \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n-                        .span_label(m.span, &format!(\"missing `name` argument\")).emit();\n+                        .span_label(m.span, \"missing `name` argument\").emit();\n                     Symbol::intern(\"foo\")\n                 }\n             };"}, {"sha": "84bb82de370e4f55f5e4635060d8ccde38fa4dc9", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -367,7 +367,7 @@ impl<'a> Context<'a> {\n                 && self.triple != config::host_triple() {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n             }\n-            err.span_label(self.span, &format!(\"can't find crate\"));\n+            err.span_label(self.span, \"can't find crate\");\n             err\n         };\n "}, {"sha": "0d592b4d72be5b11df3d9ddd232ca0fa39cb921b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -242,9 +242,9 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                    to the crate attributes to enable\");\n         } else {\n             self.find_drop_implementation_method_span()\n-                .map(|span| err.span_label(span, &format!(\"destructor defined here\")));\n+                .map(|span| err.span_label(span, \"destructor defined here\"));\n \n-            err.span_label(self.span, &format!(\"constants cannot have destructors\"));\n+            err.span_label(self.span, \"constants cannot have destructors\");\n         }\n \n         err.emit();\n@@ -291,8 +291,8 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 \"cannot refer to statics by value, use a constant instead\"\n             };\n             struct_span_err!(self.tcx.sess, self.span, E0394, \"{}\", msg)\n-                .span_label(self.span, &format!(\"referring to another static by value\"))\n-                .note(&format!(\"use the address-of operator or a constant instead\"))\n+                .span_label(self.span, \"referring to another static by value\")\n+                .note(\"use the address-of operator or a constant instead\")\n                 .emit();\n \n             // Replace STATIC with NOT_CONST to avoid further errors.\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                         \"raw pointers cannot be dereferenced in {}s\",\n                                         this.mode)\n                                     .span_label(this.span,\n-                                        &format!(\"dereference of raw pointer in constant\"))\n+                                        \"dereference of raw pointer in constant\")\n                                     .emit();\n                                 }\n                             }\n@@ -645,7 +645,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             struct_span_err!(self.tcx.sess,  self.span, E0017,\n                                              \"references in {}s may only refer \\\n                                               to immutable values\", self.mode)\n-                                .span_label(self.span, &format!(\"{}s require immutable values\",\n+                                .span_label(self.span, format!(\"{}s require immutable values\",\n                                                                 self.mode))\n                                 .emit();\n                         }\n@@ -713,7 +713,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             self.mode)\n                         .span_label(\n                             self.span,\n-                            &format!(\"comparing raw pointers in static\"))\n+                            \"comparing raw pointers in static\")\n                         .emit();\n                     }\n                 }\n@@ -724,7 +724,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 if self.mode != Mode::Fn {\n                     struct_span_err!(self.tcx.sess, self.span, E0010,\n                                      \"allocations are not allowed in {}s\", self.mode)\n-                        .span_label(self.span, &format!(\"allocation not allowed in {}s\", self.mode))\n+                        .span_label(self.span, format!(\"allocation not allowed in {}s\", self.mode))\n                         .emit();\n                 }\n             }"}, {"sha": "d7fee7f3110f4cdb90e197f16dcfcab5fc0f0b63", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -55,7 +55,7 @@ impl<'a> AstValidator<'a> {\n                                            E0449,\n                                            \"unnecessary visibility qualifier\");\n             if vis == &Visibility::Public {\n-                err.span_label(span, &format!(\"`pub` not needed here\"));\n+                err.span_label(span, \"`pub` not needed here\");\n             }\n             if let Some(note) = note {\n                 err.note(note);\n@@ -80,7 +80,7 @@ impl<'a> AstValidator<'a> {\n             Constness::Const => {\n                 struct_span_err!(self.session, constness.span, E0379,\n                                  \"trait fns cannot be declared const\")\n-                    .span_label(constness.span, &format!(\"trait fns cannot be const\"))\n+                    .span_label(constness.span, \"trait fns cannot be const\")\n                     .emit();\n             }\n             _ => {}\n@@ -272,7 +272,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                                                    E0130,\n                                                    \"patterns aren't allowed in foreign function \\\n                                                     declarations\");\n-                    err.span_label(span, &format!(\"pattern not allowed in foreign function\"));\n+                    err.span_label(span, \"pattern not allowed in foreign function\");\n                     if is_recent {\n                         err.span_note(span,\n                                       \"this is a recent error, see issue #35203 for more details\");"}, {"sha": "a0998b1bd1bfb3fd7cd3a54da70b140d3987da0a", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -180,7 +180,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     Ok(Ordering::Greater) => {\n                         struct_span_err!(self.tcx.sess, start.span, E0030,\n                             \"lower range bound must be less than or equal to upper\")\n-                            .span_label(start.span, &format!(\"lower bound larger than upper bound\"))\n+                            .span_label(start.span, \"lower bound larger than upper bound\")\n                             .emit();\n                     }\n                     Err(ErrorReported) => {}"}, {"sha": "21a4c007fb1926b35144ee74db78919dd8ebf430", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                                              \"`break` with value from a `{}` loop\",\n                                              kind.name())\n                                 .span_label(e.span,\n-                                            &format!(\"can only break with a value inside `loop`\"))\n+                                            \"can only break with a value inside `loop`\")\n                                 .emit();\n                         }\n                     }\n@@ -154,12 +154,12 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n             Loop(_) => {}\n             Closure => {\n                 struct_span_err!(self.sess, span, E0267, \"`{}` inside of a closure\", name)\n-                .span_label(span, &format!(\"cannot break inside of a closure\"))\n+                .span_label(span, \"cannot break inside of a closure\")\n                 .emit();\n             }\n             Normal => {\n                 struct_span_err!(self.sess, span, E0268, \"`{}` outside of loop\", name)\n-                .span_label(span, &format!(\"cannot break outside of a loop\"))\n+                .span_label(span, \"cannot break outside of a loop\")\n                 .emit();\n             }\n         }\n@@ -169,7 +169,7 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n         struct_span_err!(self.sess, span, E0590,\n                          \"`break` or `continue` with no label in the condition of a `while` loop\")\n             .span_label(span,\n-                        &format!(\"unlabeled `{}` in the condition of a `while` loop\", cf_type))\n+                        format!(\"unlabeled `{}` in the condition of a `while` loop\", cf_type))\n             .emit();\n     }\n }"}, {"sha": "8d455adc23c99d95b500988fec69e1874f192d79", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'b: 'a, 'hir: 'b> CheckItemRecursionVisitor<'a, 'b, 'hir> {\n             });\n             if !any_static {\n                 struct_span_err!(self.sess, span, E0265, \"recursive constant\")\n-                    .span_label(span, &format!(\"recursion not allowed in constant\"))\n+                    .span_label(span, \"recursion not allowed in constant\")\n                     .emit();\n             }\n             return;"}, {"sha": "f63102433c1e6d5a6a51c2e0ea1ec65a1171694c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -433,7 +433,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n         if !def.is_enum() && !field.vis.is_accessible_from(self.current_item, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n                              field.name, def.variant_descr(), self.tcx.item_path_str(def.did))\n-                .span_label(span, &format!(\"field `{}` is private\", field.name))\n+                .span_label(span, format!(\"field `{}` is private\", field.name))\n                 .emit();\n         }\n     }\n@@ -926,7 +926,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n                     if self.has_pub_restricted || self.has_old_errors {\n                         let mut err = struct_span_err!(self.tcx.sess, self.span, E0446,\n                             \"private type `{}` in public interface\", ty);\n-                        err.span_label(self.span, &format!(\"can't leak private type\"));\n+                        err.span_label(self.span, \"can't leak private type\");\n                         err.emit();\n                     } else {\n                         self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n@@ -961,7 +961,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n                 if self.has_pub_restricted || self.has_old_errors {\n                     struct_span_err!(self.tcx.sess, self.span, E0445,\n                                      \"private trait `{}` in public interface\", trait_ref)\n-                        .span_label(self.span, &format!(\n+                        .span_label(self.span, format!(\n                                     \"private trait can't be public\"))\n                         .emit();\n                 } else {"}, {"sha": "ac556270886ac677dcb0247c2791345f6348e59b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -183,7 +183,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                            E0401,\n                                            \"can't use type parameters from outer function; \\\n                                            try using a local type parameter instead\");\n-            err.span_label(span, &format!(\"use of type variable from outer function\"));\n+            err.span_label(span, \"use of type variable from outer function\");\n             err\n         }\n         ResolutionError::OuterTypeParameterContext => {\n@@ -199,8 +199,8 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                             \"the name `{}` is already used for a type parameter \\\n                                             in this type parameter list\",\n                                             name);\n-             err.span_label(span, &format!(\"already used\"));\n-             err.span_label(first_use_span.clone(), &format!(\"first use of `{}`\", name));\n+             err.span_label(span, \"already used\");\n+             err.span_label(first_use_span.clone(), format!(\"first use of `{}`\", name));\n              err\n         }\n         ResolutionError::MethodNotMemberOfTrait(method, trait_) => {\n@@ -210,7 +210,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                            \"method `{}` is not a member of trait `{}`\",\n                                            method,\n                                            trait_);\n-            err.span_label(span, &format!(\"not a member of trait `{}`\", trait_));\n+            err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n             err\n         }\n         ResolutionError::TypeNotMemberOfTrait(type_, trait_) => {\n@@ -220,7 +220,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              \"type `{}` is not a member of trait `{}`\",\n                              type_,\n                              trait_);\n-            err.span_label(span, &format!(\"not a member of trait `{}`\", trait_));\n+            err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n             err\n         }\n         ResolutionError::ConstNotMemberOfTrait(const_, trait_) => {\n@@ -230,7 +230,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              \"const `{}` is not a member of trait `{}`\",\n                              const_,\n                              trait_);\n-            err.span_label(span, &format!(\"not a member of trait `{}`\", trait_));\n+            err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n             err\n         }\n         ResolutionError::VariableNotBoundInPattern(binding_error) => {\n@@ -239,11 +239,11 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             let msg = format!(\"variable `{}` is not bound in all patterns\", binding_error.name);\n             let mut err = resolver.session.struct_span_err_with_code(msp, &msg, \"E0408\");\n             for sp in target_sp {\n-                err.span_label(sp, &format!(\"pattern doesn't bind `{}`\", binding_error.name));\n+                err.span_label(sp, format!(\"pattern doesn't bind `{}`\", binding_error.name));\n             }\n             let origin_sp = binding_error.origin.iter().map(|x| *x).collect::<Vec<_>>();\n             for sp in origin_sp {\n-                err.span_label(sp, &\"variable not in all patterns\");\n+                err.span_label(sp, \"variable not in all patterns\");\n             }\n             err\n         }\n@@ -255,8 +255,8 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              \"variable `{}` is bound in inconsistent \\\n                              ways within the same match arm\",\n                              variable_name);\n-            err.span_label(span, &format!(\"bound in different ways\"));\n-            err.span_label(first_binding_span, &format!(\"first binding\"));\n+            err.span_label(span, \"bound in different ways\");\n+            err.span_label(first_binding_span, \"first binding\");\n             err\n         }\n         ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n@@ -265,7 +265,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              E0415,\n                              \"identifier `{}` is bound more than once in this parameter list\",\n                              identifier);\n-            err.span_label(span, &format!(\"used as parameter more than once\"));\n+            err.span_label(span, \"used as parameter more than once\");\n             err\n         }\n         ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n@@ -274,7 +274,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              E0416,\n                              \"identifier `{}` is bound more than once in the same pattern\",\n                              identifier);\n-            err.span_label(span, &format!(\"used in a pattern more than once\"));\n+            err.span_label(span, \"used in a pattern more than once\");\n             err\n         }\n         ResolutionError::UndeclaredLabel(name) => {\n@@ -283,7 +283,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                            E0426,\n                                            \"use of undeclared label `{}`\",\n                                            name);\n-            err.span_label(span, &format!(\"undeclared label `{}`\",&name));\n+            err.span_label(span, format!(\"undeclared label `{}`\", name));\n             err\n         }\n         ResolutionError::SelfImportsOnlyAllowedWithin => {\n@@ -313,14 +313,14 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             };\n             let mut err = struct_span_err!(resolver.session, span, E0432, \"{}\", msg);\n             if let Some((_, p)) = name {\n-                err.span_label(span, &p);\n+                err.span_label(span, p);\n             }\n             err\n         }\n         ResolutionError::FailedToResolve(msg) => {\n             let mut err = struct_span_err!(resolver.session, span, E0433,\n                                            \"failed to resolve. {}\", msg);\n-            err.span_label(span, &msg);\n+            err.span_label(span, msg);\n             err\n         }\n         ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n@@ -336,7 +336,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              span,\n                              E0435,\n                              \"attempt to use a non-constant value in a constant\");\n-            err.span_label(span, &format!(\"non-constant used with constant\"));\n+            err.span_label(span, \"non-constant used with constant\");\n             err\n         }\n         ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, name, binding) => {\n@@ -345,17 +345,17 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                            span,\n                                            E0530,\n                                            \"{}s cannot shadow {}s\", what_binding, shadows_what);\n-            err.span_label(span, &format!(\"cannot be named the same as a {}\", shadows_what));\n+            err.span_label(span, format!(\"cannot be named the same as a {}\", shadows_what));\n             let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-            let msg = &format!(\"a {} `{}` is {} here\", shadows_what, name, participle);\n+            let msg = format!(\"a {} `{}` is {} here\", shadows_what, name, participle);\n             err.span_label(binding.span, msg);\n             err\n         }\n         ResolutionError::ForwardDeclaredTyParam => {\n             let mut err = struct_span_err!(resolver.session, span, E0128,\n                                            \"type parameters with a default cannot use \\\n                                             forward declared identifiers\");\n-            err.span_label(span, &format!(\"defaulted type parameters \\\n+            err.span_label(span, format!(\"defaulted type parameters \\\n                                            cannot be forward declared\"));\n             err\n         }\n@@ -2256,13 +2256,13 @@ impl<'a> Resolver<'a> {\n             if is_self_type(path, ns) {\n                 __diagnostic_used!(E0411);\n                 err.code(\"E0411\".into());\n-                err.span_label(span, &format!(\"`Self` is only available in traits and impls\"));\n+                err.span_label(span, \"`Self` is only available in traits and impls\");\n                 return err;\n             }\n             if is_self_value(path, ns) {\n                 __diagnostic_used!(E0424);\n                 err.code(\"E0424\".into());\n-                err.span_label(span, &format!(\"`self` value is only available in \\\n+                err.span_label(span, format!(\"`self` value is only available in \\\n                                                methods with `self` parameter\"));\n                 return err;\n             }\n@@ -2294,18 +2294,18 @@ impl<'a> Resolver<'a> {\n                     let self_is_available = this.self_value_is_available(path[0].ctxt);\n                     match candidate {\n                         AssocSuggestion::Field => {\n-                            err.span_label(span, &format!(\"did you mean `self.{}`?\", path_str));\n+                            err.span_label(span, format!(\"did you mean `self.{}`?\", path_str));\n                             if !self_is_available {\n-                                err.span_label(span, &format!(\"`self` value is only available in \\\n+                                err.span_label(span, format!(\"`self` value is only available in \\\n                                                                methods with `self` parameter\"));\n                             }\n                         }\n                         AssocSuggestion::MethodWithSelf if self_is_available => {\n-                            err.span_label(span, &format!(\"did you mean `self.{}(...)`?\",\n+                            err.span_label(span, format!(\"did you mean `self.{}(...)`?\",\n                                                            path_str));\n                         }\n                         AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n-                            err.span_label(span, &format!(\"did you mean `Self::{}`?\", path_str));\n+                            err.span_label(span, format!(\"did you mean `Self::{}`?\", path_str));\n                         }\n                     }\n                     return err;\n@@ -2316,29 +2316,29 @@ impl<'a> Resolver<'a> {\n \n             // Try Levenshtein.\n             if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected) {\n-                err.span_label(ident_span, &format!(\"did you mean `{}`?\", candidate));\n+                err.span_label(ident_span, format!(\"did you mean `{}`?\", candidate));\n                 levenshtein_worked = true;\n             }\n \n             // Try context dependent help if relaxed lookup didn't work.\n             if let Some(def) = def {\n                 match (def, source) {\n                     (Def::Macro(..), _) => {\n-                        err.span_label(span, &format!(\"did you mean `{}!(...)`?\", path_str));\n+                        err.span_label(span, format!(\"did you mean `{}!(...)`?\", path_str));\n                         return err;\n                     }\n                     (Def::TyAlias(..), PathSource::Trait) => {\n-                        err.span_label(span, &format!(\"type aliases cannot be used for traits\"));\n+                        err.span_label(span, \"type aliases cannot be used for traits\");\n                         return err;\n                     }\n                     (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n                         ExprKind::Field(_, ident) => {\n-                            err.span_label(parent.span, &format!(\"did you mean `{}::{}`?\",\n+                            err.span_label(parent.span, format!(\"did you mean `{}::{}`?\",\n                                                                  path_str, ident.node));\n                             return err;\n                         }\n                         ExprKind::MethodCall(ident, ..) => {\n-                            err.span_label(parent.span, &format!(\"did you mean `{}::{}(...)`?\",\n+                            err.span_label(parent.span, format!(\"did you mean `{}::{}(...)`?\",\n                                                                  path_str, ident.node));\n                             return err;\n                         }\n@@ -2349,12 +2349,12 @@ impl<'a> Resolver<'a> {\n                             if let Some((ctor_def, ctor_vis))\n                                     = this.struct_constructors.get(&def_id).cloned() {\n                                 if is_expected(ctor_def) && !this.is_accessible(ctor_vis) {\n-                                    err.span_label(span, &format!(\"constructor is not visible \\\n+                                    err.span_label(span, format!(\"constructor is not visible \\\n                                                                    here due to private fields\"));\n                                 }\n                             }\n                         }\n-                        err.span_label(span, &format!(\"did you mean `{} {{ /* fields */ }}`?\",\n+                        err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\",\n                                                        path_str));\n                         return err;\n                     }\n@@ -2364,7 +2364,7 @@ impl<'a> Resolver<'a> {\n \n             // Fallback label.\n             if !levenshtein_worked {\n-                err.span_label(base_span, &fallback_label);\n+                err.span_label(base_span, fallback_label);\n             }\n             err\n         };\n@@ -3374,9 +3374,9 @@ impl<'a> Resolver<'a> {\n             },\n         };\n \n-        err.span_label(span, &format!(\"`{}` already {}\", name, participle));\n+        err.span_label(span, format!(\"`{}` already {}\", name, participle));\n         if old_binding.span != syntax_pos::DUMMY_SP {\n-            err.span_label(old_binding.span, &format!(\"previous {} of `{}` here\", noun, name));\n+            err.span_label(old_binding.span, format!(\"previous {} of `{}` here\", noun, name));\n         }\n         err.emit();\n         self.name_already_seen.insert(name, span);"}, {"sha": "106f421f39e75b12a5b65e8da2b9c61f68525fa6", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -630,7 +630,7 @@ impl<'a> Resolver<'a> {\n                     err.help(&format!(\"did you mean `{}`?\", suggestion));\n                 }\n             } else {\n-                err.help(&format!(\"have you added the `#[macro_use]` on the module/import?\"));\n+                err.help(\"have you added the `#[macro_use]` on the module/import?\");\n             }\n         }\n     }"}, {"sha": "804e1ea740f50e4152c75fbc14a4ad03317ffddd", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -539,7 +539,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Ok(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     struct_span_err!(this.session, directive.span, E0253, \"{}\", &msg)\n-                        .span_label(directive.span, &format!(\"cannot be imported directly\"))\n+                        .span_label(directive.span, \"cannot be imported directly\")\n                         .emit();\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n@@ -701,7 +701,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             } else if ns == TypeNS {\n                 struct_span_err!(self.session, directive.span, E0365,\n                                  \"`{}` is private, and cannot be reexported\", ident)\n-                    .span_label(directive.span, &format!(\"reexport of private `{}`\", ident))\n+                    .span_label(directive.span, format!(\"reexport of private `{}`\", ident))\n                     .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                     .emit();\n             } else {\n@@ -794,7 +794,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                             let msg =\n                                 format!(\"a macro named `{}` has already been exported\", ident);\n                             self.session.struct_span_err(span, &msg)\n-                                .span_label(span, &format!(\"`{}` already exported\", ident))\n+                                .span_label(span, format!(\"`{}` already exported\", ident))\n                                 .span_note(binding.span, \"previous macro export here\")\n                                 .emit();\n                         }"}, {"sha": "adcb3d682ca238b7541a3ad584155562c6f80463", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -163,7 +163,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::ParenthesizedParameters(..) => {\n                 struct_span_err!(tcx.sess, span, E0214,\n                           \"parenthesized parameters may only be used with a trait\")\n-                    .span_label(span, &format!(\"only traits may use parentheses\"))\n+                    .span_label(span, \"only traits may use parentheses\")\n                     .emit();\n \n                 return Substs::for_item(tcx, def_id, |_, _| {\n@@ -294,7 +294,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     struct_span_err!(tcx.sess, span, E0393,\n                                      \"the type parameter `{}` must be explicitly specified\",\n                                      def.name)\n-                        .span_label(span, &format!(\"missing reference to `{}`\", def.name))\n+                        .span_label(span, format!(\"missing reference to `{}`\", def.name))\n                         .note(&format!(\"because of the default `Self` reference, \\\n                                         type parameters must be specified on object types\"))\n                         .emit();\n@@ -635,7 +635,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             let span = b.trait_ref.path.span;\n             struct_span_err!(self.tcx().sess, span, E0225,\n                 \"only Send/Sync traits can be used as additional traits in a trait object\")\n-                .span_label(span, &format!(\"non-Send/Sync additional trait\"))\n+                .span_label(span, \"non-Send/Sync additional trait\")\n                 .emit();\n         }\n \n@@ -684,7 +684,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n                         name,\n                         tcx.item_path_str(trait_def_id))\n-                        .span_label(span, &format!(\n+                        .span_label(span, format!(\n                             \"missing associated type `{}` value\", name))\n                         .emit();\n         }\n@@ -730,7 +730,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                         trait_str: &str,\n                                         name: &str) {\n         struct_span_err!(self.tcx().sess, span, E0223, \"ambiguous associated type\")\n-            .span_label(span, &format!(\"ambiguous associated type\"))\n+            .span_label(span, \"ambiguous associated type\")\n             .note(&format!(\"specify the type using the syntax `<{} as {}>::{}`\",\n                   type_str, trait_str, name))\n             .emit();\n@@ -784,7 +784,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                           \"associated type `{}` not found for `{}`\",\n                           assoc_name,\n                           ty_param_name)\n-                  .span_label(span, &format!(\"associated type `{}` not found\", assoc_name))\n+                  .span_label(span, format!(\"associated type `{}` not found\", assoc_name))\n                   .emit();\n                 return Err(ErrorReported);\n             }\n@@ -797,7 +797,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 \"ambiguous associated type `{}` in bounds of `{}`\",\n                 assoc_name,\n                 ty_param_name);\n-            err.span_label(span, &format!(\"ambiguous associated type `{}`\", assoc_name));\n+            err.span_label(span, format!(\"ambiguous associated type `{}`\", assoc_name));\n \n             for bound in bounds {\n                 let bound_span = self.tcx().associated_items(bound.def_id()).find(|item| {\n@@ -806,7 +806,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 .and_then(|item| self.tcx().hir.span_if_local(item.def_id));\n \n                 if let Some(span) = bound_span {\n-                    err.span_label(span, &format!(\"ambiguous `{}` from `{}`\",\n+                    err.span_label(span, format!(\"ambiguous `{}` from `{}`\",\n                                                   assoc_name,\n                                                   bound));\n                 } else {\n@@ -951,15 +951,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             for typ in segment.parameters.types() {\n                 struct_span_err!(self.tcx().sess, typ.span, E0109,\n                                  \"type parameters are not allowed on this type\")\n-                    .span_label(typ.span, &format!(\"type parameter not allowed\"))\n+                    .span_label(typ.span, \"type parameter not allowed\")\n                     .emit();\n                 break;\n             }\n             for lifetime in segment.parameters.lifetimes() {\n                 struct_span_err!(self.tcx().sess, lifetime.span, E0110,\n                                  \"lifetime parameters are not allowed on this type\")\n                     .span_label(lifetime.span,\n-                                &format!(\"lifetime parameter not allowed on this type\"))\n+                                \"lifetime parameter not allowed on this type\")\n                     .emit();\n                 break;\n             }\n@@ -973,7 +973,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn prohibit_projection(&self, span: Span) {\n         let mut err = struct_span_err!(self.tcx().sess, span, E0229,\n                                        \"associated type bindings are not allowed here\");\n-        err.span_label(span, &format!(\"associate type not allowed here\")).emit();\n+        err.span_label(span, \"associate type not allowed here\").emit();\n     }\n \n     // Check a type Path and convert it to a Ty.\n@@ -1214,7 +1214,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyTypeof(ref _e) => {\n                 struct_span_err!(tcx.sess, ast_ty.span, E0516,\n                                  \"`typeof` is a reserved keyword but unimplemented\")\n-                    .span_label(ast_ty.span, &format!(\"reserved keyword\"))\n+                    .span_label(ast_ty.span, \"reserved keyword\")\n                     .emit();\n \n                 tcx.types.err\n@@ -1426,7 +1426,7 @@ fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n                 \"wrong number of type arguments: {} {}, found {}\",\n                 expected, required, supplied)\n             .span_label(span,\n-                &format!(\"{} {} type argument{}\",\n+                format!(\"{} {} type argument{}\",\n                     expected,\n                     required,\n                     arguments_plural))\n@@ -1444,7 +1444,7 @@ fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n                 expected, supplied)\n             .span_label(\n                 span,\n-                &format!(\"{} type argument{}\",\n+                format!(\"{} type argument{}\",\n                     if accepted == 0 { \"expected no\" } else { &expected },\n                     arguments_plural)\n             )\n@@ -1470,7 +1470,7 @@ fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected\n     struct_span_err!(tcx.sess, span, E0107,\n                      \"wrong number of lifetime parameters: expected {}, found {}\",\n                      expected, number)\n-        .span_label(span, &label)\n+        .span_label(span, label)\n         .emit();\n }\n "}, {"sha": "bbe34f37950dc6b7b9238092cf87891785b01654", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     struct_span_err!(tcx.sess, span, E0029,\n                         \"only char and numeric types are allowed in range patterns\")\n-                        .span_label(span, &format!(\"ranges require char or numeric types\"))\n+                        .span_label(span, \"ranges require char or numeric types\")\n                         .note(&format!(\"start type: {}\", self.ty_to_string(lhs_ty)))\n                         .note(&format!(\"end type: {}\", self.ty_to_string(rhs_ty)))\n                         .emit();\n@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     tcx.sess, pat.span, E0527,\n                                     \"pattern requires {} elements but array has {}\",\n                                     min_len, size)\n-                                    .span_label(pat.span, &format!(\"expected {} elements\",size))\n+                                    .span_label(pat.span, format!(\"expected {} elements\",size))\n                                     .emit();\n                             }\n                             (inner_ty, tcx.types.err)\n@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     \"pattern requires at least {} elements but array has {}\",\n                                     min_len, size)\n                                 .span_label(pat.span,\n-                                    &format!(\"pattern cannot match array of {} elements\", size))\n+                                    format!(\"pattern cannot match array of {} elements\", size))\n                                 .emit();\n                             (inner_ty, tcx.types.err)\n                         }\n@@ -297,7 +297,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             }\n \n                             err.span_label( pat.span,\n-                                &format!(\"pattern cannot match with input type `{}`\", expected_ty)\n+                                format!(\"pattern cannot match with input type `{}`\", expected_ty)\n                             ).emit();\n                         }\n                         (tcx.types.err, tcx.types.err)\n@@ -379,7 +379,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let type_str = self.ty_to_string(expected);\n                     struct_span_err!(self.tcx.sess, span, E0033,\n                               \"type `{}` cannot be dereferenced\", type_str)\n-                        .span_label(span, &format!(\"type `{}` cannot be dereferenced\", type_str))\n+                        .span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str))\n                         .emit();\n                     return false\n                 }\n@@ -593,7 +593,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               def.kind_name(),\n                               hir::print::to_string(&tcx.hir, |s| s.print_qpath(qpath, false)));\n             struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n-                .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n+                .span_label(pat.span, \"not a tuple variant or struct\").emit();\n             on_error();\n         };\n \n@@ -642,7 +642,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                              \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n                              subpats.len(), subpats_ending, def.kind_name(),\n                              variant.fields.len(),  fields_ending)\n-                .span_label(pat.span, &format!(\"expected {} field{}, found {}\",\n+                .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n                                                variant.fields.len(), fields_ending, subpats.len()))\n                 .emit();\n             on_error();\n@@ -683,8 +683,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       in the pattern\",\n                                      field.name)\n                         .span_label(span,\n-                                    &format!(\"multiple uses of `{}` in pattern\", field.name))\n-                        .span_label(*occupied.get(), &format!(\"first use of `{}`\", field.name))\n+                                    format!(\"multiple uses of `{}` in pattern\", field.name))\n+                        .span_label(*occupied.get(), format!(\"first use of `{}`\", field.name))\n                         .emit();\n                     tcx.types.err\n                 }\n@@ -703,7 +703,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              tcx.item_path_str(variant.did),\n                                              field.name)\n                                 .span_label(span,\n-                                            &format!(\"{} `{}` does not have field `{}`\",\n+                                            format!(\"{} `{}` does not have field `{}`\",\n                                                      kind_name,\n                                                      tcx.item_path_str(variant.did),\n                                                      field.name))\n@@ -732,7 +732,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 struct_span_err!(tcx.sess, span, E0027,\n                                 \"pattern does not mention field `{}`\",\n                                 field.name)\n-                                .span_label(span, &format!(\"missing field `{}`\", field.name))\n+                                .span_label(span, format!(\"missing field `{}`\", field.name))\n                                 .emit();\n             }\n         }"}, {"sha": "f03451c04ed004a19d5d38c0bc0295b2fa84ce49", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n                              E0055,\n                              \"reached the recursion limit while auto-dereferencing {:?}\",\n                              self.cur_ty)\n-                .span_label(self.span, &format!(\"deref recursion limit reached\"))\n+                .span_label(self.span, \"deref recursion limit reached\")\n                 .help(&format!(\n                         \"consider adding a `#[recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                         suggested_limit))"}, {"sha": "dde5f598a68329ec77a3e91c858fdcfb46575085", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -27,7 +27,7 @@ use rustc::hir;\n pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefId) {\n     if tcx.lang_items.drop_trait() == Some(trait_id) {\n         struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\")\n-            .span_label(span, &format!(\"explicit destructor calls not allowed\"))\n+            .span_label(span, \"explicit destructor calls not allowed\")\n             .emit();\n     }\n }"}, {"sha": "72ce7d3b5ed711abe4cb6539cd5380fb19108af9", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                        },\n                                        self.expr_ty);\n                 err.span_label(error_span,\n-                               &format!(\"cannot cast `{}` as `{}`\",\n+                               format!(\"cannot cast `{}` as `{}`\",\n                                         fcx.ty_to_string(self.expr_ty),\n                                         cast_ty));\n                 if let Ok(snippet) = fcx.sess().codemap().span_to_snippet(self.expr.span) {\n@@ -200,7 +200,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             }\n             CastError::CastToBool => {\n                 struct_span_err!(fcx.tcx.sess, self.span, E0054, \"cannot cast as `bool`\")\n-                    .span_label(self.span, &format!(\"unsupported cast\"))\n+                    .span_label(self.span, \"unsupported cast\")\n                     .help(\"compare with zero instead\")\n                     .emit();\n             }"}, {"sha": "c228fc6b24abde730be51c16c4ae0618176e0a79", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -1144,7 +1144,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         db = struct_span_err!(\n                             fcx.tcx.sess, cause.span, E0069,\n                             \"`return;` in a function whose return type is not `()`\");\n-                        db.span_label(cause.span, &format!(\"return type is not ()\"));\n+                        db.span_label(cause.span, \"return type is not ()\");\n                     }\n                     _ => {\n                         db = fcx.report_mismatched_types(cause, expected, found, err);"}, {"sha": "0579bb15fd6d2d8e8098faab59077745d9efe463", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -402,7 +402,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          \"lifetime parameters or bounds on method `{}` do not match the \\\n                           trait declaration\",\n                          impl_m.name)\n-            .span_label(span, &format!(\"lifetimes do not match trait\"))\n+            .span_label(span, \"lifetimes do not match trait\")\n             .emit();\n         return Err(ErrorReported);\n     }\n@@ -534,9 +534,9 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             not in the trait\",\n                                            trait_m.name,\n                                            self_descr);\n-            err.span_label(impl_m_span, &format!(\"`{}` used in impl\", self_descr));\n+            err.span_label(impl_m_span, format!(\"`{}` used in impl\", self_descr));\n             if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n-                err.span_label(span, &format!(\"trait declared without `{}`\", self_descr));\n+                err.span_label(span, format!(\"trait declared without `{}`\", self_descr));\n             }\n             err.emit();\n             return Err(ErrorReported);\n@@ -552,9 +552,9 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            trait_m.name,\n                                            self_descr);\n             err.span_label(impl_m_span,\n-                           &format!(\"expected `{}` in impl\", self_descr));\n+                           format!(\"expected `{}` in impl\", self_descr));\n             if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n-                err.span_label(span, &format!(\"`{}` used in trait\", self_descr));\n+                err.span_label(span, format!(\"`{}` used in trait\", self_descr));\n             }\n             err.emit();\n             return Err(ErrorReported);\n@@ -606,7 +606,7 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         if let Some(span) = trait_item_span {\n             err.span_label(span,\n-                           &format!(\"expected {}\",\n+                           format!(\"expected {}\",\n                                     &if num_trait_m_type_params != 1 {\n                                         format!(\"{} type parameters\", num_trait_m_type_params)\n                                     } else {\n@@ -617,7 +617,7 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         err.span_label(span,\n-                       &format!(\"found {}{}\",\n+                       format!(\"found {}{}\",\n                                 &if num_impl_m_type_params != 1 {\n                                     format!(\"{} type parameters\", num_impl_m_type_params)\n                                 } else {\n@@ -696,15 +696,15 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        trait_number_args);\n         if let Some(trait_span) = trait_span {\n             err.span_label(trait_span,\n-                           &format!(\"trait requires {}\",\n+                           format!(\"trait requires {}\",\n                                     &if trait_number_args != 1 {\n                                         format!(\"{} parameters\", trait_number_args)\n                                     } else {\n                                         format!(\"{} parameter\", trait_number_args)\n                                     }));\n         }\n         err.span_label(impl_span,\n-                       &format!(\"expected {}, found {}\",\n+                       format!(\"expected {}, found {}\",\n                                 &if trait_number_args != 1 {\n                                     format!(\"{} parameters\", trait_number_args)\n                                 } else {"}, {"sha": "60067e6a6ec0238e9c8da62e73ec9f60ed71e31c", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -57,7 +57,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         \"intrinsic has wrong number of type \\\n                         parameters: found {}, expected {}\",\n                         i_n_tps, n_tps)\n-            .span_label(span, &format!(\"expected {} type parameter\", n_tps))\n+            .span_label(span, format!(\"expected {} type parameter\", n_tps))\n             .emit();\n     } else {\n         require_same_types(tcx,\n@@ -101,7 +101,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             op => {\n                 struct_span_err!(tcx.sess, it.span, E0092,\n                       \"unrecognized atomic operation function: `{}`\", op)\n-                  .span_label(it.span, &format!(\"unrecognized atomic operation\"))\n+                  .span_label(it.span, \"unrecognized atomic operation\")\n                   .emit();\n                 return;\n             }\n@@ -305,7 +305,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 struct_span_err!(tcx.sess, it.span, E0093,\n                                 \"unrecognized intrinsic function: `{}`\",\n                                 *other)\n-                                .span_label(it.span, &format!(\"unrecognized intrinsic\"))\n+                                .span_label(it.span, \"unrecognized intrinsic\")\n                                 .emit();\n                 return;\n             }\n@@ -505,7 +505,7 @@ fn match_intrinsic_type_to_type<'a, 'tcx>(\n                     }\n                 }\n                 _ => simple_error(&format!(\"`{}`\", t),\n-                                  &format!(\"tuple\")),\n+                                  \"tuple\"),\n             }\n         }\n     }"}, {"sha": "fdde4e9fef497cedbfa82d1a71fbe4ce9c844080", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -285,7 +285,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                  self.span,\n                                  E0035,\n                                  \"does not take type parameters\")\n-                    .span_label(self.span, &\"called with unneeded type parameters\")\n+                    .span_label(self.span, \"called with unneeded type parameters\")\n                     .emit();\n             } else {\n                 struct_span_err!(self.tcx.sess,\n@@ -296,7 +296,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                  num_method_types,\n                                  num_supplied_types)\n                     .span_label(self.span,\n-                                &format!(\"Passed {} type argument{}, expected {}\",\n+                                format!(\"Passed {} type argument{}, expected {}\",\n                                          num_supplied_types,\n                                          if num_supplied_types != 1 { \"s\" } else { \"\" },\n                                          num_method_types))"}, {"sha": "c7ec379b0de25d9fc1181a959ebe42a3407ebd8e", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -209,9 +209,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                               expr_string,\n                                                               item_name));\n                                         }\n-                                        err.span_label(span, &\"field, not a method\");\n+                                        err.span_label(span, \"field, not a method\");\n                                     } else {\n-                                        err.span_label(span, &\"private field, not a method\");\n+                                        err.span_label(span, \"private field, not a method\");\n                                     }\n                                     break;\n                                 }\n@@ -272,7 +272,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                span,\n                                                E0034,\n                                                \"multiple applicable items in scope\");\n-                err.span_label(span, &format!(\"multiple `{}` found\", item_name));\n+                err.span_label(span, format!(\"multiple `{}` found\", item_name));\n \n                 report_candidates(&mut err, sources);\n                 err.emit();"}, {"sha": "127ffc60cf4dd90ae66c0a0eccaa35ab19aaff6d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -1130,7 +1130,7 @@ fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             struct_span_err!(\n                 tcx.sess, attr.span, E0232,\n                 \"this attribute must have a value\")\n-                .span_label(attr.span, &format!(\"attribute requires a value\"))\n+                .span_label(attr.span, \"attribute requires a value\")\n                 .note(&format!(\"eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\"))\n                 .emit();\n         }\n@@ -1146,12 +1146,12 @@ fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         \"`{}` specializes an item from a parent `impl`, but \\\n          that item is not marked `default`\",\n         impl_item.name);\n-    err.span_label(impl_item.span, &format!(\"cannot specialize default item `{}`\",\n+    err.span_label(impl_item.span, format!(\"cannot specialize default item `{}`\",\n                                             impl_item.name));\n \n     match tcx.span_of_impl(parent_impl) {\n         Ok(span) => {\n-            err.span_label(span, &\"parent `impl` is here\");\n+            err.span_label(span, \"parent `impl` is here\");\n             err.note(&format!(\"to specialize, `{}` in the parent `impl` must be marked `default`\",\n                               impl_item.name));\n         }\n@@ -1226,11 +1226,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   which doesn't match its trait `{}`\",\n                                   ty_impl_item.name,\n                                   impl_trait_ref);\n-                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         err.span_label(impl_item.span, \"does not match trait\");\n                          // We can only get the spans from local trait definition\n                          // Same for E0324 and E0325\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n-                            err.span_label(trait_span, &format!(\"item in trait\"));\n+                            err.span_label(trait_span, \"item in trait\");\n                          }\n                          err.emit()\n                     }\n@@ -1262,9 +1262,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   which doesn't match its trait `{}`\",\n                                   ty_impl_item.name,\n                                   impl_trait_ref);\n-                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n-                            err.span_label(trait_span, &format!(\"item in trait\"));\n+                            err.span_label(trait_span, \"item in trait\");\n                          }\n                          err.emit()\n                     }\n@@ -1280,9 +1280,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   which doesn't match its trait `{}`\",\n                                   ty_impl_item.name,\n                                   impl_trait_ref);\n-                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n-                            err.span_label(trait_span, &format!(\"item in trait\"));\n+                            err.span_label(trait_span, \"item in trait\");\n                          }\n                          err.emit()\n                     }\n@@ -1331,13 +1331,13 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             missing_items.iter()\n                   .map(|trait_item| trait_item.name.to_string())\n                   .collect::<Vec<_>>().join(\"`, `\"));\n-        err.span_label(impl_span, &format!(\"missing `{}` in implementation\",\n+        err.span_label(impl_span, format!(\"missing `{}` in implementation\",\n                 missing_items.iter()\n                     .map(|trait_item| trait_item.name.to_string())\n                     .collect::<Vec<_>>().join(\"`, `\")));\n         for trait_item in missing_items {\n             if let Some(span) = tcx.hir.span_if_local(trait_item.def_id) {\n-                err.span_label(span, &format!(\"`{}` from trait\", trait_item.name));\n+                err.span_label(span, format!(\"`{}` from trait\", trait_item.name));\n             } else {\n                 err.note(&format!(\"`{}` from trait: `{}`\",\n                                   trait_item.name,\n@@ -1377,7 +1377,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Representability::SelfRecursive(spans) => {\n             let mut err = tcx.recursive_type_with_infinite_size_error(item_def_id);\n             for span in spans {\n-                err.span_label(span, &\"recursive without indirection\");\n+                err.span_label(span, \"recursive without indirection\");\n             }\n             err.emit();\n             return false\n@@ -1399,7 +1399,7 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n             let e = fields[0].ty(tcx, substs);\n             if !fields.iter().all(|f| f.ty(tcx, substs) == e) {\n                 struct_span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\")\n-                                .span_label(sp, &format!(\"SIMD elements must have the same type\"))\n+                                .span_label(sp, \"SIMD elements must have the same type\")\n                                 .emit();\n                 return;\n             }\n@@ -1471,7 +1471,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         struct_span_err!(\n             tcx.sess, sp, E0084,\n             \"unsupported representation for zero-variant enum\")\n-            .span_label(sp, &format!(\"unsupported enum representation\"))\n+            .span_label(sp, \"unsupported enum representation\")\n             .emit();\n     }\n \n@@ -1505,8 +1505,8 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             };\n             struct_span_err!(tcx.sess, span, E0081,\n                              \"discriminant value `{}` already exists\", disr_vals[i])\n-                .span_label(i_span, &format!(\"first use of `{}`\", disr_vals[i]))\n-                .span_label(span , &format!(\"enum already has `{}`\", disr_vals[i]))\n+                .span_label(i_span, format!(\"first use of `{}`\", disr_vals[i]))\n+                .span_label(span , format!(\"enum already has `{}`\", disr_vals[i]))\n                 .emit();\n         }\n         disr_vals.push(discr);\n@@ -2401,12 +2401,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if arg_count == 1 {\" was\"} else {\"s were\"}),\n                 error_code);\n \n-            err.span_label(sp, &format!(\"expected {}{} parameter{}\",\n+            err.span_label(sp, format!(\"expected {}{} parameter{}\",\n                                         if variadic {\"at least \"} else {\"\"},\n                                         expected_count,\n                                         if expected_count == 1 {\"\"} else {\"s\"}));\n             if let Some(def_s) = def_span {\n-                err.span_label(def_s, &format!(\"defined here\"));\n+                err.span_label(def_s, \"defined here\");\n             }\n             err.emit();\n         }\n@@ -2938,10 +2938,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(suggested_field_name) =\n                         Self::suggest_field_name(def.struct_variant(), field, vec![]) {\n                             err.span_label(field.span,\n-                                           &format!(\"did you mean `{}`?\", suggested_field_name));\n+                                           format!(\"did you mean `{}`?\", suggested_field_name));\n                         } else {\n                             err.span_label(field.span,\n-                                           &format!(\"unknown field\"));\n+                                           \"unknown field\");\n                         };\n                 }\n                 ty::TyRawPtr(..) => {\n@@ -3076,15 +3076,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                            &field.name,\n                                                            skip_fields.collect()) {\n             err.span_label(field.name.span,\n-                           &format!(\"field does not exist - did you mean `{}`?\", field_name));\n+                           format!(\"field does not exist - did you mean `{}`?\", field_name));\n         } else {\n             match ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n-                    err.span_label(field.name.span, &format!(\"`{}::{}` does not have this field\",\n+                    err.span_label(field.name.span, format!(\"`{}::{}` does not have this field\",\n                                                              ty, variant.name));\n                 }\n                 _ => {\n-                    err.span_label(field.name.span, &format!(\"`{}` does not have this field\", ty));\n+                    err.span_label(field.name.span, format!(\"`{}` does not have this field\", ty));\n                 }\n             }\n         };\n@@ -3149,10 +3149,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                 \"field `{}` specified more than once\",\n                                                 field.name.node);\n \n-                    err.span_label(field.name.span, &format!(\"used more than once\"));\n+                    err.span_label(field.name.span, \"used more than once\");\n \n                     if let Some(prev_span) = seen_fields.get(&field.name.node) {\n-                        err.span_label(*prev_span, &format!(\"first use of `{}`\", field.name.node));\n+                        err.span_label(*prev_span, format!(\"first use of `{}`\", field.name.node));\n                     }\n \n                     err.emit();\n@@ -3199,7 +3199,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         remaining_fields_names,\n                         truncated_fields_error,\n                         adt_ty)\n-                        .span_label(span, &format!(\"missing {}{}\",\n+                        .span_label(span, format!(\"missing {}{}\",\n                             remaining_fields_names,\n                             truncated_fields_error))\n                         .emit();\n@@ -3266,7 +3266,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             struct_span_err!(self.tcx.sess, path_span, E0071,\n                              \"expected struct, variant or union type, found {}\",\n                              ty.sort_string(self.tcx))\n-                .span_label(path_span, &format!(\"not a struct\"))\n+                .span_label(path_span, \"not a struct\")\n                 .emit();\n             None\n         }\n@@ -3625,7 +3625,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     \"invalid left-hand side expression\")\n                 .span_label(\n                     expr.span,\n-                    &format!(\"left-hand of expression not valid\"))\n+                    \"left-hand of expression not valid\")\n                 .emit();\n             }\n \n@@ -4517,7 +4517,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                              \"too many lifetime parameters provided: \\\n                               expected at most {}, found {}\",\n                              expected_text, actual_text)\n-                .span_label(span, &format!(\"expected {}\", expected_text))\n+                .span_label(span, format!(\"expected {}\", expected_text))\n                 .emit();\n         } else if lifetimes.len() > 0 && lifetimes.len() < lifetime_defs.len() {\n             let expected_text = count_lifetime_params(lifetime_defs.len());\n@@ -4526,7 +4526,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                              \"too few lifetime parameters provided: \\\n                               expected {}, found {}\",\n                              expected_text, actual_text)\n-                .span_label(span, &format!(\"expected {}\", expected_text))\n+                .span_label(span, format!(\"expected {}\", expected_text))\n                 .emit();\n         }\n \n@@ -4551,7 +4551,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                              \"too many type parameters provided: \\\n                               expected at most {}, found {}\",\n                              expected_text, actual_text)\n-                .span_label(span, &format!(\"expected {}\", expected_text))\n+                .span_label(span, format!(\"expected {}\", expected_text))\n                 .emit();\n \n             // To prevent derived errors to accumulate due to extra\n@@ -4565,7 +4565,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                              \"too few type parameters provided: \\\n                               expected {}, found {}\",\n                              expected_text, actual_text)\n-                .span_label(span, &format!(\"expected {}\", expected_text))\n+                .span_label(span, format!(\"expected {}\", expected_text))\n                 .emit();\n         }\n \n@@ -4654,7 +4654,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             struct_span_err!(tcx.sess, param.span, E0091,\n                 \"type parameter `{}` is unused\",\n                 param.name)\n-                .span_label(param.span, &format!(\"unused type parameter\"))\n+                .span_label(param.span, \"unused type parameter\")\n                 .emit();\n         }\n     }"}, {"sha": "59cb61d9b97f0b3196126eb3637a6daca34a0c29", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 E0067, \"invalid left-hand side expression\")\n             .span_label(\n                 lhs_expr.span,\n-                &format!(\"invalid expression for left-hand side\"))\n+                \"invalid expression for left-hand side\")\n             .emit();\n         }\n         ty\n@@ -203,7 +203,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                          op.node.as_str(),\n                                          lhs_ty)\n                             .span_label(lhs_expr.span,\n-                                        &format!(\"cannot use `{}=` on type `{}`\",\n+                                        format!(\"cannot use `{}=` on type `{}`\",\n                                         op.node.as_str(), lhs_ty))\n                             .emit();\n                     } else {\n@@ -278,7 +278,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if let TyRef(_, r_ty) = rhs_ty.sty {\n                 if l_ty.ty.sty == TyStr && r_ty.ty.sty == TyStr {\n                     err.span_label(expr.span,\n-                        &\"`+` can't be used to concatenate two `&str` strings\");\n+                        \"`+` can't be used to concatenate two `&str` strings\");\n                     let codemap = self.tcx.sess.codemap();\n                     let suggestion =\n                         match codemap.span_to_snippet(lhs_expr.span) {"}, {"sha": "93529aecac039f883a39c9982543090002e819f4", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -684,15 +684,15 @@ fn error_392<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, param_name: ast:\n                        -> DiagnosticBuilder<'tcx> {\n     let mut err = struct_span_err!(tcx.sess, span, E0392,\n                   \"parameter `{}` is never used\", param_name);\n-    err.span_label(span, &format!(\"unused type parameter\"));\n+    err.span_label(span, \"unused type parameter\");\n     err\n }\n \n fn error_194(tcx: TyCtxt, span: Span, trait_decl_span: Span, name: ast::Name) {\n     struct_span_err!(tcx.sess, span, E0194,\n               \"type parameter `{}` shadows another type parameter of the same name\",\n               name)\n-        .span_label(span, &format!(\"shadows another type parameter\"))\n-        .span_label(trait_decl_span, &format!(\"first `{}` declared here\", name))\n+        .span_label(span, \"shadows another type parameter\")\n+        .span_label(trait_decl_span, format!(\"first `{}` declared here\", name))\n         .emit();\n }"}, {"sha": "743bfbb44ab7504ef2af4017a9f35fea53b22ae8", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -74,7 +74,7 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                          E0120,\n                                          \"the Drop trait may only be implemented on \\\n                                          structures\")\n-                            .span_label(span, &format!(\"implementing Drop requires a struct\"))\n+                            .span_label(span, \"implementing Drop requires a struct\")\n                             .emit();\n                     }\n                     _ => {\n@@ -130,7 +130,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              \"the trait `Copy` may not be implemented for this type\")\n                 .span_label(\n                     tcx.def_span(field.did),\n-                    &\"this field does not implement `Copy`\")\n+                    \"this field does not implement `Copy`\")\n                 .emit()\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n@@ -145,7 +145,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              span,\n                              E0206,\n                              \"the trait `Copy` may not be implemented for this type\")\n-                .span_label(span, &format!(\"type is not a structure or enumeration\"))\n+                .span_label(span, \"type is not a structure or enumeration\")\n                 .emit();\n         }\n         Err(CopyImplementationError::HasDestructor) => {\n@@ -154,7 +154,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              E0184,\n                              \"the trait `Copy` may not be implemented for this type; the \\\n                               type has a destructor\")\n-                .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n+                .span_label(span, \"Copy not allowed on types with destructors\")\n                 .emit();\n         }\n     }\n@@ -310,7 +310,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           })\n                                           .collect::<Vec<_>>()\n                                           .join(\", \")));\n-                    err.span_label(span, &format!(\"requires multiple coercions\"));\n+                    err.span_label(span, \"requires multiple coercions\");\n                     err.emit();\n                     return err_info;\n                 }"}, {"sha": "f7ebc21044222d28c90c309c62903e235656018c", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -259,7 +259,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n                                  ty.span,\n                                  E0118,\n                                  \"no base type found for inherent implementation\")\n-                    .span_label(ty.span, &format!(\"impl requires a base type\"))\n+                    .span_label(ty.span, \"impl requires a base type\")\n                     .note(&format!(\"either implement a trait on it or create a newtype \\\n                                     to wrap it instead\"))\n                     .emit();\n@@ -296,7 +296,7 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n                              \"cannot define inherent `impl` for a type outside of the crate \\\n                               where the type is defined\")\n                 .span_label(item.span,\n-                            &format!(\"impl for type defined outside of crate.\"))\n+                            \"impl for type defined outside of crate.\")\n                 .note(\"define and implement a trait or new type instead\")\n                 .emit();\n         }"}, {"sha": "2751e1ff38a5090620344d49ded167658087a8e5", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -56,9 +56,9 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n                                      \"duplicate definitions with name `{}`\",\n                                      name)\n                         .span_label(self.tcx.span_of_impl(item1).unwrap(),\n-                                    &format!(\"duplicate definitions for `{}`\", name))\n+                                    format!(\"duplicate definitions for `{}`\", name))\n                         .span_label(self.tcx.span_of_impl(item2).unwrap(),\n-                                    &format!(\"other definition for `{}`\", name))\n+                                    format!(\"other definition for `{}`\", name))\n                         .emit();\n                 }\n             }"}, {"sha": "8b9dc20315d25fff85ee0a9bf6a2b51cb6907a59", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -62,7 +62,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_d\n                          span,\n                          E0322,\n                          \"explicit impls for the `Sized` trait are not permitted\")\n-            .span_label(span, &format!(\"impl of 'Sized' not allowed\"))\n+            .span_label(span, \"impl of 'Sized' not allowed\")\n             .emit();\n         return;\n     }"}, {"sha": "097720adad447ee15bcee5fa4daf5c6d47345d6c", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -48,7 +48,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                          E0117,\n                                          \"only traits defined in the current crate can be \\\n                                           implemented for arbitrary types\")\n-                            .span_label(item.span, &format!(\"impl doesn't use types inside crate\"))\n+                            .span_label(item.span, \"impl doesn't use types inside crate\")\n                             .note(&format!(\"the impl does not reference any types defined in \\\n                                             this crate\"))\n                             .note(\"define and implement a trait or new type instead\")\n@@ -153,7 +153,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                      \"cannot create default implementations for traits outside \\\n                                       the crate they're defined in; define a new trait instead\")\n                         .span_label(item_trait_ref.path.span,\n-                                    &format!(\"`{}` trait not defined in this crate\",\n+                                    format!(\"`{}` trait not defined in this crate\",\n                             self.tcx.hir.node_to_pretty_string(item_trait_ref.ref_id)))\n                         .emit();\n                     return;"}, {"sha": "f479dc2e6ab617a60a52a60f8bf091d6b05b0834", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -60,9 +60,9 @@ pub fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n \n         match tcx.span_of_impl(overlap.with_impl) {\n             Ok(span) => {\n-                err.span_label(span, &format!(\"first implementation here\"));\n+                err.span_label(span, \"first implementation here\");\n                 err.span_label(tcx.span_of_impl(impl_def_id).unwrap(),\n-                               &format!(\"conflicting implementation{}\",\n+                               format!(\"conflicting implementation{}\",\n                                         overlap.self_desc\n                                             .map_or(String::new(),\n                                                     |ty| format!(\" for `{}`\", ty))));"}, {"sha": "ec200241ee695cc4a5f635b481cc6d0fe0cdc416", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -220,7 +220,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n             span,\n             E0121,\n             \"the type placeholder `_` is not allowed within types on item signatures\"\n-        ).span_label(span, &format!(\"not allowed in type signatures\"))\n+        ).span_label(span, \"not allowed in type signatures\")\n         .emit();\n         self.tcx().types.err\n     }\n@@ -568,7 +568,7 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         } else {\n             struct_span_err!(tcx.sess, variant.span, E0370,\n                              \"enum discriminant overflowed\")\n-                .span_label(variant.span, &format!(\"overflowed on value after {}\",\n+                .span_label(variant.span, format!(\"overflowed on value after {}\",\n                                                    prev_discr.unwrap()))\n                 .note(&format!(\"explicitly set `{} = {}` if that is desired outcome\",\n                                variant.node.name, wrapped_discr))\n@@ -604,8 +604,8 @@ fn convert_struct_variant<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             struct_span_err!(tcx.sess, f.span, E0124,\n                              \"field `{}` is already declared\",\n                              f.name)\n-                .span_label(f.span, &\"field already declared\")\n-                .span_label(prev_span, &format!(\"`{}` first declared here\", f.name))\n+                .span_label(f.span, \"field already declared\")\n+                .span_label(prev_span, format!(\"`{}` first declared here\", f.name))\n                 .emit();\n         } else {\n             seen_fields.insert(f.name, f.span);"}, {"sha": "6b4f08d3d4c8d73aca47443d934014ec687f4d07", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -166,7 +166,7 @@ fn report_unused_parameter(tcx: TyCtxt,\n         \"the {} parameter `{}` is not constrained by the \\\n         impl trait, self type, or predicates\",\n         kind, name)\n-        .span_label(span, &format!(\"unconstrained {} parameter\", kind))\n+        .span_label(span, format!(\"unconstrained {} parameter\", kind))\n         .emit();\n }\n \n@@ -188,9 +188,9 @@ fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                \"duplicate definitions with name `{}`:\",\n                                                impl_item.name);\n                 err.span_label(*entry.get(),\n-                               &format!(\"previous definition of `{}` here\",\n+                               format!(\"previous definition of `{}` here\",\n                                         impl_item.name));\n-                err.span_label(impl_item.span, &format!(\"duplicate definition\"));\n+                err.span_label(impl_item.span, \"duplicate definition\");\n                 err.emit();\n             }\n             Vacant(entry) => {"}, {"sha": "84de4ff2b7b69203b32cb09ba36c42231bd68c86", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -143,7 +143,7 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n     if decl.variadic && abi != Abi::C {\n         let mut err = struct_span_err!(tcx.sess, span, E0045,\n                   \"variadic function must have C calling convention\");\n-        err.span_label(span, &(\"variadics require C calling conventions\").to_string())\n+        err.span_label(span, \"variadics require C calling conventions\")\n             .emit();\n     }\n }\n@@ -190,7 +190,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 struct_span_err!(tcx.sess, generics.span, E0131,\n                                          \"main function is not allowed to have type parameters\")\n                                     .span_label(generics.span,\n-                                                &format!(\"main cannot have type parameters\"))\n+                                                \"main cannot have type parameters\")\n                                     .emit();\n                                 return;\n                             }\n@@ -240,7 +240,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             struct_span_err!(tcx.sess, ps.span, E0132,\n                                 \"start function is not allowed to have type parameters\")\n                                 .span_label(ps.span,\n-                                            &format!(\"start function cannot have type parameters\"))\n+                                            \"start function cannot have type parameters\")\n                                 .emit();\n                             return;\n                         }"}, {"sha": "5db82e23bbf1eb0244d6500e8c0533f21e6f0105", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -687,9 +687,9 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n             }\n         }\n         clean::Vector(ref t) if is_not_debug => {\n-            primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n+            primitive_link(f, PrimitiveType::Slice, \"[\")?;\n             fmt::Display::fmt(t, f)?;\n-            primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n+            primitive_link(f, PrimitiveType::Slice, \"]\")\n         }\n         clean::Vector(ref t) => write!(f, \"[{:?}]\", t),\n         clean::FixedVector(ref t, ref s) if is_not_debug => {"}, {"sha": "528d903b8b0187ba155995fb79754ed302ff043e", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -2412,7 +2412,7 @@ mod tests {\n \n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n-        let unicode = unicode.join(&format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n+        let unicode = unicode.join(\"test-\uac01\u4e01\u30fc\u518d\u89c1\");\n         check!(fs::create_dir(&unicode));\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());"}, {"sha": "0980b73e80c5c5d8125973de01fb8586db045b2d", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -511,8 +511,7 @@ pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Symb\n             } else {\n                 struct_span_err!(diag, attr.span, E0558,\n                                  \"export_name attribute has invalid format\")\n-                    .span_label(attr.span,\n-                                &format!(\"did you mean #[export_name=\\\"*\\\"]?\"))\n+                    .span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n                     .emit();\n                 None\n             }"}, {"sha": "ca1351e3b4158c89793b06bd622f4e54f22aad99", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198917bb4f13daca7225af61d17c6fd4f70487bd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=198917bb4f13daca7225af61d17c6fd4f70487bd", "patch": "@@ -602,10 +602,10 @@ impl<'a> Parser<'a> {\n                 label_sp\n             };\n             if self.span.contains(sp) {\n-                err.span_label(self.span, &label_exp);\n+                err.span_label(self.span, label_exp);\n             } else {\n-                err.span_label(sp, &label_exp);\n-                err.span_label(self.span, &\"unexpected token\");\n+                err.span_label(sp, label_exp);\n+                err.span_label(self.span, \"unexpected token\");\n             }\n             Err(err)\n         }\n@@ -1512,10 +1512,10 @@ impl<'a> Parser<'a> {\n                 err.span_suggestion(sum_span, \"try adding parentheses:\", sum_with_parens);\n             }\n             TyKind::Ptr(..) | TyKind::BareFn(..) => {\n-                err.span_label(sum_span, &\"perhaps you forgot parentheses?\");\n+                err.span_label(sum_span, \"perhaps you forgot parentheses?\");\n             }\n             _ => {\n-                err.span_label(sum_span, &\"expected a path\");\n+                err.span_label(sum_span, \"expected a path\");\n             },\n         }\n         err.emit();\n@@ -2556,7 +2556,7 @@ impl<'a> Parser<'a> {\n                     let fstr = n.as_str();\n                     let mut err = self.diagnostic().struct_span_err(self.prev_span,\n                         &format!(\"unexpected token: `{}`\", n));\n-                    err.span_label(self.prev_span, &\"unexpected token\");\n+                    err.span_label(self.prev_span, \"unexpected token\");\n                     if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,\n@@ -2708,7 +2708,7 @@ impl<'a> Parser<'a> {\n                 let span_of_tilde = lo;\n                 let mut err = self.diagnostic().struct_span_err(span_of_tilde,\n                         \"`~` can not be used as a unary operator\");\n-                err.span_label(span_of_tilde, &\"did you mean `!`?\");\n+                err.span_label(span_of_tilde, \"did you mean `!`?\");\n                 err.help(\"use `!` instead of `~` if you meant to perform bitwise negation\");\n                 err.emit();\n                 (span, self.mk_unary(UnOp::Not, e))\n@@ -4792,7 +4792,7 @@ impl<'a> Parser<'a> {\n             sp,\n             &format!(\"missing `fn`, `type`, or `const` for {}-item declaration\",\n                      item_type));\n-        err.span_label(sp, &\"missing `fn`, `type`, or `const`\");\n+        err.span_label(sp, \"missing `fn`, `type`, or `const`\");\n         err\n     }\n "}]}