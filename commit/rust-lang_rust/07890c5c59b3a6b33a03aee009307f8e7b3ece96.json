{"sha": "07890c5c59b3a6b33a03aee009307f8e7b3ece96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ODkwYzVjNTliM2E2YjMzYTAzYWVlMDA5MzA3ZjhlN2IzZWNlOTY=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-02-28T01:12:32Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-03-07T01:18:51Z"}, "message": "Add target_features to TransFnAttrs\n\nPart of #47320", "tree": {"sha": "12ce0978bca16fb831fbad551572782ba365a6c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12ce0978bca16fb831fbad551572782ba365a6c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07890c5c59b3a6b33a03aee009307f8e7b3ece96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07890c5c59b3a6b33a03aee009307f8e7b3ece96", "html_url": "https://github.com/rust-lang/rust/commit/07890c5c59b3a6b33a03aee009307f8e7b3ece96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07890c5c59b3a6b33a03aee009307f8e7b3ece96/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39f9d23b656d5fc5bfaf8cc8b85dceb1e8b91b99", "url": "https://api.github.com/repos/rust-lang/rust/commits/39f9d23b656d5fc5bfaf8cc8b85dceb1e8b91b99", "html_url": "https://github.com/rust-lang/rust/commit/39f9d23b656d5fc5bfaf8cc8b85dceb1e8b91b99"}], "stats": {"total": 202, "additions": 101, "deletions": 101}, "files": [{"sha": "ed46296389da4ba4f0ad96d6f5f83d3fca4183fe", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=07890c5c59b3a6b33a03aee009307f8e7b3ece96", "patch": "@@ -636,7 +636,6 @@ define_dep_nodes!( <'tcx>\n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n \n     [input] TargetFeaturesWhitelist,\n-    [] TargetFeaturesEnabled(DefId),\n \n     [] InstanceDefSizeEstimate { instance_def: InstanceDef<'tcx> },\n "}, {"sha": "d22703452605b6bb242a0b91d956ef22fe47d955", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=07890c5c59b3a6b33a03aee009307f8e7b3ece96", "patch": "@@ -47,7 +47,7 @@ struct CheckAttrVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     /// Check any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n-        self.tcx.target_features_enabled(self.tcx.hir.local_def_id(item.id));\n+        self.tcx.trans_fn_attrs(self.tcx.hir.local_def_id(item.id));\n \n         for attr in &item.attrs {\n             if let Some(name) = attr.name() {"}, {"sha": "b484c62188d39749268f91eeea5f27f5c1be5064", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=07890c5c59b3a6b33a03aee009307f8e7b3ece96", "patch": "@@ -2217,6 +2217,7 @@ pub struct TransFnAttrs {\n     pub flags: TransFnAttrFlags,\n     pub inline: InlineAttr,\n     pub export_name: Option<Symbol>,\n+    pub target_features: Vec<Symbol>,\n }\n \n bitflags! {\n@@ -2238,6 +2239,7 @@ impl TransFnAttrs {\n             flags: TransFnAttrFlags::empty(),\n             inline: InlineAttr::None,\n             export_name: None,\n+            target_features: vec![],\n         }\n     }\n "}, {"sha": "69487d3899e7f431edcee8b1e6549f7b18ce391d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=07890c5c59b3a6b33a03aee009307f8e7b3ece96", "patch": "@@ -1148,11 +1148,13 @@ impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrs\n             flags,\n             inline,\n             export_name,\n+            ref target_features,\n         } = *self;\n \n         flags.hash_stable(hcx, hasher);\n         inline.hash_stable(hcx, hasher);\n         export_name.hash_stable(hcx, hasher);\n+        target_features.hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "43a71f1c0d367ab385449be5ecd9a546e202b7d4", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=07890c5c59b3a6b33a03aee009307f8e7b3ece96", "patch": "@@ -384,7 +384,6 @@ define_maps! { <'tcx>\n \n     [] fn target_features_whitelist:\n         target_features_whitelist_node(CrateNum) -> Lrc<FxHashSet<String>>,\n-    [] fn target_features_enabled: TargetFeaturesEnabled(DefId) -> Lrc<Vec<String>>,\n \n     // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n     [] fn instance_def_size_estimate: instance_def_size_estimate_dep_node(ty::InstanceDef<'tcx>)"}, {"sha": "cec3b88b80439608da6e33f85e5ed55a5ce2df23", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=07890c5c59b3a6b33a03aee009307f8e7b3ece96", "patch": "@@ -930,7 +930,6 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::OutputFilenames => { force!(output_filenames, LOCAL_CRATE); }\n \n         DepKind::TargetFeaturesWhitelist => { force!(target_features_whitelist, LOCAL_CRATE); }\n-        DepKind::TargetFeaturesEnabled => { force!(target_features_enabled, def_id!()); }\n \n         DepKind::GetSymbolExportLevel => { force!(symbol_export_level, def_id!()); }\n         DepKind::Features => { force!(features_query, LOCAL_CRATE); }"}, {"sha": "d5ec8d1b5526256573cf69552de26dc754f878fd", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 12, "deletions": 93, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=07890c5c59b3a6b33a03aee009307f8e7b3ece96", "patch": "@@ -12,19 +12,15 @@\n use std::ffi::{CStr, CString};\n \n use rustc::hir::TransFnAttrFlags;\n-use rustc::hir::Unsafety;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::session::config::Sanitizer;\n-use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n \n use llvm::{self, Attribute, ValueRef};\n use llvm::AttributePlace::Function;\n use llvm_util;\n pub use syntax::attr::{self, InlineAttr};\n-use syntax::ast;\n use context::CodegenCx;\n \n /// Mark LLVM function to use provided inline heuristic.\n@@ -127,10 +123,18 @@ pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n         unwind(llfn, false);\n     }\n \n-    let target_features = cx.tcx.target_features_enabled(id);\n-\n-    if !target_features.is_empty() {\n-        let val = CString::new(target_features.join(\",\")).unwrap();\n+    let features =\n+        trans_fn_attrs.target_features\n+        .iter()\n+        .map(|f| {\n+            let feature = &*f.as_str();\n+            format!(\"+{}\", llvm_util::to_llvm_feature(cx.tcx.sess, feature))\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\",\");\n+\n+    if !features.is_empty() {\n+        let val = CString::new(features).unwrap();\n         llvm::AddFunctionAttrStringValue(\n             llfn, llvm::AttributePlace::Function,\n             cstr(\"target-features\\0\"), &val);\n@@ -149,89 +153,4 @@ pub fn provide(providers: &mut Providers) {\n             .map(|c| c.to_string())\n             .collect())\n     };\n-\n-    providers.target_features_enabled = |tcx, id| {\n-        let whitelist = tcx.target_features_whitelist(LOCAL_CRATE);\n-        let mut target_features = Vec::new();\n-        for attr in tcx.get_attrs(id).iter() {\n-            if !attr.check_name(\"target_feature\") {\n-                continue\n-            }\n-            if let Some(val) = attr.value_str() {\n-                for feat in val.as_str().split(\",\").map(|f| f.trim()) {\n-                    if !feat.is_empty() && !feat.contains('\\0') {\n-                        target_features.push(feat.to_string());\n-                    }\n-                }\n-                let msg = \"#[target_feature = \\\"..\\\"] is deprecated and will \\\n-                           eventually be removed, use \\\n-                           #[target_feature(enable = \\\"..\\\")] instead\";\n-                tcx.sess.span_warn(attr.span, &msg);\n-                continue\n-            }\n-\n-            if tcx.fn_sig(id).unsafety() == Unsafety::Normal {\n-                let msg = \"#[target_feature(..)] can only be applied to \\\n-                           `unsafe` function\";\n-                tcx.sess.span_err(attr.span, msg);\n-            }\n-            from_target_feature(tcx, attr, &whitelist, &mut target_features);\n-        }\n-        Lrc::new(target_features)\n-    };\n-}\n-\n-fn from_target_feature(\n-    tcx: TyCtxt,\n-    attr: &ast::Attribute,\n-    whitelist: &FxHashSet<String>,\n-    target_features: &mut Vec<String>,\n-) {\n-    let list = match attr.meta_item_list() {\n-        Some(list) => list,\n-        None => {\n-            let msg = \"#[target_feature] attribute must be of the form \\\n-                       #[target_feature(..)]\";\n-            tcx.sess.span_err(attr.span, &msg);\n-            return\n-        }\n-    };\n-\n-    for item in list {\n-        if !item.check_name(\"enable\") {\n-            let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n-                       currently\";\n-            tcx.sess.span_err(item.span, &msg);\n-            continue\n-        }\n-        let value = match item.value_str() {\n-            Some(list) => list,\n-            None => {\n-                let msg = \"#[target_feature] attribute must be of the form \\\n-                           #[target_feature(enable = \\\"..\\\")]\";\n-                tcx.sess.span_err(item.span, &msg);\n-                continue\n-            }\n-        };\n-        let value = value.as_str();\n-        for feature in value.split(',') {\n-            if whitelist.contains(feature) {\n-                let llvm_feature = llvm_util::to_llvm_feature(&tcx.sess, feature);\n-                target_features.push(format!(\"+{}\", llvm_feature));\n-                continue\n-            }\n-\n-            let msg = format!(\"the feature named `{}` is not valid for \\\n-                               this target\", feature);\n-            let mut err = tcx.sess.struct_span_err(item.span, &msg);\n-\n-            if feature.starts_with(\"+\") {\n-                let valid = whitelist.contains(&feature[1..]);\n-                if valid {\n-                    err.help(\"consider removing the leading `+` in the feature name\");\n-                }\n-            }\n-            err.emit();\n-        }\n-    }\n }"}, {"sha": "4667e3633077d3f9dd1d1f4f67eaff2815016693", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=07890c5c59b3a6b33a03aee009307f8e7b3ece96", "patch": "@@ -44,6 +44,7 @@ use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::cstore::MetadataLoader;\n use rustc::dep_graph::DepGraph;\n use rustc_back::target::Target;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_mir::monomorphize::collector;\n use link::{build_link_meta, out_filename};\n \n@@ -198,8 +199,9 @@ impl TransCrate for MetadataOnlyTransCrate {\n \n     fn provide(&self, providers: &mut Providers) {\n         ::symbol_names::provide(providers);\n-        providers.target_features_enabled = |_tcx, _id| {\n-            Lrc::new(Vec::new()) // Just a dummy\n+\n+        providers.target_features_whitelist = |_tcx, _cnum| {\n+            Lrc::new(FxHashSet()) // Just a dummy\n         };\n     }\n     fn provide_extern(&self, _providers: &mut Providers) {}"}, {"sha": "c16d2c593aafc55dea21d11947c28e3cd70458e7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07890c5c59b3a6b33a03aee009307f8e7b3ece96/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=07890c5c59b3a6b33a03aee009307f8e7b3ece96", "patch": "@@ -36,6 +36,7 @@ use rustc::ty::{ToPredicate, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n+use rustc::util::nodemap::FxHashSet;\n use util::nodemap::FxHashMap;\n \n use rustc_const_math::ConstInt;\n@@ -47,10 +48,10 @@ use syntax::codemap::Spanned;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use rustc::hir::{self, map as hir_map, TransFnAttrs, TransFnAttrFlags};\n+use rustc::hir::{self, map as hir_map, TransFnAttrs, TransFnAttrFlags, Unsafety};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::def::{Def, CtorKind};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n \n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n@@ -1727,11 +1728,68 @@ fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn from_target_feature(\n+    tcx: TyCtxt,\n+    attr: &ast::Attribute,\n+    whitelist: &FxHashSet<String>,\n+    target_features: &mut Vec<Symbol>,\n+) {\n+    let list = match attr.meta_item_list() {\n+        Some(list) => list,\n+        None => {\n+            let msg = \"#[target_feature] attribute must be of the form \\\n+                       #[target_feature(..)]\";\n+            tcx.sess.span_err(attr.span, &msg);\n+            return\n+        }\n+    };\n+\n+    for item in list {\n+        if !item.check_name(\"enable\") {\n+            let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n+                       currently\";\n+            tcx.sess.span_err(item.span, &msg);\n+            continue\n+        }\n+        let value = match item.value_str() {\n+            Some(list) => list,\n+            None => {\n+                let msg = \"#[target_feature] attribute must be of the form \\\n+                           #[target_feature(enable = \\\"..\\\")]\";\n+                tcx.sess.span_err(item.span, &msg);\n+                continue\n+            }\n+        };\n+        let value = value.as_str();\n+        for feature in value.split(',') {\n+            if whitelist.contains(feature) {\n+                target_features.push(Symbol::intern(feature));\n+                continue\n+            }\n+\n+            let msg = format!(\"the feature named `{}` is not valid for \\\n+                               this target\", feature);\n+            let mut err = tcx.sess.struct_span_err(item.span, &msg);\n+\n+            if feature.starts_with(\"+\") {\n+                let valid = whitelist.contains(&feature[1..]);\n+                if valid {\n+                    err.help(\"consider removing the leading `+` in the feature name\");\n+                }\n+            }\n+            err.emit();\n+        }\n+    }\n+}\n+\n+\n fn trans_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> TransFnAttrs {\n     let attrs = tcx.get_attrs(id);\n \n     let mut trans_fn_attrs = TransFnAttrs::new();\n \n+    let whitelist = tcx.target_features_whitelist(LOCAL_CRATE);\n+\n     for attr in attrs.iter() {\n         if attr.check_name(\"cold\") {\n             trans_fn_attrs.flags |= TransFnAttrFlags::COLD;\n@@ -1790,6 +1848,26 @@ fn trans_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> TransFnAt\n                     .span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n                     .emit();\n             }\n+        } else if attr.check_name(\"target_feature\") {\n+            if let Some(val) = attr.value_str() {\n+                for feat in val.as_str().split(\",\").map(|f| f.trim()) {\n+                    if !feat.is_empty() && !feat.contains('\\0') {\n+                        trans_fn_attrs.target_features.push(Symbol::intern(feat));\n+                    }\n+                }\n+                let msg = \"#[target_feature = \\\"..\\\"] is deprecated and will \\\n+                           eventually be removed, use \\\n+                           #[target_feature(enable = \\\"..\\\")] instead\";\n+                tcx.sess.span_warn(attr.span, &msg);\n+                continue\n+            }\n+\n+            if tcx.fn_sig(id).unsafety() == Unsafety::Normal {\n+                let msg = \"#[target_feature(..)] can only be applied to \\\n+                           `unsafe` function\";\n+                tcx.sess.span_err(attr.span, msg);\n+            }\n+            from_target_feature(tcx, attr, &whitelist, &mut trans_fn_attrs.target_features);\n         }\n     }\n "}]}