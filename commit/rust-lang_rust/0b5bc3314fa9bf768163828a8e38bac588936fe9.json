{"sha": "0b5bc3314fa9bf768163828a8e38bac588936fe9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNWJjMzMxNGZhOWJmNzY4MTYzODI4YThlMzhiYWM1ODg5MzZmZTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-31T09:44:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-05T16:29:15Z"}, "message": "Implement new operator dispatch semantics.\n\nKey points are:\n1. `a + b` maps directly to `Add<A,B>`, where `A` and `B` are the types of `a` and `b`.\n2. Indexing and slicing autoderefs consistently.", "tree": {"sha": "5e080bbbd80c8e71da11c4aef39a2170b414c1ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e080bbbd80c8e71da11c4aef39a2170b414c1ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b5bc3314fa9bf768163828a8e38bac588936fe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5bc3314fa9bf768163828a8e38bac588936fe9", "html_url": "https://github.com/rust-lang/rust/commit/0b5bc3314fa9bf768163828a8e38bac588936fe9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b5bc3314fa9bf768163828a8e38bac588936fe9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33ef78fa8bbe9b8d05ba0da607d4da5e31475a95", "url": "https://api.github.com/repos/rust-lang/rust/commits/33ef78fa8bbe9b8d05ba0da607d4da5e31475a95", "html_url": "https://github.com/rust-lang/rust/commit/33ef78fa8bbe9b8d05ba0da607d4da5e31475a95"}], "stats": {"total": 1048, "additions": 827, "deletions": 221}, "files": [{"sha": "23a528959354129ba1286c5ac788d79ded6f3465", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -5566,3 +5566,18 @@ pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[Freevar]| -> T)\n         Some(d) => f(d.as_slice())\n     }\n }\n+\n+impl AutoAdjustment {\n+    pub fn is_identity(&self) -> bool {\n+        match *self {\n+            AdjustAddEnv(..) => false,\n+            AdjustDerefRef(ref r) => r.is_identity(),\n+        }\n+    }\n+}\n+\n+impl AutoDerefRef {\n+    pub fn is_identity(&self) -> bool {\n+        self.autoderefs == 0 && self.autoref.is_none()\n+    }\n+}"}, {"sha": "abffa857a089a79558dee7b88578be509e2b50b3", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 237, "deletions": 54, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -96,6 +96,7 @@ use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::TypeAndSubsts;\n+use middle::typeck::check::vtable;\n use middle::ty_fold::TypeFoldable;\n use util::common::indenter;\n use util::ppaux;\n@@ -173,46 +174,178 @@ pub fn lookup<'a, 'tcx>(\n \n pub fn lookup_in_trait<'a, 'tcx>(\n     fcx: &'a FnCtxt<'a, 'tcx>,\n-\n-    // In a call `a.b::<X, Y, ...>(...)`:\n-    span: Span,                         // The expression `a.b(...)`'s span.\n-    self_expr: Option<&'a ast::Expr>,   // The expression `a`, if available.\n-    m_name: ast::Name,                  // The name `b`.\n-    trait_did: DefId,                   // The trait to limit the lookup to.\n-    self_ty: ty::t,                     // The type of `a`.\n-    supplied_tps: &'a [ty::t])          // The list of types X, Y, ... .\n+    span: Span,\n+    self_expr: Option<&'a ast::Expr>,\n+    m_name: ast::Name,\n+    trait_def_id: DefId,\n+    self_ty: ty::t,\n+    opt_input_types: Option<Vec<ty::t>>)\n     -> Option<MethodCallee>\n {\n-    let mut lcx = LookupContext {\n-        fcx: fcx,\n-        span: span,\n-        self_expr: self_expr,\n-        m_name: m_name,\n-        supplied_tps: supplied_tps,\n-        impl_dups: HashSet::new(),\n-        inherent_candidates: Vec::new(),\n-        extension_candidates: Vec::new(),\n-        static_candidates: Vec::new(),\n-        deref_args: check::DoDerefArgs,\n-        check_traits: CheckTraitsOnly,\n-        autoderef_receiver: DontAutoderefReceiver,\n-    };\n+    lookup_in_trait_adjusted(fcx, span, self_expr, m_name, trait_def_id,\n+                             ty::AutoDerefRef { autoderefs: 0, autoref: None },\n+                             self_ty, opt_input_types)\n+}\n \n-    debug!(\"method lookup_in_trait(self_ty={}, self_expr={}, m_name={}, trait_did={})\",\n+pub fn lookup_in_trait_adjusted<'a, 'tcx>(\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    span: Span,\n+    self_expr: Option<&'a ast::Expr>,\n+    m_name: ast::Name,\n+    trait_def_id: DefId,\n+    autoderefref: ty::AutoDerefRef,\n+    self_ty: ty::t,\n+    opt_input_types: Option<Vec<ty::t>>)\n+    -> Option<MethodCallee>\n+{\n+    debug!(\"method lookup_in_trait(self_ty={}, self_expr={}, m_name={}, trait_def_id={})\",\n            self_ty.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()),\n            m_name.repr(fcx.tcx()),\n-           trait_did.repr(fcx.tcx()));\n+           trait_def_id.repr(fcx.tcx()));\n+\n+    let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_def_id);\n+\n+    let expected_number_of_input_types = trait_def.generics.types.len(subst::TypeSpace);\n+    let input_types = match opt_input_types {\n+        Some(input_types) => {\n+            assert_eq!(expected_number_of_input_types, input_types.len());\n+            input_types\n+        }\n+\n+        None => {\n+            fcx.inh.infcx.next_ty_vars(expected_number_of_input_types)\n+        }\n+    };\n+\n+    let number_assoc_types = trait_def.generics.types.len(subst::AssocSpace);\n+    let assoc_types = fcx.inh.infcx.next_ty_vars(number_assoc_types);\n \n-    lcx.push_bound_candidates(self_ty, Some(trait_did));\n-    lcx.push_extension_candidate(trait_did);\n+    assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n+    assert!(trait_def.generics.regions.is_empty());\n \n-    // when doing a trait search, ambiguity can't really happen except\n-    // as part of the trait-lookup in general\n-    match lcx.search(self_ty) {\n-        Ok(callee) => Some(callee),\n-        Err(_) => None\n+    // Construct a trait-reference `self_ty : Trait<input_tys>`\n+    let substs = subst::Substs::new_trait(input_types, Vec::new(), assoc_types, self_ty);\n+    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n+\n+    // Construct an obligation\n+    let obligation = traits::Obligation::misc(span, trait_ref.clone());\n+\n+    // Now we want to know if this can be matched\n+    let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n+                                                  &fcx.inh.param_env,\n+                                                  fcx);\n+    if !selcx.evaluate_obligation_intracrate(&obligation) {\n+        debug!(\"--> Cannot match obligation\");\n+        return None; // Cannot be matched, no such method resolution is possible.\n+    }\n+\n+    // Trait must have a method named `m_name` and it should not have\n+    // type parameters or early-bound regions.\n+    let tcx = fcx.tcx();\n+    let (method_num, method_ty) = trait_method(tcx, trait_def_id, m_name).unwrap();\n+    assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n+    assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n+\n+    // Substitute the trait parameters into the method type and\n+    // instantiate late-bound regions to get the actual method type.\n+    let ref bare_fn_ty = method_ty.fty;\n+    let fn_sig = bare_fn_ty.sig.subst(tcx, &trait_ref.substs);\n+    let fn_sig = replace_late_bound_regions_with_fresh_var(fcx.infcx(), span,\n+                                                           fn_sig.binder_id, &fn_sig);\n+    let transformed_self_ty = fn_sig.inputs[0];\n+    let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+        sig: fn_sig,\n+        fn_style: bare_fn_ty.fn_style,\n+        abi: bare_fn_ty.abi.clone(),\n+    });\n+\n+    debug!(\"matched method fty={} obligation={}\",\n+           fty.repr(fcx.tcx()),\n+           obligation.repr(fcx.tcx()));\n+\n+    // Register obligations for the parameters.  This will include the\n+    // `Self` parameter, which in turn has a bound of the main trait,\n+    // so this also effectively registers `obligation` as well.  (We\n+    // used to register `obligation` explicitly, but that resulted in\n+    // double error messages being reported.)\n+    fcx.add_obligations_for_parameters(\n+        traits::ObligationCause::misc(span),\n+        &trait_ref.substs,\n+        &method_ty.generics);\n+\n+    // FIXME(#18653) -- Try to resolve obligations, giving us more\n+    // typing information, which can sometimes be needed to avoid\n+    // pathological region inference failures.\n+    vtable::select_new_fcx_obligations(fcx);\n+\n+    // Insert any adjustments needed (always an autoref of some mutability).\n+    match self_expr {\n+        None => { }\n+\n+        Some(self_expr) => {\n+            debug!(\"inserting adjustment if needed (self-id = {}, \\\n+                   base adjustment = {}, explicit self = {})\",\n+                   self_expr.id, autoderefref, method_ty.explicit_self);\n+\n+            match method_ty.explicit_self {\n+                ty::ByValueExplicitSelfCategory => {\n+                    // Trait method is fn(self), no transformation needed.\n+                    if !autoderefref.is_identity() {\n+                        fcx.write_adjustment(\n+                            self_expr.id,\n+                            span,\n+                            ty::AdjustDerefRef(autoderefref));\n+                    }\n+                }\n+\n+                ty::ByReferenceExplicitSelfCategory(..) => {\n+                    // Trait method is fn(&self) or fn(&mut self), need an\n+                    // autoref. Pull the region etc out of the type of first argument.\n+                    match ty::get(transformed_self_ty).sty {\n+                        ty::ty_rptr(region, ty::mt { mutbl, ty: _ }) => {\n+                            let ty::AutoDerefRef { autoderefs, autoref } = autoderefref;\n+                            let autoref = autoref.map(|r| box r);\n+                            fcx.write_adjustment(\n+                                self_expr.id,\n+                                span,\n+                                ty::AdjustDerefRef(ty::AutoDerefRef {\n+                                    autoderefs: autoderefs,\n+                                    autoref: Some(ty::AutoPtr(region, mutbl, autoref))\n+                                }));\n+                        }\n+\n+                        _ => {\n+                            fcx.tcx().sess.span_bug(\n+                                span,\n+                                format!(\n+                                    \"trait method is &self but first arg is: {}\",\n+                                    transformed_self_ty.repr(fcx.tcx())).as_slice());\n+                        }\n+                    }\n+                }\n+\n+                _ => {\n+                    fcx.tcx().sess.span_bug(\n+                        span,\n+                        format!(\n+                            \"unexpected explicit self type in operator method: {}\",\n+                            method_ty.explicit_self).as_slice());\n+                }\n+            }\n+        }\n     }\n+\n+    let callee = MethodCallee {\n+        origin: MethodTypeParam(MethodParam{trait_ref: trait_ref.clone(),\n+                                            method_num: method_num}),\n+        ty: fty,\n+        substs: trait_ref.substs.clone()\n+    };\n+\n+    debug!(\"callee = {}\", callee.repr(fcx.tcx()));\n+\n+    Some(callee)\n }\n \n pub fn report_error(fcx: &FnCtxt,\n@@ -1446,9 +1579,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n     }\n \n-    fn fixup_derefs_on_method_receiver_if_necessary(\n-            &self,\n-            method_callee: &MethodCallee) {\n+    fn fixup_derefs_on_method_receiver_if_necessary(&self,\n+                                                    method_callee: &MethodCallee) {\n         let sig = match ty::get(method_callee.ty).sty {\n             ty::ty_bare_fn(ref f) => f.sig.clone(),\n             ty::ty_closure(ref f) => f.sig.clone(),\n@@ -1485,6 +1617,9 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             }\n         }\n \n+        debug!(\"fixup_derefs_on_method_receiver_if_necessary: exprs={}\",\n+               exprs.repr(self.tcx()));\n+\n         // Fix up autoderefs and derefs.\n         for (i, expr) in exprs.iter().rev().enumerate() {\n             // Count autoderefs.\n@@ -1500,6 +1635,9 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 Some(_) | None => 0,\n             };\n \n+            debug!(\"fixup_derefs_on_method_receiver_if_necessary: i={} expr={} autoderef_count={}\",\n+                   i, expr.repr(self.tcx()), autoderef_count);\n+\n             if autoderef_count > 0 {\n                 check::autoderef(self.fcx,\n                                  expr.span,\n@@ -1518,24 +1656,59 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             // Don't retry the first one or we might infinite loop!\n             if i != 0 {\n                 match expr.node {\n-                    ast::ExprIndex(ref base_expr, ref index_expr) => {\n-                        check::try_overloaded_index(\n-                                self.fcx,\n-                                Some(MethodCall::expr(expr.id)),\n-                                *expr,\n+                    ast::ExprIndex(ref base_expr, _) => {\n+                        let mut base_adjustment =\n+                            match self.fcx.inh.adjustments.borrow().find(&base_expr.id) {\n+                                Some(&ty::AdjustDerefRef(ref adr)) => (*adr).clone(),\n+                                None => ty::AutoDerefRef { autoderefs: 0, autoref: None },\n+                                Some(_) => {\n+                                    self.tcx().sess.span_bug(\n+                                        base_expr.span,\n+                                        \"unexpected adjustment type\");\n+                                }\n+                            };\n+\n+                        // If this is an overloaded index, the\n+                        // adjustment will include an extra layer of\n+                        // autoref because the method is an &self/&mut\n+                        // self method. We have to peel it off to get\n+                        // the raw adjustment that `try_index_step`\n+                        // expects. This is annoying and horrible. We\n+                        // ought to recode this routine so it doesn't\n+                        // (ab)use the normal type checking paths.\n+                        base_adjustment.autoref = match base_adjustment.autoref {\n+                            None => { None }\n+                            Some(AutoPtr(_, _, None)) => { None }\n+                            Some(AutoPtr(_, _, Some(box r))) => { Some(r) }\n+                            Some(_) => {\n+                                self.tcx().sess.span_bug(\n+                                    base_expr.span,\n+                                    \"unexpected adjustment autoref\");\n+                            }\n+                        };\n+\n+                        let adjusted_base_ty =\n+                            self.fcx.adjust_expr_ty(\n                                 &**base_expr,\n-                                self.fcx.expr_ty(&**base_expr),\n-                                index_expr,\n-                                PreferMutLvalue);\n+                                Some(&ty::AdjustDerefRef(base_adjustment.clone())));\n+\n+                        check::try_index_step(\n+                            self.fcx,\n+                            MethodCall::expr(expr.id),\n+                            *expr,\n+                            &**base_expr,\n+                            adjusted_base_ty,\n+                            base_adjustment,\n+                            PreferMutLvalue);\n                     }\n                     ast::ExprUnary(ast::UnDeref, ref base_expr) => {\n                         check::try_overloaded_deref(\n-                                self.fcx,\n-                                expr.span,\n-                                Some(MethodCall::expr(expr.id)),\n-                                Some(&**base_expr),\n-                                self.fcx.expr_ty(&**base_expr),\n-                                PreferMutLvalue);\n+                            self.fcx,\n+                            expr.span,\n+                            Some(MethodCall::expr(expr.id)),\n+                            Some(&**base_expr),\n+                            self.fcx.expr_ty(&**base_expr),\n+                            PreferMutLvalue);\n                     }\n                     _ => {}\n                 }\n@@ -1623,15 +1796,25 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     fn replace_late_bound_regions_with_fresh_var<T>(&self, binder_id: ast::NodeId, value: &T) -> T\n         where T : TypeFoldable + Repr\n     {\n-        let (_, value) = replace_late_bound_regions(\n-            self.fcx.tcx(),\n-            binder_id,\n-            value,\n-            |br| self.fcx.infcx().next_region_var(infer::LateBoundRegion(self.span, br)));\n-        value\n+        replace_late_bound_regions_with_fresh_var(self.fcx.infcx(), self.span, binder_id, value)\n     }\n }\n \n+fn replace_late_bound_regions_with_fresh_var<T>(infcx: &infer::InferCtxt,\n+                                                span: Span,\n+                                                binder_id: ast::NodeId,\n+                                                value: &T)\n+                                                -> T\n+    where T : TypeFoldable + Repr\n+{\n+    let (_, value) = replace_late_bound_regions(\n+        infcx.tcx,\n+        binder_id,\n+        value,\n+        |br| infcx.next_region_var(infer::LateBoundRegion(span, br)));\n+    value\n+}\n+\n fn trait_method(tcx: &ty::ctxt,\n                 trait_def_id: ast::DefId,\n                 method_name: ast::Name)"}, {"sha": "0e3a77ba9639c78db9ca9d24c6eb8228454359e0", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 325, "deletions": 161, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -1630,6 +1630,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             adj: ty::AutoAdjustment) {\n         debug!(\"write_adjustment(node_id={}, adj={})\", node_id, adj);\n \n+        if adj.is_identity() {\n+            return;\n+        }\n+\n         // Careful: adjustments can imply trait obligations if we are\n         // casting from a concrete type to an object type. I think\n         // it'd probably be nicer to move the logic that creates the\n@@ -1813,6 +1817,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> ty::t {\n+        /*!\n+         * Fetch type of `expr` after applying adjustments that\n+         * have been recorded in the fcx.\n+         */\n+\n+        let adjustments = self.inh.adjustments.borrow();\n+        let adjustment = adjustments.find(&expr.id);\n+        self.adjust_expr_ty(expr, adjustment)\n+    }\n+\n+    pub fn adjust_expr_ty(&self,\n+                          expr: &ast::Expr,\n+                          adjustment: Option<&ty::AutoAdjustment>)\n+                          -> ty::t\n+    {\n+        /*!\n+         * Apply `adjustment` to the type of `expr`\n+         */\n+\n+        let raw_ty = self.expr_ty(expr);\n+        let raw_ty = self.infcx().shallow_resolve(raw_ty);\n+        ty::adjust_ty(self.tcx(),\n+                      expr.span,\n+                      expr.id,\n+                      raw_ty,\n+                      adjustment,\n+                      |method_call| self.inh.method_map.borrow()\n+                                                       .find(&method_call)\n+                                                       .map(|method| method.ty))\n+    }\n+\n     pub fn node_ty(&self, id: ast::NodeId) -> ty::t {\n         match self.inh.node_types.borrow().find(&id) {\n             Some(&t) => t,\n@@ -2062,6 +2098,10 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n     for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n         let resolved_t = structurally_resolved_type(fcx, sp, t);\n \n+        if ty::type_is_error(resolved_t) {\n+            return (resolved_t, autoderefs, None);\n+        }\n+\n         match should_stop(resolved_t, autoderefs) {\n             Some(x) => return (resolved_t, autoderefs, Some(x)),\n             None => {}\n@@ -2117,17 +2157,17 @@ fn try_overloaded_call<'a>(fcx: &FnCtxt,\n             None => continue,\n             Some(function_trait) => function_trait,\n         };\n-        let method_callee = match method::lookup_in_trait(\n-                fcx,\n-                call_expression.span,\n-                Some(&*callee),\n-                method_name,\n-                function_trait,\n-                callee_type,\n-                []) {\n-            None => continue,\n-            Some(method_callee) => method_callee,\n-        };\n+        let method_callee =\n+            match method::lookup_in_trait(fcx,\n+                                          call_expression.span,\n+                                          Some(&*callee),\n+                                          method_name,\n+                                          function_trait,\n+                                          callee_type,\n+                                          None) {\n+                None => continue,\n+                Some(method_callee) => method_callee,\n+            };\n         let method_call = MethodCall::expr(call_expression.id);\n         let output_type = check_method_argument_types(fcx,\n                                                       call_expression.span,\n@@ -2159,13 +2199,14 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n                         base_expr: Option<&ast::Expr>,\n                         base_ty: ty::t,\n                         lvalue_pref: LvaluePreference)\n-                        -> Option<ty::mt> {\n+                        -> Option<ty::mt>\n+{\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n         (PreferMutLvalue, Some(trait_did)) => {\n             method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n                                     token::intern(\"deref_mut\"), trait_did,\n-                                    base_ty, [])\n+                                    base_ty, None)\n         }\n         _ => None\n     };\n@@ -2175,25 +2216,27 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n         (None, Some(trait_did)) => {\n             method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n                                     token::intern(\"deref\"), trait_did,\n-                                    base_ty, [])\n+                                    base_ty, None)\n         }\n         (method, _) => method\n     };\n \n-    make_return_type(fcx, method_call, method)\n+    make_overloaded_lvalue_return_type(fcx, method_call, method)\n }\n \n-fn get_method_ty(method: &Option<MethodCallee>) -> ty::t {\n-    match method {\n-        &Some(ref method) => method.ty,\n-        &None => ty::mk_err()\n-    }\n-}\n+fn make_overloaded_lvalue_return_type(fcx: &FnCtxt,\n+                                      method_call: Option<MethodCall>,\n+                                      method: Option<MethodCallee>)\n+                                      -> Option<ty::mt>\n+{\n+    /*!\n+     * For the overloaded lvalue expressions (`*x`, `x[3]`), the trait\n+     * returns a type of `&T`, but the actual type we assign to the\n+     * *expression* is `T`. So this function just peels off the return\n+     * type by one layer to yield `T`. It also inserts the\n+     * `method-callee` into the method map.\n+     */\n \n-fn make_return_type(fcx: &FnCtxt,\n-                    method_call: Option<MethodCall>,\n-                    method: Option<MethodCallee>)\n-                    -> Option<ty::mt> {\n     match method {\n         Some(method) => {\n             let ref_ty = ty::ty_fn_ret(method.ty);\n@@ -2205,26 +2248,126 @@ fn make_return_type(fcx: &FnCtxt,\n                 None => {}\n             }\n             match ref_ty {\n-                ty::FnConverging(ref_ty) =>\n-                    ty::deref(ref_ty, true),\n-                ty::FnDiverging =>\n-                    None\n+                ty::FnConverging(ref_ty) => {\n+                    ty::deref(ref_ty, true)\n+                }\n+                ty::FnDiverging => {\n+                    fcx.tcx().sess.bug(\"index/deref traits do not define a `!` return\")\n+                }\n             }\n         }\n         None => None,\n     }\n }\n \n+fn autoderef_for_index<T>(fcx: &FnCtxt,\n+                          base_expr: &ast::Expr,\n+                          base_ty: ty::t,\n+                          lvalue_pref: LvaluePreference,\n+                          step: |ty::t, ty::AutoDerefRef| -> Option<T>)\n+                          -> Option<T>\n+{\n+    let (ty, autoderefs, final_mt) =\n+        autoderef(fcx, base_expr.span, base_ty, Some(base_expr.id), lvalue_pref, |adj_ty, idx| {\n+            let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n+            step(adj_ty, autoderefref)\n+        });\n+\n+    if final_mt.is_some() {\n+        return final_mt;\n+    }\n+\n+    // After we have fully autoderef'd, if the resulting type is [T, ..n], then\n+    // do a final unsized coercion to yield [T].\n+    match ty::get(ty).sty {\n+        ty::ty_vec(element_ty, Some(n)) => {\n+            let adjusted_ty = ty::mk_vec(fcx.tcx(), element_ty, None);\n+            let autoderefref = ty::AutoDerefRef {\n+                autoderefs: autoderefs,\n+                autoref: Some(ty::AutoUnsize(ty::UnsizeLength(n)))\n+            };\n+            step(adjusted_ty, autoderefref)\n+        }\n+        _ => {\n+            None\n+        }\n+    }\n+}\n+\n fn try_overloaded_slice(fcx: &FnCtxt,\n-                        method_call: Option<MethodCall>,\n+                        method_call: MethodCall,\n                         expr: &ast::Expr,\n                         base_expr: &ast::Expr,\n                         base_ty: ty::t,\n                         start_expr: &Option<P<ast::Expr>>,\n                         end_expr: &Option<P<ast::Expr>>,\n-                        mutbl: &ast::Mutability)\n-                        -> Option<ty::mt> {\n-    let method = if mutbl == &ast::MutMutable {\n+                        mutbl: ast::Mutability)\n+                        -> Option<ty::t> // return type is result of slice\n+{\n+    /*!\n+     * Autoderefs `base_expr`, looking for a `Slice` impl. If it\n+     * finds one, installs the relevant method info and returns the\n+     * result type (else None).\n+     */\n+\n+    let lvalue_pref = match mutbl {\n+        ast::MutMutable => PreferMutLvalue,\n+        ast::MutImmutable => NoPreference\n+    };\n+\n+    let opt_method_ty =\n+        autoderef_for_index(fcx, base_expr, base_ty, lvalue_pref, |adjusted_ty, autoderefref| {\n+            try_overloaded_slice_step(fcx, method_call, expr, base_expr,\n+                                      adjusted_ty, autoderefref, mutbl,\n+                                      start_expr, end_expr)\n+        });\n+\n+    // Regardless of whether the lookup succeeds, check the method arguments\n+    // so that we have *some* type for each argument.\n+    let method_ty_or_err = opt_method_ty.unwrap_or(ty::mk_err());\n+\n+    let mut args = vec![];\n+    start_expr.as_ref().map(|x| args.push(x));\n+    end_expr.as_ref().map(|x| args.push(x));\n+\n+    check_method_argument_types(fcx,\n+                                expr.span,\n+                                method_ty_or_err,\n+                                expr,\n+                                args.as_slice(),\n+                                DoDerefArgs,\n+                                DontTupleArguments);\n+\n+    opt_method_ty.map(|method_ty| {\n+        let result_ty = ty::ty_fn_ret(method_ty);\n+        match result_ty {\n+            ty::FnConverging(result_ty) => result_ty,\n+            ty::FnDiverging => {\n+                fcx.tcx().sess.span_bug(expr.span,\n+                                        \"slice trait does not define a `!` return\")\n+            }\n+        }\n+    })\n+}\n+\n+fn try_overloaded_slice_step(fcx: &FnCtxt,\n+                             method_call: MethodCall,\n+                             expr: &ast::Expr,\n+                             base_expr: &ast::Expr,\n+                             base_ty: ty::t, // autoderef'd type\n+                             autoderefref: ty::AutoDerefRef,\n+                             mutbl: ast::Mutability,\n+                             start_expr: &Option<P<ast::Expr>>,\n+                             end_expr: &Option<P<ast::Expr>>)\n+                             -> Option<ty::t> // result type is type of method being called\n+{\n+    /*!\n+     * Checks for a `Slice` (or `SliceMut`) impl at the relevant level\n+     * of autoderef. If it finds one, installs method info and returns\n+     * type of method (else None).\n+     */\n+\n+    let method = if mutbl == ast::MutMutable {\n         // Try `SliceMut` first, if preferred.\n         match fcx.tcx().lang_items.slice_mut_trait() {\n             Some(trait_did) => {\n@@ -2235,13 +2378,14 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n                     (&None, &None) => \"as_mut_slice_\",\n                 };\n \n-                method::lookup_in_trait(fcx,\n-                                        expr.span,\n-                                        Some(&*base_expr),\n-                                        token::intern(method_name),\n-                                        trait_did,\n-                                        base_ty,\n-                                        [])\n+                method::lookup_in_trait_adjusted(fcx,\n+                                                 expr.span,\n+                                                 Some(&*base_expr),\n+                                                 token::intern(method_name),\n+                                                 trait_did,\n+                                                 autoderefref,\n+                                                 base_ty,\n+                                                 None)\n             }\n             _ => None,\n         }\n@@ -2258,104 +2402,99 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n                     (&None, &None) => \"as_slice_\",\n                 };\n \n-                method::lookup_in_trait(fcx,\n-                                        expr.span,\n-                                        Some(&*base_expr),\n-                                        token::intern(method_name),\n-                                        trait_did,\n-                                        base_ty,\n-                                        [])\n+                method::lookup_in_trait_adjusted(fcx,\n+                                                 expr.span,\n+                                                 Some(&*base_expr),\n+                                                 token::intern(method_name),\n+                                                 trait_did,\n+                                                 autoderefref,\n+                                                 base_ty,\n+                                                 None)\n             }\n             _ => None,\n         }\n     };\n \n+    // If some lookup succeeded, install method in table\n+    method.map(|method| {\n+        let ty = method.ty;\n+        fcx.inh.method_map.borrow_mut().insert(method_call, method);\n+        ty\n+    })\n+}\n \n-    // Regardless of whether the lookup succeeds, check the method arguments\n-    // so that we have *some* type for each argument.\n-    let method_type = get_method_ty(&method);\n-\n-    let mut args = vec![];\n-    start_expr.as_ref().map(|x| args.push(x));\n-    end_expr.as_ref().map(|x| args.push(x));\n+fn try_index_step(fcx: &FnCtxt,\n+                  method_call: MethodCall,\n+                  expr: &ast::Expr,\n+                  base_expr: &ast::Expr,\n+                  adjusted_ty: ty::t,\n+                  adjustment: ty::AutoDerefRef,\n+                  lvalue_pref: LvaluePreference)\n+                  -> Option<(/*index type*/ ty::t, /*element type*/ ty::t)>\n+{\n+    /*!\n+     * To type-check `base_expr[index_expr]`, we progressively autoderef (and otherwise adjust)\n+     * `base_expr`, looking for a type which either supports builtin indexing or overloaded\n+     * indexing. This loop implements one step in that search; the autoderef loop is implemented\n+     * by `autoderef_for_index`.\n+     */\n \n-    check_method_argument_types(fcx,\n-                                expr.span,\n-                                method_type,\n-                                expr,\n-                                args.as_slice(),\n-                                DoDerefArgs,\n-                                DontTupleArguments);\n+    debug!(\"try_index_step(expr={}, base_expr.id={}, adjusted_ty={}, adjustment={})\",\n+           expr.repr(fcx.tcx()),\n+           base_expr.repr(fcx.tcx()),\n+           adjusted_ty.repr(fcx.tcx()),\n+           adjustment);\n \n-    match method {\n-        Some(method) => {\n-            let result_ty = ty::ty_fn_ret(method.ty);\n-            match method_call {\n-                Some(method_call) => {\n-                    fcx.inh.method_map.borrow_mut().insert(method_call,\n-                                                           method);\n-                }\n-                None => {}\n-            }\n-            match result_ty {\n-                ty::FnConverging(result_ty) =>\n-                    Some(ty::mt { ty: result_ty, mutbl: ast::MutImmutable }),\n-                ty::FnDiverging =>\n-                    None\n-            }\n+    // Try built-in indexing first.\n+    match ty::index(adjusted_ty) {\n+        Some(ty) => {\n+            fcx.write_adjustment(base_expr.id, base_expr.span, ty::AdjustDerefRef(adjustment));\n+            return Some((ty::mk_uint(), ty));\n         }\n-        None => None,\n+\n+        None => { }\n     }\n-}\n \n-fn try_overloaded_index(fcx: &FnCtxt,\n-                        method_call: Option<MethodCall>,\n-                        expr: &ast::Expr,\n-                        base_expr: &ast::Expr,\n-                        base_ty: ty::t,\n-                        index_expr: &P<ast::Expr>,\n-                        lvalue_pref: LvaluePreference)\n-                        -> Option<ty::mt> {\n+    let input_ty = fcx.infcx().next_ty_var();\n+    let return_ty = fcx.infcx().next_ty_var();\n+\n     // Try `IndexMut` first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.index_mut_trait()) {\n         (PreferMutLvalue, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx,\n-                                    expr.span,\n-                                    Some(&*base_expr),\n-                                    token::intern(\"index_mut\"),\n-                                    trait_did,\n-                                    base_ty,\n-                                    [])\n+            method::lookup_in_trait_adjusted(fcx,\n+                                             expr.span,\n+                                             Some(&*base_expr),\n+                                             token::intern(\"index_mut\"),\n+                                             trait_did,\n+                                             adjustment.clone(),\n+                                             adjusted_ty,\n+                                             Some(vec![input_ty, return_ty]))\n         }\n         _ => None,\n     };\n \n     // Otherwise, fall back to `Index`.\n     let method = match (method, fcx.tcx().lang_items.index_trait()) {\n         (None, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx,\n-                                    expr.span,\n-                                    Some(&*base_expr),\n-                                    token::intern(\"index\"),\n-                                    trait_did,\n-                                    base_ty,\n-                                    [])\n+            method::lookup_in_trait_adjusted(fcx,\n+                                             expr.span,\n+                                             Some(&*base_expr),\n+                                             token::intern(\"index\"),\n+                                             trait_did,\n+                                             adjustment,\n+                                             adjusted_ty,\n+                                             Some(vec![input_ty, return_ty]))\n         }\n         (method, _) => method,\n     };\n \n-    // Regardless of whether the lookup succeeds, check the method arguments\n-    // so that we have *some* type for each argument.\n-    let method_type = get_method_ty(&method);\n-    check_method_argument_types(fcx,\n-                                expr.span,\n-                                method_type,\n-                                expr,\n-                                &[index_expr],\n-                                DoDerefArgs,\n-                                DontTupleArguments);\n-\n-    make_return_type(fcx, method_call, method)\n+    // If some lookup succeeds, write callee into table and extract index/element\n+    // type from the method signature.\n+    // If some lookup succeeded, install method in table\n+    method.map(|method| {\n+        make_overloaded_lvalue_return_type(fcx, Some(method_call), Some(method));\n+        (input_ty, return_ty)\n+    })\n }\n \n /// Given the head of a `for` expression, looks up the `next` method in the\n@@ -2383,7 +2522,7 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n                                          token::intern(\"next\"),\n                                          trait_did,\n                                          expr_type,\n-                                         []);\n+                                         None);\n \n     // Regardless of whether the lookup succeeds, check the method arguments\n     // so that we have *some* type for each argument.\n@@ -2427,10 +2566,15 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n                         if !substs.types.is_empty_in(subst::TypeSpace) => {\n                     *substs.types.get(subst::TypeSpace, 0)\n                 }\n+                ty::ty_err => {\n+                    ty::mk_err()\n+                }\n                 _ => {\n                     fcx.tcx().sess.span_err(iterator_expr.span,\n-                                            \"`next` method of the `Iterator` \\\n-                                             trait has an unexpected type\");\n+                                            format!(\"`next` method of the `Iterator` \\\n+                                                    trait has an unexpected type `{}`\",\n+                                                    fcx.infcx().ty_to_string(return_type))\n+                                            .as_slice());\n                     ty::mk_err()\n                 }\n             }\n@@ -2457,7 +2601,7 @@ fn check_method_argument_types<'a>(fcx: &FnCtxt,\n                              deref_args,\n                              false,\n                              tuple_arguments);\n-        ty::FnConverging(method_fn_ty)\n+        ty::FnConverging(ty::mk_err())\n     } else {\n         match ty::get(method_fn_ty).sty {\n             ty::ty_bare_fn(ref fty) => {\n@@ -3060,8 +3204,36 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                   unbound_method: ||) -> ty::t {\n         let method = match trait_did {\n             Some(trait_did) => {\n-                method::lookup_in_trait(fcx, op_ex.span, Some(lhs), opname,\n-                                        trait_did, lhs_ty, &[])\n+                // We do eager coercions to make using operators\n+                // more ergonomic:\n+                //\n+                // - If the input is of type &'a T (resp. &'a mut T),\n+                //   then reborrow it to &'b T (resp. &'b mut T) where\n+                //   'b <= 'a.  This makes things like `x == y`, where\n+                //   `x` and `y` are both region pointers, work.  We\n+                //   could also solve this with variance or different\n+                //   traits that don't force left and right to have same\n+                //   type.\n+                let (adj_ty, adjustment) = match ty::get(lhs_ty).sty {\n+                    ty::ty_rptr(r_in, mt) => {\n+                        let r_adj = fcx.infcx().next_region_var(infer::Autoref(lhs.span));\n+                        fcx.mk_subr(infer::Reborrow(lhs.span), r_adj, r_in);\n+                        let adjusted_ty = ty::mk_rptr(fcx.tcx(), r_adj, mt);\n+                        let autoptr = ty::AutoPtr(r_adj, mt.mutbl, None);\n+                        let adjustment = ty::AutoDerefRef { autoderefs: 1, autoref: Some(autoptr) };\n+                        (adjusted_ty, adjustment)\n+                    }\n+                    _ => {\n+                        (lhs_ty, ty::AutoDerefRef { autoderefs: 0, autoref: None })\n+                    }\n+                };\n+\n+                debug!(\"adjusted_ty={} adjustment={}\",\n+                       adj_ty.repr(fcx.tcx()),\n+                       adjustment);\n+\n+                method::lookup_in_trait_adjusted(fcx, op_ex.span, Some(lhs), opname,\n+                                                 trait_did, adjustment, adj_ty, None)\n             }\n             None => None\n         };\n@@ -4338,55 +4510,47 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprIndex(ref base, ref idx) => {\n           check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n           check_expr(fcx, &**idx);\n-          let raw_base_t = fcx.expr_ty(&**base);\n+          let base_t = fcx.expr_ty(&**base);\n           let idx_t = fcx.expr_ty(&**idx);\n-          if ty::type_is_error(raw_base_t) {\n-              fcx.write_ty(id, raw_base_t);\n+          if ty::type_is_error(base_t) {\n+              fcx.write_ty(id, base_t);\n           } else if ty::type_is_error(idx_t) {\n               fcx.write_ty(id, idx_t);\n           } else {\n-              let (_, autoderefs, field_ty) =\n-                autoderef(fcx, expr.span, raw_base_t, Some(base.id),\n-                          lvalue_pref, |base_t, _| ty::index(base_t));\n-              match field_ty {\n-                  Some(ty) => {\n-                      check_expr_has_type(fcx, &**idx, ty::mk_uint());\n-                      fcx.write_ty(id, ty);\n-                      fcx.write_autoderef_adjustment(base.id, base.span, autoderefs);\n+              let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n+\n+              let result =\n+                  autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n+                      try_index_step(fcx,\n+                                     MethodCall::expr(expr.id),\n+                                     expr,\n+                                     &**base,\n+                                     adj_ty,\n+                                     adj,\n+                                     lvalue_pref)\n+                  });\n+\n+              match result {\n+                  Some((index_ty, element_ty)) => {\n+                      check_expr_has_type(fcx, &**idx, index_ty);\n+                      fcx.write_ty(id, element_ty);\n                   }\n                   _ => {\n-                      // This is an overloaded method.\n-                      let base_t = structurally_resolved_type(fcx,\n-                                                              expr.span,\n-                                                              raw_base_t);\n-                      let method_call = MethodCall::expr(expr.id);\n-                      match try_overloaded_index(fcx,\n-                                                 Some(method_call),\n-                                                 expr,\n-                                                 &**base,\n-                                                 base_t,\n-                                                 idx,\n-                                                 lvalue_pref) {\n-                          Some(mt) => fcx.write_ty(id, mt.ty),\n-                          None => {\n-                                fcx.type_error_message(expr.span,\n-                                                       |actual| {\n-                                                        format!(\"cannot \\\n-                                                                 index a \\\n-                                                                 value of \\\n-                                                                 type `{}`\",\n-                                                                actual)\n-                                                       },\n-                                                       base_t,\n-                                                       None);\n-                                fcx.write_ty(id, ty::mk_err())\n-                          }\n-                      }\n+                      check_expr_has_type(fcx, &**idx, ty::mk_err());\n+                      fcx.type_error_message(\n+                          expr.span,\n+                          |actual| {\n+                              format!(\"cannot index a value of type `{}`\",\n+                                      actual)\n+                          },\n+                          base_t,\n+                          None);\n+                      fcx.write_ty(id, ty::mk_err())\n                   }\n               }\n           }\n        }\n-       ast::ExprSlice(ref base, ref start, ref end, ref mutbl) => {\n+       ast::ExprSlice(ref base, ref start, ref end, mutbl) => {\n           check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n           let raw_base_t = fcx.expr_ty(&**base);\n \n@@ -4415,19 +4579,19 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                       raw_base_t);\n               let method_call = MethodCall::expr(expr.id);\n               match try_overloaded_slice(fcx,\n-                                         Some(method_call),\n+                                         method_call,\n                                          expr,\n                                          &**base,\n                                          base_t,\n                                          start,\n                                          end,\n                                          mutbl) {\n-                  Some(mt) => fcx.write_ty(id, mt.ty),\n+                  Some(ty) => fcx.write_ty(id, ty),\n                   None => {\n                         fcx.type_error_message(expr.span,\n                            |actual| {\n                                 format!(\"cannot take a {}slice of a value with type `{}`\",\n-                                        if mutbl == &ast::MutMutable {\n+                                        if mutbl == ast::MutMutable {\n                                             \"mutable \"\n                                         } else {\n                                             \"\""}, {"sha": "91e563c75e4754d1c972c4661b643c72193abc10", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -32,6 +32,7 @@ use syntax::ast_map;\n use syntax::codemap::{Span, Pos};\n use syntax::parse::token;\n use syntax::print::pprust;\n+use syntax::ptr::P;\n use syntax::{ast, ast_util};\n use syntax::owned_slice::OwnedSlice;\n \n@@ -561,6 +562,12 @@ impl<T:Repr> Repr for Option<T> {\n     }\n }\n \n+impl<T:Repr> Repr for P<T> {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        (*self).repr(tcx)\n+    }\n+}\n+\n impl<T:Repr,U:Repr> Repr for Result<T,U> {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match self {"}, {"sha": "2253d7512c053c5615c45dbd5f702a5f789a28b0", "filename": "src/test/compile-fail/borrowck-overloaded-index-autoderef.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we still see borrowck errors of various kinds when using\n+// indexing and autoderef in combination.\n+\n+struct Foo {\n+    x: int,\n+    y: int,\n+}\n+\n+impl Index<String,int> for Foo {\n+    fn index<'a>(&'a self, z: &String) -> &'a int {\n+        if z.as_slice() == \"x\" {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n+    }\n+}\n+\n+impl IndexMut<String,int> for Foo {\n+    fn index_mut<'a>(&'a mut self, z: &String) -> &'a mut int {\n+        if z.as_slice() == \"x\" {\n+            &mut self.x\n+        } else {\n+            &mut self.y\n+        }\n+    }\n+}\n+\n+fn test1(mut f: Box<Foo>, s: String) {\n+    let _p = &mut f[s];\n+    let _q = &f[s]; //~ ERROR cannot borrow\n+}\n+\n+fn test2(mut f: Box<Foo>, s: String) {\n+    let _p = &mut f[s];\n+    let _q = &mut f[s]; //~ ERROR cannot borrow\n+}\n+\n+struct Bar {\n+    foo: Foo\n+}\n+\n+fn test3(mut f: Box<Bar>, s: String) {\n+    let _p = &mut f.foo[s];\n+    let _q = &mut f.foo[s]; //~ ERROR cannot borrow\n+}\n+\n+fn test4(mut f: Box<Bar>, s: String) {\n+    let _p = &f.foo[s];\n+    let _q = &f.foo[s];\n+}\n+\n+fn test5(mut f: Box<Bar>, s: String) {\n+    let _p = &f.foo[s];\n+    let _q = &mut f.foo[s]; //~ ERROR cannot borrow\n+}\n+\n+fn test6(mut f: Box<Bar>, g: Foo, s: String) {\n+    let _p = &f.foo[s];\n+    f.foo = g; //~ ERROR cannot assign\n+}\n+\n+fn test7(mut f: Box<Bar>, g: Bar, s: String) {\n+    let _p = &f.foo[s];\n+    *f = g; //~ ERROR cannot assign\n+}\n+\n+fn test8(mut f: Box<Bar>, g: Foo, s: String) {\n+    let _p = &mut f.foo[s];\n+    f.foo = g; //~ ERROR cannot assign\n+}\n+\n+fn test9(mut f: Box<Bar>, g: Bar, s: String) {\n+    let _p = &mut f.foo[s];\n+    *f = g; //~ ERROR cannot assign\n+}\n+\n+fn main() {\n+}\n+\n+"}, {"sha": "4ec8c2b1b7ea580773294a6a374395b9321886a7", "filename": "src/test/compile-fail/issue-13482-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let x = [1,2];\n     let y = match x {\n         [] => None,\n-        //~^ ERROR types: expected `[_#0i, ..2]`, found `[_#7, ..0]`\n+        //~^ ERROR types: expected `[_#0i, ..2]`, found `[_#7t, ..0]`\n         //         (expected array of 2 elements, found array of 0 elements)\n         [a,_] => Some(a)\n     };"}, {"sha": "61877775269d1f049e1a778153a05368d8ba4a50", "filename": "src/test/compile-fail/issue-15207.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -11,7 +11,6 @@\n fn main() {\n     loop {\n         break.push(1) //~ ERROR the type of this value must be known in this context\n-        //~^ ERROR multiple applicable methods in scope\n         ;\n     }\n }"}, {"sha": "5048a9aa919c6e3dc8381b035bf31ac3ef4fb796", "filename": "src/test/compile-fail/issue-17033.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -11,7 +11,7 @@\n #![feature(overloaded_calls)]\n \n fn f<'r>(p: &'r mut fn(p: &mut ())) {\n-    p(()) //~ ERROR mismatched types: expected `&mut ()`, found `()`\n+    (*p)(()) //~ ERROR mismatched types: expected `&mut ()`, found `()`\n }\n \n fn main() {}"}, {"sha": "1150f40db762f7849622dc7b6f1b6d3fb62efa27", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -18,7 +18,6 @@ impl<A> vec_monad<A> for Vec<A> {\n         let mut r = panic!();\n         for elt in self.iter() { r = r + f(*elt); }\n         //~^ ERROR the type of this value must be known\n-        //~^^ ERROR not implemented\n    }\n }\n fn main() {"}, {"sha": "6778ed88ff70bf69dd6b33d6fee6e17eb5b1528f", "filename": "src/test/compile-fail/slice-mut-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -15,5 +15,5 @@\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Can't mutably slice an immutable slice\n-    let y = x[mut 2..4]; //~ ERROR cannot take a mutable slice of a value with type `&[int]`\n+    let y = x[mut 2..4]; //~ ERROR cannot borrow\n }"}, {"sha": "c87e85417582d953501dfbb2765073b91967f664", "filename": "src/test/compile-fail/type-params-in-different-spaces-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -12,7 +12,7 @@ use std::num::Num;\n \n trait BrokenAdd: Num {\n     fn broken_add<T>(&self, rhs: T) -> Self {\n-        *self + rhs //~ ERROR mismatched types\n+        *self + rhs //~ ERROR expected `Self`, found `T`\n     }\n }\n "}, {"sha": "7c6ad45a9efe1ce84088467bab71e2d3b2c872ca", "filename": "src/test/run-pass/overloaded-index-assoc-list.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "previous_filename": "src/test/run-pass/overload-index-operator.rs"}, {"sha": "d51956da89409733dbb5e3edd7470ae1148f2801", "filename": "src/test/run-pass/overloaded-index-autoderef.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test overloaded indexing combined with autoderef.\n+\n+struct Foo {\n+    x: int,\n+    y: int,\n+}\n+\n+impl Index<int,int> for Foo {\n+    fn index(&self, z: &int) -> &int {\n+        if *z == 0 {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n+    }\n+}\n+\n+impl IndexMut<int,int> for Foo {\n+    fn index_mut(&mut self, z: &int) -> &mut int {\n+        if *z == 0 {\n+            &mut self.x\n+        } else {\n+            &mut self.y\n+        }\n+    }\n+}\n+\n+trait Int {\n+    fn get(self) -> int;\n+    fn get_from_ref(&self) -> int;\n+    fn inc(&mut self);\n+}\n+\n+impl Int for int {\n+    fn get(self) -> int { self }\n+    fn get_from_ref(&self) -> int { *self }\n+    fn inc(&mut self) { *self += 1; }\n+}\n+\n+fn main() {\n+    let mut f = box Foo {\n+        x: 1,\n+        y: 2,\n+    };\n+\n+    assert_eq!(f[1], 2);\n+\n+    f[0] = 3;\n+\n+    assert_eq!(f[0], 3);\n+\n+    // Test explicit IndexMut where `f` must be autoderef:\n+    {\n+        let p = &mut f[1];\n+        *p = 4;\n+    }\n+\n+    // Test explicit Index where `f` must be autoderef:\n+    {\n+        let p = &f[1];\n+        assert_eq!(*p, 4);\n+    }\n+\n+    // Test calling methods with `&mut self`, `self, and `&self` receivers:\n+    f[1].inc();\n+    assert_eq!(f[1].get(), 5);\n+    assert_eq!(f[1].get_from_ref(), 5);\n+}\n+"}, {"sha": "e8b0408ca0dc00499fa53db06086c374e115de37", "filename": "src/test/run-pass/overloaded-index-in-field.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test using overloaded indexing when the \"map\" is stored in a\n+// field. This caused problems at some point.\n+\n+struct Foo {\n+    x: int,\n+    y: int,\n+}\n+\n+struct Bar {\n+    foo: Foo\n+}\n+\n+impl Index<int,int> for Foo {\n+    fn index(&self, z: &int) -> &int {\n+        if *z == 0 {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n+    }\n+}\n+\n+trait Int {\n+    fn get(self) -> int;\n+    fn get_from_ref(&self) -> int;\n+    fn inc(&mut self);\n+}\n+\n+impl Int for int {\n+    fn get(self) -> int { self }\n+    fn get_from_ref(&self) -> int { *self }\n+    fn inc(&mut self) { *self += 1; }\n+}\n+\n+fn main() {\n+    let f = Bar { foo: Foo {\n+        x: 1,\n+        y: 2,\n+    } };\n+    assert_eq!(f.foo[1].get(), 2);\n+}\n+"}, {"sha": "23bebfa35d7f305238ce801e1532c72aab545ef8", "filename": "src/test/run-pass/overloaded-index.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bc3314fa9bf768163828a8e38bac588936fe9/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index.rs?ref=0b5bc3314fa9bf768163828a8e38bac588936fe9", "patch": "@@ -33,6 +33,18 @@ impl IndexMut<int,int> for Foo {\n     }\n }\n \n+trait Int {\n+    fn get(self) -> int;\n+    fn get_from_ref(&self) -> int;\n+    fn inc(&mut self);\n+}\n+\n+impl Int for int {\n+    fn get(self) -> int { self }\n+    fn get_from_ref(&self) -> int { *self }\n+    fn inc(&mut self) { *self += 1; }\n+}\n+\n fn main() {\n     let mut f = Foo {\n         x: 1,\n@@ -49,5 +61,10 @@ fn main() {\n         let p = &f[1];\n         assert_eq!(*p, 4);\n     }\n+\n+    // Test calling methods with `&mut self`, `self, and `&self` receivers:\n+    f[1].inc();\n+    assert_eq!(f[1].get(), 5);\n+    assert_eq!(f[1].get_from_ref(), 5);\n }\n "}]}