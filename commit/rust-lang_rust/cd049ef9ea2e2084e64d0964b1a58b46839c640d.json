{"sha": "cd049ef9ea2e2084e64d0964b1a58b46839c640d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkMDQ5ZWY5ZWEyZTIwODRlNjRkMDk2NGIxYTU4YjQ2ODM5YzY0MGQ=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-03-06T21:24:04Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-03-09T19:15:01Z"}, "message": "Remove useless references/dereferences", "tree": {"sha": "308159d49008580af7a6bde530f3255056456e79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/308159d49008580af7a6bde530f3255056456e79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd049ef9ea2e2084e64d0964b1a58b46839c640d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd049ef9ea2e2084e64d0964b1a58b46839c640d", "html_url": "https://github.com/rust-lang/rust/commit/cd049ef9ea2e2084e64d0964b1a58b46839c640d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd049ef9ea2e2084e64d0964b1a58b46839c640d/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2c432289195eaf65e42566ed0b95f82a913bcb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2c432289195eaf65e42566ed0b95f82a913bcb3", "html_url": "https://github.com/rust-lang/rust/commit/c2c432289195eaf65e42566ed0b95f82a913bcb3"}], "stats": {"total": 316, "additions": 148, "deletions": 168}, "files": [{"sha": "808c6e3ff644b76b358f4ec6d3b03e675fcbbd1d", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -23,29 +23,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             expr,\n             targeted_by_break,\n             safety_mode,\n-        } = ast_block;\n+        } = *ast_block;\n         self.in_opt_scope(opt_destruction_scope.map(|de| (de, source_info)), move |this| {\n-            this.in_scope((*region_scope, source_info), LintLevel::Inherited, move |this| {\n-                if *targeted_by_break {\n-                    this.in_breakable_scope(None, destination, *span, |this| {\n+            this.in_scope((region_scope, source_info), LintLevel::Inherited, move |this| {\n+                if targeted_by_break {\n+                    this.in_breakable_scope(None, destination, span, |this| {\n                         Some(this.ast_block_stmts(\n                             destination,\n                             block,\n-                            *span,\n-                            &stmts,\n-                            expr.as_deref(),\n-                            *safety_mode,\n+                            span,\n+                            stmts,\n+                            expr,\n+                            safety_mode,\n                         ))\n                     })\n                 } else {\n-                    this.ast_block_stmts(\n-                        destination,\n-                        block,\n-                        *span,\n-                        &stmts,\n-                        expr.as_deref(),\n-                        *safety_mode,\n-                    )\n+                    this.ast_block_stmts(destination, block, span, stmts, expr, safety_mode)\n                 }\n             })\n         })\n@@ -87,15 +80,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let source_info = this.source_info(span);\n         for Stmt { kind, opt_destruction_scope } in stmts {\n             match kind {\n-                StmtKind::Expr { scope, expr } => {\n+                &StmtKind::Expr { scope, expr } => {\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result: true });\n                     unpack!(\n                         block = this.in_opt_scope(\n                             opt_destruction_scope.map(|de| (de, source_info)),\n                             |this| {\n-                                let si = (*scope, source_info);\n+                                let si = (scope, source_info);\n                                 this.in_scope(si, LintLevel::Inherited, |this| {\n-                                    this.stmt_expr(block, &expr, Some(*scope))\n+                                    this.stmt_expr(block, expr, Some(scope))\n                                 })\n                             }\n                         )\n@@ -110,7 +103,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let_scope_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a source scope.\n-                    let remainder_span = remainder_scope.span(this.tcx, &this.region_scope_tree);\n+                    let remainder_span = remainder_scope.span(this.tcx, this.region_scope_tree);\n \n                     let visibility_scope =\n                         Some(this.new_source_scope(remainder_span, LintLevel::Inherited, None));\n@@ -128,11 +121,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                         this.declare_bindings(\n                                             visibility_scope,\n                                             remainder_span,\n-                                            &pattern,\n+                                            pattern,\n                                             ArmHasGuard(false),\n                                             Some((None, initializer_span)),\n                                         );\n-                                        this.expr_into_pattern(block, pattern.clone(), &init)\n+                                        this.expr_into_pattern(block, pattern.clone(), init)\n                                     })\n                                 }\n                             )\n@@ -143,7 +136,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             this.declare_bindings(\n                                 visibility_scope,\n                                 remainder_span,\n-                                &pattern,\n+                                pattern,\n                                 ArmHasGuard(false),\n                                 None,\n                             );"}, {"sha": "727aedb0ef854df15fe5c121eea1bcee7b31155d", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -10,25 +10,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// `expr` is a valid compile-time constant!\n     crate fn as_constant(&mut self, expr: &Expr<'_, 'tcx>) -> Constant<'tcx> {\n         let this = self;\n-        let Expr { ty, temp_lifetime: _, span, kind } = expr;\n+        let Expr { ty, temp_lifetime: _, span, ref kind } = *expr;\n         match kind {\n-            ExprKind::Scope { region_scope: _, lint_level: _, value } => this.as_constant(&value),\n+            ExprKind::Scope { region_scope: _, lint_level: _, value } => this.as_constant(value),\n             ExprKind::Literal { literal, user_ty, const_id: _ } => {\n                 let user_ty = user_ty.map(|user_ty| {\n                     this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n-                        span: *span,\n+                        span,\n                         user_ty,\n                         inferred_ty: ty,\n                     })\n                 });\n-                assert_eq!(literal.ty, *ty);\n-                Constant { span: *span, user_ty, literal }\n+                assert_eq!(literal.ty, ty);\n+                Constant { span, user_ty, literal }\n             }\n-            ExprKind::StaticRef { literal, .. } => Constant { span: *span, user_ty: None, literal },\n+            ExprKind::StaticRef { literal, .. } => Constant { span, user_ty: None, literal },\n             ExprKind::ConstBlock { value } => {\n-                Constant { span: *span, user_ty: None, literal: value }\n+                Constant { span: span, user_ty: None, literal: value }\n             }\n-            _ => span_bug!(*span, \"expression is not a valid constant {:?}\", kind),\n+            _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }\n     }\n }"}, {"sha": "c393878e0b9957b3a2ec3f4d080eb61191b9095d", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -98,11 +98,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"as_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n-        if let ExprKind::Scope { region_scope, lint_level, value } = &expr.kind {\n+        if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n             let source_info = this.source_info(expr.span);\n-            let region_scope = (*region_scope, source_info);\n+            let region_scope = (region_scope, source_info);\n             return this\n-                .in_scope(region_scope, *lint_level, |this| this.as_operand(block, scope, &value));\n+                .in_scope(region_scope, lint_level, |this| this.as_operand(block, scope, value));\n         }\n \n         let category = Category::of(&expr.kind).unwrap();\n@@ -128,11 +128,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"as_call_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n-        if let ExprKind::Scope { region_scope, lint_level, value } = &expr.kind {\n+        if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n             let source_info = this.source_info(expr.span);\n-            let region_scope = (*region_scope, source_info);\n-            return this.in_scope(region_scope, *lint_level, |this| {\n-                this.as_call_operand(block, scope, &value)\n+            let region_scope = (region_scope, source_info);\n+            return this.in_scope(region_scope, lint_level, |this| {\n+                this.as_call_operand(block, scope, value)\n             });\n         }\n \n@@ -149,7 +149,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // As described above, detect the case where we are passing a value of unsized\n                 // type, and that value is coming from the deref of a box.\n-                if let ExprKind::Deref { ref arg } = expr.kind {\n+                if let ExprKind::Deref { arg } = expr.kind {\n                     // Generate let tmp0 = arg0\n                     let operand = unpack!(block = this.as_temp(block, scope, arg, Mutability::Mut));\n "}, {"sha": "532c725c823ef143524635a0306b34be176a3ae1", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -406,59 +406,57 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let this = self;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n-        match &expr.kind {\n+        match expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n-                this.in_scope((*region_scope, source_info), *lint_level, |this| {\n-                    this.expr_as_place(block, &value, mutability, fake_borrow_temps)\n+                this.in_scope((region_scope, source_info), lint_level, |this| {\n+                    this.expr_as_place(block, value, mutability, fake_borrow_temps)\n                 })\n             }\n             ExprKind::Field { lhs, name } => {\n-                let place_builder = unpack!(\n-                    block = this.expr_as_place(block, &lhs, mutability, fake_borrow_temps,)\n-                );\n-                block.and(place_builder.field(*name, expr.ty))\n+                let place_builder =\n+                    unpack!(block = this.expr_as_place(block, lhs, mutability, fake_borrow_temps,));\n+                block.and(place_builder.field(name, expr.ty))\n             }\n             ExprKind::Deref { arg } => {\n-                let place_builder = unpack!(\n-                    block = this.expr_as_place(block, &arg, mutability, fake_borrow_temps,)\n-                );\n+                let place_builder =\n+                    unpack!(block = this.expr_as_place(block, arg, mutability, fake_borrow_temps,));\n                 block.and(place_builder.deref())\n             }\n             ExprKind::Index { lhs, index } => this.lower_index_expression(\n                 block,\n-                &lhs,\n-                &index,\n+                lhs,\n+                index,\n                 mutability,\n                 fake_borrow_temps,\n                 expr.temp_lifetime,\n                 expr_span,\n                 source_info,\n             ),\n             ExprKind::UpvarRef { closure_def_id, var_hir_id } => {\n-                let upvar_id = ty::UpvarId::new(*var_hir_id, closure_def_id.expect_local());\n+                let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id.expect_local());\n                 this.lower_captured_upvar(block, upvar_id)\n             }\n \n             ExprKind::VarRef { id } => {\n-                let place_builder = if this.is_bound_var_in_guard(*id) {\n-                    let index = this.var_local_id(*id, RefWithinGuard);\n+                let place_builder = if this.is_bound_var_in_guard(id) {\n+                    let index = this.var_local_id(id, RefWithinGuard);\n                     PlaceBuilder::from(index).deref()\n                 } else {\n-                    let index = this.var_local_id(*id, OutsideGuard);\n+                    let index = this.var_local_id(id, OutsideGuard);\n                     PlaceBuilder::from(index)\n                 };\n                 block.and(place_builder)\n             }\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n                 let place_builder = unpack!(\n-                    block = this.expr_as_place(block, &source, mutability, fake_borrow_temps,)\n+                    block = this.expr_as_place(block, source, mutability, fake_borrow_temps,)\n                 );\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index =\n                         this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                             span: source_info.span,\n-                            user_ty: *user_ty,\n+                            user_ty,\n                             inferred_ty: expr.ty,\n                         });\n \n@@ -481,12 +479,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             ExprKind::ValueTypeAscription { source, user_ty } => {\n                 let temp =\n-                    unpack!(block = this.as_temp(block, source.temp_lifetime, &source, mutability));\n+                    unpack!(block = this.as_temp(block, source.temp_lifetime, source, mutability));\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index =\n                         this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                             span: source_info.span,\n-                            user_ty: *user_ty,\n+                            user_ty,\n                             inferred_ty: expr.ty,\n                         });\n                     this.cfg.push("}, {"sha": "d73e5eef70ca6c2b03083d5e8179cbe4ad5ee9ed", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -41,27 +41,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n \n-        match &expr.kind {\n-            ExprKind::ThreadLocalRef(did) => block.and(Rvalue::ThreadLocalRef(*did)),\n+        match expr.kind {\n+            ExprKind::ThreadLocalRef(did) => block.and(Rvalue::ThreadLocalRef(did)),\n             ExprKind::Scope { region_scope, lint_level, value } => {\n-                let region_scope = (*region_scope, source_info);\n-                this.in_scope(region_scope, *lint_level, |this| {\n-                    this.as_rvalue(block, scope, &value)\n-                })\n+                let region_scope = (region_scope, source_info);\n+                this.in_scope(region_scope, lint_level, |this| this.as_rvalue(block, scope, value))\n             }\n             ExprKind::Repeat { value, count } => {\n-                let value_operand = unpack!(block = this.as_operand(block, scope, &value));\n+                let value_operand = unpack!(block = this.as_operand(block, scope, value));\n                 block.and(Rvalue::Repeat(value_operand, count))\n             }\n             ExprKind::Binary { op, lhs, rhs } => {\n-                let lhs = unpack!(block = this.as_operand(block, scope, &lhs));\n-                let rhs = unpack!(block = this.as_operand(block, scope, &rhs));\n-                this.build_binary_op(block, *op, expr_span, expr.ty, lhs, rhs)\n+                let lhs = unpack!(block = this.as_operand(block, scope, lhs));\n+                let rhs = unpack!(block = this.as_operand(block, scope, rhs));\n+                this.build_binary_op(block, op, expr_span, expr.ty, lhs, rhs)\n             }\n             ExprKind::Unary { op, arg } => {\n-                let arg = unpack!(block = this.as_operand(block, scope, &arg));\n+                let arg = unpack!(block = this.as_operand(block, scope, arg));\n                 // Check for -MIN on signed integers\n-                if this.check_overflow && *op == UnOp::Neg && expr.ty.is_signed() {\n+                if this.check_overflow && op == UnOp::Neg && expr.ty.is_signed() {\n                     let bool_ty = this.tcx.types.bool;\n \n                     let minval = this.minval_literal(expr_span, expr.ty);\n@@ -82,7 +80,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         expr_span,\n                     );\n                 }\n-                block.and(Rvalue::UnaryOp(*op, arg))\n+                block.and(Rvalue::UnaryOp(op, arg))\n             }\n             ExprKind::Box { value } => {\n                 // The `Box<T>` temporary created here is not a part of the HIR,\n@@ -107,18 +105,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     block = this.expr_into_dest(\n                         this.tcx.mk_place_deref(Place::from(result)),\n                         block,\n-                        &value\n+                        value\n                     )\n                 );\n                 block.and(Rvalue::Use(Operand::Move(Place::from(result))))\n             }\n             ExprKind::Cast { source } => {\n-                let source = unpack!(block = this.as_operand(block, scope, &source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::Misc, source, expr.ty))\n             }\n             ExprKind::Pointer { cast, source } => {\n-                let source = unpack!(block = this.as_operand(block, scope, &source));\n-                block.and(Rvalue::Cast(CastKind::Pointer(*cast), source, expr.ty))\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n+                block.and(Rvalue::Cast(CastKind::Pointer(cast), source, expr.ty))\n             }\n             ExprKind::Array { fields } => {\n                 // (*) We would (maybe) be closer to codegen if we\n@@ -151,7 +149,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let el_ty = expr.ty.sequence_element_type(this.tcx);\n                 let fields: Vec<_> = fields\n                     .into_iter()\n-                    .map(|f| unpack!(block = this.as_operand(block, scope, &f)))\n+                    .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n                     .collect();\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Array(el_ty), fields))\n@@ -161,7 +159,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // first process the set of fields\n                 let fields: Vec<_> = fields\n                     .into_iter()\n-                    .map(|f| unpack!(block = this.as_operand(block, scope, &f)))\n+                    .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n                     .collect();\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n@@ -181,25 +179,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             // This occurs when capturing by copy/move, while\n                             // by reference captures use as_operand\n                             Some(Category::Place) => {\n-                                let place = unpack!(block = this.as_place(block, &upvar));\n+                                let place = unpack!(block = this.as_place(block, upvar));\n                                 this.consume_by_copy_or_move(place)\n                             }\n                             _ => {\n                                 // Turn mutable borrow captures into unique\n                                 // borrow captures when capturing an immutable\n                                 // variable. This is sound because the mutation\n                                 // that caused the capture will cause an error.\n-                                match &upvar.kind {\n+                                match upvar.kind {\n                                     ExprKind::Borrow {\n                                         borrow_kind:\n                                             BorrowKind::Mut { allow_two_phase_borrow: false },\n                                         arg,\n                                     } => unpack!(\n                                         block = this.limit_capture_mutability(\n-                                            upvar.span, upvar.ty, scope, block, &arg,\n+                                            upvar.span, upvar.ty, scope, block, arg,\n                                         )\n                                     ),\n-                                    _ => unpack!(block = this.as_operand(block, scope, &upvar)),\n+                                    _ => unpack!(block = this.as_operand(block, scope, upvar)),\n                                 }\n                             }\n                         }\n@@ -210,9 +208,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         // We implicitly set the discriminant to 0. See\n                         // librustc_mir/transform/deaggregator.rs for details.\n                         let movability = movability.unwrap();\n-                        box AggregateKind::Generator(*closure_id, substs, movability)\n+                        box AggregateKind::Generator(closure_id, substs, movability)\n                     }\n-                    UpvarSubsts::Closure(substs) => box AggregateKind::Closure(*closure_id, substs),\n+                    UpvarSubsts::Closure(substs) => box AggregateKind::Closure(closure_id, substs),\n                 };\n                 block.and(Rvalue::Aggregate(result, operands))\n             }"}, {"sha": "98b910ab21c16d683d9f063580c87052e9d22a42", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -38,8 +38,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n-        if let ExprKind::Scope { region_scope, lint_level, value } = &expr.kind {\n-            return this.in_scope((*region_scope, source_info), *lint_level, |this| {\n+        if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n+            return this.in_scope((region_scope, source_info), lint_level, |this| {\n                 this.as_temp(block, temp_lifetime, value, mutability)\n             });\n         }"}, {"sha": "47f75825fb6af61dcc202effc3f940ae2ddd7be4", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -36,24 +36,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             this.block_context.push(BlockFrame::SubExpr);\n         }\n \n-        let block_and = match &expr.kind {\n+        let block_and = match expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n-                let region_scope = (*region_scope, source_info);\n+                let region_scope = (region_scope, source_info);\n                 ensure_sufficient_stack(|| {\n-                    this.in_scope(region_scope, *lint_level, |this| {\n-                        this.expr_into_dest(destination, block, &value)\n+                    this.in_scope(region_scope, lint_level, |this| {\n+                        this.expr_into_dest(destination, block, value)\n                     })\n                 })\n             }\n-            ExprKind::Block { body: ast_block } => {\n-                this.ast_block(destination, block, &ast_block, source_info)\n+            ExprKind::Block { body: ref ast_block } => {\n+                this.ast_block(destination, block, ast_block, source_info)\n             }\n             ExprKind::Match { scrutinee, arms } => {\n-                this.match_expr(destination, expr_span, block, &scrutinee, &arms)\n+                this.match_expr(destination, expr_span, block, scrutinee, arms)\n             }\n             ExprKind::If { cond, then, else_opt } => {\n                 let place = unpack!(\n-                    block = this.as_temp(block, Some(this.local_scope()), &cond, Mutability::Mut)\n+                    block = this.as_temp(block, Some(this.local_scope()), cond, Mutability::Mut)\n                 );\n                 let operand = Operand::Move(Place::from(place));\n \n@@ -62,9 +62,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let term = TerminatorKind::if_(this.tcx, operand, then_block, else_block);\n                 this.cfg.terminate(block, source_info, term);\n \n-                unpack!(then_block = this.expr_into_dest(destination, then_block, &then));\n+                unpack!(then_block = this.expr_into_dest(destination, then_block, then));\n                 else_block = if let Some(else_opt) = else_opt {\n-                    unpack!(this.expr_into_dest(destination, else_block, &else_opt))\n+                    unpack!(this.expr_into_dest(destination, else_block, else_opt))\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n                     // we implicitly generate a `else {}` if it is not specified.\n@@ -94,8 +94,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // (#66975) Source could be a const of type `!`, so has to\n                 // exist in the generated MIR.\n                 unpack!(\n-                    block =\n-                        this.as_temp(block, Some(this.local_scope()), &source, Mutability::Mut,)\n+                    block = this.as_temp(block, Some(this.local_scope()), source, Mutability::Mut,)\n                 );\n \n                 // This is an optimization. If the expression was a call then we already have an\n@@ -128,15 +127,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.cfg.start_new_block(),\n                 );\n \n-                let lhs = unpack!(block = this.as_local_operand(block, &lhs));\n+                let lhs = unpack!(block = this.as_local_operand(block, lhs));\n                 let blocks = match op {\n                     LogicalOp::And => (else_block, false_block),\n                     LogicalOp::Or => (true_block, else_block),\n                 };\n                 let term = TerminatorKind::if_(this.tcx, lhs, blocks.0, blocks.1);\n                 this.cfg.terminate(block, source_info, term);\n \n-                let rhs = unpack!(else_block = this.as_local_operand(else_block, &rhs));\n+                let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n                 let term = TerminatorKind::if_(this.tcx, rhs, true_block, false_block);\n                 this.cfg.terminate(else_block, source_info, term);\n \n@@ -197,18 +196,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // introduce a unit temporary as the destination for the loop body.\n                     let tmp = this.get_unit_temp();\n                     // Execute the body, branching back to the test.\n-                    let body_block_end = unpack!(this.expr_into_dest(tmp, body_block, &body));\n+                    let body_block_end = unpack!(this.expr_into_dest(tmp, body_block, body));\n                     this.cfg.goto(body_block_end, source_info, loop_block);\n \n                     // Loops are only exited by `break` expressions.\n                     None\n                 })\n             }\n             ExprKind::Call { ty: _, fun, args, from_hir_call, fn_span } => {\n-                let fun = unpack!(block = this.as_local_operand(block, &fun));\n+                let fun = unpack!(block = this.as_local_operand(block, fun));\n                 let args: Vec<_> = args\n                     .into_iter()\n-                    .map(|arg| unpack!(block = this.as_local_call_operand(block, &arg)))\n+                    .map(|arg| unpack!(block = this.as_local_call_operand(block, arg)))\n                     .collect();\n \n                 let success = this.cfg.start_new_block();\n@@ -232,38 +231,38 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         } else {\n                             Some((destination, success))\n                         },\n-                        from_hir_call: *from_hir_call,\n-                        fn_span: *fn_span,\n+                        from_hir_call,\n+                        fn_span,\n                     },\n                 );\n                 this.diverge_from(block);\n                 success.unit()\n             }\n-            ExprKind::Use { source } => this.expr_into_dest(destination, block, &source),\n+            ExprKind::Use { source } => this.expr_into_dest(destination, block, source),\n             ExprKind::Borrow { arg, borrow_kind } => {\n                 // We don't do this in `as_rvalue` because we use `as_place`\n                 // for borrow expressions, so we cannot create an `RValue` that\n                 // remains valid across user code. `as_rvalue` is usually called\n                 // by this method anyway, so this shouldn't cause too many\n                 // unnecessary temporaries.\n                 let arg_place = match borrow_kind {\n-                    BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, &arg)),\n-                    _ => unpack!(block = this.as_place(block, &arg)),\n+                    BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, arg)),\n+                    _ => unpack!(block = this.as_place(block, arg)),\n                 };\n-                let borrow = Rvalue::Ref(this.tcx.lifetimes.re_erased, *borrow_kind, arg_place);\n+                let borrow = Rvalue::Ref(this.tcx.lifetimes.re_erased, borrow_kind, arg_place);\n                 this.cfg.push_assign(block, source_info, destination, borrow);\n                 block.unit()\n             }\n             ExprKind::AddressOf { mutability, arg } => {\n                 let place = match mutability {\n-                    hir::Mutability::Not => this.as_read_only_place(block, &arg),\n-                    hir::Mutability::Mut => this.as_place(block, &arg),\n+                    hir::Mutability::Not => this.as_read_only_place(block, arg),\n+                    hir::Mutability::Mut => this.as_place(block, arg),\n                 };\n-                let address_of = Rvalue::AddressOf(*mutability, unpack!(block = place));\n+                let address_of = Rvalue::AddressOf(mutability, unpack!(block = place));\n                 this.cfg.push_assign(block, source_info, destination, address_of);\n                 block.unit()\n             }\n-            ExprKind::Adt { adt_def, variant_index, substs, user_ty, fields, base } => {\n+            ExprKind::Adt { adt_def, variant_index, substs, user_ty, fields, ref base } => {\n                 // See the notes for `ExprKind::Array` in `as_rvalue` and for\n                 // `ExprKind::Borrow` above.\n                 let is_union = adt_def.is_union();\n@@ -275,16 +274,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // (evaluating them in order given by user)\n                 let fields_map: FxHashMap<_, _> = fields\n                     .into_iter()\n-                    .map(|f| {\n-                        (f.name, unpack!(block = this.as_operand(block, Some(scope), &f.expr)))\n-                    })\n+                    .map(|f| (f.name, unpack!(block = this.as_operand(block, Some(scope), f.expr))))\n                     .collect();\n \n                 let field_names: Vec<_> =\n-                    (0..adt_def.variants[*variant_index].fields.len()).map(Field::new).collect();\n+                    (0..adt_def.variants[variant_index].fields.len()).map(Field::new).collect();\n \n                 let fields: Vec<_> = if let Some(FruInfo { base, field_types }) = base {\n-                    let place_builder = unpack!(block = this.as_place_builder(block, &base));\n+                    let place_builder = unpack!(block = this.as_place_builder(block, base));\n \n                     // MIR does not natively support FRU, so for each\n                     // base-supplied field, generate an operand that\n@@ -318,7 +315,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 });\n                 let adt = box AggregateKind::Adt(\n                     adt_def,\n-                    *variant_index,\n+                    variant_index,\n                     substs,\n                     user_ty,\n                     active_field_index,\n@@ -336,48 +333,48 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 use rustc_middle::mir;\n                 let operands = operands\n                     .into_iter()\n-                    .map(|op| match op {\n+                    .map(|op| match *op {\n                         thir::InlineAsmOperand::In { reg, expr } => mir::InlineAsmOperand::In {\n-                            reg: *reg,\n-                            value: unpack!(block = this.as_local_operand(block, &expr)),\n+                            reg,\n+                            value: unpack!(block = this.as_local_operand(block, expr)),\n                         },\n                         thir::InlineAsmOperand::Out { reg, late, expr } => {\n                             mir::InlineAsmOperand::Out {\n-                                reg: *reg,\n-                                late: *late,\n+                                reg,\n+                                late,\n                                 place: expr\n                                     .as_ref()\n                                     .map(|expr| unpack!(block = this.as_place(block, expr))),\n                             }\n                         }\n                         thir::InlineAsmOperand::InOut { reg, late, expr } => {\n-                            let place = unpack!(block = this.as_place(block, &expr));\n+                            let place = unpack!(block = this.as_place(block, expr));\n                             mir::InlineAsmOperand::InOut {\n-                                reg: *reg,\n-                                late: *late,\n+                                reg,\n+                                late,\n                                 // This works because asm operands must be Copy\n                                 in_value: Operand::Copy(place),\n                                 out_place: Some(place),\n                             }\n                         }\n                         thir::InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n                             mir::InlineAsmOperand::InOut {\n-                                reg: *reg,\n-                                late: *late,\n-                                in_value: unpack!(block = this.as_local_operand(block, &in_expr)),\n+                                reg,\n+                                late,\n+                                in_value: unpack!(block = this.as_local_operand(block, in_expr)),\n                                 out_place: out_expr.as_ref().map(|out_expr| {\n                                     unpack!(block = this.as_place(block, out_expr))\n                                 }),\n                             }\n                         }\n                         thir::InlineAsmOperand::Const { expr } => mir::InlineAsmOperand::Const {\n-                            value: unpack!(block = this.as_local_operand(block, &expr)),\n+                            value: unpack!(block = this.as_local_operand(block, expr)),\n                         },\n                         thir::InlineAsmOperand::SymFn { expr } => {\n-                            mir::InlineAsmOperand::SymFn { value: box this.as_constant(&expr) }\n+                            mir::InlineAsmOperand::SymFn { value: box this.as_constant(expr) }\n                         }\n                         thir::InlineAsmOperand::SymStatic { def_id } => {\n-                            mir::InlineAsmOperand::SymStatic { def_id: *def_id }\n+                            mir::InlineAsmOperand::SymStatic { def_id }\n                         }\n                     })\n                     .collect();\n@@ -390,7 +387,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     TerminatorKind::InlineAsm {\n                         template,\n                         operands,\n-                        options: *options,\n+                        options,\n                         line_spans,\n                         destination: if options.contains(InlineAsmOptions::NORETURN) {\n                             None\n@@ -449,7 +446,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             ExprKind::Yield { value } => {\n                 let scope = this.local_scope();\n-                let value = unpack!(block = this.as_operand(block, Some(scope), &value));\n+                let value = unpack!(block = this.as_operand(block, Some(scope), value));\n                 let resume = this.cfg.start_new_block();\n                 this.cfg.terminate(\n                     block,"}, {"sha": "a3fbd21642d903d0f91a501813f7edadf8d73b5f", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -21,10 +21,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let source_info = this.source_info(expr.span);\n         // Handle a number of expressions that don't need a destination at all. This\n         // avoids needing a mountain of temporary `()` variables.\n-        match &expr.kind {\n+        match expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n-                this.in_scope((*region_scope, source_info), *lint_level, |this| {\n-                    this.stmt_expr(block, &value, statement_scope)\n+                this.in_scope((region_scope, source_info), lint_level, |this| {\n+                    this.stmt_expr(block, value, statement_scope)\n                 })\n             }\n             ExprKind::Assign { lhs, rhs } => {\n@@ -40,12 +40,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Generate better code for things that don't need to be\n                 // dropped.\n                 if lhs.ty.needs_drop(this.tcx, this.param_env) {\n-                    let rhs = unpack!(block = this.as_local_operand(block, &rhs));\n-                    let lhs = unpack!(block = this.as_place(block, &lhs));\n+                    let rhs = unpack!(block = this.as_local_operand(block, rhs));\n+                    let lhs = unpack!(block = this.as_place(block, lhs));\n                     unpack!(block = this.build_drop_and_replace(block, lhs_span, lhs, rhs));\n                 } else {\n-                    let rhs = unpack!(block = this.as_local_rvalue(block, &rhs));\n-                    let lhs = unpack!(block = this.as_place(block, &lhs));\n+                    let rhs = unpack!(block = this.as_local_rvalue(block, rhs));\n+                    let lhs = unpack!(block = this.as_place(block, lhs));\n                     this.cfg.push_assign(block, source_info, lhs, rhs);\n                 }\n \n@@ -67,34 +67,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.block_context.push(BlockFrame::SubExpr);\n \n                 // As above, RTL.\n-                let rhs = unpack!(block = this.as_local_operand(block, &rhs));\n-                let lhs = unpack!(block = this.as_place(block, &lhs));\n+                let rhs = unpack!(block = this.as_local_operand(block, rhs));\n+                let lhs = unpack!(block = this.as_place(block, lhs));\n \n                 // we don't have to drop prior contents or anything\n                 // because AssignOp is only legal for Copy types\n                 // (overloaded ops should be desugared into a call).\n                 let result = unpack!(\n-                    block = this.build_binary_op(\n-                        block,\n-                        *op,\n-                        expr_span,\n-                        lhs_ty,\n-                        Operand::Copy(lhs),\n-                        rhs\n-                    )\n+                    block =\n+                        this.build_binary_op(block, op, expr_span, lhs_ty, Operand::Copy(lhs), rhs)\n                 );\n                 this.cfg.push_assign(block, source_info, lhs, result);\n \n                 this.block_context.pop();\n                 block.unit()\n             }\n             ExprKind::Continue { label } => {\n-                this.break_scope(block, None, BreakableTarget::Continue(*label), source_info)\n+                this.break_scope(block, None, BreakableTarget::Continue(label), source_info)\n             }\n             ExprKind::Break { label, value } => this.break_scope(\n                 block,\n                 value.as_deref(),\n-                BreakableTarget::Break(*label),\n+                BreakableTarget::Break(label),\n                 source_info,\n             ),\n             ExprKind::Return { value } => {\n@@ -120,7 +114,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Statement {\n                         source_info,\n                         kind: StatementKind::LlvmInlineAsm(box LlvmInlineAsm {\n-                            asm: (*asm).clone(),\n+                            asm: asm.clone(),\n                             outputs,\n                             inputs,\n                         }),"}, {"sha": "6c31528be73f7fb7f324de631336385a292d5027", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -1754,7 +1754,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Guard::IfLet(pat, scrutinee) => {\n                     let scrutinee_span = scrutinee.span;\n                     let scrutinee_place =\n-                        unpack!(block = self.lower_scrutinee(block, &scrutinee, scrutinee_span));\n+                        unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span));\n                     let mut guard_candidate = Candidate::new(scrutinee_place, &pat, false);\n                     let wildcard = Pat::wildcard_from_ty(pat.ty);\n                     let mut otherwise_candidate = Candidate::new(scrutinee_place, &wildcard, false);"}, {"sha": "cb53c7ef5a601e7afd372b128f6b13e1fcbdeb16", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -643,7 +643,7 @@ where\n                         fn_def.did.to_def_id(),\n                         &arguments,\n                         arg_scope,\n-                        &expr,\n+                        expr,\n                     )\n                 }))\n             }));"}, {"sha": "d450f8a265d994e2dfb433131f6870c2067ffea1", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -11,7 +11,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n     crate fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block<'thir, 'tcx> {\n         // We have to eagerly lower the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n-        let stmts = self.mirror_stmts(block.hir_id.local_id, &*block.stmts);\n+        let stmts = self.mirror_stmts(block.hir_id.local_id, block.stmts);\n         let opt_destruction_scope =\n             self.region_scope_tree.opt_destruction_scope(block.hir_id.local_id);\n         Block {\n@@ -23,7 +23,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n             opt_destruction_scope,\n             span: block.span,\n             stmts,\n-            expr: block.expr.as_ref().map(|expr| self.mirror_expr(expr)),\n+            expr: block.expr.map(|expr| self.mirror_expr(expr)),\n             safety_mode: match block.rules {\n                 hir::BlockCheckMode::DefaultBlock => BlockSafety::Safe,\n                 hir::BlockCheckMode::UnsafeBlock(..) => BlockSafety::ExplicitUnsafe(block.hir_id),\n@@ -59,7 +59,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                         data: region::ScopeData::Remainder(region::FirstStatementIndex::new(index)),\n                     };\n \n-                    let mut pattern = self.pattern_from_hir(&local.pat);\n+                    let mut pattern = self.pattern_from_hir(local.pat);\n \n                     if let Some(ty) = &local.ty {\n                         if let Some(&user_ty) ="}, {"sha": "00456a8bcc3dc92d83e2bc1f24215953cdc2b89d", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd049ef9ea2e2084e64d0964b1a58b46839c640d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=cd049ef9ea2e2084e64d0964b1a58b46839c640d", "patch": "@@ -203,7 +203,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                     ExprKind::Call {\n                         ty: method.ty,\n                         fun: self.arena.alloc(method),\n-                        args: &*self\n+                        args: self\n                             .arena\n                             .alloc_from_iter(vec![self.mirror_expr_inner(fun), tupled_args]),\n                         from_hir_call: true,\n@@ -243,7 +243,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                             adt_def,\n                             substs,\n                             variant_index: index,\n-                            fields: &*field_refs,\n+                            fields: field_refs,\n                             user_ty,\n                             base: None,\n                         }\n@@ -277,7 +277,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                 if self.typeck_results().is_method_call(expr) {\n                     let lhs = self.mirror_expr_inner(lhs);\n                     let rhs = self.mirror_expr_inner(rhs);\n-                    self.overloaded_operator(expr, &*self.arena.alloc_from_iter(vec![lhs, rhs]))\n+                    self.overloaded_operator(expr, self.arena.alloc_from_iter(vec![lhs, rhs]))\n                 } else {\n                     ExprKind::AssignOp {\n                         op: bin_op(op.node),\n@@ -297,7 +297,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                 if self.typeck_results().is_method_call(expr) {\n                     let lhs = self.mirror_expr_inner(lhs);\n                     let rhs = self.mirror_expr_inner(rhs);\n-                    self.overloaded_operator(expr, &*self.arena.alloc_from_iter(vec![lhs, rhs]))\n+                    self.overloaded_operator(expr, self.arena.alloc_from_iter(vec![lhs, rhs]))\n                 } else {\n                     // FIXME overflow\n                     match op.node {\n@@ -332,7 +332,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                         expr,\n                         expr_ty,\n                         None,\n-                        &*self.arena.alloc_from_iter(vec![lhs, index]),\n+                        self.arena.alloc_from_iter(vec![lhs, index]),\n                         expr.span,\n                     )\n                 } else {\n@@ -347,7 +347,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                         expr,\n                         expr_ty,\n                         None,\n-                        &*self.arena.alloc_from_iter(iter::once(arg)),\n+                        self.arena.alloc_from_iter(iter::once(arg)),\n                         expr.span,\n                     )\n                 } else {\n@@ -358,7 +358,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n             hir::ExprKind::Unary(hir::UnOp::Not, ref arg) => {\n                 if self.typeck_results().is_method_call(expr) {\n                     let arg = self.mirror_expr_inner(arg);\n-                    self.overloaded_operator(expr, &*self.arena.alloc_from_iter(iter::once(arg)))\n+                    self.overloaded_operator(expr, self.arena.alloc_from_iter(iter::once(arg)))\n                 } else {\n                     ExprKind::Unary { op: UnOp::Not, arg: self.mirror_expr(arg) }\n                 }\n@@ -367,7 +367,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n             hir::ExprKind::Unary(hir::UnOp::Neg, ref arg) => {\n                 if self.typeck_results().is_method_call(expr) {\n                     let arg = self.mirror_expr_inner(arg);\n-                    self.overloaded_operator(expr, &*self.arena.alloc_from_iter(iter::once(arg)))\n+                    self.overloaded_operator(expr, self.arena.alloc_from_iter(iter::once(arg)))\n                 } else if let hir::ExprKind::Lit(ref lit) = arg.kind {\n                     ExprKind::Literal {\n                         literal: self.const_eval_literal(&lit.node, expr_ty, lit.span, true),"}]}