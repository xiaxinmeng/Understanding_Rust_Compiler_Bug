{"sha": "3fd632aa7ec9b4ad356a1ec5b3fe0794e6e3d8c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZDYzMmFhN2VjOWI0YWQzNTZhMWVjNWIzZmUwNzk0ZTZlM2Q4YzM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-06T20:39:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-06T20:39:12Z"}, "message": "Rollup merge of #61559 - spastorino:make-visitors-iterate, r=oli-obk\n\nMake visitors iterate\n\nr? @oli-obk\n\nThe second commit is not completely equivalent, unsure if the code is wrong or not. Tests pass though, otherwise we would need to iterate in the opposite direction as it happened in other parts of the code.", "tree": {"sha": "f1ad6b575920076bb634fc06b00da6534a1bd9fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1ad6b575920076bb634fc06b00da6534a1bd9fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fd632aa7ec9b4ad356a1ec5b3fe0794e6e3d8c3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc+XnwCRBK7hj4Ov3rIwAAdHIIADDpl4xwtGij06lvmkhiaEoP\nNFjcFt8hGyKvF8pzuKxWwEWv+c2kWRKtRft0fpCskdfC9k65WoqmACQgvs37oMj/\n9C/j+d4rYh3KrNFTe08s9uJKczMagl0Hzn4CKFM6GRcuiz1VCFwy0XoE6mR/qaAA\n4WBw/boBHtWhEKi0RmqxxICsPwVA5EbVsHCIKyEv5J0dHCN0AqL7/vuvxbf8TwIg\nYyxD9MAmfcHxRnMsaMFVpveK1uyhIDOtGjn0KUd8L62jSez1Xuzm1KnstZ5APNhB\n4koIOBwu7ukNv3wXB04iY54OBPZr+R77JZKoeq+CDwwiQ+RDHQS/Lgd6l96+8qI=\n=HarK\n-----END PGP SIGNATURE-----\n", "payload": "tree f1ad6b575920076bb634fc06b00da6534a1bd9fa\nparent 4c74056867e2df800b0932e5b78d8464d8dc449f\nparent 0cfaa28bc5edda198571fca9410cbc9f71b8d17a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1559853552 +0200\ncommitter GitHub <noreply@github.com> 1559853552 +0200\n\nRollup merge of #61559 - spastorino:make-visitors-iterate, r=oli-obk\n\nMake visitors iterate\n\nr? @oli-obk\n\nThe second commit is not completely equivalent, unsure if the code is wrong or not. Tests pass though, otherwise we would need to iterate in the opposite direction as it happened in other parts of the code.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd632aa7ec9b4ad356a1ec5b3fe0794e6e3d8c3", "html_url": "https://github.com/rust-lang/rust/commit/3fd632aa7ec9b4ad356a1ec5b3fe0794e6e3d8c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fd632aa7ec9b4ad356a1ec5b3fe0794e6e3d8c3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c74056867e2df800b0932e5b78d8464d8dc449f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c74056867e2df800b0932e5b78d8464d8dc449f", "html_url": "https://github.com/rust-lang/rust/commit/4c74056867e2df800b0932e5b78d8464d8dc449f"}, {"sha": "0cfaa28bc5edda198571fca9410cbc9f71b8d17a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cfaa28bc5edda198571fca9410cbc9f71b8d17a", "html_url": "https://github.com/rust-lang/rust/commit/0cfaa28bc5edda198571fca9410cbc9f71b8d17a"}], "stats": {"total": 164, "additions": 87, "deletions": 77}, "files": [{"sha": "549608bf7ee5fb5a9e7ee9621d82d38acb7817be", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 48, "deletions": 37, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3fd632aa7ec9b4ad356a1ec5b3fe0794e6e3d8c3/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd632aa7ec9b4ad356a1ec5b3fe0794e6e3d8c3/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=3fd632aa7ec9b4ad356a1ec5b3fe0794e6e3d8c3", "patch": "@@ -154,51 +154,62 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                    context: PlaceContext,\n                    location: Location) {\n         debug!(\"visit_place(place={:?}, context={:?})\", place, context);\n+        let mut context = context;\n         let cx = self.fx.cx;\n \n-        if let mir::Place::Projection(ref proj) = *place {\n-            // Allow uses of projections that are ZSTs or from scalar fields.\n-            let is_consume = match context {\n-                PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n-                PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => true,\n-                _ => false\n-            };\n-            if is_consume {\n-                let base_ty = proj.base.ty(self.fx.mir, cx.tcx());\n-                let base_ty = self.fx.monomorphize(&base_ty);\n-\n-                // ZSTs don't require any actual memory access.\n-                let elem_ty = base_ty\n-                    .projection_ty(cx.tcx(), &proj.elem)\n-                    .ty;\n-                let elem_ty = self.fx.monomorphize(&elem_ty);\n-                if cx.layout_of(elem_ty).is_zst() {\n-                    return;\n-                }\n-\n-                if let mir::ProjectionElem::Field(..) = proj.elem {\n-                    let layout = cx.layout_of(base_ty.ty);\n-                    if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n-                        // Recurse with the same context, instead of `Projection`,\n-                        // potentially stopping at non-operand projections,\n-                        // which would trigger `not_ssa` on locals.\n-                        self.visit_place(&proj.base, context, location);\n+        place.iterate(|place_base, place_projections| {\n+            for proj in place_projections {\n+                // Allow uses of projections that are ZSTs or from scalar fields.\n+                let is_consume = match context {\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => true,\n+                    _ => false\n+                };\n+                if is_consume {\n+                    let base_ty = proj.base.ty(self.fx.mir, cx.tcx());\n+                    let base_ty = self.fx.monomorphize(&base_ty);\n+\n+                    // ZSTs don't require any actual memory access.\n+                    let elem_ty = base_ty\n+                        .projection_ty(cx.tcx(), &proj.elem)\n+                        .ty;\n+                    let elem_ty = self.fx.monomorphize(&elem_ty);\n+                    if cx.layout_of(elem_ty).is_zst() {\n                         return;\n                     }\n+\n+                    if let mir::ProjectionElem::Field(..) = proj.elem {\n+                        let layout = cx.layout_of(base_ty.ty);\n+                        if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n+                            // Recurse with the same context, instead of `Projection`,\n+                            // potentially stopping at non-operand projections,\n+                            // which would trigger `not_ssa` on locals.\n+                            continue;\n+                        }\n+                    }\n                 }\n-            }\n \n-            // A deref projection only reads the pointer, never needs the place.\n-            if let mir::ProjectionElem::Deref = proj.elem {\n-                return self.visit_place(\n-                    &proj.base,\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n-                    location\n-                );\n+                // A deref projection only reads the pointer, never needs the place.\n+                if let mir::ProjectionElem::Deref = proj.elem {\n+                    return self.visit_place(\n+                        &proj.base,\n+                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                        location\n+                    );\n+                }\n+\n+                context = if context.is_mutating_use() {\n+                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n+                } else {\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n+                };\n             }\n-        }\n \n-        self.super_place(place, context, location);\n+            // Default base visit behavior\n+            if let mir::PlaceBase::Local(local) = place_base {\n+                self.visit_local(local, context, location);\n+            }\n+        });\n     }\n \n     fn visit_local(&mut self,"}, {"sha": "4e8cc124e50407fe97dc49772ec636cabc4debb5", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/3fd632aa7ec9b4ad356a1ec5b3fe0794e6e3d8c3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd632aa7ec9b4ad356a1ec5b3fe0794e6e3d8c3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=3fd632aa7ec9b4ad356a1ec5b3fe0794e6e3d8c3", "patch": "@@ -199,11 +199,39 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n     fn visit_place(&mut self,\n                     place: &Place<'tcx>,\n                     context: PlaceContext,\n-                    location: Location) {\n-        match place {\n-            &Place::Projection(box Projection {\n-                ref base, ref elem\n-            }) => {\n+                    _location: Location) {\n+        place.iterate(|place_base, place_projections| {\n+            match place_base {\n+                PlaceBase::Local(..) => {\n+                    // Locals are safe.\n+                }\n+                PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. }) => {\n+                    bug!(\"unsafety checking should happen before promotion\")\n+                }\n+                PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. }) => {\n+                    if self.tcx.is_mutable_static(*def_id) {\n+                        self.require_unsafe(\"use of mutable static\",\n+                            \"mutable statics can be mutated by multiple threads: aliasing \\\n+                             violations or data races will cause undefined behavior\",\n+                             UnsafetyViolationKind::General);\n+                    } else if self.tcx.is_foreign_item(*def_id) {\n+                        let source_info = self.source_info;\n+                        let lint_root =\n+                            self.source_scope_local_data[source_info.scope].lint_root;\n+                        self.register_violations(&[UnsafetyViolation {\n+                            source_info,\n+                            description: InternedString::intern(\"use of extern static\"),\n+                            details: InternedString::intern(\n+                                \"extern statics are not controlled by the Rust type system: \\\n+                                invalid data, aliasing violations or data races will cause \\\n+                                undefined behavior\"),\n+                            kind: UnsafetyViolationKind::ExternStatic(lint_root)\n+                        }], &[]);\n+                    }\n+                }\n+            }\n+\n+            for proj in place_projections {\n                 if context.is_borrow() {\n                     if util::is_disaligned(self.tcx, self.mir, self.param_env, place) {\n                         let source_info = self.source_info;\n@@ -220,7 +248,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         }], &[]);\n                     }\n                 }\n-                let is_borrow_of_interior_mut = context.is_borrow() && !base\n+                let is_borrow_of_interior_mut = context.is_borrow() && !proj.base\n                     .ty(self.mir, self.tcx)\n                     .ty\n                     .is_freeze(self.tcx, self.param_env, self.source_info.span);\n@@ -236,15 +264,15 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     );\n                 }\n                 let old_source_info = self.source_info;\n-                if let &Place::Base(PlaceBase::Local(local)) = base {\n+                if let Place::Base(PlaceBase::Local(local)) = proj.base {\n                     if self.mir.local_decls[local].internal {\n                         // Internal locals are used in the `move_val_init` desugaring.\n                         // We want to check unsafety against the source info of the\n                         // desugaring, rather than the source info of the RHS.\n                         self.source_info = self.mir.local_decls[local].source_info;\n                     }\n                 }\n-                let base_ty = base.ty(self.mir, self.tcx).ty;\n+                let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                 match base_ty.sty {\n                     ty::RawPtr(..) => {\n                         self.require_unsafe(\"dereference of raw pointer\",\n@@ -260,8 +288,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                                     MutatingUseContext::AsmOutput\n                                 )\n                             {\n-                                let elem_ty = match elem {\n-                                    &ProjectionElem::Field(_, ty) => ty,\n+                                let elem_ty = match proj.elem {\n+                                    ProjectionElem::Field(_, ty) => ty,\n                                     _ => span_bug!(\n                                         self.source_info.span,\n                                         \"non-field projection {:?} from union?\",\n@@ -292,36 +320,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 self.source_info = old_source_info;\n             }\n-            &Place::Base(PlaceBase::Local(..)) => {\n-                // locals are safe\n-            }\n-            &Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) => {\n-                bug!(\"unsafety checking should happen before promotion\")\n-            }\n-            &Place::Base(\n-                PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. })\n-            ) => {\n-                if self.tcx.is_mutable_static(def_id) {\n-                    self.require_unsafe(\"use of mutable static\",\n-                        \"mutable statics can be mutated by multiple threads: aliasing violations \\\n-                         or data races will cause undefined behavior\",\n-                         UnsafetyViolationKind::General);\n-                } else if self.tcx.is_foreign_item(def_id) {\n-                    let source_info = self.source_info;\n-                    let lint_root =\n-                        self.source_scope_local_data[source_info.scope].lint_root;\n-                    self.register_violations(&[UnsafetyViolation {\n-                        source_info,\n-                        description: InternedString::intern(\"use of extern static\"),\n-                        details: InternedString::intern(\n-                            \"extern statics are not controlled by the Rust type system: invalid \\\n-                            data, aliasing violations or data races will cause undefined behavior\"),\n-                        kind: UnsafetyViolationKind::ExternStatic(lint_root)\n-                    }], &[]);\n-                }\n-            }\n-        };\n-        self.super_place(place, context, location);\n+        });\n     }\n }\n "}]}