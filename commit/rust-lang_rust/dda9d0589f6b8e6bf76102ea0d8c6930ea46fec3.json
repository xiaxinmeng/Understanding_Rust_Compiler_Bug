{"sha": "dda9d0589f6b8e6bf76102ea0d8c6930ea46fec3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYTlkMDU4OWY2YjhlNmJmNzYxMDJlYTBkOGM2OTMwZWE0NmZlYzM=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2021-03-14T04:07:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-14T04:07:34Z"}, "message": "Rollup merge of #82943 - kornelski:threadstdio, r=joshtriplett\n\nDemonstrate best practice for feeding stdin of a child processes\n\nDocumentation change.\n\nIt's possible to create a deadlock with stdin/stdout I/O on a single thread:\n\n* the child process may fill its stdout buffer, and have to wait for the parent process to read it,\n* but the parent process may be waiting until its stdin write finishes before reading the stdout.\n\nTherefore, the parent process should use separate threads for writing and reading.\n\nThese examples are not deadlocking in practice, because they use short strings, but I think it's better to demonstrate code that works even for long writes. The problem is non-obvious and tricky to debug (it seems that even libstd has a similar issue: #45572).\n\nThis also demonstrates how to use stdio with threads: it's not obvious that `.take()` can be used to avoid fighting with the borrow checker.\n\nI've checked that the modified examples run fine.", "tree": {"sha": "d3bcdc1035a24a7fc635c74de2fe9b1a283d7ce9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3bcdc1035a24a7fc635c74de2fe9b1a283d7ce9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dda9d0589f6b8e6bf76102ea0d8c6930ea46fec3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgTYwHCRBK7hj4Ov3rIwAAdHIIAGM3gKTdz2181cDUeRm5bDef\nhiH1Ixj1AoJ14p8tARR38NHujJCYv5BdLrFOP5k6NL/6sEbzRPOC3uq5ZXnQUNed\n6tnN5ebJgYwWfpFlA5qlkQu9VNpuX2ff94kf0u5blQQBEJSFoJlpALuPU/JTUnM6\no2FHE9NKiLRG3Bq+Xiux2LEBBFjf3sfM62il2TYxLbQk/W2AD4oiZECDwnx0G8Gg\nW9/rnFf1LPf9mZkOaIuU/tyMb+p9sIIpgfa6zv/xOCutKi86lsloX4Ia+HJqglEA\nvoHnL16QxmcKQNdWa0SAFxvPzPUuuB/pn1VeOL6dMkdbWvHjAMRADHQooJmp/qw=\n=UHpK\n-----END PGP SIGNATURE-----\n", "payload": "tree d3bcdc1035a24a7fc635c74de2fe9b1a283d7ce9\nparent 9ce0820eefaa6dbfeadbca75f99063ae668cb30d\nparent ce2d95cd75adb5f75921536191b4dcfa41be1eff\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1615694854 +0900\ncommitter GitHub <noreply@github.com> 1615694854 +0900\n\nRollup merge of #82943 - kornelski:threadstdio, r=joshtriplett\n\nDemonstrate best practice for feeding stdin of a child processes\n\nDocumentation change.\n\nIt's possible to create a deadlock with stdin/stdout I/O on a single thread:\n\n* the child process may fill its stdout buffer, and have to wait for the parent process to read it,\n* but the parent process may be waiting until its stdin write finishes before reading the stdout.\n\nTherefore, the parent process should use separate threads for writing and reading.\n\nThese examples are not deadlocking in practice, because they use short strings, but I think it's better to demonstrate code that works even for long writes. The problem is non-obvious and tricky to debug (it seems that even libstd has a similar issue: #45572).\n\nThis also demonstrates how to use stdio with threads: it's not obvious that `.take()` can be used to avoid fighting with the borrow checker.\n\nI've checked that the modified examples run fine.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dda9d0589f6b8e6bf76102ea0d8c6930ea46fec3", "html_url": "https://github.com/rust-lang/rust/commit/dda9d0589f6b8e6bf76102ea0d8c6930ea46fec3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dda9d0589f6b8e6bf76102ea0d8c6930ea46fec3/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ce0820eefaa6dbfeadbca75f99063ae668cb30d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ce0820eefaa6dbfeadbca75f99063ae668cb30d", "html_url": "https://github.com/rust-lang/rust/commit/9ce0820eefaa6dbfeadbca75f99063ae668cb30d"}, {"sha": "ce2d95cd75adb5f75921536191b4dcfa41be1eff", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce2d95cd75adb5f75921536191b4dcfa41be1eff", "html_url": "https://github.com/rust-lang/rust/commit/ce2d95cd75adb5f75921536191b4dcfa41be1eff"}], "stats": {"total": 25, "additions": 18, "deletions": 7}, "files": [{"sha": "f9cfd11e90650e2035c75b3413a4c03cc7881605", "filename": "library/std/src/process.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dda9d0589f6b8e6bf76102ea0d8c6930ea46fec3/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda9d0589f6b8e6bf76102ea0d8c6930ea46fec3/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=dda9d0589f6b8e6bf76102ea0d8c6930ea46fec3", "patch": "@@ -71,11 +71,15 @@\n //!     .spawn()\n //!     .expect(\"failed to execute child\");\n //!\n-//! {\n-//!     // limited borrow of stdin\n-//!     let stdin = child.stdin.as_mut().expect(\"failed to get stdin\");\n+//! // If the child process fills its stdout buffer, it may end up\n+//! // waiting until the parent reads the stdout, and not be able to\n+//! // read stdin in the meantime, causing a deadlock.\n+//! // Writing from another thread ensures that stdout is being read\n+//! // at the same time, avoiding the problem.\n+//! let mut stdin = child.stdin.take().expect(\"failed to get stdin\");\n+//! std::thread::spawn(move || {\n //!     stdin.write_all(b\"test\").expect(\"failed to write to stdin\");\n-//! }\n+//! });\n //!\n //! let output = child\n //!     .wait_with_output()\n@@ -1145,14 +1149,21 @@ impl Stdio {\n     ///     .spawn()\n     ///     .expect(\"Failed to spawn child process\");\n     ///\n-    /// {\n-    ///     let stdin = child.stdin.as_mut().expect(\"Failed to open stdin\");\n+    /// let mut stdin = child.stdin.take().expect(\"Failed to open stdin\");\n+    /// std::thread::spawn(move || {\n     ///     stdin.write_all(\"Hello, world!\".as_bytes()).expect(\"Failed to write to stdin\");\n-    /// }\n+    /// });\n     ///\n     /// let output = child.wait_with_output().expect(\"Failed to read stdout\");\n     /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"!dlrow ,olleH\");\n     /// ```\n+    ///\n+    /// Writing more than a pipe buffer's worth of input to stdin without also reading\n+    /// stdout and stderr at the same time may cause a deadlock.\n+    /// This is an issue when running any program that doesn't guarantee that it reads\n+    /// its entire stdin before writing more than a pipe buffer's worth of output.\n+    /// The size of a pipe buffer varies on different targets.\n+    ///\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn piped() -> Stdio {\n         Stdio(imp::Stdio::MakePipe)"}]}