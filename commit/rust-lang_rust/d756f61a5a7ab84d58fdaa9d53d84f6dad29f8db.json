{"sha": "d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NTZmNjFhNWE3YWI4NGQ1OGZkYWE5ZDUzZDg0ZjZkYWQyOWY4ZGI=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-11-09T09:55:57Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-11-22T05:22:31Z"}, "message": "Make is_uninhabited respect privacy", "tree": {"sha": "c56b85f11021792f673249fbb140944c7a3e316c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c56b85f11021792f673249fbb140944c7a3e316c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db", "html_url": "https://github.com/rust-lang/rust/commit/d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6cc398207009884a2885855e79ba424c2f4c303", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6cc398207009884a2885855e79ba424c2f4c303", "html_url": "https://github.com/rust-lang/rust/commit/a6cc398207009884a2885855e79ba424c2f4c303"}], "stats": {"total": 35, "additions": 21, "deletions": 14}, "files": [{"sha": "88eb4ec1014cb6c6f41c3828a8442afdbc55bb26", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db", "patch": "@@ -1394,13 +1394,16 @@ impl<'a, 'gcx, 'tcx> AdtDefData<'tcx, 'static> {\n     #[inline]\n     pub fn is_uninhabited_recurse(&'tcx self,\n                                   visited: &mut HashMap<(DefId, &'tcx Substs<'tcx>), ()>,\n+                                  block: Option<NodeId>,\n                                   cx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   substs: &'tcx Substs<'tcx>) -> bool {\n         match visited.entry((self.did, substs)) {\n             hash_map::Entry::Occupied(_) => return false,\n             hash_map::Entry::Vacant(ve) => ve.insert(()),\n         };\n-        self.variants.iter().all(|v| v.is_uninhabited_recurse(visited, cx, substs, self.is_union()))\n+        self.variants.iter().all(|v| {\n+            v.is_uninhabited_recurse(visited, block, cx, substs, self.is_union())\n+        })\n     }\n }\n \n@@ -1809,13 +1812,14 @@ impl<'a, 'gcx, 'tcx> VariantDefData<'tcx, 'static> {\n     #[inline]\n     pub fn is_uninhabited_recurse(&'tcx self,\n                                   visited: &mut HashMap<(DefId, &'tcx Substs<'tcx>), ()>,\n+                                  block: Option<NodeId>,\n                                   cx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   substs: &'tcx Substs<'tcx>,\n                                   is_union: bool) -> bool {\n         if is_union {\n-            self.fields.iter().all(|f| f.is_uninhabited_recurse(visited, cx, substs))\n+            self.fields.iter().all(|f| f.is_uninhabited_recurse(visited, block, cx, substs))\n         } else {\n-            self.fields.iter().any(|f| f.is_uninhabited_recurse(visited, cx, substs))\n+            self.fields.iter().any(|f| f.is_uninhabited_recurse(visited, block, cx, substs))\n         }\n     }\n }\n@@ -1849,9 +1853,11 @@ impl<'a, 'gcx, 'tcx> FieldDefData<'tcx, 'static> {\n     #[inline]\n     pub fn is_uninhabited_recurse(&'tcx self,\n                                   visited: &mut HashMap<(DefId, &'tcx Substs<'tcx>), ()>,\n+                                  block: Option<NodeId>,\n                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   substs: &'tcx Substs<'tcx>) -> bool {\n-        self.ty(tcx, substs).is_uninhabited_recurse(visited, tcx)\n+        block.map_or(true, |b| self.vis.is_accessible_from(b, &tcx.map)) &&\n+        self.ty(tcx, substs).is_uninhabited_recurse(visited, block, tcx)\n     }\n }\n "}, {"sha": "4e54e3a3630ddd6cc124ecb4a61eab8e5812417d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db", "patch": "@@ -23,7 +23,7 @@ use std::fmt;\n use std::ops;\n use std::collections::HashMap;\n use syntax::abi;\n-use syntax::ast::{self, Name};\n+use syntax::ast::{self, Name, NodeId};\n use syntax::symbol::{keywords, InternedString};\n \n use serialize;\n@@ -930,25 +930,26 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_uninhabited(&self, cx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    /// Checks whether a type is uninhabited.\n+    /// If `block` is `Some(id)` it also checks that the uninhabited-ness is visible from `id`.\n+    pub fn is_uninhabited(&self, block: Option<NodeId>, cx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         let mut visited = HashMap::new();\n-        self.is_uninhabited_recurse(&mut visited, cx)\n+        self.is_uninhabited_recurse(&mut visited, block, cx)\n     }\n \n     pub fn is_uninhabited_recurse(&self,\n                                   visited: &mut HashMap<(DefId, &'tcx Substs<'tcx>), ()>,\n+                                  block: Option<NodeId>,\n                                   cx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        // FIXME(#24885): be smarter here, the AdtDefData::is_empty method could easily be made\n-        // more complete.\n         match self.sty {\n             TyAdt(def, substs) => {\n-                def.is_uninhabited_recurse(visited, cx, substs)\n+                def.is_uninhabited_recurse(visited, block, cx, substs)\n             },\n \n             TyNever => true,\n-            TyTuple(ref tys) => tys.iter().any(|ty| ty.is_uninhabited_recurse(visited, cx)),\n-            TyArray(ty, len) => len > 0 && ty.is_uninhabited_recurse(visited, cx),\n-            TyRef(_, ref tm) => tm.ty.is_uninhabited_recurse(visited, cx),\n+            TyTuple(ref tys) => tys.iter().any(|ty| ty.is_uninhabited_recurse(visited, block, cx)),\n+            TyArray(ty, len) => len > 0 && ty.is_uninhabited_recurse(visited, block, cx),\n+            TyRef(_, ref tm) => tm.ty.is_uninhabited_recurse(visited, block, cx),\n \n             _ => false,\n         }"}, {"sha": "3c94d7d6fd5d14919824d55b931de929616ce987", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=d756f61a5a7ab84d58fdaa9d53d84f6dad29f8db", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Check for empty enum, because is_useful only works on inhabited types.\n             let pat_ty = self.tcx.tables().node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n-                if !pat_ty.is_uninhabited(self.tcx) {\n+                if !pat_ty.is_uninhabited(Some(scrut.id), self.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n                     let mut err = create_e0004(self.tcx.sess, span,\n                                                format!(\"non-exhaustive patterns: type {} \\"}]}