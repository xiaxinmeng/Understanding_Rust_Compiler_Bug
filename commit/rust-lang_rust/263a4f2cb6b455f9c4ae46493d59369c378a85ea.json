{"sha": "263a4f2cb6b455f9c4ae46493d59369c378a85ea", "node_id": "C_kwDOAAsO6NoAKDI2M2E0ZjJjYjZiNDU1ZjljNGFlNDY0OTNkNTkzNjljMzc4YTg1ZWE", "commit": {"author": {"name": "Bryan Garza", "email": "1396101+bryangarza@users.noreply.github.com", "date": "2023-04-27T21:38:32Z"}, "committer": {"name": "Bryan Garza", "email": "1396101+bryangarza@users.noreply.github.com", "date": "2023-05-24T21:52:19Z"}, "message": "Safe Transmute: Change Answer type to Result\n\nThis patch updates the `Answer` type from `rustc_transmute` so that it just a\ntype alias to `Result`. This makes it so that the standard methods for `Result`\ncan be used to process the `Answer` tree, including being able to make use of\nthe `?` operator on `Answer`s.\n\nAlso, remove some unused functions", "tree": {"sha": "5b928687e50f2cfa00f7555552590a3610539b8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b928687e50f2cfa00f7555552590a3610539b8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/263a4f2cb6b455f9c4ae46493d59369c378a85ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/263a4f2cb6b455f9c4ae46493d59369c378a85ea", "html_url": "https://github.com/rust-lang/rust/commit/263a4f2cb6b455f9c4ae46493d59369c378a85ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/263a4f2cb6b455f9c4ae46493d59369c378a85ea/comments", "author": {"login": "bryangarza", "id": 1396101, "node_id": "MDQ6VXNlcjEzOTYxMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1396101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bryangarza", "html_url": "https://github.com/bryangarza", "followers_url": "https://api.github.com/users/bryangarza/followers", "following_url": "https://api.github.com/users/bryangarza/following{/other_user}", "gists_url": "https://api.github.com/users/bryangarza/gists{/gist_id}", "starred_url": "https://api.github.com/users/bryangarza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bryangarza/subscriptions", "organizations_url": "https://api.github.com/users/bryangarza/orgs", "repos_url": "https://api.github.com/users/bryangarza/repos", "events_url": "https://api.github.com/users/bryangarza/events{/privacy}", "received_events_url": "https://api.github.com/users/bryangarza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bryangarza", "id": 1396101, "node_id": "MDQ6VXNlcjEzOTYxMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1396101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bryangarza", "html_url": "https://github.com/bryangarza", "followers_url": "https://api.github.com/users/bryangarza/followers", "following_url": "https://api.github.com/users/bryangarza/following{/other_user}", "gists_url": "https://api.github.com/users/bryangarza/gists{/gist_id}", "starred_url": "https://api.github.com/users/bryangarza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bryangarza/subscriptions", "organizations_url": "https://api.github.com/users/bryangarza/orgs", "repos_url": "https://api.github.com/users/bryangarza/repos", "events_url": "https://api.github.com/users/bryangarza/events{/privacy}", "received_events_url": "https://api.github.com/users/bryangarza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f1cec8d8472c3ffacedd4783c64182a407c72df", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f1cec8d8472c3ffacedd4783c64182a407c72df", "html_url": "https://github.com/rust-lang/rust/commit/8f1cec8d8472c3ffacedd4783c64182a407c72df"}], "stats": {"total": 253, "additions": 113, "deletions": 140}, "files": [{"sha": "e8abd5964bbf3e32cb383d0f2397c62d350bb141", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=263a4f2cb6b455f9c4ae46493d59369c378a85ea", "patch": "@@ -675,11 +675,11 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             scope,\n             assume,\n         ) {\n-            rustc_transmute::Answer::Yes => Ok(Certainty::Yes),\n-            rustc_transmute::Answer::No(_)\n-            | rustc_transmute::Answer::IfTransmutable { .. }\n-            | rustc_transmute::Answer::IfAll(_)\n-            | rustc_transmute::Answer::IfAny(_) => Err(NoSolution),\n+            Ok(None) => Ok(Certainty::Yes),\n+            Err(_)\n+            | Ok(Some(rustc_transmute::Condition::IfTransmutable { .. }))\n+            | Ok(Some(rustc_transmute::Condition::IfAll(_)))\n+            | Ok(Some(rustc_transmute::Condition::IfAny(_))) => Err(NoSolution),\n         }\n     }\n }"}, {"sha": "71419fe0eee0ba2de489df39622fc77e74cba1d7", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=263a4f2cb6b455f9c4ae46493d59369c378a85ea", "patch": "@@ -2751,13 +2751,14 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             rustc_transmute::Assume::from_const(self.infcx.tcx, obligation.param_env, trait_ref.substs.const_at(3)) else {\n                 span_bug!(span, \"Unable to construct rustc_transmute::Assume where it was previously possible\");\n             };\n+        // FIXME(bryangarza): Need to flatten here too\n         match rustc_transmute::TransmuteTypeEnv::new(self.infcx).is_transmutable(\n             obligation.cause,\n             src_and_dst,\n             scope,\n             assume,\n         ) {\n-            rustc_transmute::Answer::No(reason) => {\n+            Err(reason) => {\n                 let dst = trait_ref.substs.type_at(0);\n                 let src = trait_ref.substs.type_at(1);\n                 let custom_err_msg = format!(\n@@ -2795,7 +2796,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 (custom_err_msg, Some(reason_msg))\n             }\n             // Should never get a Yes at this point! We already ran it before, and did not get a Yes.\n-            rustc_transmute::Answer::Yes => span_bug!(\n+            Ok(None) => span_bug!(\n                 span,\n                 \"Inconsistent rustc_transmute::is_transmutable(...) result, got Yes\",\n             ),"}, {"sha": "528a5f9dc616ab27b70c05c2ba268950ecb06cef", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=263a4f2cb6b455f9c4ae46493d59369c378a85ea", "patch": "@@ -279,23 +279,24 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ImplSourceBuiltinData { nested: obligations }\n     }\n \n-    #[instrument(skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn confirm_transmutability_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        #[instrument(level = \"debug\", skip(tcx, obligation, predicate))]\n         fn flatten_answer_tree<'tcx>(\n             tcx: TyCtxt<'tcx>,\n             obligation: &TraitObligation<'tcx>,\n             predicate: TraitPredicate<'tcx>,\n             answer: rustc_transmute::Answer<rustc_transmute::layout::rustc::Ref<'tcx>>,\n         ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n             match answer {\n-                rustc_transmute::Answer::Yes => Ok(vec![]),\n-                rustc_transmute::Answer::No(_) => Err(Unimplemented),\n+                Ok(None) => Ok(vec![]),\n+                Err(_) => Err(Unimplemented),\n                 // FIXME(bryangarza): Add separate `IfAny` case, instead of treating as `IfAll`\n-                rustc_transmute::Answer::IfAll(answers)\n-                | rustc_transmute::Answer::IfAny(answers) => {\n+                Ok(Some(rustc_transmute::Condition::IfAll(answers)))\n+                | Ok(Some(rustc_transmute::Condition::IfAny(answers))) => {\n                     let mut nested = vec![];\n                     for flattened in answers\n                         .into_iter()\n@@ -305,7 +306,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                     Ok(nested)\n                 }\n-                rustc_transmute::Answer::IfTransmutable { src, dst } => {\n+                Ok(Some(rustc_transmute::Condition::IfTransmutable { src, dst })) => {\n                     let trait_def_id = obligation.predicate.def_id();\n                     let scope = predicate.trait_ref.substs.type_at(2);\n                     let assume_const = predicate.trait_ref.substs.const_at(3);\n@@ -334,8 +335,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         }\n \n-        debug!(?obligation, \"confirm_transmutability_candidate\");\n-\n         // We erase regions here because transmutability calls layout queries,\n         // which does not handle inference regions and doesn't particularly\n         // care about other regions. Erasing late-bound regions is equivalent\n@@ -352,21 +351,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(Unimplemented);\n         };\n \n+        let dst = predicate.trait_ref.substs.type_at(0);\n+        let src = predicate.trait_ref.substs.type_at(1);\n         let mut transmute_env = rustc_transmute::TransmuteTypeEnv::new(self.infcx);\n         let maybe_transmutable = transmute_env.is_transmutable(\n             obligation.cause.clone(),\n-            rustc_transmute::Types {\n-                dst: predicate.trait_ref.substs.type_at(0),\n-                src: predicate.trait_ref.substs.type_at(1),\n-            },\n+            rustc_transmute::Types { dst, src },\n             predicate.trait_ref.substs.type_at(2),\n             assume,\n         );\n \n-        info!(?maybe_transmutable);\n-        let nested = flatten_answer_tree(self.tcx(), obligation, predicate, maybe_transmutable)?;\n-        info!(?nested);\n-        Ok(ImplSourceBuiltinData { nested })\n+        debug!(?src, ?dst);\n+        let fully_flattened =\n+            flatten_answer_tree(self.tcx(), obligation, predicate, maybe_transmutable)?;\n+        debug!(?fully_flattened);\n+        Ok(ImplSourceBuiltinData { nested: fully_flattened })\n     }\n \n     /// This handles the case where an `auto trait Foo` impl is being used."}, {"sha": "baf63e6d3a22525e44f8a298ef668511fbed5f13", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=263a4f2cb6b455f9c4ae46493d59369c378a85ea", "patch": "@@ -19,15 +19,12 @@ pub struct Assume {\n     pub validity: bool,\n }\n \n-/// The type encodes answers to the question: \"Are these types transmutable?\"\n-#[derive(Debug, Hash, Eq, PartialEq, PartialOrd, Ord, Clone)]\n-pub enum Answer<R> {\n-    /// `Src` is transmutable into `Dst`.\n-    Yes,\n-\n-    /// `Src` is NOT transmutable into `Dst`.\n-    No(Reason),\n+/// Either we have an error, or we have an optional Condition that must hold.\n+pub type Answer<R> = Result<Option<Condition<R>>, Reason>;\n \n+/// A condition which must hold for safe transmutation to be possible\n+#[derive(Debug, Hash, Eq, PartialEq, Clone)]\n+pub enum Condition<R> {\n     /// `Src` is transmutable into `Dst`, if `src` is transmutable into `dst`.\n     IfTransmutable { src: R, dst: R },\n "}, {"sha": "de00efb16148fa5e6737050a1794cc64c252d8ab", "filename": "compiler/rustc_transmute/src/maybe_transmutable/mod.rs", "status": "modified", "additions": 79, "deletions": 103, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs?ref=263a4f2cb6b455f9c4ae46493d59369c378a85ea", "patch": "@@ -5,7 +5,7 @@ mod tests;\n use crate::{\n     layout::{self, dfa, Byte, Dfa, Nfa, Ref, Tree, Uninhabited},\n     maybe_transmutable::query_context::QueryContext,\n-    Answer, Map, Reason,\n+    Answer, Condition, Map, Reason,\n };\n \n pub(crate) struct MaybeTransmutableQuery<L, C>\n@@ -76,12 +76,12 @@ mod rustc {\n                 let dst = Tree::from_ty(dst, context);\n \n                 match (src, dst) {\n-                    // Answer `Yes` here, because 'unknown layout' and type errors will already\n+                    // Answer `Ok(None)` here, because 'unknown layout' and type errors will already\n                     // be reported by rustc. No need to spam the user with more errors.\n-                    (Err(Err::TypeError(_)), _) | (_, Err(Err::TypeError(_))) => Err(Answer::Yes),\n-                    (Err(Err::Unknown), _) | (_, Err(Err::Unknown)) => Err(Answer::Yes),\n+                    (Err(Err::TypeError(_)), _) | (_, Err(Err::TypeError(_))) => Err(Ok(None)),\n+                    (Err(Err::Unknown), _) | (_, Err(Err::Unknown)) => Err(Ok(None)),\n                     (Err(Err::Unspecified), _) | (_, Err(Err::Unspecified)) => {\n-                        Err(Answer::No(Reason::SrcIsUnspecified))\n+                        Err(Err(Reason::SrcIsUnspecified))\n                     }\n                     (Ok(src), Ok(dst)) => Ok((src, dst)),\n                 }\n@@ -127,13 +127,12 @@ where\n             // Convert `src` from a tree-based representation to an NFA-based representation.\n             // If the conversion fails because `src` is uninhabited, conclude that the transmutation\n             // is acceptable, because instances of the `src` type do not exist.\n-            let src = Nfa::from_tree(src).map_err(|Uninhabited| Answer::Yes)?;\n+            let src = Nfa::from_tree(src).map_err(|Uninhabited| Ok(None))?;\n \n             // Convert `dst` from a tree-based representation to an NFA-based representation.\n             // If the conversion fails because `src` is uninhabited, conclude that the transmutation\n             // is unacceptable, because instances of the `dst` type do not exist.\n-            let dst =\n-                Nfa::from_tree(dst).map_err(|Uninhabited| Answer::No(Reason::DstIsPrivate))?;\n+            let dst = Nfa::from_tree(dst).map_err(|Uninhabited| Err(Reason::DstIsPrivate))?;\n \n             Ok((src, dst))\n         });\n@@ -205,13 +204,13 @@ where\n         } else {\n             let answer = if dst_state == self.dst.accepting {\n                 // truncation: `size_of(Src) >= size_of(Dst)`\n-                Answer::Yes\n+                Ok(None)\n             } else if src_state == self.src.accepting {\n                 // extension: `size_of(Src) >= size_of(Dst)`\n                 if let Some(dst_state_prime) = self.dst.byte_from(dst_state, Byte::Uninit) {\n                     self.answer_memo(cache, src_state, dst_state_prime)\n                 } else {\n-                    Answer::No(Reason::DstIsTooBig)\n+                    Err(Reason::DstIsTooBig)\n                 }\n             } else {\n                 let src_quantifier = if self.assume.validity {\n@@ -244,24 +243,24 @@ where\n                             } else {\n                                 // otherwise, we've exhausted our options.\n                                 // the DFAs, from this point onwards, are bit-incompatible.\n-                                Answer::No(Reason::DstIsBitIncompatible)\n+                                Err(Reason::DstIsBitIncompatible)\n                             }\n                         },\n                     ),\n                 );\n \n                 // The below early returns reflect how this code would behave:\n                 //   if self.assume.validity {\n-                //       bytes_answer.or(refs_answer)\n+                //       or(bytes_answer, refs_answer)\n                 //   } else {\n-                //       bytes_answer.and(refs_answer)\n+                //       and(bytes_answer, refs_answer)\n                 //   }\n                 // ...if `refs_answer` was computed lazily. The below early\n                 // returns can be deleted without impacting the correctness of\n                 // the algoritm; only its performance.\n                 match bytes_answer {\n-                    Answer::No(..) if !self.assume.validity => return bytes_answer,\n-                    Answer::Yes if self.assume.validity => return bytes_answer,\n+                    Err(_) if !self.assume.validity => return bytes_answer,\n+                    Ok(None) if self.assume.validity => return bytes_answer,\n                     _ => {}\n                 };\n \n@@ -277,20 +276,25 @@ where\n                                     .into_iter()\n                                     .map(|(&dst_ref, &dst_state_prime)| {\n                                         if !src_ref.is_mutable() && dst_ref.is_mutable() {\n-                                            Answer::No(Reason::DstIsMoreUnique)\n+                                            Err(Reason::DstIsMoreUnique)\n                                         } else if !self.assume.alignment\n                                             && src_ref.min_align() < dst_ref.min_align()\n                                         {\n-                                            Answer::No(Reason::DstHasStricterAlignment)\n+                                            Err(Reason::DstHasStricterAlignment)\n                                         } else {\n                                             // ...such that `src` is transmutable into `dst`, if\n                                             // `src_ref` is transmutability into `dst_ref`.\n-                                            Answer::IfTransmutable { src: src_ref, dst: dst_ref }\n-                                                .and(self.answer_memo(\n+                                            and(\n+                                                Ok(Some(Condition::IfTransmutable {\n+                                                    src: src_ref,\n+                                                    dst: dst_ref,\n+                                                })),\n+                                                self.answer_memo(\n                                                     cache,\n                                                     src_state_prime,\n                                                     dst_state_prime,\n-                                                ))\n+                                                ),\n+                                            )\n                                         }\n                                     }),\n                             )\n@@ -299,9 +303,9 @@ where\n                 );\n \n                 if self.assume.validity {\n-                    bytes_answer.or(refs_answer)\n+                    or(bytes_answer, refs_answer)\n                 } else {\n-                    bytes_answer.and(refs_answer)\n+                    and(bytes_answer, refs_answer)\n                 }\n             };\n             if let Some(..) = cache.insert((src_state, dst_state), answer.clone()) {\n@@ -312,81 +316,55 @@ where\n     }\n }\n \n-impl<R> Answer<R>\n-where\n-    R: layout::Ref,\n-{\n-    pub(crate) fn and(self, rhs: Self) -> Self {\n-        match (self, rhs) {\n-            (_, Self::No(reason)) | (Self::No(reason), _) => Self::No(reason),\n-\n-            (Self::Yes, other) | (other, Self::Yes) => other,\n-\n-            (Self::IfAll(mut lhs), Self::IfAll(ref mut rhs)) => {\n-                lhs.append(rhs);\n-                Self::IfAll(lhs)\n-            }\n-\n-            (constraint, Self::IfAll(mut constraints))\n-            | (Self::IfAll(mut constraints), constraint) => {\n-                constraints.push(constraint);\n-                Self::IfAll(constraints)\n-            }\n-\n-            (lhs, rhs) => Self::IfAll(vec![lhs, rhs]),\n+fn and<R>(lhs: Answer<R>, rhs: Answer<R>) -> Answer<R> {\n+    // Should propagate errors on the right side, because the initial value\n+    // used in `apply` is on the left side.\n+    let rhs = rhs?;\n+    let lhs = lhs?;\n+    Ok(match (lhs, rhs) {\n+        // If only one side has a condition, pass it along\n+        (None, other) | (other, None) => other,\n+        // If both sides have IfAll conditions, merge them\n+        (Some(Condition::IfAll(mut lhs)), Some(Condition::IfAll(ref mut rhs))) => {\n+            lhs.append(rhs);\n+            Some(Condition::IfAll(lhs))\n         }\n-    }\n-\n-    pub(crate) fn or(self, rhs: Self) -> Self {\n-        match (self, rhs) {\n-            (Self::Yes, _) | (_, Self::Yes) => Self::Yes,\n-            (other, Self::No(reason)) | (Self::No(reason), other) => other,\n-            (Self::IfAny(mut lhs), Self::IfAny(ref mut rhs)) => {\n-                lhs.append(rhs);\n-                Self::IfAny(lhs)\n-            }\n-            (constraint, Self::IfAny(mut constraints))\n-            | (Self::IfAny(mut constraints), constraint) => {\n-                constraints.push(constraint);\n-                Self::IfAny(constraints)\n-            }\n-            (lhs, rhs) => Self::IfAny(vec![lhs, rhs]),\n+        // If only one side is an IfAll, add the other Condition to it\n+        (constraint, Some(Condition::IfAll(mut constraints)))\n+        | (Some(Condition::IfAll(mut constraints)), constraint) => {\n+            constraints.push(Ok(constraint));\n+            Some(Condition::IfAll(constraints))\n         }\n-    }\n+        // Otherwise, both lhs and rhs conditions can be combined in a parent IfAll\n+        (lhs, rhs) => Some(Condition::IfAll(vec![Ok(lhs), Ok(rhs)])),\n+    })\n }\n \n-pub fn for_all<R, I, F>(iter: I, f: F) -> Answer<R>\n-where\n-    R: layout::Ref,\n-    I: IntoIterator,\n-    F: FnMut(<I as IntoIterator>::Item) -> Answer<R>,\n-{\n-    use std::ops::ControlFlow::{Break, Continue};\n-    let (Continue(result) | Break(result)) =\n-        iter.into_iter().map(f).try_fold(Answer::Yes, |constraints, constraint| {\n-            match constraint.and(constraints) {\n-                Answer::No(reason) => Break(Answer::No(reason)),\n-                maybe => Continue(maybe),\n-            }\n-        });\n-    result\n-}\n-\n-pub fn there_exists<R, I, F>(iter: I, f: F) -> Answer<R>\n-where\n-    R: layout::Ref,\n-    I: IntoIterator,\n-    F: FnMut(<I as IntoIterator>::Item) -> Answer<R>,\n-{\n-    use std::ops::ControlFlow::{Break, Continue};\n-    let (Continue(result) | Break(result)) = iter.into_iter().map(f).try_fold(\n-        Answer::No(Reason::DstIsBitIncompatible),\n-        |constraints, constraint| match constraint.or(constraints) {\n-            Answer::Yes => Break(Answer::Yes),\n-            maybe => Continue(maybe),\n-        },\n-    );\n-    result\n+fn or<R>(lhs: Answer<R>, rhs: Answer<R>) -> Answer<R> {\n+    // If both are errors, then we should return the one on the right\n+    if lhs.is_err() && rhs.is_err() {\n+        return rhs;\n+    }\n+    // Otherwise, errors can be ignored for the rest of the pattern matching\n+    let lhs = lhs.unwrap_or(None);\n+    let rhs = rhs.unwrap_or(None);\n+    Ok(match (lhs, rhs) {\n+        // If only one side has a condition, pass it along\n+        (None, other) | (other, None) => other,\n+        // If both sides have IfAny conditions, merge them\n+        (Some(Condition::IfAny(mut lhs)), Some(Condition::IfAny(ref mut rhs))) => {\n+            lhs.append(rhs);\n+            Some(Condition::IfAny(lhs))\n+        }\n+        // If only one side is an IfAny, add the other Condition to it\n+        (constraint, Some(Condition::IfAny(mut constraints)))\n+        | (Some(Condition::IfAny(mut constraints)), constraint) => {\n+            constraints.push(Ok(constraint));\n+            Some(Condition::IfAny(constraints))\n+        }\n+        // Otherwise, both lhs and rhs conditions can be combined in a parent IfAny\n+        (lhs, rhs) => Some(Condition::IfAny(vec![Ok(lhs), Ok(rhs)])),\n+    })\n }\n \n pub enum Quantifier {\n@@ -403,16 +381,14 @@ impl Quantifier {\n         use std::ops::ControlFlow::{Break, Continue};\n \n         let (init, try_fold_f): (_, fn(_, _) -> _) = match self {\n-            Self::ThereExists => {\n-                (Answer::No(Reason::DstIsBitIncompatible), |accum: Answer<R>, next| {\n-                    match accum.or(next) {\n-                        Answer::Yes => Break(Answer::Yes),\n-                        maybe => Continue(maybe),\n-                    }\n-                })\n-            }\n-            Self::ForAll => (Answer::Yes, |accum: Answer<R>, next| match accum.and(next) {\n-                Answer::No(reason) => Break(Answer::No(reason)),\n+            Self::ThereExists => (Err(Reason::DstIsBitIncompatible), |accum: Answer<R>, next| {\n+                match or(accum, next) {\n+                    Ok(None) => Break(Ok(None)),\n+                    maybe => Continue(maybe),\n+                }\n+            }),\n+            Self::ForAll => (Ok(None), |accum: Answer<R>, next| match and(accum, next) {\n+                Err(reason) => Break(Err(reason)),\n                 maybe => Continue(maybe),\n             }),\n         };"}, {"sha": "df6a83df23f2028742d8b0364cec7c20c6ed3dd4", "filename": "compiler/rustc_transmute/src/maybe_transmutable/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a4f2cb6b455f9c4ae46493d59369c378a85ea/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs?ref=263a4f2cb6b455f9c4ae46493d59369c378a85ea", "patch": "@@ -1,6 +1,6 @@\n use super::query_context::test::{Def, UltraMinimal};\n use crate::maybe_transmutable::MaybeTransmutableQuery;\n-use crate::{layout, Answer, Reason};\n+use crate::{layout, Reason};\n use itertools::Itertools;\n \n mod bool {\n@@ -17,7 +17,7 @@ mod bool {\n             UltraMinimal,\n         )\n         .answer();\n-        assert_eq!(answer, Answer::Yes);\n+        assert_eq!(answer, Ok(None));\n     }\n \n     #[test]\n@@ -30,7 +30,7 @@ mod bool {\n             UltraMinimal,\n         )\n         .answer();\n-        assert_eq!(answer, Answer::Yes);\n+        assert_eq!(answer, Ok(None));\n     }\n \n     #[test]\n@@ -65,7 +65,7 @@ mod bool {\n \n                 if src_set.is_subset(&dst_set) {\n                     assert_eq!(\n-                        Answer::Yes,\n+                        Ok(None),\n                         MaybeTransmutableQuery::new(\n                             src_layout.clone(),\n                             dst_layout.clone(),\n@@ -80,7 +80,7 @@ mod bool {\n                     );\n                 } else if !src_set.is_disjoint(&dst_set) {\n                     assert_eq!(\n-                        Answer::Yes,\n+                        Ok(None),\n                         MaybeTransmutableQuery::new(\n                             src_layout.clone(),\n                             dst_layout.clone(),\n@@ -95,7 +95,7 @@ mod bool {\n                     );\n                 } else {\n                     assert_eq!(\n-                        Answer::No(Reason::DstIsBitIncompatible),\n+                        Err(Reason::DstIsBitIncompatible),\n                         MaybeTransmutableQuery::new(\n                             src_layout.clone(),\n                             dst_layout.clone(),"}]}