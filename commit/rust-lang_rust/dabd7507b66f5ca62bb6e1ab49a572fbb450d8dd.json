{"sha": "dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYmQ3NTA3YjY2ZjVjYTYyYmI2ZTFhYjQ5YTU3MmZiYjQ1MGQ4ZGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-23T10:26:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-02T17:09:38Z"}, "message": "Ensure that, for every trait `Foo`, the predicate `Foo : Foo` holds.", "tree": {"sha": "248d3bc2c1ce401b4d8cc470663730ed06278e63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/248d3bc2c1ce401b4d8cc470663730ed06278e63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "html_url": "https://github.com/rust-lang/rust/commit/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19dcecb2258dcbc6f02be9beac105b57fd43472f", "url": "https://api.github.com/repos/rust-lang/rust/commits/19dcecb2258dcbc6f02be9beac105b57fd43472f", "html_url": "https://github.com/rust-lang/rust/commit/19dcecb2258dcbc6f02be9beac105b57fd43472f"}], "stats": {"total": 374, "additions": 335, "deletions": 39}, "files": [{"sha": "c0f8eb59fce861250abc84f8973def3d37479fed", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "patch": "@@ -605,9 +605,6 @@ impl<'a, Sized? T: Show> Show for &'a T {\n impl<'a, Sized? T: Show> Show for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n-impl<'a> Show for &'a (Show+'a) {\n-    fn fmt(&self, f: &mut Formatter) -> Result { (*self).fmt(f) }\n-}\n \n impl Show for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {"}, {"sha": "41028292da8f7100950b9baa4c1d0708a9bdd935", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "patch": "@@ -217,6 +217,9 @@ pub enum Vtable<'tcx, N> {\n     /// for some type parameter.\n     VtableParam,\n \n+    /// Virtual calls through an object\n+    VtableObject(VtableObjectData<'tcx>),\n+\n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n \n@@ -252,6 +255,13 @@ pub struct VtableBuiltinData<N> {\n     pub nested: subst::VecPerParamSpace<N>\n }\n \n+/// A vtable for some object-safe trait `Foo` automatically derived\n+/// for the object type `Foo`.\n+#[deriving(PartialEq,Eq,Clone)]\n+pub struct VtableObjectData<'tcx> {\n+    pub object_ty: Ty<'tcx>,\n+}\n+\n /// True if neither the trait nor self type is local. Note that `impl_def_id` must refer to an impl\n /// of a trait, not an inherent impl.\n pub fn is_orphan_impl(tcx: &ty::ctxt,\n@@ -372,6 +382,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableFnPointer(..) => (&[]).iter(),\n             VtableUnboxedClosure(..) => (&[]).iter(),\n             VtableParam => (&[]).iter(),\n+            VtableObject(_) => (&[]).iter(),\n             VtableBuiltin(ref i) => i.iter_nested(),\n         }\n     }\n@@ -382,6 +393,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableFnPointer(ref sig) => VtableFnPointer((*sig).clone()),\n             VtableUnboxedClosure(d, ref s) => VtableUnboxedClosure(d, s.clone()),\n             VtableParam => VtableParam,\n+            VtableObject(ref p) => VtableObject(p.clone()),\n             VtableBuiltin(ref b) => VtableBuiltin(b.map_nested(op)),\n         }\n     }\n@@ -394,6 +406,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableFnPointer(sig) => VtableFnPointer(sig),\n             VtableUnboxedClosure(d, s) => VtableUnboxedClosure(d, s),\n             VtableParam => VtableParam,\n+            VtableObject(p) => VtableObject(p),\n             VtableBuiltin(no) => VtableBuiltin(no.map_move_nested(op)),\n         }\n     }"}, {"sha": "0544e32b62c6a7846bf165011c35886a67cdf448", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "patch": "@@ -377,20 +377,14 @@ fn project_type<'cx,'tcx>(\n         ambiguous: false,\n     };\n \n-    assemble_candidates_from_object_type(selcx,\n-                                         obligation,\n-                                         &mut candidates);\n-\n-    if candidates.vec.is_empty() {\n-        assemble_candidates_from_param_env(selcx,\n-                                           obligation,\n-                                           &mut candidates);\n-\n-        if let Err(e) = assemble_candidates_from_impls(selcx,\n-                                                       obligation,\n-                                                       &mut candidates) {\n-            return Err(ProjectionTyError::TraitSelectionError(e));\n-        }\n+    assemble_candidates_from_param_env(selcx,\n+                                       obligation,\n+                                       &mut candidates);\n+\n+    if let Err(e) = assemble_candidates_from_impls(selcx,\n+                                                   obligation,\n+                                                   &mut candidates) {\n+        return Err(ProjectionTyError::TraitSelectionError(e));\n     }\n \n     debug!(\"{} candidates, ambiguous={}\",\n@@ -467,18 +461,22 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n fn assemble_candidates_from_object_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    object_ty: Ty<'tcx>)\n {\n     let infcx = selcx.infcx();\n-    let trait_ref = infcx.resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n-    debug!(\"assemble_candidates_from_object_type(trait_ref={})\",\n-           trait_ref.repr(infcx.tcx));\n-    let self_ty = trait_ref.self_ty();\n-    let data = match self_ty.sty {\n+    debug!(\"assemble_candidates_from_object_type(object_ty={})\",\n+           object_ty.repr(infcx.tcx));\n+    let data = match object_ty.sty {\n         ty::ty_trait(ref data) => data,\n-        _ => { return; }\n+        _ => {\n+            selcx.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"assemble_candidates_from_object_type called with non-object: {}\",\n+                        object_ty.repr(selcx.tcx()))[]);\n+        }\n     };\n-    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), self_ty);\n+    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n     let env_predicates = projection_bounds.iter()\n                                           .map(|p| p.as_predicate())\n                                           .collect();\n@@ -515,6 +513,10 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             candidate_set.vec.push(\n                 ProjectionTyCandidate::Impl(data));\n         }\n+        super::VtableObject(data) => {\n+            assemble_candidates_from_object_type(\n+                selcx, obligation, candidate_set, data.object_ty);\n+        }\n         super::VtableParam(..) => {\n             // This case tell us nothing about the value of an\n             // associated type. Consider:"}, {"sha": "6a69c878a762fde1e72f16399d26938900802efa", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 125, "deletions": 9, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "patch": "@@ -24,8 +24,10 @@ use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n-use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure, VtableFnPointer};\n-use super::{VtableImplData, VtableBuiltinData};\n+use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure,\n+            VtableFnPointer, VtableObject};\n+use super::{VtableImplData, VtableObjectData, VtableBuiltinData};\n+use super::object_safety;\n use super::{util};\n \n use middle::fast_reject;\n@@ -147,6 +149,8 @@ enum SelectionCandidate<'tcx> {\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n     FnPointerCandidate,\n \n+    ObjectCandidate,\n+\n     ErrorCandidate,\n }\n \n@@ -717,6 +721,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 try!(self.assemble_unboxed_closure_candidates(obligation, &mut candidates));\n                 try!(self.assemble_fn_pointer_candidates(obligation, &mut candidates));\n                 try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n+                self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n             }\n         }\n \n@@ -878,7 +883,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let matching_bounds =\n             all_bounds.filter(\n                 |bound| self.infcx.probe(\n-                    |_| self.match_where_clause(obligation, bound.clone())).is_ok());\n+                    |_| self.match_poly_trait_ref(obligation, bound.clone())).is_ok());\n \n         let param_candidates =\n             matching_bounds.map(|bound| ParamCandidate(bound));\n@@ -945,7 +950,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         match self_ty.sty {\n-            ty::ty_infer(..) => {\n+            ty::ty_infer(ty::TyVar(_)) => {\n                 candidates.ambiguous = true; // could wind up being a fn() type\n             }\n \n@@ -991,6 +996,67 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(())\n     }\n \n+    /// Search for impls that might apply to `obligation`.\n+    fn assemble_candidates_from_object_ty(&mut self,\n+                                          obligation: &TraitObligation<'tcx>,\n+                                          candidates: &mut SelectionCandidateSet<'tcx>)\n+    {\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+\n+        debug!(\"assemble_candidates_from_object_ty(self_ty={})\",\n+               self_ty.repr(self.tcx()));\n+\n+        // Object-safety candidates are only applicable to object-safe\n+        // traits. Including this check is useful because it helps\n+        // inference in cases of traits like `BorrowFrom`, which are\n+        // not object-safe, and which rely on being able to infer the\n+        // self-type from one of the other inputs. Without this check,\n+        // these cases wind up being considered ambiguous due to a\n+        // (spurious) ambiguity introduced here.\n+        if !object_safety::is_object_safe(self.tcx(), obligation.predicate.to_poly_trait_ref()) {\n+            return;\n+        }\n+\n+        let poly_trait_ref = match self_ty.sty {\n+            ty::ty_trait(ref data) => {\n+                data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+            }\n+            ty::ty_infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n+                candidates.ambiguous = true; // could wind up being an object type\n+                return;\n+            }\n+            _ => {\n+                return;\n+            }\n+        };\n+\n+        debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n+               poly_trait_ref.repr(self.tcx()));\n+\n+        // see whether the object trait can be upcast to the trait we are looking for\n+        let obligation_def_id = obligation.predicate.def_id();\n+        let upcast_trait_ref = match util::upcast(self.tcx(), poly_trait_ref, obligation_def_id) {\n+            Some(r) => r,\n+            None => { return; }\n+        };\n+\n+        debug!(\"assemble_candidates_from_object_ty: upcast_trait_ref={}\",\n+               upcast_trait_ref.repr(self.tcx()));\n+\n+        // check whether the upcast version of the trait-ref matches what we are looking for\n+        match\n+            self.infcx.probe(\n+                |_| self.match_poly_trait_ref(obligation, upcast_trait_ref.clone()))\n+        {\n+            Ok(()) => {\n+                debug!(\"assemble_candidates_from_object_ty: matched, pushing candidate\");\n+                candidates.vec.push(ObjectCandidate);\n+            }\n+            Err(()) => { }\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // WINNOW\n     //\n@@ -1544,6 +1610,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(VtableUnboxedClosure(closure_def_id, substs))\n             }\n \n+            ObjectCandidate => {\n+                let data = self.confirm_object_candidate(obligation);\n+                Ok(VtableObject(data))\n+            }\n+\n             FnPointerCandidate => {\n                 let fn_type =\n                     try!(self.confirm_fn_pointer_candidate(obligation));\n@@ -1727,6 +1798,48 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          nested: impl_predicates }\n     }\n \n+    fn confirm_object_candidate(&mut self,\n+                                obligation: &TraitObligation<'tcx>)\n+                                -> VtableObjectData<'tcx>\n+    {\n+        debug!(\"confirm_object_candidate({})\",\n+               obligation.repr(self.tcx()));\n+\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        let poly_trait_ref = match self_ty.sty {\n+            ty::ty_trait(ref data) => {\n+                data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+            }\n+            _ => {\n+                self.tcx().sess.span_bug(obligation.cause.span,\n+                                         \"object candidate with non-object\");\n+            }\n+        };\n+\n+        let obligation_def_id = obligation.predicate.def_id();\n+        let upcast_trait_ref = match util::upcast(self.tcx(),\n+                                                  poly_trait_ref.clone(),\n+                                                  obligation_def_id) {\n+            Some(r) => r,\n+            None => {\n+                self.tcx().sess.span_bug(obligation.cause.span,\n+                                         format!(\"unable to upcast from {} to {}\",\n+                                                 poly_trait_ref.repr(self.tcx()),\n+                                                 obligation_def_id.repr(self.tcx())).as_slice());\n+            }\n+        };\n+\n+        match self.match_poly_trait_ref(obligation, upcast_trait_ref) {\n+            Ok(()) => { }\n+            Err(()) => {\n+                self.tcx().sess.span_bug(obligation.cause.span,\n+                                         \"failed to match trait refs\");\n+            }\n+        }\n+\n+        VtableObjectData { object_ty: self_ty }\n+    }\n+\n     fn confirm_fn_pointer_candidate(&mut self,\n                                     obligation: &TraitObligation<'tcx>)\n                                     -> Result<ty::Ty<'tcx>,SelectionError<'tcx>>\n@@ -1962,12 +2075,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n     }\n \n-    fn match_where_clause(&mut self,\n-                          obligation: &TraitObligation<'tcx>,\n-                          where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n-                        -> Result<(),()>\n+    fn match_poly_trait_ref(&mut self,\n+                            obligation: &TraitObligation<'tcx>,\n+                            where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n+                            -> Result<(),()>\n     {\n-        debug!(\"match_where_clause: obligation={} where_clause_trait_ref={}\",\n+        debug!(\"match_poly_trait_ref: obligation={} where_clause_trait_ref={}\",\n                obligation.repr(self.tcx()),\n                where_clause_trait_ref.repr(self.tcx()));\n \n@@ -2161,6 +2274,9 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n             ProjectionCandidate => format!(\"ProjectionCandidate\"),\n             FnPointerCandidate => format!(\"FnPointerCandidate\"),\n+            ObjectCandidate => {\n+                format!(\"ObjectCandidate\")\n+            }\n             UnboxedClosureCandidate(c, ref s) => {\n                 format!(\"UnboxedClosureCandidate({},{})\", c, s.repr(tcx))\n             }"}, {"sha": "41a59d6a5d84679b63d9a3c056bb9463a457bb87", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "patch": "@@ -238,6 +238,12 @@ impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n     }\n }\n \n+impl<'tcx> fmt::Show for super::VtableObjectData<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableObject(...)\")\n+    }\n+}\n+\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,\n@@ -366,6 +372,10 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n                 format!(\"VtableFnPointer({})\",\n                         d.repr(tcx)),\n \n+            super::VtableObject(ref d) =>\n+                format!(\"VtableObject({})\",\n+                        d.repr(tcx)),\n+\n             super::VtableParam =>\n                 format!(\"VtableParam\"),\n \n@@ -391,6 +401,13 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableBuiltinData<N> {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for super::VtableObjectData<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"VtableObject(object_ty={})\",\n+                self.object_ty.repr(tcx))\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {"}, {"sha": "abbf530529bb2fd41959cb259c4dc90e5a04db15", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "patch": "@@ -503,6 +503,15 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n             }\n             traits::VtableParam => traits::VtableParam,\n             traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n+            traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n+        traits::VtableObjectData {\n+            object_ty: self.object_ty.fold_with(folder)\n         }\n     }\n }"}, {"sha": "99624f1b1e7d8197a36e4a12e91a161a35c9c621", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 147, "deletions": 4, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use arena::TypedArena;\n use back::abi;\n-use llvm;\n-use llvm::ValueRef;\n+use back::link;\n+use llvm::{mod, ValueRef, get_param};\n use metadata::csearch;\n-use middle::subst::{Substs};\n+use middle::subst::{Subst, Substs};\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n@@ -370,6 +370,10 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llfn = trans_fn_pointer_shim(bcx.ccx(), fn_ty);\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n+        traits::VtableObject(ref data) => {\n+            let llfn = trans_object_shim(bcx.ccx(), data.object_ty, trait_id, n_method);\n+            Callee { bcx: bcx, data: Fn(llfn) }\n+        }\n         traits::VtableBuiltin(..) |\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n@@ -503,6 +507,137 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n }\n \n+/// Generate a shim function that allows an object type like `SomeTrait` to\n+/// implement the type `SomeTrait`. Imagine a trait definition:\n+///\n+///    trait SomeTrait { fn get(&self) -> int; ... }\n+///\n+/// And a generic bit of code:\n+///\n+///    fn foo<T:SomeTrait>(t: &T) {\n+///        let x = SomeTrait::get;\n+///        x(t)\n+///    }\n+///\n+/// What is the value of `x` when `foo` is invoked with `T=SomeTrait`?\n+/// The answer is that it it is a shim function generate by this\n+/// routine:\n+///\n+///    fn shim(t: &SomeTrait) -> int {\n+///        // ... call t.get() virtually ...\n+///    }\n+///\n+/// In fact, all virtual calls can be thought of as normal trait calls\n+/// that go through this shim function.\n+pub fn trans_object_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    object_ty: Ty<'tcx>,\n+    trait_id: ast::DefId,\n+    method_offset_in_trait: uint)\n+    -> ValueRef\n+{\n+    let _icx = push_ctxt(\"trans_object_shim\");\n+    let tcx = ccx.tcx();\n+\n+    debug!(\"trans_object_shim(object_ty={}, trait_id={}, n_method={})\",\n+           object_ty.repr(tcx),\n+           trait_id.repr(tcx),\n+           method_offset_in_trait);\n+\n+    let object_trait_ref =\n+        match object_ty.sty {\n+            ty::ty_trait(ref data) => {\n+                data.principal_trait_ref_with_self_ty(tcx, object_ty)\n+            }\n+            _ => {\n+                tcx.sess.bug(format!(\"trans_object_shim() called on non-object: {}\",\n+                                     object_ty.repr(tcx)).as_slice());\n+            }\n+        };\n+\n+    // Upcast to the trait in question and extract out the substitutions.\n+    let upcast_trait_ref = traits::upcast(ccx.tcx(), object_trait_ref.clone(), trait_id).unwrap();\n+    let object_substs = upcast_trait_ref.substs().clone().erase_regions();\n+    debug!(\"trans_object_shim: object_substs={}\", object_substs.repr(tcx));\n+\n+    // Lookup the type of this method as deeclared in the trait and apply substitutions.\n+    let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n+        ty::MethodTraitItem(method) => method,\n+        ty::TypeTraitItem(_) => {\n+            tcx.sess.bug(\"can't create a method shim for an associated type\")\n+        }\n+    };\n+    let fty = method_ty.fty.subst(tcx, &object_substs);\n+    let fty = tcx.mk_bare_fn(fty);\n+    debug!(\"trans_object_shim: fty={}\", fty.repr(tcx));\n+\n+    //\n+    let method_bare_fn_ty =\n+        ty::mk_bare_fn(tcx, None, fty);\n+    let function_name =\n+        link::mangle_internal_name_by_type_and_seq(ccx, method_bare_fn_ty, \"object_shim\");\n+    let llfn =\n+        decl_internal_rust_fn(ccx, method_bare_fn_ty, function_name.as_slice());\n+\n+    //\n+    let block_arena = TypedArena::new();\n+    let empty_substs = Substs::trans_empty();\n+    let fcx = new_fn_ctxt(ccx,\n+                          llfn,\n+                          ast::DUMMY_NODE_ID,\n+                          false,\n+                          fty.sig.0.output,\n+                          &empty_substs,\n+                          None,\n+                          &block_arena);\n+    let mut bcx = init_function(&fcx, false, fty.sig.0.output);\n+\n+    // the first argument (`self`) will be a trait object\n+    let llobject = get_param(fcx.llfn, fcx.arg_pos(0) as u32);\n+\n+    debug!(\"trans_object_shim: llobject={}\",\n+           bcx.val_to_string(llobject));\n+\n+    // the remaining arguments will be, well, whatever they are\n+    let llargs: Vec<_> =\n+        fty.sig.0.inputs[1..].iter()\n+        .enumerate()\n+        .map(|(i, _)| {\n+            let llarg = get_param(fcx.llfn, fcx.arg_pos(i+1) as u32);\n+            debug!(\"trans_object_shim: input #{} == {}\",\n+                   i, bcx.val_to_string(llarg));\n+            llarg\n+        })\n+        .collect();\n+    assert!(!fcx.needs_ret_allocas);\n+\n+    let dest =\n+        fcx.llretslotptr.get().map(\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, fty.sig.0.output, \"ret_slot\")));\n+\n+    let method_offset_in_vtable =\n+        traits::get_vtable_index_of_object_method(bcx.tcx(),\n+                                                  object_trait_ref.clone(),\n+                                                  trait_id,\n+                                                  method_offset_in_trait);\n+    debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n+           method_offset_in_vtable);\n+\n+    bcx = trans_call_inner(bcx,\n+                           None,\n+                           method_bare_fn_ty,\n+                           |bcx, _| trans_trait_callee_from_llval(bcx,\n+                                                                  method_bare_fn_ty,\n+                                                                  method_offset_in_vtable,\n+                                                                  llobject),\n+                           ArgVals(llargs.as_slice()),\n+                           dest).bcx;\n+\n+    finish_fn(&fcx, bcx, fty.sig.0.output);\n+\n+    llfn\n+}\n+\n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n ///\n@@ -560,6 +695,14 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let llfn = vec![trans_fn_pointer_shim(bcx.ccx(), bare_fn_ty)];\n                 llfn.into_iter()\n             }\n+            traits::VtableObject(ref data) => {\n+                // this would imply that the Self type being erased is\n+                // an object type; this cannot happen because we\n+                // cannot cast an unsized type into a trait object\n+                bcx.sess().bug(\n+                    format!(\"cannot get vtable for an object type: {}\",\n+                            data.repr(bcx.tcx())).as_slice());\n+            }\n             traits::VtableParam => {\n                 bcx.sess().bug(\n                     format!(\"resolved vtable for {} to bad vtable {} in trans\","}, {"sha": "1ef6c1140321846dc53f24970f355a5f0c57af51", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=dabd7507b66f5ca62bb6e1ab49a572fbb450d8dd", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use check::{FnCtxt, structurally_resolved_type};\n-use middle::subst::{FnSpace, SelfSpace};\n use middle::traits::{mod, ObjectSafetyViolation, MethodViolationCode};\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;"}]}