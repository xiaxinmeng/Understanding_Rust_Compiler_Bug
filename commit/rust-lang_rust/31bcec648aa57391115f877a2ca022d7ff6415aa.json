{"sha": "31bcec648aa57391115f877a2ca022d7ff6415aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYmNlYzY0OGFhNTczOTExMTVmODc3YTJjYTAyMmQ3ZmY2NDE1YWE=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2019-02-08T19:42:34Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2019-02-14T03:40:17Z"}, "message": "Add vectored read and write support\n\nThis functionality has lived for a while in the tokio ecosystem, where\nit can improve performance by minimizing copies.", "tree": {"sha": "2e9ba98a3146cb8eebf72d469a81615389edd4fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e9ba98a3146cb8eebf72d469a81615389edd4fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31bcec648aa57391115f877a2ca022d7ff6415aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31bcec648aa57391115f877a2ca022d7ff6415aa", "html_url": "https://github.com/rust-lang/rust/commit/31bcec648aa57391115f877a2ca022d7ff6415aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31bcec648aa57391115f877a2ca022d7ff6415aa/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4772dc8087b1d0f2bab6d064fd930e596c82d439", "url": "https://api.github.com/repos/rust-lang/rust/commits/4772dc8087b1d0f2bab6d064fd930e596c82d439", "html_url": "https://github.com/rust-lang/rust/commit/4772dc8087b1d0f2bab6d064fd930e596c82d439"}], "stats": {"total": 1125, "additions": 1033, "deletions": 92}, "files": [{"sha": "a5edc4360ca4b5554709a4a3e907897ec6beaf23", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -5,7 +5,7 @@ use io::prelude::*;\n use cmp;\n use error;\n use fmt;\n-use io::{self, Initializer, DEFAULT_BUF_SIZE, Error, ErrorKind, SeekFrom};\n+use io::{self, Initializer, DEFAULT_BUF_SIZE, Error, ErrorKind, SeekFrom, IoVec, IoVecMut};\n use memchr;\n \n /// The `BufReader` struct adds buffering to any reader.\n@@ -235,6 +235,19 @@ impl<R: Read> Read for BufReader<R> {\n         Ok(nread)\n     }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let total_len = bufs.iter().map(|b| b.as_slice().len()).sum::<usize>();\n+        if self.pos == self.cap && total_len >= self.buf.len() {\n+            return self.inner.read_vectored(bufs);\n+        }\n+        let nread = {\n+            let mut rem = self.fill_buf()?;\n+            rem.read_vectored(bufs)?\n+        };\n+        self.consume(nread);\n+        Ok(nread)\n+    }\n+\n     // we can't skip unconditionally because of the large buffer case in read.\n     unsafe fn initializer(&self) -> Initializer {\n         self.inner.initializer()\n@@ -577,9 +590,25 @@ impl<W: Write> Write for BufWriter<W> {\n             self.panicked = false;\n             r\n         } else {\n-            Write::write(&mut self.buf, buf)\n+            self.buf.write(buf)\n+        }\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let total_len = bufs.iter().map(|b| b.as_slice().len()).sum::<usize>();\n+        if self.buf.len() + total_len > self.buf.capacity() {\n+            self.flush_buf()?;\n+        }\n+        if total_len >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.inner.as_mut().unwrap().write_vectored(bufs);\n+            self.panicked = false;\n+            r\n+        } else {\n+            self.buf.write_vectored(bufs)\n         }\n     }\n+\n     fn flush(&mut self) -> io::Result<()> {\n         self.flush_buf().and_then(|()| self.get_mut().flush())\n     }"}, {"sha": "ef636cc6f8c69a0dd27f640181d5e6fa38e27014", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 212, "deletions": 5, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -2,7 +2,7 @@ use io::prelude::*;\n \n use core::convert::TryInto;\n use cmp;\n-use io::{self, Initializer, SeekFrom, Error, ErrorKind};\n+use io::{self, Initializer, SeekFrom, Error, ErrorKind, IoVec, IoVecMut};\n \n /// A `Cursor` wraps an in-memory buffer and provides it with a\n /// [`Seek`] implementation.\n@@ -221,6 +221,19 @@ impl<T> Read for Cursor<T> where T: AsRef<[u8]> {\n         Ok(n)\n     }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let mut nread = 0;\n+        for buf in bufs {\n+            let buf = buf.as_mut_slice();\n+            let n = self.read(buf)?;\n+            nread += n;\n+            if n < buf.len() {\n+                break;\n+            }\n+        }\n+        Ok(nread)\n+    }\n+\n     fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n         let n = buf.len();\n         Read::read_exact(&mut self.fill_buf()?, buf)?;\n@@ -251,6 +264,24 @@ fn slice_write(pos_mut: &mut u64, slice: &mut [u8], buf: &[u8]) -> io::Result<us\n     Ok(amt)\n }\n \n+fn slice_write_vectored(\n+    pos_mut: &mut u64,\n+    slice: &mut [u8],\n+    bufs: &[IoVec<'_>],\n+) -> io::Result<usize>\n+{\n+    let mut nwritten = 0;\n+    for buf in bufs {\n+        let buf = buf.as_slice();\n+        let n = slice_write(pos_mut, slice, buf)?;\n+        nwritten += n;\n+        if n < buf.len() {\n+            break;\n+        }\n+    }\n+    Ok(nwritten)\n+}\n+\n // Resizing write implementation\n fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usize> {\n     let pos: usize = (*pos_mut).try_into().map_err(|_| {\n@@ -278,12 +309,31 @@ fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usi\n     Ok(buf.len())\n }\n \n+fn vec_write_vectored(\n+    pos_mut: &mut u64,\n+    vec: &mut Vec<u8>,\n+    bufs: &[IoVec<'_>],\n+) -> io::Result<usize>\n+{\n+    let mut nwritten = 0;\n+    for buf in bufs {\n+        nwritten += vec_write(pos_mut, vec, buf.as_slice())?;\n+    }\n+    Ok(nwritten)\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for Cursor<&'a mut [u8]> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         slice_write(&mut self.pos, self.inner, buf)\n     }\n+\n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        slice_write_vectored(&mut self.pos, self.inner, bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n@@ -292,6 +342,11 @@ impl<'a> Write for Cursor<&'a mut Vec<u8>> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         vec_write(&mut self.pos, self.inner, buf)\n     }\n+\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        vec_write_vectored(&mut self.pos, self.inner, bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n@@ -300,6 +355,11 @@ impl Write for Cursor<Vec<u8>> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         vec_write(&mut self.pos, &mut self.inner, buf)\n     }\n+\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        vec_write_vectored(&mut self.pos, &mut self.inner, bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n@@ -309,21 +369,30 @@ impl Write for Cursor<Box<[u8]>> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         slice_write(&mut self.pos, &mut self.inner, buf)\n     }\n+\n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        slice_write_vectored(&mut self.pos, &mut self.inner, bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n #[cfg(test)]\n mod tests {\n     use io::prelude::*;\n-    use io::{Cursor, SeekFrom};\n+    use io::{Cursor, SeekFrom, IoVec, IoVecMut};\n \n     #[test]\n     fn test_vec_writer() {\n         let mut writer = Vec::new();\n         assert_eq!(writer.write(&[0]).unwrap(), 1);\n         assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n         assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.write_vectored(\n+            &[IoVec::new(&[]), IoVec::new(&[8, 9]), IoVec::new(&[10])],\n+        ).unwrap(), 3);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         assert_eq!(writer, b);\n     }\n \n@@ -333,7 +402,10 @@ mod tests {\n         assert_eq!(writer.write(&[0]).unwrap(), 1);\n         assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n         assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.write_vectored(\n+            &[IoVec::new(&[]), IoVec::new(&[8, 9]), IoVec::new(&[10])],\n+        ).unwrap(), 3);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         assert_eq!(&writer.get_ref()[..], b);\n     }\n \n@@ -344,7 +416,10 @@ mod tests {\n         assert_eq!(writer.write(&[0]).unwrap(), 1);\n         assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n         assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.write_vectored(\n+            &[IoVec::new(&[]), IoVec::new(&[8, 9]), IoVec::new(&[10])],\n+        ).unwrap(), 3);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         assert_eq!(&writer.get_ref()[..], b);\n     }\n \n@@ -366,6 +441,26 @@ mod tests {\n         assert_eq!(&**writer.get_ref(), b);\n     }\n \n+    #[test]\n+    fn test_box_slice_writer_vectored() {\n+        let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+        assert_eq!(writer.position(), 0);\n+        assert_eq!(writer.write_vectored(&[IoVec::new(&[0])]).unwrap(), 1);\n+        assert_eq!(writer.position(), 1);\n+        assert_eq!(\n+            writer.write_vectored(&[IoVec::new(&[1, 2, 3]), IoVec::new(&[4, 5, 6, 7])]).unwrap(),\n+            7,\n+        );\n+        assert_eq!(writer.position(), 8);\n+        assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n+        assert_eq!(writer.position(), 8);\n+\n+        assert_eq!(writer.write_vectored(&[IoVec::new(&[8, 9])]).unwrap(), 1);\n+        assert_eq!(writer.write_vectored(&[IoVec::new(&[10])]).unwrap(), 0);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n+        assert_eq!(&**writer.get_ref(), b);\n+    }\n+\n     #[test]\n     fn test_buf_writer() {\n         let mut buf = [0 as u8; 9];\n@@ -387,6 +482,31 @@ mod tests {\n         assert_eq!(buf, b);\n     }\n \n+    #[test]\n+    fn test_buf_writer_vectored() {\n+        let mut buf = [0 as u8; 9];\n+        {\n+            let mut writer = Cursor::new(&mut buf[..]);\n+            assert_eq!(writer.position(), 0);\n+            assert_eq!(writer.write_vectored(&[IoVec::new(&[0])]).unwrap(), 1);\n+            assert_eq!(writer.position(), 1);\n+            assert_eq!(\n+                writer.write_vectored(\n+                    &[IoVec::new(&[1, 2, 3]), IoVec::new(&[4, 5, 6, 7])],\n+                ).unwrap(),\n+                7,\n+            );\n+            assert_eq!(writer.position(), 8);\n+            assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n+            assert_eq!(writer.position(), 8);\n+\n+            assert_eq!(writer.write_vectored(&[IoVec::new(&[8, 9])]).unwrap(), 1);\n+            assert_eq!(writer.write_vectored(&[IoVec::new(&[10])]).unwrap(), 0);\n+        }\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n+        assert_eq!(buf, b);\n+    }\n+\n     #[test]\n     fn test_buf_writer_seek() {\n         let mut buf = [0 as u8; 8];\n@@ -447,6 +567,35 @@ mod tests {\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n+    #[test]\n+    fn test_mem_reader_vectored() {\n+        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n+        let mut buf = [];\n+        assert_eq!(reader.read_vectored(&mut [IoVecMut::new(&mut buf)]).unwrap(), 0);\n+        assert_eq!(reader.position(), 0);\n+        let mut buf = [0];\n+        assert_eq!(\n+            reader.read_vectored(&mut [IoVecMut::new(&mut []), IoVecMut::new(&mut buf)]).unwrap(),\n+            1,\n+        );\n+        assert_eq!(reader.position(), 1);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf, b);\n+        let mut buf1 = [0; 4];\n+        let mut buf2 = [0; 4];\n+        assert_eq!(\n+            reader.read_vectored(\n+                &mut [IoVecMut::new(&mut buf1), IoVecMut::new(&mut buf2)],\n+            ).unwrap(),\n+            7,\n+        );\n+        let b1: &[_] = &[1, 2, 3, 4];\n+        let b2: &[_] = &[5, 6, 7];\n+        assert_eq!(buf1, b1);\n+        assert_eq!(&buf2[..3], b2);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    }\n+\n     #[test]\n     fn test_boxed_slice_reader() {\n         let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n@@ -469,6 +618,35 @@ mod tests {\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n+    #[test]\n+    fn test_boxed_slice_reader_vectored() {\n+        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n+        let mut buf = [];\n+        assert_eq!(reader.read_vectored(&mut [IoVecMut::new(&mut buf)]).unwrap(), 0);\n+        assert_eq!(reader.position(), 0);\n+        let mut buf = [0];\n+        assert_eq!(\n+            reader.read_vectored(&mut [IoVecMut::new(&mut []), IoVecMut::new(&mut buf)]).unwrap(),\n+            1,\n+        );\n+        assert_eq!(reader.position(), 1);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf, b);\n+        let mut buf1 = [0; 4];\n+        let mut buf2 = [0; 4];\n+        assert_eq!(\n+            reader.read_vectored(\n+                &mut [IoVecMut::new(&mut buf1), IoVecMut::new(&mut buf2)],\n+            ).unwrap(),\n+            7,\n+        );\n+        let b1: &[_] = &[1, 2, 3, 4];\n+        let b2: &[_] = &[5, 6, 7];\n+        assert_eq!(buf1, b1);\n+        assert_eq!(&buf2[..3], b2);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    }\n+\n     #[test]\n     fn read_to_end() {\n         let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -499,6 +677,35 @@ mod tests {\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n+    #[test]\n+    fn test_slice_reader_vectored() {\n+        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n+        let reader = &mut &in_buf[..];\n+        let mut buf = [];\n+        assert_eq!(reader.read_vectored(&mut [IoVecMut::new(&mut buf)]).unwrap(), 0);\n+        let mut buf = [0];\n+        assert_eq!(\n+            reader.read_vectored(&mut [IoVecMut::new(&mut []), IoVecMut::new(&mut buf)]).unwrap(),\n+            1,\n+        );\n+        assert_eq!(reader.len(), 7);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf, b);\n+        let mut buf1 = [0; 4];\n+        let mut buf2 = [0; 4];\n+        assert_eq!(\n+            reader.read_vectored(\n+                &mut [IoVecMut::new(&mut buf1), IoVecMut::new(&mut buf2)],\n+            ).unwrap(),\n+            7,\n+        );\n+        let b1: &[_] = &[1, 2, 3, 4];\n+        let b2: &[_] = &[5, 6, 7];\n+        assert_eq!(buf1, b1);\n+        assert_eq!(&buf2[..3], b2);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    }\n+\n     #[test]\n     fn test_read_exact() {\n         let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];"}, {"sha": "4bba4af77c482171a23a15d4b0dc6eeef8c522fa", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,5 +1,6 @@\n use cmp;\n-use io::{self, SeekFrom, Read, Initializer, Write, Seek, BufRead, Error, ErrorKind};\n+use io::{self, SeekFrom, Read, Initializer, Write, Seek, BufRead, Error, ErrorKind, IoVecMut,\n+         IoVec};\n use fmt;\n use mem;\n \n@@ -13,6 +14,11 @@ impl<'a, R: Read + ?Sized> Read for &'a mut R {\n         (**self).read(buf)\n     }\n \n+    #[inline]\n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        (**self).read_vectored(bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         (**self).initializer()\n@@ -38,6 +44,11 @@ impl<'a, W: Write + ?Sized> Write for &'a mut W {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n \n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        (**self).write_vectored(bufs)\n+    }\n+\n     #[inline]\n     fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n \n@@ -82,6 +93,11 @@ impl<R: Read + ?Sized> Read for Box<R> {\n         (**self).read(buf)\n     }\n \n+    #[inline]\n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        (**self).read_vectored(bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         (**self).initializer()\n@@ -107,6 +123,11 @@ impl<W: Write + ?Sized> Write for Box<W> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n \n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        (**self).write_vectored(bufs)\n+    }\n+\n     #[inline]\n     fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n \n@@ -171,6 +192,19 @@ impl<'a> Read for &'a [u8] {\n         Ok(amt)\n     }\n \n+    #[inline]\n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let mut nread = 0;\n+        for buf in bufs {\n+            nread += self.read(buf.as_mut_slice())?;\n+            if self.is_empty() {\n+                break;\n+            }\n+        }\n+\n+        Ok(nread)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -231,6 +265,19 @@ impl<'a> Write for &'a mut [u8] {\n         Ok(amt)\n     }\n \n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let mut nwritten = 0;\n+        for buf in bufs {\n+            nwritten += self.write(buf.as_slice())?;\n+            if self.is_empty() {\n+                break;\n+            }\n+        }\n+\n+        Ok(nwritten)\n+    }\n+\n     #[inline]\n     fn write_all(&mut self, data: &[u8]) -> io::Result<()> {\n         if self.write(data)? == data.len() {\n@@ -254,6 +301,16 @@ impl Write for Vec<u8> {\n         Ok(buf.len())\n     }\n \n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let len = bufs.iter().map(|b| b.as_slice().len()).sum();\n+        self.reserve(len);\n+        for buf in bufs {\n+            self.extend_from_slice(buf.as_slice());\n+        }\n+        Ok(len)\n+    }\n+\n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n         self.extend_from_slice(buf);"}, {"sha": "b9765605f8e3b11baaf6ac6aecfc0d32f298000f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 123, "deletions": 1, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -265,6 +265,7 @@ use slice;\n use str;\n use memchr;\n use ptr;\n+use sys;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::buffered::{BufReader, BufWriter, LineWriter};\n@@ -520,6 +521,22 @@ pub trait Read {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n \n+    /// Like `read`, except that it reads into a slice of buffers.\n+    ///\n+    /// Data is copied to fill each buffer in order, with the final buffer\n+    /// written to possibly being only partially filled. This method must behave\n+    /// as a single call to `read` with the buffers concatenated would.\n+    ///\n+    /// The default implementation simply passes the first nonempty buffer to\n+    /// `read`.\n+    #[unstable(feature = \"iovec\", issue = \"0\")]\n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> Result<usize> {\n+        match bufs.iter_mut().map(|b| b.as_mut_slice()).find(|b| !b.is_empty()) {\n+            Some(buf) => self.read(buf),\n+            None => Ok(0),\n+        }\n+    }\n+\n     /// Determines if this `Read`er can work with buffers of uninitialized\n     /// memory.\n     ///\n@@ -867,6 +884,85 @@ pub trait Read {\n     }\n }\n \n+/// A buffer type used with `Read::read_vectored`.\n+///\n+/// It is semantically a wrapper around an `&mut [u8]`, but is guaranteed to be\n+/// ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on\n+/// Windows.\n+#[unstable(feature = \"iovec\", issue = \"0\")]\n+#[repr(transparent)]\n+pub struct IoVecMut<'a>(sys::io::IoVecMut<'a>);\n+\n+#[unstable(feature = \"iovec\", issue = \"0\")]\n+impl<'a> fmt::Debug for IoVecMut<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.as_slice(), fmt)\n+    }\n+}\n+\n+impl<'a> IoVecMut<'a> {\n+    /// Creates a new `IoVecMut` wrapping a byte slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics on Windows if the slice is larger than 4GB.\n+    #[unstable(feature = \"iovec\", issue = \"0\")]\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut(sys::io::IoVecMut::new(buf))\n+    }\n+\n+    /// Returns a shared reference to the inner slice.\n+    #[unstable(feature = \"iovec\", issue = \"0\")]\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        self.0.as_slice()\n+    }\n+\n+    /// Returns a mutable reference to the inner slice.\n+    #[unstable(feature = \"iovec\", issue = \"0\")]\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &'a mut [u8] {\n+        self.0.as_mut_slice()\n+    }\n+}\n+\n+/// A buffer type used with `Write::write_vectored`.\n+///\n+/// It is semantically a wrapper around an `&[u8]`, but is guaranteed to be\n+/// ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on\n+/// Windows.\n+#[unstable(feature = \"iovec\", issue = \"0\")]\n+#[repr(transparent)]\n+pub struct IoVec<'a>(sys::io::IoVec<'a>);\n+\n+#[unstable(feature = \"iovec\", issue = \"0\")]\n+impl<'a> fmt::Debug for IoVec<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.as_slice(), fmt)\n+    }\n+}\n+\n+impl<'a> IoVec<'a> {\n+    /// Creates a new `IoVec` wrapping a byte slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics on Windows if the slice is larger than 4GB.\n+    #[unstable(feature = \"iovec\", issue = \"0\")]\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec(sys::io::IoVec::new(buf))\n+    }\n+\n+    /// Returns a shared reference to the inner slice.\n+    #[unstable(feature = \"iovec\", issue = \"0\")]\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        self.0.as_slice()\n+    }\n+}\n+\n /// A type used to conditionally initialize buffers passed to `Read` methods.\n #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n #[derive(Debug)]\n@@ -997,6 +1093,22 @@ pub trait Write {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, buf: &[u8]) -> Result<usize>;\n \n+    /// Like `write`, except that it writes from a slice of buffers.\n+    ///\n+    /// Data is copied to from each buffer in order, with the final buffer\n+    /// read from possibly being only partially consumed. This method must\n+    /// behave as a call to `write` with the buffers concatenated would.\n+    ///\n+    /// The default implementation simply passes the first nonempty buffer to\n+    /// `write`.\n+    #[unstable(feature = \"iovec\", issue = \"0\")]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> Result<usize> {\n+        match bufs.iter().map(|b| b.as_slice()).find(|b| !b.is_empty()) {\n+            Some(buf) => self.write(buf),\n+            None => Ok(0),\n+        }\n+    }\n+\n     /// Flush this output stream, ensuring that all intermediately buffered\n     /// contents reach their destination.\n     ///\n@@ -1691,13 +1803,23 @@ impl<T: Read, U: Read> Read for Chain<T, U> {\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n         if !self.done_first {\n             match self.first.read(buf)? {\n-                0 if buf.len() != 0 => { self.done_first = true; }\n+                0 if buf.len() != 0 => self.done_first = true,\n                 n => return Ok(n),\n             }\n         }\n         self.second.read(buf)\n     }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> Result<usize> {\n+        if !self.done_first {\n+            match self.first.read_vectored(bufs)? {\n+                0 if bufs.iter().any(|b| !b.as_slice().is_empty()) => self.done_first = true,\n+                n => return Ok(n),\n+            }\n+        }\n+        self.second.read_vectored(bufs)\n+    }\n+\n     unsafe fn initializer(&self) -> Initializer {\n         let initializer = self.first.initializer();\n         if initializer.should_initialize() {"}, {"sha": "6743018793fb6cb3218ddd52c7a94c693dfa12c5", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,7 +1,7 @@\n #![allow(missing_copy_implementations)]\n \n use fmt;\n-use io::{self, Read, Initializer, Write, ErrorKind, BufRead};\n+use io::{self, Read, Initializer, Write, ErrorKind, BufRead, IoVec, IoVecMut};\n use mem;\n \n /// Copies the entire contents of a reader into a writer.\n@@ -152,6 +152,15 @@ impl Read for Repeat {\n         Ok(buf.len())\n     }\n \n+    #[inline]\n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let mut nwritten = 0;\n+        for buf in bufs {\n+            nwritten += self.read(buf.as_mut_slice())?;\n+        }\n+        Ok(nwritten)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -195,6 +204,13 @@ pub fn sink() -> Sink { Sink { _priv: () } }\n impl Write for Sink {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n+\n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let total_len = bufs.iter().map(|b| b.as_slice().len()).sum();\n+        Ok(total_len)\n+    }\n+\n     #[inline]\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }"}, {"sha": "ebfe0b0de9ec99db43764ea789d092276677cdcf", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -228,6 +228,7 @@\n #![feature(arbitrary_self_types)]\n #![feature(array_error_internals)]\n #![feature(asm)]\n+#![feature(bind_by_move_pattern_guards)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n #![feature(cfg_target_has_atomic)]"}, {"sha": "d8a9d80cdbf781e8cc1c98279d28cffba2faff67", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,7 +1,7 @@\n use io::prelude::*;\n \n use fmt;\n-use io::{self, Initializer};\n+use io::{self, Initializer, IoVec, IoVecMut};\n use net::{ToSocketAddrs, SocketAddr, Shutdown};\n use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner, IntoInner};\n@@ -569,6 +569,10 @@ impl TcpStream {\n impl Read for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -577,12 +581,21 @@ impl Read for TcpStream {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for TcpStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Read for &'a TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -591,6 +604,11 @@ impl<'a> Read for &'a TcpStream {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for &'a TcpStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n@@ -911,7 +929,7 @@ impl fmt::Debug for TcpListener {\n \n #[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n mod tests {\n-    use io::ErrorKind;\n+    use io::{ErrorKind, IoVec, IoVecMut};\n     use io::prelude::*;\n     use net::*;\n     use net::test::{next_test_ip4, next_test_ip6};\n@@ -1184,6 +1202,53 @@ mod tests {\n         })\n     }\n \n+    #[test]\n+    fn read_vectored() {\n+        each_ip(&mut |addr| {\n+            let srv = t!(TcpListener::bind(&addr));\n+            let mut s1 = t!(TcpStream::connect(&addr));\n+            let mut s2 = t!(srv.accept()).0;\n+\n+            let len = s1.write(&[10, 11, 12]).unwrap();\n+            assert_eq!(len, 3);\n+\n+            let mut a = [];\n+            let mut b = [0];\n+            let mut c = [0; 3];\n+            let len = t!(s2.read_vectored(\n+                &mut [IoVecMut::new(&mut a), IoVecMut::new(&mut b), IoVecMut::new(&mut c)],\n+            ));\n+            assert!(len > 0);\n+            assert_eq!(b, [10]);\n+            // some implementations don't support readv, so we may only fill the first buffer\n+            assert!(len == 1 || c == [11, 12, 0]);\n+        })\n+    }\n+\n+    #[test]\n+    fn write_vectored() {\n+        each_ip(&mut |addr| {\n+            let srv = t!(TcpListener::bind(&addr));\n+            let mut s1 = t!(TcpStream::connect(&addr));\n+            let mut s2 = t!(srv.accept()).0;\n+\n+            let a = [];\n+            let b = [10];\n+            let c = [11, 12];\n+            t!(s1.write_vectored(&[IoVec::new(&a), IoVec::new(&b), IoVec::new(&c)]));\n+\n+            let mut buf = [0; 4];\n+            let len = t!(s2.read(&mut buf));\n+            // some implementations don't support writev, so we may only write the first buffer\n+            if len == 1 {\n+                assert_eq!(buf, [10, 0, 0, 0]);\n+            } else {\n+                assert_eq!(len, 3);\n+                assert_eq!(buf, [10, 11, 12, 0]);\n+            }\n+        })\n+    }\n+\n     #[test]\n     fn double_bind() {\n         each_ip(&mut |addr| {"}, {"sha": "9ee5788c58009c52d0a47f8e404cdf5aa7c27bb0", "filename": "src/libstd/sys/cloudabi/io.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fcloudabi%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fcloudabi%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fio.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -0,0 +1,32 @@\n+pub struct IoVec<'a>(&'a [u8]);\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        self.0\n+    }\n+}\n+\n+pub struct IoVecMut<'a>(&'a mut [u8]);\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &'a mut [u8] {\n+        self.0\n+    }\n+}"}, {"sha": "d9bc21861c90da0c74391637aa174d81a6053fd6", "filename": "src/libstd/sys/cloudabi/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,4 +1,3 @@\n-use io;\n use libc;\n use mem;\n \n@@ -10,6 +9,7 @@ pub mod backtrace;\n #[path = \"../unix/cmath.rs\"]\n pub mod cmath;\n pub mod condvar;\n+pub mod io;\n #[path = \"../unix/memchr.rs\"]\n pub mod memchr;\n pub mod mutex;\n@@ -32,24 +32,24 @@ pub use self::shims::*;\n #[allow(dead_code)]\n pub fn init() {}\n \n-pub fn decode_error_kind(errno: i32) -> io::ErrorKind {\n+pub fn decode_error_kind(errno: i32) -> ::io::ErrorKind {\n     match errno {\n-        x if x == abi::errno::ACCES as i32 => io::ErrorKind::PermissionDenied,\n-        x if x == abi::errno::ADDRINUSE as i32 => io::ErrorKind::AddrInUse,\n-        x if x == abi::errno::ADDRNOTAVAIL as i32 => io::ErrorKind::AddrNotAvailable,\n-        x if x == abi::errno::AGAIN as i32 => io::ErrorKind::WouldBlock,\n-        x if x == abi::errno::CONNABORTED as i32 => io::ErrorKind::ConnectionAborted,\n-        x if x == abi::errno::CONNREFUSED as i32 => io::ErrorKind::ConnectionRefused,\n-        x if x == abi::errno::CONNRESET as i32 => io::ErrorKind::ConnectionReset,\n-        x if x == abi::errno::EXIST as i32 => io::ErrorKind::AlreadyExists,\n-        x if x == abi::errno::INTR as i32 => io::ErrorKind::Interrupted,\n-        x if x == abi::errno::INVAL as i32 => io::ErrorKind::InvalidInput,\n-        x if x == abi::errno::NOENT as i32 => io::ErrorKind::NotFound,\n-        x if x == abi::errno::NOTCONN as i32 => io::ErrorKind::NotConnected,\n-        x if x == abi::errno::PERM as i32 => io::ErrorKind::PermissionDenied,\n-        x if x == abi::errno::PIPE as i32 => io::ErrorKind::BrokenPipe,\n-        x if x == abi::errno::TIMEDOUT as i32 => io::ErrorKind::TimedOut,\n-        _ => io::ErrorKind::Other,\n+        x if x == abi::errno::ACCES as i32 => ::io::ErrorKind::PermissionDenied,\n+        x if x == abi::errno::ADDRINUSE as i32 => ::io::ErrorKind::AddrInUse,\n+        x if x == abi::errno::ADDRNOTAVAIL as i32 => ::io::ErrorKind::AddrNotAvailable,\n+        x if x == abi::errno::AGAIN as i32 => ::io::ErrorKind::WouldBlock,\n+        x if x == abi::errno::CONNABORTED as i32 => ::io::ErrorKind::ConnectionAborted,\n+        x if x == abi::errno::CONNREFUSED as i32 => ::io::ErrorKind::ConnectionRefused,\n+        x if x == abi::errno::CONNRESET as i32 => ::io::ErrorKind::ConnectionReset,\n+        x if x == abi::errno::EXIST as i32 => ::io::ErrorKind::AlreadyExists,\n+        x if x == abi::errno::INTR as i32 => ::io::ErrorKind::Interrupted,\n+        x if x == abi::errno::INVAL as i32 => ::io::ErrorKind::InvalidInput,\n+        x if x == abi::errno::NOENT as i32 => ::io::ErrorKind::NotFound,\n+        x if x == abi::errno::NOTCONN as i32 => ::io::ErrorKind::NotConnected,\n+        x if x == abi::errno::PERM as i32 => ::io::ErrorKind::PermissionDenied,\n+        x if x == abi::errno::PIPE as i32 => ::io::ErrorKind::BrokenPipe,\n+        x if x == abi::errno::TIMEDOUT as i32 => ::io::ErrorKind::TimedOut,\n+        _ => ::io::ErrorKind::Other,\n     }\n }\n "}, {"sha": "9ee5788c58009c52d0a47f8e404cdf5aa7c27bb0", "filename": "src/libstd/sys/redox/io.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fredox%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fredox%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fio.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -0,0 +1,32 @@\n+pub struct IoVec<'a>(&'a [u8]);\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        self.0\n+    }\n+}\n+\n+pub struct IoVecMut<'a>(&'a mut [u8]);\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &'a mut [u8] {\n+        self.0\n+    }\n+}"}, {"sha": "c3878349bb329c6ab1cc519f87626f8972fe3cbf", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,6 +1,6 @@\n #![allow(dead_code, missing_docs, nonstandard_style)]\n \n-use io::{self, ErrorKind};\n+use ::io::{ErrorKind};\n \n pub use libc::strlen;\n pub use self::rand::hashmap_random_keys;\n@@ -17,6 +17,7 @@ pub mod ext;\n pub mod fast_thread_local;\n pub mod fd;\n pub mod fs;\n+pub mod io;\n pub mod memchr;\n pub mod mutex;\n pub mod net;\n@@ -63,8 +64,8 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     }\n }\n \n-pub fn cvt(result: Result<usize, syscall::Error>) -> io::Result<usize> {\n-    result.map_err(|err| io::Error::from_raw_os_error(err.errno))\n+pub fn cvt(result: Result<usize, syscall::Error>) -> ::io::Result<usize> {\n+    result.map_err(|err| ::io::Error::from_raw_os_error(err.errno))\n }\n \n #[doc(hidden)]\n@@ -82,9 +83,9 @@ macro_rules! impl_is_minus_one {\n \n impl_is_minus_one! { i8 i16 i32 i64 isize }\n \n-pub fn cvt_libc<T: IsMinusOne>(t: T) -> io::Result<T> {\n+pub fn cvt_libc<T: IsMinusOne>(t: T) -> ::io::Result<T> {\n     if t.is_minus_one() {\n-        Err(io::Error::last_os_error())\n+        Err(::io::Error::last_os_error())\n     } else {\n         Ok(t)\n     }"}, {"sha": "08e12dc1ab1006e8de572e89e8ad0fba0ff75719", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,5 +1,5 @@\n use cmp;\n-use io::{self, Error, ErrorKind, Result};\n+use io::{self, Error, ErrorKind, Result, IoVec, IoVecMut};\n use mem;\n use net::{SocketAddr, Shutdown};\n use path::Path;\n@@ -34,10 +34,24 @@ impl TcpStream {\n         self.0.read(buf)\n     }\n \n+    pub fn read_vectored(&self, buf: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        match buf.iter_mut().map(|b| b.as_mut_slice()).find(|b| !b.is_empty()) {\n+            Some(buf) => self.read(buf),\n+            None => Ok(0),\n+        }\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> Result<usize> {\n         self.0.write(buf)\n     }\n \n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        match buf.iter().map(|b| b.as_slice()).find(|b| !b.is_empty()) {\n+            Some(buf) => self.write(buf),\n+            None => Ok(0),\n+        }\n+    }\n+\n     pub fn take_error(&self) -> Result<Option<Error>> {\n         Ok(None)\n     }"}, {"sha": "9ee5788c58009c52d0a47f8e404cdf5aa7c27bb0", "filename": "src/libstd/sys/sgx/io.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fsgx%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fsgx%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fio.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -0,0 +1,32 @@\n+pub struct IoVec<'a>(&'a [u8]);\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        self.0\n+    }\n+}\n+\n+pub struct IoVecMut<'a>(&'a mut [u8]);\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &'a mut [u8] {\n+        self.0\n+    }\n+}"}, {"sha": "403dd61187fc3146ff308e158a29d6f2f385677f", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -3,7 +3,6 @@\n //! This module contains the facade (aka platform-specific) implementations of\n //! OS level functionality for Fortanix SGX.\n \n-use io;\n use os::raw::c_char;\n use sync::atomic::{AtomicBool, Ordering};\n \n@@ -20,6 +19,7 @@ pub mod env;\n pub mod ext;\n pub mod fd;\n pub mod fs;\n+pub mod io;\n pub mod memchr;\n pub mod mutex;\n pub mod net;\n@@ -41,12 +41,12 @@ pub fn init() {\n \n /// This function is used to implement functionality that simply doesn't exist.\n /// Programs relying on this functionality will need to deal with the error.\n-pub fn unsupported<T>() -> io::Result<T> {\n+pub fn unsupported<T>() -> ::io::Result<T> {\n     Err(unsupported_err())\n }\n \n-pub fn unsupported_err() -> io::Error {\n-    io::Error::new(io::ErrorKind::Other,\n+pub fn unsupported_err() -> ::io::Error {\n+    ::io::Error::new(::io::ErrorKind::Other,\n                    \"operation not supported on SGX yet\")\n }\n \n@@ -55,58 +55,58 @@ pub fn unsupported_err() -> io::Error {\n /// returned, the program might very well be able to function normally. This is\n /// what happens when `SGX_INEFFECTIVE_ERROR` is set to `true`. If it is\n /// `false`, the behavior is the same as `unsupported`.\n-pub fn sgx_ineffective<T>(v: T) -> io::Result<T> {\n+pub fn sgx_ineffective<T>(v: T) -> ::io::Result<T> {\n     static SGX_INEFFECTIVE_ERROR: AtomicBool = AtomicBool::new(false);\n     if SGX_INEFFECTIVE_ERROR.load(Ordering::Relaxed) {\n-        Err(io::Error::new(io::ErrorKind::Other,\n+        Err(::io::Error::new(::io::ErrorKind::Other,\n                        \"operation can't be trusted to have any effect on SGX\"))\n     } else {\n         Ok(v)\n     }\n }\n \n-pub fn decode_error_kind(code: i32) -> io::ErrorKind {\n+pub fn decode_error_kind(code: i32) -> ::io::ErrorKind {\n     use fortanix_sgx_abi::Error;\n \n     // FIXME: not sure how to make sure all variants of Error are covered\n     if code == Error::NotFound as _ {\n-        io::ErrorKind::NotFound\n+        ::io::ErrorKind::NotFound\n     } else if code == Error::PermissionDenied as _ {\n-        io::ErrorKind::PermissionDenied\n+        ::io::ErrorKind::PermissionDenied\n     } else if code == Error::ConnectionRefused as _ {\n-        io::ErrorKind::ConnectionRefused\n+        ::io::ErrorKind::ConnectionRefused\n     } else if code == Error::ConnectionReset as _ {\n-        io::ErrorKind::ConnectionReset\n+        ::io::ErrorKind::ConnectionReset\n     } else if code == Error::ConnectionAborted as _ {\n-        io::ErrorKind::ConnectionAborted\n+        ::io::ErrorKind::ConnectionAborted\n     } else if code == Error::NotConnected as _ {\n-        io::ErrorKind::NotConnected\n+        ::io::ErrorKind::NotConnected\n     } else if code == Error::AddrInUse as _ {\n-        io::ErrorKind::AddrInUse\n+        ::io::ErrorKind::AddrInUse\n     } else if code == Error::AddrNotAvailable as _ {\n-        io::ErrorKind::AddrNotAvailable\n+        ::io::ErrorKind::AddrNotAvailable\n     } else if code == Error::BrokenPipe as _ {\n-        io::ErrorKind::BrokenPipe\n+        ::io::ErrorKind::BrokenPipe\n     } else if code == Error::AlreadyExists as _ {\n-        io::ErrorKind::AlreadyExists\n+        ::io::ErrorKind::AlreadyExists\n     } else if code == Error::WouldBlock as _ {\n-        io::ErrorKind::WouldBlock\n+        ::io::ErrorKind::WouldBlock\n     } else if code == Error::InvalidInput as _ {\n-        io::ErrorKind::InvalidInput\n+        ::io::ErrorKind::InvalidInput\n     } else if code == Error::InvalidData as _ {\n-        io::ErrorKind::InvalidData\n+        ::io::ErrorKind::InvalidData\n     } else if code == Error::TimedOut as _ {\n-        io::ErrorKind::TimedOut\n+        ::io::ErrorKind::TimedOut\n     } else if code == Error::WriteZero as _ {\n-        io::ErrorKind::WriteZero\n+        ::io::ErrorKind::WriteZero\n     } else if code == Error::Interrupted as _ {\n-        io::ErrorKind::Interrupted\n+        ::io::ErrorKind::Interrupted\n     } else if code == Error::Other as _ {\n-        io::ErrorKind::Other\n+        ::io::ErrorKind::Other\n     } else if code == Error::UnexpectedEof as _ {\n-        io::ErrorKind::UnexpectedEof\n+        ::io::ErrorKind::UnexpectedEof\n     } else {\n-        io::ErrorKind::Other\n+        ::io::ErrorKind::Other\n     }\n }\n "}, {"sha": "2ecae1d746f74319dd198531e4c28f3a793f3f65", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -103,10 +103,26 @@ impl TcpStream {\n         self.inner.inner.read(buf)\n     }\n \n+    pub fn read_vectored(&self, buf: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let buf = match buf.get(0) {\n+            Some(buf) => buf.as_mut_slice(),\n+            None => return Ok(0),\n+        };\n+        self.read(buf)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.inner.write(buf)\n     }\n \n+    pub fn write_vectored(&self, buf: &[IoVec<'_>]) -> io::Result<usize> {\n+        let buf = match buf.get(0) {\n+            Some(buf) => buf.as_slice(),\n+            None => return Ok(0),\n+        };\n+        self.read(buf)\n+    }\n+\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         addr_to_sockaddr(&self.peer_addr)\n     }"}, {"sha": "4b60ea654c1f19d49bbce92cb1dc3ab663d0e44a", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -18,7 +18,7 @@ mod libc {\n use ascii;\n use ffi::OsStr;\n use fmt;\n-use io::{self, Initializer};\n+use io::{self, Initializer, IoVec, IoVecMut};\n use mem;\n use net::{self, Shutdown};\n use os::unix::ffi::OsStrExt;\n@@ -551,6 +551,10 @@ impl io::Read for UnixStream {\n         io::Read::read(&mut &*self, buf)\n     }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        io::Read::read_vectored(&mut &*self, bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -563,6 +567,10 @@ impl<'a> io::Read for &'a UnixStream {\n         self.0.read(buf)\n     }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -575,6 +583,10 @@ impl io::Write for UnixStream {\n         io::Write::write(&mut &*self, buf)\n     }\n \n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        io::Write::write_vectored(&mut &*self, bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> {\n         io::Write::flush(&mut &*self)\n     }\n@@ -586,6 +598,10 @@ impl<'a> io::Write for &'a UnixStream {\n         self.0.write(buf)\n     }\n \n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> {\n         Ok(())\n     }\n@@ -1510,6 +1526,25 @@ mod test {\n         thread.join().unwrap();\n     }\n \n+    #[test]\n+    fn vectored() {\n+        let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n+\n+        let len = or_panic!(s1.write_vectored(\n+            &[IoVec::new(b\"hello\"), IoVec::new(b\" \"), IoVec::new(b\"world!\")],\n+        ));\n+        assert_eq!(len, 12);\n+\n+        let mut buf1 = [0; 6];\n+        let mut buf2 = [0; 7];\n+        let len = or_panic!(s2.read_vectored(\n+            &mut [IoVecMut::new(&mut buf1), IoVecMut::new(&mut buf2)],\n+        ));\n+        assert_eq!(len, 12);\n+        assert_eq!(&buf1, b\"hello \");\n+        assert_eq!(&buf2, b\"world!\\0\");\n+    }\n+\n     #[test]\n     fn pair() {\n         let msg1 = b\"hello\";"}, {"sha": "6946b7b5dfa48e9ff4c567670eb2fa3d271e6635", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,7 +1,7 @@\n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n use cmp;\n-use io::{self, Read, Initializer};\n+use io::{self, Read, Initializer, IoVec, IoVecMut};\n use libc::{self, c_int, c_void, ssize_t};\n use mem;\n use sync::atomic::{AtomicBool, Ordering};\n@@ -52,6 +52,15 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::readv(self.fd,\n+                        bufs.as_ptr() as *const libc::iovec,\n+                        cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         let mut me = self;\n         (&mut me).read_to_end(buf)\n@@ -105,6 +114,15 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::writev(self.fd,\n+                         bufs.as_ptr() as *const libc::iovec,\n+                         cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n         #[cfg(target_os = \"android\")]\n         use super::android::cvt_pwrite64;"}, {"sha": "69b2db82ea3ae2eecb9db9857d4525903a3a2d6d", "filename": "src/libstd/sys/unix/io.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fio.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -0,0 +1,61 @@\n+use marker::PhantomData;\n+use libc::{iovec, c_void};\n+use slice;\n+\n+#[repr(transparent)]\n+pub struct IoVec<'a> {\n+    vec: iovec,\n+    _p: PhantomData<&'a [u8]>,\n+}\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec {\n+            vec: iovec {\n+                iov_base: buf.as_ptr() as *mut u8 as *mut c_void,\n+                iov_len: buf.len()\n+            },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        unsafe {\n+            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n+        }\n+    }\n+}\n+\n+pub struct IoVecMut<'a> {\n+    vec: iovec,\n+    _p: PhantomData<&'a mut [u8]>,\n+}\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut {\n+            vec: iovec {\n+                iov_base: buf.as_mut_ptr() as *mut c_void,\n+                iov_len: buf.len()\n+            },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        unsafe {\n+            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &'a mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len)\n+        }\n+    }\n+}"}, {"sha": "4775e29fb570919c817818b6d64b34677808de52", "filename": "src/libstd/sys/unix/l4re.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -5,7 +5,7 @@ macro_rules! unimpl {\n pub mod net {\n     #![allow(warnings)]\n     use fmt;\n-    use io;\n+    use io::{self, IoVec, IoVecMut};\n     use libc;\n     use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n     use sys_common::{AsInner, FromInner, IntoInner};\n@@ -46,6 +46,10 @@ pub mod net {\n             unimpl!();\n         }\n \n+        pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n         pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n             unimpl!();\n         }\n@@ -62,6 +66,10 @@ pub mod net {\n             unimpl!();\n         }\n \n+        pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n         pub fn set_timeout(&self, _: Option<Duration>, _: libc::c_int) -> io::Result<()> {\n             unimpl!();\n         }\n@@ -144,10 +152,18 @@ pub mod net {\n             unimpl!();\n         }\n \n+        pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n         pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n             unimpl!();\n         }\n \n+        pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n         pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n             unimpl!();\n         }"}, {"sha": "0de1a223fbd12a478a6ea4fe3459c5fa1b94dcd7", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,6 +1,6 @@\n #![allow(missing_docs, nonstandard_style)]\n \n-use io::{self, ErrorKind};\n+use io::ErrorKind;\n use libc;\n \n #[cfg(any(rustdoc, target_os = \"linux\"))] pub use os::linux as platform;\n@@ -39,6 +39,7 @@ pub mod fast_thread_local;\n pub mod fd;\n pub mod fs;\n pub mod memchr;\n+pub mod io;\n pub mod mutex;\n #[cfg(not(target_os = \"l4re\"))]\n pub mod net;\n@@ -126,15 +127,15 @@ macro_rules! impl_is_minus_one {\n \n impl_is_minus_one! { i8 i16 i32 i64 isize }\n \n-pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n+pub fn cvt<T: IsMinusOne>(t: T) -> ::io::Result<T> {\n     if t.is_minus_one() {\n-        Err(io::Error::last_os_error())\n+        Err(::io::Error::last_os_error())\n     } else {\n         Ok(t)\n     }\n }\n \n-pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n+pub fn cvt_r<T, F>(mut f: F) -> ::io::Result<T>\n     where T: IsMinusOne,\n           F: FnMut() -> T\n {"}, {"sha": "521d9b425179b438b426e03b89a3e2e4d4b5f90d", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,5 +1,5 @@\n use ffi::CStr;\n-use io;\n+use io::{self, IoVec, IoVecMut};\n use libc::{self, c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n use mem;\n use net::{SocketAddr, Shutdown};\n@@ -241,6 +241,10 @@ impl Socket {\n         self.recv_with_flags(buf, MSG_PEEK)\n     }\n \n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n     fn recv_from_with_flags(&self, buf: &mut [u8], flags: c_int)\n                             -> io::Result<(usize, SocketAddr)> {\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n@@ -269,6 +273,10 @@ impl Socket {\n         self.0.write(buf)\n     }\n \n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n     pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n         let timeout = match dur {\n             Some(dur) => {"}, {"sha": "9ee5788c58009c52d0a47f8e404cdf5aa7c27bb0", "filename": "src/libstd/sys/wasm/io.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwasm%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwasm%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fio.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -0,0 +1,32 @@\n+pub struct IoVec<'a>(&'a [u8]);\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        self.0\n+    }\n+}\n+\n+pub struct IoVecMut<'a>(&'a mut [u8]);\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &'a mut [u8] {\n+        self.0\n+    }\n+}"}, {"sha": "e71c6bcd7fe76dc447a5813d09f88f7aa36349f3", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -14,7 +14,6 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n-use io;\n use os::raw::c_char;\n use ptr;\n use sys::os_str::Buf;\n@@ -29,6 +28,7 @@ pub mod backtrace;\n pub mod cmath;\n pub mod env;\n pub mod fs;\n+pub mod io;\n pub mod memchr;\n pub mod net;\n pub mod os;\n@@ -63,17 +63,17 @@ cfg_if! {\n pub fn init() {\n }\n \n-pub fn unsupported<T>() -> io::Result<T> {\n+pub fn unsupported<T>() -> ::io::Result<T> {\n     Err(unsupported_err())\n }\n \n-pub fn unsupported_err() -> io::Error {\n-    io::Error::new(io::ErrorKind::Other,\n+pub fn unsupported_err() -> ::io::Error {\n+    ::io::Error::new(::io::ErrorKind::Other,\n                    \"operation not supported on wasm yet\")\n }\n \n-pub fn decode_error_kind(_code: i32) -> io::ErrorKind {\n-    io::ErrorKind::Other\n+pub fn decode_error_kind(_code: i32) -> ::io::ErrorKind {\n+    ::io::ErrorKind::Other\n }\n \n // This enum is used as the storage for a bunch of types which can't actually"}, {"sha": "d9f5d538432055d59c086479e6e555469e7a8edd", "filename": "src/libstd/sys/wasm/net.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,5 +1,5 @@\n use fmt;\n-use io;\n+use io::{self, IoVec, IoVecMut};\n use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n use time::Duration;\n use sys::{unsupported, Void};\n@@ -40,10 +40,18 @@ impl TcpStream {\n         match self.0 {}\n     }\n \n+    pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n     pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n         match self.0 {}\n     }\n \n+    pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         match self.0 {}\n     }"}, {"sha": "a78b599204b200ddeddecd41c52c9af0ca6065d8", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -57,6 +57,9 @@ pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\n pub type LPSTR = *mut CHAR;\n pub type LPWSTR = *mut WCHAR;\n pub type LPFILETIME = *mut FILETIME;\n+pub type LPWSABUF = *mut WSABUF;\n+pub type LPWSAOVERLAPPED = *mut c_void;\n+pub type LPWSAOVERLAPPED_COMPLETION_ROUTINE = *mut c_void;\n \n pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n pub type PLARGE_INTEGER = *mut c_longlong;\n@@ -324,6 +327,12 @@ pub struct WSADATA {\n     pub szSystemStatus: [u8; WSASYS_STATUS_LEN + 1],\n }\n \n+#[repr(C)]\n+pub struct WSABUF {\n+    pub len: ULONG,\n+    pub buf: *mut CHAR,\n+}\n+\n #[repr(C)]\n pub struct WSAPROTOCOL_INFO {\n     pub dwServiceFlags1: DWORD,\n@@ -988,6 +997,22 @@ extern \"system\" {\n                                dwProcessId: DWORD,\n                                lpProtocolInfo: LPWSAPROTOCOL_INFO)\n                                -> c_int;\n+    pub fn WSASend(s: SOCKET,\n+                   lpBuffers: LPWSABUF,\n+                   dwBufferCount: DWORD,\n+                   lpNumberOfBytesSent: LPDWORD,\n+                   dwFlags: DWORD,\n+                   lpOverlapped: LPWSAOVERLAPPED,\n+                   lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE)\n+                   -> c_int;\n+    pub fn WSARecv(s: SOCKET,\n+                   lpBuffers: LPWSABUF,\n+                   dwBufferCount: DWORD,\n+                   lpNumberOfBytesRecvd: LPDWORD,\n+                   lpFlags: LPDWORD,\n+                   lpOverlapped: LPWSAOVERLAPPED,\n+                   lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE)\n+                   -> c_int;\n     pub fn GetCurrentProcessId() -> DWORD;\n     pub fn WSASocketW(af: c_int,\n                       kind: c_int,"}, {"sha": "a14bfea9a2176b2950bb8d97c795f6dc98f98799", "filename": "src/libstd/sys/windows/io.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -0,0 +1,63 @@\n+use marker::PhantomData;\n+use slice;\n+use sys::c;\n+\n+#[repr(transparent)]\n+pub struct IoVec<'a> {\n+    vec: c::WSABUF,\n+    _p: PhantomData<&'a [u8]>,\n+}\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        assert!(buf.len() <= c::ULONG::max_value() as usize);\n+        IoVec {\n+            vec: c::WSABUF {\n+                len: buf.len() as c::ULONG,\n+                buf: buf.as_ptr() as *mut u8 as *mut c::CHAR,\n+            },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        unsafe {\n+            slice::from_raw_parts(self.vec.buf as *mut u8, self.vec.len as usize)\n+        }\n+    }\n+}\n+\n+pub struct IoVecMut<'a> {\n+    vec: c::WSABUF,\n+    _p: PhantomData<&'a mut [u8]>,\n+}\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        assert!(buf.len() <= c::ULONG::max_value() as usize);\n+        IoVecMut {\n+            vec: c::WSABUF {\n+                len: buf.len() as c::ULONG,\n+                buf: buf.as_mut_ptr() as *mut c::CHAR,\n+            },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &'a [u8] {\n+        unsafe {\n+            slice::from_raw_parts(self.vec.buf as *mut u8, self.vec.len as usize)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &'a mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self.vec.buf as *mut u8, self.vec.len as usize)\n+        }\n+    }\n+}"}, {"sha": "56c76a169feb8959519308d5d0111489a5174aa7", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -2,7 +2,7 @@\n \n use ptr;\n use ffi::{OsStr, OsString};\n-use io::{self, ErrorKind};\n+use io::ErrorKind;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n use time::Duration;\n@@ -26,6 +26,7 @@ pub mod ext;\n pub mod fast_thread_local;\n pub mod fs;\n pub mod handle;\n+pub mod io;\n pub mod memchr;\n pub mod mutex;\n pub mod net;\n@@ -75,12 +76,12 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     }\n }\n \n-pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n-    fn inner(s: &OsStr) -> io::Result<Vec<u16>> {\n+pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> ::io::Result<Vec<u16>> {\n+    fn inner(s: &OsStr) -> ::io::Result<Vec<u16>> {\n         let mut maybe_result: Vec<u16> = s.encode_wide().collect();\n         if maybe_result.iter().any(|&u| u == 0) {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"strings passed to WinAPI cannot contain NULs\"));\n+            return Err(::io::Error::new(::io::ErrorKind::InvalidInput,\n+                                        \"strings passed to WinAPI cannot contain NULs\"));\n         }\n         maybe_result.push(0);\n         Ok(maybe_result)\n@@ -102,7 +103,7 @@ pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n // Once the syscall has completed (errors bail out early) the second closure is\n // yielded the data which has been read from the syscall. The return value\n // from this closure is then the return value of the function.\n-fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> io::Result<T>\n+fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> ::io::Result<T>\n     where F1: FnMut(*mut u16, c::DWORD) -> c::DWORD,\n           F2: FnOnce(&[u16]) -> T\n {\n@@ -134,7 +135,7 @@ fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> io::Result<T>\n             c::SetLastError(0);\n             let k = match f1(buf.as_mut_ptr(), n as c::DWORD) {\n                 0 if c::GetLastError() == 0 => 0,\n-                0 => return Err(io::Error::last_os_error()),\n+                0 => return Err(::io::Error::last_os_error()),\n                 n => n,\n             } as usize;\n             if k == n && c::GetLastError() == c::ERROR_INSUFFICIENT_BUFFER {\n@@ -157,7 +158,7 @@ fn wide_char_to_multi_byte(code_page: u32,\n                            flags: u32,\n                            s: &[u16],\n                            no_default_char: bool)\n-                           -> io::Result<Vec<i8>> {\n+                           -> ::io::Result<Vec<i8>> {\n     unsafe {\n         let mut size = c::WideCharToMultiByte(code_page,\n                                               flags,\n@@ -168,7 +169,7 @@ fn wide_char_to_multi_byte(code_page: u32,\n                                               ptr::null(),\n                                               ptr::null_mut());\n         if size == 0 {\n-            return Err(io::Error::last_os_error());\n+            return Err(::io::Error::last_os_error());\n         }\n \n         let mut buf = Vec::with_capacity(size as usize);\n@@ -185,10 +186,10 @@ fn wide_char_to_multi_byte(code_page: u32,\n                                       if no_default_char { &mut used_default_char }\n                                       else { ptr::null_mut() });\n         if size == 0 {\n-            return Err(io::Error::last_os_error());\n+            return Err(::io::Error::last_os_error());\n         }\n         if no_default_char && used_default_char == c::TRUE {\n-            return Err(io::Error::new(io::ErrorKind::InvalidData,\n+            return Err(::io::Error::new(::io::ErrorKind::InvalidData,\n                                       \"string cannot be converted to requested code page\"));\n         }\n \n@@ -220,9 +221,9 @@ macro_rules! impl_is_zero {\n \n impl_is_zero! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n \n-pub fn cvt<I: IsZero>(i: I) -> io::Result<I> {\n+pub fn cvt<I: IsZero>(i: I) -> ::io::Result<I> {\n     if i.is_zero() {\n-        Err(io::Error::last_os_error())\n+        Err(::io::Error::last_os_error())\n     } else {\n         Ok(i)\n     }"}, {"sha": "76be26a9d1a578a01ae0b8dc69974809ccf76b6e", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,7 +1,7 @@\n #![unstable(issue = \"0\", feature = \"windows_net\")]\n \n use cmp;\n-use io::{self, Read};\n+use io::{self, Read, IoVec, IoVecMut};\n use libc::{c_int, c_void, c_ulong, c_long};\n use mem;\n use net::{SocketAddr, Shutdown};\n@@ -207,6 +207,30 @@ impl Socket {\n         self.recv_with_flags(buf, 0)\n     }\n \n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        // On unix when a socket is shut down all further reads return 0, so we\n+        // do the same on windows to map a shut down socket to returning EOF.\n+        let len = cmp::min(bufs.len(), c::DWORD::max_value() as usize) as c::DWORD;\n+        let mut nread = 0;\n+        let mut flags = 0;\n+        unsafe {\n+            let ret = c::WSARecv(\n+                self.0,\n+                bufs.as_mut_ptr() as *mut c::WSABUF,\n+                len,\n+                &mut nread,\n+                &mut flags,\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+            );\n+            match ret {\n+                0 => Ok(nread as usize),\n+                _ if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n+                _ => Err(last_error()),\n+            }\n+        }\n+    }\n+\n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.recv_with_flags(buf, c::MSG_PEEK)\n     }\n@@ -243,6 +267,23 @@ impl Socket {\n         self.recv_from_with_flags(buf, c::MSG_PEEK)\n     }\n \n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let len = cmp::min(bufs.len(), c::DWORD::max_value() as usize) as c::DWORD;\n+        let mut nwritten = 0;\n+        unsafe {\n+            cvt(c::WSASend(\n+                self.0,\n+                bufs.as_ptr() as *const c::WSABUF as *mut c::WSABUF,\n+                len,\n+                &mut nwritten,\n+                0,\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+            ))?;\n+        }\n+        Ok(nwritten as usize)\n+    }\n+\n     pub fn set_timeout(&self, dur: Option<Duration>,\n                        kind: c_int) -> io::Result<()> {\n         let timeout = match dur {"}, {"sha": "0d60593ce1f2ff3939517e782eff75e85a14525d", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31bcec648aa57391115f877a2ca022d7ff6415aa/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=31bcec648aa57391115f877a2ca022d7ff6415aa", "patch": "@@ -1,7 +1,7 @@\n use cmp;\n use ffi::CString;\n use fmt;\n-use io::{self, Error, ErrorKind};\n+use io::{self, Error, ErrorKind, IoVec, IoVecMut};\n use libc::{c_int, c_void};\n use mem;\n use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n@@ -255,6 +255,10 @@ impl TcpStream {\n         self.inner.read(buf)\n     }\n \n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        self.inner.read_vectored(bufs)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n         let ret = cvt(unsafe {\n@@ -266,6 +270,10 @@ impl TcpStream {\n         Ok(ret as usize)\n     }\n \n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        self.inner.write_vectored(bufs)\n+    }\n+\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         sockname(|buf, len| unsafe {\n             c::getpeername(*self.inner.as_inner(), buf, len)"}]}