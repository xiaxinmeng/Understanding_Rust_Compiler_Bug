{"sha": "7b9d6d3bc8730aa565dbb5e285027443696aef0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiOWQ2ZDNiYzg3MzBhYTU2NWRiYjVlMjg1MDI3NDQzNjk2YWVmMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-04T11:39:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-04T11:39:27Z"}, "message": "Auto merge of #31069 - sfackler:file-try-clone, r=alexcrichton\n\nI have it set as stable right now under the rationale that it's extending an existing, stable API to another type in the \"obvious\" way.\n\nr? @alexcrichton\n\ncc @reem", "tree": {"sha": "c1cb0abb2734d46c4c69ebcdd2887ee364563eb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1cb0abb2734d46c4c69ebcdd2887ee364563eb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b9d6d3bc8730aa565dbb5e285027443696aef0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b9d6d3bc8730aa565dbb5e285027443696aef0c", "html_url": "https://github.com/rust-lang/rust/commit/7b9d6d3bc8730aa565dbb5e285027443696aef0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b9d6d3bc8730aa565dbb5e285027443696aef0c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c30f127907a46fbd46534fb929dfeeca515ab0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c30f127907a46fbd46534fb929dfeeca515ab0f", "html_url": "https://github.com/rust-lang/rust/commit/9c30f127907a46fbd46534fb929dfeeca515ab0f"}, {"sha": "a414b61f9279b2806ab92ec17cdd19cf57d59e2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a414b61f9279b2806ab92ec17cdd19cf57d59e2f", "html_url": "https://github.com/rust-lang/rust/commit/a414b61f9279b2806ab92ec17cdd19cf57d59e2f"}], "stats": {"total": 126, "additions": 87, "deletions": 39}, "files": [{"sha": "a984c4c25c1a0031606ace79d13ed2dfb9a6b95e", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7b9d6d3bc8730aa565dbb5e285027443696aef0c/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9d6d3bc8730aa565dbb5e285027443696aef0c/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=7b9d6d3bc8730aa565dbb5e285027443696aef0c", "patch": "@@ -309,6 +309,18 @@ impl File {\n     pub fn metadata(&self) -> io::Result<Metadata> {\n         self.inner.file_attr().map(Metadata)\n     }\n+\n+    /// Creates a new independently owned handle to the underlying file.\n+    ///\n+    /// The returned `File` is a reference to the same state that this object\n+    /// references. Both handles will read and write with the same cursor\n+    /// position.\n+    #[unstable(feature = \"file_try_clone\", reason = \"newly added\", issue = \"31405\")]\n+    pub fn try_clone(&self) -> io::Result<File> {\n+        Ok(File {\n+            inner: try!(self.inner.duplicate())\n+        })\n+    }\n }\n \n impl AsInner<fs_imp::File> for File {\n@@ -2283,6 +2295,28 @@ mod tests {\n         assert!(v == &bytes[..]);\n     }\n \n+    #[test]\n+    fn file_try_clone() {\n+        let tmpdir = tmpdir();\n+\n+        let mut f1 = check!(OpenOptions::new()\n+                                       .read(true)\n+                                       .write(true)\n+                                       .create(true)\n+                                       .open(&tmpdir.join(\"test\")));\n+        let mut f2 = check!(f1.try_clone());\n+\n+        check!(f1.write_all(b\"hello world\"));\n+        check!(f1.seek(SeekFrom::Start(2)));\n+\n+        let mut buf = vec![];\n+        check!(f2.read_to_end(&mut buf));\n+        assert_eq!(buf, b\"llo world\");\n+        drop(f2);\n+\n+        check!(f1.write_all(b\"!\"));\n+    }\n+\n     #[test]\n     #[cfg(not(windows))]\n     fn unlink_readonly() {"}, {"sha": "d5f03764be27119d2a7d7c3e2e73742571bf9f28", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7b9d6d3bc8730aa565dbb5e285027443696aef0c/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9d6d3bc8730aa565dbb5e285027443696aef0c/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=7b9d6d3bc8730aa565dbb5e285027443696aef0c", "patch": "@@ -13,6 +13,7 @@ use libc::{self, c_int, size_t, c_void};\n use mem;\n use sys::cvt;\n use sys_common::AsInner;\n+use sync::atomic::{AtomicBool, Ordering};\n \n pub struct FileDesc {\n     fd: c_int,\n@@ -65,6 +66,47 @@ impl FileDesc {\n             debug_assert_eq!(ret, 0);\n         }\n     }\n+\n+    pub fn duplicate(&self) -> io::Result<FileDesc> {\n+        // We want to atomically duplicate this file descriptor and set the\n+        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n+        // flag, however, isn't supported on older Linux kernels (earlier than\n+        // 2.6.24).\n+        //\n+        // To detect this and ensure that CLOEXEC is still set, we\n+        // follow a strategy similar to musl [1] where if passing\n+        // F_DUPFD_CLOEXEC causes `fcntl` to return EINVAL it means it's not\n+        // supported (the third parameter, 0, is always valid), so we stop\n+        // trying that. We also *still* call the `set_cloexec` method as\n+        // apparently some kernel at some point stopped setting CLOEXEC even\n+        // though it reported doing so on F_DUPFD_CLOEXEC.\n+        //\n+        // Also note that Android doesn't have F_DUPFD_CLOEXEC, but get it to\n+        // resolve so we at least compile this.\n+        //\n+        // [1]: http://comments.gmane.org/gmane.linux.lib.musl.general/2963\n+        #[cfg(target_os = \"android\")]\n+        use libc::F_DUPFD as F_DUPFD_CLOEXEC;\n+        #[cfg(not(target_os = \"android\"))]\n+        use libc::F_DUPFD_CLOEXEC;\n+\n+        let make_filedesc = |fd| {\n+            let fd = FileDesc::new(fd);\n+            fd.set_cloexec();\n+            fd\n+        };\n+        static TRY_CLOEXEC: AtomicBool = AtomicBool::new(true);\n+        let fd = self.raw();\n+        if !cfg!(target_os = \"android\") && TRY_CLOEXEC.load(Ordering::Relaxed) {\n+            match cvt(unsafe { libc::fcntl(fd, F_DUPFD_CLOEXEC, 0) }) {\n+                Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {\n+                    TRY_CLOEXEC.store(false, Ordering::Relaxed);\n+                }\n+                res => return res.map(make_filedesc),\n+            }\n+        }\n+        cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD, 0) }).map(make_filedesc)\n+    }\n }\n \n impl AsInner<c_int> for FileDesc {"}, {"sha": "efc8bd6cd2ed18e23c88d6dde1fae412ac8e9ced", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b9d6d3bc8730aa565dbb5e285027443696aef0c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9d6d3bc8730aa565dbb5e285027443696aef0c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=7b9d6d3bc8730aa565dbb5e285027443696aef0c", "patch": "@@ -414,6 +414,10 @@ impl File {\n         Ok(n as u64)\n     }\n \n+    pub fn duplicate(&self) -> io::Result<File> {\n+        self.0.duplicate().map(File)\n+    }\n+\n     pub fn fd(&self) -> &FileDesc { &self.0 }\n \n     pub fn into_fd(self) -> FileDesc { self.0 }"}, {"sha": "0aa43803048f305f88009c963016cd67b5ce1b46", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7b9d6d3bc8730aa565dbb5e285027443696aef0c/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9d6d3bc8730aa565dbb5e285027443696aef0c/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=7b9d6d3bc8730aa565dbb5e285027443696aef0c", "patch": "@@ -15,7 +15,6 @@ use io;\n use libc::{self, c_int, size_t};\n use net::{SocketAddr, Shutdown};\n use str;\n-use sync::atomic::{AtomicBool, Ordering};\n use sys::fd::FileDesc;\n use sys_common::{AsInner, FromInner, IntoInner};\n use sys_common::net::{getsockopt, setsockopt};\n@@ -67,44 +66,7 @@ impl Socket {\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {\n-        // We want to atomically duplicate this file descriptor and set the\n-        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n-        // flag, however, isn't supported on older Linux kernels (earlier than\n-        // 2.6.24).\n-        //\n-        // To detect this and ensure that CLOEXEC is still set, we\n-        // follow a strategy similar to musl [1] where if passing\n-        // F_DUPFD_CLOEXEC causes `fcntl` to return EINVAL it means it's not\n-        // supported (the third parameter, 0, is always valid), so we stop\n-        // trying that. We also *still* call the `set_cloexec` method as\n-        // apparently some kernel at some point stopped setting CLOEXEC even\n-        // though it reported doing so on F_DUPFD_CLOEXEC.\n-        //\n-        // Also note that Android doesn't have F_DUPFD_CLOEXEC, but get it to\n-        // resolve so we at least compile this.\n-        //\n-        // [1]: http://comments.gmane.org/gmane.linux.lib.musl.general/2963\n-        #[cfg(target_os = \"android\")]\n-        use libc::F_DUPFD as F_DUPFD_CLOEXEC;\n-        #[cfg(not(target_os = \"android\"))]\n-        use libc::F_DUPFD_CLOEXEC;\n-\n-        let make_socket = |fd| {\n-            let fd = FileDesc::new(fd);\n-            fd.set_cloexec();\n-            Socket(fd)\n-        };\n-        static TRY_CLOEXEC: AtomicBool = AtomicBool::new(true);\n-        let fd = self.0.raw();\n-        if !cfg!(target_os = \"android\") && TRY_CLOEXEC.load(Ordering::Relaxed) {\n-            match cvt(unsafe { libc::fcntl(fd, F_DUPFD_CLOEXEC, 0) }) {\n-                Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {\n-                    TRY_CLOEXEC.store(false, Ordering::Relaxed);\n-                }\n-                res => return res.map(make_socket),\n-            }\n-        }\n-        cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD, 0) }).map(make_socket)\n+        self.0.duplicate().map(Socket)\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {"}, {"sha": "e965a4a1d540208d0064ef9e97f2a0f4236a6f22", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b9d6d3bc8730aa565dbb5e285027443696aef0c/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9d6d3bc8730aa565dbb5e285027443696aef0c/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=7b9d6d3bc8730aa565dbb5e285027443696aef0c", "patch": "@@ -338,6 +338,12 @@ impl File {\n         Ok(newpos as u64)\n     }\n \n+    pub fn duplicate(&self) -> io::Result<File> {\n+        Ok(File {\n+            handle: try!(self.handle.duplicate(0, true, c::DUPLICATE_SAME_ACCESS)),\n+        })\n+    }\n+\n     pub fn handle(&self) -> &Handle { &self.handle }\n \n     pub fn into_handle(self) -> Handle { self.handle }"}]}