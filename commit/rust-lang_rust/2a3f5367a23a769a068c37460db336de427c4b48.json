{"sha": "2a3f5367a23a769a068c37460db336de427c4b48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhM2Y1MzY3YTIzYTc2OWEwNjhjMzc0NjBkYjMzNmRlNDI3YzRiNDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-16T11:18:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-16T11:18:05Z"}, "message": "Auto merge of #50473 - petrochenkov:pmapi, r=alexcrichton\n\nReview proc macro API 1.2\n\ncc https://github.com/rust-lang/rust/issues/38356\n\nSummary of applied changes:\n- Documentation for proc macro API 1.2 is expanded.\n- Renamed APIs: `Term` -> `Ident`, `TokenTree::Term` -> `TokenTree::Ident`, `Op` -> `Punct`, `TokenTree::Op` -> `TokenTree::Punct`, `Op::op` -> `Punct::as_char`.\n- Removed APIs: `Ident::as_str`, use `Display` impl for `Ident` instead.\n- New APIs (not stabilized in 1.2): `Ident::new_raw` for creating a raw identifier (I'm not sure `new_x` it's a very idiomatic name though).\n- Runtime changes:\n    - `Punct::new` now ensures that the input `char` is a valid punctuation character in Rust.\n    - `Ident::new` ensures that the input `str` is a valid identifier in Rust.\n    - Lifetimes in proc macros are now represented as two joint tokens - `Punct('\\'', Spacing::Joint)` and `Ident(\"lifetime_name_without_quote\")` similarly to multi-character operators.\n- Stabilized APIs: None yet.\n\nA bit of motivation for renaming (although it was already stated in the review comments):\n- With my compiler frontend glasses on `Ident` is the single most appropriate name for this thing, *especially* if we are doing input validation on construction. `TokenTree::Ident` effectively wraps `token::Ident` or `ast::Ident + is_raw`, its meaning is \"identifier\" and it's already named `ident` in declarative macros.\n- Regarding `Punct`, the motivation is that `Op` is actively misleading. The thing doesn't mean an operator, it's neither a subset of operators (there is non-operator punctuation in the language), nor superset (operators can be multicharacter while this thing is always a single character). So I named it `Punct` (first proposed in [the original RFC](https://github.com/rust-lang/rfcs/pull/1566), then [by @SimonSapin](https://github.com/rust-lang/rust/issues/38356#issuecomment-276676526)) , together with input validation it's now a subset of ASCII punctuation character category (`u8::is_ascii_punctuation`).", "tree": {"sha": "8017b98f72aba661e56c0f0be9bf8a37f4b15f2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8017b98f72aba661e56c0f0be9bf8a37f4b15f2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a3f5367a23a769a068c37460db336de427c4b48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a3f5367a23a769a068c37460db336de427c4b48", "html_url": "https://github.com/rust-lang/rust/commit/2a3f5367a23a769a068c37460db336de427c4b48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a3f5367a23a769a068c37460db336de427c4b48/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "448cc578a903730d422f6e638641787d0dbd7bc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/448cc578a903730d422f6e638641787d0dbd7bc7", "html_url": "https://github.com/rust-lang/rust/commit/448cc578a903730d422f6e638641787d0dbd7bc7"}, {"sha": "dab8c0ab28c317f7b9e350a0ba84fd51787f84d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dab8c0ab28c317f7b9e350a0ba84fd51787f84d6", "html_url": "https://github.com/rust-lang/rust/commit/dab8c0ab28c317f7b9e350a0ba84fd51787f84d6"}], "stats": {"total": 805, "additions": 595, "deletions": 210}, "files": [{"sha": "610a9a2a39486580743152b98967c55d6061ccba", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 207, "deletions": 126, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,13 +11,11 @@\n //! A support library for macro authors when defining new macros.\n //!\n //! This library, provided by the standard distribution, provides the types\n-//! consumed in the interfaces of procedurally defined macro definitions.\n-//! Currently the primary use of this crate is to provide the ability to define\n-//! new custom derive modes through `#[proc_macro_derive]`.\n+//! consumed in the interfaces of procedurally defined macro definitions such as\n+//! function-like macros `#[proc_macro]`, macro attribures `#[proc_macro_attribute]` and\n+//! custom derive attributes`#[proc_macro_derive]`.\n //!\n-//! Note that this crate is intentionally very bare-bones currently. The main\n-//! type, `TokenStream`, only supports `fmt::Display` and `FromStr`\n-//! implementations, indicating that it can only go to and come from a string.\n+//! Note that this crate is intentionally bare-bones currently.\n //! This functionality is intended to be expanded over time as more surface\n //! area for macro authors is stabilized.\n //!\n@@ -55,28 +53,29 @@ use std::str::FromStr;\n use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n use syntax::parse::{self, token};\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{keywords, Symbol};\n use syntax::tokenstream;\n-use syntax::parse::lexer::comments;\n+use syntax::parse::lexer::{self, comments};\n use syntax_pos::{FileMap, Pos, SyntaxContext, FileName};\n use syntax_pos::hygiene::Mark;\n \n /// The main type provided by this crate, representing an abstract stream of\n-/// tokens.\n+/// tokens, or, more specifically, a sequence of token trees.\n+/// The type provide interfaces for iterating over those token trees and, conversely,\n+/// collecting a number of token trees into one stream.\n ///\n-/// This is both the input and output of `#[proc_macro_derive]` definitions.\n-/// Currently it's required to be a list of valid Rust items, but this\n-/// restriction may be lifted in the future.\n+/// This is both the input and output of `#[proc_macro]`, `#[proc_macro_attribute]`\n+/// and `#[proc_macro_derive]` definitions.\n ///\n /// The API of this type is intentionally bare-bones, but it'll be expanded over\n /// time!\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n #[derive(Clone)]\n pub struct TokenStream(tokenstream::TokenStream);\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl !Send for TokenStream {}\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl !Sync for TokenStream {}\n \n /// Error returned from `TokenStream::from_str`.\n@@ -86,13 +85,13 @@ pub struct LexError {\n     _inner: (),\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl !Send for LexError {}\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl !Sync for LexError {}\n \n impl TokenStream {\n-    /// Returns an empty `TokenStream`.\n+    /// Returns an empty `TokenStream` containing no token trees.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn empty() -> TokenStream {\n         TokenStream(tokenstream::TokenStream::empty())\n@@ -105,6 +104,12 @@ impl TokenStream {\n     }\n }\n \n+/// Attempts to break the string into tokens and parse those tokens into a token stream.\n+/// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n+/// or characters not existing in the language.\n+///\n+/// NOTE: Some errors may cause panics instead of returning `LexError`. We reserve the right to\n+/// change these errors into `LexError`s later.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl FromStr for TokenStream {\n     type Err = LexError;\n@@ -125,13 +130,17 @@ impl FromStr for TokenStream {\n     }\n }\n \n+/// Prints the token stream as a string that is supposed to be losslessly convertible back\n+/// into the same token stream (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters and negative numeric literals.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Display for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.0.fmt(f)\n     }\n }\n \n+/// Prints token in a form convenient for debugging.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Debug for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -140,21 +149,25 @@ impl fmt::Debug for TokenStream {\n     }\n }\n \n+/// Creates a token stream containing a single token tree.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n         TokenStream(tree.to_internal())\n     }\n }\n \n+/// Collects a number of token trees into a single stream.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl iter::FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n         trees.into_iter().map(TokenStream::from).collect()\n     }\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+/// A \"flattening\" operation on token streams, collects token trees\n+/// from multiple token streams into a single stream.\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl iter::FromIterator<TokenStream> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n         let mut builder = tokenstream::TokenStreamBuilder::new();\n@@ -165,15 +178,17 @@ impl iter::FromIterator<TokenStream> for TokenStream {\n     }\n }\n \n-/// Implementation details for the `TokenTree` type, such as iterators.\n+/// Public implementation details for the `TokenStream` type, such as iterators.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub mod token_stream {\n     use syntax::tokenstream;\n     use syntax_pos::DUMMY_SP;\n \n     use {TokenTree, TokenStream, Delimiter};\n \n-    /// An iterator over `TokenTree`s.\n+    /// An iterator over `TokenStream`'s `TokenTree`s.\n+    /// The iteration is \"shallow\", e.g. the iterator doesn't recurse into delimited groups,\n+    /// and returns whole groups as token trees.\n     #[derive(Clone)]\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub struct IntoIter {\n@@ -191,6 +206,12 @@ pub mod token_stream {\n                     let next = self.cursor.next_as_stream()?;\n                     Some(TokenTree::from_internal(next, &mut self.stack))\n                 })?;\n+                // HACK: The condition \"dummy span + group with empty delimiter\" represents an AST\n+                // fragment approximately converted into a token stream. This may happen, for\n+                // example, with inputs to proc macro attributes, including derives. Such \"groups\"\n+                // need to flattened during iteration over stream's token trees.\n+                // Eventually this needs to be removed in favor of keeping original token trees\n+                // and not doing the roundtrip through AST.\n                 if tree.span().0 == DUMMY_SP {\n                     if let TokenTree::Group(ref group) = tree {\n                         if group.delimiter() == Delimiter::None {\n@@ -217,7 +238,7 @@ pub mod token_stream {\n \n /// `quote!(..)` accepts arbitrary tokens and expands into a `TokenStream` describing the input.\n /// For example, `quote!(a + b)` will produce a expression, that, when evaluated, constructs\n-/// the `TokenStream` `[Word(\"a\"), Op('+', Alone), Word(\"b\")]`.\n+/// the `TokenStream` `[Ident(\"a\"), Punct('+', Alone), Ident(\"b\")]`.\n ///\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`.\n@@ -268,6 +289,9 @@ impl Span {\n     }\n \n     /// The span of the invocation of the current procedural macro.\n+    /// Identifiers created with this span will be resolved as if they were written\n+    /// directly at the macro call location (call-site hygiene) and other code\n+    /// at the macro call site will be able to refer to them as well.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn call_site() -> Span {\n         ::__internal::with_sess(|(_, mark)| Span(mark.expn_info().unwrap().call_site))\n@@ -355,6 +379,7 @@ impl Span {\n     diagnostic_method!(help, Level::Help);\n }\n \n+/// Prints a span in a form convenient for debugging.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Debug for Span {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -460,12 +485,12 @@ impl PartialEq<FileName> for SourceFile {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Clone)]\n pub enum TokenTree {\n-    /// A delimited tokenstream\n+    /// A token stream surrounded by bracket delimiters.\n     Group(Group),\n-    /// A unicode identifier\n-    Term(Term),\n-    /// A punctuation character (`+`, `,`, `$`, etc.).\n-    Op(Op),\n+    /// An identifier.\n+    Ident(Ident),\n+    /// A single punctuation character (`+`, `,`, `$`, etc.).\n+    Punct(Punct),\n     /// A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.\n     Literal(Literal),\n }\n@@ -476,14 +501,14 @@ impl !Send for TokenTree {}\n impl !Sync for TokenTree {}\n \n impl TokenTree {\n-    /// Returns the span of this token, accessing the `span` method of each of\n-    /// the internal tokens.\n+    /// Returns the span of this tree, delegating to the `span` method of\n+    /// the contained token or a delimited stream.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn span(&self) -> Span {\n         match *self {\n             TokenTree::Group(ref t) => t.span(),\n-            TokenTree::Term(ref t) => t.span(),\n-            TokenTree::Op(ref t) => t.span(),\n+            TokenTree::Ident(ref t) => t.span(),\n+            TokenTree::Punct(ref t) => t.span(),\n             TokenTree::Literal(ref t) => t.span(),\n         }\n     }\n@@ -497,22 +522,23 @@ impl TokenTree {\n     pub fn set_span(&mut self, span: Span) {\n         match *self {\n             TokenTree::Group(ref mut t) => t.set_span(span),\n-            TokenTree::Term(ref mut t) => t.set_span(span),\n-            TokenTree::Op(ref mut t) => t.set_span(span),\n+            TokenTree::Ident(ref mut t) => t.set_span(span),\n+            TokenTree::Punct(ref mut t) => t.set_span(span),\n             TokenTree::Literal(ref mut t) => t.set_span(span),\n         }\n     }\n }\n \n+/// Prints token treee in a form convenient for debugging.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Debug for TokenTree {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Each of these has the name in the struct type in the derived debug,\n         // so don't bother with an extra layer of indirection\n         match *self {\n             TokenTree::Group(ref tt) => tt.fmt(f),\n-            TokenTree::Term(ref tt) => tt.fmt(f),\n-            TokenTree::Op(ref tt) => tt.fmt(f),\n+            TokenTree::Ident(ref tt) => tt.fmt(f),\n+            TokenTree::Punct(ref tt) => tt.fmt(f),\n             TokenTree::Literal(ref tt) => tt.fmt(f),\n         }\n     }\n@@ -526,16 +552,16 @@ impl From<Group> for TokenTree {\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl From<Term> for TokenTree {\n-    fn from(g: Term) -> TokenTree {\n-        TokenTree::Term(g)\n+impl From<Ident> for TokenTree {\n+    fn from(g: Ident) -> TokenTree {\n+        TokenTree::Ident(g)\n     }\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl From<Op> for TokenTree {\n-    fn from(g: Op) -> TokenTree {\n-        TokenTree::Op(g)\n+impl From<Punct> for TokenTree {\n+    fn from(g: Punct) -> TokenTree {\n+        TokenTree::Punct(g)\n     }\n }\n \n@@ -546,23 +572,24 @@ impl From<Literal> for TokenTree {\n     }\n }\n \n+/// Prints the token tree as a string that is supposed to be losslessly convertible back\n+/// into the same token tree (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters and negative numeric literals.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Display for TokenTree {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             TokenTree::Group(ref t) => t.fmt(f),\n-            TokenTree::Term(ref t) => t.fmt(f),\n-            TokenTree::Op(ref t) => t.fmt(f),\n+            TokenTree::Ident(ref t) => t.fmt(f),\n+            TokenTree::Punct(ref t) => t.fmt(f),\n             TokenTree::Literal(ref t) => t.fmt(f),\n         }\n     }\n }\n \n-/// A delimited token stream\n+/// A delimited token stream.\n ///\n-/// A `Group` internally contains a `TokenStream` which is delimited by a\n-/// `Delimiter`. Groups represent multiple tokens internally and have a `Span`\n-/// for the entire stream.\n+/// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n #[derive(Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub struct Group {\n@@ -586,12 +613,16 @@ pub enum Delimiter {\n     Brace,\n     /// `[ ... ]`\n     Bracket,\n-    /// An implicit delimiter, e.g. `$var`, where $var is  `...`.\n+    /// `\u00d8 ... \u00d8`\n+    /// An implicit delimiter, that may, for example, appear around tokens coming from a\n+    /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n+    /// `$var * 3` where `$var` is `1 + 2`.\n+    /// Implicit delimiters may not survive roundtrip of a token stream through a string.\n     None,\n }\n \n impl Group {\n-    /// Creates a new `group` with the given delimiter and token stream.\n+    /// Creates a new `Group` with the given delimiter and token stream.\n     ///\n     /// This constructor will set the span for this group to\n     /// `Span::call_site()`. To change the span you can use the `set_span`\n@@ -639,152 +670,191 @@ impl Group {\n     }\n }\n \n+/// Prints the group as a string that should be losslessly convertible back\n+/// into the same group (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Display for Group {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n     }\n }\n \n-/// An `Op` is an operator like `+` or `-`, and only represents one character.\n+/// An `Punct` is an single punctuation character like `+`, `-` or `#`.\n ///\n-/// Operators like `+=` are represented as two instance of `Op` with different\n+/// Multicharacter operators like `+=` are represented as two instances of `Punct` with different\n /// forms of `Spacing` returned.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-#[derive(Copy, Clone, Debug)]\n-pub struct Op {\n-    op: char,\n+#[derive(Clone, Debug)]\n+pub struct Punct {\n+    ch: char,\n     spacing: Spacing,\n     span: Span,\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl !Send for Op {}\n+impl !Send for Punct {}\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl !Sync for Op {}\n+impl !Sync for Punct {}\n \n-/// Whether an `Op` is either followed immediately by another `Op` or followed by whitespace.\n+/// Whether an `Punct` is followed immediately by another `Punct` or\n+/// followed by another token or whitespace.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub enum Spacing {\n-    /// e.g. `+` is `Alone` in `+ =`.\n+    /// E.g. `+` is `Alone` in `+ =`, `+ident` or `+()`.\n     Alone,\n-    /// e.g. `+` is `Joint` in `+=`.\n+    /// E.g. `+` is `Joint` in `+=` or `'#`.\n+    /// Additionally, single quote `'` can join with identifiers to form lifetimes `'ident`.\n     Joint,\n }\n \n-impl Op {\n-    /// Creates a new `Op` from the given character and spacing.\n+impl Punct {\n+    /// Creates a new `Punct` from the given character and spacing.\n+    /// The `ch` argument must be a valid punctuation character permitted by the language,\n+    /// otherwise the function will panic.\n     ///\n-    /// The returned `Op` will have the default span of `Span::call_site()`\n+    /// The returned `Punct` will have the default span of `Span::call_site()`\n     /// which can be further configured with the `set_span` method below.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn new(op: char, spacing: Spacing) -> Op {\n-        Op {\n-            op: op,\n+    pub fn new(ch: char, spacing: Spacing) -> Punct {\n+        const LEGAL_CHARS: &[char] = &['=', '<', '>', '!', '~', '+', '-', '*', '/', '%', '^',\n+                                       '&', '|', '@', '.', ',', ';', ':', '#', '$', '?', '\\''];\n+        if !LEGAL_CHARS.contains(&ch) {\n+            panic!(\"unsupported character `{:?}`\", ch)\n+        }\n+        Punct {\n+            ch: ch,\n             spacing: spacing,\n             span: Span::call_site(),\n         }\n     }\n \n-    /// Returns the character this operation represents, for example `'+'`\n+    /// Returns the value of this punctuation character as `char`.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn op(&self) -> char {\n-        self.op\n+    pub fn as_char(&self) -> char {\n+        self.ch\n     }\n \n-    /// Returns the spacing of this operator, indicating whether it's a joint\n-    /// operator with more operators coming next in the token stream or an\n-    /// `Alone` meaning that the operator has ended.\n+    /// Returns the spacing of this punctuation character, indicating whether it's immediately\n+    /// followed by another `Punct` in the token stream, so they can potentially be combined into\n+    /// a multicharacter operator (`Joint`), or it's followed by some other token or whitespace\n+    /// (`Alone`) so the operator has certainly ended.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn spacing(&self) -> Spacing {\n         self.spacing\n     }\n \n-    /// Returns the span for this operator character\n+    /// Returns the span for this punctuation character.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn span(&self) -> Span {\n         self.span\n     }\n \n-    /// Configure the span for this operator's character\n+    /// Configure the span for this punctuation character.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn set_span(&mut self, span: Span) {\n         self.span = span;\n     }\n }\n \n+/// Prints the punctuation character as a string that should be losslessly convertible\n+/// back into the same character.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl fmt::Display for Op {\n+impl fmt::Display for Punct {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n     }\n }\n \n-/// An interned string.\n-#[derive(Copy, Clone, Debug)]\n+/// An identifier (`ident`).\n+#[derive(Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-pub struct Term {\n+pub struct Ident {\n     sym: Symbol,\n     span: Span,\n+    is_raw: bool,\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl !Send for Term {}\n+impl !Send for Ident {}\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl !Sync for Term {}\n+impl !Sync for Ident {}\n \n-impl Term {\n-    /// Creates a new `Term` with the given `string` as well as the specified\n+impl Ident {\n+    /// Creates a new `Ident` with the given `string` as well as the specified\n     /// `span`.\n+    /// The `string` argument must be a valid identifier permitted by the\n+    /// language, otherwise the function will panic.\n     ///\n     /// Note that `span`, currently in rustc, configures the hygiene information\n-    /// for this identifier. As of this time `Span::call_site()` explicitly\n-    /// opts-in to **non-hygienic** information (aka copy/pasted code) while\n-    /// spans like `Span::def_site()` will opt-in to hygienic information,\n-    /// meaning that code at the call site of the macro can't access this\n-    /// identifier.\n+    /// for this identifier.\n+    ///\n+    /// As of this time `Span::call_site()` explicitly opts-in to \"call-site\" hygiene\n+    /// meaning that identifiers created with this span will be resolved as if they were written\n+    /// directly at the location of the macro call, and other code at the macro call site will be\n+    /// able to refer to them as well.\n+    ///\n+    /// Later spans like `Span::def_site()` will allow to opt-in to \"definition-site\" hygiene\n+    /// meaning that identifiers created with this span will be resolved at the location of the\n+    /// macro definition and other code at the macro call site will not be able to refer to them.\n     ///\n     /// Due to the current importance of hygiene this constructor, unlike other\n     /// tokens, requires a `Span` to be specified at construction.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn new(string: &str, span: Span) -> Term {\n-        Term {\n+    pub fn new(string: &str, span: Span) -> Ident {\n+        if !lexer::is_valid_ident(string) {\n+            panic!(\"`{:?}` is not a valid identifier\", string)\n+        }\n+        Ident {\n             sym: Symbol::intern(string),\n             span,\n+            is_raw: false,\n         }\n     }\n \n-    // FIXME: Remove this, do not stabilize\n-    /// Get a reference to the interned string.\n+    /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn as_str(&self) -> &str {\n-        unsafe { &*(&*self.sym.as_str() as *const str) }\n+    pub fn new_raw(string: &str, span: Span) -> Ident {\n+        let mut ident = Ident::new(string, span);\n+        if ident.sym == keywords::Underscore.name() ||\n+           token::is_path_segment_keyword(ast::Ident::with_empty_ctxt(ident.sym)) {\n+            panic!(\"`{:?}` is not a valid raw identifier\", string)\n+        }\n+        ident.is_raw = true;\n+        ident\n     }\n \n-    /// Returns the span of this `Term`, encompassing the entire string returned\n+    /// Returns the span of this `Ident`, encompassing the entire string returned\n     /// by `as_str`.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn span(&self) -> Span {\n         self.span\n     }\n \n-    /// Configures the span of this `Term`, possibly changing hygiene\n-    /// information.\n+    /// Configures the span of this `Ident`, possibly changing its hygiene context.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn set_span(&mut self, span: Span) {\n         self.span = span;\n     }\n }\n \n+/// Prints the identifier as a string that should be losslessly convertible\n+/// back into the same identifier.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl fmt::Display for Term {\n+impl fmt::Display for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.is_raw {\n+            f.write_str(\"r#\")?;\n+        }\n         self.sym.as_str().fmt(f)\n     }\n }\n \n-/// A literal character (`'a'`), string (`\"hello\"`), a number (`2.3`), etc.\n+/// A literal string (`\"hello\"`), byte string (`b\"hello\"`),\n+/// character (`'a'`), byte character (`b'a'`), an integer or floating point number\n+/// with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n+/// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n #[derive(Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub struct Literal {\n@@ -805,6 +875,8 @@ macro_rules! suffixed_int_literals {\n         /// This function will create an integer like `1u32` where the integer\n         /// value specified is the first part of the token and the integral is\n         /// also suffixed at the end.\n+        /// Literals created from negative numbers may not survive rountrips through\n+        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n         ///\n         /// Literals created through this method have the `Span::call_site()`\n         /// span by default, which can be configured with the `set_span` method\n@@ -829,6 +901,8 @@ macro_rules! unsuffixed_int_literals {\n         /// specified on this token, meaning that invocations like\n         /// `Literal::i8_unsuffixed(1)` are equivalent to\n         /// `Literal::u32_unsuffixed(1)`.\n+        /// Literals created from negative numbers may not survive rountrips through\n+        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n         ///\n         /// Literals created through this method have the `Span::call_site()`\n         /// span by default, which can be configured with the `set_span` method\n@@ -880,6 +954,8 @@ impl Literal {\n     /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n     /// the float's value is emitted directly into the token but no suffix is\n     /// used, so it may be inferred to be a `f64` later in the compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n     ///\n     /// # Panics\n     ///\n@@ -903,6 +979,8 @@ impl Literal {\n     /// specified is the preceding part of the token and `f32` is the suffix of\n     /// the token. This token will always be inferred to be an `f32` in the\n     /// compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n     ///\n     /// # Panics\n     ///\n@@ -925,6 +1003,8 @@ impl Literal {\n     /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n     /// the float's value is emitted directly into the token but no suffix is\n     /// used, so it may be inferred to be a `f64` later in the compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n     ///\n     /// # Panics\n     ///\n@@ -948,6 +1028,8 @@ impl Literal {\n     /// specified is the preceding part of the token and `f64` is the suffix of\n     /// the token. This token will always be inferred to be an `f64` in the\n     /// compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n     ///\n     /// # Panics\n     ///\n@@ -1016,6 +1098,8 @@ impl Literal {\n     }\n }\n \n+/// Prints the literal as a string that should be losslessly convertible\n+/// back into the same literal (except for possible rounding for floating point literals).\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Display for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -1068,15 +1152,15 @@ impl TokenTree {\n             })\n         }\n         macro_rules! op {\n-            ($a:expr) => (tt!(Op::new($a, op_kind)));\n+            ($a:expr) => (tt!(Punct::new($a, op_kind)));\n             ($a:expr, $b:expr) => ({\n-                stack.push(tt!(Op::new($b, op_kind)));\n-                tt!(Op::new($a, Spacing::Joint))\n+                stack.push(tt!(Punct::new($b, op_kind)));\n+                tt!(Punct::new($a, Spacing::Joint))\n             });\n             ($a:expr, $b:expr, $c:expr) => ({\n-                stack.push(tt!(Op::new($c, op_kind)));\n-                stack.push(tt!(Op::new($b, Spacing::Joint)));\n-                tt!(Op::new($a, Spacing::Joint))\n+                stack.push(tt!(Punct::new($c, op_kind)));\n+                stack.push(tt!(Punct::new($b, Spacing::Joint)));\n+                tt!(Punct::new($a, Spacing::Joint))\n             })\n         }\n \n@@ -1127,27 +1211,33 @@ impl TokenTree {\n             Pound => op!('#'),\n             Dollar => op!('$'),\n             Question => op!('?'),\n+            SingleQuote => op!('\\''),\n \n-            Ident(ident, false) | Lifetime(ident) => {\n-                tt!(Term::new(&ident.name.as_str(), Span(span)))\n+            Ident(ident, false) => {\n+                tt!(self::Ident::new(&ident.name.as_str(), Span(span)))\n             }\n             Ident(ident, true) => {\n-                tt!(Term::new(&format!(\"r#{}\", ident), Span(span)))\n+                tt!(self::Ident::new_raw(&ident.name.as_str(), Span(span)))\n+            }\n+            Lifetime(ident) => {\n+                let ident = ident.without_first_quote();\n+                stack.push(tt!(self::Ident::new(&ident.name.as_str(), Span(span))));\n+                tt!(Punct::new('\\'', Spacing::Joint))\n             }\n             Literal(lit, suffix) => tt!(self::Literal { lit, suffix, span: Span(span) }),\n             DocComment(c) => {\n                 let style = comments::doc_comment_style(&c.as_str());\n                 let stripped = comments::strip_doc_comment_decoration(&c.as_str());\n                 let stream = vec![\n-                    tt!(Term::new(\"doc\", Span(span))),\n-                    tt!(Op::new('=', Spacing::Alone)),\n+                    tt!(self::Ident::new(\"doc\", Span(span))),\n+                    tt!(Punct::new('=', Spacing::Alone)),\n                     tt!(self::Literal::string(&stripped)),\n                 ].into_iter().collect();\n                 stack.push(tt!(Group::new(Delimiter::Bracket, stream)));\n                 if style == ast::AttrStyle::Inner {\n-                    stack.push(tt!(Op::new('!', Spacing::Alone)));\n+                    stack.push(tt!(Punct::new('!', Spacing::Alone)));\n                 }\n-                tt!(Op::new('#', Spacing::Alone))\n+                tt!(Punct::new('#', Spacing::Alone))\n             }\n \n             Interpolated(_) => {\n@@ -1167,26 +1257,16 @@ impl TokenTree {\n         use syntax::parse::token::*;\n         use syntax::tokenstream::{TokenTree, Delimited};\n \n-        let (op, kind, span) = match self {\n-            self::TokenTree::Op(tt) => (tt.op(), tt.spacing(), tt.span()),\n+        let (ch, kind, span) = match self {\n+            self::TokenTree::Punct(tt) => (tt.as_char(), tt.spacing(), tt.span()),\n             self::TokenTree::Group(tt) => {\n                 return TokenTree::Delimited(tt.span.0, Delimited {\n                     delim: tt.delimiter.to_internal(),\n                     tts: tt.stream.0.into(),\n                 }).into();\n             },\n-            self::TokenTree::Term(tt) => {\n-                let ident = ast::Ident::new(tt.sym, tt.span.0);\n-                let sym_str = tt.sym.to_string();\n-                let token = if sym_str.starts_with(\"'\") {\n-                    Lifetime(ident)\n-                } else if sym_str.starts_with(\"r#\") {\n-                    let name = Symbol::intern(&sym_str[2..]);\n-                    let ident = ast::Ident::new(name, ident.span);\n-                    Ident(ident, true)\n-                } else {\n-                    Ident(ident, false)\n-                };\n+            self::TokenTree::Ident(tt) => {\n+                let token = Ident(ast::Ident::new(tt.sym, tt.span.0), tt.is_raw);\n                 return TokenTree::Token(tt.span.0, token).into();\n             }\n             self::TokenTree::Literal(self::Literal {\n@@ -1223,7 +1303,7 @@ impl TokenTree {\n             }\n         };\n \n-        let token = match op {\n+        let token = match ch {\n             '=' => Eq,\n             '<' => Lt,\n             '>' => Gt,\n@@ -1245,7 +1325,8 @@ impl TokenTree {\n             '#' => Pound,\n             '$' => Dollar,\n             '?' => Question,\n-            _ => panic!(\"unsupported character {}\", op),\n+            '\\'' => SingleQuote,\n+            _ => unreachable!(),\n         };\n \n         let tree = TokenTree::Token(span.0, token);\n@@ -1268,7 +1349,7 @@ impl TokenTree {\n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n #[doc(hidden)]\n pub mod __internal {\n-    pub use quote::{LiteralKind, Quoter, unquote};\n+    pub use quote::{LiteralKind, SpannedSymbol, Quoter, unquote};\n \n     use std::cell::Cell;\n "}, {"sha": "390d4bc08682509e9352d442bceec6b7f66db4d8", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -14,10 +14,11 @@\n //! This quasiquoter uses macros 2.0 hygiene to reliably access\n //! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n \n-use {Delimiter, Literal, Spacing, Span, Term, Op, Group, TokenStream, TokenTree};\n+use {Delimiter, Literal, Spacing, Span, Ident, Punct, Group, TokenStream, TokenTree};\n \n use syntax::ext::base::{ExtCtxt, ProcMacro};\n use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream;\n \n pub struct Quoter;\n@@ -35,14 +36,14 @@ macro_rules! tt2ts {\n }\n \n macro_rules! quote_tok {\n-    (,) => { tt2ts!(Op::new(',', Spacing::Alone)) };\n-    (.) => { tt2ts!(Op::new('.', Spacing::Alone)) };\n-    (:) => { tt2ts!(Op::new(':', Spacing::Alone)) };\n-    (|) => { tt2ts!(Op::new('|', Spacing::Alone)) };\n+    (,) => { tt2ts!(Punct::new(',', Spacing::Alone)) };\n+    (.) => { tt2ts!(Punct::new('.', Spacing::Alone)) };\n+    (:) => { tt2ts!(Punct::new(':', Spacing::Alone)) };\n+    (|) => { tt2ts!(Punct::new('|', Spacing::Alone)) };\n     (::) => {\n         [\n-            TokenTree::from(Op::new(':', Spacing::Joint)),\n-            TokenTree::from(Op::new(':', Spacing::Alone)),\n+            TokenTree::from(Punct::new(':', Spacing::Joint)),\n+            TokenTree::from(Punct::new(':', Spacing::Alone)),\n         ].iter()\n             .cloned()\n             .map(|mut x| {\n@@ -51,13 +52,13 @@ macro_rules! quote_tok {\n             })\n             .collect::<TokenStream>()\n     };\n-    (!) => { tt2ts!(Op::new('!', Spacing::Alone)) };\n-    (<) => { tt2ts!(Op::new('<', Spacing::Alone)) };\n-    (>) => { tt2ts!(Op::new('>', Spacing::Alone)) };\n-    (_) => { tt2ts!(Op::new('_', Spacing::Alone)) };\n+    (!) => { tt2ts!(Punct::new('!', Spacing::Alone)) };\n+    (<) => { tt2ts!(Punct::new('<', Spacing::Alone)) };\n+    (>) => { tt2ts!(Punct::new('>', Spacing::Alone)) };\n+    (_) => { tt2ts!(Punct::new('_', Spacing::Alone)) };\n     (0) => { tt2ts!(Literal::i8_unsuffixed(0)) };\n-    (&) => { tt2ts!(Op::new('&', Spacing::Alone)) };\n-    ($i:ident) => { tt2ts!(Term::new(stringify!($i), Span::def_site())) };\n+    (&) => { tt2ts!(Punct::new('&', Spacing::Alone)) };\n+    ($i:ident) => { tt2ts!(Ident::new(stringify!($i), Span::def_site())) };\n }\n \n macro_rules! quote_tree {\n@@ -110,15 +111,15 @@ impl Quote for TokenStream {\n             if after_dollar {\n                 after_dollar = false;\n                 match tree {\n-                    TokenTree::Term(_) => {\n+                    TokenTree::Ident(_) => {\n                         let tree = TokenStream::from(tree);\n                         return Some(quote!(::__internal::unquote(&(unquote tree)),));\n                     }\n-                    TokenTree::Op(ref tt) if tt.op() == '$' => {}\n+                    TokenTree::Punct(ref tt) if tt.as_char() == '$' => {}\n                     _ => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n                 }\n-            } else if let TokenTree::Op(tt) = tree {\n-                if tt.op() == '$' {\n+            } else if let TokenTree::Punct(ref tt) = tree {\n+                if tt.as_char() == '$' {\n                     after_dollar = true;\n                     return None;\n                 }\n@@ -143,9 +144,9 @@ impl Quote for TokenStream {\n impl Quote for TokenTree {\n     fn quote(self) -> TokenStream {\n         match self {\n-            TokenTree::Op(tt) => quote!(::TokenTree::Op( (quote tt) )),\n+            TokenTree::Punct(tt) => quote!(::TokenTree::Punct( (quote tt) )),\n             TokenTree::Group(tt) => quote!(::TokenTree::Group( (quote tt) )),\n-            TokenTree::Term(tt) => quote!(::TokenTree::Term( (quote tt) )),\n+            TokenTree::Ident(tt) => quote!(::TokenTree::Ident( (quote tt) )),\n             TokenTree::Literal(tt) => quote!(::TokenTree::Literal( (quote tt) )),\n         }\n     }\n@@ -175,15 +176,15 @@ impl Quote for Group {\n     }\n }\n \n-impl Quote for Op {\n+impl Quote for Punct {\n     fn quote(self) -> TokenStream {\n-        quote!(::Op::new((quote self.op()), (quote self.spacing())))\n+        quote!(::Punct::new((quote self.as_char()), (quote self.spacing())))\n     }\n }\n \n-impl Quote for Term {\n+impl Quote for Ident {\n     fn quote(self) -> TokenStream {\n-        quote!(::Term::new((quote self.sym.as_str()), (quote self.span())))\n+        quote!(::Ident::new((quote self.sym.as_str()), (quote self.span())))\n     }\n }\n \n@@ -195,14 +196,32 @@ impl Quote for Span {\n \n macro_rules! literals {\n     ($($i:ident),*; $($raw:ident),*) => {\n+        pub struct SpannedSymbol {\n+            sym: Symbol,\n+            span: Span,\n+        }\n+\n+        impl SpannedSymbol {\n+            pub fn new(string: &str, span: Span) -> SpannedSymbol {\n+                SpannedSymbol { sym: Symbol::intern(string), span }\n+            }\n+        }\n+\n+        impl Quote for SpannedSymbol {\n+            fn quote(self) -> TokenStream {\n+                quote!(::__internal::SpannedSymbol::new((quote self.sym.as_str()),\n+                                                        (quote self.span)))\n+            }\n+        }\n+\n         pub enum LiteralKind {\n             $($i,)*\n             $($raw(u16),)*\n         }\n \n         impl LiteralKind {\n-            pub fn with_contents_and_suffix(self, contents: Term, suffix: Option<Term>)\n-                                            -> Literal {\n+            pub fn with_contents_and_suffix(self, contents: SpannedSymbol,\n+                                            suffix: Option<SpannedSymbol>) -> Literal {\n                 let sym = contents.sym;\n                 let suffix = suffix.map(|t| t.sym);\n                 match self {\n@@ -225,13 +244,14 @@ macro_rules! literals {\n         }\n \n         impl Literal {\n-            fn kind_contents_and_suffix(self) -> (LiteralKind, Term, Option<Term>) {\n+            fn kind_contents_and_suffix(self) -> (LiteralKind, SpannedSymbol, Option<SpannedSymbol>)\n+            {\n                 let (kind, contents) = match self.lit {\n                     $(token::Lit::$i(contents) => (LiteralKind::$i, contents),)*\n                     $(token::Lit::$raw(contents, n) => (LiteralKind::$raw(n), contents),)*\n                 };\n-                let suffix = self.suffix.map(|sym| Term::new(&sym.as_str(), self.span()));\n-                (kind, Term::new(&contents.as_str(), self.span()), suffix)\n+                let suffix = self.suffix.map(|sym| SpannedSymbol::new(&sym.as_str(), self.span()));\n+                (kind, SpannedSymbol::new(&contents.as_str(), self.span()), suffix)\n             }\n         }\n "}, {"sha": "f56d701b028794fc629569d6529896db43eab697", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -314,6 +314,7 @@ fn hash_token<'a, 'gcx, W: StableHasherResult>(\n         token::Token::Pound |\n         token::Token::Dollar |\n         token::Token::Question |\n+        token::Token::SingleQuote |\n         token::Token::Whitespace |\n         token::Token::Comment |\n         token::Token::Eof => {}"}, {"sha": "cff89b03e3d8b3532638c76f40aa45e3dea46357", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -353,7 +353,7 @@ impl<'a> Classifier<'a> {\n             token::Lifetime(..) => Class::Lifetime,\n \n             token::Eof | token::Interpolated(..) |\n-            token::Tilde | token::At | token::DotEq => Class::None,\n+            token::Tilde | token::At | token::DotEq | token::SingleQuote => Class::None,\n         };\n \n         // Anything that didn't return above is the simple case where we the"}, {"sha": "a6e6ccde72c9f46b2b0a54b0fbf82d7c9497a9e8", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -711,6 +711,7 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::Pound        => \"Pound\",\n         token::Dollar       => \"Dollar\",\n         token::Question     => \"Question\",\n+        token::SingleQuote  => \"SingleQuote\",\n         token::Eof          => \"Eof\",\n \n         token::Whitespace | token::Comment | token::Shebang(_) => {"}, {"sha": "3e22598043a3ed1cfef9adf8c5d17626ef778357", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -1770,6 +1770,12 @@ fn ident_continue(c: Option<char>) -> bool {\n     (c > '\\x7f' && c.is_xid_continue())\n }\n \n+// The string is a valid identifier or a lifetime identifier.\n+pub fn is_valid_ident(s: &str) -> bool {\n+    let mut chars = s.chars();\n+    ident_start(chars.next()) && chars.all(|ch| ident_continue(Some(ch)))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "a1c056cbb2ccbbb368627aedf17af5dff840ad16", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -210,6 +210,8 @@ pub enum Token {\n     Pound,\n     Dollar,\n     Question,\n+    /// Used by proc macros for representing lifetimes, not generated by lexer right now.\n+    SingleQuote,\n     /// An opening delimiter, eg. `{`\n     OpenDelim(DelimToken),\n     /// A closing delimiter, eg. `}`\n@@ -513,6 +515,10 @@ impl Token {\n                 Colon => ModSep,\n                 _ => return None,\n             },\n+            SingleQuote => match joint {\n+                Ident(ident, false) => Lifetime(ident),\n+                _ => return None,\n+            },\n \n             Le | EqEq | Ne | Ge | AndAnd | OrOr | Tilde | BinOpEq(..) | At | DotDotDot | DotEq |\n             DotDotEq | Comma | Semi | ModSep | RArrow | LArrow | FatArrow | Pound | Dollar |"}, {"sha": "8e33fa08083967689644a66c597c54ff761098ef", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -224,6 +224,7 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Pound                => \"#\".to_string(),\n         token::Dollar               => \"$\".to_string(),\n         token::Question             => \"?\".to_string(),\n+        token::SingleQuote          => \"'\".to_string(),\n \n         /* Literals */\n         token::Literal(lit, suf) => {"}, {"sha": "f3f7cb1406cbd26359449f582cc13f78040d4492", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attributes-included.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -53,7 +53,7 @@ pub fn bar(attr: TokenStream, input: TokenStream) -> TokenStream {\n \n fn assert_inline(slice: &mut &[TokenTree]) {\n     match &slice[0] {\n-        TokenTree::Op(tt) => assert_eq!(tt.op(), '#'),\n+        TokenTree::Punct(tt) => assert_eq!(tt.as_char(), '#'),\n         _ => panic!(\"expected '#' char\"),\n     }\n     match &slice[1] {\n@@ -65,8 +65,8 @@ fn assert_inline(slice: &mut &[TokenTree]) {\n \n fn assert_doc(slice: &mut &[TokenTree]) {\n     match &slice[0] {\n-        TokenTree::Op(tt) => {\n-            assert_eq!(tt.op(), '#');\n+        TokenTree::Punct(tt) => {\n+            assert_eq!(tt.as_char(), '#');\n             assert_eq!(tt.spacing(), Spacing::Alone);\n         }\n         _ => panic!(\"expected #\"),\n@@ -86,12 +86,12 @@ fn assert_doc(slice: &mut &[TokenTree]) {\n     }\n \n     match &tokens[0] {\n-        TokenTree::Term(tt) => assert_eq!(\"doc\", &*tt.to_string()),\n+        TokenTree::Ident(tt) => assert_eq!(\"doc\", &*tt.to_string()),\n         _ => panic!(\"expected `doc`\"),\n     }\n     match &tokens[1] {\n-        TokenTree::Op(tt) => {\n-            assert_eq!(tt.op(), '=');\n+        TokenTree::Punct(tt) => {\n+            assert_eq!(tt.as_char(), '=');\n             assert_eq!(tt.spacing(), Spacing::Alone);\n         }\n         _ => panic!(\"expected equals\"),\n@@ -106,7 +106,7 @@ fn assert_doc(slice: &mut &[TokenTree]) {\n \n fn assert_invoc(slice: &mut &[TokenTree]) {\n     match &slice[0] {\n-        TokenTree::Op(tt) => assert_eq!(tt.op(), '#'),\n+        TokenTree::Punct(tt) => assert_eq!(tt.as_char(), '#'),\n         _ => panic!(\"expected '#' char\"),\n     }\n     match &slice[1] {\n@@ -118,11 +118,11 @@ fn assert_invoc(slice: &mut &[TokenTree]) {\n \n fn assert_foo(slice: &mut &[TokenTree]) {\n     match &slice[0] {\n-        TokenTree::Term(tt) => assert_eq!(&*tt.to_string(), \"fn\"),\n+        TokenTree::Ident(tt) => assert_eq!(&*tt.to_string(), \"fn\"),\n         _ => panic!(\"expected fn\"),\n     }\n     match &slice[1] {\n-        TokenTree::Term(tt) => assert_eq!(&*tt.to_string(), \"foo\"),\n+        TokenTree::Ident(tt) => assert_eq!(&*tt.to_string(), \"foo\"),\n         _ => panic!(\"expected foo\"),\n     }\n     match &slice[2] {\n@@ -148,8 +148,8 @@ fn fold_tree(input: TokenTree) -> TokenTree {\n         TokenTree::Group(b) => {\n             TokenTree::Group(Group::new(b.delimiter(), fold_stream(b.stream())))\n         }\n-        TokenTree::Op(b) => TokenTree::Op(b),\n-        TokenTree::Term(a) => TokenTree::Term(a),\n+        TokenTree::Punct(b) => TokenTree::Punct(b),\n+        TokenTree::Ident(a) => TokenTree::Ident(a),\n         TokenTree::Literal(a) => {\n             if a.to_string() != \"\\\"foo\\\"\" {\n                 TokenTree::Literal(a)"}, {"sha": "e1a7ffaa26cb7851a3b31117fc7a299b78806661", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/issue_38586.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue_38586.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue_38586.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue_38586.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,6 @@\n // force-host\n // no-prefer-dynamic\n \n-#![feature(proc_macro, proc_macro_lib)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "2d843d0e466525784b466b8125b6df32d2079c26", "filename": "src/test/compile-fail-fulldeps/proc-macro/issue-38586.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-38586.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-38586.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-38586.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,8 +11,6 @@\n // aux-build:issue_38586.rs\n // ignore-stage1\n \n-#![feature(proc_macro)]\n-\n #[macro_use]\n extern crate issue_38586;\n "}, {"sha": "98e50183097cce111dae113a677ad97defa18c50", "filename": "src/test/compile-fail-fulldeps/proc-macro/lints_in_proc_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Flints_in_proc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Flints_in_proc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Flints_in_proc_macros.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // aux-build:bang_proc_macro2.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_non_items)]\n #![allow(unused_macros)]\n \n extern crate bang_proc_macro2;"}, {"sha": "be5b8c39f1ddecc802971392ee759e376459916b", "filename": "src/test/compile-fail-fulldeps/proc-macro/macro-use-bang.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-bang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-bang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-bang.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:bang_proc_macro.rs\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(proc_macro_non_items)]\n \n #[macro_use]\n extern crate bang_proc_macro;"}, {"sha": "ef6d4557f4cd746f7b59c6e107739929469fd91f", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-gates2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates2.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:proc-macro-gates.rs\n \n-#![feature(proc_macro, stmt_expr_attributes)]\n+#![feature(use_extern_macros, stmt_expr_attributes)]\n \n extern crate proc_macro_gates as foo;\n "}, {"sha": "ec6f54fb1378f4d703bf1cb33edec5b78da1f725", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -33,7 +33,7 @@ pub fn cond(input: TokenStream) -> TokenStream {\n             panic!(\"Invalid macro usage in cond: {}\", cond);\n         }\n         let is_else = match test {\n-            TokenTree::Term(word) => &*word.to_string() == \"else\",\n+            TokenTree::Ident(ref word) => &*word.to_string() == \"else\",\n             _ => false,\n         };\n         conds.push(if is_else || input.peek().is_none() {"}, {"sha": "f026d8e2365d9953ebc1b07ca2e6a88bf87379fe", "filename": "src/test/run-pass-fulldeps/auxiliary/hello_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro, proc_macro_lib, proc_macro_non_items)]\n+#![feature(proc_macro, proc_macro_non_items)]\n \n extern crate proc_macro;\n "}, {"sha": "9a5bffb92a4937112106c1fc937781d858df5d29", "filename": "src/test/run-pass-fulldeps/auxiliary/proc_macro_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro, proc_macro_lib, proc_macro_non_items)]\n+#![feature(proc_macro, proc_macro_non_items)]\n \n extern crate proc_macro;\n "}, {"sha": "f1dcec8af6906a5478fabcce97cc7a8c58a690fe", "filename": "src/test/run-pass-fulldeps/macro-quote-cond.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-cond.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // aux-build:cond_plugin.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_non_items)]\n \n extern crate cond_plugin;\n "}, {"sha": "1f6a340c7e88bd93ace0b5e1b880cbc7a37581f2", "filename": "src/test/run-pass-fulldeps/macro-quote-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-test.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -13,7 +13,7 @@\n // aux-build:hello_macro.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_non_items)]\n \n extern crate hello_macro;\n "}, {"sha": "55c4c32a94d80c8e85610cac5db99fa98cec606c", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/count_compound_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -28,7 +28,7 @@ fn count_compound_ops_helper(input: TokenStream) -> u32 {\n     let mut count = 0;\n     for token in input {\n         match &token {\n-            TokenTree::Op(tt) if tt.spacing() == Spacing::Alone => {\n+            TokenTree::Punct(tt) if tt.spacing() == Spacing::Alone => {\n                 count += 1;\n             }\n             TokenTree::Group(tt) => {"}, {"sha": "2b413579a9a0f4387ff64e9f5679db2101b050e5", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-attr-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-attr-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-attr-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-attr-cfg.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // no-prefer-dynamic\n-#![feature(proc_macro)]\n+\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "bac6524847a887f30f68918e2d398df5cee80a0f", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/hygiene_example.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fhygiene_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fhygiene_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fhygiene_example.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n extern crate hygiene_example_codegen;\n "}, {"sha": "f31f57b442a6e502fc1f22bede636c3db08607ce", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/lifetimes.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Flifetimes.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::*;\n+\n+#[proc_macro]\n+pub fn lifetimes_bang(input: TokenStream) -> TokenStream {\n+    // Roundtrip through token trees\n+    input.into_iter().collect()\n+}\n+\n+#[proc_macro_attribute]\n+pub fn lifetimes_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n+    // Roundtrip through AST\n+    input\n+}\n+\n+#[proc_macro_derive(Lifetimes)]\n+pub fn lifetimes_derive(input: TokenStream) -> TokenStream {\n+    // Roundtrip through a string\n+    format!(\"mod m {{ {} }}\", input).parse().unwrap()\n+}"}, {"sha": "fb505755792321d7d3b156816daca4d96d8a449a", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/modify-ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -38,14 +38,14 @@ fn assert_eq(a: TokenStream, b: TokenStream) {\n                 assert_eq!(a.delimiter(), b.delimiter());\n                 assert_eq(a.stream(), b.stream());\n             }\n-            (TokenTree::Op(a), TokenTree::Op(b)) => {\n-                assert_eq!(a.op(), b.op());\n+            (TokenTree::Punct(a), TokenTree::Punct(b)) => {\n+                assert_eq!(a.as_char(), b.as_char());\n                 assert_eq!(a.spacing(), b.spacing());\n             }\n             (TokenTree::Literal(a), TokenTree::Literal(b)) => {\n                 assert_eq!(a.to_string(), b.to_string());\n             }\n-            (TokenTree::Term(a), TokenTree::Term(b)) => {\n+            (TokenTree::Ident(a), TokenTree::Ident(b)) => {\n                 assert_eq!(a.to_string(), b.to_string());\n             }\n             (a, b) => panic!(\"{:?} != {:?}\", a, b),"}, {"sha": "f9d17a9decbb6b5134775e8f0ca018dfdfb9f02f", "filename": "src/test/run-pass-fulldeps/proc-macro/bang-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fbang-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fbang-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fbang-macro.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // aux-build:bang-macro.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_non_items)]\n \n extern crate bang_macro;\n use bang_macro::rewrite;"}, {"sha": "f4a51d0624ae6152af9ed255e8abda7eb365d3ba", "filename": "src/test/run-pass-fulldeps/proc-macro/count_compound_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcount_compound_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcount_compound_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcount_compound_ops.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // aux-build:count_compound_ops.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_non_items)]\n \n extern crate count_compound_ops;\n use count_compound_ops::count_compound_ops;"}, {"sha": "6ef23bc772b5c26ab5cbce89ba9dfb1f2bcff5fe", "filename": "src/test/run-pass-fulldeps/proc-macro/derive-attr-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-attr-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-attr-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-attr-cfg.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // aux-build:derive-attr-cfg.rs\n // ignore-stage1\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n extern crate derive_attr_cfg;\n use derive_attr_cfg::Foo;"}, {"sha": "5ee164415a1a583770f2f6aa1a21e674483e27e3", "filename": "src/test/run-pass-fulldeps/proc-macro/hygiene_example.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fhygiene_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fhygiene_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fhygiene_example.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -12,7 +12,7 @@\n // aux-build:hygiene_example.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_non_items)]\n \n extern crate hygiene_example;\n use hygiene_example::hello;"}, {"sha": "5b7d8c2b05b69123bcf4c6d3929ba9225070d7b3", "filename": "src/test/run-pass-fulldeps/proc-macro/issue-39889.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-39889.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-39889.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-39889.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // aux-build:issue-39889.rs\n // ignore-stage1\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n #![allow(unused)]\n \n extern crate issue_39889;"}, {"sha": "b828199883fa081108077eb6560e0d191a858fe5", "filename": "src/test/run-pass-fulldeps/proc-macro/issue-40001.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-40001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-40001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-40001.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // aux-build:issue-40001-plugin.rs\n // ignore-stage1\n \n-#![feature(proc_macro, plugin)]\n+#![feature(plugin)]\n #![plugin(issue_40001_plugin)]\n \n #[whitelisted_attr]"}, {"sha": "0bcb23cc8bb7dea7c5a96b2bbd87499063ecdb30", "filename": "src/test/run-pass-fulldeps/proc-macro/lifetimes.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Flifetimes.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lifetimes.rs\n+// ignore-stage1\n+\n+#![feature(proc_macro)]\n+\n+extern crate lifetimes;\n+use lifetimes::*;\n+\n+lifetimes_bang! {\n+    fn bang<'a>() -> &'a u8 { &0 }\n+}\n+\n+#[lifetimes_attr]\n+fn attr<'a>() -> &'a u8 { &1 }\n+\n+#[derive(Lifetimes)]\n+pub struct Lifetimes<'a> {\n+    pub field: &'a u8,\n+}\n+\n+fn main() {\n+    assert_eq!(bang::<'static>(), &0);\n+    assert_eq!(attr::<'static>(), &1);\n+    let l1 = Lifetimes { field: &0 };\n+    let l2 = m::Lifetimes { field: &1 };\n+}"}, {"sha": "a793d069d1448b8551eca130d8258daaf4a55d1a", "filename": "src/test/run-pass-fulldeps/proc-macro/negative-token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fnegative-token.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fnegative-token.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fnegative-token.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // aux-build:negative-token.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(proc_macro_non_items)]\n \n extern crate negative_token;\n "}, {"sha": "735e088b82a50354f72812dcda1e4949fb7d5522", "filename": "src/test/run-pass-fulldeps/proc-macro/span-api-tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fspan-api-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fspan-api-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fspan-api-tests.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -13,7 +13,7 @@\n \n // ignore-pretty\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n #[macro_use]\n extern crate span_test_macros;"}, {"sha": "6bdfe5f86aadb0e840323de56ac8a4fd847b53bb", "filename": "src/test/ui-fulldeps/auxiliary/invalid-punct-ident.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Finvalid-punct-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Finvalid-punct-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Finvalid-punct-ident.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+pub fn invalid_punct(_: TokenStream) -> TokenStream {\n+    TokenTree::from(Punct::new('`', Spacing::Alone)).into()\n+}\n+\n+#[proc_macro]\n+pub fn invalid_ident(_: TokenStream) -> TokenStream {\n+    TokenTree::from(Ident::new(\"*\", Span::call_site())).into()\n+}\n+\n+#[proc_macro]\n+pub fn invalid_raw_ident(_: TokenStream) -> TokenStream {\n+    TokenTree::from(Ident::new_raw(\"self\", Span::call_site())).into()\n+}\n+\n+#[proc_macro]\n+pub fn lexer_failure(_: TokenStream) -> TokenStream {\n+    \"a b ) c\".parse().expect(\"parsing failed without panic\")\n+}"}, {"sha": "ecf0a56edf7661d30162915e469b4fdf9d732948", "filename": "src/test/ui-fulldeps/auxiliary/lifetimes.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flifetimes.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::*;\n+\n+#[proc_macro]\n+pub fn single_quote_alone(_: TokenStream) -> TokenStream {\n+    // `&'a u8`, but the `'` token is not joint\n+    let trees: Vec<TokenTree> = vec![\n+        Punct::new('&', Spacing::Alone).into(),\n+        Punct::new('\\'', Spacing::Alone).into(),\n+        Ident::new(\"a\", Span::call_site()).into(),\n+        Ident::new(\"u8\", Span::call_site()).into(),\n+    ];\n+    trees.into_iter().collect()\n+}"}, {"sha": "7be909c3c9e87f6a4322719fa241f0a3fe989fc8", "filename": "src/test/ui-fulldeps/custom-derive/auxiliary/plugin.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fauxiliary%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fauxiliary%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fauxiliary%2Fplugin.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro, proc_macro_lib)]\n \n extern crate proc_macro;\n "}, {"sha": "5ec79a5520009a27c7801afd12a7925d86adcb6f", "filename": "src/test/ui-fulldeps/custom-derive/issue-36935.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fissue-36935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fissue-36935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fissue-36935.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,8 +11,6 @@\n // aux-build:plugin.rs\n // ignore-stage1\n \n-#![feature(proc_macro)]\n-\n #[macro_use] extern crate plugin;\n \n #[derive(Foo, Bar)] //~ ERROR proc-macro derive panicked"}, {"sha": "ecbe0a9a0c079e04e655428c9bb136c7b5546ab2", "filename": "src/test/ui-fulldeps/custom-derive/issue-36935.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fissue-36935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fissue-36935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fissue-36935.stderr?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -1,5 +1,5 @@\n error: proc-macro derive panicked\n-  --> $DIR/issue-36935.rs:18:15\n+  --> $DIR/issue-36935.rs:16:15\n    |\n LL | #[derive(Foo, Bar)] //~ ERROR proc-macro derive panicked\n    |               ^^^"}, {"sha": "576c156c1059e01c7fc6e36b050eef6e4f93bffc", "filename": "src/test/ui-fulldeps/invalid-punct-ident-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-1.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:invalid-punct-ident.rs\n+\n+#[macro_use]\n+extern crate invalid_punct_ident;\n+\n+invalid_punct!(); //~ ERROR proc macro panicked"}, {"sha": "3b3619e2637f88ca62747c0995ae89bfa93cddbd", "filename": "src/test/ui-fulldeps/invalid-punct-ident-1.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-1.stderr?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,10 @@\n+error: proc macro panicked\n+  --> $DIR/invalid-punct-ident-1.rs:16:1\n+   |\n+LL | invalid_punct!(); //~ ERROR proc macro panicked\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: message: unsupported character `'`'`\n+\n+error: aborting due to previous error\n+"}, {"sha": "874a7d169d19dceec39638732336ab5e16198b00", "filename": "src/test/ui-fulldeps/invalid-punct-ident-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-2.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:invalid-punct-ident.rs\n+\n+#[macro_use]\n+extern crate invalid_punct_ident;\n+\n+invalid_ident!(); //~ ERROR proc macro panicked"}, {"sha": "869c0908bb51a6d1793e8137ec1f6a4415c687b5", "filename": "src/test/ui-fulldeps/invalid-punct-ident-2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-2.stderr?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,10 @@\n+error: proc macro panicked\n+  --> $DIR/invalid-punct-ident-2.rs:16:1\n+   |\n+LL | invalid_ident!(); //~ ERROR proc macro panicked\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: message: `\"*\"` is not a valid identifier\n+\n+error: aborting due to previous error\n+"}, {"sha": "f73bf500545d52f08032bbdfd53417dae40d0a52", "filename": "src/test/ui-fulldeps/invalid-punct-ident-3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-3.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:invalid-punct-ident.rs\n+\n+#[macro_use]\n+extern crate invalid_punct_ident;\n+\n+invalid_raw_ident!(); //~ ERROR proc macro panicked"}, {"sha": "716f6ffa098203255685bbda8a82ad70498de7d3", "filename": "src/test/ui-fulldeps/invalid-punct-ident-3.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-3.stderr?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,10 @@\n+error: proc macro panicked\n+  --> $DIR/invalid-punct-ident-3.rs:16:1\n+   |\n+LL | invalid_raw_ident!(); //~ ERROR proc macro panicked\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: message: `\"self\"` is not a valid raw identifier\n+\n+error: aborting due to previous error\n+"}, {"sha": "1e93c69c6502c3dc840d94d1553c268f1e695314", "filename": "src/test/ui-fulldeps/invalid-punct-ident-4.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-4.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:invalid-punct-ident.rs\n+\n+#[macro_use]\n+extern crate invalid_punct_ident;\n+\n+lexer_failure!(); //~ ERROR proc macro panicked\n+                  //~| ERROR unexpected close delimiter: `)`"}, {"sha": "4493e37eeb2739ed877dd1776b298c3540093dda", "filename": "src/test/ui-fulldeps/invalid-punct-ident-4.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finvalid-punct-ident-4.stderr?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,14 @@\n+error: unexpected close delimiter: `)`\n+  --> $DIR/invalid-punct-ident-4.rs:16:1\n+   |\n+LL | lexer_failure!(); //~ ERROR proc macro panicked\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error: proc macro panicked\n+  --> $DIR/invalid-punct-ident-4.rs:16:1\n+   |\n+LL | lexer_failure!(); //~ ERROR proc macro panicked\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "6e88143d637f142b6d65a5546181d7164cf751a1", "filename": "src/test/ui-fulldeps/lifetimes.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flifetimes.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lifetimes.rs\n+\n+#![feature(proc_macro, proc_macro_non_items)]\n+\n+extern crate lifetimes;\n+\n+use lifetimes::*;\n+\n+type A = single_quote_alone!(); //~ ERROR expected type, found `'`"}, {"sha": "6baf2b16998f17e62b27c12e3862a11dede4f989", "filename": "src/test/ui-fulldeps/lifetimes.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Flifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Flifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flifetimes.stderr?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -0,0 +1,8 @@\n+error: expected type, found `'`\n+  --> $DIR/lifetimes.rs:19:10\n+   |\n+LL | type A = single_quote_alone!(); //~ ERROR expected type, found `'`\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "8dfb9cb4fb751b6e971fa4d24379b36597db4b6a", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/three-equals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -27,8 +27,8 @@ fn parse(input: TokenStream) -> Result<(), Diagnostic> {\n                            .help(\"input must be: `===`\"))\n         }\n \n-        if let TokenTree::Op(tt) = tree {\n-            if tt.op() == '=' {\n+        if let TokenTree::Punct(ref tt) = tree {\n+            if tt.as_char() == '=' {\n                 count += 1;\n                 last_span = span;\n                 continue"}, {"sha": "a60841d848c16363ac56f08e03cd04abf7d2e858", "filename": "src/test/ui-fulldeps/proc-macro/parent-source-spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fparent-source-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fparent-source-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fparent-source-spans.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // aux-build:parent-source-spans.rs\n // ignore-stage1\n \n-#![feature(proc_macro, decl_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, decl_macro, proc_macro_non_items)]\n \n extern crate parent_source_spans;\n "}, {"sha": "ee5f3b33a0648c739473f33c12a4aac83985a6cd", "filename": "src/test/ui-fulldeps/proc-macro/three-equals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fthree-equals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fthree-equals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fthree-equals.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -11,7 +11,7 @@\n // aux-build:three-equals.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_non_items)]\n \n extern crate three_equals;\n "}, {"sha": "9cc825fcddd7afad40c7cdcf1e1cda99a4dd1f72", "filename": "src/test/ui-fulldeps/resolve-error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fresolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fresolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fresolve-error.rs?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -14,7 +14,6 @@\n // aux-build:bang_proc_macro.rs\n \n #![feature(proc_macro)]\n-#![allow(unused_macros)]\n \n #[macro_use]\n extern crate derive_foo;"}, {"sha": "caa7966461487211532de3f7e9d41194b2c283bf", "filename": "src/test/ui-fulldeps/resolve-error.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fresolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a3f5367a23a769a068c37460db336de427c4b48/src%2Ftest%2Fui-fulldeps%2Fresolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fresolve-error.stderr?ref=2a3f5367a23a769a068c37460db336de427c4b48", "patch": "@@ -1,59 +1,59 @@\n error: cannot find derive macro `FooWithLongNan` in this scope\n-  --> $DIR/resolve-error.rs:37:10\n+  --> $DIR/resolve-error.rs:36:10\n    |\n LL | #[derive(FooWithLongNan)]\n    |          ^^^^^^^^^^^^^^ help: try: `FooWithLongName`\n \n error: cannot find attribute macro `attr_proc_macra` in this scope\n-  --> $DIR/resolve-error.rs:41:3\n+  --> $DIR/resolve-error.rs:40:3\n    |\n LL | #[attr_proc_macra]\n    |   ^^^^^^^^^^^^^^^ help: try: `attr_proc_macro`\n \n error: cannot find attribute macro `FooWithLongNan` in this scope\n-  --> $DIR/resolve-error.rs:45:3\n+  --> $DIR/resolve-error.rs:44:3\n    |\n LL | #[FooWithLongNan]\n    |   ^^^^^^^^^^^^^^\n \n error: cannot find derive macro `Dlone` in this scope\n-  --> $DIR/resolve-error.rs:49:10\n+  --> $DIR/resolve-error.rs:48:10\n    |\n LL | #[derive(Dlone)]\n    |          ^^^^^ help: try: `Clone`\n \n error: cannot find derive macro `Dlona` in this scope\n-  --> $DIR/resolve-error.rs:53:10\n+  --> $DIR/resolve-error.rs:52:10\n    |\n LL | #[derive(Dlona)]\n    |          ^^^^^ help: try: `Clona`\n \n error: cannot find derive macro `attr_proc_macra` in this scope\n-  --> $DIR/resolve-error.rs:57:10\n+  --> $DIR/resolve-error.rs:56:10\n    |\n LL | #[derive(attr_proc_macra)]\n    |          ^^^^^^^^^^^^^^^\n \n error: cannot find macro `FooWithLongNama!` in this scope\n-  --> $DIR/resolve-error.rs:62:5\n+  --> $DIR/resolve-error.rs:61:5\n    |\n LL |     FooWithLongNama!();\n    |     ^^^^^^^^^^^^^^^ help: you could try the macro: `FooWithLongNam`\n \n error: cannot find macro `attr_proc_macra!` in this scope\n-  --> $DIR/resolve-error.rs:65:5\n+  --> $DIR/resolve-error.rs:64:5\n    |\n LL |     attr_proc_macra!();\n    |     ^^^^^^^^^^^^^^^ help: you could try the macro: `attr_proc_mac`\n \n error: cannot find macro `Dlona!` in this scope\n-  --> $DIR/resolve-error.rs:68:5\n+  --> $DIR/resolve-error.rs:67:5\n    |\n LL |     Dlona!();\n    |     ^^^^^\n \n error: cannot find macro `bang_proc_macrp!` in this scope\n-  --> $DIR/resolve-error.rs:71:5\n+  --> $DIR/resolve-error.rs:70:5\n    |\n LL |     bang_proc_macrp!();\n    |     ^^^^^^^^^^^^^^^ help: you could try the macro: `bang_proc_macro`"}]}