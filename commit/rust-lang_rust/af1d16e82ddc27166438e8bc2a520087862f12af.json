{"sha": "af1d16e82ddc27166438e8bc2a520087862f12af", "node_id": "C_kwDOAAsO6NoAKGFmMWQxNmU4MmRkYzI3MTY2NDM4ZThiYzJhNTIwMDg3ODYyZjEyYWY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-01-31T23:53:00Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-02-02T23:06:52Z"}, "message": "Improve doc comment desugaring.\n\nSometimes the parser needs to desugar a doc comment into `#[doc =\nr\"foo\"]`. Currently it does this in a hacky way: by pushing a \"fake\" new\nframe (one without a delimiter) onto the `TokenCursor` stack.\n\nThis commit changes things so that the token stream itself is modified\nin place. The nice thing about this is that it means\n`TokenCursorFrame::delim_sp` is now only `None` for the outermost frame.", "tree": {"sha": "09ecefef955ad55a2b81a0dc604d0e79a0c0968e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09ecefef955ad55a2b81a0dc604d0e79a0c0968e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af1d16e82ddc27166438e8bc2a520087862f12af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af1d16e82ddc27166438e8bc2a520087862f12af", "html_url": "https://github.com/rust-lang/rust/commit/af1d16e82ddc27166438e8bc2a520087862f12af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af1d16e82ddc27166438e8bc2a520087862f12af/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "html_url": "https://github.com/rust-lang/rust/commit/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc"}], "stats": {"total": 57, "additions": 30, "deletions": 27}, "files": [{"sha": "dd01fc8ffc506db7b26bd63a1cf94af6286e3709", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af1d16e82ddc27166438e8bc2a520087862f12af/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1d16e82ddc27166438e8bc2a520087862f12af/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=af1d16e82ddc27166438e8bc2a520087862f12af", "patch": "@@ -614,6 +614,15 @@ impl Cursor {\n     pub fn look_ahead(&self, n: usize) -> Option<&TokenTree> {\n         self.stream.0.get(self.index + n)\n     }\n+\n+    // Replace the previously obtained token tree with `tts`, and rewind to\n+    // just before them.\n+    pub fn replace_prev_and_rewind(&mut self, tts: Vec<TokenTree>) {\n+        assert!(self.index > 0);\n+        self.index -= 1;\n+        let stream = Lrc::make_mut(&mut self.stream.0);\n+        stream.splice(self.index..self.index + 1, tts);\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]"}, {"sha": "0499a56a09db46afd3be2d864170511e51c0aad5", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/af1d16e82ddc27166438e8bc2a520087862f12af/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1d16e82ddc27166438e8bc2a520087862f12af/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=af1d16e82ddc27166438e8bc2a520087862f12af", "patch": "@@ -224,7 +224,7 @@ impl<'a> Drop for Parser<'a> {\n #[derive(Clone)]\n struct TokenCursor {\n     // The current (innermost) frame. `frame` and `stack` could be combined,\n-    // but it's faster to have them separately to access `frame` directly\n+    // but it's faster to keep them separate and access `frame` directly\n     // rather than via something like `stack.last().unwrap()` or\n     // `stack[stack.len() - 1]`.\n     frame: TokenCursorFrame,\n@@ -259,6 +259,7 @@ struct TokenCursor {\n \n #[derive(Clone)]\n struct TokenCursorFrame {\n+    // This is `None` only for the outermost frame.\n     delim_sp: Option<(Delimiter, DelimSpan)>,\n     tree_cursor: tokenstream::Cursor,\n }\n@@ -285,7 +286,9 @@ impl TokenCursor {\n                 match tree {\n                     &TokenTree::Token(ref token, spacing) => match (desugar_doc_comments, token) {\n                         (true, &Token { kind: token::DocComment(_, attr_style, data), span }) => {\n-                            return self.desugar(attr_style, data, span);\n+                            let desugared = self.desugar(attr_style, data, span);\n+                            self.frame.tree_cursor.replace_prev_and_rewind(desugared);\n+                            // Continue to get the first token of the desugared doc comment.\n                         }\n                         _ => return (token.clone(), spacing),\n                     },\n@@ -300,19 +303,22 @@ impl TokenCursor {\n                     }\n                 };\n             } else if let Some(frame) = self.stack.pop() {\n-                if let Some((delim, span)) = self.frame.delim_sp && delim != Delimiter::Invisible {\n-                    self.frame = frame;\n+                // We have exhausted this frame. Move back to its parent frame.\n+                let (delim, span) = self.frame.delim_sp.unwrap();\n+                self.frame = frame;\n+                if delim != Delimiter::Invisible {\n                     return (Token::new(token::CloseDelim(delim), span.close), Spacing::Alone);\n                 }\n-                self.frame = frame;\n                 // No close delimiter to return; continue on to the next iteration.\n             } else {\n+                // We have exhausted the outermost frame.\n                 return (Token::new(token::Eof, DUMMY_SP), Spacing::Alone);\n             }\n         }\n     }\n \n-    fn desugar(&mut self, attr_style: AttrStyle, data: Symbol, span: Span) -> (Token, Spacing) {\n+    // Desugar a doc comment into something like `#[doc = r\"foo\"]`.\n+    fn desugar(&mut self, attr_style: AttrStyle, data: Symbol, span: Span) -> Vec<TokenTree> {\n         // Searches for the occurrences of `\"#*` and returns the minimum number of `#`s\n         // required to wrap the text. E.g.\n         // - `abc d` is wrapped as `r\"abc d\"` (num_of_hashes = 0)\n@@ -346,27 +352,15 @@ impl TokenCursor {\n             .collect::<TokenStream>(),\n         );\n \n-        self.stack.push(mem::replace(\n-            &mut self.frame,\n-            TokenCursorFrame::new(\n-                None,\n-                if attr_style == AttrStyle::Inner {\n-                    [\n-                        TokenTree::token_alone(token::Pound, span),\n-                        TokenTree::token_alone(token::Not, span),\n-                        body,\n-                    ]\n-                    .into_iter()\n-                    .collect::<TokenStream>()\n-                } else {\n-                    [TokenTree::token_alone(token::Pound, span), body]\n-                        .into_iter()\n-                        .collect::<TokenStream>()\n-                },\n-            ),\n-        ));\n-\n-        self.next(/* desugar_doc_comments */ false)\n+        if attr_style == AttrStyle::Inner {\n+            vec![\n+                TokenTree::token_alone(token::Pound, span),\n+                TokenTree::token_alone(token::Not, span),\n+                body,\n+            ]\n+        } else {\n+            vec![TokenTree::token_alone(token::Pound, span), body]\n+        }\n     }\n }\n "}]}