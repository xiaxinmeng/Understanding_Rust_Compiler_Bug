{"sha": "a0b4e6764809022433edbff275528ec2540bda73", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwYjRlNjc2NDgwOTAyMjQzM2VkYmZmMjc1NTI4ZWMyNTQwYmRhNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-03T14:52:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-03T14:52:08Z"}, "message": "Auto merge of #35174 - arielb1:llvm-type-audit, r=eddyb\n\nAudit C++ types in rustllvm\n\ncc @eddyb\n\nFixes #35131", "tree": {"sha": "9470236d08b017db44a20795660cd8baacb9e36b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9470236d08b017db44a20795660cd8baacb9e36b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0b4e6764809022433edbff275528ec2540bda73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0b4e6764809022433edbff275528ec2540bda73", "html_url": "https://github.com/rust-lang/rust/commit/a0b4e6764809022433edbff275528ec2540bda73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0b4e6764809022433edbff275528ec2540bda73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cf189701e0a8caacbf106e5bfebfa302570bb81", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cf189701e0a8caacbf106e5bfebfa302570bb81", "html_url": "https://github.com/rust-lang/rust/commit/9cf189701e0a8caacbf106e5bfebfa302570bb81"}, {"sha": "3041a97b1acef4f8549d9e297db8deaf571341f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3041a97b1acef4f8549d9e297db8deaf571341f2", "html_url": "https://github.com/rust-lang/rust/commit/3041a97b1acef4f8549d9e297db8deaf571341f2"}], "stats": {"total": 5593, "additions": 2937, "deletions": 2656}, "files": [{"sha": "b50dbd01ad0cc0071bcf20cf8b5ba366ca724dc2", "filename": "mk/rustllvm.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -24,7 +24,7 @@ LLVM_EXTRA_INCDIRS_$(1)= $$(call CFG_CC_INCLUDE_$(1),$(S)src/llvm/include) \\\n endif\n \n RUSTLLVM_OBJS_CS_$(1) := $$(addprefix rustllvm/, \\\n-\tExecutionEngineWrapper.cpp RustWrapper.cpp PassWrapper.cpp \\\n+\tRustWrapper.cpp PassWrapper.cpp \\\n \tArchiveWrapper.cpp)\n \n RUSTLLVM_INCS_$(1) = $$(LLVM_EXTRA_INCDIRS_$(1)) \\"}, {"sha": "772c59b34dd02725897eca4d397c6d5bac309aa8", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -186,7 +186,7 @@ pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n     let sopts = config::build_session_options(&matches);\n \n     if sopts.debugging_opts.debug_llvm {\n-        unsafe { llvm::LLVMSetDebug(1); }\n+        unsafe { llvm::LLVMRustSetDebug(1); }\n     }\n \n     let descriptions = diagnostics_registry();"}, {"sha": "b8548aaec5bd74d023d99016d3042f1c220913aa", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -112,8 +112,7 @@ fn main() {\n         cfg.flag(&flag);\n     }\n \n-    cfg.file(\"../rustllvm/ExecutionEngineWrapper.cpp\")\n-       .file(\"../rustllvm/PassWrapper.cpp\")\n+    cfg.file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n        .cpp(true)"}, {"sha": "8520ae1df60dd460898aa08fa6549d2bd23b432a", "filename": "src/librustc_llvm/diagnostic.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -16,22 +16,29 @@ pub use self::Diagnostic::*;\n use libc::{c_char, c_uint};\n use std::ptr;\n \n-use {DebugLocRef, DiagnosticInfoRef, TwineRef, ValueRef};\n+use {DiagnosticInfoRef, TwineRef, ValueRef};\n+use ffi::DebugLocRef;\n \n #[derive(Copy, Clone)]\n pub enum OptimizationDiagnosticKind {\n     OptimizationRemark,\n     OptimizationMissed,\n     OptimizationAnalysis,\n+    OptimizationAnalysisFPCommute,\n+    OptimizationAnalysisAliasing,\n     OptimizationFailure,\n+    OptimizationRemarkOther,\n }\n \n impl OptimizationDiagnosticKind {\n     pub fn describe(self) -> &'static str {\n         match self {\n-            OptimizationRemark => \"remark\",\n+            OptimizationRemark |\n+            OptimizationRemarkOther => \"remark\",\n             OptimizationMissed => \"missed\",\n             OptimizationAnalysis => \"analysis\",\n+            OptimizationAnalysisFPCommute => \"floating-point\",\n+            OptimizationAnalysisAliasing => \"aliasing\",\n             OptimizationFailure => \"failure\",\n         }\n     }\n@@ -58,11 +65,11 @@ impl OptimizationDiagnostic {\n             message: ptr::null_mut(),\n         };\n \n-        super::LLVMUnpackOptimizationDiagnostic(di,\n-                                                &mut opt.pass_name,\n-                                                &mut opt.function,\n-                                                &mut opt.debug_loc,\n-                                                &mut opt.message);\n+        super::LLVMRustUnpackOptimizationDiagnostic(di,\n+                                                    &mut opt.pass_name,\n+                                                    &mut opt.function,\n+                                                    &mut opt.debug_loc,\n+                                                    &mut opt.message);\n \n         opt\n     }\n@@ -84,10 +91,10 @@ impl InlineAsmDiagnostic {\n             instruction: ptr::null_mut(),\n         };\n \n-        super::LLVMUnpackInlineAsmDiagnostic(di,\n-                                             &mut opt.cookie,\n-                                             &mut opt.message,\n-                                             &mut opt.instruction);\n+        super::LLVMRustUnpackInlineAsmDiagnostic(di,\n+                                                 &mut opt.cookie,\n+                                                 &mut opt.message,\n+                                                 &mut opt.instruction);\n \n         opt\n     }\n@@ -103,24 +110,39 @@ pub enum Diagnostic {\n \n impl Diagnostic {\n     pub unsafe fn unpack(di: DiagnosticInfoRef) -> Diagnostic {\n-        let kind = super::LLVMGetDiagInfoKind(di);\n+        use super::DiagnosticKind as Dk;\n+        let kind = super::LLVMRustGetDiagInfoKind(di);\n \n         match kind {\n-            super::DK_InlineAsm => InlineAsm(InlineAsmDiagnostic::unpack(di)),\n+            Dk::InlineAsm => InlineAsm(InlineAsmDiagnostic::unpack(di)),\n \n-            super::DK_OptimizationRemark => {\n+            Dk::OptimizationRemark => {\n                 Optimization(OptimizationDiagnostic::unpack(OptimizationRemark, di))\n             }\n-\n-            super::DK_OptimizationRemarkMissed => {\n+            Dk::OptimizationRemarkOther => {\n+                Optimization(OptimizationDiagnostic::unpack(OptimizationRemarkOther, di))\n+            }\n+            Dk::OptimizationRemarkMissed => {\n                 Optimization(OptimizationDiagnostic::unpack(OptimizationMissed, di))\n             }\n \n-            super::DK_OptimizationRemarkAnalysis => {\n+            Dk::OptimizationRemarkAnalysis => {\n                 Optimization(OptimizationDiagnostic::unpack(OptimizationAnalysis, di))\n             }\n \n-            super::DK_OptimizationFailure => {\n+\n+            Dk::OptimizationRemarkAnalysisFPCommute => {\n+                Optimization(OptimizationDiagnostic::unpack(\n+                    OptimizationAnalysisFPCommute, di))\n+            }\n+\n+            Dk::OptimizationRemarkAnalysisAliasing => {\n+                Optimization(OptimizationDiagnostic::unpack(\n+                    OptimizationAnalysisAliasing, di))\n+            }\n+\n+\n+            Dk::OptimizationFailure => {\n                 Optimization(OptimizationDiagnostic::unpack(OptimizationFailure, di))\n             }\n "}, {"sha": "6301c57c55540ebe7fe260db96eb82055f33114e", "filename": "src/librustc_llvm/ffi.rs", "status": "added", "additions": 2068, "deletions": 0, "changes": 2068, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -0,0 +1,2068 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use debuginfo::{DIBuilderRef, DIDescriptor,\n+                DIFile, DILexicalBlock, DISubprogram, DIType,\n+                DIBasicType, DIDerivedType, DICompositeType, DIScope,\n+                DIVariable, DIGlobalVariable, DIArray, DISubrange,\n+                DITemplateTypeParameter, DIEnumerator, DINameSpace};\n+\n+use libc::{c_uint, c_int, size_t, c_char};\n+use libc::{c_longlong, c_ulonglong, c_void};\n+\n+use RustStringRef;\n+\n+pub type Opcode = u32;\n+pub type Bool = c_uint;\n+\n+pub const True: Bool = 1 as Bool;\n+pub const False: Bool = 0 as Bool;\n+\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum LLVMRustResult {\n+    Success,\n+    Failure,\n+}\n+// Consts for the LLVM CallConv type, pre-cast to usize.\n+\n+/// LLVM CallingConv::ID. Should we wrap this?\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum CallConv {\n+    CCallConv = 0,\n+    FastCallConv = 8,\n+    ColdCallConv = 9,\n+    X86StdcallCallConv = 64,\n+    X86FastcallCallConv = 65,\n+    X86_64_Win64 = 79,\n+    X86_VectorCall = 80\n+}\n+\n+/// LLVMLinkage\n+///\n+/// This enum omits the obsolete (and no-op) linkage types DLLImportLinkage,\n+/// DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n+/// LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n+/// they've been removed in upstream LLVM commit r203866.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[repr(C)]\n+pub enum Linkage {\n+    ExternalLinkage = 0,\n+    AvailableExternallyLinkage = 1,\n+    LinkOnceAnyLinkage = 2,\n+    LinkOnceODRLinkage = 3,\n+    WeakAnyLinkage = 5,\n+    WeakODRLinkage = 6,\n+    AppendingLinkage = 7,\n+    InternalLinkage = 8,\n+    PrivateLinkage = 9,\n+    ExternalWeakLinkage = 12,\n+    CommonLinkage = 14,\n+}\n+\n+/// LLVMDiagnosticSeverity\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub enum DiagnosticSeverity {\n+    Error = 0,\n+    Warning = 1,\n+    Remark = 2,\n+    Note = 3,\n+}\n+\n+/// LLVMDLLStorageClass\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum DLLStorageClass {\n+  Default   = 0,\n+  DllImport = 1, /* Function to be imported from DLL. */\n+  DllExport = 2, /* Function to be accessible from DLL. */\n+}\n+\n+bitflags! {\n+    #[derive(Default, Debug)]\n+    flags Attribute : u64 {\n+        const ZExt            = 1 << 0,\n+        const SExt            = 1 << 1,\n+        const NoReturn        = 1 << 2,\n+        const InReg           = 1 << 3,\n+        const StructRet       = 1 << 4,\n+        const NoUnwind        = 1 << 5,\n+        const NoAlias         = 1 << 6,\n+        const ByVal           = 1 << 7,\n+        const Nest            = 1 << 8,\n+        const ReadNone        = 1 << 9,\n+        const ReadOnly        = 1 << 10,\n+        const NoInline        = 1 << 11,\n+        const AlwaysInline    = 1 << 12,\n+        const OptimizeForSize = 1 << 13,\n+        const StackProtect    = 1 << 14,\n+        const StackProtectReq = 1 << 15,\n+        const NoCapture       = 1 << 21,\n+        const NoRedZone       = 1 << 22,\n+        const NoImplicitFloat = 1 << 23,\n+        const Naked           = 1 << 24,\n+        const InlineHint      = 1 << 25,\n+        const ReturnsTwice    = 1 << 29,\n+        const UWTable         = 1 << 30,\n+        const NonLazyBind     = 1 << 31,\n+\n+        // Some of these are missing from the LLVM C API, the rest are\n+        // present, but commented out, and preceded by the following warning:\n+        // FIXME: These attributes are currently not included in the C API as\n+        // a temporary measure until the API/ABI impact to the C API is understood\n+        // and the path forward agreed upon.\n+        const SanitizeAddress = 1 << 32,\n+        const MinSize         = 1 << 33,\n+        const NoDuplicate     = 1 << 34,\n+        const StackProtectStrong = 1 << 35,\n+        const SanitizeThread  = 1 << 36,\n+        const SanitizeMemory  = 1 << 37,\n+        const NoBuiltin       = 1 << 38,\n+        const Returned        = 1 << 39,\n+        const Cold            = 1 << 40,\n+        const Builtin         = 1 << 41,\n+        const OptimizeNone    = 1 << 42,\n+        const InAlloca        = 1 << 43,\n+        const NonNull         = 1 << 44,\n+        const JumpTable       = 1 << 45,\n+        const Convergent      = 1 << 46,\n+        const SafeStack       = 1 << 47,\n+        const NoRecurse       = 1 << 48,\n+        const InaccessibleMemOnly         = 1 << 49,\n+        const InaccessibleMemOrArgMemOnly = 1 << 50,\n+    }\n+}\n+\n+/// LLVMIntPredicate\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum IntPredicate {\n+    IntEQ = 32,\n+    IntNE = 33,\n+    IntUGT = 34,\n+    IntUGE = 35,\n+    IntULT = 36,\n+    IntULE = 37,\n+    IntSGT = 38,\n+    IntSGE = 39,\n+    IntSLT = 40,\n+    IntSLE = 41,\n+}\n+\n+/// LLVMRealPredicate\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum RealPredicate {\n+    RealPredicateFalse = 0,\n+    RealOEQ = 1,\n+    RealOGT = 2,\n+    RealOGE = 3,\n+    RealOLT = 4,\n+    RealOLE = 5,\n+    RealONE = 6,\n+    RealORD = 7,\n+    RealUNO = 8,\n+    RealUEQ = 9,\n+    RealUGT = 10,\n+    RealUGE = 11,\n+    RealULT = 12,\n+    RealULE = 13,\n+    RealUNE = 14,\n+    RealPredicateTrue = 15,\n+}\n+\n+/// LLVMTypeKind\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+#[repr(C)]\n+pub enum TypeKind {\n+    Void      = 0,\n+    Half      = 1,\n+    Float     = 2,\n+    Double    = 3,\n+    X86_FP80  = 4,\n+    FP128     = 5,\n+    PPC_FP128 = 6,\n+    Label     = 7,\n+    Integer   = 8,\n+    Function  = 9,\n+    Struct    = 10,\n+    Array     = 11,\n+    Pointer   = 12,\n+    Vector    = 13,\n+    Metadata  = 14,\n+    X86_MMX   = 15,\n+    Token     = 16,\n+}\n+\n+/// LLVMAtomicRmwBinOp\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum AtomicRmwBinOp {\n+    AtomicXchg = 0,\n+    AtomicAdd  = 1,\n+    AtomicSub  = 2,\n+    AtomicAnd  = 3,\n+    AtomicNand = 4,\n+    AtomicOr   = 5,\n+    AtomicXor  = 6,\n+    AtomicMax  = 7,\n+    AtomicMin  = 8,\n+    AtomicUMax = 9,\n+    AtomicUMin = 10,\n+}\n+\n+/// LLVMAtomicOrdering\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum AtomicOrdering {\n+    NotAtomic = 0,\n+    Unordered = 1,\n+    Monotonic = 2,\n+    // Consume = 3,  // Not specified yet.\n+    Acquire = 4,\n+    Release = 5,\n+    AcquireRelease = 6,\n+    SequentiallyConsistent = 7\n+}\n+\n+/// LLVMRustSynchronizationScope\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum SynchronizationScope {\n+    Other,\n+    SingleThread,\n+    CrossThread,\n+}\n+\n+/// LLVMRustFileType\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum FileType {\n+    Other,\n+    AssemblyFile,\n+    ObjectFile,\n+}\n+\n+/// Enum pinned in LLVMContext, used in\n+/// LLVMSetMetadata so ABI-stable.\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum MetadataType {\n+    MD_dbg = 0,\n+    MD_tbaa = 1,\n+    MD_prof = 2,\n+    MD_fpmath = 3,\n+    MD_range = 4,\n+    MD_tbaa_struct = 5,\n+    MD_invariant_load = 6,\n+    MD_alias_scope = 7,\n+    MD_noalias = 8,\n+    MD_nontemporal = 9,\n+    MD_mem_parallel_loop_access = 10,\n+    MD_nonnull = 11,\n+}\n+\n+/// LLVMRustAsmDialect\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum AsmDialect {\n+    Other,\n+    Att,\n+    Intel,\n+}\n+\n+/// LLVMRustCodeGenOptLevel\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum CodeGenOptLevel {\n+    Other,\n+    None,\n+    Less,\n+    Default,\n+    Aggressive,\n+}\n+\n+/// LLVMRelocMode\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum RelocMode {\n+    Default = 0,\n+    Static = 1,\n+    PIC = 2,\n+    DynamicNoPic = 3,\n+}\n+\n+/// LLVMRustCodeModel\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum CodeModel {\n+    Other,\n+    Default,\n+    JITDefault,\n+    Small,\n+    Kernel,\n+    Medium,\n+    Large,\n+}\n+\n+/// LLVMRustDiagnosticKind\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum DiagnosticKind {\n+    Other,\n+    InlineAsm,\n+    StackSize,\n+    DebugMetadataVersion,\n+    SampleProfile,\n+    OptimizationRemark,\n+    OptimizationRemarkMissed,\n+    OptimizationRemarkAnalysis,\n+    OptimizationRemarkAnalysisFPCommute,\n+    OptimizationRemarkAnalysisAliasing,\n+    OptimizationRemarkOther,\n+    OptimizationFailure,\n+}\n+\n+/// LLVMRustArchiveKind\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum ArchiveKind {\n+    Other,\n+    K_GNU,\n+    K_MIPS64,\n+    K_BSD,\n+    K_COFF,\n+}\n+\n+/// LLVMRustPassKind\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+#[repr(C)]\n+pub enum PassKind {\n+    Other,\n+    Function,\n+    Module,\n+}\n+\n+// Opaque pointer types\n+#[allow(missing_copy_implementations)]\n+pub enum Module_opaque {}\n+pub type ModuleRef = *mut Module_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Context_opaque {}\n+pub type ContextRef = *mut Context_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Type_opaque {}\n+pub type TypeRef = *mut Type_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Value_opaque {}\n+pub type ValueRef = *mut Value_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Metadata_opaque {}\n+pub type MetadataRef = *mut Metadata_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum BasicBlock_opaque {}\n+pub type BasicBlockRef = *mut BasicBlock_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Builder_opaque {}\n+pub type BuilderRef = *mut Builder_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum ExecutionEngine_opaque {}\n+pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum MemoryBuffer_opaque {}\n+pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum PassManager_opaque {}\n+pub type PassManagerRef = *mut PassManager_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum PassManagerBuilder_opaque {}\n+pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Use_opaque {}\n+pub type UseRef = *mut Use_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum TargetData_opaque {}\n+pub type TargetDataRef = *mut TargetData_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum ObjectFile_opaque {}\n+pub type ObjectFileRef = *mut ObjectFile_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum SectionIterator_opaque {}\n+pub type SectionIteratorRef = *mut SectionIterator_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Pass_opaque {}\n+pub type PassRef = *mut Pass_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum TargetMachine_opaque {}\n+pub type TargetMachineRef = *mut TargetMachine_opaque;\n+pub enum Archive_opaque {}\n+pub type ArchiveRef = *mut Archive_opaque;\n+pub enum ArchiveIterator_opaque {}\n+pub type ArchiveIteratorRef = *mut ArchiveIterator_opaque;\n+pub enum ArchiveChild_opaque {}\n+pub type ArchiveChildRef = *mut ArchiveChild_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Twine_opaque {}\n+pub type TwineRef = *mut Twine_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum DiagnosticInfo_opaque {}\n+pub type DiagnosticInfoRef = *mut DiagnosticInfo_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum DebugLoc_opaque {}\n+pub type DebugLocRef = *mut DebugLoc_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum SMDiagnostic_opaque {}\n+pub type SMDiagnosticRef = *mut SMDiagnostic_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum RustArchiveMember_opaque {}\n+pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum OperandBundleDef_opaque {}\n+pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n+\n+pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n+pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n+\n+pub mod debuginfo {\n+    pub use self::DIDescriptorFlags::*;\n+    use super::{MetadataRef};\n+\n+    #[allow(missing_copy_implementations)]\n+    pub enum DIBuilder_opaque {}\n+    pub type DIBuilderRef = *mut DIBuilder_opaque;\n+\n+    pub type DIDescriptor = MetadataRef;\n+    pub type DIScope = DIDescriptor;\n+    pub type DILocation = DIDescriptor;\n+    pub type DIFile = DIScope;\n+    pub type DILexicalBlock = DIScope;\n+    pub type DISubprogram = DIScope;\n+    pub type DINameSpace = DIScope;\n+    pub type DIType = DIDescriptor;\n+    pub type DIBasicType = DIType;\n+    pub type DIDerivedType = DIType;\n+    pub type DICompositeType = DIDerivedType;\n+    pub type DIVariable = DIDescriptor;\n+    pub type DIGlobalVariable = DIDescriptor;\n+    pub type DIArray = DIDescriptor;\n+    pub type DISubrange = DIDescriptor;\n+    pub type DIEnumerator = DIDescriptor;\n+    pub type DITemplateTypeParameter = DIDescriptor;\n+\n+    #[derive(Copy, Clone)]\n+    pub enum DIDescriptorFlags {\n+      FlagPrivate            = 1 << 0,\n+      FlagProtected          = 1 << 1,\n+      FlagFwdDecl            = 1 << 2,\n+      FlagAppleBlock         = 1 << 3,\n+      FlagBlockByrefStruct   = 1 << 4,\n+      FlagVirtual            = 1 << 5,\n+      FlagArtificial         = 1 << 6,\n+      FlagExplicit           = 1 << 7,\n+      FlagPrototyped         = 1 << 8,\n+      FlagObjcClassComplete  = 1 << 9,\n+      FlagObjectPointer      = 1 << 10,\n+      FlagVector             = 1 << 11,\n+      FlagStaticMember       = 1 << 12,\n+      FlagIndirectVariable   = 1 << 13,\n+      FlagLValueReference    = 1 << 14,\n+      FlagRValueReference    = 1 << 15\n+    }\n+}\n+\n+\n+// Link to our native llvm bindings (things that we need to use the C++ api\n+// for) and because llvm is written in C++ we need to link against libstdc++\n+//\n+// You'll probably notice that there is an omission of all LLVM libraries\n+// from this location. This is because the set of LLVM libraries that we\n+// link to is mostly defined by LLVM, and the `llvm-config` tool is used to\n+// figure out the exact set of libraries. To do this, the build system\n+// generates an llvmdeps.rs file next to this one which will be\n+// automatically updated whenever LLVM is updated to include an up-to-date\n+// set of the libraries we need to link to LLVM for.\n+#[link(name = \"rustllvm\", kind = \"static\")]\n+#[cfg(not(cargobuild))]\n+extern {}\n+\n+#[linked_from = \"rustllvm\"] // not quite true but good enough\n+extern {\n+    /* Create and destroy contexts. */\n+    pub fn LLVMContextCreate() -> ContextRef;\n+    pub fn LLVMContextDispose(C: ContextRef);\n+    pub fn LLVMGetMDKindIDInContext(C: ContextRef,\n+                                    Name: *const c_char,\n+                                    SLen: c_uint)\n+                                    -> c_uint;\n+\n+    /* Create and destroy modules. */\n+    pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char,\n+                                             C: ContextRef)\n+                                             -> ModuleRef;\n+    pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n+    pub fn LLVMCloneModule(M: ModuleRef) -> ModuleRef;\n+    pub fn LLVMDisposeModule(M: ModuleRef);\n+\n+    /// Data layout. See Module::getDataLayout.\n+    pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n+    pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n+\n+    /// Target triple. See Module::getTargetTriple.\n+    pub fn LLVMGetTarget(M: ModuleRef) -> *const c_char;\n+    pub fn LLVMSetTarget(M: ModuleRef, Triple: *const c_char);\n+\n+    /// See Module::dump.\n+    pub fn LLVMDumpModule(M: ModuleRef);\n+\n+    /// See Module::setModuleInlineAsm.\n+    pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n+\n+    /// See llvm::LLVMTypeKind::getTypeID.\n+    pub fn LLVMRustGetTypeKind(Ty: TypeRef) -> TypeKind;\n+\n+    /// See llvm::LLVMType::getContext.\n+    pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n+\n+    /* Operations on integer types */\n+    pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint)\n+                                -> TypeRef;\n+\n+    pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n+\n+    /* Operations on real types */\n+    pub fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n+\n+    /* Operations on function types */\n+    pub fn LLVMFunctionType(ReturnType: TypeRef,\n+                            ParamTypes: *const TypeRef,\n+                            ParamCount: c_uint,\n+                            IsVarArg: Bool)\n+                            -> TypeRef;\n+    pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n+    pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n+    pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *mut TypeRef);\n+\n+    /* Operations on struct types */\n+    pub fn LLVMStructTypeInContext(C: ContextRef,\n+                                   ElementTypes: *const TypeRef,\n+                                   ElementCount: c_uint,\n+                                   Packed: Bool)\n+                                   -> TypeRef;\n+    pub fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetStructElementTypes(StructTy: TypeRef,\n+                                     Dest: *mut TypeRef);\n+    pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n+\n+    /* Operations on array, pointer, and vector types (sequence types) */\n+    pub fn LLVMRustArrayType(ElementType: TypeRef, ElementCount: u64) -> TypeRef;\n+    pub fn LLVMPointerType(ElementType: TypeRef, AddressSpace: c_uint)\n+                           -> TypeRef;\n+    pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint)\n+                          -> TypeRef;\n+\n+    pub fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n+    pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef, V: ValueRef)\n+                                  -> *const c_void;\n+    pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n+\n+    /* Operations on other types */\n+    pub fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMRustMetadataTypeInContext(C: ContextRef) -> TypeRef;\n+\n+    /* Operations on all values */\n+    pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n+    pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n+    pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n+    pub fn LLVMDumpValue(Val: ValueRef);\n+    pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n+    pub fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n+\n+    /* Operations on Uses */\n+    pub fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n+    pub fn LLVMGetNextUse(U: UseRef) -> UseRef;\n+    pub fn LLVMGetUser(U: UseRef) -> ValueRef;\n+    pub fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n+\n+    /* Operations on Users */\n+    pub fn LLVMGetNumOperands(Val: ValueRef) -> c_int;\n+    pub fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n+    pub fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n+\n+    /* Operations on constants of any type */\n+    pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n+    /* all zeroes */\n+    pub fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMConstICmp(Pred: IntPredicate, V1: ValueRef, V2: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef)\n+                         -> ValueRef;\n+    /* only for isize/vector */\n+    pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMIsConstant(Val: ValueRef) -> Bool;\n+    pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n+    pub fn LLVMIsUndef(Val: ValueRef) -> Bool;\n+    pub fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n+\n+    /* Operations on metadata */\n+    pub fn LLVMMDStringInContext(C: ContextRef,\n+                                 Str: *const c_char,\n+                                 SLen: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMMDNodeInContext(C: ContextRef,\n+                               Vals: *const ValueRef,\n+                               Count: c_uint)\n+                               -> ValueRef;\n+    pub fn LLVMAddNamedMetadataOperand(M: ModuleRef,\n+                                       Str: *const c_char,\n+                                       Val: ValueRef);\n+\n+    /* Operations on scalar constants */\n+    pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool)\n+                        -> ValueRef;\n+    pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *const c_char, Radix: u8)\n+                                -> ValueRef;\n+    pub fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n+                                       Text: *const c_char,\n+                                       SLen: c_uint,\n+                                       Radix: u8)\n+                                       -> ValueRef;\n+    pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n+    pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n+                                        Text: *const c_char,\n+                                        SLen: c_uint)\n+                                        -> ValueRef;\n+    pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n+    pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n+\n+\n+    /* Operations on composite constants */\n+    pub fn LLVMConstStringInContext(C: ContextRef,\n+                                    Str: *const c_char,\n+                                    Length: c_uint,\n+                                    DontNullTerminate: Bool)\n+                                    -> ValueRef;\n+    pub fn LLVMConstStructInContext(C: ContextRef,\n+                                    ConstantVals: *const ValueRef,\n+                                    Count: c_uint,\n+                                    Packed: Bool)\n+                                    -> ValueRef;\n+\n+    pub fn LLVMConstArray(ElementTy: TypeRef,\n+                          ConstantVals: *const ValueRef,\n+                          Length: c_uint)\n+                          -> ValueRef;\n+    pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint)\n+                           -> ValueRef;\n+\n+    /* Constant expressions */\n+    pub fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstUDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n+                              RHSConstant: ValueRef)\n+                              -> ValueRef;\n+    pub fn LLVMConstFDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstURem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstAnd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstOr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                       -> ValueRef;\n+    pub fn LLVMConstXor(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstGEP(ConstantVal: ValueRef,\n+                        ConstantIndices: *const ValueRef,\n+                        NumIndices: c_uint)\n+                        -> ValueRef;\n+    pub fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n+                                ConstantIndices: *const ValueRef,\n+                                NumIndices: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n+                          -> ValueRef;\n+    pub fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFPTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n+                            -> ValueRef;\n+    pub fn LLVMConstFPExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                          -> ValueRef;\n+    pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: TypeRef)\n+                             -> ValueRef;\n+    pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: TypeRef)\n+                             -> ValueRef;\n+    pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                            -> ValueRef;\n+    pub fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                   -> ValueRef;\n+    pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                -> ValueRef;\n+    pub fn LLVMConstIntCast(ConstantVal: ValueRef,\n+                            ToType: TypeRef,\n+                            isSigned: Bool)\n+                            -> ValueRef;\n+    pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstSelect(ConstantCondition: ValueRef,\n+                           ConstantIfTrue: ValueRef,\n+                           ConstantIfFalse: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstExtractElement(VectorConstant: ValueRef,\n+                                   IndexConstant: ValueRef)\n+                                   -> ValueRef;\n+    pub fn LLVMConstInsertElement(VectorConstant: ValueRef,\n+                                  ElementValueConstant: ValueRef,\n+                                  IndexConstant: ValueRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n+                                  VectorBConstant: ValueRef,\n+                                  MaskConstant: ValueRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n+                                 IdxList: *const c_uint,\n+                                 NumIdx: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMConstInsertValue(AggConstant: ValueRef,\n+                                ElementValueConstant: ValueRef,\n+                                IdxList: *const c_uint,\n+                                NumIdx: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMConstInlineAsm(Ty: TypeRef,\n+                              AsmString: *const c_char,\n+                              Constraints: *const c_char,\n+                              HasSideEffects: Bool,\n+                              IsAlignStack: Bool)\n+                              -> ValueRef;\n+    pub fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n+\n+\n+\n+    /* Operations on global variables, functions, and aliases (globals) */\n+    pub fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n+    pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n+    pub fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetLinkage(Global: ValueRef, Link: Linkage);\n+    pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n+    pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n+    pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n+    pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n+    pub fn LLVMSetDLLStorageClass(V: ValueRef,\n+                                  C: DLLStorageClass);\n+\n+\n+    /* Operations on global variables */\n+    pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n+                                       Ty: TypeRef,\n+                                       Name: *const c_char,\n+                                       AddressSpace: c_uint)\n+                                       -> ValueRef;\n+    pub fn LLVMGetNamedGlobal(M: ModuleRef,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMRustGetOrInsertGlobal(M: ModuleRef,\n+                                     Name: *const c_char,\n+                                     T: TypeRef)\n+                                     -> ValueRef;\n+    pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n+    pub fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMSetInitializer(GlobalVar: ValueRef,\n+                              ConstantVal: ValueRef);\n+    pub fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n+    pub fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n+    pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n+    pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n+    pub fn LLVMRustGetNamedValue(M: ModuleRef, Name: *const c_char) -> ValueRef;\n+\n+    /* Operations on aliases */\n+    pub fn LLVMAddAlias(M: ModuleRef,\n+                        Ty: TypeRef,\n+                        Aliasee: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+\n+    /* Operations on functions */\n+    pub fn LLVMAddFunction(M: ModuleRef,\n+                           Name: *const c_char,\n+                           FunctionTy: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMDeleteFunction(Fn: ValueRef);\n+    pub fn LLVMRustGetOrInsertFunction(M: ModuleRef,\n+                                       Name: *const c_char,\n+                                       FunctionTy: TypeRef)\n+                                       -> ValueRef;\n+    pub fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n+    pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n+    pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n+    pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: u64);\n+    pub fn LLVMRustAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n+    pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef, index: c_uint,\n+                                              Name: *const c_char,\n+                                              Value: *const c_char);\n+    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef,\n+                                            index: c_uint,\n+                                            attr: u64);\n+    pub fn LLVMRustRemoveFunctionAttrString(Fn: ValueRef,\n+                                            index: c_uint,\n+                                            Name: *const c_char);\n+    pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_uint);\n+\n+    /* Operations on parameters */\n+    pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetParams(Fn: ValueRef, Params: *const ValueRef);\n+    pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n+    pub fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n+    pub fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n+    pub fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n+    pub fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n+    pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n+\n+    /* Operations on basic blocks */\n+    pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n+    pub fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *const ValueRef);\n+    pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n+    pub fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n+    pub fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+\n+    pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n+                                         Fn: ValueRef,\n+                                         Name: *const c_char)\n+                                         -> BasicBlockRef;\n+    pub fn LLVMInsertBasicBlockInContext(C: ContextRef,\n+                                         BB: BasicBlockRef,\n+                                         Name: *const c_char)\n+                                         -> BasicBlockRef;\n+    pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n+\n+    pub fn LLVMMoveBasicBlockAfter(BB: BasicBlockRef,\n+                                   MoveAfter: BasicBlockRef);\n+\n+    pub fn LLVMMoveBasicBlockBefore(BB: BasicBlockRef,\n+                                    MoveBefore: BasicBlockRef);\n+\n+    /* Operations on instructions */\n+    pub fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n+\n+    /* Operations on call sites */\n+    pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n+    pub fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n+    pub fn LLVMAddInstrAttribute(Instr: ValueRef,\n+                                 index: c_uint,\n+                                 IA: c_uint);\n+    pub fn LLVMRemoveInstrAttribute(Instr: ValueRef,\n+                                    index: c_uint,\n+                                    IA: c_uint);\n+    pub fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n+                                      index: c_uint,\n+                                      align: c_uint);\n+    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef,\n+                                    index: c_uint,\n+                                    Val: u64);\n+    pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef,\n+                                                  index: c_uint,\n+                                                  bytes: u64);\n+\n+    /* Operations on call instructions (only) */\n+    pub fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n+    pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n+\n+    /* Operations on load/store instructions (only) */\n+    pub fn LLVMGetVolatile(MemoryAccessInst: ValueRef) -> Bool;\n+    pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);\n+\n+    /* Operations on phi nodes */\n+    pub fn LLVMAddIncoming(PhiNode: ValueRef,\n+                           IncomingValues: *const ValueRef,\n+                           IncomingBlocks: *const BasicBlockRef,\n+                           Count: c_uint);\n+    pub fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n+    pub fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMGetIncomingBlock(PhiNode: ValueRef, Index: c_uint)\n+                                -> BasicBlockRef;\n+\n+    /* Instruction builders */\n+    pub fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n+    pub fn LLVMPositionBuilder(Builder: BuilderRef,\n+                               Block: BasicBlockRef,\n+                               Instr: ValueRef);\n+    pub fn LLVMPositionBuilderBefore(Builder: BuilderRef,\n+                                     Instr: ValueRef);\n+    pub fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n+                                    Block: BasicBlockRef);\n+    pub fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n+    pub fn LLVMClearInsertionPosition(Builder: BuilderRef);\n+    pub fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n+    pub fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n+                                         Instr: ValueRef,\n+                                         Name: *const c_char);\n+    pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n+\n+    /* Metadata */\n+    pub fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n+    pub fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n+    pub fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n+\n+    /* Terminators */\n+    pub fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n+    pub fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildAggregateRet(B: BuilderRef,\n+                                 RetVals: *const ValueRef,\n+                                 N: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMBuildCondBr(B: BuilderRef,\n+                           If: ValueRef,\n+                           Then: BasicBlockRef,\n+                           Else: BasicBlockRef)\n+                           -> ValueRef;\n+    pub fn LLVMBuildSwitch(B: BuilderRef,\n+                           V: ValueRef,\n+                           Else: BasicBlockRef,\n+                           NumCases: c_uint)\n+                           -> ValueRef;\n+    pub fn LLVMBuildIndirectBr(B: BuilderRef,\n+                               Addr: ValueRef,\n+                               NumDests: c_uint)\n+                               -> ValueRef;\n+    pub fn LLVMRustBuildInvoke(B: BuilderRef,\n+                               Fn: ValueRef,\n+                               Args: *const ValueRef,\n+                               NumArgs: c_uint,\n+                               Then: BasicBlockRef,\n+                               Catch: BasicBlockRef,\n+                               Bundle: OperandBundleDefRef,\n+                               Name: *const c_char)\n+                               -> ValueRef;\n+    pub fn LLVMRustBuildLandingPad(B: BuilderRef,\n+                                   Ty: TypeRef,\n+                                   PersFn: ValueRef,\n+                                   NumClauses: c_uint,\n+                                   Name: *const c_char,\n+                                   F: ValueRef)\n+                                   -> ValueRef;\n+    pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n+\n+    pub fn LLVMRustBuildCleanupPad(B: BuilderRef,\n+                                   ParentPad: ValueRef,\n+                                   ArgCnt: c_uint,\n+                                   Args: *const ValueRef,\n+                                   Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustBuildCleanupRet(B: BuilderRef,\n+                                   CleanupPad: ValueRef,\n+                                   UnwindBB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMRustBuildCatchPad(B: BuilderRef,\n+                                 ParentPad: ValueRef,\n+                                 ArgCnt: c_uint,\n+                                 Args: *const ValueRef,\n+                                 Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustBuildCatchRet(B: BuilderRef,\n+                                 Pad: ValueRef,\n+                                 BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMRustBuildCatchSwitch(Builder: BuilderRef,\n+                                    ParentPad: ValueRef,\n+                                    BB: BasicBlockRef,\n+                                    NumHandlers: c_uint,\n+                                    Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustAddHandler(CatchSwitch: ValueRef,\n+                              Handler: BasicBlockRef);\n+    pub fn LLVMRustSetPersonalityFn(B: BuilderRef, Pers: ValueRef);\n+\n+    /* Add a case to the switch instruction */\n+    pub fn LLVMAddCase(Switch: ValueRef,\n+                       OnVal: ValueRef,\n+                       Dest: BasicBlockRef);\n+\n+    /* Add a destination to the indirectbr instruction */\n+    pub fn LLVMAddDestination(IndirectBr: ValueRef, Dest: BasicBlockRef);\n+\n+    /* Add a clause to the landing pad instruction */\n+    pub fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n+\n+    /* Set the cleanup on a landing pad instruction */\n+    pub fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n+\n+    /* Arithmetic */\n+    pub fn LLVMBuildAdd(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWAdd(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWAdd(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFAdd(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSub(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWSub(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWSub(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFSub(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildMul(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWMul(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWMul(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFMul(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildUDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildExactSDiv(B: BuilderRef,\n+                              LHS: ValueRef,\n+                              RHS: ValueRef,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildFDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildURem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSRem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFRem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildShl(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildLShr(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildAShr(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildAnd(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildOr(B: BuilderRef,\n+                       LHS: ValueRef,\n+                       RHS: ValueRef,\n+                       Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildXor(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildBinOp(B: BuilderRef,\n+                          Op: Opcode,\n+                          LHS: ValueRef,\n+                          RHS: ValueRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: ValueRef);\n+\n+    /* Memory */\n+    pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildLoad(B: BuilderRef,\n+                         PointerVal: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+\n+    pub fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef)\n+                          -> ValueRef;\n+\n+    pub fn LLVMBuildGEP(B: BuilderRef,\n+                        Pointer: ValueRef,\n+                        Indices: *const ValueRef,\n+                        NumIndices: c_uint,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildInBoundsGEP(B: BuilderRef,\n+                                Pointer: ValueRef,\n+                                Indices: *const ValueRef,\n+                                NumIndices: c_uint,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+    pub fn LLVMBuildStructGEP(B: BuilderRef,\n+                              Pointer: ValueRef,\n+                              Idx: c_uint,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildGlobalString(B: BuilderRef,\n+                                 Str: *const c_char,\n+                                 Name: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n+                                    Str: *const c_char,\n+                                    Name: *const c_char)\n+                                    -> ValueRef;\n+\n+    /* Casts */\n+    pub fn LLVMBuildTrunc(B: BuilderRef,\n+                          Val: ValueRef,\n+                          DestTy: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildZExt(B: BuilderRef,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSExt(B: BuilderRef,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFPToUI(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFPToSI(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildUIToFP(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildSIToFP(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFPTrunc(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildFPExt(B: BuilderRef,\n+                          Val: ValueRef,\n+                          DestTy: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildPtrToInt(B: BuilderRef,\n+                             Val: ValueRef,\n+                             DestTy: TypeRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n+    pub fn LLVMBuildIntToPtr(B: BuilderRef,\n+                             Val: ValueRef,\n+                             DestTy: TypeRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n+    pub fn LLVMBuildBitCast(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n+                                   Val: ValueRef,\n+                                   DestTy: TypeRef,\n+                                   Name: *const c_char)\n+                                   -> ValueRef;\n+    pub fn LLVMBuildCast(B: BuilderRef,\n+                         Op: Opcode,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char) -> ValueRef;\n+    pub fn LLVMBuildPointerCast(B: BuilderRef,\n+                                Val: ValueRef,\n+                                DestTy: TypeRef,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+    pub fn LLVMBuildIntCast(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildFPCast(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+\n+    /* Comparisons */\n+    pub fn LLVMBuildICmp(B: BuilderRef,\n+                         Op: c_uint,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFCmp(B: BuilderRef,\n+                         Op: c_uint,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+\n+    /* Miscellaneous instructions */\n+    pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMRustBuildCall(B: BuilderRef,\n+                             Fn: ValueRef,\n+                             Args: *const ValueRef,\n+                             NumArgs: c_uint,\n+                             Bundle: OperandBundleDefRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n+    pub fn LLVMBuildSelect(B: BuilderRef,\n+                           If: ValueRef,\n+                           Then: ValueRef,\n+                           Else: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildVAArg(B: BuilderRef,\n+                          list: ValueRef,\n+                          Ty: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildExtractElement(B: BuilderRef,\n+                                   VecVal: ValueRef,\n+                                   Index: ValueRef,\n+                                   Name: *const c_char)\n+                                   -> ValueRef;\n+    pub fn LLVMBuildInsertElement(B: BuilderRef,\n+                                  VecVal: ValueRef,\n+                                  EltVal: ValueRef,\n+                                  Index: ValueRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildShuffleVector(B: BuilderRef,\n+                                  V1: ValueRef,\n+                                  V2: ValueRef,\n+                                  Mask: ValueRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildExtractValue(B: BuilderRef,\n+                                 AggVal: ValueRef,\n+                                 Index: c_uint,\n+                                 Name: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildInsertValue(B: BuilderRef,\n+                                AggVal: ValueRef,\n+                                EltVal: ValueRef,\n+                                Index: c_uint,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+\n+    pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildPtrDiff(B: BuilderRef,\n+                            LHS: ValueRef,\n+                            RHS: ValueRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+\n+    /* Atomic Operations */\n+    pub fn LLVMRustBuildAtomicLoad(B: BuilderRef,\n+                                   PointerVal: ValueRef,\n+                                   Name: *const c_char,\n+                                   Order: AtomicOrdering,\n+                                   Alignment: c_uint)\n+                                   -> ValueRef;\n+\n+    pub fn LLVMRustBuildAtomicStore(B: BuilderRef,\n+                                    Val: ValueRef,\n+                                    Ptr: ValueRef,\n+                                    Order: AtomicOrdering,\n+                                    Alignment: c_uint)\n+                                    -> ValueRef;\n+\n+    pub fn LLVMRustBuildAtomicCmpXchg(B: BuilderRef,\n+                                      LHS: ValueRef,\n+                                      CMP: ValueRef,\n+                                      RHS: ValueRef,\n+                                      Order: AtomicOrdering,\n+                                      FailureOrder: AtomicOrdering,\n+                                      Weak: Bool)\n+                                      -> ValueRef;\n+\n+    pub fn LLVMBuildAtomicRMW(B: BuilderRef,\n+                              Op: AtomicRmwBinOp,\n+                              LHS: ValueRef,\n+                              RHS: ValueRef,\n+                              Order: AtomicOrdering,\n+                              SingleThreaded: Bool)\n+                              -> ValueRef;\n+\n+    pub fn LLVMRustBuildAtomicFence(B: BuilderRef,\n+                                    Order: AtomicOrdering,\n+                                    Scope: SynchronizationScope);\n+\n+\n+    /* Selected entries from the downcasts. */\n+    pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n+\n+    /// Writes a module to the specified path. Returns 0 on success.\n+    pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n+\n+    /// Creates target data from a target layout string.\n+    pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n+    /// Number of bytes clobbered when doing a Store to *T.\n+    pub fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n+                               -> c_ulonglong;\n+\n+    /// Number of bytes clobbered when doing a Store to *T.\n+    pub fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n+                                -> c_ulonglong;\n+\n+    /// Distance between successive elements in an array of T. Includes ABI padding.\n+    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n+\n+    /// Returns the preferred alignment of a type.\n+    pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                        -> c_uint;\n+    /// Returns the minimum alignment of a type.\n+    pub fn LLVMABIAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                  -> c_uint;\n+\n+    /// Computes the byte offset of the indexed struct element for a\n+    /// target.\n+    pub fn LLVMOffsetOfElement(TD: TargetDataRef,\n+                               StructTy: TypeRef,\n+                               Element: c_uint)\n+                               -> c_ulonglong;\n+\n+    /// Returns the minimum alignment of a type when part of a call frame.\n+    pub fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                        -> c_uint;\n+\n+    /// Disposes target data.\n+    pub fn LLVMDisposeTargetData(TD: TargetDataRef);\n+\n+    /// Creates a pass manager.\n+    pub fn LLVMCreatePassManager() -> PassManagerRef;\n+\n+    /// Creates a function-by-function pass manager\n+    pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef)\n+                                                  -> PassManagerRef;\n+\n+    /// Disposes a pass manager.\n+    pub fn LLVMDisposePassManager(PM: PassManagerRef);\n+\n+    /// Runs a pass manager on a module.\n+    pub fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n+\n+    /// Runs the function passes on the provided function.\n+    pub fn LLVMRunFunctionPassManager(FPM: PassManagerRef, F: ValueRef)\n+                                      -> Bool;\n+\n+    /// Initializes all the function passes scheduled in the manager\n+    pub fn LLVMInitializeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n+\n+    /// Finalizes all the function passes scheduled in the manager\n+    pub fn LLVMFinalizeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n+\n+    pub fn LLVMInitializePasses();\n+\n+    /// Adds a verification pass.\n+    pub fn LLVMAddVerifierPass(PM: PassManagerRef);\n+\n+    pub fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n+    pub fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n+    pub fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n+    pub fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n+    pub fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n+    pub fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n+    pub fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n+    pub fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n+    pub fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n+    pub fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n+    pub fn LLVMAddReassociatePass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n+    pub fn LLVMAddLICMPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n+    pub fn LLVMAddGVNPass(PM: PassManagerRef);\n+    pub fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n+    pub fn LLVMAddSCCPPass(PM: PassManagerRef);\n+    pub fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n+    pub fn LLVMAddConstantMergePass(PM: PassManagerRef);\n+    pub fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n+    pub fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n+    pub fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n+    pub fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n+    pub fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n+    pub fn LLVMAddPruneEHPass(PM: PassManagerRef);\n+    pub fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n+    pub fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n+    pub fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n+    pub fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n+\n+    pub fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n+    pub fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n+    pub fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n+                                             OptimizationLevel: c_uint);\n+    pub fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n+                                              Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n+        PMB: PassManagerBuilderRef,\n+        threshold: c_uint);\n+    pub fn LLVMPassManagerBuilderPopulateModulePassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef);\n+\n+    pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef);\n+    pub fn LLVMPassManagerBuilderPopulateLTOPassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef,\n+        Internalize: Bool,\n+        RunInliner: Bool);\n+\n+    /// Destroys a memory buffer.\n+    pub fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n+\n+\n+    /* Stuff that's in rustllvm/ because it's not upstream yet. */\n+\n+    /// Opens an object file.\n+    pub fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n+    /// Closes an object file.\n+    pub fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n+\n+    /// Enumerates the sections in an object file.\n+    pub fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n+    /// Destroys a section iterator.\n+    pub fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n+    /// Returns true if the section iterator is at the end of the section\n+    /// list:\n+    pub fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n+                                      SI: SectionIteratorRef)\n+                                      -> Bool;\n+    /// Moves the section iterator to point to the next section.\n+    pub fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n+    /// Returns the current section size.\n+    pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n+    /// Returns the current section contents as a string buffer.\n+    pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n+\n+    /// Reads the given file and returns it as a memory buffer. Use\n+    /// LLVMDisposeMemoryBuffer() to get rid of it.\n+    pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char)\n+                                                        -> MemoryBufferRef;\n+    /// Borrows the contents of the memory buffer (doesn't copy it)\n+    pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *const c_char,\n+                                                 InputDataLength: size_t,\n+                                                 BufferName: *const c_char,\n+                                                 RequiresNull: Bool)\n+                                                 -> MemoryBufferRef;\n+    pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *const c_char,\n+                                                     InputDataLength: size_t,\n+                                                     BufferName: *const c_char)\n+                                                     -> MemoryBufferRef;\n+\n+    pub fn LLVMIsMultithreaded() -> Bool;\n+    pub fn LLVMStartMultithreaded() -> Bool;\n+\n+    /// Returns a string describing the last error caused by an LLVMRust* call.\n+    pub fn LLVMRustGetLastError() -> *const c_char;\n+\n+    /// Print the pass timings since static dtors aren't picking them up.\n+    pub fn LLVMRustPrintPassTimings();\n+\n+    pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n+\n+    pub fn LLVMStructSetBody(StructTy: TypeRef,\n+                             ElementTypes: *const TypeRef,\n+                             ElementCount: c_uint,\n+                             Packed: Bool);\n+\n+    pub fn LLVMConstNamedStruct(S: TypeRef,\n+                                ConstantVals: *const ValueRef,\n+                                Count: c_uint)\n+                                -> ValueRef;\n+\n+    /// Enables LLVM debug output.\n+    pub fn LLVMRustSetDebug(Enabled: c_int);\n+\n+    /// Prepares inline assembly.\n+    pub fn LLVMRustInlineAsm(Ty: TypeRef,\n+                             AsmString: *const c_char,\n+                             Constraints: *const c_char,\n+                             SideEffects: Bool,\n+                             AlignStack: Bool,\n+                             Dialect: AsmDialect)\n+                             -> ValueRef;\n+\n+    pub fn LLVMRustDebugMetadataVersion() -> u32;\n+    pub fn LLVMRustVersionMajor() -> u32;\n+    pub fn LLVMRustVersionMinor() -> u32;\n+\n+    pub fn LLVMRustAddModuleFlag(M: ModuleRef,\n+                                 name: *const c_char,\n+                                 value: u32);\n+\n+    pub fn LLVMRustDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n+\n+    pub fn LLVMRustDIBuilderDispose(Builder: DIBuilderRef);\n+\n+    pub fn LLVMRustDIBuilderFinalize(Builder: DIBuilderRef);\n+\n+    pub fn LLVMRustDIBuilderCreateCompileUnit(Builder: DIBuilderRef,\n+                                              Lang: c_uint,\n+                                              File: *const c_char,\n+                                              Dir: *const c_char,\n+                                              Producer: *const c_char,\n+                                              isOptimized: bool,\n+                                              Flags: *const c_char,\n+                                              RuntimeVer: c_uint,\n+                                              SplitName: *const c_char)\n+                                              -> DIDescriptor;\n+\n+    pub fn LLVMRustDIBuilderCreateFile(Builder: DIBuilderRef,\n+                                       Filename: *const c_char,\n+                                       Directory: *const c_char)\n+                                       -> DIFile;\n+\n+    pub fn LLVMRustDIBuilderCreateSubroutineType(Builder: DIBuilderRef,\n+                                                 File: DIFile,\n+                                                 ParameterTypes: DIArray)\n+                                                 -> DICompositeType;\n+\n+    pub fn LLVMRustDIBuilderCreateFunction(Builder: DIBuilderRef,\n+                                           Scope: DIDescriptor,\n+                                           Name: *const c_char,\n+                                           LinkageName: *const c_char,\n+                                           File: DIFile,\n+                                           LineNo: c_uint,\n+                                           Ty: DIType,\n+                                           isLocalToUnit: bool,\n+                                           isDefinition: bool,\n+                                           ScopeLine: c_uint,\n+                                           Flags: c_uint,\n+                                           isOptimized: bool,\n+                                           Fn: ValueRef,\n+                                           TParam: DIArray,\n+                                           Decl: DIDescriptor)\n+                                           -> DISubprogram;\n+\n+    pub fn LLVMRustDIBuilderCreateBasicType(Builder: DIBuilderRef,\n+                                            Name: *const c_char,\n+                                            SizeInBits: u64,\n+                                            AlignInBits: u64,\n+                                            Encoding: c_uint)\n+                                            -> DIBasicType;\n+\n+    pub fn LLVMRustDIBuilderCreatePointerType(Builder: DIBuilderRef,\n+                                          PointeeTy: DIType,\n+                                          SizeInBits: u64,\n+                                          AlignInBits: u64,\n+                                          Name: *const c_char)\n+                                          -> DIDerivedType;\n+\n+    pub fn LLVMRustDIBuilderCreateStructType(Builder: DIBuilderRef,\n+                                             Scope: DIDescriptor,\n+                                             Name: *const c_char,\n+                                             File: DIFile,\n+                                             LineNumber: c_uint,\n+                                             SizeInBits: u64,\n+                                             AlignInBits: u64,\n+                                             Flags: c_uint,\n+                                             DerivedFrom: DIType,\n+                                             Elements: DIArray,\n+                                             RunTimeLang: c_uint,\n+                                             VTableHolder: DIType,\n+                                             UniqueId: *const c_char)\n+                                             -> DICompositeType;\n+\n+    pub fn LLVMRustDIBuilderCreateMemberType(Builder: DIBuilderRef,\n+                                             Scope: DIDescriptor,\n+                                             Name: *const c_char,\n+                                             File: DIFile,\n+                                             LineNo: c_uint,\n+                                             SizeInBits: u64,\n+                                             AlignInBits: u64,\n+                                             OffsetInBits: u64,\n+                                             Flags: c_uint,\n+                                             Ty: DIType)\n+                                             -> DIDerivedType;\n+\n+    pub fn LLVMRustDIBuilderCreateLexicalBlock(Builder: DIBuilderRef,\n+                                               Scope: DIScope,\n+                                               File: DIFile,\n+                                               Line: c_uint,\n+                                               Col: c_uint)\n+                                               -> DILexicalBlock;\n+\n+    pub fn LLVMRustDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n+                                                 Context: DIScope,\n+                                                 Name: *const c_char,\n+                                                 LinkageName: *const c_char,\n+                                                 File: DIFile,\n+                                                 LineNo: c_uint,\n+                                                 Ty: DIType,\n+                                                 isLocalToUnit: bool,\n+                                                 Val: ValueRef,\n+                                                 Decl: DIDescriptor)\n+                                                 -> DIGlobalVariable;\n+\n+    pub fn LLVMRustDIBuilderCreateVariable(Builder: DIBuilderRef,\n+                                           Tag: c_uint,\n+                                           Scope: DIDescriptor,\n+                                           Name: *const c_char,\n+                                           File: DIFile,\n+                                           LineNo: c_uint,\n+                                           Ty: DIType,\n+                                           AlwaysPreserve: bool,\n+                                           Flags: c_uint,\n+                                           AddrOps: *const i64,\n+                                           AddrOpsCount: c_uint,\n+                                           ArgNo: c_uint)\n+                                           -> DIVariable;\n+\n+    pub fn LLVMRustDIBuilderCreateArrayType(Builder: DIBuilderRef,\n+                                            Size: u64,\n+                                            AlignInBits: u64,\n+                                            Ty: DIType,\n+                                            Subscripts: DIArray)\n+                                            -> DIType;\n+\n+    pub fn LLVMRustDIBuilderCreateVectorType(Builder: DIBuilderRef,\n+                                             Size: u64,\n+                                             AlignInBits: u64,\n+                                             Ty: DIType,\n+                                             Subscripts: DIArray)\n+                                             -> DIType;\n+\n+    pub fn LLVMRustDIBuilderGetOrCreateSubrange(Builder: DIBuilderRef,\n+                                                Lo: i64,\n+                                                Count: i64)\n+                                                -> DISubrange;\n+\n+    pub fn LLVMRustDIBuilderGetOrCreateArray(Builder: DIBuilderRef,\n+                                             Ptr: *const DIDescriptor,\n+                                             Count: c_uint)\n+                                             -> DIArray;\n+\n+    pub fn LLVMRustDIBuilderInsertDeclareAtEnd(Builder: DIBuilderRef,\n+                                               Val: ValueRef,\n+                                               VarInfo: DIVariable,\n+                                               AddrOps: *const i64,\n+                                               AddrOpsCount: c_uint,\n+                                               DL: ValueRef,\n+                                               InsertAtEnd: BasicBlockRef)\n+                                               -> ValueRef;\n+\n+    pub fn LLVMRustDIBuilderInsertDeclareBefore(Builder: DIBuilderRef,\n+                                                Val: ValueRef,\n+                                                VarInfo: DIVariable,\n+                                                AddrOps: *const i64,\n+                                                AddrOpsCount: c_uint,\n+                                                DL: ValueRef,\n+                                                InsertBefore: ValueRef)\n+                                                -> ValueRef;\n+\n+    pub fn LLVMRustDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n+                                             Name: *const c_char,\n+                                             Val: u64)\n+                                             -> DIEnumerator;\n+\n+    pub fn LLVMRustDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n+                                                  Scope: DIScope,\n+                                                  Name: *const c_char,\n+                                                  File: DIFile,\n+                                                  LineNumber: c_uint,\n+                                                  SizeInBits: u64,\n+                                                  AlignInBits: u64,\n+                                                  Elements: DIArray,\n+                                                  ClassType: DIType)\n+                                                  -> DIType;\n+\n+    pub fn LLVMRustDIBuilderCreateUnionType(Builder: DIBuilderRef,\n+                                            Scope: DIScope,\n+                                            Name: *const c_char,\n+                                            File: DIFile,\n+                                            LineNumber: c_uint,\n+                                            SizeInBits: u64,\n+                                            AlignInBits: u64,\n+                                            Flags: c_uint,\n+                                            Elements: DIArray,\n+                                            RunTimeLang: c_uint,\n+                                            UniqueId: *const c_char)\n+                                            -> DIType;\n+\n+    pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n+\n+    pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n+                                                        Scope: DIScope,\n+                                                        Name: *const c_char,\n+                                                        Ty: DIType,\n+                                                        File: DIFile,\n+                                                        LineNo: c_uint,\n+                                                        ColumnNo: c_uint)\n+                                                        -> DITemplateTypeParameter;\n+\n+\n+    pub fn LLVMRustDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n+                                            Scope: DIScope,\n+                                            Name: *const c_char,\n+                                            File: DIFile,\n+                                            LineNo: c_uint)\n+                                            -> DINameSpace;\n+    pub fn LLVMRustDICompositeTypeSetTypeArray(Builder: DIBuilderRef,\n+                                               CompositeType: DIType,\n+                                               TypeArray: DIArray);\n+\n+\n+    pub fn LLVMRustDIBuilderCreateDebugLocation(Context: ContextRef,\n+                                                Line: c_uint,\n+                                                Column: c_uint,\n+                                                Scope: DIScope,\n+                                                InlinedAt: MetadataRef)\n+                                                -> ValueRef;\n+    pub fn LLVMRustDIBuilderCreateOpDeref() -> i64;\n+    pub fn LLVMRustDIBuilderCreateOpPlus() -> i64;\n+\n+    pub fn LLVMRustWriteTypeToString(Type: TypeRef, s: RustStringRef);\n+    pub fn LLVMRustWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n+\n+    pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n+\n+    pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n+\n+    pub fn LLVMRustPassKind(Pass: PassRef) -> PassKind;\n+    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;\n+    pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: PassRef);\n+\n+    pub fn LLVMRustHasFeature(T: TargetMachineRef,\n+                              s: *const c_char) -> bool;\n+\n+    pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n+                                       CPU: *const c_char,\n+                                       Features: *const c_char,\n+                                       Model: CodeModel,\n+                                       Reloc: RelocMode,\n+                                       Level: CodeGenOptLevel,\n+                                       UseSoftFP: bool,\n+                                       PositionIndependentExecutable: bool,\n+                                       FunctionSections: bool,\n+                                       DataSections: bool) -> TargetMachineRef;\n+    pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n+    pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef,\n+                                     PM: PassManagerRef,\n+                                     M: ModuleRef);\n+    pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n+                                         M: ModuleRef,\n+                                         DisableSimplifyLibCalls: bool);\n+    pub fn LLVMRustConfigurePassManagerBuilder(PMB: PassManagerBuilderRef,\n+                                               OptLevel: CodeGenOptLevel,\n+                                               MergeFunctions: bool,\n+                                               SLPVectorize: bool,\n+                                               LoopVectorize: bool);\n+    pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef,\n+                                  DisableSimplifyLibCalls: bool);\n+    pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n+    pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n+                                   PM: PassManagerRef,\n+                                   M: ModuleRef,\n+                                   Output: *const c_char,\n+                                   FileType: FileType)\n+                                   -> LLVMRustResult;\n+    pub fn LLVMRustPrintModule(PM: PassManagerRef,\n+                               M: ModuleRef,\n+                               Output: *const c_char);\n+    pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n+    pub fn LLVMRustPrintPasses();\n+    pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n+    pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n+                                       AddLifetimes: bool);\n+    pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n+                                         bc: *const c_char,\n+                                         len: size_t) -> bool;\n+    pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n+                                      syms: *const *const c_char,\n+                                      len: size_t);\n+    pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n+\n+    pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n+    pub fn LLVMRustArchiveIteratorNew(AR: ArchiveRef) -> ArchiveIteratorRef;\n+    pub fn LLVMRustArchiveIteratorNext(AIR: ArchiveIteratorRef) -> ArchiveChildRef;\n+    pub fn LLVMRustArchiveChildName(ACR: ArchiveChildRef,\n+                                    size: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildData(ACR: ArchiveChildRef,\n+                                    size: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildFree(ACR: ArchiveChildRef);\n+    pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n+    pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n+\n+    pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n+                                  data: *mut *const c_char) -> size_t;\n+\n+    pub fn LLVMRustWriteTwineToString(T: TwineRef, s: RustStringRef);\n+\n+    pub fn LLVMContextSetDiagnosticHandler(C: ContextRef,\n+                                           Handler: DiagnosticHandler,\n+                                           DiagnosticContext: *mut c_void);\n+\n+    pub fn LLVMRustUnpackOptimizationDiagnostic(DI: DiagnosticInfoRef,\n+                                                pass_name_out: *mut *const c_char,\n+                                                function_out: *mut ValueRef,\n+                                                debugloc_out: *mut DebugLocRef,\n+                                                message_out: *mut TwineRef);\n+    pub fn LLVMRustUnpackInlineAsmDiagnostic(DI: DiagnosticInfoRef,\n+                                             cookie_out: *mut c_uint,\n+                                             message_out: *mut TwineRef,\n+                                             instruction_out: *mut ValueRef);\n+\n+    pub fn LLVMRustWriteDiagnosticInfoToString(DI: DiagnosticInfoRef,\n+                                               s: RustStringRef);\n+    pub fn LLVMGetDiagInfoSeverity(DI: DiagnosticInfoRef) -> DiagnosticSeverity;\n+    pub fn LLVMRustGetDiagInfoKind(DI: DiagnosticInfoRef) -> DiagnosticKind;\n+\n+    pub fn LLVMRustWriteDebugLocToString(C: ContextRef,\n+                                         DL: DebugLocRef,\n+                                         s: RustStringRef);\n+\n+    pub fn LLVMRustSetInlineAsmDiagnosticHandler(C: ContextRef,\n+                                                 H: InlineAsmDiagHandler,\n+                                                 CX: *mut c_void);\n+\n+    pub fn LLVMRustWriteSMDiagnosticToString(d: SMDiagnosticRef, s: RustStringRef);\n+\n+    pub fn LLVMRustWriteArchive(Dst: *const c_char,\n+                                NumMembers: size_t,\n+                                Members: *const RustArchiveMemberRef,\n+                                WriteSymbtab: bool,\n+                                Kind: ArchiveKind) ->\n+                                LLVMRustResult;\n+    pub fn LLVMRustArchiveMemberNew(Filename: *const c_char,\n+                                    Name: *const c_char,\n+                                    Child: ArchiveChildRef) -> RustArchiveMemberRef;\n+    pub fn LLVMRustArchiveMemberFree(Member: RustArchiveMemberRef);\n+\n+    pub fn LLVMRustSetDataLayoutFromTargetMachine(M: ModuleRef,\n+                                                  TM: TargetMachineRef);\n+    pub fn LLVMRustGetModuleDataLayout(M: ModuleRef) -> TargetDataRef;\n+\n+    pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n+                                         Inputs: *const ValueRef,\n+                                         NumInputs: c_uint)\n+                                         -> OperandBundleDefRef;\n+    pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n+\n+    pub fn LLVMRustPositionBuilderAtStart(B: BuilderRef, BB: BasicBlockRef);\n+\n+    pub fn LLVMRustSetComdat(M: ModuleRef, V: ValueRef, Name: *const c_char);\n+    pub fn LLVMRustUnsetComdat(V: ValueRef);\n+    pub fn LLVMRustSetModulePIELevel(M: ModuleRef);\n+}\n+\n+\n+// LLVM requires symbols from this library, but apparently they're not printed\n+// during llvm-config?\n+#[cfg(windows)]\n+#[link(name = \"ole32\")]\n+extern {}"}, {"sha": "6c4e1a54ea7281b4ff3d0ae55f9c3ac7c9337e76", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 90, "deletions": 2077, "changes": 2167, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -33,157 +33,35 @@\n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n-pub use self::AttributeSet::*;\n pub use self::IntPredicate::*;\n pub use self::RealPredicate::*;\n pub use self::TypeKind::*;\n-pub use self::AtomicBinOp::*;\n-pub use self::AtomicOrdering::*;\n-pub use self::SynchronizationScope::*;\n-pub use self::FileType::*;\n+pub use self::AtomicRmwBinOp::*;\n pub use self::MetadataType::*;\n-pub use self::AsmDialect::*;\n-pub use self::CodeGenOptLevel::*;\n pub use self::CodeGenOptSize::*;\n-pub use self::RelocMode::*;\n-pub use self::CodeGenModel::*;\n pub use self::DiagnosticKind::*;\n pub use self::CallConv::*;\n-pub use self::Visibility::*;\n pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n-pub use self::DLLStorageClassTypes::*;\n \n use std::str::FromStr;\n+use std::slice;\n use std::ffi::{CString, CStr};\n use std::cell::RefCell;\n-use std::slice;\n-use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n-use libc::{c_longlong, c_ulonglong, c_void};\n-use debuginfo::{DIBuilderRef, DIDescriptor,\n-                DIFile, DILexicalBlock, DISubprogram, DIType,\n-                DIBasicType, DIDerivedType, DICompositeType, DIScope,\n-                DIVariable, DIGlobalVariable, DIArray, DISubrange,\n-                DITemplateTypeParameter, DIEnumerator, DINameSpace};\n+use libc::{c_uint, c_char, size_t};\n \n pub mod archive_ro;\n pub mod diagnostic;\n+pub mod ffi;\n \n-pub type Opcode = u32;\n-pub type Bool = c_uint;\n-\n-pub const True: Bool = 1 as Bool;\n-pub const False: Bool = 0 as Bool;\n-\n-// Consts for the LLVM CallConv type, pre-cast to usize.\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum CallConv {\n-    CCallConv = 0,\n-    FastCallConv = 8,\n-    ColdCallConv = 9,\n-    X86StdcallCallConv = 64,\n-    X86FastcallCallConv = 65,\n-    X86_64_Win64 = 79,\n-    X86_VectorCall = 80\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum Visibility {\n-    LLVMDefaultVisibility = 0,\n-    HiddenVisibility = 1,\n-    ProtectedVisibility = 2,\n-}\n-\n-// This enum omits the obsolete (and no-op) linkage types DLLImportLinkage,\n-// DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n-// LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n-// they've been removed in upstream LLVM commit r203866.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum Linkage {\n-    ExternalLinkage = 0,\n-    AvailableExternallyLinkage = 1,\n-    LinkOnceAnyLinkage = 2,\n-    LinkOnceODRLinkage = 3,\n-    WeakAnyLinkage = 5,\n-    WeakODRLinkage = 6,\n-    AppendingLinkage = 7,\n-    InternalLinkage = 8,\n-    PrivateLinkage = 9,\n-    ExternalWeakLinkage = 12,\n-    CommonLinkage = 14,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone, Debug)]\n-pub enum DiagnosticSeverity {\n-    Error,\n-    Warning,\n-    Remark,\n-    Note,\n-}\n-\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum DLLStorageClassTypes {\n-    DefaultStorageClass = 0,\n-    DLLImportStorageClass = 1,\n-    DLLExportStorageClass = 2,\n-}\n-\n-bitflags! {\n-    #[derive(Default, Debug)]\n-    flags Attribute : u64 {\n-        const ZExt            = 1 << 0,\n-        const SExt            = 1 << 1,\n-        const NoReturn        = 1 << 2,\n-        const InReg           = 1 << 3,\n-        const StructRet       = 1 << 4,\n-        const NoUnwind        = 1 << 5,\n-        const NoAlias         = 1 << 6,\n-        const ByVal           = 1 << 7,\n-        const Nest            = 1 << 8,\n-        const ReadNone        = 1 << 9,\n-        const ReadOnly        = 1 << 10,\n-        const NoInline        = 1 << 11,\n-        const AlwaysInline    = 1 << 12,\n-        const OptimizeForSize = 1 << 13,\n-        const StackProtect    = 1 << 14,\n-        const StackProtectReq = 1 << 15,\n-        const NoCapture       = 1 << 21,\n-        const NoRedZone       = 1 << 22,\n-        const NoImplicitFloat = 1 << 23,\n-        const Naked           = 1 << 24,\n-        const InlineHint      = 1 << 25,\n-        const ReturnsTwice    = 1 << 29,\n-        const UWTable         = 1 << 30,\n-        const NonLazyBind     = 1 << 31,\n+pub use ffi::*;\n \n-        // Some of these are missing from the LLVM C API, the rest are\n-        // present, but commented out, and preceded by the following warning:\n-        // FIXME: These attributes are currently not included in the C API as\n-        // a temporary measure until the API/ABI impact to the C API is understood\n-        // and the path forward agreed upon.\n-        const SanitizeAddress = 1 << 32,\n-        const MinSize         = 1 << 33,\n-        const NoDuplicate     = 1 << 34,\n-        const StackProtectStrong = 1 << 35,\n-        const SanitizeThread  = 1 << 36,\n-        const SanitizeMemory  = 1 << 37,\n-        const NoBuiltin       = 1 << 38,\n-        const Returned        = 1 << 39,\n-        const Cold            = 1 << 40,\n-        const Builtin         = 1 << 41,\n-        const OptimizeNone    = 1 << 42,\n-        const InAlloca        = 1 << 43,\n-        const NonNull         = 1 << 44,\n-        const JumpTable       = 1 << 45,\n-        const Convergent      = 1 << 46,\n-        const SafeStack       = 1 << 47,\n-        const NoRecurse       = 1 << 48,\n-        const InaccessibleMemOnly         = 1 << 49,\n-        const InaccessibleMemOrArgMemOnly = 1 << 50,\n+impl LLVMRustResult {\n+    pub fn into_result(self) -> Result<(), ()> {\n+        match self {\n+            LLVMRustResult::Success => Ok(()),\n+            LLVMRustResult::Failure => Err(()),\n+        }\n     }\n }\n \n@@ -214,167 +92,64 @@ impl Attributes {\n         self\n     }\n \n-    pub fn apply_llfn(&self, idx: usize, llfn: ValueRef) {\n+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n         unsafe {\n-            LLVMAddFunctionAttribute(llfn, idx as c_uint, self.regular.bits());\n+            self.regular.apply_llfn(idx, llfn);\n             if self.dereferenceable_bytes != 0 {\n-                LLVMAddDereferenceableAttr(llfn, idx as c_uint,\n-                                           self.dereferenceable_bytes);\n+                LLVMRustAddDereferenceableAttr(\n+                    llfn,\n+                    idx.as_uint(),\n+                    self.dereferenceable_bytes);\n             }\n         }\n     }\n \n-    pub fn apply_callsite(&self, idx: usize, callsite: ValueRef) {\n+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n         unsafe {\n-            LLVMRustAddCallSiteAttribute(callsite, idx as c_uint, self.regular.bits());\n+            self.regular.apply_callsite(idx, callsite);\n             if self.dereferenceable_bytes != 0 {\n-                LLVMAddDereferenceableCallSiteAttr(callsite, idx as c_uint,\n-                                                   self.dereferenceable_bytes);\n+                LLVMRustAddDereferenceableCallSiteAttr(\n+                    callsite,\n+                    idx.as_uint(),\n+                    self.dereferenceable_bytes);\n             }\n         }\n     }\n }\n \n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum AttributeSet {\n-    ReturnIndex = 0,\n-    FunctionIndex = !0\n-}\n-\n-// enum for the LLVM IntPredicate type\n-#[derive(Copy, Clone)]\n-pub enum IntPredicate {\n-    IntEQ = 32,\n-    IntNE = 33,\n-    IntUGT = 34,\n-    IntUGE = 35,\n-    IntULT = 36,\n-    IntULE = 37,\n-    IntSGT = 38,\n-    IntSGE = 39,\n-    IntSLT = 40,\n-    IntSLE = 41,\n-}\n-\n-// enum for the LLVM RealPredicate type\n-#[derive(Copy, Clone)]\n-pub enum RealPredicate {\n-    RealPredicateFalse = 0,\n-    RealOEQ = 1,\n-    RealOGT = 2,\n-    RealOGE = 3,\n-    RealOLT = 4,\n-    RealOLE = 5,\n-    RealONE = 6,\n-    RealORD = 7,\n-    RealUNO = 8,\n-    RealUEQ = 9,\n-    RealUGT = 10,\n-    RealUGE = 11,\n-    RealULT = 12,\n-    RealULE = 13,\n-    RealUNE = 14,\n-    RealPredicateTrue = 15,\n-}\n-\n-// The LLVM TypeKind type - must stay in sync with the def of\n-// LLVMTypeKind in llvm/include/llvm-c/Core.h\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(C)]\n-pub enum TypeKind {\n-    Void      = 0,\n-    Half      = 1,\n-    Float     = 2,\n-    Double    = 3,\n-    X86_FP80  = 4,\n-    FP128     = 5,\n-    PPC_FP128 = 6,\n-    Label     = 7,\n-    Integer   = 8,\n-    Function  = 9,\n-    Struct    = 10,\n-    Array     = 11,\n-    Pointer   = 12,\n-    Vector    = 13,\n-    Metadata  = 14,\n-    X86_MMX   = 15,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum AtomicBinOp {\n-    AtomicXchg = 0,\n-    AtomicAdd  = 1,\n-    AtomicSub  = 2,\n-    AtomicAnd  = 3,\n-    AtomicNand = 4,\n-    AtomicOr   = 5,\n-    AtomicXor  = 6,\n-    AtomicMax  = 7,\n-    AtomicMin  = 8,\n-    AtomicUMax = 9,\n-    AtomicUMin = 10,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum AtomicOrdering {\n-    NotAtomic = 0,\n-    Unordered = 1,\n-    Monotonic = 2,\n-    // Consume = 3,  // Not specified yet.\n-    Acquire = 4,\n-    Release = 5,\n-    AcquireRelease = 6,\n-    SequentiallyConsistent = 7\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum SynchronizationScope {\n-    SingleThread = 0,\n-    CrossThread = 1\n+pub fn AddFunctionAttrStringValue(\n+    llfn: ValueRef,\n+    idx: AttributePlace,\n+    attr: &'static str,\n+    value: &'static str\n+) {\n+    unsafe {\n+        LLVMRustAddFunctionAttrStringValue(\n+            llfn,\n+            idx.as_uint(),\n+            attr.as_ptr() as *const _,\n+            value.as_ptr() as *const _)\n+    }\n }\n \n-// Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n #[repr(C)]\n #[derive(Copy, Clone)]\n-pub enum FileType {\n-    AssemblyFileType = 0,\n-    ObjectFileType = 1\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum MetadataType {\n-    MD_dbg = 0,\n-    MD_tbaa = 1,\n-    MD_prof = 2,\n-    MD_fpmath = 3,\n-    MD_range = 4,\n-    MD_tbaa_struct = 5,\n-    MD_invariant_load = 6,\n-    MD_alias_scope = 7,\n-    MD_noalias = 8,\n-    MD_nontemporal = 9,\n-    MD_mem_parallel_loop_access = 10,\n-    MD_nonnull = 11,\n+pub enum AttributePlace {\n+    Argument(u32),\n+    Function,\n }\n \n-// Inline Asm Dialect\n-#[derive(Copy, Clone)]\n-pub enum AsmDialect {\n-    AD_ATT   = 0,\n-    AD_Intel = 1\n-}\n+impl AttributePlace {\n+    pub fn ReturnValue() -> Self {\n+        AttributePlace::Argument(0)\n+    }\n \n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum CodeGenOptLevel {\n-    CodeGenLevelNone = 0,\n-    CodeGenLevelLess = 1,\n-    CodeGenLevelDefault = 2,\n-    CodeGenLevelAggressive = 3,\n+    fn as_uint(self) -> c_uint {\n+        match self {\n+            AttributePlace::Function => !0,\n+            AttributePlace::Argument(i) => i,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -385,48 +160,6 @@ pub enum CodeGenOptSize {\n     CodeGenOptSizeAggressive = 2,\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum RelocMode {\n-    RelocDefault = 0,\n-    RelocStatic = 1,\n-    RelocPIC = 2,\n-    RelocDynamicNoPic = 3,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum CodeGenModel {\n-    CodeModelDefault = 0,\n-    CodeModelJITDefault = 1,\n-    CodeModelSmall = 2,\n-    CodeModelKernel = 3,\n-    CodeModelMedium = 4,\n-    CodeModelLarge = 5,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum DiagnosticKind {\n-    DK_InlineAsm = 0,\n-    DK_StackSize,\n-    DK_DebugMetadataVersion,\n-    DK_SampleProfile,\n-    DK_OptimizationRemark,\n-    DK_OptimizationRemarkMissed,\n-    DK_OptimizationRemarkAnalysis,\n-    DK_OptimizationFailure,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum ArchiveKind {\n-    K_GNU,\n-    K_MIPS64,\n-    K_BSD,\n-    K_COFF,\n-}\n-\n impl FromStr for ArchiveKind {\n     type Err = ();\n \n@@ -441,1726 +174,22 @@ impl FromStr for ArchiveKind {\n     }\n }\n \n-/// Represents the different LLVM passes Rust supports\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(C)]\n-pub enum SupportedPassKind {\n-    Function,\n-    Module,\n-    Unsupported,\n-}\n-\n-// Opaque pointer types\n-#[allow(missing_copy_implementations)]\n-pub enum Module_opaque {}\n-pub type ModuleRef = *mut Module_opaque;\n #[allow(missing_copy_implementations)]\n-pub enum Context_opaque {}\n-pub type ContextRef = *mut Context_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Type_opaque {}\n-pub type TypeRef = *mut Type_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Value_opaque {}\n-pub type ValueRef = *mut Value_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Metadata_opaque {}\n-pub type MetadataRef = *mut Metadata_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum BasicBlock_opaque {}\n-pub type BasicBlockRef = *mut BasicBlock_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Builder_opaque {}\n-pub type BuilderRef = *mut Builder_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum ExecutionEngine_opaque {}\n-pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum MemoryBuffer_opaque {}\n-pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum PassManager_opaque {}\n-pub type PassManagerRef = *mut PassManager_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum PassManagerBuilder_opaque {}\n-pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Use_opaque {}\n-pub type UseRef = *mut Use_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum TargetData_opaque {}\n-pub type TargetDataRef = *mut TargetData_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum ObjectFile_opaque {}\n-pub type ObjectFileRef = *mut ObjectFile_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum SectionIterator_opaque {}\n-pub type SectionIteratorRef = *mut SectionIterator_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Pass_opaque {}\n-pub type PassRef = *mut Pass_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum TargetMachine_opaque {}\n-pub type TargetMachineRef = *mut TargetMachine_opaque;\n-pub enum Archive_opaque {}\n-pub type ArchiveRef = *mut Archive_opaque;\n-pub enum ArchiveIterator_opaque {}\n-pub type ArchiveIteratorRef = *mut ArchiveIterator_opaque;\n-pub enum ArchiveChild_opaque {}\n-pub type ArchiveChildRef = *mut ArchiveChild_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Twine_opaque {}\n-pub type TwineRef = *mut Twine_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum DiagnosticInfo_opaque {}\n-pub type DiagnosticInfoRef = *mut DiagnosticInfo_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum DebugLoc_opaque {}\n-pub type DebugLocRef = *mut DebugLoc_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum SMDiagnostic_opaque {}\n-pub type SMDiagnosticRef = *mut SMDiagnostic_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum RustArchiveMember_opaque {}\n-pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum OperandBundleDef_opaque {}\n-pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n-\n-pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n-pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n-\n-pub mod debuginfo {\n-    pub use self::DIDescriptorFlags::*;\n-    use super::{MetadataRef};\n-\n-    #[allow(missing_copy_implementations)]\n-    pub enum DIBuilder_opaque {}\n-    pub type DIBuilderRef = *mut DIBuilder_opaque;\n-\n-    pub type DIDescriptor = MetadataRef;\n-    pub type DIScope = DIDescriptor;\n-    pub type DILocation = DIDescriptor;\n-    pub type DIFile = DIScope;\n-    pub type DILexicalBlock = DIScope;\n-    pub type DISubprogram = DIScope;\n-    pub type DINameSpace = DIScope;\n-    pub type DIType = DIDescriptor;\n-    pub type DIBasicType = DIType;\n-    pub type DIDerivedType = DIType;\n-    pub type DICompositeType = DIDerivedType;\n-    pub type DIVariable = DIDescriptor;\n-    pub type DIGlobalVariable = DIDescriptor;\n-    pub type DIArray = DIDescriptor;\n-    pub type DISubrange = DIDescriptor;\n-    pub type DIEnumerator = DIDescriptor;\n-    pub type DITemplateTypeParameter = DIDescriptor;\n-\n-    #[derive(Copy, Clone)]\n-    pub enum DIDescriptorFlags {\n-      FlagPrivate            = 1 << 0,\n-      FlagProtected          = 1 << 1,\n-      FlagFwdDecl            = 1 << 2,\n-      FlagAppleBlock         = 1 << 3,\n-      FlagBlockByrefStruct   = 1 << 4,\n-      FlagVirtual            = 1 << 5,\n-      FlagArtificial         = 1 << 6,\n-      FlagExplicit           = 1 << 7,\n-      FlagPrototyped         = 1 << 8,\n-      FlagObjcClassComplete  = 1 << 9,\n-      FlagObjectPointer      = 1 << 10,\n-      FlagVector             = 1 << 11,\n-      FlagStaticMember       = 1 << 12,\n-      FlagIndirectVariable   = 1 << 13,\n-      FlagLValueReference    = 1 << 14,\n-      FlagRValueReference    = 1 << 15\n-    }\n-}\n-\n-\n-// Link to our native llvm bindings (things that we need to use the C++ api\n-// for) and because llvm is written in C++ we need to link against libstdc++\n-//\n-// You'll probably notice that there is an omission of all LLVM libraries\n-// from this location. This is because the set of LLVM libraries that we\n-// link to is mostly defined by LLVM, and the `llvm-config` tool is used to\n-// figure out the exact set of libraries. To do this, the build system\n-// generates an llvmdeps.rs file next to this one which will be\n-// automatically updated whenever LLVM is updated to include an up-to-date\n-// set of the libraries we need to link to LLVM for.\n-#[link(name = \"rustllvm\", kind = \"static\")]\n-#[cfg(not(cargobuild))]\n-extern {}\n-\n-#[linked_from = \"rustllvm\"] // not quite true but good enough\n-extern {\n-    /* Create and destroy contexts. */\n-    pub fn LLVMContextCreate() -> ContextRef;\n-    pub fn LLVMContextDispose(C: ContextRef);\n-    pub fn LLVMGetMDKindIDInContext(C: ContextRef,\n-                                    Name: *const c_char,\n-                                    SLen: c_uint)\n-                                    -> c_uint;\n-\n-    /* Create and destroy modules. */\n-    pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char,\n-                                             C: ContextRef)\n-                                             -> ModuleRef;\n-    pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n-    pub fn LLVMCloneModule(M: ModuleRef) -> ModuleRef;\n-    pub fn LLVMDisposeModule(M: ModuleRef);\n-\n-    /// Data layout. See Module::getDataLayout.\n-    pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n-    pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n-\n-    /// Target triple. See Module::getTargetTriple.\n-    pub fn LLVMGetTarget(M: ModuleRef) -> *const c_char;\n-    pub fn LLVMSetTarget(M: ModuleRef, Triple: *const c_char);\n-\n-    /// See Module::dump.\n-    pub fn LLVMDumpModule(M: ModuleRef);\n-\n-    /// See Module::setModuleInlineAsm.\n-    pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n-\n-    /// See llvm::LLVMTypeKind::getTypeID.\n-    pub fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n-\n-    /// See llvm::LLVMType::getContext.\n-    pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n-\n-    /* Operations on integer types */\n-    pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint)\n-                                -> TypeRef;\n-\n-    pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n-\n-    /* Operations on real types */\n-    pub fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n-\n-    /* Operations on function types */\n-    pub fn LLVMFunctionType(ReturnType: TypeRef,\n-                            ParamTypes: *const TypeRef,\n-                            ParamCount: c_uint,\n-                            IsVarArg: Bool)\n-                            -> TypeRef;\n-    pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n-    pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n-    pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *mut TypeRef);\n-\n-    /* Operations on struct types */\n-    pub fn LLVMStructTypeInContext(C: ContextRef,\n-                                   ElementTypes: *const TypeRef,\n-                                   ElementCount: c_uint,\n-                                   Packed: Bool)\n-                                   -> TypeRef;\n-    pub fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetStructElementTypes(StructTy: TypeRef,\n-                                     Dest: *mut TypeRef);\n-    pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n-\n-    /* Operations on array, pointer, and vector types (sequence types) */\n-    pub fn LLVMRustArrayType(ElementType: TypeRef, ElementCount: u64) -> TypeRef;\n-    pub fn LLVMPointerType(ElementType: TypeRef, AddressSpace: c_uint)\n-                           -> TypeRef;\n-    pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint)\n-                          -> TypeRef;\n-\n-    pub fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n-    pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef, V: ValueRef)\n-                                  -> *const c_void;\n-    pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n-\n-    /* Operations on other types */\n-    pub fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n-\n-    /* Operations on all values */\n-    pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n-    pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n-    pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n-    pub fn LLVMDumpValue(Val: ValueRef);\n-    pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n-    pub fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n-    pub fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n-    pub fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n-\n-    /* Operations on Uses */\n-    pub fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n-    pub fn LLVMGetNextUse(U: UseRef) -> UseRef;\n-    pub fn LLVMGetUser(U: UseRef) -> ValueRef;\n-    pub fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n-\n-    /* Operations on Users */\n-    pub fn LLVMGetNumOperands(Val: ValueRef) -> c_int;\n-    pub fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n-    pub fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n-\n-    /* Operations on constants of any type */\n-    pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n-    /* all zeroes */\n-    pub fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMConstICmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstFCmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n-                         -> ValueRef;\n-    /* only for isize/vector */\n-    pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMIsConstant(Val: ValueRef) -> Bool;\n-    pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n-    pub fn LLVMIsUndef(Val: ValueRef) -> Bool;\n-    pub fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n-\n-    /* Operations on metadata */\n-    pub fn LLVMMDStringInContext(C: ContextRef,\n-                                 Str: *const c_char,\n-                                 SLen: c_uint)\n-                                 -> ValueRef;\n-    pub fn LLVMMDNodeInContext(C: ContextRef,\n-                               Vals: *const ValueRef,\n-                               Count: c_uint)\n-                               -> ValueRef;\n-    pub fn LLVMAddNamedMetadataOperand(M: ModuleRef,\n-                                       Str: *const c_char,\n-                                       Val: ValueRef);\n-\n-    /* Operations on scalar constants */\n-    pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool)\n-                        -> ValueRef;\n-    pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *const c_char, Radix: u8)\n-                                -> ValueRef;\n-    pub fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n-                                       Text: *const c_char,\n-                                       SLen: c_uint,\n-                                       Radix: u8)\n-                                       -> ValueRef;\n-    pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n-    pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n-                                        Text: *const c_char,\n-                                        SLen: c_uint)\n-                                        -> ValueRef;\n-    pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n-    pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n-\n-\n-    /* Operations on composite constants */\n-    pub fn LLVMConstStringInContext(C: ContextRef,\n-                                    Str: *const c_char,\n-                                    Length: c_uint,\n-                                    DontNullTerminate: Bool)\n-                                    -> ValueRef;\n-    pub fn LLVMConstStructInContext(C: ContextRef,\n-                                    ConstantVals: *const ValueRef,\n-                                    Count: c_uint,\n-                                    Packed: Bool)\n-                                    -> ValueRef;\n-\n-    pub fn LLVMConstArray(ElementTy: TypeRef,\n-                          ConstantVals: *const ValueRef,\n-                          Length: c_uint)\n-                          -> ValueRef;\n-    pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint)\n-                           -> ValueRef;\n-\n-    /* Constant expressions */\n-    pub fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstNSWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstNUWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstNSWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstNUWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstNSWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstNUWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstUDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n-                              RHSConstant: ValueRef)\n-                              -> ValueRef;\n-    pub fn LLVMConstFDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstURem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstSRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstFRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstAnd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstOr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                       -> ValueRef;\n-    pub fn LLVMConstXor(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstGEP(ConstantVal: ValueRef,\n-                        ConstantIndices: *const ValueRef,\n-                        NumIndices: c_uint)\n-                        -> ValueRef;\n-    pub fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n-                                ConstantIndices: *const ValueRef,\n-                                NumIndices: c_uint)\n-                                -> ValueRef;\n-    pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n-                          -> ValueRef;\n-    pub fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstFPTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n-                            -> ValueRef;\n-    pub fn LLVMConstFPExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                          -> ValueRef;\n-    pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: TypeRef)\n-                             -> ValueRef;\n-    pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: TypeRef)\n-                             -> ValueRef;\n-    pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                            -> ValueRef;\n-    pub fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                   -> ValueRef;\n-    pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                -> ValueRef;\n-    pub fn LLVMConstIntCast(ConstantVal: ValueRef,\n-                            ToType: TypeRef,\n-                            isSigned: Bool)\n-                            -> ValueRef;\n-    pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstSelect(ConstantCondition: ValueRef,\n-                           ConstantIfTrue: ValueRef,\n-                           ConstantIfFalse: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstExtractElement(VectorConstant: ValueRef,\n-                                   IndexConstant: ValueRef)\n-                                   -> ValueRef;\n-    pub fn LLVMConstInsertElement(VectorConstant: ValueRef,\n-                                  ElementValueConstant: ValueRef,\n-                                  IndexConstant: ValueRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n-                                  VectorBConstant: ValueRef,\n-                                  MaskConstant: ValueRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n-                                 IdxList: *const c_uint,\n-                                 NumIdx: c_uint)\n-                                 -> ValueRef;\n-    pub fn LLVMConstInsertValue(AggConstant: ValueRef,\n-                                ElementValueConstant: ValueRef,\n-                                IdxList: *const c_uint,\n-                                NumIdx: c_uint)\n-                                -> ValueRef;\n-    pub fn LLVMConstInlineAsm(Ty: TypeRef,\n-                              AsmString: *const c_char,\n-                              Constraints: *const c_char,\n-                              HasSideEffects: Bool,\n-                              IsAlignStack: Bool)\n-                              -> ValueRef;\n-    pub fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n-\n-\n-\n-    /* Operations on global variables, functions, and aliases (globals) */\n-    pub fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n-    pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n-    pub fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n-    pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n-    pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n-    pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n-    pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n-\n-\n-    /* Operations on global variables */\n-    pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n-                                       Ty: TypeRef,\n-                                       Name: *const c_char,\n-                                       AddressSpace: c_uint)\n-                                       -> ValueRef;\n-    pub fn LLVMGetNamedGlobal(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMGetOrInsertGlobal(M: ModuleRef, Name: *const c_char, T: TypeRef) -> ValueRef;\n-    pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n-    pub fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMSetInitializer(GlobalVar: ValueRef,\n-                              ConstantVal: ValueRef);\n-    pub fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n-    pub fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n-    pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n-    pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n-    pub fn LLVMGetNamedValue(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-\n-    /* Operations on aliases */\n-    pub fn LLVMAddAlias(M: ModuleRef,\n-                        Ty: TypeRef,\n-                        Aliasee: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-\n-    /* Operations on functions */\n-    pub fn LLVMAddFunction(M: ModuleRef,\n-                           Name: *const c_char,\n-                           FunctionTy: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMDeleteFunction(Fn: ValueRef);\n-    pub fn LLVMGetOrInsertFunction(M: ModuleRef,\n-                                   Name: *const c_char,\n-                                   FunctionTy: TypeRef)\n-                                   -> ValueRef;\n-    pub fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-    pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n-    pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n-    pub fn LLVMAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: uint64_t);\n-    pub fn LLVMAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: uint64_t);\n-    pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n-    pub fn LLVMAddFunctionAttrStringValue(Fn: ValueRef, index: c_uint,\n-                                          Name: *const c_char,\n-                                          Value: *const c_char);\n-    pub fn LLVMRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: uint64_t);\n-    pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n-    pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_uint);\n-\n-    /* Operations on parameters */\n-    pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMGetParams(Fn: ValueRef, Params: *const ValueRef);\n-    pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n-    pub fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n-    pub fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n-    pub fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n-    pub fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n-    pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n-\n-    /* Operations on basic blocks */\n-    pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n-    pub fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *const ValueRef);\n-    pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-    pub fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-    pub fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-\n-    pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n-                                         Fn: ValueRef,\n-                                         Name: *const c_char)\n-                                         -> BasicBlockRef;\n-    pub fn LLVMInsertBasicBlockInContext(C: ContextRef,\n-                                         BB: BasicBlockRef,\n-                                         Name: *const c_char)\n-                                         -> BasicBlockRef;\n-    pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n-\n-    pub fn LLVMMoveBasicBlockAfter(BB: BasicBlockRef,\n-                                   MoveAfter: BasicBlockRef);\n-\n-    pub fn LLVMMoveBasicBlockBefore(BB: BasicBlockRef,\n-                                    MoveBefore: BasicBlockRef);\n-\n-    /* Operations on instructions */\n-    pub fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n-\n-    /* Operations on call sites */\n-    pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n-    pub fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n-    pub fn LLVMAddInstrAttribute(Instr: ValueRef,\n-                                 index: c_uint,\n-                                 IA: c_uint);\n-    pub fn LLVMRemoveInstrAttribute(Instr: ValueRef,\n-                                    index: c_uint,\n-                                    IA: c_uint);\n-    pub fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n-                                      index: c_uint,\n-                                      align: c_uint);\n-    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef,\n-                                    index: c_uint,\n-                                    Val: uint64_t);\n-    pub fn LLVMAddDereferenceableCallSiteAttr(Instr: ValueRef,\n-                                              index: c_uint,\n-                                              bytes: uint64_t);\n-\n-    /* Operations on call instructions (only) */\n-    pub fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n-    pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n-\n-    /* Operations on load/store instructions (only) */\n-    pub fn LLVMGetVolatile(MemoryAccessInst: ValueRef) -> Bool;\n-    pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);\n-\n-    /* Operations on phi nodes */\n-    pub fn LLVMAddIncoming(PhiNode: ValueRef,\n-                           IncomingValues: *const ValueRef,\n-                           IncomingBlocks: *const BasicBlockRef,\n-                           Count: c_uint);\n-    pub fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n-    pub fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint)\n-                                -> ValueRef;\n-    pub fn LLVMGetIncomingBlock(PhiNode: ValueRef, Index: c_uint)\n-                                -> BasicBlockRef;\n-\n-    /* Instruction builders */\n-    pub fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n-    pub fn LLVMPositionBuilder(Builder: BuilderRef,\n-                               Block: BasicBlockRef,\n-                               Instr: ValueRef);\n-    pub fn LLVMPositionBuilderBefore(Builder: BuilderRef,\n-                                     Instr: ValueRef);\n-    pub fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n-                                    Block: BasicBlockRef);\n-    pub fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n-    pub fn LLVMClearInsertionPosition(Builder: BuilderRef);\n-    pub fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n-    pub fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n-                                         Instr: ValueRef,\n-                                         Name: *const c_char);\n-    pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n-\n-    /* Execution engine */\n-    pub fn LLVMBuildExecutionEngine(Mod: ModuleRef) -> ExecutionEngineRef;\n-    pub fn LLVMDisposeExecutionEngine(EE: ExecutionEngineRef);\n-    pub fn LLVMExecutionEngineFinalizeObject(EE: ExecutionEngineRef);\n-    pub fn LLVMRustLoadDynamicLibrary(path: *const c_char) -> Bool;\n-    pub fn LLVMExecutionEngineAddModule(EE: ExecutionEngineRef, M: ModuleRef);\n-    pub fn LLVMExecutionEngineRemoveModule(EE: ExecutionEngineRef, M: ModuleRef)\n-                                           -> Bool;\n-\n-    /* Metadata */\n-    pub fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n-    pub fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n-    pub fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n-\n-    /* Terminators */\n-    pub fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n-    pub fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildAggregateRet(B: BuilderRef,\n-                                 RetVals: *const ValueRef,\n-                                 N: c_uint)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMBuildCondBr(B: BuilderRef,\n-                           If: ValueRef,\n-                           Then: BasicBlockRef,\n-                           Else: BasicBlockRef)\n-                           -> ValueRef;\n-    pub fn LLVMBuildSwitch(B: BuilderRef,\n-                           V: ValueRef,\n-                           Else: BasicBlockRef,\n-                           NumCases: c_uint)\n-                           -> ValueRef;\n-    pub fn LLVMBuildIndirectBr(B: BuilderRef,\n-                               Addr: ValueRef,\n-                               NumDests: c_uint)\n-                               -> ValueRef;\n-    pub fn LLVMRustBuildInvoke(B: BuilderRef,\n-                               Fn: ValueRef,\n-                               Args: *const ValueRef,\n-                               NumArgs: c_uint,\n-                               Then: BasicBlockRef,\n-                               Catch: BasicBlockRef,\n-                               Bundle: OperandBundleDefRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-    pub fn LLVMRustBuildLandingPad(B: BuilderRef,\n-                                   Ty: TypeRef,\n-                                   PersFn: ValueRef,\n-                                   NumClauses: c_uint,\n-                                   Name: *const c_char,\n-                                   F: ValueRef)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n-\n-    pub fn LLVMRustBuildCleanupPad(B: BuilderRef,\n-                                   ParentPad: ValueRef,\n-                                   ArgCnt: c_uint,\n-                                   Args: *const ValueRef,\n-                                   Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustBuildCleanupRet(B: BuilderRef,\n-                                   CleanupPad: ValueRef,\n-                                   UnwindBB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMRustBuildCatchPad(B: BuilderRef,\n-                                 ParentPad: ValueRef,\n-                                 ArgCnt: c_uint,\n-                                 Args: *const ValueRef,\n-                                 Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustBuildCatchRet(B: BuilderRef,\n-                                 Pad: ValueRef,\n-                                 BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMRustBuildCatchSwitch(Builder: BuilderRef,\n-                                    ParentPad: ValueRef,\n-                                    BB: BasicBlockRef,\n-                                    NumHandlers: c_uint,\n-                                    Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustAddHandler(CatchSwitch: ValueRef,\n-                              Handler: BasicBlockRef);\n-    pub fn LLVMRustSetPersonalityFn(B: BuilderRef, Pers: ValueRef);\n-\n-    /* Add a case to the switch instruction */\n-    pub fn LLVMAddCase(Switch: ValueRef,\n-                       OnVal: ValueRef,\n-                       Dest: BasicBlockRef);\n-\n-    /* Add a destination to the indirectbr instruction */\n-    pub fn LLVMAddDestination(IndirectBr: ValueRef, Dest: BasicBlockRef);\n-\n-    /* Add a clause to the landing pad instruction */\n-    pub fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n-\n-    /* Set the cleanup on a landing pad instruction */\n-    pub fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n-\n-    /* Arithmetic */\n-    pub fn LLVMBuildAdd(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWAdd(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWAdd(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFAdd(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSub(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWSub(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWSub(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFSub(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildMul(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWMul(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWMul(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFMul(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildUDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildExactSDiv(B: BuilderRef,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildFDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildURem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSRem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFRem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildShl(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildLShr(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildAShr(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildAnd(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildOr(B: BuilderRef,\n-                       LHS: ValueRef,\n-                       RHS: ValueRef,\n-                       Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildXor(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildBinOp(B: BuilderRef,\n-                          Op: Opcode,\n-                          LHS: ValueRef,\n-                          RHS: ValueRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: ValueRef);\n-\n-    /* Memory */\n-    pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildLoad(B: BuilderRef,\n-                         PointerVal: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-\n-    pub fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef)\n-                          -> ValueRef;\n-\n-    pub fn LLVMBuildGEP(B: BuilderRef,\n-                        Pointer: ValueRef,\n-                        Indices: *const ValueRef,\n-                        NumIndices: c_uint,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildInBoundsGEP(B: BuilderRef,\n-                                Pointer: ValueRef,\n-                                Indices: *const ValueRef,\n-                                NumIndices: c_uint,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-    pub fn LLVMBuildStructGEP(B: BuilderRef,\n-                              Pointer: ValueRef,\n-                              Idx: c_uint,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildGlobalString(B: BuilderRef,\n-                                 Str: *const c_char,\n-                                 Name: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n-                                    Str: *const c_char,\n-                                    Name: *const c_char)\n-                                    -> ValueRef;\n-\n-    /* Casts */\n-    pub fn LLVMBuildTrunc(B: BuilderRef,\n-                          Val: ValueRef,\n-                          DestTy: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildZExt(B: BuilderRef,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSExt(B: BuilderRef,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFPToUI(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFPToSI(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildUIToFP(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildSIToFP(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFPTrunc(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-    pub fn LLVMBuildFPExt(B: BuilderRef,\n-                          Val: ValueRef,\n-                          DestTy: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildPtrToInt(B: BuilderRef,\n-                             Val: ValueRef,\n-                             DestTy: TypeRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildIntToPtr(B: BuilderRef,\n-                             Val: ValueRef,\n-                             DestTy: TypeRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildBitCast(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-    pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n-                                  Val: ValueRef,\n-                                  DestTy: TypeRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n-                                  Val: ValueRef,\n-                                  DestTy: TypeRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n-                                   Val: ValueRef,\n-                                   DestTy: TypeRef,\n-                                   Name: *const c_char)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildCast(B: BuilderRef,\n-                         Op: Opcode,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildPointerCast(B: BuilderRef,\n-                                Val: ValueRef,\n-                                DestTy: TypeRef,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-    pub fn LLVMBuildIntCast(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-    pub fn LLVMBuildFPCast(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-\n-    /* Comparisons */\n-    pub fn LLVMBuildICmp(B: BuilderRef,\n-                         Op: c_uint,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFCmp(B: BuilderRef,\n-                         Op: c_uint,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-\n-    /* Miscellaneous instructions */\n-    pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMRustBuildCall(B: BuilderRef,\n-                             Fn: ValueRef,\n-                             Args: *const ValueRef,\n-                             NumArgs: c_uint,\n-                             Bundle: OperandBundleDefRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildSelect(B: BuilderRef,\n-                           If: ValueRef,\n-                           Then: ValueRef,\n-                           Else: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildVAArg(B: BuilderRef,\n-                          list: ValueRef,\n-                          Ty: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildExtractElement(B: BuilderRef,\n-                                   VecVal: ValueRef,\n-                                   Index: ValueRef,\n-                                   Name: *const c_char)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildInsertElement(B: BuilderRef,\n-                                  VecVal: ValueRef,\n-                                  EltVal: ValueRef,\n-                                  Index: ValueRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildShuffleVector(B: BuilderRef,\n-                                  V1: ValueRef,\n-                                  V2: ValueRef,\n-                                  Mask: ValueRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildExtractValue(B: BuilderRef,\n-                                 AggVal: ValueRef,\n-                                 Index: c_uint,\n-                                 Name: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildInsertValue(B: BuilderRef,\n-                                AggVal: ValueRef,\n-                                EltVal: ValueRef,\n-                                Index: c_uint,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-\n-    pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildPtrDiff(B: BuilderRef,\n-                            LHS: ValueRef,\n-                            RHS: ValueRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-\n-    /* Atomic Operations */\n-    pub fn LLVMBuildAtomicLoad(B: BuilderRef,\n-                               PointerVal: ValueRef,\n-                               Name: *const c_char,\n-                               Order: AtomicOrdering,\n-                               Alignment: c_uint)\n-                               -> ValueRef;\n-\n-    pub fn LLVMBuildAtomicStore(B: BuilderRef,\n-                                Val: ValueRef,\n-                                Ptr: ValueRef,\n-                                Order: AtomicOrdering,\n-                                Alignment: c_uint)\n-                                -> ValueRef;\n-\n-    pub fn LLVMRustBuildAtomicCmpXchg(B: BuilderRef,\n-                                  LHS: ValueRef,\n-                                  CMP: ValueRef,\n-                                  RHS: ValueRef,\n-                                  Order: AtomicOrdering,\n-                                  FailureOrder: AtomicOrdering,\n-                                  Weak: Bool)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildAtomicRMW(B: BuilderRef,\n-                              Op: AtomicBinOp,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n-                              Order: AtomicOrdering,\n-                              SingleThreaded: Bool)\n-                              -> ValueRef;\n-\n-    pub fn LLVMBuildAtomicFence(B: BuilderRef,\n-                                Order: AtomicOrdering,\n-                                Scope: SynchronizationScope);\n-\n-\n-    /* Selected entries from the downcasts. */\n-    pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n-\n-    /// Writes a module to the specified path. Returns 0 on success.\n-    pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n-\n-    /// Creates target data from a target layout string.\n-    pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n-    /// Number of bytes clobbered when doing a Store to *T.\n-    pub fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n-                               -> c_ulonglong;\n-\n-    /// Number of bytes clobbered when doing a Store to *T.\n-    pub fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n-                                -> c_ulonglong;\n-\n-    /// Distance between successive elements in an array of T. Includes ABI padding.\n-    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n-\n-    /// Returns the preferred alignment of a type.\n-    pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                        -> c_uint;\n-    /// Returns the minimum alignment of a type.\n-    pub fn LLVMABIAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                  -> c_uint;\n-\n-    /// Computes the byte offset of the indexed struct element for a\n-    /// target.\n-    pub fn LLVMOffsetOfElement(TD: TargetDataRef,\n-                               StructTy: TypeRef,\n-                               Element: c_uint)\n-                               -> c_ulonglong;\n-\n-    /// Returns the minimum alignment of a type when part of a call frame.\n-    pub fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                        -> c_uint;\n-\n-    /// Disposes target data.\n-    pub fn LLVMDisposeTargetData(TD: TargetDataRef);\n-\n-    /// Creates a pass manager.\n-    pub fn LLVMCreatePassManager() -> PassManagerRef;\n-\n-    /// Creates a function-by-function pass manager\n-    pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef)\n-                                                  -> PassManagerRef;\n-\n-    /// Disposes a pass manager.\n-    pub fn LLVMDisposePassManager(PM: PassManagerRef);\n-\n-    /// Runs a pass manager on a module.\n-    pub fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n-\n-    /// Runs the function passes on the provided function.\n-    pub fn LLVMRunFunctionPassManager(FPM: PassManagerRef, F: ValueRef)\n-                                      -> Bool;\n-\n-    /// Initializes all the function passes scheduled in the manager\n-    pub fn LLVMInitializeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n-\n-    /// Finalizes all the function passes scheduled in the manager\n-    pub fn LLVMFinalizeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n-\n-    pub fn LLVMInitializePasses();\n-\n-    /// Adds a verification pass.\n-    pub fn LLVMAddVerifierPass(PM: PassManagerRef);\n-\n-    pub fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n-    pub fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n-    pub fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n-    pub fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n-    pub fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n-    pub fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n-    pub fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n-    pub fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n-    pub fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n-    pub fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n-    pub fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n-    pub fn LLVMAddReassociatePass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n-    pub fn LLVMAddLICMPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n-    pub fn LLVMAddGVNPass(PM: PassManagerRef);\n-    pub fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n-    pub fn LLVMAddSCCPPass(PM: PassManagerRef);\n-    pub fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n-    pub fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n-    pub fn LLVMAddConstantMergePass(PM: PassManagerRef);\n-    pub fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n-    pub fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n-    pub fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n-    pub fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n-    pub fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n-    pub fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n-    pub fn LLVMAddPruneEHPass(PM: PassManagerRef);\n-    pub fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n-    pub fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n-    pub fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n-    pub fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n-\n-    pub fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n-    pub fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n-    pub fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n-                                             OptimizationLevel: c_uint);\n-    pub fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n-                                              Value: Bool);\n-    pub fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n-        PMB: PassManagerBuilderRef,\n-        Value: Bool);\n-    pub fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n-        PMB: PassManagerBuilderRef,\n-        Value: Bool);\n-    pub fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(\n-        PMB: PassManagerBuilderRef,\n-        Value: Bool);\n-    pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n-        PMB: PassManagerBuilderRef,\n-        threshold: c_uint);\n-    pub fn LLVMPassManagerBuilderPopulateModulePassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef);\n-\n-    pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef);\n-    pub fn LLVMPassManagerBuilderPopulateLTOPassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef,\n-        Internalize: Bool,\n-        RunInliner: Bool);\n-\n-    /// Destroys a memory buffer.\n-    pub fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n-\n-\n-    /* Stuff that's in rustllvm/ because it's not upstream yet. */\n-\n-    /// Opens an object file.\n-    pub fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n-    /// Closes an object file.\n-    pub fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n-\n-    /// Enumerates the sections in an object file.\n-    pub fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n-    /// Destroys a section iterator.\n-    pub fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n-    /// Returns true if the section iterator is at the end of the section\n-    /// list:\n-    pub fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n-                                      SI: SectionIteratorRef)\n-                                      -> Bool;\n-    /// Moves the section iterator to point to the next section.\n-    pub fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n-    /// Returns the current section size.\n-    pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n-    /// Returns the current section contents as a string buffer.\n-    pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n-\n-    /// Reads the given file and returns it as a memory buffer. Use\n-    /// LLVMDisposeMemoryBuffer() to get rid of it.\n-    pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char)\n-                                                        -> MemoryBufferRef;\n-    /// Borrows the contents of the memory buffer (doesn't copy it)\n-    pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *const c_char,\n-                                                 InputDataLength: size_t,\n-                                                 BufferName: *const c_char,\n-                                                 RequiresNull: Bool)\n-                                                 -> MemoryBufferRef;\n-    pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *const c_char,\n-                                                     InputDataLength: size_t,\n-                                                     BufferName: *const c_char)\n-                                                     -> MemoryBufferRef;\n-\n-    pub fn LLVMIsMultithreaded() -> Bool;\n-    pub fn LLVMStartMultithreaded() -> Bool;\n-\n-    /// Returns a string describing the last error caused by an LLVMRust* call.\n-    pub fn LLVMRustGetLastError() -> *const c_char;\n-\n-    /// Print the pass timings since static dtors aren't picking them up.\n-    pub fn LLVMRustPrintPassTimings();\n-\n-    pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n-\n-    pub fn LLVMStructSetBody(StructTy: TypeRef,\n-                             ElementTypes: *const TypeRef,\n-                             ElementCount: c_uint,\n-                             Packed: Bool);\n-\n-    pub fn LLVMConstNamedStruct(S: TypeRef,\n-                                ConstantVals: *const ValueRef,\n-                                Count: c_uint)\n-                                -> ValueRef;\n-\n-    /// Enables LLVM debug output.\n-    pub fn LLVMSetDebug(Enabled: c_int);\n-\n-    /// Prepares inline assembly.\n-    pub fn LLVMInlineAsm(Ty: TypeRef,\n-                         AsmString: *const c_char,\n-                         Constraints: *const c_char,\n-                         SideEffects: Bool,\n-                         AlignStack: Bool,\n-                         Dialect: c_uint)\n-                         -> ValueRef;\n-\n-    pub fn LLVMRustDebugMetadataVersion() -> u32;\n-    pub fn LLVMVersionMajor() -> u32;\n-    pub fn LLVMVersionMinor() -> u32;\n-\n-    pub fn LLVMRustAddModuleFlag(M: ModuleRef,\n-                                 name: *const c_char,\n-                                 value: u32);\n-\n-    pub fn LLVMDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n-\n-    pub fn LLVMDIBuilderDispose(Builder: DIBuilderRef);\n-\n-    pub fn LLVMDIBuilderFinalize(Builder: DIBuilderRef);\n-\n-    pub fn LLVMDIBuilderCreateCompileUnit(Builder: DIBuilderRef,\n-                                          Lang: c_uint,\n-                                          File: *const c_char,\n-                                          Dir: *const c_char,\n-                                          Producer: *const c_char,\n-                                          isOptimized: bool,\n-                                          Flags: *const c_char,\n-                                          RuntimeVer: c_uint,\n-                                          SplitName: *const c_char)\n-                                          -> DIDescriptor;\n-\n-    pub fn LLVMDIBuilderCreateFile(Builder: DIBuilderRef,\n-                                   Filename: *const c_char,\n-                                   Directory: *const c_char)\n-                                   -> DIFile;\n-\n-    pub fn LLVMDIBuilderCreateSubroutineType(Builder: DIBuilderRef,\n-                                             File: DIFile,\n-                                             ParameterTypes: DIArray)\n-                                             -> DICompositeType;\n-\n-    pub fn LLVMDIBuilderCreateFunction(Builder: DIBuilderRef,\n-                                       Scope: DIDescriptor,\n-                                       Name: *const c_char,\n-                                       LinkageName: *const c_char,\n-                                       File: DIFile,\n-                                       LineNo: c_uint,\n-                                       Ty: DIType,\n-                                       isLocalToUnit: bool,\n-                                       isDefinition: bool,\n-                                       ScopeLine: c_uint,\n-                                       Flags: c_uint,\n-                                       isOptimized: bool,\n-                                       Fn: ValueRef,\n-                                       TParam: DIArray,\n-                                       Decl: DIDescriptor)\n-                                       -> DISubprogram;\n-\n-    pub fn LLVMDIBuilderCreateBasicType(Builder: DIBuilderRef,\n-                                        Name: *const c_char,\n-                                        SizeInBits: c_ulonglong,\n-                                        AlignInBits: c_ulonglong,\n-                                        Encoding: c_uint)\n-                                        -> DIBasicType;\n-\n-    pub fn LLVMDIBuilderCreatePointerType(Builder: DIBuilderRef,\n-                                          PointeeTy: DIType,\n-                                          SizeInBits: c_ulonglong,\n-                                          AlignInBits: c_ulonglong,\n-                                          Name: *const c_char)\n-                                          -> DIDerivedType;\n-\n-    pub fn LLVMDIBuilderCreateStructType(Builder: DIBuilderRef,\n-                                         Scope: DIDescriptor,\n-                                         Name: *const c_char,\n-                                         File: DIFile,\n-                                         LineNumber: c_uint,\n-                                         SizeInBits: c_ulonglong,\n-                                         AlignInBits: c_ulonglong,\n-                                         Flags: c_uint,\n-                                         DerivedFrom: DIType,\n-                                         Elements: DIArray,\n-                                         RunTimeLang: c_uint,\n-                                         VTableHolder: DIType,\n-                                         UniqueId: *const c_char)\n-                                         -> DICompositeType;\n-\n-    pub fn LLVMDIBuilderCreateMemberType(Builder: DIBuilderRef,\n-                                         Scope: DIDescriptor,\n-                                         Name: *const c_char,\n-                                         File: DIFile,\n-                                         LineNo: c_uint,\n-                                         SizeInBits: c_ulonglong,\n-                                         AlignInBits: c_ulonglong,\n-                                         OffsetInBits: c_ulonglong,\n-                                         Flags: c_uint,\n-                                         Ty: DIType)\n-                                         -> DIDerivedType;\n-\n-    pub fn LLVMDIBuilderCreateLexicalBlock(Builder: DIBuilderRef,\n-                                           Scope: DIScope,\n-                                           File: DIFile,\n-                                           Line: c_uint,\n-                                           Col: c_uint)\n-                                           -> DILexicalBlock;\n-\n-    pub fn LLVMDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n-                                             Context: DIScope,\n-                                             Name: *const c_char,\n-                                             LinkageName: *const c_char,\n-                                             File: DIFile,\n-                                             LineNo: c_uint,\n-                                             Ty: DIType,\n-                                             isLocalToUnit: bool,\n-                                             Val: ValueRef,\n-                                             Decl: DIDescriptor)\n-                                             -> DIGlobalVariable;\n-\n-    pub fn LLVMDIBuilderCreateVariable(Builder: DIBuilderRef,\n-                                            Tag: c_uint,\n-                                            Scope: DIDescriptor,\n-                                            Name: *const c_char,\n-                                            File: DIFile,\n-                                            LineNo: c_uint,\n-                                            Ty: DIType,\n-                                            AlwaysPreserve: bool,\n-                                            Flags: c_uint,\n-                                            AddrOps: *const i64,\n-                                            AddrOpsCount: c_uint,\n-                                            ArgNo: c_uint)\n-                                            -> DIVariable;\n-\n-    pub fn LLVMDIBuilderCreateArrayType(Builder: DIBuilderRef,\n-                                        Size: c_ulonglong,\n-                                        AlignInBits: c_ulonglong,\n-                                        Ty: DIType,\n-                                        Subscripts: DIArray)\n-                                        -> DIType;\n-\n-    pub fn LLVMDIBuilderCreateVectorType(Builder: DIBuilderRef,\n-                                         Size: c_ulonglong,\n-                                         AlignInBits: c_ulonglong,\n-                                         Ty: DIType,\n-                                         Subscripts: DIArray)\n-                                         -> DIType;\n-\n-    pub fn LLVMDIBuilderGetOrCreateSubrange(Builder: DIBuilderRef,\n-                                            Lo: c_longlong,\n-                                            Count: c_longlong)\n-                                            -> DISubrange;\n-\n-    pub fn LLVMDIBuilderGetOrCreateArray(Builder: DIBuilderRef,\n-                                         Ptr: *const DIDescriptor,\n-                                         Count: c_uint)\n-                                         -> DIArray;\n-\n-    pub fn LLVMDIBuilderInsertDeclareAtEnd(Builder: DIBuilderRef,\n-                                           Val: ValueRef,\n-                                           VarInfo: DIVariable,\n-                                           AddrOps: *const i64,\n-                                           AddrOpsCount: c_uint,\n-                                           DL: ValueRef,\n-                                           InsertAtEnd: BasicBlockRef)\n-                                           -> ValueRef;\n-\n-    pub fn LLVMDIBuilderInsertDeclareBefore(Builder: DIBuilderRef,\n-                                            Val: ValueRef,\n-                                            VarInfo: DIVariable,\n-                                            AddrOps: *const i64,\n-                                            AddrOpsCount: c_uint,\n-                                            DL: ValueRef,\n-                                            InsertBefore: ValueRef)\n-                                            -> ValueRef;\n-\n-    pub fn LLVMDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n-                                         Name: *const c_char,\n-                                         Val: c_ulonglong)\n-                                         -> DIEnumerator;\n-\n-    pub fn LLVMDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n-                                              Scope: DIScope,\n-                                              Name: *const c_char,\n-                                              File: DIFile,\n-                                              LineNumber: c_uint,\n-                                              SizeInBits: c_ulonglong,\n-                                              AlignInBits: c_ulonglong,\n-                                              Elements: DIArray,\n-                                              ClassType: DIType)\n-                                              -> DIType;\n-\n-    pub fn LLVMDIBuilderCreateUnionType(Builder: DIBuilderRef,\n-                                        Scope: DIScope,\n-                                        Name: *const c_char,\n-                                        File: DIFile,\n-                                        LineNumber: c_uint,\n-                                        SizeInBits: c_ulonglong,\n-                                        AlignInBits: c_ulonglong,\n-                                        Flags: c_uint,\n-                                        Elements: DIArray,\n-                                        RunTimeLang: c_uint,\n-                                        UniqueId: *const c_char)\n-                                        -> DIType;\n-\n-    pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n-\n-    pub fn LLVMDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n-                                                    Scope: DIScope,\n-                                                    Name: *const c_char,\n-                                                    Ty: DIType,\n-                                                    File: DIFile,\n-                                                    LineNo: c_uint,\n-                                                    ColumnNo: c_uint)\n-                                                    -> DITemplateTypeParameter;\n-\n-    pub fn LLVMDIBuilderCreateOpDeref() -> i64;\n-\n-    pub fn LLVMDIBuilderCreateOpPlus() -> i64;\n-\n-    pub fn LLVMDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n-                                        Scope: DIScope,\n-                                        Name: *const c_char,\n-                                        File: DIFile,\n-                                        LineNo: c_uint)\n-                                        -> DINameSpace;\n-\n-    pub fn LLVMDIBuilderCreateDebugLocation(Context: ContextRef,\n-                                            Line: c_uint,\n-                                            Column: c_uint,\n-                                            Scope: DIScope,\n-                                            InlinedAt: MetadataRef)\n-                                            -> ValueRef;\n-\n-    pub fn LLVMDICompositeTypeSetTypeArray(Builder: DIBuilderRef,\n-                                           CompositeType: DIType,\n-                                           TypeArray: DIArray);\n-    pub fn LLVMWriteTypeToString(Type: TypeRef, s: RustStringRef);\n-    pub fn LLVMWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n-\n-    pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n-\n-    pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n-    pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n-\n-    pub fn LLVMRustPassKind(Pass: PassRef) -> SupportedPassKind;\n-    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;\n-    pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: PassRef);\n-\n-    pub fn LLVMRustHasFeature(T: TargetMachineRef,\n-                              s: *const c_char) -> bool;\n-\n-    pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n-                                       CPU: *const c_char,\n-                                       Features: *const c_char,\n-                                       Model: CodeGenModel,\n-                                       Reloc: RelocMode,\n-                                       Level: CodeGenOptLevel,\n-                                       UseSoftFP: bool,\n-                                       PositionIndependentExecutable: bool,\n-                                       FunctionSections: bool,\n-                                       DataSections: bool) -> TargetMachineRef;\n-    pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n-    pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef,\n-                                     PM: PassManagerRef,\n-                                     M: ModuleRef);\n-    pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n-                                         M: ModuleRef,\n-                                         DisableSimplifyLibCalls: bool);\n-    pub fn LLVMRustConfigurePassManagerBuilder(PMB: PassManagerBuilderRef,\n-                                               OptLevel: CodeGenOptLevel,\n-                                               MergeFunctions: bool,\n-                                               SLPVectorize: bool,\n-                                               LoopVectorize: bool);\n-    pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef,\n-                                  DisableSimplifyLibCalls: bool);\n-    pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n-    pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n-                                   PM: PassManagerRef,\n-                                   M: ModuleRef,\n-                                   Output: *const c_char,\n-                                   FileType: FileType) -> bool;\n-    pub fn LLVMRustPrintModule(PM: PassManagerRef,\n-                               M: ModuleRef,\n-                               Output: *const c_char);\n-    pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n-    pub fn LLVMRustPrintPasses();\n-    pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n-    pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n-                                       AddLifetimes: bool);\n-    pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n-                                         bc: *const c_char,\n-                                         len: size_t) -> bool;\n-    pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n-                                      syms: *const *const c_char,\n-                                      len: size_t);\n-    pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n-\n-    pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n-    pub fn LLVMRustArchiveIteratorNew(AR: ArchiveRef) -> ArchiveIteratorRef;\n-    pub fn LLVMRustArchiveIteratorNext(AIR: ArchiveIteratorRef) -> ArchiveChildRef;\n-    pub fn LLVMRustArchiveChildName(ACR: ArchiveChildRef,\n-                                    size: *mut size_t) -> *const c_char;\n-    pub fn LLVMRustArchiveChildData(ACR: ArchiveChildRef,\n-                                    size: *mut size_t) -> *const c_char;\n-    pub fn LLVMRustArchiveChildFree(ACR: ArchiveChildRef);\n-    pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n-    pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n-\n-    pub fn LLVMRustSetDLLStorageClass(V: ValueRef,\n-                                      C: DLLStorageClassTypes);\n-\n-    pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n-                                  data: *mut *const c_char) -> c_int;\n-\n-    pub fn LLVMWriteTwineToString(T: TwineRef, s: RustStringRef);\n-\n-    pub fn LLVMContextSetDiagnosticHandler(C: ContextRef,\n-                                           Handler: DiagnosticHandler,\n-                                           DiagnosticContext: *mut c_void);\n-\n-    pub fn LLVMUnpackOptimizationDiagnostic(DI: DiagnosticInfoRef,\n-                                            pass_name_out: *mut *const c_char,\n-                                            function_out: *mut ValueRef,\n-                                            debugloc_out: *mut DebugLocRef,\n-                                            message_out: *mut TwineRef);\n-    pub fn LLVMUnpackInlineAsmDiagnostic(DI: DiagnosticInfoRef,\n-                                            cookie_out: *mut c_uint,\n-                                            message_out: *mut TwineRef,\n-                                            instruction_out: *mut ValueRef);\n-\n-    pub fn LLVMWriteDiagnosticInfoToString(DI: DiagnosticInfoRef, s: RustStringRef);\n-    pub fn LLVMGetDiagInfoSeverity(DI: DiagnosticInfoRef) -> DiagnosticSeverity;\n-    pub fn LLVMGetDiagInfoKind(DI: DiagnosticInfoRef) -> DiagnosticKind;\n-\n-    pub fn LLVMWriteDebugLocToString(C: ContextRef, DL: DebugLocRef, s: RustStringRef);\n-\n-    pub fn LLVMSetInlineAsmDiagnosticHandler(C: ContextRef,\n-                                             H: InlineAsmDiagHandler,\n-                                             CX: *mut c_void);\n-\n-    pub fn LLVMWriteSMDiagnosticToString(d: SMDiagnosticRef, s: RustStringRef);\n-\n-    pub fn LLVMRustWriteArchive(Dst: *const c_char,\n-                                NumMembers: size_t,\n-                                Members: *const RustArchiveMemberRef,\n-                                WriteSymbtab: bool,\n-                                Kind: ArchiveKind) -> c_int;\n-    pub fn LLVMRustArchiveMemberNew(Filename: *const c_char,\n-                                    Name: *const c_char,\n-                                    Child: ArchiveChildRef) -> RustArchiveMemberRef;\n-    pub fn LLVMRustArchiveMemberFree(Member: RustArchiveMemberRef);\n-\n-    pub fn LLVMRustSetDataLayoutFromTargetMachine(M: ModuleRef,\n-                                                  TM: TargetMachineRef);\n-    pub fn LLVMRustGetModuleDataLayout(M: ModuleRef) -> TargetDataRef;\n-\n-    pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n-                                         Inputs: *const ValueRef,\n-                                         NumInputs: c_uint)\n-                                         -> OperandBundleDefRef;\n-    pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n+pub enum RustString_opaque {}\n+pub type RustStringRef = *mut RustString_opaque;\n+type RustStringRepr = *mut RefCell<Vec<u8>>;\n \n-    pub fn LLVMRustPositionBuilderAtStart(B: BuilderRef, BB: BasicBlockRef);\n+/// Appending to a Rust string -- used by raw_rust_string_ostream.\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rust_llvm_string_write_impl(sr: RustStringRef,\n+                                                     ptr: *const c_char,\n+                                                     size: size_t) {\n+    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n \n-    pub fn LLVMRustSetComdat(M: ModuleRef, V: ValueRef, Name: *const c_char);\n-    pub fn LLVMRustUnsetComdat(V: ValueRef);\n-    pub fn LLVMRustSetModulePIELevel(M: ModuleRef);\n+    let sr = sr as RustStringRepr;\n+    (*sr).borrow_mut().extend_from_slice(slice);\n }\n \n-// LLVM requires symbols from this library, but apparently they're not printed\n-// during llvm-config?\n-#[cfg(windows)]\n-#[link(name = \"ole32\")]\n-extern {}\n-\n pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n     unsafe {\n         LLVMSetInstructionCallConv(instr, cc as c_uint);\n@@ -2171,11 +200,6 @@ pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n         LLVMSetFunctionCallConv(fn_, cc as c_uint);\n     }\n }\n-pub fn SetLinkage(global: ValueRef, link: Linkage) {\n-    unsafe {\n-        LLVMSetLinkage(global, link as c_uint);\n-    }\n-}\n \n // Externally visible symbols that might appear in multiple translation units need to appear in\n // their own comdat section so that the duplicates can be discarded at link time. This can for\n@@ -2195,12 +219,6 @@ pub fn UnsetComdat(val: ValueRef) {\n     }\n }\n \n-pub fn SetDLLStorageClass(global: ValueRef, class: DLLStorageClassTypes) {\n-    unsafe {\n-        LLVMRustSetDLLStorageClass(global, class);\n-    }\n-}\n-\n pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n     unsafe {\n         LLVMSetUnnamedAddr(global, unnamed as Bool);\n@@ -2213,29 +231,40 @@ pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n     }\n }\n \n-pub fn ConstICmp(pred: IntPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n-    unsafe {\n-        LLVMConstICmp(pred as c_ushort, v1, v2)\n+impl Attribute {\n+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        unsafe {\n+            LLVMRustAddFunctionAttribute(\n+                llfn, idx.as_uint(), self.bits())\n+        }\n     }\n-}\n-pub fn ConstFCmp(pred: RealPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n-    unsafe {\n-        LLVMConstFCmp(pred as c_ushort, v1, v2)\n+\n+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+        unsafe {\n+            LLVMRustAddCallSiteAttribute(\n+                callsite, idx.as_uint(), self.bits())\n+        }\n     }\n-}\n \n-pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n-    unsafe {\n-        LLVMAddFunctionAttribute(fn_, FunctionIndex as c_uint,\n-                                 attr.bits() as uint64_t)\n+    pub fn unapply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        unsafe {\n+            LLVMRustRemoveFunctionAttributes(\n+                llfn, idx.as_uint(), self.bits())\n+        }\n     }\n-}\n \n-pub fn RemoveFunctionAttributes(fn_: ValueRef, attr: Attribute) {\n-    unsafe {\n-        LLVMRemoveFunctionAttributes(fn_, FunctionIndex as c_uint,\n-                                           attr.bits() as uint64_t)\n+    pub fn toggle_llfn(&self,\n+                       idx: AttributePlace,\n+                       llfn: ValueRef,\n+                       set: bool)\n+    {\n+        if set {\n+            self.apply_llfn(idx, llfn);\n+        } else {\n+            self.unapply_llfn(idx, llfn);\n+        }\n     }\n+\n }\n \n /* Memory-managed interface to target data. */\n@@ -2332,35 +361,19 @@ pub fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n     }\n }\n \n-#[allow(missing_copy_implementations)]\n-pub enum RustString_opaque {}\n-pub type RustStringRef = *mut RustString_opaque;\n-type RustStringRepr = *mut RefCell<Vec<u8>>;\n-\n-/// Appending to a Rust string -- used by raw_rust_string_ostream.\n-#[no_mangle]\n-pub unsafe extern \"C\" fn rust_llvm_string_write_impl(sr: RustStringRef,\n-                                                     ptr: *const c_char,\n-                                                     size: size_t) {\n-    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n-\n-    let sr = sr as RustStringRepr;\n-    (*sr).borrow_mut().extend_from_slice(slice);\n-}\n-\n pub fn build_string<F>(f: F) -> Option<String> where F: FnOnce(RustStringRef){\n     let mut buf = RefCell::new(Vec::new());\n     f(&mut buf as RustStringRepr as RustStringRef);\n     String::from_utf8(buf.into_inner()).ok()\n }\n \n pub unsafe fn twine_to_string(tr: TwineRef) -> String {\n-    build_string(|s| LLVMWriteTwineToString(tr, s))\n+    build_string(|s| LLVMRustWriteTwineToString(tr, s))\n         .expect(\"got a non-UTF8 Twine from LLVM\")\n }\n \n pub unsafe fn debug_loc_to_string(c: ContextRef, tr: DebugLocRef) -> String {\n-    build_string(|s| LLVMWriteDebugLocToString(c, tr, s))\n+    build_string(|s| LLVMRustWriteDebugLocToString(c, tr, s))\n         .expect(\"got a non-UTF8 DebugLoc from LLVM\")\n }\n "}, {"sha": "587c03af3abb6d6eaae9fbdd1c73a2650912049e", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -552,13 +552,13 @@ impl FnType {\n     pub fn apply_attrs_llfn(&self, llfn: ValueRef) {\n         let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n         if !self.ret.is_ignore() {\n-            self.ret.attrs.apply_llfn(i, llfn);\n+            self.ret.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n         }\n         i += 1;\n         for arg in &self.args {\n             if !arg.is_ignore() {\n                 if arg.pad.is_some() { i += 1; }\n-                arg.attrs.apply_llfn(i, llfn);\n+                arg.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n                 i += 1;\n             }\n         }\n@@ -567,13 +567,13 @@ impl FnType {\n     pub fn apply_attrs_callsite(&self, callsite: ValueRef) {\n         let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n         if !self.ret.is_ignore() {\n-            self.ret.attrs.apply_callsite(i, callsite);\n+            self.ret.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n         }\n         i += 1;\n         for arg in &self.args {\n             if !arg.is_ignore() {\n                 if arg.pad.is_some() { i += 1; }\n-                arg.attrs.apply_callsite(i, callsite);\n+                arg.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n                 i += 1;\n             }\n         }"}, {"sha": "5514fb0f4efc37b067b21439af683cf9d6a8f754", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -83,8 +83,8 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     let dialect = match ia.dialect {\n-        AsmDialect::Att   => llvm::AD_ATT,\n-        AsmDialect::Intel => llvm::AD_Intel\n+        AsmDialect::Att   => llvm::AsmDialect::Att,\n+        AsmDialect::Intel => llvm::AsmDialect::Intel,\n     };\n \n     let asm = CString::new(ia.asm.as_bytes()).unwrap();"}, {"sha": "62eac35e0abd9766d64b7b471c6cf2022e15e182", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 21, "deletions": 41, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n //! Set and unset common attributes on LLVM values.\n \n-use libc::c_uint;\n-use llvm::{self, ValueRef};\n+use llvm::{self, Attribute, ValueRef};\n+use llvm::AttributePlace::Function;\n pub use syntax::attr::InlineAttr;\n use syntax::ast;\n use context::CrateContext;\n@@ -20,71 +20,52 @@ use context::CrateContext;\n pub fn inline(val: ValueRef, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n-        Hint   => llvm::SetFunctionAttribute(val, llvm::Attribute::InlineHint),\n-        Always => llvm::SetFunctionAttribute(val, llvm::Attribute::AlwaysInline),\n-        Never  => llvm::SetFunctionAttribute(val, llvm::Attribute::NoInline),\n+        Hint   => Attribute::InlineHint.apply_llfn(Function, val),\n+        Always => Attribute::AlwaysInline.apply_llfn(Function, val),\n+        Never  => Attribute::NoInline.apply_llfn(Function, val),\n         None   => {\n-            let attr = llvm::Attribute::InlineHint |\n-                       llvm::Attribute::AlwaysInline |\n-                       llvm::Attribute::NoInline;\n-            llvm::RemoveFunctionAttributes(val, attr)\n+            let attr = Attribute::InlineHint |\n+                       Attribute::AlwaysInline |\n+                       Attribute::NoInline;\n+            attr.unapply_llfn(Function, val)\n         },\n     };\n }\n \n /// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n #[inline]\n pub fn emit_uwtable(val: ValueRef, emit: bool) {\n-    if emit {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::UWTable);\n-    } else {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::UWTable);\n-    }\n+    Attribute::UWTable.toggle_llfn(Function, val, emit);\n }\n \n /// Tell LLVM whether the function can or cannot unwind.\n #[inline]\n pub fn unwind(val: ValueRef, can_unwind: bool) {\n-    if can_unwind {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::NoUnwind);\n-    } else {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::NoUnwind);\n-    }\n+    Attribute::NoUnwind.toggle_llfn(Function, val, !can_unwind);\n }\n \n /// Tell LLVM whether it should optimise function for size.\n #[inline]\n #[allow(dead_code)] // possibly useful function\n pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n-    if optimize {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::OptimizeForSize);\n-    } else {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::OptimizeForSize);\n-    }\n+    Attribute::OptimizeForSize.toggle_llfn(Function, val, optimize);\n }\n \n /// Tell LLVM if this function should be 'naked', i.e. skip the epilogue and prologue.\n #[inline]\n pub fn naked(val: ValueRef, is_naked: bool) {\n-    if is_naked {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::Naked);\n-    } else {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::Naked);\n-    }\n+    Attribute::Naked.toggle_llfn(Function, val, is_naked);\n }\n \n pub fn set_frame_pointer_elimination(ccx: &CrateContext, llfn: ValueRef) {\n     // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a\n     // parameter.\n     if ccx.sess().must_not_eliminate_frame_pointers() {\n-        unsafe {\n-            let attr = \"no-frame-pointer-elim\\0\".as_ptr() as *const _;\n-            let val = \"true\\0\".as_ptr() as *const _;\n-            llvm::LLVMAddFunctionAttrStringValue(llfn,\n-                                                 llvm::FunctionIndex as c_uint,\n-                                                 attr,\n-                                                 val);\n-        }\n+        llvm::AddFunctionAttrStringValue(\n+            llfn,\n+            llvm::AttributePlace::Function,\n+            \"no-frame-pointer-elim\\0\",\n+            \"true\\0\")\n     }\n }\n \n@@ -98,13 +79,12 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n \n     for attr in attrs {\n         if attr.check_name(\"cold\") {\n-            llvm::Attributes::default().set(llvm::Attribute::Cold)\n-                .apply_llfn(llvm::FunctionIndex as usize, llfn)\n+            Attribute::Cold.apply_llfn(Function, llfn);\n         } else if attr.check_name(\"naked\") {\n             naked(llfn, true);\n         } else if attr.check_name(\"allocator\") {\n-            llvm::Attributes::default().set(llvm::Attribute::NoAlias)\n-                .apply_llfn(llvm::ReturnIndex as usize, llfn)\n+            Attribute::NoAlias.apply_llfn(\n+                llvm::AttributePlace::ReturnValue(), llfn);\n         } else if attr.check_name(\"unwind\") {\n             unwind(llfn, true);\n         }"}, {"sha": "e063209799f16b0ba4641cf4fdcb524b6473f431", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -293,7 +293,7 @@ impl<'a> ArchiveBuilder<'a> {\n                                                members.as_ptr(),\n                                                self.should_update_symbols,\n                                                kind);\n-            let ret = if r != 0 {\n+            let ret = if r.into_result().is_err() {\n                 let err = llvm::LLVMRustGetLastError();\n                 let msg = if err.is_null() {\n                     \"failed to write archive\".to_string()"}, {"sha": "8ce2fa762f9e2606103399f371c6db5afd9a2329", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -54,7 +54,7 @@ pub fn write_output_file(\n         let output_c = path2cstr(output);\n         let result = llvm::LLVMRustWriteOutputFile(\n                 target, pm, m, output_c.as_ptr(), file_type);\n-        if !result {\n+        if result.into_result().is_err() {\n             llvm_err(handler, format!(\"could not write output to {}\", output.display()));\n         }\n     }\n@@ -138,11 +138,11 @@ fn target_feature(sess: &Session) -> String {\n \n fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n     match optimize {\n-      config::OptLevel::No => llvm::CodeGenLevelNone,\n-      config::OptLevel::Less => llvm::CodeGenLevelLess,\n-      config::OptLevel::Default => llvm::CodeGenLevelDefault,\n-      config::OptLevel::Aggressive => llvm::CodeGenLevelAggressive,\n-      _ => llvm::CodeGenLevelDefault,\n+      config::OptLevel::No => llvm::CodeGenOptLevel::None,\n+      config::OptLevel::Less => llvm::CodeGenOptLevel::Less,\n+      config::OptLevel::Default => llvm::CodeGenOptLevel::Default,\n+      config::OptLevel::Aggressive => llvm::CodeGenOptLevel::Aggressive,\n+      _ => llvm::CodeGenOptLevel::Default,\n     }\n }\n \n@@ -169,11 +169,11 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     };\n \n     let code_model = match code_model_arg {\n-        \"default\" => llvm::CodeModelDefault,\n-        \"small\" => llvm::CodeModelSmall,\n-        \"kernel\" => llvm::CodeModelKernel,\n-        \"medium\" => llvm::CodeModelMedium,\n-        \"large\" => llvm::CodeModelLarge,\n+        \"default\" => llvm::CodeModel::Default,\n+        \"small\" => llvm::CodeModel::Small,\n+        \"kernel\" => llvm::CodeModel::Kernel,\n+        \"medium\" => llvm::CodeModel::Medium,\n+        \"large\" => llvm::CodeModel::Large,\n         _ => {\n             sess.err(&format!(\"{:?} is not a valid code model\",\n                              sess.opts\n@@ -365,7 +365,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n                                         cookie: c_uint) {\n     let HandlerFreeVars { cgcx, .. } = *(user as *const HandlerFreeVars);\n \n-    let msg = llvm::build_string(|s| llvm::LLVMWriteSMDiagnosticToString(diag, s))\n+    let msg = llvm::build_string(|s| llvm::LLVMRustWriteSMDiagnosticToString(diag, s))\n         .expect(\"non-UTF8 SMDiagnostic\");\n \n     report_inline_asm(cgcx, &msg[..], cookie);\n@@ -421,7 +421,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     };\n     let fv = &fv as *const HandlerFreeVars as *mut c_void;\n \n-    llvm::LLVMSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, fv);\n+    llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, fv);\n     llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, fv);\n \n     let module_name = Some(&mtrans.name[..]);\n@@ -449,9 +449,9 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 return false;\n             }\n             let pass_manager = match llvm::LLVMRustPassKind(pass) {\n-                llvm::SupportedPassKind::Function => fpm,\n-                llvm::SupportedPassKind::Module => mpm,\n-                llvm::SupportedPassKind::Unsupported => {\n+                llvm::PassKind::Function => fpm,\n+                llvm::PassKind::Module => mpm,\n+                llvm::PassKind::Other => {\n                     cgcx.handler.err(\"Encountered LLVM pass kind we can't handle\");\n                     return true\n                 },\n@@ -579,7 +579,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path,\n-                                  llvm::AssemblyFileType);\n+                                  llvm::FileType::AssemblyFile);\n             });\n             if config.emit_obj {\n                 llvm::LLVMDisposeModule(llmod);\n@@ -588,7 +588,8 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n         if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out, llvm::ObjectFileType);\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out,\n+                                  llvm::FileType::ObjectFile);\n             });\n         }\n     });\n@@ -1078,7 +1079,7 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n     // reasonable defaults and prepare it to actually populate the pass\n     // manager.\n     let builder = llvm::LLVMPassManagerBuilderCreate();\n-    let opt_level = config.opt_level.unwrap_or(llvm::CodeGenLevelNone);\n+    let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n     let opt_size = config.opt_size.unwrap_or(llvm::CodeGenOptSizeNone);\n     let inline_threshold = config.inline_threshold;\n \n@@ -1102,7 +1103,7 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n         (_, _, Some(t)) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, t as u32);\n         }\n-        (llvm::CodeGenLevelAggressive, _, _) => {\n+        (llvm::CodeGenOptLevel::Aggressive, _, _) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 275);\n         }\n         (_, llvm::CodeGenOptSizeDefault, _) => {\n@@ -1111,15 +1112,18 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n         (_, llvm::CodeGenOptSizeAggressive, _) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 25);\n         }\n-        (llvm::CodeGenLevelNone, _, _) => {\n+        (llvm::CodeGenOptLevel::None, _, _) => {\n             llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n         }\n-        (llvm::CodeGenLevelLess, _, _) => {\n+        (llvm::CodeGenOptLevel::Less, _, _) => {\n             llvm::LLVMRustAddAlwaysInlinePass(builder, true);\n         }\n-        (llvm::CodeGenLevelDefault, _, _) => {\n+        (llvm::CodeGenOptLevel::Default, _, _) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n         }\n+        (llvm::CodeGenOptLevel::Other, _, _) => {\n+            bug!(\"CodeGenOptLevel::Other selected\")\n+        }\n     }\n \n     f(builder);"}, {"sha": "1077cb296c1ac307e2e5a07535ed1eaf11166825", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -2347,8 +2347,9 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                     let has_fixed_linkage = linkage_fixed_explicitly.contains(&name_cow);\n \n                     if !is_referenced_somewhere && !is_reachable && !has_fixed_linkage {\n-                        llvm::SetLinkage(val, llvm::InternalLinkage);\n-                        llvm::SetDLLStorageClass(val, llvm::DefaultStorageClass);\n+                        llvm::LLVMSetLinkage(val, llvm::InternalLinkage);\n+                        llvm::LLVMSetDLLStorageClass(val,\n+                                                     llvm::DLLStorageClass::Default);\n                         llvm::UnsetComdat(val);\n                     }\n                 }\n@@ -2393,7 +2394,7 @@ fn create_imps(cx: &CrateContextList) {\n                                               imp_name.as_ptr() as *const _);\n                 let init = llvm::LLVMConstBitCast(val, i8p_ty.to_ref());\n                 llvm::LLVMSetInitializer(imp, init);\n-                llvm::SetLinkage(imp, llvm::ExternalLinkage);\n+                llvm::LLVMSetLinkage(imp, llvm::ExternalLinkage);\n             }\n         }\n     }"}, {"sha": "8cd47bd148d0cf597e5241a65bc6b0b511a7635f", "filename": "src/librustc_trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuild.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -12,7 +12,7 @@\n #![allow(non_snake_case)]\n \n use llvm;\n-use llvm::{AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n+use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate};\n use llvm::{ValueRef, BasicBlockRef};\n use common::*;\n@@ -1117,7 +1117,7 @@ pub fn AtomicCmpXchg(cx: Block, dst: ValueRef,\n                      weak: llvm::Bool) -> ValueRef {\n     B(cx).atomic_cmpxchg(dst, cmp, src, order, failure_order, weak)\n }\n-pub fn AtomicRMW(cx: Block, op: AtomicBinOp,\n+pub fn AtomicRMW(cx: Block, op: AtomicRmwBinOp,\n                  dst: ValueRef, src: ValueRef,\n                  order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_rmw(op, dst, src, order)"}, {"sha": "90f96af5496915527d9a71c0271dc2b61b64056b", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)] // FFI wrappers\n \n use llvm;\n-use llvm::{AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n+use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use base;\n@@ -503,8 +503,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n             let align = llalign_of_pref(self.ccx, ty.element_type());\n-            llvm::LLVMBuildAtomicLoad(self.llbuilder, ptr, noname(), order,\n-                                      align as c_uint)\n+            llvm::LLVMRustBuildAtomicLoad(self.llbuilder, ptr, noname(), order,\n+                                          align as c_uint)\n         }\n     }\n \n@@ -565,7 +565,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n             let align = llalign_of_pref(self.ccx, ty.element_type());\n-            llvm::LLVMBuildAtomicStore(self.llbuilder, val, ptr, order, align as c_uint);\n+            llvm::LLVMRustBuildAtomicStore(self.llbuilder, val, ptr, order, align as c_uint);\n         }\n     }\n \n@@ -840,8 +840,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"Asm Output Type: {:?}\", output);\n         let fty = Type::func(&argtys[..], &output);\n         unsafe {\n-            let v = llvm::LLVMInlineAsm(\n-                fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n+            let v = llvm::LLVMRustInlineAsm(\n+                fty.to_ref(), asm, cons, volatile, alignstack, dia);\n             self.call(v, inputs, None)\n         }\n     }\n@@ -1087,7 +1087,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                          order, failure_order, weak)\n         }\n     }\n-    pub fn atomic_rmw(&self, op: AtomicBinOp,\n+    pub fn atomic_rmw(&self, op: AtomicRmwBinOp,\n                      dst: ValueRef, src: ValueRef,\n                      order: AtomicOrdering) -> ValueRef {\n         unsafe {\n@@ -1097,7 +1097,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     pub fn atomic_fence(&self, order: AtomicOrdering, scope: SynchronizationScope) {\n         unsafe {\n-            llvm::LLVMBuildAtomicFence(self.llbuilder, order, scope);\n+            llvm::LLVMRustBuildAtomicFence(self.llbuilder, order, scope);\n         }\n     }\n }"}, {"sha": "e53a5edfc668519f2f305e8f63687419c7ebb83a", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -249,11 +249,13 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     if  !ccx.instances().borrow().contains_key(&instance) {\n         let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n \n-        if ccx.sess().target.target.options.allows_weak_linkage {\n-            llvm::SetLinkage(llfn, llvm::WeakODRLinkage);\n-            llvm::SetUniqueComdat(ccx.llmod(), llfn);\n-        } else {\n-            llvm::SetLinkage(llfn, llvm::InternalLinkage);\n+        unsafe {\n+            if ccx.sess().target.target.options.allows_weak_linkage {\n+                llvm::LLVMSetLinkage(llfn, llvm::WeakODRLinkage);\n+                llvm::SetUniqueComdat(ccx.llmod(), llfn);\n+            } else {\n+                llvm::LLVMSetLinkage(llfn, llvm::InternalLinkage);\n+            }\n         }\n \n         // set an inline hint for all closures"}, {"sha": "a1783e9c0a3829960035925d7f39d6183b28f4cb", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -980,7 +980,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n-        llvm::SetLinkage(g, llvm::InternalLinkage);\n+        llvm::LLVMSetLinkage(g, llvm::InternalLinkage);\n \n         cx.const_cstr_cache().borrow_mut().insert(s, g);\n         g"}, {"sha": "7afb5257258ec38f5c5b26100e7ececad4bbff9f", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -10,7 +10,7 @@\n \n \n use llvm;\n-use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n+use llvm::{SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::const_qualif::ConstQualif;\n use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, lookup_const_by_id, ErrKind};\n@@ -125,7 +125,7 @@ pub fn addr_of_mut(ccx: &CrateContext,\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetAlignment(gv, align);\n-        SetLinkage(gv, InternalLinkage);\n+        llvm::LLVMSetLinkage(gv, InternalLinkage);\n         SetUnnamedAddr(gv, true);\n         gv\n     }\n@@ -637,10 +637,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 hir::BiEq | hir::BiNe | hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe => {\n                     if is_float {\n                         let cmp = base::bin_op_to_fcmp_predicate(b.node);\n-                        ConstFCmp(cmp, te1, te2)\n+                        llvm::LLVMConstFCmp(cmp, te1, te2)\n                     } else {\n                         let cmp = base::bin_op_to_icmp_predicate(b.node, signed);\n-                        ConstICmp(cmp, te1, te2)\n+                        llvm::LLVMConstICmp(cmp, te1, te2)\n                     }\n                 },\n             } } // unsafe { match b.node {\n@@ -1072,7 +1072,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                     unsafe {\n                         // Declare a symbol `foo` with the desired linkage.\n                         let g1 = declare::declare_global(ccx, &sym, llty2);\n-                        llvm::SetLinkage(g1, linkage);\n+                        llvm::LLVMSetLinkage(g1, linkage);\n \n                         // Declare an internal global `extern_with_linkage_foo` which\n                         // is initialized with the address of `foo`.  If `foo` is\n@@ -1086,7 +1086,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                             ccx.sess().span_fatal(span,\n                                 &format!(\"symbol `{}` is already defined\", &sym))\n                         });\n-                        llvm::SetLinkage(g2, llvm::InternalLinkage);\n+                        llvm::LLVMSetLinkage(g2, llvm::InternalLinkage);\n                         llvm::LLVMSetInitializer(g2, g1);\n                         g2\n                     }\n@@ -1126,7 +1126,9 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n             }\n         }\n         if ccx.use_dll_storage_attrs() {\n-            llvm::SetDLLStorageClass(g, llvm::DLLImportStorageClass);\n+            unsafe {\n+                llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+            }\n         }\n         g\n     };\n@@ -1182,7 +1184,7 @@ pub fn trans_static(ccx: &CrateContext,\n             let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(datum.val));\n             let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n             llvm::LLVMSetValueName(datum.val, empty_string.as_ptr());\n-            let new_g = llvm::LLVMGetOrInsertGlobal(\n+            let new_g = llvm::LLVMRustGetOrInsertGlobal(\n                 ccx.llmod(), name_string.as_ptr(), val_llty.to_ref());\n             // To avoid breaking any invariants, we leave around the old\n             // global for the moment; we'll replace all references to it"}, {"sha": "166ce990fddfa72303618ca5d0aea7cad9c20dee", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -325,10 +325,10 @@ pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n     };\n \n     match reloc_model_arg {\n-        \"pic\" => llvm::RelocPIC,\n-        \"static\" => llvm::RelocStatic,\n-        \"default\" => llvm::RelocDefault,\n-        \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n+        \"pic\" => llvm::RelocMode::PIC,\n+        \"static\" => llvm::RelocMode::Static,\n+        \"default\" => llvm::RelocMode::Default,\n+        \"dynamic-no-pic\" => llvm::RelocMode::DynamicNoPic,\n         _ => {\n             sess.err(&format!(\"{:?} is not a valid relocation mode\",\n                              sess.opts\n@@ -347,7 +347,7 @@ fn is_any_library(sess: &Session) -> bool {\n }\n \n pub fn is_pie_binary(sess: &Session) -> bool {\n-    !is_any_library(sess) && get_reloc_model(sess) == llvm::RelocPIC\n+    !is_any_library(sess) && get_reloc_model(sess) == llvm::RelocMode::PIC\n }\n \n unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {"}, {"sha": "fe6a48d4c559dac732df51158504bdb562f3f466", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -133,7 +133,7 @@ fn make_mir_scope(ccx: &CrateContext,\n     let loc = span_start(ccx, scope_data.span);\n     scopes[scope] = unsafe {\n     let file_metadata = file_metadata(ccx, &loc.file.name, &loc.file.abs_path);\n-        llvm::LLVMDIBuilderCreateLexicalBlock(\n+        llvm::LLVMRustDIBuilderCreateLexicalBlock(\n             DIB(ccx),\n             parent_scope,\n             file_metadata,\n@@ -156,7 +156,7 @@ fn with_new_scope<F>(cx: &CrateContext,\n     let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n     let scope_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateLexicalBlock(\n+        llvm::LLVMRustDIBuilderCreateLexicalBlock(\n             DIB(cx),\n             parent_scope,\n             file_metadata,\n@@ -272,7 +272,7 @@ fn walk_pattern(cx: &CrateContext,\n                 let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                 let scope_metadata = unsafe {\n-                    llvm::LLVMDIBuilderCreateLexicalBlock(\n+                    llvm::LLVMRustDIBuilderCreateLexicalBlock(\n                         DIB(cx),\n                         parent_scope,\n                         file_metadata,"}, {"sha": "0a8d490dcd2dd3e54601a69484f44d1eddf7aaea", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -77,7 +77,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n             llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n             llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n-            llvm::SetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n+            llvm::LLVMSetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n             // This should make sure that the whole section is not larger than\n             // the string it contains. Otherwise we get a warning from GDB.\n             llvm::LLVMSetAlignment(section_var, 1);"}, {"sha": "8011347d3eb12c76770dd9c447b03147653d5214", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -504,12 +504,12 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n \n     let subrange = unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound)\n+        llvm::LLVMRustDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound)\n     };\n \n     let subscripts = create_DIArray(DIB(cx), &[subrange]);\n     let metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateArrayType(\n+        llvm::LLVMRustDIBuilderCreateArrayType(\n             DIB(cx),\n             bytes_to_bits(array_size_in_bytes),\n             bytes_to_bits(element_type_align),\n@@ -612,7 +612,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     return MetadataCreationResult::new(\n         unsafe {\n-            llvm::LLVMDIBuilderCreateSubroutineType(\n+            llvm::LLVMRustDIBuilderCreateSubroutineType(\n                 DIB(cx),\n                 unknown_file_metadata(cx),\n                 create_DIArray(DIB(cx), &signature_metadata[..]))\n@@ -885,8 +885,8 @@ fn file_metadata_(cx: &CrateContext, key: &str, file_name: &str, work_dir: &str)\n     let file_name = CString::new(file_name).unwrap();\n     let work_dir = CString::new(work_dir).unwrap();\n     let file_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name.as_ptr(),\n-                                      work_dir.as_ptr())\n+        llvm::LLVMRustDIBuilderCreateFile(DIB(cx), file_name.as_ptr(),\n+                                          work_dir.as_ptr())\n     };\n \n     let mut created_files = debug_context(cx).created_files.borrow_mut();\n@@ -916,7 +916,7 @@ pub fn scope_metadata(fcx: &FunctionContext,\n \n pub fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n     unsafe {\n-        llvm::LLVMDIBuilderCreateBasicType(\n+        llvm::LLVMRustDIBuilderCreateBasicType(\n             DIB(cx),\n             \"!\\0\".as_ptr() as *const _,\n             bytes_to_bits(0),\n@@ -951,7 +951,7 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (size, align) = size_and_align_of(cx, llvm_type);\n     let name = CString::new(name).unwrap();\n     let ty_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateBasicType(\n+        llvm::LLVMRustDIBuilderCreateBasicType(\n             DIB(cx),\n             name.as_ptr(),\n             bytes_to_bits(size),\n@@ -971,7 +971,7 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n     let name = CString::new(name).unwrap();\n     let ptr_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreatePointerType(\n+        llvm::LLVMRustDIBuilderCreatePointerType(\n             DIB(cx),\n             pointee_type_metadata,\n             bytes_to_bits(pointer_size),\n@@ -1017,7 +1017,7 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n     let flags = \"\\0\";\n     let split_name = \"\\0\";\n     return unsafe {\n-        llvm::LLVMDIBuilderCreateCompileUnit(\n+        llvm::LLVMRustDIBuilderCreateCompileUnit(\n             debug_context.builder,\n             DW_LANG_RUST,\n             compile_unit_name,\n@@ -1596,7 +1596,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let token = v.name.as_str();\n             let name = CString::new(token.as_bytes()).unwrap();\n             unsafe {\n-                llvm::LLVMDIBuilderCreateEnumerator(\n+                llvm::LLVMRustDIBuilderCreateEnumerator(\n                     DIB(cx),\n                     name.as_ptr(),\n                     v.disr_val.to_u64_unchecked())\n@@ -1623,7 +1623,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n                 let name = CString::new(discriminant_name.as_bytes()).unwrap();\n                 let discriminant_type_metadata = unsafe {\n-                    llvm::LLVMDIBuilderCreateEnumerationType(\n+                    llvm::LLVMRustDIBuilderCreateEnumerationType(\n                         DIB(cx),\n                         containing_scope,\n                         name.as_ptr(),\n@@ -1667,7 +1667,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let enum_name = CString::new(enum_name).unwrap();\n     let unique_type_id_str = CString::new(unique_type_id_str.as_bytes()).unwrap();\n     let enum_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateUnionType(\n+        llvm::LLVMRustDIBuilderCreateUnionType(\n         DIB(cx),\n         containing_scope,\n         enum_name.as_ptr(),\n@@ -1769,7 +1769,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n             let member_name = member_description.name.as_bytes();\n             let member_name = CString::new(member_name).unwrap();\n             unsafe {\n-                llvm::LLVMDIBuilderCreateMemberType(\n+                llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n                     composite_type_metadata,\n                     member_name.as_ptr(),\n@@ -1786,13 +1786,14 @@ fn set_members_of_composite_type(cx: &CrateContext,\n \n     unsafe {\n         let type_array = create_DIArray(DIB(cx), &member_metadata[..]);\n-        llvm::LLVMDICompositeTypeSetTypeArray(DIB(cx), composite_type_metadata, type_array);\n+        llvm::LLVMRustDICompositeTypeSetTypeArray(\n+            DIB(cx), composite_type_metadata, type_array);\n     }\n }\n \n-// A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any\n-// caching, does not add any fields to the struct. This can be done later with\n-// set_members_of_composite_type().\n+// A convenience wrapper around LLVMRustDIBuilderCreateStructType(). Does not do\n+// any caching, does not add any fields to the struct. This can be done later\n+// with set_members_of_composite_type().\n fn create_struct_stub(cx: &CrateContext,\n                       struct_llvm_type: Type,\n                       struct_type_name: &str,\n@@ -1807,12 +1808,12 @@ fn create_struct_stub(cx: &CrateContext,\n     let name = CString::new(struct_type_name).unwrap();\n     let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n     let metadata_stub = unsafe {\n-        // LLVMDIBuilderCreateStructType() wants an empty array. A null\n+        // LLVMRustDIBuilderCreateStructType() wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n         // later on in llvm/lib/IR/Value.cpp.\n         let empty_array = create_DIArray(DIB(cx), &[]);\n \n-        llvm::LLVMDIBuilderCreateStructType(\n+        llvm::LLVMRustDIBuilderCreateStructType(\n             DIB(cx),\n             containing_scope,\n             name.as_ptr(),\n@@ -1868,16 +1869,16 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let var_name = CString::new(var_name).unwrap();\n     let linkage_name = CString::new(linkage_name).unwrap();\n     unsafe {\n-        llvm::LLVMDIBuilderCreateStaticVariable(DIB(cx),\n-                                                var_scope,\n-                                                var_name.as_ptr(),\n-                                                linkage_name.as_ptr(),\n-                                                file_metadata,\n-                                                line_number,\n-                                                type_metadata,\n-                                                is_local_to_unit,\n-                                                global,\n-                                                ptr::null_mut());\n+        llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),\n+                                                    var_scope,\n+                                                    var_name.as_ptr(),\n+                                                    linkage_name.as_ptr(),\n+                                                    file_metadata,\n+                                                    line_number,\n+                                                    type_metadata,\n+                                                    is_local_to_unit,\n+                                                    global,\n+                                                    ptr::null_mut());\n     }\n }\n \n@@ -1980,10 +1981,10 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                               env_index);\n \n     let address_operations = unsafe {\n-        [llvm::LLVMDIBuilderCreateOpDeref(),\n-         llvm::LLVMDIBuilderCreateOpPlus(),\n+        [llvm::LLVMRustDIBuilderCreateOpDeref(),\n+         llvm::LLVMRustDIBuilderCreateOpPlus(),\n          byte_offset_of_var_in_env as i64,\n-         llvm::LLVMDIBuilderCreateOpDeref()]\n+         llvm::LLVMRustDIBuilderCreateOpDeref()]\n     };\n \n     let address_op_count = if captured_by_ref {\n@@ -2021,7 +2022,7 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let scope_metadata = scope_metadata(bcx.fcx, binding.id, binding.span);\n     let aops = unsafe {\n-        [llvm::LLVMDIBuilderCreateOpDeref()]\n+        [llvm::LLVMRustDIBuilderCreateOpDeref()]\n     };\n     // Regardless of the actual type (`T`) we're always passed the stack slot\n     // (alloca) for the binding. For ByRef bindings that's a `T*` but for ByMove"}, {"sha": "464c32c3cc725b78992f1bc7ca1844fd6808b01c", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -89,7 +89,7 @@ pub struct CrateDebugContext<'tcx> {\n impl<'tcx> CrateDebugContext<'tcx> {\n     pub fn new(llmod: ModuleRef) -> CrateDebugContext<'tcx> {\n         debug!(\"CrateDebugContext::new\");\n-        let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n+        let builder = unsafe { llvm::LLVMRustDIBuilderCreate(llmod) };\n         // DIBuilder inherits context from the module, so we'd better use the same one\n         let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n         return CrateDebugContext {\n@@ -179,8 +179,8 @@ pub fn finalize(cx: &CrateContext) {\n     }\n \n     unsafe {\n-        llvm::LLVMDIBuilderFinalize(DIB(cx));\n-        llvm::LLVMDIBuilderDispose(DIB(cx));\n+        llvm::LLVMRustDIBuilderFinalize(DIB(cx));\n+        llvm::LLVMRustDIBuilderDispose(DIB(cx));\n         // Debuginfo generation in LLVM by default uses a higher\n         // version of dwarf than OS X currently understands. We can\n         // instruct LLVM to emit an older version of dwarf, however,\n@@ -252,7 +252,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx, sig, abi);\n-        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n+        llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n     // Find the enclosing function, in case this is a closure.\n@@ -286,7 +286,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let linkage_name = CString::new(linkage_name).unwrap();\n \n     let fn_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateFunction(\n+        llvm::LLVMRustDIBuilderCreateFunction(\n             DIB(cx),\n             containing_scope,\n             function_name.as_ptr(),\n@@ -390,7 +390,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n                 let name = CString::new(param.name.as_str().as_bytes()).unwrap();\n                 unsafe {\n-                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                    llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n                         ptr::null_mut(),\n                         name.as_ptr(),\n@@ -494,7 +494,7 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         (DirectVariable { alloca }, address_operations) |\n         (IndirectVariable {alloca, address_operations}, _) => {\n             let metadata = unsafe {\n-                llvm::LLVMDIBuilderCreateVariable(\n+                llvm::LLVMRustDIBuilderCreateVariable(\n                     DIB(cx),\n                     dwarf_tag,\n                     scope_metadata,\n@@ -512,7 +512,7 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));\n             unsafe {\n                 let debug_loc = llvm::LLVMGetCurrentDebugLocation(cx.raw_builder());\n-                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                let instr = llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n                     DIB(cx),\n                     alloca,\n                     metadata,"}, {"sha": "5953ec4aaedfa3cb492de9d8a61f9fa4cf05beac", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -78,7 +78,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n     };\n \n     let scope = unsafe {\n-        llvm::LLVMDIBuilderCreateNameSpace(\n+        llvm::LLVMRustDIBuilderCreateNameSpace(\n             DIB(ccx),\n             parent_scope,\n             namespace_name.as_ptr(),"}, {"sha": "d288b9dcef70bb379c2c89a6fecbd99da6d485f1", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -206,7 +206,7 @@ pub fn set_debug_location(cx: &CrateContext,\n             debug!(\"setting debug location to {} {}\", line, col);\n \n             unsafe {\n-                llvm::LLVMDIBuilderCreateDebugLocation(\n+                llvm::LLVMRustDIBuilderCreateDebugLocation(\n                     debug_context(cx).llcontext,\n                     line as c_uint,\n                     col as c_uint,"}, {"sha": "5734a12394113fe86a2c825652c0aa11540f1a9c", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -40,7 +40,7 @@ pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n #[allow(non_snake_case)]\n pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     return unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n+        llvm::LLVMRustDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n     };\n }\n "}, {"sha": "324e8697ecae695ab61e3a6e550cdf085fa85fd2", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -20,6 +20,7 @@\n //! * Use define_* family of methods when you might be defining the ValueRef.\n //! * When in doubt, define.\n use llvm::{self, ValueRef};\n+use llvm::AttributePlace::Function;\n use rustc::ty;\n use abi::{Abi, FnType};\n use attributes;\n@@ -40,7 +41,7 @@ pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRe\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     unsafe {\n-        llvm::LLVMGetOrInsertGlobal(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertGlobal(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n     }\n }\n \n@@ -55,7 +56,7 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     let llfn = unsafe {\n-        llvm::LLVMGetOrInsertFunction(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertFunction(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n     };\n \n     llvm::SetFunctionCallConv(llfn, callconv);\n@@ -65,16 +66,16 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n \n     if ccx.tcx().sess.opts.cg.no_redzone\n         .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n-        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoRedZone)\n+        llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n     }\n \n     match ccx.tcx().sess.opts.cg.opt_level.as_ref().map(String::as_ref) {\n         Some(\"s\") => {\n-            llvm::SetFunctionAttribute(llfn, llvm::Attribute::OptimizeForSize);\n+            llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);\n         },\n         Some(\"z\") => {\n-            llvm::SetFunctionAttribute(llfn, llvm::Attribute::MinSize);\n-            llvm::SetFunctionAttribute(llfn, llvm::Attribute::OptimizeForSize);\n+            llvm::Attribute::MinSize.apply_llfn(Function, llfn);\n+            llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);\n         },\n         _ => {},\n     }\n@@ -111,7 +112,7 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n     let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.llvm_type(ccx));\n \n     if sig.output == ty::FnDiverging {\n-        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n+        llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n     }\n \n     if abi != Abi::Rust && abi != Abi::RustCall {\n@@ -162,7 +163,7 @@ pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     name: &str,\n                                     fn_type: ty::Ty<'tcx>) -> ValueRef {\n     let llfn = define_fn(ccx, name, fn_type);\n-    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n+    unsafe { llvm::LLVMSetLinkage(llfn, llvm::InternalLinkage) };\n     llfn\n }\n \n@@ -173,7 +174,7 @@ pub fn get_declared_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n-    let val = unsafe { llvm::LLVMGetNamedValue(ccx.llmod(), namebuf.as_ptr()) };\n+    let val = unsafe { llvm::LLVMRustGetNamedValue(ccx.llmod(), namebuf.as_ptr()) };\n     if val.is_null() {\n         debug!(\"get_declared_value: {:?} value is null\", name);\n         None"}, {"sha": "2f27aed065d80f17b926d937a1d2ee473c2e1b4e", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -640,28 +640,30 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         // This requires that atomic intrinsics follow a specific naming pattern:\n         // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n         (_, name) if name.starts_with(\"atomic_\") => {\n+            use llvm::AtomicOrdering::*;\n+\n             let split: Vec<&str> = name.split('_').collect();\n \n             let is_cxchg = split[1] == \"cxchg\" || split[1] == \"cxchgweak\";\n             let (order, failorder) = match split.len() {\n-                2 => (llvm::SequentiallyConsistent, llvm::SequentiallyConsistent),\n+                2 => (SequentiallyConsistent, SequentiallyConsistent),\n                 3 => match split[2] {\n-                    \"unordered\" => (llvm::Unordered, llvm::Unordered),\n-                    \"relaxed\" => (llvm::Monotonic, llvm::Monotonic),\n-                    \"acq\"     => (llvm::Acquire, llvm::Acquire),\n-                    \"rel\"     => (llvm::Release, llvm::Monotonic),\n-                    \"acqrel\"  => (llvm::AcquireRelease, llvm::Acquire),\n+                    \"unordered\" => (Unordered, Unordered),\n+                    \"relaxed\" => (Monotonic, Monotonic),\n+                    \"acq\"     => (Acquire, Acquire),\n+                    \"rel\"     => (Release, Monotonic),\n+                    \"acqrel\"  => (AcquireRelease, Acquire),\n                     \"failrelaxed\" if is_cxchg =>\n-                        (llvm::SequentiallyConsistent, llvm::Monotonic),\n+                        (SequentiallyConsistent, Monotonic),\n                     \"failacq\" if is_cxchg =>\n-                        (llvm::SequentiallyConsistent, llvm::Acquire),\n+                        (SequentiallyConsistent, Acquire),\n                     _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n                 },\n                 4 => match (split[2], split[3]) {\n                     (\"acq\", \"failrelaxed\") if is_cxchg =>\n-                        (llvm::Acquire, llvm::Monotonic),\n+                        (Acquire, Monotonic),\n                     (\"acqrel\", \"failrelaxed\") if is_cxchg =>\n-                        (llvm::AcquireRelease, llvm::Monotonic),\n+                        (AcquireRelease, Monotonic),\n                     _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n                 },\n                 _ => ccx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n@@ -714,12 +716,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"fence\" => {\n-                    AtomicFence(bcx, order, llvm::CrossThread);\n+                    AtomicFence(bcx, order, llvm::SynchronizationScope::CrossThread);\n                     C_nil(ccx)\n                 }\n \n                 \"singlethreadfence\" => {\n-                    AtomicFence(bcx, order, llvm::SingleThread);\n+                    AtomicFence(bcx, order, llvm::SynchronizationScope::SingleThread);\n                     C_nil(ccx)\n                 }\n "}, {"sha": "00db19d2739c3953d95615af8801e6169acb13ae", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -824,11 +824,11 @@ pub fn const_scalar_binop(op: mir::BinOp,\n             mir::BinOp::Gt | mir::BinOp::Ge => {\n                 if is_float {\n                     let cmp = base::bin_op_to_fcmp_predicate(op.to_hir_binop());\n-                    llvm::ConstFCmp(cmp, lhs, rhs)\n+                    llvm::LLVMConstFCmp(cmp, lhs, rhs)\n                 } else {\n                     let cmp = base::bin_op_to_icmp_predicate(op.to_hir_binop(),\n                                                                 signed);\n-                    llvm::ConstICmp(cmp, lhs, rhs)\n+                    llvm::LLVMConstICmp(cmp, lhs, rhs)\n                 }\n             }\n         }"}, {"sha": "8f723d288c9eb4718cb4bb77580396bbf122b4ac", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -324,8 +324,8 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                         machine::llelement_offset(bcx.ccx(), lltuplety, i);\n \n                     let ops = unsafe {\n-                        [llvm::LLVMDIBuilderCreateOpDeref(),\n-                         llvm::LLVMDIBuilderCreateOpPlus(),\n+                        [llvm::LLVMRustDIBuilderCreateOpDeref(),\n+                         llvm::LLVMRustDIBuilderCreateOpPlus(),\n                          byte_offset_of_var_in_tuple as i64]\n                     };\n \n@@ -450,10 +450,10 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                     machine::llelement_offset(bcx.ccx(), llclosurety, i);\n \n                 let ops = unsafe {\n-                    [llvm::LLVMDIBuilderCreateOpDeref(),\n-                     llvm::LLVMDIBuilderCreateOpPlus(),\n+                    [llvm::LLVMRustDIBuilderCreateOpDeref(),\n+                     llvm::LLVMRustDIBuilderCreateOpPlus(),\n                      byte_offset_of_var_in_env as i64,\n-                     llvm::LLVMDIBuilderCreateOpDeref()]\n+                     llvm::LLVMRustDIBuilderCreateOpDeref()]\n                 };\n \n                 // The environment and the capture can each be indirect."}, {"sha": "e9aacaa0f954f2e4fc20daa8d50ba442bcabc0b8", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -125,7 +125,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             if ccx.shared().translation_items().borrow().contains(&trans_item) {\n                 attributes::from_fn_attrs(ccx, attrs, lldecl);\n-                llvm::SetLinkage(lldecl, llvm::ExternalLinkage);\n+                unsafe {\n+                    llvm::LLVMSetLinkage(lldecl, llvm::ExternalLinkage);\n+                }\n             } else {\n                 // FIXME: #34151\n                 // Normally, getting here would indicate a bug in trans::collector,"}, {"sha": "35bb0481c8e979e6f82248a111fa18254fb078eb", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                         &format!(\"symbol `{}` is already defined\", symbol_name))\n                 });\n \n-                llvm::SetLinkage(g, linkage);\n+                unsafe { llvm::LLVMSetLinkage(g, linkage) };\n             }\n \n             item => bug!(\"predefine_static: expected static, found {:?}\", item)\n@@ -250,7 +250,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                 ref attrs, node: hir::ImplItemKind::Method(..), ..\n             }) => {\n                 let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n-                llvm::SetLinkage(lldecl, linkage);\n+                unsafe { llvm::LLVMSetLinkage(lldecl, linkage) };\n                 base::set_link_section(ccx, lldecl, attrs);\n                 if linkage == llvm::LinkOnceODRLinkage ||\n                    linkage == llvm::WeakODRLinkage {\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         assert!(declare::get_defined_value(ccx, symbol_name).is_none());\n         let llfn = declare::declare_cfn(ccx, symbol_name, llfnty);\n-        llvm::SetLinkage(llfn, linkage);\n+        unsafe { llvm::LLVMSetLinkage(llfn, linkage) };\n         if linkage == llvm::LinkOnceODRLinkage ||\n            linkage == llvm::WeakODRLinkage {\n             llvm::SetUniqueComdat(ccx.llmod(), llfn);"}, {"sha": "d191591e082adedef8e9d7a0bfd00cd3cef875bd", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -36,7 +36,7 @@ pub struct Type {\n impl fmt::Debug for Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&llvm::build_string(|s| unsafe {\n-            llvm::LLVMWriteTypeToString(self.to_ref(), s);\n+            llvm::LLVMRustWriteTypeToString(self.to_ref(), s);\n         }).expect(\"non-UTF8 type description from LLVM\"))\n     }\n }\n@@ -72,7 +72,7 @@ impl Type {\n     }\n \n     pub fn metadata(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMMetadataTypeInContext(ccx.llcx()))\n+        ty!(llvm::LLVMRustMetadataTypeInContext(ccx.llcx()))\n     }\n \n     pub fn i1(ccx: &CrateContext) -> Type {\n@@ -208,7 +208,7 @@ impl Type {\n \n     pub fn kind(&self) -> TypeKind {\n         unsafe {\n-            llvm::LLVMGetTypeKind(self.to_ref())\n+            llvm::LLVMRustGetTypeKind(self.to_ref())\n         }\n     }\n "}, {"sha": "79e0c11515fc49f34fe6cb5ed716a2fd8d1378a6", "filename": "src/librustc_trans/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Flibrustc_trans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fvalue.rs?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -23,7 +23,7 @@ pub struct Value(pub ValueRef);\n impl fmt::Debug for Value {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&llvm::build_string(|s| unsafe {\n-            llvm::LLVMWriteValueToString(self.0, s);\n+            llvm::LLVMRustWriteValueToString(self.0, s);\n         }).expect(\"nun-UTF8 value description from LLVM\"))\n     }\n }"}, {"sha": "1e873b5345c43d22f09da97e95eb203062b22c51", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 65, "deletions": 33, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -16,24 +16,62 @@\n using namespace llvm;\n using namespace llvm::object;\n \n-struct LLVMRustArchiveMember {\n+struct RustArchiveMember {\n   const char *filename;\n   const char *name;\n   Archive::Child child;\n \n-  LLVMRustArchiveMember(): filename(NULL), name(NULL),\n+  RustArchiveMember(): filename(NULL), name(NULL),\n #if LLVM_VERSION_MINOR >= 8\n     child(NULL, NULL, NULL)\n #else\n     child(NULL, NULL)\n #endif\n   {}\n-  ~LLVMRustArchiveMember() {}\n+  ~RustArchiveMember() {}\n };\n \n-typedef OwningBinary<Archive> RustArchive;\n \n-extern \"C\" void*\n+struct RustArchiveIterator {\n+    Archive::child_iterator cur;\n+    Archive::child_iterator end;\n+#if LLVM_VERSION_MINOR >= 9\n+    Error err;\n+#endif\n+};\n+\n+enum class LLVMRustArchiveKind {\n+    Other,\n+    GNU,\n+    MIPS64,\n+    BSD,\n+    COFF,\n+};\n+\n+static Archive::Kind\n+from_rust(LLVMRustArchiveKind kind)\n+{\n+    switch (kind) {\n+    case LLVMRustArchiveKind::GNU:\n+        return Archive::K_GNU;\n+    case LLVMRustArchiveKind::MIPS64:\n+        return Archive::K_MIPS64;\n+    case LLVMRustArchiveKind::BSD:\n+        return Archive::K_BSD;\n+    case LLVMRustArchiveKind::COFF:\n+        return Archive::K_COFF;\n+    default:\n+      llvm_unreachable(\"Bad ArchiveKind.\");\n+  }\n+}\n+\n+typedef OwningBinary<Archive> *LLVMRustArchiveRef;\n+typedef RustArchiveMember *LLVMRustArchiveMemberRef;\n+typedef Archive::Child *LLVMRustArchiveChildRef;\n+typedef Archive::Child const *LLVMRustArchiveChildConstRef;\n+typedef RustArchiveIterator *LLVMRustArchiveIteratorRef;\n+\n+extern \"C\" LLVMRustArchiveRef\n LLVMRustOpenArchive(char *path) {\n     ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or = MemoryBuffer::getFile(path,\n                                                                           -1,\n@@ -66,20 +104,12 @@ LLVMRustOpenArchive(char *path) {\n }\n \n extern \"C\" void\n-LLVMRustDestroyArchive(RustArchive *ar) {\n+LLVMRustDestroyArchive(LLVMRustArchiveRef ar) {\n     delete ar;\n }\n \n-struct RustArchiveIterator {\n-    Archive::child_iterator cur;\n-    Archive::child_iterator end;\n-#if LLVM_VERSION_MINOR >= 9\n-    Error err;\n-#endif\n-};\n-\n-extern \"C\" RustArchiveIterator*\n-LLVMRustArchiveIteratorNew(RustArchive *ra) {\n+extern \"C\" LLVMRustArchiveIteratorRef\n+LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {\n     Archive *ar = ra->getBinary();\n     RustArchiveIterator *rai = new RustArchiveIterator();\n #if LLVM_VERSION_MINOR <= 8\n@@ -95,8 +125,8 @@ LLVMRustArchiveIteratorNew(RustArchive *ra) {\n     return rai;\n }\n \n-extern \"C\" const Archive::Child*\n-LLVMRustArchiveIteratorNext(RustArchiveIterator *rai) {\n+extern \"C\" LLVMRustArchiveChildConstRef\n+LLVMRustArchiveIteratorNext(LLVMRustArchiveIteratorRef rai) {\n #if LLVM_VERSION_MINOR >= 9\n     if (rai->err) {\n         LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n@@ -122,17 +152,17 @@ LLVMRustArchiveIteratorNext(RustArchiveIterator *rai) {\n }\n \n extern \"C\" void\n-LLVMRustArchiveChildFree(Archive::Child *child) {\n+LLVMRustArchiveChildFree(LLVMRustArchiveChildRef child) {\n     delete child;\n }\n \n extern \"C\" void\n-LLVMRustArchiveIteratorFree(RustArchiveIterator *rai) {\n+LLVMRustArchiveIteratorFree(LLVMRustArchiveIteratorRef rai) {\n     delete rai;\n }\n \n extern \"C\" const char*\n-LLVMRustArchiveChildName(const Archive::Child *child, size_t *size) {\n+LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef child, size_t *size) {\n     ErrorOr<StringRef> name_or_err = child->getName();\n     if (name_or_err.getError())\n         return NULL;\n@@ -142,7 +172,7 @@ LLVMRustArchiveChildName(const Archive::Child *child, size_t *size) {\n }\n \n extern \"C\" const char*\n-LLVMRustArchiveChildData(Archive::Child *child, size_t *size) {\n+LLVMRustArchiveChildData(LLVMRustArchiveChildRef child, size_t *size) {\n     StringRef buf;\n     ErrorOr<StringRef> buf_or_err = child->getBuffer();\n     if (buf_or_err.getError()) {\n@@ -154,9 +184,10 @@ LLVMRustArchiveChildData(Archive::Child *child, size_t *size) {\n     return buf.data();\n }\n \n-extern \"C\" LLVMRustArchiveMember*\n-LLVMRustArchiveMemberNew(char *Filename, char *Name, Archive::Child *child) {\n-    LLVMRustArchiveMember *Member = new LLVMRustArchiveMember;\n+extern \"C\" LLVMRustArchiveMemberRef\n+LLVMRustArchiveMemberNew(char *Filename, char *Name,\n+\t\t\t LLVMRustArchiveChildRef child) {\n+    RustArchiveMember *Member = new RustArchiveMember;\n     Member->filename = Filename;\n     Member->name = Name;\n     if (child)\n@@ -165,22 +196,23 @@ LLVMRustArchiveMemberNew(char *Filename, char *Name, Archive::Child *child) {\n }\n \n extern \"C\" void\n-LLVMRustArchiveMemberFree(LLVMRustArchiveMember *Member) {\n+LLVMRustArchiveMemberFree(LLVMRustArchiveMemberRef Member) {\n     delete Member;\n }\n \n-extern \"C\" int\n+extern \"C\" LLVMRustResult\n LLVMRustWriteArchive(char *Dst,\n                      size_t NumMembers,\n-                     const LLVMRustArchiveMember **NewMembers,\n+                     const LLVMRustArchiveMemberRef *NewMembers,\n                      bool WriteSymbtab,\n-                     Archive::Kind Kind) {\n+                     LLVMRustArchiveKind rust_kind) {\n \n #if LLVM_VERSION_MINOR <= 8\n   std::vector<NewArchiveIterator> Members;\n #else\n   std::vector<NewArchiveMember> Members;\n #endif\n+  auto Kind = from_rust(rust_kind);\n \n   for (size_t i = 0; i < NumMembers; i++) {\n     auto Member = NewMembers[i];\n@@ -190,7 +222,7 @@ LLVMRustWriteArchive(char *Dst,\n       Expected<NewArchiveMember> MOrErr = NewArchiveMember::getFile(Member->filename, true);\n       if (!MOrErr) {\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n-        return -1;\n+        return LLVMRustResult::Failure;\n       }\n       Members.push_back(std::move(*MOrErr));\n #elif LLVM_VERSION_MINOR == 8\n@@ -205,7 +237,7 @@ LLVMRustWriteArchive(char *Dst,\n       Expected<NewArchiveMember> MOrErr = NewArchiveMember::getOldMember(Member->child, true);\n       if (!MOrErr) {\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n-        return -1;\n+        return LLVMRustResult::Failure;\n       }\n       Members.push_back(std::move(*MOrErr));\n #endif\n@@ -217,7 +249,7 @@ LLVMRustWriteArchive(char *Dst,\n   auto pair = writeArchive(Dst, Members, WriteSymbtab, Kind, true);\n #endif\n   if (!pair.second)\n-    return 0;\n+    return LLVMRustResult::Success;\n   LLVMRustSetLastError(pair.second.message().c_str());\n-  return -1;\n+  return LLVMRustResult::Failure;\n }"}, {"sha": "b26ab44601998d9dd89d81d92eae1ac0b7d70760", "filename": "src/rustllvm/ExecutionEngineWrapper.cpp", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/9cf189701e0a8caacbf106e5bfebfa302570bb81/src%2Frustllvm%2FExecutionEngineWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9cf189701e0a8caacbf106e5bfebfa302570bb81/src%2Frustllvm%2FExecutionEngineWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FExecutionEngineWrapper.cpp?ref=9cf189701e0a8caacbf106e5bfebfa302570bb81", "patch": "@@ -1,111 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include \"rustllvm.h\"\n-\n-#include \"llvm/ExecutionEngine/SectionMemoryManager.h\"\n-\n-using namespace llvm;\n-using namespace llvm::sys;\n-using namespace llvm::object;\n-\n-class RustJITMemoryManager : public SectionMemoryManager\n-{\n-    typedef SectionMemoryManager Base;\n-\n-    public:\n-\n-    RustJITMemoryManager() {}\n-\n-    uint64_t getSymbolAddress(const std::string &Name) override\n-    {\n-        return Base::getSymbolAddress(Name);\n-    }\n-};\n-\n-DEFINE_SIMPLE_CONVERSION_FUNCTIONS(RustJITMemoryManager, LLVMRustJITMemoryManagerRef)\n-\n-extern \"C\" LLVMBool LLVMRustLoadDynamicLibrary(const char *path)\n-{\n-    std::string err;\n-    DynamicLibrary lib = DynamicLibrary::getPermanentLibrary(path, &err);\n-\n-    if (!lib.isValid())\n-        LLVMRustSetLastError(err.c_str());\n-\n-    return lib.isValid();\n-}\n-\n-// Calls LLVMAddModule;\n-// exists for consistency with LLVMExecutionEngineRemoveModule\n-extern \"C\" void LLVMExecutionEngineAddModule(\n-    LLVMExecutionEngineRef eeref, LLVMModuleRef mref)\n-{\n-#ifdef _WIN32\n-    // On Windows, MCJIT must generate ELF objects\n-    std::string target = getProcessTriple();\n-    target += \"-elf\";\n-    target = Triple::normalize(target);\n-    unwrap(mref)->setTargetTriple(target);\n-#endif\n-    LLVMAddModule(eeref, mref);\n-}\n-\n-// LLVMRemoveModule exists in LLVM's C bindings,\n-// but it requires pointless parameters\n-extern \"C\" LLVMBool LLVMExecutionEngineRemoveModule(\n-    LLVMExecutionEngineRef eeref, LLVMModuleRef mref)\n-{\n-    ExecutionEngine *ee = unwrap(eeref);\n-    Module *m = unwrap(mref);\n-\n-    return ee->removeModule(m);\n-}\n-\n-extern \"C\" LLVMExecutionEngineRef LLVMBuildExecutionEngine(LLVMModuleRef mod)\n-{\n-    // These are necessary for code generation to work properly.\n-    InitializeNativeTarget();\n-    InitializeNativeTargetAsmPrinter();\n-    InitializeNativeTargetAsmParser();\n-\n-#ifdef _WIN32\n-    // On Windows, MCJIT must generate ELF objects\n-    std::string target = getProcessTriple();\n-    target += \"-elf\";\n-    target = Triple::normalize(target);\n-    unwrap(mod)->setTargetTriple(target);\n-#endif\n-\n-    std::string error_str;\n-    TargetOptions options;\n-\n-    RustJITMemoryManager *mm = new RustJITMemoryManager;\n-\n-    ExecutionEngine *ee =\n-        EngineBuilder(std::unique_ptr<Module>(unwrap(mod)))\n-            .setMCJITMemoryManager(std::unique_ptr<RustJITMemoryManager>(mm))\n-            .setEngineKind(EngineKind::JIT)\n-            .setErrorStr(&error_str)\n-            .setTargetOptions(options)\n-            .create();\n-\n-    if (!ee)\n-        LLVMRustSetLastError(error_str.c_str());\n-\n-    return wrap(ee);\n-}\n-\n-extern \"C\" void LLVMExecutionEngineFinalizeObject(LLVMExecutionEngineRef eeref)\n-{\n-    ExecutionEngine *ee = unwrap(eeref);\n-\n-    ee->finalizeObject();\n-}"}, {"sha": "e3dcf45cf0fb585b9bf2f5a0c5d289227225f715", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 112, "deletions": 26, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -54,41 +54,48 @@ LLVMInitializePasses() {\n   initializeTarget(Registry);\n }\n \n-\n-enum class SupportedPassKind {\n+enum class LLVMRustPassKind {\n+  Other,\n   Function,\n   Module,\n-  Unsupported\n };\n \n-extern \"C\" Pass*\n+static LLVMRustPassKind\n+to_rust(PassKind kind)\n+{\n+  switch (kind) {\n+  case PT_Function:\n+      return LLVMRustPassKind::Function;\n+  case PT_Module:\n+      return LLVMRustPassKind::Module;\n+  default:\n+      return LLVMRustPassKind::Other;\n+  }\n+}\n+\n+extern \"C\" LLVMPassRef\n LLVMRustFindAndCreatePass(const char *PassName) {\n     StringRef SR(PassName);\n     PassRegistry *PR = PassRegistry::getPassRegistry();\n \n     const PassInfo *PI = PR->getPassInfo(SR);\n     if (PI) {\n-        return PI->createPass();\n+      return wrap(PI->createPass());\n     }\n     return NULL;\n }\n \n-extern \"C\" SupportedPassKind\n-LLVMRustPassKind(Pass *pass) {\n-    assert(pass);\n-    PassKind passKind = pass->getPassKind();\n-    if (passKind == PT_Module) {\n-        return SupportedPassKind::Module;\n-    } else if (passKind == PT_Function) {\n-        return SupportedPassKind::Function;\n-    } else {\n-        return SupportedPassKind::Unsupported;\n-    }\n+extern \"C\" LLVMRustPassKind\n+LLVMRustPassKind(LLVMPassRef rust_pass) {\n+    assert(rust_pass);\n+    Pass *pass = unwrap(rust_pass);\n+    return to_rust(pass->getPassKind());\n }\n \n extern \"C\" void\n-LLVMRustAddPass(LLVMPassManagerRef PM, Pass *pass) {\n-    assert(pass);\n+LLVMRustAddPass(LLVMPassManagerRef PM, LLVMPassRef rust_pass) {\n+    assert(rust_pass);\n+    Pass *pass = unwrap(rust_pass);\n     PassManagerBase *pm = unwrap(PM);\n     pm->add(pass);\n }\n@@ -162,13 +169,69 @@ LLVMRustHasFeature(LLVMTargetMachineRef TM,\n     return (Bits & FeatureEntry->Value) == FeatureEntry->Value;\n }\n \n+enum class LLVMRustCodeModel {\n+    Other,\n+    Default,\n+    JITDefault,\n+    Small,\n+    Kernel,\n+    Medium,\n+    Large,\n+};\n+\n+static CodeModel::Model\n+from_rust(LLVMRustCodeModel model)\n+{\n+    switch (model) {\n+    case LLVMRustCodeModel::Default:\n+        return CodeModel::Default;\n+    case LLVMRustCodeModel::JITDefault:\n+        return CodeModel::JITDefault;\n+    case LLVMRustCodeModel::Small:\n+        return CodeModel::Small;\n+    case LLVMRustCodeModel::Kernel:\n+        return CodeModel::Kernel;\n+    case LLVMRustCodeModel::Medium:\n+        return CodeModel::Medium;\n+    case LLVMRustCodeModel::Large:\n+        return CodeModel::Large;\n+    default:\n+        llvm_unreachable(\"Bad CodeModel.\");\n+  }\n+}\n+\n+enum class LLVMRustCodeGenOptLevel {\n+    Other,\n+    None,\n+    Less,\n+    Default,\n+    Aggressive,\n+};\n+\n+static CodeGenOpt::Level\n+from_rust(LLVMRustCodeGenOptLevel level)\n+{\n+    switch (level) {\n+    case LLVMRustCodeGenOptLevel::None:\n+        return CodeGenOpt::None;\n+    case LLVMRustCodeGenOptLevel::Less:\n+        return CodeGenOpt::Less;\n+    case LLVMRustCodeGenOptLevel::Default:\n+        return CodeGenOpt::Default;\n+    case LLVMRustCodeGenOptLevel::Aggressive:\n+        return CodeGenOpt::Aggressive;\n+    default:\n+        llvm_unreachable(\"Bad CodeGenOptLevel.\");\n+  }\n+}\n+\n extern \"C\" LLVMTargetMachineRef\n LLVMRustCreateTargetMachine(const char *triple,\n                             const char *cpu,\n                             const char *feature,\n-                            CodeModel::Model CM,\n+                            LLVMRustCodeModel rust_CM,\n                             LLVMRelocMode Reloc,\n-                            CodeGenOpt::Level OptLevel,\n+                            LLVMRustCodeGenOptLevel rust_OptLevel,\n                             bool UseSoftFloat,\n                             bool PositionIndependentExecutable,\n                             bool FunctionSections,\n@@ -179,6 +242,9 @@ LLVMRustCreateTargetMachine(const char *triple,\n #else\n     Optional<Reloc::Model> RM;\n #endif\n+    auto CM = from_rust(rust_CM);\n+    auto OptLevel = from_rust(rust_OptLevel);\n+\n     switch (Reloc){\n         case LLVMRelocStatic:\n             RM = Reloc::Static;\n@@ -251,14 +317,14 @@ LLVMRustAddAnalysisPasses(LLVMTargetMachineRef TM,\n \n extern \"C\" void\n LLVMRustConfigurePassManagerBuilder(LLVMPassManagerBuilderRef PMB,\n-                                    CodeGenOpt::Level OptLevel,\n+\t\t\t\t    LLVMRustCodeGenOptLevel OptLevel,\n                                     bool MergeFunctions,\n                                     bool SLPVectorize,\n                                     bool LoopVectorize) {\n     // Ignore mergefunc for now as enabling it causes crashes.\n     //unwrap(PMB)->MergeFunctions = MergeFunctions;\n     unwrap(PMB)->SLPVectorize = SLPVectorize;\n-    unwrap(PMB)->OptLevel = OptLevel;\n+    unwrap(PMB)->OptLevel = from_rust(OptLevel);\n     unwrap(PMB)->LoopVectorize = LoopVectorize;\n }\n \n@@ -314,13 +380,33 @@ LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n     cl::ParseCommandLineOptions(Argc, Argv);\n }\n \n-extern \"C\" bool\n+enum class LLVMRustFileType {\n+    Other,\n+    AssemblyFile,\n+    ObjectFile,\n+};\n+\n+static TargetMachine::CodeGenFileType\n+from_rust(LLVMRustFileType type)\n+{\n+    switch (type) {\n+    case LLVMRustFileType::AssemblyFile:\n+        return TargetMachine::CGFT_AssemblyFile;\n+    case LLVMRustFileType::ObjectFile:\n+        return TargetMachine::CGFT_ObjectFile;\n+    default:\n+        llvm_unreachable(\"Bad FileType.\");\n+  }\n+}\n+\n+extern \"C\" LLVMRustResult\n LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n                         LLVMPassManagerRef PMR,\n                         LLVMModuleRef M,\n                         const char *path,\n-                        TargetMachine::CodeGenFileType FileType) {\n+                        LLVMRustFileType rust_FileType) {\n   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n+  auto FileType = from_rust(rust_FileType);\n \n   std::string ErrorInfo;\n   std::error_code EC;\n@@ -329,7 +415,7 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n     ErrorInfo = EC.message();\n   if (ErrorInfo != \"\") {\n     LLVMRustSetLastError(ErrorInfo.c_str());\n-    return false;\n+    return LLVMRustResult::Failure;\n   }\n \n   unwrap(Target)->addPassesToEmitFile(*PM, OS, FileType, false);\n@@ -339,7 +425,7 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n   // stream (OS), so the only real safe place to delete this is here? Don't we\n   // wish this was written in Rust?\n   delete PM;\n-  return true;\n+  return LLVMRustResult::Success;\n }\n \n extern \"C\" void"}, {"sha": "e1c6dd07d2b3856a5a2050a8551474123f7a56c3", "filename": "src/rustllvm/README", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Frustllvm%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Frustllvm%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FREADME?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -1,2 +1,16 @@\n This directory currently contains some LLVM support code. This will generally\n be sent upstream to LLVM in time; for now it lives here.\n+\n+NOTE: the LLVM C++ ABI is subject to between-version breakage and must *never*\n+be exposed to Rust. To allow for easy auditing of that, all Rust-exposed types\n+must be typedef-ed as \"LLVMXyz\", or \"LLVMRustXyz\" if they were defined here.\n+\n+Functions that return a failure status and leave the error in\n+the LLVM last error should return an LLVMRustResult rather than an\n+int or anything to avoid confusion.\n+\n+When translating enums, add a single `Other` variant as the first\n+one to allow for new variants to be added. It should abort when used\n+as an input.\n+\n+All other types must not be typedef-ed as such."}, {"sha": "0da25e7ac57b7a7eea4628692251f0b92743d3cd", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 358, "deletions": 200, "changes": 558, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -13,6 +13,7 @@\n #include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/IR/DiagnosticInfo.h\"\n #include \"llvm/IR/DiagnosticPrinter.h\"\n+#include \"llvm/IR/Instructions.h\"\n \n #include \"llvm/IR/CallSite.h\"\n \n@@ -27,6 +28,30 @@ using namespace llvm;\n using namespace llvm::sys;\n using namespace llvm::object;\n \n+// LLVMAtomicOrdering is already an enum - don't create another\n+// one.\n+static AtomicOrdering from_rust(LLVMAtomicOrdering Ordering) {\n+  switch (Ordering) {\n+    case LLVMAtomicOrderingNotAtomic:\n+        return AtomicOrdering::NotAtomic;\n+    case LLVMAtomicOrderingUnordered:\n+        return AtomicOrdering::Unordered;\n+    case LLVMAtomicOrderingMonotonic:\n+        return AtomicOrdering::Monotonic;\n+    case LLVMAtomicOrderingAcquire:\n+        return AtomicOrdering::Acquire;\n+    case LLVMAtomicOrderingRelease:\n+        return AtomicOrdering::Release;\n+    case LLVMAtomicOrderingAcquireRelease:\n+        return AtomicOrdering::AcquireRelease;\n+    case LLVMAtomicOrderingSequentiallyConsistent:\n+        return AtomicOrdering::SequentiallyConsistent;\n+  }\n+\n+  llvm_unreachable(\"Invalid LLVMAtomicOrdering value!\");\n+}\n+\n+\n static char *LastError;\n \n extern \"C\" LLVMMemoryBufferRef\n@@ -57,45 +82,30 @@ LLVMRustSetNormalizedTarget(LLVMModuleRef M, const char *triple) {\n     unwrap(M)->setTargetTriple(Triple::normalize(triple));\n }\n \n-extern \"C\" LLVMValueRef LLVMRustConstSmallInt(LLVMTypeRef IntTy, unsigned N,\n-                                              LLVMBool SignExtend) {\n-  return LLVMConstInt(IntTy, (unsigned long long)N, SignExtend);\n-}\n-\n-extern \"C\" LLVMValueRef LLVMRustConstInt(LLVMTypeRef IntTy,\n-           unsigned N_hi,\n-           unsigned N_lo,\n-           LLVMBool SignExtend) {\n-  unsigned long long N = N_hi;\n-  N <<= 32;\n-  N |= N_lo;\n-  return LLVMConstInt(IntTy, N, SignExtend);\n-}\n-\n extern \"C\" void LLVMRustPrintPassTimings() {\n   raw_fd_ostream OS (2, false); // stderr.\n   TimerGroup::printAll(OS);\n }\n \n-extern \"C\" LLVMValueRef LLVMGetNamedValue(LLVMModuleRef M,\n-                                          const char* Name) {\n+extern \"C\" LLVMValueRef LLVMRustGetNamedValue(LLVMModuleRef M,\n+\t\t\t\t\t      const char* Name) {\n     return wrap(unwrap(M)->getNamedValue(Name));\n }\n \n-extern \"C\" LLVMValueRef LLVMGetOrInsertFunction(LLVMModuleRef M,\n-                                                const char* Name,\n-                                                LLVMTypeRef FunctionTy) {\n+extern \"C\" LLVMValueRef LLVMRustGetOrInsertFunction(LLVMModuleRef M,\n+\t\t\t\t\t\t    const char* Name,\n+\t\t\t\t\t\t    LLVMTypeRef FunctionTy) {\n   return wrap(unwrap(M)->getOrInsertFunction(Name,\n                                              unwrap<FunctionType>(FunctionTy)));\n }\n \n-extern \"C\" LLVMValueRef LLVMGetOrInsertGlobal(LLVMModuleRef M,\n-                                              const char* Name,\n-                                              LLVMTypeRef Ty) {\n+extern \"C\" LLVMValueRef LLVMRustGetOrInsertGlobal(LLVMModuleRef M,\n+\t\t\t\t\t\t  const char* Name,\n+\t\t\t\t\t\t  LLVMTypeRef Ty) {\n   return wrap(unwrap(M)->getOrInsertGlobal(Name, unwrap(Ty)));\n }\n \n-extern \"C\" LLVMTypeRef LLVMMetadataTypeInContext(LLVMContextRef C) {\n+extern \"C\" LLVMTypeRef LLVMRustMetadataTypeInContext(LLVMContextRef C) {\n   return wrap(Type::getMetadataTy(*unwrap(C)));\n }\n \n@@ -110,7 +120,10 @@ extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index,\n }\n \n \n-extern \"C\" void LLVMAddDereferenceableCallSiteAttr(LLVMValueRef Instr, unsigned idx, uint64_t b) {\n+extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n+\t\t\t\t\t\t       unsigned idx,\n+\t\t\t\t\t\t       uint64_t b)\n+{\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   AttrBuilder B;\n   B.addDereferenceableAttr(b);\n@@ -120,38 +133,50 @@ extern \"C\" void LLVMAddDereferenceableCallSiteAttr(LLVMValueRef Instr, unsigned\n                                                          idx, B)));\n }\n \n-extern \"C\" void LLVMAddFunctionAttribute(LLVMValueRef Fn, unsigned index,\n-                                         uint64_t Val) {\n+extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn,\n+\t\t\t\t\t     unsigned index,\n+\t\t\t\t\t     uint64_t Val)\n+{\n   Function *A = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addRawValue(Val);\n   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n }\n \n-extern \"C\" void LLVMAddDereferenceableAttr(LLVMValueRef Fn, unsigned index, uint64_t bytes) {\n+extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn,\n+\t\t\t\t\t       unsigned index,\n+\t\t\t\t\t       uint64_t bytes)\n+{\n   Function *A = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addDereferenceableAttr(bytes);\n   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n }\n \n-extern \"C\" void LLVMAddFunctionAttrString(LLVMValueRef Fn, unsigned index, const char *Name) {\n+extern \"C\" void LLVMRustAddFunctionAttrString(LLVMValueRef Fn,\n+\t\t\t\t\t      unsigned index,\n+\t\t\t\t\t      const char *Name)\n+{\n   Function *F = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addAttribute(Name);\n   F->addAttributes(index, AttributeSet::get(F->getContext(), index, B));\n }\n \n-extern \"C\" void LLVMAddFunctionAttrStringValue(LLVMValueRef Fn, unsigned index,\n-                                               const char *Name,\n-                                               const char *Value) {\n+extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n+\t\t\t\t\t\t   unsigned index,\n+\t\t\t\t\t\t   const char *Name,\n+\t\t\t\t\t\t   const char *Value) {\n   Function *F = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addAttribute(Name, Value);\n   F->addAttributes(index, AttributeSet::get(F->getContext(), index, B));\n }\n \n-extern \"C\" void LLVMRemoveFunctionAttributes(LLVMValueRef Fn, unsigned index, uint64_t Val) {\n+extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,\n+\t\t\t\t\t\t unsigned index,\n+\t\t\t\t\t\t uint64_t Val)\n+{\n   Function *A = unwrap<Function>(Fn);\n   const AttributeSet PAL = A->getAttributes();\n   AttrBuilder B(Val);\n@@ -161,7 +186,10 @@ extern \"C\" void LLVMRemoveFunctionAttributes(LLVMValueRef Fn, unsigned index, ui\n   A->setAttributes(PALnew);\n }\n \n-extern \"C\" void LLVMRemoveFunctionAttrString(LLVMValueRef fn, unsigned index, const char *Name) {\n+extern \"C\" void LLVMRustRemoveFunctionAttrString(LLVMValueRef fn,\n+\t\t\t\t\t\t unsigned index,\n+\t\t\t\t\t\t const char *Name)\n+{\n   Function *f = unwrap<Function>(fn);\n   LLVMContext &C = f->getContext();\n   AttrBuilder B;\n@@ -181,24 +209,24 @@ extern \"C\" void LLVMRustSetHasUnsafeAlgebra(LLVMValueRef V) {\n     }\n }\n \n-extern \"C\" LLVMValueRef LLVMBuildAtomicLoad(LLVMBuilderRef B,\n-                                            LLVMValueRef source,\n-                                            const char* Name,\n-                                            AtomicOrdering order,\n-                                            unsigned alignment) {\n+extern \"C\" LLVMValueRef LLVMRustBuildAtomicLoad(LLVMBuilderRef B,\n+\t\t\t\t\t\tLLVMValueRef source,\n+\t\t\t\t\t\tconst char* Name,\n+\t\t\t\t\t\tLLVMAtomicOrdering order,\n+\t\t\t\t\t\tunsigned alignment) {\n     LoadInst* li = new LoadInst(unwrap(source),0);\n-    li->setAtomic(order);\n+    li->setAtomic(from_rust(order));\n     li->setAlignment(alignment);\n     return wrap(unwrap(B)->Insert(li, Name));\n }\n \n-extern \"C\" LLVMValueRef LLVMBuildAtomicStore(LLVMBuilderRef B,\n-                                             LLVMValueRef val,\n-                                             LLVMValueRef target,\n-                                             AtomicOrdering order,\n-                                             unsigned alignment) {\n+extern \"C\" LLVMValueRef LLVMRustBuildAtomicStore(LLVMBuilderRef B,\n+\t\t\t\t\t\t LLVMValueRef val,\n+\t\t\t\t\t\t LLVMValueRef target,\n+\t\t\t\t\t\t LLVMAtomicOrdering order,\n+\t\t\t\t\t\t unsigned alignment) {\n     StoreInst* si = new StoreInst(unwrap(val),unwrap(target));\n-    si->setAtomic(order);\n+    si->setAtomic(from_rust(order));\n     si->setAlignment(alignment);\n     return wrap(unwrap(B)->Insert(si));\n }\n@@ -207,54 +235,96 @@ extern \"C\" LLVMValueRef LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B,\n                                                LLVMValueRef target,\n                                                LLVMValueRef old,\n                                                LLVMValueRef source,\n-                                               AtomicOrdering order,\n-                                               AtomicOrdering failure_order,\n+                                               LLVMAtomicOrdering order,\n+                                               LLVMAtomicOrdering failure_order,\n                                                LLVMBool weak) {\n-    AtomicCmpXchgInst* acxi = unwrap(B)->CreateAtomicCmpXchg(unwrap(target),\n-                                                             unwrap(old),\n-                                                             unwrap(source),\n-                                                             order,\n-                                                             failure_order);\n+    AtomicCmpXchgInst* acxi = unwrap(B)->CreateAtomicCmpXchg(\n+        unwrap(target),\n+        unwrap(old),\n+        unwrap(source),\n+        from_rust(order),\n+\tfrom_rust(failure_order));\n     acxi->setWeak(weak);\n     return wrap(acxi);\n }\n-extern \"C\" LLVMValueRef LLVMBuildAtomicFence(LLVMBuilderRef B,\n-                                             AtomicOrdering order,\n-                                             SynchronizationScope scope) {\n-    return wrap(unwrap(B)->CreateFence(order, scope));\n+\n+enum class LLVMRustSynchronizationScope {\n+    Other,\n+    SingleThread,\n+    CrossThread,\n+};\n+\n+static SynchronizationScope\n+from_rust(LLVMRustSynchronizationScope scope)\n+{\n+    switch (scope) {\n+    case LLVMRustSynchronizationScope::SingleThread:\n+        return SingleThread;\n+    case LLVMRustSynchronizationScope::CrossThread:\n+        return CrossThread;\n+    default:\n+        llvm_unreachable(\"bad SynchronizationScope.\");\n+    }\n }\n \n-extern \"C\" void LLVMSetDebug(int Enabled) {\n+extern \"C\" LLVMValueRef LLVMRustBuildAtomicFence(\n+    LLVMBuilderRef B,\n+    LLVMAtomicOrdering order,\n+    LLVMRustSynchronizationScope scope)\n+{\n+    return wrap(unwrap(B)->CreateFence(from_rust(order), from_rust(scope)));\n+}\n+\n+extern \"C\" void LLVMRustSetDebug(int Enabled) {\n #ifndef NDEBUG\n   DebugFlag = Enabled;\n #endif\n }\n \n-extern \"C\" LLVMValueRef LLVMInlineAsm(LLVMTypeRef Ty,\n-                                      char *AsmString,\n-                                      char *Constraints,\n-                                      LLVMBool HasSideEffects,\n-                                      LLVMBool IsAlignStack,\n-                                      unsigned Dialect) {\n+enum class LLVMRustAsmDialect {\n+    Other,\n+    Att,\n+    Intel,\n+};\n+\n+static InlineAsm::AsmDialect\n+from_rust(LLVMRustAsmDialect dialect)\n+{\n+    switch (dialect) {\n+    case LLVMRustAsmDialect::Att:\n+        return InlineAsm::AD_ATT;\n+    case LLVMRustAsmDialect::Intel:\n+        return InlineAsm::AD_Intel;\n+    default:\n+        llvm_unreachable(\"bad AsmDialect.\");\n+    }\n+}\n+\n+extern \"C\" LLVMValueRef LLVMRustInlineAsm(LLVMTypeRef Ty,\n+\t\t\t\t\t  char *AsmString,\n+\t\t\t\t\t  char *Constraints,\n+\t\t\t\t\t  LLVMBool HasSideEffects,\n+\t\t\t\t\t  LLVMBool IsAlignStack,\n+\t\t\t\t\t  LLVMRustAsmDialect Dialect) {\n     return wrap(InlineAsm::get(unwrap<FunctionType>(Ty), AsmString,\n                                Constraints, HasSideEffects,\n-                               IsAlignStack, (InlineAsm::AsmDialect) Dialect));\n+                               IsAlignStack, from_rust(Dialect)));\n }\n \n-typedef DIBuilder* DIBuilderRef;\n+typedef DIBuilder* LLVMRustDIBuilderRef;\n \n-typedef struct LLVMOpaqueMetadata *LLVMMetadataRef;\n+typedef struct LLVMOpaqueMetadata *LLVMRustMetadataRef;\n \n namespace llvm {\n-DEFINE_ISA_CONVERSION_FUNCTIONS(Metadata, LLVMMetadataRef)\n+DEFINE_ISA_CONVERSION_FUNCTIONS(Metadata, LLVMRustMetadataRef)\n \n-inline Metadata **unwrap(LLVMMetadataRef *Vals) {\n+inline Metadata **unwrap(LLVMRustMetadataRef *Vals) {\n   return reinterpret_cast<Metadata**>(Vals);\n }\n }\n \n template<typename DIT>\n-DIT* unwrapDIptr(LLVMMetadataRef ref) {\n+DIT* unwrapDIptr(LLVMRustMetadataRef ref) {\n     return (DIT*) (ref ? unwrap<MDNode>(ref) : NULL);\n }\n \n@@ -266,11 +336,11 @@ extern \"C\" uint32_t LLVMRustDebugMetadataVersion() {\n     return DEBUG_METADATA_VERSION;\n }\n \n-extern \"C\" uint32_t LLVMVersionMinor() {\n+extern \"C\" uint32_t LLVMRustVersionMinor() {\n   return LLVM_VERSION_MINOR;\n }\n \n-extern \"C\" uint32_t LLVMVersionMajor() {\n+extern \"C\" uint32_t LLVMRustVersionMajor() {\n   return LLVM_VERSION_MAJOR;\n }\n \n@@ -280,20 +350,20 @@ extern \"C\" void LLVMRustAddModuleFlag(LLVMModuleRef M,\n     unwrap(M)->addModuleFlag(Module::Warning, name, value);\n }\n \n-extern \"C\" DIBuilderRef LLVMDIBuilderCreate(LLVMModuleRef M) {\n+extern \"C\" LLVMRustDIBuilderRef LLVMRustDIBuilderCreate(LLVMModuleRef M) {\n     return new DIBuilder(*unwrap(M));\n }\n \n-extern \"C\" void LLVMDIBuilderDispose(DIBuilderRef Builder) {\n+extern \"C\" void LLVMRustDIBuilderDispose(LLVMRustDIBuilderRef Builder) {\n     delete Builder;\n }\n \n-extern \"C\" void LLVMDIBuilderFinalize(DIBuilderRef Builder) {\n+extern \"C\" void LLVMRustDIBuilderFinalize(LLVMRustDIBuilderRef Builder) {\n     Builder->finalize();\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateCompileUnit(\n-    DIBuilderRef Builder,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateCompileUnit(\n+    LLVMRustDIBuilderRef Builder,\n     unsigned Lang,\n     const char* File,\n     const char* Dir,\n@@ -312,40 +382,40 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateCompileUnit(\n                                            SplitName));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateFile(\n-    DIBuilderRef Builder,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateFile(\n+    LLVMRustDIBuilderRef Builder,\n     const char* Filename,\n     const char* Directory) {\n     return wrap(Builder->createFile(Filename, Directory));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateSubroutineType(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef File,\n-    LLVMMetadataRef ParameterTypes) {\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateSubroutineType(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef File,\n+    LLVMRustMetadataRef ParameterTypes) {\n     return wrap(Builder->createSubroutineType(\n #if LLVM_VERSION_MINOR == 7\n         unwrapDI<DIFile>(File),\n #endif\n         DITypeRefArray(unwrap<MDTuple>(ParameterTypes))));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateFunction(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef Scope,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateFunction(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef Scope,\n     const char* Name,\n     const char* LinkageName,\n-    LLVMMetadataRef File,\n+    LLVMRustMetadataRef File,\n     unsigned LineNo,\n-    LLVMMetadataRef Ty,\n+    LLVMRustMetadataRef Ty,\n     bool isLocalToUnit,\n     bool isDefinition,\n     unsigned ScopeLine,\n     unsigned Flags,\n     bool isOptimized,\n     LLVMValueRef Fn,\n-    LLVMMetadataRef TParam,\n-    LLVMMetadataRef Decl) {\n+    LLVMRustMetadataRef TParam,\n+    LLVMRustMetadataRef Decl) {\n #if LLVM_VERSION_MINOR >= 8\n     DITemplateParameterArray TParams =\n         DITemplateParameterArray(unwrap<MDTuple>(TParam));\n@@ -370,8 +440,8 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateFunction(\n #endif\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateBasicType(\n-    DIBuilderRef Builder,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateBasicType(\n+    LLVMRustDIBuilderRef Builder,\n     const char* Name,\n     uint64_t SizeInBits,\n     uint64_t AlignInBits,\n@@ -381,29 +451,29 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateBasicType(\n         AlignInBits, Encoding));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreatePointerType(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef PointeeTy,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreatePointerType(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef PointeeTy,\n     uint64_t SizeInBits,\n     uint64_t AlignInBits,\n     const char* Name) {\n     return wrap(Builder->createPointerType(\n         unwrapDI<DIType>(PointeeTy), SizeInBits, AlignInBits, Name));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateStructType(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef Scope,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStructType(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef Scope,\n     const char* Name,\n-    LLVMMetadataRef File,\n+    LLVMRustMetadataRef File,\n     unsigned LineNumber,\n     uint64_t SizeInBits,\n     uint64_t AlignInBits,\n     unsigned Flags,\n-    LLVMMetadataRef DerivedFrom,\n-    LLVMMetadataRef Elements,\n+    LLVMRustMetadataRef DerivedFrom,\n+    LLVMRustMetadataRef Elements,\n     unsigned RunTimeLang,\n-    LLVMMetadataRef VTableHolder,\n+    LLVMRustMetadataRef VTableHolder,\n     const char *UniqueId) {\n     return wrap(Builder->createStructType(\n         unwrapDI<DIDescriptor>(Scope),\n@@ -421,28 +491,28 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateStructType(\n         ));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateMemberType(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef Scope,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateMemberType(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef Scope,\n     const char* Name,\n-    LLVMMetadataRef File,\n+    LLVMRustMetadataRef File,\n     unsigned LineNo,\n     uint64_t SizeInBits,\n     uint64_t AlignInBits,\n     uint64_t OffsetInBits,\n     unsigned Flags,\n-    LLVMMetadataRef Ty) {\n+    LLVMRustMetadataRef Ty) {\n     return wrap(Builder->createMemberType(\n         unwrapDI<DIDescriptor>(Scope), Name,\n         unwrapDI<DIFile>(File), LineNo,\n         SizeInBits, AlignInBits, OffsetInBits, Flags,\n         unwrapDI<DIType>(Ty)));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateLexicalBlock(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef Scope,\n-    LLVMMetadataRef File,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateLexicalBlock(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef Scope,\n+    LLVMRustMetadataRef File,\n     unsigned Line,\n     unsigned Col) {\n     return wrap(Builder->createLexicalBlock(\n@@ -451,17 +521,17 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateLexicalBlock(\n         ));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateStaticVariable(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef Context,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef Context,\n     const char* Name,\n     const char* LinkageName,\n-    LLVMMetadataRef File,\n+    LLVMRustMetadataRef File,\n     unsigned LineNo,\n-    LLVMMetadataRef Ty,\n+    LLVMRustMetadataRef Ty,\n     bool isLocalToUnit,\n     LLVMValueRef Val,\n-    LLVMMetadataRef Decl = NULL) {\n+    LLVMRustMetadataRef Decl = NULL) {\n     return wrap(Builder->createGlobalVariable(unwrapDI<DIDescriptor>(Context),\n         Name,\n         LinkageName,\n@@ -473,14 +543,14 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateStaticVariable(\n         unwrapDIptr<MDNode>(Decl)));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateVariable(\n-    DIBuilderRef Builder,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(\n+    LLVMRustDIBuilderRef Builder,\n     unsigned Tag,\n-    LLVMMetadataRef Scope,\n+    LLVMRustMetadataRef Scope,\n     const char* Name,\n-    LLVMMetadataRef File,\n+    LLVMRustMetadataRef File,\n     unsigned LineNo,\n-    LLVMMetadataRef Ty,\n+    LLVMRustMetadataRef Ty,\n     bool AlwaysPreserve,\n     unsigned Flags,\n     int64_t* AddrOps,\n@@ -509,50 +579,50 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateVariable(\n #endif\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateArrayType(\n-    DIBuilderRef Builder,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateArrayType(\n+    LLVMRustDIBuilderRef Builder,\n     uint64_t Size,\n     uint64_t AlignInBits,\n-    LLVMMetadataRef Ty,\n-    LLVMMetadataRef Subscripts) {\n+    LLVMRustMetadataRef Ty,\n+    LLVMRustMetadataRef Subscripts) {\n     return wrap(Builder->createArrayType(Size, AlignInBits,\n         unwrapDI<DIType>(Ty),\n         DINodeArray(unwrapDI<MDTuple>(Subscripts))\n     ));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateVectorType(\n-    DIBuilderRef Builder,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVectorType(\n+    LLVMRustDIBuilderRef Builder,\n     uint64_t Size,\n     uint64_t AlignInBits,\n-    LLVMMetadataRef Ty,\n-    LLVMMetadataRef Subscripts) {\n+    LLVMRustMetadataRef Ty,\n+    LLVMRustMetadataRef Subscripts) {\n     return wrap(Builder->createVectorType(Size, AlignInBits,\n         unwrapDI<DIType>(Ty),\n         DINodeArray(unwrapDI<MDTuple>(Subscripts))\n     ));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderGetOrCreateSubrange(\n-    DIBuilderRef Builder,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderGetOrCreateSubrange(\n+    LLVMRustDIBuilderRef Builder,\n     int64_t Lo,\n     int64_t Count) {\n     return wrap(Builder->getOrCreateSubrange(Lo, Count));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderGetOrCreateArray(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef* Ptr,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderGetOrCreateArray(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef* Ptr,\n     unsigned Count) {\n     Metadata **DataValue = unwrap(Ptr);\n     return wrap(Builder->getOrCreateArray(\n         ArrayRef<Metadata*>(DataValue, Count)).get());\n }\n \n-extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareAtEnd(\n-    DIBuilderRef Builder,\n+extern \"C\" LLVMValueRef LLVMRustDIBuilderInsertDeclareAtEnd(\n+    LLVMRustDIBuilderRef Builder,\n     LLVMValueRef Val,\n-    LLVMMetadataRef VarInfo,\n+    LLVMRustMetadataRef VarInfo,\n     int64_t* AddrOps,\n     unsigned AddrOpsCount,\n     LLVMValueRef DL,\n@@ -566,10 +636,10 @@ extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareAtEnd(\n         unwrap(InsertAtEnd)));\n }\n \n-extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareBefore(\n-    DIBuilderRef Builder,\n+extern \"C\" LLVMValueRef LLVMRustDIBuilderInsertDeclareBefore(\n+    LLVMRustDIBuilderRef Builder,\n     LLVMValueRef Val,\n-    LLVMMetadataRef VarInfo,\n+    LLVMRustMetadataRef VarInfo,\n     int64_t* AddrOps,\n     unsigned AddrOpsCount,\n     LLVMValueRef DL,\n@@ -583,24 +653,24 @@ extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareBefore(\n         unwrap<Instruction>(InsertBefore)));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateEnumerator(\n-    DIBuilderRef Builder,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateEnumerator(\n+    LLVMRustDIBuilderRef Builder,\n     const char* Name,\n     uint64_t Val)\n {\n     return wrap(Builder->createEnumerator(Name, Val));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateEnumerationType(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef Scope,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateEnumerationType(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef Scope,\n     const char* Name,\n-    LLVMMetadataRef File,\n+    LLVMRustMetadataRef File,\n     unsigned LineNumber,\n     uint64_t SizeInBits,\n     uint64_t AlignInBits,\n-    LLVMMetadataRef Elements,\n-    LLVMMetadataRef ClassType)\n+    LLVMRustMetadataRef Elements,\n+    LLVMRustMetadataRef ClassType)\n {\n     return wrap(Builder->createEnumerationType(\n         unwrapDI<DIDescriptor>(Scope),\n@@ -613,16 +683,16 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateEnumerationType(\n         unwrapDI<DIType>(ClassType)));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateUnionType(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef Scope,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateUnionType(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef Scope,\n     const char* Name,\n-    LLVMMetadataRef File,\n+    LLVMRustMetadataRef File,\n     unsigned LineNumber,\n     uint64_t SizeInBits,\n     uint64_t AlignInBits,\n     unsigned Flags,\n-    LLVMMetadataRef Elements,\n+    LLVMRustMetadataRef Elements,\n     unsigned RunTimeLang,\n     const char* UniqueId)\n {\n@@ -640,12 +710,12 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateUnionType(\n         ));\n }\n \n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateTemplateTypeParameter(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef Scope,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateTemplateTypeParameter(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef Scope,\n     const char* Name,\n-    LLVMMetadataRef Ty,\n-    LLVMMetadataRef File,\n+    LLVMRustMetadataRef Ty,\n+    LLVMRustMetadataRef File,\n     unsigned LineNo,\n     unsigned ColumnNo)\n {\n@@ -656,21 +726,11 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateTemplateTypeParameter(\n       ));\n }\n \n-extern \"C\" int64_t LLVMDIBuilderCreateOpDeref()\n-{\n-    return dwarf::DW_OP_deref;\n-}\n-\n-extern \"C\" int64_t LLVMDIBuilderCreateOpPlus()\n-{\n-    return dwarf::DW_OP_plus;\n-}\n-\n-extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateNameSpace(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef Scope,\n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateNameSpace(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef Scope,\n     const char* Name,\n-    LLVMMetadataRef File,\n+    LLVMRustMetadataRef File,\n     unsigned LineNo)\n {\n     return wrap(Builder->createNameSpace(\n@@ -680,22 +740,22 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateNameSpace(\n         LineNo));\n }\n \n-extern \"C\" void LLVMDICompositeTypeSetTypeArray(\n-    DIBuilderRef Builder,\n-    LLVMMetadataRef CompositeType,\n-    LLVMMetadataRef TypeArray)\n+extern \"C\" void LLVMRustDICompositeTypeSetTypeArray(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef CompositeType,\n+    LLVMRustMetadataRef TypeArray)\n {\n     DICompositeType *tmp = unwrapDI<DICompositeType>(CompositeType);\n     Builder->replaceArrays(tmp, DINodeArray(unwrap<MDTuple>(TypeArray)));\n }\n \n-extern \"C\" LLVMValueRef LLVMDIBuilderCreateDebugLocation(\n+extern \"C\" LLVMValueRef LLVMRustDIBuilderCreateDebugLocation(\n   LLVMContextRef Context,\n   unsigned Line,\n   unsigned Column,\n-  LLVMMetadataRef Scope,\n-  LLVMMetadataRef InlinedAt) {\n-\n+  LLVMRustMetadataRef Scope,\n+  LLVMRustMetadataRef InlinedAt)\n+{\n     LLVMContext& context = *unwrap(Context);\n \n     DebugLoc debug_loc = DebugLoc::get(Line,\n@@ -706,12 +766,22 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateDebugLocation(\n     return wrap(MetadataAsValue::get(context, debug_loc.getAsMDNode()));\n }\n \n-extern \"C\" void LLVMWriteTypeToString(LLVMTypeRef Type, RustStringRef str) {\n+extern \"C\" int64_t LLVMRustDIBuilderCreateOpDeref()\n+{\n+    return dwarf::DW_OP_deref;\n+}\n+\n+extern \"C\" int64_t LLVMRustDIBuilderCreateOpPlus()\n+{\n+    return dwarf::DW_OP_plus;\n+}\n+\n+extern \"C\" void LLVMRustWriteTypeToString(LLVMTypeRef Type, RustStringRef str) {\n     raw_rust_string_ostream os(str);\n     unwrap<llvm::Type>(Type)->print(os);\n }\n \n-extern \"C\" void LLVMWriteValueToString(LLVMValueRef Value, RustStringRef str) {\n+extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef Value, RustStringRef str) {\n     raw_rust_string_ostream os(str);\n     os << \"(\";\n     unwrap<llvm::Value>(Value)->getType()->print(os);\n@@ -746,13 +816,6 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n     return true;\n }\n \n-extern \"C\" void\n-LLVMRustSetDLLStorageClass(LLVMValueRef Value,\n-                           GlobalValue::DLLStorageClassTypes Class) {\n-    GlobalValue *V = unwrap<GlobalValue>(Value);\n-    V->setDLLStorageClass(Class);\n-}\n-\n // Note that the two following functions look quite similar to the\n // LLVMGetSectionName function. Sadly, it appears that this function only\n // returns a char* pointer, which isn't guaranteed to be null-terminated. The\n@@ -768,7 +831,7 @@ inline section_iterator *unwrap(LLVMSectionIteratorRef SI) {\n     return reinterpret_cast<section_iterator*>(SI);\n }\n \n-extern \"C\" int\n+extern \"C\" size_t\n LLVMRustGetSectionName(LLVMSectionIteratorRef SI, const char **ptr) {\n     StringRef ret;\n     if (std::error_code ec = (*unwrap(SI))->getName(ret))\n@@ -787,13 +850,13 @@ DEFINE_SIMPLE_CONVERSION_FUNCTIONS(Twine, LLVMTwineRef)\n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(DebugLoc, LLVMDebugLocRef)\n \n extern \"C\" void\n-LLVMWriteTwineToString(LLVMTwineRef T, RustStringRef str) {\n+LLVMRustWriteTwineToString(LLVMTwineRef T, RustStringRef str) {\n     raw_rust_string_ostream os(str);\n     unwrap(T)->print(os);\n }\n \n extern \"C\" void\n-LLVMUnpackOptimizationDiagnostic(\n+LLVMRustUnpackOptimizationDiagnostic(\n     LLVMDiagnosticInfoRef di,\n     const char **pass_name_out,\n     LLVMValueRef *function_out,\n@@ -811,7 +874,7 @@ LLVMUnpackOptimizationDiagnostic(\n }\n \n extern \"C\" void\n-LLVMUnpackInlineAsmDiagnostic(\n+LLVMRustUnpackInlineAsmDiagnostic(\n     LLVMDiagnosticInfoRef di,\n     unsigned *cookie_out,\n     LLVMTwineRef *message_out,\n@@ -826,17 +889,111 @@ LLVMUnpackInlineAsmDiagnostic(\n     *instruction_out = wrap(ia->getInstruction());\n }\n \n-extern \"C\" void LLVMWriteDiagnosticInfoToString(LLVMDiagnosticInfoRef di, RustStringRef str) {\n+extern \"C\" void LLVMRustWriteDiagnosticInfoToString(LLVMDiagnosticInfoRef di, RustStringRef str) {\n     raw_rust_string_ostream os(str);\n     DiagnosticPrinterRawOStream dp(os);\n     unwrap(di)->print(dp);\n }\n \n-extern \"C\" int LLVMGetDiagInfoKind(LLVMDiagnosticInfoRef di) {\n-    return unwrap(di)->getKind();\n+enum class LLVMRustDiagnosticKind {\n+    Other,\n+    InlineAsm,\n+    StackSize,\n+    DebugMetadataVersion,\n+    SampleProfile,\n+    OptimizationRemark,\n+    OptimizationRemarkMissed,\n+    OptimizationRemarkAnalysis,\n+    OptimizationRemarkAnalysisFPCommute,\n+    OptimizationRemarkAnalysisAliasing,\n+    OptimizationRemarkOther,\n+    OptimizationFailure,\n+};\n+\n+static LLVMRustDiagnosticKind\n+to_rust(DiagnosticKind kind)\n+{\n+    switch (kind) {\n+    case DK_InlineAsm:\n+        return LLVMRustDiagnosticKind::InlineAsm;\n+    case DK_StackSize:\n+        return LLVMRustDiagnosticKind::StackSize;\n+    case DK_DebugMetadataVersion:\n+        return LLVMRustDiagnosticKind::DebugMetadataVersion;\n+    case DK_SampleProfile:\n+        return LLVMRustDiagnosticKind::SampleProfile;\n+    case DK_OptimizationRemark:\n+        return LLVMRustDiagnosticKind::OptimizationRemark;\n+    case DK_OptimizationRemarkMissed:\n+        return LLVMRustDiagnosticKind::OptimizationRemarkMissed;\n+    case DK_OptimizationRemarkAnalysis:\n+        return LLVMRustDiagnosticKind::OptimizationRemarkAnalysis;\n+#if LLVM_VERSION_MINOR >= 8\n+    case DK_OptimizationRemarkAnalysisFPCommute:\n+        return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisFPCommute;\n+    case DK_OptimizationRemarkAnalysisAliasing:\n+        return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisAliasing;\n+#endif\n+    default:\n+#if LLVM_VERSION_MINOR >= 9\n+        return (kind >= DK_FirstRemark && kind <= DK_LastRemark) ?\n+            LLVMRustDiagnosticKind::OptimizationRemarkOther :\n+            LLVMRustDiagnosticKind::Other;\n+#else\n+        return LLVMRustDiagnosticKind::Other;\n+#endif\n+  }\n+}\n+\n+extern \"C\" LLVMRustDiagnosticKind LLVMRustGetDiagInfoKind(LLVMDiagnosticInfoRef di) {\n+    return to_rust((DiagnosticKind) unwrap(di)->getKind());\n+}\n+// This is kept distinct from LLVMGetTypeKind, because when\n+// a new type kind is added, the Rust-side enum must be\n+// updated or UB will result.\n+extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n+  switch (unwrap(Ty)->getTypeID()) {\n+  case Type::VoidTyID:\n+    return LLVMVoidTypeKind;\n+  case Type::HalfTyID:\n+    return LLVMHalfTypeKind;\n+  case Type::FloatTyID:\n+    return LLVMFloatTypeKind;\n+  case Type::DoubleTyID:\n+    return LLVMDoubleTypeKind;\n+  case Type::X86_FP80TyID:\n+    return LLVMX86_FP80TypeKind;\n+  case Type::FP128TyID:\n+    return LLVMFP128TypeKind;\n+  case Type::PPC_FP128TyID:\n+    return LLVMPPC_FP128TypeKind;\n+  case Type::LabelTyID:\n+    return LLVMLabelTypeKind;\n+  case Type::MetadataTyID:\n+    return LLVMMetadataTypeKind;\n+  case Type::IntegerTyID:\n+    return LLVMIntegerTypeKind;\n+  case Type::FunctionTyID:\n+    return LLVMFunctionTypeKind;\n+  case Type::StructTyID:\n+    return LLVMStructTypeKind;\n+  case Type::ArrayTyID:\n+    return LLVMArrayTypeKind;\n+  case Type::PointerTyID:\n+    return LLVMPointerTypeKind;\n+  case Type::VectorTyID:\n+    return LLVMVectorTypeKind;\n+  case Type::X86_MMXTyID:\n+    return LLVMX86_MMXTypeKind;\n+#if LLVM_VERSION_MINOR >= 8\n+  case Type::TokenTyID:\n+    return LLVMTokenTypeKind;\n+#endif\n+  }\n+  llvm_unreachable(\"Unhandled TypeID.\");\n }\n \n-extern \"C\" void LLVMWriteDebugLocToString(\n+extern \"C\" void LLVMRustWriteDebugLocToString(\n     LLVMContextRef C,\n     LLVMDebugLocRef dl,\n     RustStringRef str)\n@@ -847,15 +1004,16 @@ extern \"C\" void LLVMWriteDebugLocToString(\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(SMDiagnostic, LLVMSMDiagnosticRef)\n \n-extern \"C\" void LLVMSetInlineAsmDiagnosticHandler(\n+extern \"C\" void LLVMRustSetInlineAsmDiagnosticHandler(\n     LLVMContextRef C,\n     LLVMContext::InlineAsmDiagHandlerTy H,\n     void *CX)\n {\n     unwrap(C)->setInlineAsmDiagnosticHandler(H, CX);\n }\n \n-extern \"C\" void LLVMWriteSMDiagnosticToString(LLVMSMDiagnosticRef d, RustStringRef str) {\n+extern \"C\" void LLVMRustWriteSMDiagnosticToString(LLVMSMDiagnosticRef d,\n+\t\t\t\t\t\t  RustStringRef str) {\n     raw_rust_string_ostream os(str);\n     unwrap(d)->print(\"\", os);\n }"}, {"sha": "5aae11fb456b6d9ce0abb96efcf587c9fbfec24f", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0b4e6764809022433edbff275528ec2540bda73/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/a0b4e6764809022433edbff275528ec2540bda73/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=a0b4e6764809022433edbff275528ec2540bda73", "patch": "@@ -58,6 +58,11 @@\n \n void LLVMRustSetLastError(const char*);\n \n+enum class LLVMRustResult {\n+    Success,\n+    Failure\n+};\n+\n typedef struct OpaqueRustString *RustStringRef;\n typedef struct LLVMOpaqueTwine *LLVMTwineRef;\n typedef struct LLVMOpaqueDebugLoc *LLVMDebugLocRef;"}]}