{"sha": "ee44f7ed27f8a83670af166ab886ec44e53dc233", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNDRmN2VkMjdmOGE4MzY3MGFmMTY2YWI4ODZlYzQ0ZTUzZGMyMzM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-13T18:44:12Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-16T11:34:33Z"}, "message": "`DefinitelyInitializedLvals` dataflow op (goal: move away from `MaybeUninitializedLvals`)", "tree": {"sha": "b0332cc98c6a8c18bd0fafa283f9ea31d5c379d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0332cc98c6a8c18bd0fafa283f9ea31d5c379d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee44f7ed27f8a83670af166ab886ec44e53dc233", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee44f7ed27f8a83670af166ab886ec44e53dc233", "html_url": "https://github.com/rust-lang/rust/commit/ee44f7ed27f8a83670af166ab886ec44e53dc233", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee44f7ed27f8a83670af166ab886ec44e53dc233/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8956789c35a77e774effd7a54182752dbedc321e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8956789c35a77e774effd7a54182752dbedc321e", "html_url": "https://github.com/rust-lang/rust/commit/8956789c35a77e774effd7a54182752dbedc321e"}], "stats": {"total": 230, "additions": 220, "deletions": 10}, "files": [{"sha": "4cf739396e7fc0577b085cfa418e7bd0ef885783", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 151, "deletions": 10, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/ee44f7ed27f8a83670af166ab886ec44e53dc233/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee44f7ed27f8a83670af166ab886ec44e53dc233/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=ee44f7ed27f8a83670af166ab886ec44e53dc233", "patch": "@@ -661,6 +661,53 @@ pub struct MaybeUninitializedLvals<'a, 'tcx: 'a> {\n     phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n }\n \n+/// `DefinitelyInitializedLvals` tracks all l-values that are definitely\n+/// initialized upon reaching a particular point in the control flow\n+/// for a function.\n+///\n+/// FIXME: Note that once flow-analysis is complete, this should be\n+/// the set-complement of MaybeUninitializedLvals; thus we can get rid\n+/// of one or the other of these two. I'm inclined to get rid of\n+/// MaybeUninitializedLvals, simply because the sets will tend to be\n+/// smaller in this analysis and thus easier for humans to process\n+/// when debugging.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // definite-init:\n+///                                            // {          }\n+///     let a = S; let b = S; let c; let d;    // {a, b      }\n+///\n+///     if pred {\n+///         drop(a);                           // {   b,     }\n+///         b = S;                             // {   b,     }\n+///\n+///     } else {\n+///         drop(b);                           // {a,        }\n+///         d = S;                             // {a,       d}\n+///\n+///     }                                      // {          }\n+///\n+///     c = S;                                 // {       c  }\n+/// }\n+/// ```\n+///\n+/// To determine whether an l-value *may* be uninitialized at a\n+/// particular control-flow point, one can take the set-complement\n+/// of this data.\n+///\n+/// Similarly, at a given `drop` statement, the set-difference between\n+/// this data and `MaybeInitializedLvals` yields the set of l-values\n+/// that would require a dynamic drop-flag at that statement.\n+#[derive(Debug, Default)]\n+pub struct DefinitelyInitializedLvals<'a, 'tcx: 'a> {\n+    // See \"Note on PhantomData\" above.\n+    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+}\n+\n /// `MovingOutStatements` tracks the statements that perform moves out\n /// of particular l-values. More precisely, it tracks whether the\n /// *effect* of such moves (namely, the uninitialization of the\n@@ -809,6 +856,23 @@ impl<'a, 'tcx> MaybeUninitializedLvals<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> DefinitelyInitializedLvals<'a, 'tcx> {\n+    fn update_bits(sets: &mut BlockSets, path: MovePathIndex,\n+                   state: super::DropFlagState)\n+    {\n+        match state {\n+            DropFlagState::Dead => {\n+                sets.gen_set.clear_bit(path.idx());\n+                sets.kill_set.set_bit(path.idx());\n+            }\n+            DropFlagState::Live => {\n+                sets.gen_set.set_bit(path.idx());\n+                sets.kill_set.clear_bit(path.idx());\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n     type Bit = MovePath<'tcx>;\n     type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n@@ -940,6 +1004,72 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n+    type Bit = MovePath<'tcx>;\n+    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    fn name() -> &'static str { \"definite_init\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.2.move_paths.len()\n+    }\n+    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n+        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n+    }\n+\n+    // sets on_entry bits for Arg lvalues\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets) {\n+        for e in &mut sets.on_entry[..] { *e = 0; }\n+\n+        super::drop_flag_effects_for_function_entry(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            |path, s| {\n+                assert!(s == DropFlagState::Live);\n+                sets.on_entry.set_bit(path.idx());\n+            });\n+    }\n+\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets,\n+                        bb: repr::BasicBlock,\n+                        idx: usize)\n+    {\n+        super::drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: idx },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        super::drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: statements_len },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut [usize],\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        // when a call returns successfully, that means we need to set\n+        // the bits for that dest_lval to 1 (initialized).\n+        let move_path_index = ctxt.2.rev_lookup.find(dest_lval);\n+        super::on_all_children_bits(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            move_path_index,\n+            |mpi| { in_out.set_bit(mpi.idx()); }\n+        );\n+    }\n+}\n+\n fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n     let retval = bitvec.set_bit(move_index.idx());\n     assert!(retval);\n@@ -966,21 +1096,25 @@ impl<'a, 'tcx> BitwiseOperator for MaybeUninitializedLvals<'a, 'tcx> {\n     }\n }\n \n-// FIXME: I'm not sure it ever makes sense to use `true` for a\n-// DataflowOperator::initial_value implementation, because: the way\n-// that dataflow fixed point iteration works, you want to start at\n-// bottom and work your way to a fixed point.\n+impl<'a, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 & pred2 // \"definitely\" means we intersect effects of both preds\n+    }\n+}\n+\n+// FIXME: `DataflowOperator::initial_value` should be named\n+// `bottom_value`. The way that dataflow fixed point iteration works,\n+// you want to start at bottom and work your way to a fixed point.\n+// This needs to include the detail that the control-flow merges will\n+// apply the `join` operator above to current state (which starts at\n+// that bottom value).\n //\n // This means, for propagation across the graph, that you either want\n // to start at all-zeroes and then use Union as your merge when\n // propagating, or you start at all-ones and then use Intersect as\n // your merge when propagating.\n-//\n-// (An alternative could be, when propagating from Block A into block\n-// B, to clear B's on_entry bits, and then iterate over all of B's\n-// immediate predecessors. This would require storing on_exit state\n-// for each block, however.)\n-   \n+\n impl<'a, 'tcx> DataflowOperator for MovingOutStatements<'a, 'tcx> {\n     #[inline]\n     fn initial_value() -> bool {\n@@ -1002,6 +1136,13 @@ impl<'a, 'tcx> DataflowOperator for MaybeUninitializedLvals<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn initial_value() -> bool {\n+        true // bottom = initialized\n+    }\n+}\n+\n #[inline]\n fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n                                in_vec: &[usize],"}, {"sha": "405647aec026e110f5e0a7a3ae278fa26786beb0", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee44f7ed27f8a83670af166ab886ec44e53dc233/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee44f7ed27f8a83670af166ab886ec44e53dc233/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=ee44f7ed27f8a83670af166ab886ec44e53dc233", "patch": "@@ -32,6 +32,7 @@ use self::dataflow::{BitDenotation};\n use self::dataflow::{Dataflow, DataflowAnalysis, DataflowResults};\n use self::dataflow::{HasMoveData};\n use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use self::dataflow::{DefinitelyInitializedLvals};\n use self::gather_moves::{MoveData, MovePathIndex, Location};\n use self::gather_moves::{MovePathContent};\n \n@@ -78,13 +79,18 @@ pub fn borrowck_mir<'a, 'tcx: 'a>(\n         do_dataflow(tcx, mir, id, attributes, ctxt, MaybeInitializedLvals::default());\n     let (ctxt, flow_uninits) =\n         do_dataflow(tcx, mir, id, attributes, ctxt, MaybeUninitializedLvals::default());\n+    let (ctxt, flow_def_inits) =\n+        do_dataflow(tcx, mir, id, attributes, ctxt, DefinitelyInitializedLvals::default());\n \n     if has_rustc_mir_with(attributes, \"rustc_peek_maybe_init\").is_some() {\n         dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &ctxt, &flow_inits);\n     }\n     if has_rustc_mir_with(attributes, \"rustc_peek_maybe_uninit\").is_some() {\n         dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &ctxt, &flow_uninits);\n     }\n+    if has_rustc_mir_with(attributes, \"rustc_peek_definite_init\").is_some() {\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &ctxt, &flow_def_inits);\n+    }\n     let move_data = ctxt.2;\n \n     if has_rustc_mir_with(attributes, \"stop_after_dataflow\").is_some() {"}, {"sha": "a133ddc15f1acb1993177df243055c40ff8fd2cd", "filename": "src/test/compile-fail/mir-dataflow/def-inits-1.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ee44f7ed27f8a83670af166ab886ec44e53dc233/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee44f7ed27f8a83670af166ab886ec44e53dc233/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs?ref=ee44f7ed27f8a83670af166ab886ec44e53dc233", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// General test of maybe_uninits state computed by MIR dataflow.\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+\n+use std::intrinsics::rustc_peek;\n+use std::mem::{drop, replace};\n+\n+struct S(i32);\n+\n+#[rustc_mir_borrowck]\n+#[rustc_mir(rustc_peek_definite_init,stop_after_dataflow)]\n+fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n+    let ret;\n+    // `ret` starts off uninitialized\n+    unsafe { rustc_peek(&ret); }  //~ ERROR rustc_peek: bit not set\n+\n+    // All function formal parameters start off initialized.\n+\n+    unsafe { rustc_peek(&x) };\n+    unsafe { rustc_peek(&y) };\n+    unsafe { rustc_peek(&z) };\n+\n+    ret = if test {\n+        ::std::mem::replace(x, y)\n+    } else {\n+        z = y;\n+        z\n+    };\n+\n+    // `z` may be uninitialized here.\n+    unsafe { rustc_peek(&z); } //~ ERROR rustc_peek: bit not set\n+\n+    // `y` is definitely uninitialized here.\n+    unsafe { rustc_peek(&y); } //~ ERROR rustc_peek: bit not set\n+\n+    // `x` is still (definitely) initialized (replace above is a reborrow).\n+    unsafe { rustc_peek(&x); }\n+\n+    ::std::mem::drop(x);\n+\n+    // `x` is *definitely* uninitialized here\n+    unsafe { rustc_peek(&x); } //~ ERROR rustc_peek: bit not set\n+\n+    // `ret` is now definitely initialized (via `if` above).\n+    unsafe { rustc_peek(&ret); }\n+\n+    ret\n+}\n+fn main() {\n+    foo(true, &mut S(13), S(14), S(15));\n+    foo(false, &mut S(13), S(14), S(15));\n+}"}]}