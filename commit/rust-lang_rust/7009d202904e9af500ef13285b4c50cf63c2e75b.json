{"sha": "7009d202904e9af500ef13285b4c50cf63c2e75b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMDlkMjAyOTA0ZTlhZjUwMGVmMTMyODViNGM1MGNmNjNjMmU3NWI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-16T06:24:31Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-18T16:21:38Z"}, "message": "Factor out or-pattern usefulness merging", "tree": {"sha": "dd3165421e6bec1237e7d2154ae48019c70a6fc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd3165421e6bec1237e7d2154ae48019c70a6fc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7009d202904e9af500ef13285b4c50cf63c2e75b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7009d202904e9af500ef13285b4c50cf63c2e75b", "html_url": "https://github.com/rust-lang/rust/commit/7009d202904e9af500ef13285b4c50cf63c2e75b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7009d202904e9af500ef13285b4c50cf63c2e75b/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2309783a0b65163041b03dce04d7df85dcabc2cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2309783a0b65163041b03dce04d7df85dcabc2cd", "html_url": "https://github.com/rust-lang/rust/commit/2309783a0b65163041b03dce04d7df85dcabc2cd"}], "stats": {"total": 153, "additions": 81, "deletions": 72}, "files": [{"sha": "ae92898a0f413e663c26a060f930cecb904552ed", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 81, "deletions": 72, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/7009d202904e9af500ef13285b4c50cf63c2e75b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7009d202904e9af500ef13285b4c50cf63c2e75b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=7009d202904e9af500ef13285b4c50cf63c2e75b", "patch": "@@ -648,6 +648,81 @@ impl<'tcx> Usefulness<'tcx> {\n         !matches!(*self, NotUseful)\n     }\n \n+    /// When trying several branches and each returns a `Usefulness`, we need to combine the\n+    /// results together.\n+    fn merge(usefulnesses: impl Iterator<Item = (Self, Span)>, column_count: usize) -> Self {\n+        // If two branches have detected some unreachable sub-branches, we need to be careful. If\n+        // they were detected in columns that are not the current one, we want to keep only the\n+        // sub-branches that were unreachable in _all_ branches. Eg. in the following, the last\n+        // `true` is unreachable in the second branch of the first or-pattern, but not otherwise.\n+        // Therefore we don't want to lint that it is unreachable.\n+        //\n+        // ```\n+        // match (true, true) {\n+        //     (true, true) => {}\n+        //     (false | true, false | true) => {}\n+        // }\n+        // ```\n+        // If however the sub-branches come from the current column, they come from the inside of\n+        // the current or-pattern, and we want to keep them all. Eg. in the following, we _do_ want\n+        // to lint that the last `false` is unreachable.\n+        // ```\n+        // match None {\n+        //     Some(false) => {}\n+        //     None | Some(true | false) => {}\n+        // }\n+        // ```\n+\n+        // We keep track of sub-branches separately depending on whether they come from this column\n+        // or from others.\n+        let mut unreachables_this_column: FxHashSet<Span> = FxHashSet::default();\n+        let mut unreachables_other_columns: Vec<FxHashSet<Span>> = Vec::default();\n+        // Whether at least one branch is reachable.\n+        let mut any_is_useful = false;\n+\n+        for (u, span) in usefulnesses {\n+            match u {\n+                Useful(unreachables) => {\n+                    if let Some((this_column, other_columns)) = unreachables.split_last() {\n+                        // We keep the union of unreachables found in the first column.\n+                        unreachables_this_column.extend(this_column);\n+                        // We keep the intersection of unreachables found in other columns.\n+                        if unreachables_other_columns.is_empty() {\n+                            unreachables_other_columns = other_columns.to_vec();\n+                        } else {\n+                            unreachables_other_columns = unreachables_other_columns\n+                                .into_iter()\n+                                .zip(other_columns)\n+                                .map(|(x, y)| x.intersection(&y).copied().collect())\n+                                .collect();\n+                        }\n+                    }\n+                    any_is_useful = true;\n+                }\n+                NotUseful => {\n+                    unreachables_this_column.insert(span);\n+                }\n+                UsefulWithWitness(_) => {\n+                    bug!(\n+                        \"encountered or-pat in the expansion of `_` during exhaustiveness checking\"\n+                    )\n+                }\n+            }\n+        }\n+\n+        if any_is_useful {\n+            let mut unreachables = if unreachables_other_columns.is_empty() {\n+                (0..column_count - 1).map(|_| FxHashSet::default()).collect()\n+            } else {\n+                unreachables_other_columns\n+            };\n+            unreachables.push(unreachables_this_column);\n+            Useful(unreachables)\n+        } else {\n+            NotUseful\n+        }\n+    }\n+\n     fn apply_constructor<'p>(\n         self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n@@ -833,85 +908,19 @@ fn is_useful<'p, 'tcx>(\n     if let Some(vs) = v.expand_or_pat() {\n         // We expand the or pattern, trying each of its branches in turn and keeping careful track\n         // of possible unreachable sub-branches.\n-        //\n-        // If two branches have detected some unreachable sub-branches, we need to be careful. If\n-        // they were detected in columns that are not the current one, we want to keep only the\n-        // sub-branches that were unreachable in _all_ branches. Eg. in the following, the last\n-        // `true` is unreachable in the second branch of the first or-pattern, but not otherwise.\n-        // Therefore we don't want to lint that it is unreachable.\n-        //\n-        // ```\n-        // match (true, true) {\n-        //     (true, true) => {}\n-        //     (false | true, false | true) => {}\n-        // }\n-        // ```\n-        // If however the sub-branches come from the current column, they come from the inside of\n-        // the current or-pattern, and we want to keep them all. Eg. in the following, we _do_ want\n-        // to lint that the last `false` is unreachable.\n-        // ```\n-        // match None {\n-        //     Some(false) => {}\n-        //     None | Some(true | false) => {}\n-        // }\n-        // ```\n-\n         let mut matrix = matrix.clone();\n-        // We keep track of sub-branches separately depending on whether they come from this column\n-        // or from others.\n-        let mut unreachables_this_column: FxHashSet<Span> = FxHashSet::default();\n-        let mut unreachables_other_columns: Vec<FxHashSet<Span>> = Vec::default();\n-        // Whether at least one branch is reachable.\n-        let mut any_is_useful = false;\n-\n-        for v in vs {\n-            let res = is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-            match res {\n-                Useful(unreachables) => {\n-                    if let Some((this_column, other_columns)) = unreachables.split_last() {\n-                        // We keep the union of unreachables found in the first column.\n-                        unreachables_this_column.extend(this_column);\n-                        // We keep the intersection of unreachables found in other columns.\n-                        if unreachables_other_columns.is_empty() {\n-                            unreachables_other_columns = other_columns.to_vec();\n-                        } else {\n-                            unreachables_other_columns = unreachables_other_columns\n-                                .into_iter()\n-                                .zip(other_columns)\n-                                .map(|(x, y)| x.intersection(&y).copied().collect())\n-                                .collect();\n-                        }\n-                    }\n-                    any_is_useful = true;\n-                }\n-                NotUseful => {\n-                    unreachables_this_column.insert(v.head().span);\n-                }\n-                UsefulWithWitness(_) => bug!(\n-                    \"encountered or-pat in the expansion of `_` during exhaustiveness checking\"\n-                ),\n-            }\n-\n+        let usefulnesses = vs.into_iter().map(|v| {\n+            let span = v.head().span;\n+            let u = is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {\n                 // We push the already-seen patterns into the matrix in order to detect redundant\n                 // branches like `Some(_) | Some(0)`.\n                 matrix.push(v);\n             }\n-        }\n-\n-        return if any_is_useful {\n-            let mut unreachables = if unreachables_other_columns.is_empty() {\n-                let n_columns = v.len();\n-                (0..n_columns - 1).map(|_| FxHashSet::default()).collect()\n-            } else {\n-                unreachables_other_columns\n-            };\n-            unreachables.push(unreachables_this_column);\n-            Useful(unreachables)\n-        } else {\n-            NotUseful\n-        };\n+            (u, span)\n+        });\n+        return Usefulness::merge(usefulnesses, v.len());\n     }\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476)."}]}