{"sha": "0633a0e3801e4efc9ab07bf811e442bd379ce93a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MzNhMGUzODAxZTRlZmM5YWIwN2JmODExZTQ0MmJkMzc5Y2U5M2E=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-08T21:21:20Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-13T09:54:37Z"}, "message": "remove Panic variant from InterpError", "tree": {"sha": "228f30b3f08ab6ea532f17dd7ab32f5683e249ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/228f30b3f08ab6ea532f17dd7ab32f5683e249ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0633a0e3801e4efc9ab07bf811e442bd379ce93a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0633a0e3801e4efc9ab07bf811e442bd379ce93a", "html_url": "https://github.com/rust-lang/rust/commit/0633a0e3801e4efc9ab07bf811e442bd379ce93a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0633a0e3801e4efc9ab07bf811e442bd379ce93a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e6eaceedeeda764056eb0e2134735793533770d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e6eaceedeeda764056eb0e2134735793533770d", "html_url": "https://github.com/rust-lang/rust/commit/2e6eaceedeeda764056eb0e2134735793533770d"}], "stats": {"total": 240, "additions": 117, "deletions": 123}, "files": [{"sha": "e819dfbacd898b448223fba75f1cef0f9e4c616e", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=0633a0e3801e4efc9ab07bf811e442bd379ce93a", "patch": "@@ -139,7 +139,6 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         lint_root: Option<hir::HirId>,\n     ) -> Result<(), ErrorHandled> {\n         let must_error = match self.error {\n-            InterpError::MachineStop(_) => bug!(\"CTFE does not stop\"),\n             err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n                 return Err(ErrorHandled::TooGeneric);\n             }\n@@ -149,9 +148,18 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         };\n         trace!(\"reporting const eval failure at {:?}\", self.span);\n \n+        let err_msg = match &self.error {\n+            InterpError::MachineStop(msg) => {\n+                // A custom error (`ConstEvalErrKind` in `librustc_mir/interp/const_eval/error.rs`).\n+                // Should be turned into a string by now.\n+                msg.downcast_ref::<String>().expect(\"invalid MachineStop payload\").clone()\n+            }\n+            err => err.to_string(),\n+        };\n+\n         let add_span_labels = |err: &mut DiagnosticBuilder<'_>| {\n             if !must_error {\n-                err.span_label(self.span, self.error.to_string());\n+                err.span_label(self.span, err_msg.clone());\n             }\n             // Skip the last, which is just the environment of the constant.  The stacktrace\n             // is sometimes empty because we create \"fake\" eval contexts in CTFE to do work\n@@ -183,7 +191,7 @@ impl<'tcx> ConstEvalErr<'tcx> {\n             );\n         } else {\n             let mut err = if must_error {\n-                struct_error(tcx, &self.error.to_string())\n+                struct_error(tcx, &err_msg)\n             } else {\n                 struct_error(tcx, message)\n             };\n@@ -259,6 +267,9 @@ impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     }\n }\n \n+/// Information about a panic.\n+///\n+/// FIXME: this is not actually an InterpError, and should probably be moved to another module.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n pub enum PanicInfo<O> {\n     Panic { msg: Symbol, line: u32, col: u32, file: Symbol },\n@@ -616,8 +627,6 @@ impl fmt::Debug for ResourceExhaustionInfo {\n }\n \n pub enum InterpError<'tcx> {\n-    /// The program panicked.\n-    Panic(PanicInfo<u64>),\n     /// The program caused undefined behavior.\n     UndefinedBehavior(UndefinedBehaviorInfo),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n@@ -650,8 +659,7 @@ impl fmt::Debug for InterpError<'_> {\n             InvalidProgram(ref msg) => write!(f, \"{:?}\", msg),\n             UndefinedBehavior(ref msg) => write!(f, \"{:?}\", msg),\n             ResourceExhaustion(ref msg) => write!(f, \"{:?}\", msg),\n-            Panic(ref msg) => write!(f, \"{:?}\", msg),\n-            MachineStop(_) => write!(f, \"machine caused execution to stop\"),\n+            MachineStop(_) => bug!(\"unhandled MachineStop\"),\n         }\n     }\n }"}, {"sha": "b4cfd86015296323d5e5eaf27d0ff94203a611c2", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=0633a0e3801e4efc9ab07bf811e442bd379ce93a", "patch": "@@ -37,15 +37,6 @@ macro_rules! err_ub_format {\n     ($($tt:tt)*) => { err_ub!(Ub(format!($($tt)*))) };\n }\n \n-#[macro_export]\n-macro_rules! err_panic {\n-    ($($tt:tt)*) => {\n-        $crate::mir::interpret::InterpError::Panic(\n-            $crate::mir::interpret::PanicInfo::$($tt)*\n-        )\n-    };\n-}\n-\n #[macro_export]\n macro_rules! err_exhaust {\n     ($($tt:tt)*) => {\n@@ -80,11 +71,6 @@ macro_rules! throw_ub_format {\n     ($($tt:tt)*) => { throw_ub!(Ub(format!($($tt)*))) };\n }\n \n-#[macro_export]\n-macro_rules! throw_panic {\n-    ($($tt:tt)*) => { return Err(err_panic!($($tt)*).into()) };\n-}\n-\n #[macro_export]\n macro_rules! throw_exhaust {\n     ($($tt:tt)*) => { return Err(err_exhaust!($($tt)*).into()) };"}, {"sha": "e0e7854609971c64c06ba44ac2f3bfa550ae804e", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=0633a0e3801e4efc9ab07bf811e442bd379ce93a", "patch": "@@ -2,32 +2,39 @@ use std::error::Error;\n use std::fmt;\n \n use super::InterpCx;\n-use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n+use crate::interpret::{ConstEvalErr, InterpError, InterpErrorInfo, Machine, PanicInfo};\n+\n+/// The CTFE machine has some custom error kinds.\n #[derive(Clone, Debug)]\n-pub enum ConstEvalError {\n+pub enum ConstEvalErrKind {\n     NeedsRfc(String),\n     ConstAccessesStatic,\n+    Panic(PanicInfo<u64>),\n }\n \n-impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n+// The errors become `MachineStop` with plain strings when being raised.\n+// `ConstEvalErr` (in `librustc/mir/interpret/error.rs`) knows to\n+// handle these.\n+impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalErrKind {\n     fn into(self) -> InterpErrorInfo<'tcx> {\n-        err_unsup!(Unsupported(self.to_string())).into()\n+        InterpError::MachineStop(Box::new(self.to_string())).into()\n     }\n }\n \n-impl fmt::Display for ConstEvalError {\n+impl fmt::Display for ConstEvalErrKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use self::ConstEvalError::*;\n+        use self::ConstEvalErrKind::*;\n         match *self {\n             NeedsRfc(ref msg) => {\n                 write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n             }\n             ConstAccessesStatic => write!(f, \"constant accesses static\"),\n+            Panic(ref msg) => write!(f, \"{:?}\", msg),\n         }\n     }\n }\n \n-impl Error for ConstEvalError {}\n+impl Error for ConstEvalErrKind {}\n \n /// Turn an interpreter error into something to report to the user.\n /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace."}, {"sha": "688eee05ddae7c825d5a8a665b78a62b3214b1e4", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=0633a0e3801e4efc9ab07bf811e442bd379ce93a", "patch": "@@ -9,10 +9,11 @@ use std::hash::Hash;\n use rustc_data_structures::fx::FxHashMap;\n \n use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n \n use crate::interpret::{\n     self, snapshot, AllocId, Allocation, AssertMessage, GlobalId, ImmTy, InterpCx, InterpResult,\n-    Memory, MemoryKind, OpTy, PlaceTy, Pointer, Scalar,\n+    Memory, MemoryKind, OpTy, PanicInfo, PlaceTy, Pointer, Scalar,\n };\n \n use super::error::*;\n@@ -56,6 +57,32 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n         self.dump_place(*dest);\n         return Ok(true);\n     }\n+\n+    /// \"Intercept\" a function call to a panic-related function\n+    /// because we have something special to do for it.\n+    /// Returns `true` if an intercept happened.\n+    pub fn hook_panic_fn(\n+        &mut self,\n+        span: Span,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+    ) -> InterpResult<'tcx, bool> {\n+        let def_id = instance.def_id();\n+        if Some(def_id) == self.tcx.lang_items().panic_fn()\n+            || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+        {\n+            // &'static str\n+            assert!(args.len() == 1);\n+\n+            let msg_place = self.deref_operand(args[0])?;\n+            let msg = Symbol::intern(self.read_str(msg_place)?);\n+            let span = self.find_closest_untracked_caller_location().unwrap_or(span);\n+            let (file, line, col) = self.location_triple_for_span(span);\n+            Err(ConstEvalErrKind::Panic(PanicInfo::Panic { msg, file, line, col }).into())\n+        } else {\n+            Ok(false)\n+        }\n+    }\n }\n \n /// Number of steps until the detector even starts doing anything.\n@@ -212,7 +239,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             Ok(body) => *body,\n             Err(err) => {\n                 if let err_unsup!(NoMirFor(ref path)) = err.kind {\n-                    return Err(ConstEvalError::NeedsRfc(format!(\n+                    return Err(ConstEvalErrKind::NeedsRfc(format!(\n                         \"calling extern function `{}`\",\n                         path\n                     ))\n@@ -246,7 +273,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         }\n         // An intrinsic that we do not support\n         let intrinsic_name = ecx.tcx.item_name(instance.def_id());\n-        Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into())\n+        Err(ConstEvalErrKind::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into())\n     }\n \n     fn assert_panic(\n@@ -256,7 +283,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         use rustc::mir::interpret::PanicInfo::*;\n-        Err(match msg {\n+        // Convert `PanicInfo<Operand>` to `PanicInfo<u64>`.\n+        let err = match msg {\n             BoundsCheck { ref len, ref index } => {\n                 let len = ecx\n                     .read_immediate(ecx.eval_operand(len, None)?)\n@@ -268,21 +296,21 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     .expect(\"can't eval index\")\n                     .to_scalar()?\n                     .to_machine_usize(&*ecx)?;\n-                err_panic!(BoundsCheck { len, index })\n+                BoundsCheck { len, index }\n             }\n-            Overflow(op) => err_panic!(Overflow(*op)),\n-            OverflowNeg => err_panic!(OverflowNeg),\n-            DivisionByZero => err_panic!(DivisionByZero),\n-            RemainderByZero => err_panic!(RemainderByZero),\n-            ResumedAfterReturn(generator_kind) => err_panic!(ResumedAfterReturn(*generator_kind)),\n-            ResumedAfterPanic(generator_kind) => err_panic!(ResumedAfterPanic(*generator_kind)),\n+            Overflow(op) => Overflow(*op),\n+            OverflowNeg => OverflowNeg,\n+            DivisionByZero => DivisionByZero,\n+            RemainderByZero => RemainderByZero,\n+            ResumedAfterReturn(generator_kind) => ResumedAfterReturn(*generator_kind),\n+            ResumedAfterPanic(generator_kind) => ResumedAfterPanic(*generator_kind),\n             Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n-        }\n-        .into())\n+        };\n+        Err(ConstEvalErrKind::Panic(err).into())\n     }\n \n     fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n-        Err(ConstEvalError::NeedsRfc(\"pointer-to-integer cast\".to_string()).into())\n+        Err(ConstEvalErrKind::NeedsRfc(\"pointer-to-integer cast\".to_string()).into())\n     }\n \n     fn binary_ptr_op(\n@@ -291,7 +319,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        Err(ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n+        Err(ConstEvalErrKind::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n     }\n \n     fn find_foreign_static(\n@@ -321,7 +349,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        Err(ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n+        Err(ConstEvalErrKind::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n     }\n \n     fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n@@ -355,7 +383,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         if memory_extra.can_access_statics {\n             Ok(())\n         } else {\n-            Err(ConstEvalError::ConstAccessesStatic.into())\n+            Err(ConstEvalErrKind::ConstAccessesStatic.into())\n         }\n     }\n }"}, {"sha": "a83b541279061fca017ea96fa5d6975079bd23a0", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=0633a0e3801e4efc9ab07bf811e442bd379ce93a", "patch": "@@ -376,32 +376,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(true)\n     }\n \n-    /// \"Intercept\" a function call to a panic-related function\n-    /// because we have something special to do for it.\n-    /// Returns `true` if an intercept happened.\n-    pub fn hook_panic_fn(\n-        &mut self,\n-        span: Span,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, M::PointerTag>],\n-    ) -> InterpResult<'tcx, bool> {\n-        let def_id = instance.def_id();\n-        if Some(def_id) == self.tcx.lang_items().panic_fn()\n-            || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n-        {\n-            // &'static str\n-            assert!(args.len() == 1);\n-\n-            let msg_place = self.deref_operand(args[0])?;\n-            let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let span = self.find_closest_untracked_caller_location().unwrap_or(span);\n-            let (file, line, col) = self.location_triple_for_span(span);\n-            throw_panic!(Panic { msg, file, line, col })\n-        } else {\n-            return Ok(false);\n-        }\n-    }\n-\n     pub fn exact_div(\n         &mut self,\n         a: ImmTy<'tcx, M::PointerTag>,"}, {"sha": "566601f0cae28b67d588a745f3d89460948ff3b8", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=0633a0e3801e4efc9ab07bf811e442bd379ce93a", "patch": "@@ -54,12 +54,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         location\n     }\n \n-    pub fn alloc_caller_location_for_span(&mut self, span: Span) -> MPlaceTy<'tcx, M::PointerTag> {\n-        let (file, line, column) = self.location_triple_for_span(span);\n-        self.alloc_caller_location(file, line, column)\n-    }\n-\n-    pub(super) fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n+    crate fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         (\n@@ -68,4 +63,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             caller.col_display as u32 + 1,\n         )\n     }\n+\n+    pub fn alloc_caller_location_for_span(&mut self, span: Span) -> MPlaceTy<'tcx, M::PointerTag> {\n+        let (file, line, column) = self.location_triple_for_span(span);\n+        self.alloc_caller_location(file, line, column)\n+    }\n }"}, {"sha": "43a6382646f3f9183a0e147d679a43cd7f3d3c0a", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0633a0e3801e4efc9ab07bf811e442bd379ce93a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=0633a0e3801e4efc9ab07bf811e442bd379ce93a", "patch": "@@ -4,7 +4,7 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n \n-use rustc::mir::interpret::{InterpResult, PanicInfo, Scalar};\n+use rustc::mir::interpret::{InterpError, InterpResult, PanicInfo, Scalar};\n use rustc::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n@@ -25,7 +25,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use syntax::ast::Mutability;\n \n use crate::const_eval::error_to_const_error;\n@@ -410,15 +410,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn use_ecx<F, T>(&mut self, source_info: SourceInfo, f: F) -> Option<T>\n+    fn use_ecx<F, T>(&mut self, f: F) -> Option<T>\n     where\n         F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n     {\n-        self.ecx.tcx.span = source_info.span;\n-        // FIXME(eddyb) move this to the `Panic(_)` error case, so that\n-        // `f(self)` is always called, and that the only difference when the\n-        // scope's `local_data` is missing, is that the lint isn't emitted.\n-        let lint_root = self.lint_root(source_info)?;\n         let r = match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n@@ -447,20 +442,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     | ResourceExhaustion(_) => {\n                         // Ignore these errors.\n                     }\n-                    Panic(_) => {\n-                        let diagnostic = error_to_const_error(&self.ecx, error);\n-                        diagnostic.report_as_lint(\n-                            self.ecx.tcx,\n-                            \"this expression will panic at runtime\",\n-                            lint_root,\n-                            None,\n-                        );\n-                    }\n                 }\n                 None\n             }\n         };\n-        self.ecx.tcx.span = DUMMY_SP;\n         r\n     }\n \n@@ -504,37 +489,47 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_place(&mut self, place: &Place<'tcx>) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        self.use_ecx(source_info, |this| this.ecx.eval_place_to_op(place, None))\n+        self.use_ecx(|this| this.ecx.eval_place_to_op(place, None))\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         match *op {\n             Operand::Constant(ref c) => self.eval_constant(c, source_info),\n-            Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                self.eval_place(place, source_info)\n-            }\n+            Operand::Move(ref place) | Operand::Copy(ref place) => self.eval_place(place),\n         }\n     }\n \n+    fn report_panic_as_lint(&self, source_info: SourceInfo, panic: PanicInfo<u64>) -> Option<()> {\n+        // Somewhat convoluted way to re-use the CTFE error reporting code.\n+        let lint_root = self.lint_root(source_info)?;\n+        let error = InterpError::MachineStop(Box::new(format!(\"{:?}\", panic)));\n+        let mut diagnostic = error_to_const_error(&self.ecx, error.into());\n+        diagnostic.span = source_info.span; // fix the span\n+        diagnostic.report_as_lint(\n+            self.tcx.at(source_info.span),\n+            \"this expression will panic at runtime\",\n+            lint_root,\n+            None,\n+        );\n+        None\n+    }\n+\n     fn check_unary_op(\n         &mut self,\n         op: UnOp,\n         arg: &Operand<'tcx>,\n         source_info: SourceInfo,\n     ) -> Option<()> {\n-        self.use_ecx(source_info, |this| {\n+        if self.use_ecx(|this| {\n             let val = this.ecx.read_immediate(this.ecx.eval_operand(arg, None)?)?;\n             let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, val)?;\n-\n-            if overflow {\n-                assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n-                throw_panic!(OverflowNeg);\n-            }\n-\n-            Ok(())\n-        })?;\n+            Ok(overflow)\n+        })? {\n+            assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n+            self.report_panic_as_lint(source_info, PanicInfo::OverflowNeg)?;\n+        }\n \n         Some(())\n     }\n@@ -548,9 +543,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         place_layout: TyLayout<'tcx>,\n         overflow_check: bool,\n     ) -> Option<()> {\n-        let r = self.use_ecx(source_info, |this| {\n-            this.ecx.read_immediate(this.ecx.eval_operand(right, None)?)\n-        })?;\n+        let r =\n+            self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(right, None)?))?;\n         if op == BinOp::Shr || op == BinOp::Shl {\n             let left_bits = place_layout.size.bits();\n             let right_size = r.layout.size;\n@@ -575,16 +569,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         // in MIR. However, if overflow checking is disabled, then there won't be any\n         // `Assert` statement and so we have to do additional checking here.\n         if !overflow_check {\n-            self.use_ecx(source_info, |this| {\n+            if self.use_ecx(|this| {\n                 let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n                 let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n-\n-                if overflow {\n-                    throw_panic!(Overflow(op));\n-                }\n-\n-                Ok(())\n-            })?;\n+                Ok(overflow)\n+            })? {\n+                self.report_panic_as_lint(source_info, PanicInfo::Overflow(op))?;\n+            }\n         }\n \n         Some(())\n@@ -642,7 +633,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             _ => {}\n         }\n \n-        self.use_ecx(source_info, |this| {\n+        self.use_ecx(|this| {\n             trace!(\"calling eval_rvalue_into_place(rvalue = {:?}, place = {:?})\", rvalue, place);\n             this.ecx.eval_rvalue_into_place(rvalue, place)?;\n             Ok(())\n@@ -675,7 +666,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         // FIXME> figure out what tho do when try_read_immediate fails\n-        let imm = self.use_ecx(source_info, |this| this.ecx.try_read_immediate(value));\n+        let imm = self.use_ecx(|this| this.ecx.try_read_immediate(value));\n \n         if let Some(Ok(imm)) = imm {\n             match *imm {\n@@ -698,7 +689,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     if let ty::Tuple(substs) = ty {\n                         // Only do it if tuple is also a pair with two scalars\n                         if substs.len() == 2 {\n-                            let opt_ty1_ty2 = self.use_ecx(source_info, |this| {\n+                            let opt_ty1_ty2 = self.use_ecx(|this| {\n                                 let ty1 = substs[0].expect_ty();\n                                 let ty2 = substs[1].expect_ty();\n                                 let ty_is_scalar = |ty| {"}]}