{"sha": "e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "node_id": "C_kwDOAAsO6NoAKGU3Y2MzYmRkYmUwZDBlMzc0ZDA1ZTcwMDNlNjYyYmJhMTc0MmRiYWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-07T23:40:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-07T23:40:26Z"}, "message": "Auto merge of #92007 - oli-obk:lazy_tait2, r=nikomatsakis\n\nLazy type-alias-impl-trait\n\nPreviously opaque types were processed by\n\n1. replacing all mentions of them with inference variables\n2. memorizing these inference variables in a side-table\n3. at the end of typeck, resolve the inference variables in the side table and use the resolved type as the hidden type of the opaque type\n\nThis worked okayish for `impl Trait` in return position, but required lots of roundabout type inference hacks and processing.\n\nThis PR instead stops this process of replacing opaque types with inference variables, and just keeps the opaque types around.\nWhenever an opaque type `O` is compared with another type `T`, we make the comparison succeed and record `T` as the hidden type. If `O` is compared to `U` while there is a recorded hidden type for it, we grab the recorded type (`T`) and compare that against `U`. This makes implementing\n\n* https://github.com/rust-lang/rfcs/pull/2515\n\nmuch simpler (previous attempts on the inference based scheme were very prone to ICEs and general misbehaviour that was not explainable except by random implementation defined oddities).\n\nr? `@nikomatsakis`\n\nfixes #93411\nfixes #88236", "tree": {"sha": "d16a23be9742a18b24810187154e6a9909ef9952", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d16a23be9742a18b24810187154e6a9909ef9952"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "html_url": "https://github.com/rust-lang/rust/commit/e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "734368a200904ef9c21db86c595dc04263c87be0", "url": "https://api.github.com/repos/rust-lang/rust/commits/734368a200904ef9c21db86c595dc04263c87be0", "html_url": "https://github.com/rust-lang/rust/commit/734368a200904ef9c21db86c595dc04263c87be0"}, {"sha": "9822fff2ea892fed6da7d219c945c0b30de3c7a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9822fff2ea892fed6da7d219c945c0b30de3c7a3", "html_url": "https://github.com/rust-lang/rust/commit/9822fff2ea892fed6da7d219c945c0b30de3c7a3"}], "stats": {"total": 5748, "additions": 3306, "deletions": 2442}, "files": [{"sha": "c318386f33b1333883ae3629ffa8a20e19e3d539", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -124,8 +124,9 @@ fn mir_borrowck<'tcx>(\n ) -> &'tcx BorrowCheckResult<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n+    let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n-    let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(def.did).enter(|infcx| {\n+    let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(hir_owner).enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n         do_mir_borrowck(&infcx, input_body, promoted, false).0\n@@ -140,7 +141,7 @@ fn mir_borrowck<'tcx>(\n /// If `return_body_with_facts` is true, then return the body with non-erased\n /// region ids on which the borrow checking was performed together with Polonius\n /// facts.\n-#[instrument(skip(infcx, input_body, input_promoted), level = \"debug\")]\n+#[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.with_opt_param().as_local().unwrap()), level = \"debug\")]\n fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,"}, {"sha": "f24d88163992008e44136ff2c56dd7400f3bc9f1", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,7 +1,6 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::OpaqueTyOrigin;\n-use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable};\n@@ -54,27 +53,44 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>,\n+        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (Ty<'tcx>, Span, OpaqueTyOrigin)>,\n         span: Span,\n     ) -> VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>> {\n         opaque_ty_decls\n             .into_iter()\n-            .filter_map(|(opaque_type_key, decl)| {\n+            .map(|(opaque_type_key, (concrete_type, decl_span, origin))| {\n                 let substs = opaque_type_key.substs;\n-                let concrete_type = decl.concrete_ty;\n+                // FIXME: why are the spans in decl_span often DUMMY_SP?\n+                let span = decl_span.substitute_dummy(span);\n                 debug!(?concrete_type, ?substs);\n \n                 let mut subst_regions = vec![self.universal_regions.fr_static];\n                 let universal_substs = infcx.tcx.fold_regions(substs, &mut false, |region, _| {\n-                    let vid = self.universal_regions.to_region_vid(region);\n-                    subst_regions.push(vid);\n-                    self.definitions[vid].external_name.unwrap_or_else(|| {\n-                        infcx\n-                            .tcx\n-                            .sess\n-                            .delay_span_bug(span, \"opaque type with non-universal region substs\");\n-                        infcx.tcx.lifetimes.re_static\n-                    })\n+                    if let ty::RePlaceholder(..) = region {\n+                        // Higher kinded regions don't need remapping, they don't refer to anything outside of this the substs.\n+                        return region;\n+                    }\n+                    let vid = self.to_region_vid(region);\n+                    trace!(?vid);\n+                    let scc = self.constraint_sccs.scc(vid);\n+                    trace!(?scc);\n+                    match self.scc_values.universal_regions_outlived_by(scc).find_map(|lb| {\n+                        self.eval_equal(vid, lb).then_some(self.definitions[lb].external_name?)\n+                    }) {\n+                        Some(region) => {\n+                            let vid = self.universal_regions.to_region_vid(region);\n+                            subst_regions.push(vid);\n+                            region\n+                        }\n+                        None => {\n+                            subst_regions.push(vid);\n+                            infcx.tcx.sess.delay_span_bug(\n+                                span,\n+                                \"opaque type with non-universal region substs\",\n+                            );\n+                            infcx.tcx.lifetimes.re_static\n+                        }\n+                    }\n                 });\n \n                 subst_regions.sort();\n@@ -100,12 +116,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     span,\n                 );\n \n-                check_opaque_type_parameter_valid(\n-                    infcx.tcx,\n+                (\n                     opaque_type_key,\n-                    OpaqueTypeDecl { concrete_ty: remapped_type, ..decl },\n+                    if check_opaque_type_parameter_valid(infcx.tcx, opaque_type_key, origin, span) {\n+                        remapped_type\n+                    } else {\n+                        infcx.tcx.ty_error()\n+                    },\n                 )\n-                .then_some((opaque_type_key, remapped_type))\n             })\n             .collect()\n     }\n@@ -149,9 +167,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n fn check_opaque_type_parameter_valid(\n     tcx: TyCtxt<'_>,\n     opaque_type_key: OpaqueTypeKey<'_>,\n-    decl: OpaqueTypeDecl<'_>,\n+    origin: OpaqueTyOrigin,\n+    span: Span,\n ) -> bool {\n-    match decl.origin {\n+    match origin {\n         // No need to check return position impl trait (RPIT)\n         // because for type and const parameters they are correct\n         // by construction: we convert\n@@ -177,7 +196,6 @@ fn check_opaque_type_parameter_valid(\n         // Check these\n         OpaqueTyOrigin::TyAlias => {}\n     }\n-    let span = decl.definition_span;\n     let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n     let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n     for (i, arg) in opaque_type_key.substs.iter().enumerate() {"}, {"sha": "83c8ecba1f17aa78d86d2af0a8a8c76dbc69bf06", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -147,9 +147,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // Return types are a bit more complex. They may contain opaque `impl Trait` types.\n         let mir_output_ty = body.local_decls[RETURN_PLACE].ty;\n         let output_span = body.local_decls[RETURN_PLACE].source_info.span;\n-        if let Err(terr) = self.eq_opaque_type_and_type(\n-            mir_output_ty,\n+        if let Err(terr) = self.eq_types(\n             normalized_output_ty,\n+            mir_output_ty,\n             Locations::All(output_span),\n             ConstraintCategory::BoringNoLocation,\n         ) {\n@@ -169,9 +169,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             let user_provided_output_ty = user_provided_sig.output();\n             let user_provided_output_ty =\n                 self.normalize(user_provided_output_ty, Locations::All(output_span));\n-            if let Err(err) = self.eq_opaque_type_and_type(\n-                mir_output_ty,\n+            if let Err(err) = self.eq_types(\n                 user_provided_output_ty,\n+                mir_output_ty,\n                 Locations::All(output_span),\n                 ConstraintCategory::BoringNoLocation,\n             ) {"}, {"sha": "4647610b0033da4906f9b1686c66ab6ca58ddf70", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 48, "deletions": 201, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -5,6 +5,7 @@ use std::{fmt, iter, mem};\n \n use either::Either;\n \n+use hir::OpaqueTyOrigin;\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::vec_map::VecMap;\n@@ -15,7 +16,6 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n-use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n@@ -41,7 +41,7 @@ use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n use rustc_trait_selection::traits::query::Fallible;\n-use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations};\n+use rustc_trait_selection::traits::{self, ObligationCause};\n \n use rustc_const_eval::transform::{\n     check_consts::ConstCx, promote_consts::is_const_fn_in_array_repeat_expression,\n@@ -75,7 +75,7 @@ macro_rules! span_mirbug {\n             $context.last_span,\n             &format!(\n                 \"broken MIR in {:?} ({:?}): {}\",\n-                $context.body.source.def_id(),\n+                $context.body().source.def_id(),\n                 $elem,\n                 format_args!($($message)*),\n             ),\n@@ -190,59 +190,44 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             liveness::generate(&mut cx, body, elements, flow_inits, move_data, location_table);\n \n             translate_outlives_facts(&mut cx);\n-            let opaque_type_values = mem::take(&mut infcx.inner.borrow_mut().opaque_types);\n+            let opaque_type_values =\n+                infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n             opaque_type_values\n                 .into_iter()\n-                .filter_map(|(opaque_type_key, mut decl)| {\n-                    decl.concrete_ty = infcx.resolve_vars_if_possible(decl.concrete_ty);\n+                .map(|(opaque_type_key, decl)| {\n+                    cx.fully_perform_op(\n+                        Locations::All(body.span),\n+                        ConstraintCategory::OpaqueType,\n+                        CustomTypeOp::new(\n+                            |infcx| {\n+                                infcx.register_member_constraints(\n+                                    param_env,\n+                                    opaque_type_key,\n+                                    decl.hidden_type.ty,\n+                                    decl.hidden_type.span,\n+                                );\n+                                Ok(InferOk { value: (), obligations: vec![] })\n+                            },\n+                            || \"opaque_type_map\".to_string(),\n+                        ),\n+                    )\n+                    .unwrap();\n+                    let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type.ty);\n                     trace!(\n                         \"finalized opaque type {:?} to {:#?}\",\n                         opaque_type_key,\n-                        decl.concrete_ty.kind()\n+                        hidden_type.kind()\n                     );\n-                    if decl.concrete_ty.has_infer_types_or_consts() {\n+                    if hidden_type.has_infer_types_or_consts() {\n                         infcx.tcx.sess.delay_span_bug(\n-                            body.span,\n-                            &format!(\"could not resolve {:#?}\", decl.concrete_ty.kind()),\n+                            decl.hidden_type.span,\n+                            &format!(\"could not resolve {:#?}\", hidden_type.kind()),\n                         );\n-                        decl.concrete_ty = infcx.tcx.ty_error();\n+                        hidden_type = infcx.tcx.ty_error();\n                     }\n-                    let concrete_is_opaque = if let ty::Opaque(def_id, _) = decl.concrete_ty.kind()\n-                    {\n-                        *def_id == opaque_type_key.def_id\n-                    } else {\n-                        false\n-                    };\n \n-                    if concrete_is_opaque {\n-                        // We're using an opaque `impl Trait` type without\n-                        // 'revealing' it. For example, code like this:\n-                        //\n-                        // type Foo = impl Debug;\n-                        // fn foo1() -> Foo { ... }\n-                        // fn foo2() -> Foo { foo1() }\n-                        //\n-                        // In `foo2`, we're not revealing the type of `Foo` - we're\n-                        // just treating it as the opaque type.\n-                        //\n-                        // When this occurs, we do *not* want to try to equate\n-                        // the concrete type with the underlying defining type\n-                        // of the opaque type - this will always fail, since\n-                        // the defining type of an opaque type is always\n-                        // some other type (e.g. not itself)\n-                        // Essentially, none of the normal obligations apply here -\n-                        // we're just passing around some unknown opaque type,\n-                        // without actually looking at the underlying type it\n-                        // gets 'revealed' into\n-                        debug!(\n-                            \"eq_opaque_type_and_type: non-defining use of {:?}\",\n-                            opaque_type_key.def_id,\n-                        );\n-                        None\n-                    } else {\n-                        Some((opaque_type_key, decl))\n-                    }\n+                    (opaque_type_key, (hidden_type, decl.hidden_type.span, decl.origin))\n                 })\n                 .collect()\n         },\n@@ -274,7 +259,7 @@ fn type_check_internal<'a, 'tcx, R>(\n         borrowck_context,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, body, promoted);\n+        let mut verifier = TypeVerifier::new(&mut checker, promoted);\n         verifier.visit_body(&body);\n         verifier.errors_reported\n     };\n@@ -331,7 +316,6 @@ enum FieldAccessError {\n /// is a problem.\n struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n-    body: &'b Body<'tcx>,\n     promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     last_span: Span,\n     errors_reported: bool,\n@@ -467,7 +451,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_rvalue(rvalue, location);\n-        let rval_ty = rvalue.ty(self.body, self.tcx());\n+        let rval_ty = rvalue.ty(self.body(), self.tcx());\n         self.sanitize_type(rvalue, rval_ty);\n     }\n \n@@ -526,10 +510,13 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     fn new(\n         cx: &'a mut TypeChecker<'b, 'tcx>,\n-        body: &'b Body<'tcx>,\n         promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     ) -> Self {\n-        TypeVerifier { body, promoted, cx, last_span: body.span, errors_reported: false }\n+        TypeVerifier { promoted, last_span: cx.body.span, cx, errors_reported: false }\n+    }\n+\n+    fn body(&self) -> &Body<'tcx> {\n+        self.cx.body\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -554,7 +541,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n \n-        let mut place_ty = PlaceTy::from_ty(self.body.local_decls[place.local].ty);\n+        let mut place_ty = PlaceTy::from_ty(self.body().local_decls[place.local].ty);\n \n         for elem in place.projection.iter() {\n             if place_ty.variant_index.is_none() {\n@@ -599,7 +586,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location.\n \n-        let parent_body = mem::replace(&mut self.body, promoted_body);\n+        let parent_body = mem::replace(&mut self.cx.body, promoted_body);\n \n         // Use new sets of constraints and closure bounds so that we can\n         // modify their locations.\n@@ -635,7 +622,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             self.cx.typeck_mir(promoted_body);\n         }\n \n-        self.body = parent_body;\n+        self.cx.body = parent_body;\n         // Merge the outlives constraints back in, at the given location.\n         swap_constraints(self);\n \n@@ -697,7 +684,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }))\n             }\n             ProjectionElem::Index(i) => {\n-                let index_ty = Place::from(i).ty(self.body, tcx).ty;\n+                let index_ty = Place::from(i).ty(self.body(), tcx).ty;\n                 if index_ty != tcx.types.usize {\n                     PlaceTy::from_ty(span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i))\n                 } else {\n@@ -906,7 +893,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     crate universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>,\n+    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, (Ty<'tcx>, Span, OpaqueTyOrigin)>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -1056,17 +1043,19 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         checker\n     }\n \n+    fn body(&self) -> &Body<'tcx> {\n+        self.body\n+    }\n+\n     fn unsized_feature_enabled(&self) -> bool {\n         let features = self.tcx().features();\n         features.unsized_locals || features.unsized_fn_params\n     }\n \n     /// Equate the inferred type and the annotated type for user type annotations\n+    #[instrument(skip(self), level = \"debug\")]\n     fn check_user_type_annotations(&mut self) {\n-        debug!(\n-            \"check_user_type_annotations: user_type_annotations={:?}\",\n-            self.user_type_annotations\n-        );\n+        debug!(?self.user_type_annotations);\n         for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n             let inferred_ty = self.normalize(inferred_ty, Locations::All(span));\n@@ -1207,131 +1196,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         Ok(())\n     }\n \n-    /// Equates a type `anon_ty` that may contain opaque types whose\n-    /// values are to be inferred by the MIR.\n-    ///\n-    /// The type `revealed_ty` contains the same type as `anon_ty`, but with the\n-    /// hidden types for impl traits revealed.\n-    ///\n-    /// # Example\n-    ///\n-    /// Consider a piece of code like\n-    ///\n-    /// ```rust\n-    /// type Foo<U> = impl Debug;\n-    ///\n-    /// fn foo<T: Debug>(t: T) -> Box<Foo<T>> {\n-    ///      Box::new((t, 22_u32))\n-    /// }\n-    /// ```\n-    ///\n-    /// Here, the function signature would be something like\n-    /// `fn(T) -> Box<impl Debug>`. The MIR return slot would have\n-    /// the type with the opaque type revealed, so `Box<(T, u32)>`.\n-    ///\n-    /// In terms of our function parameters:\n-    ///\n-    /// * `anon_ty` would be `Box<Foo<T>>` where `Foo<T>` is an opaque type\n-    ///   scoped to this function (note that it is parameterized by the\n-    ///   generics of `foo`). Note that `anon_ty` is not just the opaque type,\n-    ///   but the entire return type (which may contain opaque types within it).\n-    /// * `revealed_ty` would be `Box<(T, u32)>`\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn eq_opaque_type_and_type(\n-        &mut self,\n-        revealed_ty: Ty<'tcx>,\n-        anon_ty: Ty<'tcx>,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-    ) -> Fallible<()> {\n-        // Fast path for the common case.\n-        if !anon_ty.has_opaque_types() {\n-            if let Err(terr) = self.eq_types(anon_ty, revealed_ty, locations, category) {\n-                span_mirbug!(\n-                    self,\n-                    locations,\n-                    \"eq_opaque_type_and_type: `{:?}=={:?}` failed with `{:?}`\",\n-                    revealed_ty,\n-                    anon_ty,\n-                    terr\n-                );\n-            }\n-            return Ok(());\n-        }\n-\n-        let param_env = self.param_env;\n-        let body = self.body;\n-        let mir_def_id = body.source.def_id().expect_local();\n-\n-        debug!(?mir_def_id);\n-        self.fully_perform_op(\n-            locations,\n-            category,\n-            CustomTypeOp::new(\n-                |infcx| {\n-                    let mut obligations = ObligationAccumulator::default();\n-\n-                    let dummy_body_id = hir::CRATE_HIR_ID;\n-\n-                    // Replace the opaque types defined by this function with\n-                    // inference variables, creating a map. In our example above,\n-                    // this would transform the type `Box<Foo<T>>` (where `Foo` is an opaque type)\n-                    // to `Box<?T>`, returning an `opaque_type_map` mapping `{Foo<T> -> ?T}`.\n-                    // (Note that the key of the map is both the def-id of `Foo` along with\n-                    // any generic parameters.)\n-                    let output_ty = obligations.add(infcx.instantiate_opaque_types(\n-                        dummy_body_id,\n-                        param_env,\n-                        anon_ty,\n-                        locations.span(body),\n-                    ));\n-                    debug!(?output_ty, ?revealed_ty);\n-\n-                    // Make sure that the inferred types are well-formed. I'm\n-                    // not entirely sure this is needed (the HIR type check\n-                    // didn't do this) but it seems sensible to prevent opaque\n-                    // types hiding ill-formed types.\n-                    obligations.obligations.push(traits::Obligation::new(\n-                        ObligationCause::dummy(),\n-                        param_env,\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(revealed_ty.into()))\n-                            .to_predicate(infcx.tcx),\n-                    ));\n-                    obligations.add(\n-                        infcx\n-                            .at(&ObligationCause::dummy(), param_env)\n-                            .eq(output_ty, revealed_ty)?,\n-                    );\n-\n-                    debug!(\"equated\");\n-\n-                    Ok(InferOk { value: (), obligations: obligations.into_vec() })\n-                },\n-                || \"input_output\".to_string(),\n-            ),\n-        )?;\n-\n-        // Finally, if we instantiated the anon types successfully, we\n-        // have to solve any bounds (e.g., `-> impl Iterator` needs to\n-        // prove that `T: Iterator` where `T` is the type we\n-        // instantiated it with).\n-        let opaque_type_map = self.infcx.inner.borrow().opaque_types.clone();\n-        for (opaque_type_key, opaque_decl) in opaque_type_map {\n-            self.fully_perform_op(\n-                locations,\n-                ConstraintCategory::OpaqueType,\n-                CustomTypeOp::new(\n-                    |infcx| {\n-                        infcx.constrain_opaque_type(opaque_type_key, &opaque_decl);\n-                        Ok(InferOk { value: (), obligations: vec![] })\n-                    },\n-                    || \"opaque_type_map\".to_string(),\n-                ),\n-            )?;\n-        }\n-        Ok(())\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -2773,20 +2637,3 @@ impl NormalizeLocation for Location {\n         Locations::Single(self)\n     }\n }\n-\n-#[derive(Debug, Default)]\n-struct ObligationAccumulator<'tcx> {\n-    obligations: PredicateObligations<'tcx>,\n-}\n-\n-impl<'tcx> ObligationAccumulator<'tcx> {\n-    fn add<T>(&mut self, value: InferOk<'tcx, T>) -> T {\n-        let InferOk { value, obligations } = value;\n-        self.obligations.extend(obligations);\n-        value\n-    }\n-\n-    fn into_vec(self) -> PredicateObligations<'tcx> {\n-        self.obligations\n-    }\n-}"}, {"sha": "aba1dd2bc548cc65beb4899134124dd4e93e3152", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,13 +1,15 @@\n use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n-use rustc_infer::infer::NllRegionVariableOrigin;\n+use rustc_infer::infer::{InferOk, NllRegionVariableOrigin};\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Const, Ty};\n+use rustc_span::Span;\n use rustc_trait_selection::traits::query::Fallible;\n \n use crate::constraints::OutlivesConstraint;\n use crate::diagnostics::UniverseInfo;\n-use crate::type_check::{Locations, TypeChecker};\n+use crate::type_check::{CustomTypeOp, Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// Adds sufficient constraints to ensure that `a R b` where `R` depends on `v`:\n@@ -63,6 +65,10 @@ impl<'me, 'bccx, 'tcx> NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n }\n \n impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n+    fn span(&self) -> Span {\n+        self.locations.span(self.type_checker.body)\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.type_checker.param_env\n     }\n@@ -117,6 +123,9 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n \n     // We don't have to worry about the equality of consts during borrow checking\n     // as consts always have a static lifetime.\n+    // FIXME(oli-obk): is this really true? We can at least have HKL and with\n+    // inline consts we may have further lifetimes that may be unsound to treat as\n+    // 'static.\n     fn const_equate(&mut self, _a: &'tcx Const<'tcx>, _b: &'tcx Const<'tcx>) {}\n \n     fn normalization() -> NormalizationStrategy {\n@@ -126,4 +135,33 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n     fn forbid_inference_vars() -> bool {\n         true\n     }\n+\n+    fn register_opaque_type(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected: bool) {\n+        let param_env = self.param_env();\n+        let span = self.span();\n+        let def_id = self.type_checker.body.source.def_id().expect_local();\n+        let body_id = self.type_checker.tcx().hir().local_def_id_to_hir_id(def_id);\n+        let cause = ObligationCause::misc(span, body_id);\n+        self.type_checker\n+            .fully_perform_op(\n+                self.locations,\n+                self.category,\n+                CustomTypeOp::new(\n+                    |infcx| {\n+                        Ok(InferOk {\n+                            value: (),\n+                            obligations: vec![infcx.opaque_ty_obligation(\n+                                a,\n+                                b,\n+                                a_is_expected,\n+                                param_env,\n+                                cause,\n+                            )],\n+                        })\n+                    },\n+                    || \"register_opaque_type\".to_string(),\n+                ),\n+            )\n+            .unwrap();\n+    }\n }"}, {"sha": "a944b2d87ac6d42ff850c260099ea3b0815a104e", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -728,6 +728,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         self.tcx.fold_regions(value, &mut false, |_region, _depth| self.next_nll_region_var(origin))\n     }\n \n+    #[instrument(level = \"debug\", skip(self, indices))]\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NllRegionVariableOrigin,\n@@ -738,22 +739,15 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\n-            \"replace_bound_regions_with_nll_infer_vars(value={:?}, all_outlive_scope={:?})\",\n-            value, all_outlive_scope,\n-        );\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n-            debug!(\"replace_bound_regions_with_nll_infer_vars: br={:?}\", br);\n+            debug!(?br);\n             let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: all_outlive_scope.to_def_id(),\n                 bound_region: br.kind,\n             }));\n             let region_vid = self.next_nll_region_var(origin);\n             indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n-            debug!(\n-                \"replace_bound_regions_with_nll_infer_vars: liberated_region={:?} => {:?}\",\n-                liberated_region, region_vid\n-            );\n+            debug!(?liberated_region, ?region_vid);\n             region_vid\n         });\n         value\n@@ -768,6 +762,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// entries for them and store them in the indices map. This code iterates over the complete\n     /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n     /// inputs vector.\n+    #[instrument(skip(self, indices))]\n     fn replace_late_bound_regions_with_nll_infer_vars(\n         &self,\n         mir_def_id: LocalDefId,\n@@ -779,6 +774,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n             debug!(\"replace_late_bound_regions_with_nll_infer_vars: r={:?}\", r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = self.next_nll_region_var(FR);\n+                debug!(?region_vid);\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n         });"}, {"sha": "49a9b911f3a4b3894923ce206c50a14d7124ec8b", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty, TyCtxt};\n-use rustc_middle::ty::{Binder, TraitPredicate, TraitRef};\n+use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeFoldable};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n use rustc_trait_selection::traits::SelectionContext;\n@@ -46,7 +46,10 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n         location: Location,\n     ) -> bool {\n         let ty = ccx.body.local_decls[local].ty;\n-        if !NeedsDrop::in_any_value_of_ty(ccx, ty) {\n+        // Peeking into opaque types causes cycles if the current function declares said opaque\n+        // type. Thus we avoid short circuiting on the type and instead run the more expensive\n+        // analysis that looks at the actual usage within this function\n+        if !ty.has_opaque_types() && !NeedsDrop::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n@@ -100,7 +103,10 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n         location: Location,\n     ) -> bool {\n         let ty = ccx.body.local_decls[local].ty;\n-        if !HasMutInterior::in_any_value_of_ty(ccx, ty) {\n+        // Peeking into opaque types causes cycles if the current function declares said opaque\n+        // type. Thus we avoid short circuiting on the type and instead run the more expensive\n+        // analysis that looks at the actual usage within this function\n+        if !ty.has_opaque_types() && !HasMutInterior::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n@@ -148,7 +154,12 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n \n             // If we know that all values of the return type are structurally matchable, there's no\n             // need to run dataflow.\n-            _ if !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) => false,\n+            // Opaque types do not participate in const generics or pattern matching, so we can safely count them out.\n+            _ if ccx.body.return_ty().has_opaque_types()\n+                || !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) =>\n+            {\n+                false\n+            }\n \n             hir::ConstContext::Const | hir::ConstContext::Static(_) => {\n                 let mut cursor = FlowSensitiveAnalysis::new(CustomEq, ccx)\n@@ -395,6 +406,7 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n                     | ty::PredicateKind::Projection(_)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::OpaqueType(..)\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n                     ty::PredicateKind::ObjectSafe(_) => {\n                         bug!(\"object safe predicate on function: {:#?}\", predicate)"}, {"sha": "f8e5764878579ff780b285b6086f675cab48d1a0", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -79,7 +79,6 @@ pub fn equal_up_to_regions<'tcx>(\n     }\n \n     // Normalize lifetimes away on both sides, then compare.\n-    let param_env = param_env.with_reveal_all_normalized(tcx);\n     let normalize = |ty: Ty<'tcx>| {\n         tcx.normalize_erasing_regions(\n             param_env,\n@@ -171,9 +170,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             return true;\n         }\n         // Normalize projections and things like that.\n-        // FIXME: We need to reveal_all, as some optimizations change types in ways\n-        // that require unfolding opaque types.\n-        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n+        let param_env = self.param_env;\n         let src = self.tcx.normalize_erasing_regions(param_env, src);\n         let dest = self.tcx.normalize_erasing_regions(param_env, dest);\n "}, {"sha": "2f4b3844430e38afaf4ac523d09de47a10f59317", "filename": "compiler/rustc_data_structures/src/vec_map.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -30,6 +30,11 @@ where\n         }\n     }\n \n+    /// Removes the entry from the map and returns the removed value\n+    pub fn remove(&mut self, k: &K) -> Option<V> {\n+        self.0.iter().position(|(k2, _)| k2 == k).map(|pos| self.0.remove(pos).1)\n+    }\n+\n     /// Gets a reference to the value in the entry.\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n     where\n@@ -39,6 +44,15 @@ where\n         self.0.iter().find(|(key, _)| k == key.borrow()).map(|elem| &elem.1)\n     }\n \n+    /// Gets a mutable reference to the value in the entry.\n+    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Eq,\n+    {\n+        self.0.iter_mut().find(|(key, _)| k == key.borrow()).map(|elem| &mut elem.1)\n+    }\n+\n     /// Returns the any value corresponding to the supplied predicate filter.\n     ///\n     /// The supplied predicate will be applied to each (key, value) pair and it will return a\n@@ -58,7 +72,7 @@ where\n         // This should return just one element, otherwise it's a bug\n         assert!(\n             filter.next().is_none(),\n-            \"Collection {:?} should have just one matching element\",\n+            \"Collection {:#?} should have just one matching element\",\n             self\n         );\n         Some(value)"}, {"sha": "7a82b169c5720c5182a6e1ea5675c7873bcf178e", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -34,6 +34,12 @@ pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub cause: &'a ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n+    /// Whether we should define opaque types\n+    /// or just treat them opaquely.\n+    /// Currently only used to prevent predicate\n+    /// matching from matching anything against opaque\n+    /// types.\n+    pub define_opaque_types: bool,\n }\n \n pub struct Trace<'a, 'tcx> {\n@@ -49,7 +55,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> At<'a, 'tcx> {\n-        At { infcx: self, cause, param_env }\n+        At { infcx: self, cause, param_env, define_opaque_types: true }\n     }\n }\n \n@@ -64,6 +70,10 @@ pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n }\n \n impl<'a, 'tcx> At<'a, 'tcx> {\n+    pub fn define_opaque_types(self, define_opaque_types: bool) -> Self {\n+        Self { define_opaque_types, ..self }\n+    }\n+\n     /// Hacky routine for equating two impl headers in coherence.\n     pub fn eq_impl_headers(\n         self,\n@@ -194,7 +204,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .sub(a_is_expected)\n                 .relate(a, b)\n@@ -211,7 +221,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .equate(a_is_expected)\n                 .relate(a, b)\n@@ -226,7 +236,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .lub(a_is_expected)\n                 .relate(a, b)\n@@ -241,7 +251,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .glb(a_is_expected)\n                 .relate(a, b)"}, {"sha": "7d86f8a763c30349fb2b0d39261e142bb2b522d1", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 55, "deletions": 12, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -26,6 +26,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n+use rustc_span::Span;\n use std::fmt::Debug;\n use std::iter;\n \n@@ -89,6 +90,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             var_values: inference_vars,\n             region_constraints: QueryRegionConstraints::default(),\n             certainty: Certainty::Proven, // Ambiguities are OK!\n+            opaque_types: vec![],\n             value: answer,\n         })\n     }\n@@ -133,14 +135,27 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let certainty =\n             if ambig_errors.is_empty() { Certainty::Proven } else { Certainty::Ambiguous };\n \n+        let opaque_types = self.take_opaque_types_for_query_response();\n+\n         Ok(QueryResponse {\n             var_values: inference_vars,\n             region_constraints,\n             certainty,\n             value: answer,\n+            opaque_types,\n         })\n     }\n \n+    fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+        self.inner\n+            .borrow_mut()\n+            .opaque_type_storage\n+            .take_opaque_types()\n+            .into_iter()\n+            .map(|(k, v)| (self.tcx.mk_opaque(k.def_id, k.substs), v.hidden_type.ty))\n+            .collect()\n+    }\n+\n     /// Given the (canonicalized) result to a canonical query,\n     /// instantiates the result so it can be used, plugging in the\n     /// values from the canonical query. (Note that the result may\n@@ -223,13 +238,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n-        let result_subst =\n-            self.query_response_substitution_guess(cause, original_values, query_response);\n+        let InferOk { value: result_subst, mut obligations } = self\n+            .query_response_substitution_guess(cause, param_env, original_values, query_response)?;\n \n         // Compute `QueryOutlivesConstraint` values that unify each of\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n-        let mut obligations = vec![];\n \n         for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n@@ -344,20 +358,25 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             original_values, query_response,\n         );\n \n-        let result_subst =\n-            self.query_response_substitution_guess(cause, original_values, query_response);\n+        let mut value = self.query_response_substitution_guess(\n+            cause,\n+            param_env,\n+            original_values,\n+            query_response,\n+        )?;\n \n-        let obligations = self\n-            .unify_query_response_substitution_guess(\n+        value.obligations.extend(\n+            self.unify_query_response_substitution_guess(\n                 cause,\n                 param_env,\n                 original_values,\n-                &result_subst,\n+                &value.value,\n                 query_response,\n             )?\n-            .into_obligations();\n+            .into_obligations(),\n+        );\n \n-        Ok(InferOk { value: result_subst, obligations })\n+        Ok(value)\n     }\n \n     /// Given the original values and the (canonicalized) result from\n@@ -372,9 +391,10 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     fn query_response_substitution_guess<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         original_values: &OriginalQueryValues<'tcx>,\n         query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n-    ) -> CanonicalVarValues<'tcx>\n+    ) -> InferResult<'tcx, CanonicalVarValues<'tcx>>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n@@ -474,7 +494,16 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 .collect(),\n         };\n \n-        result_subst\n+        let mut obligations = vec![];\n+\n+        // Carry all newly resolved opaque types to the caller's scope\n+        for &(a, b) in &query_response.value.opaque_types {\n+            let a = substitute_value(self.tcx, &result_subst, a);\n+            let b = substitute_value(self.tcx, &result_subst, b);\n+            obligations.extend(self.handle_opaque_type(a, b, cause, param_env)?.obligations);\n+        }\n+\n+        Ok(InferOk { value: result_subst, obligations })\n     }\n \n     /// Given a \"guess\" at the values for the canonical variables in\n@@ -631,6 +660,10 @@ struct QueryTypeRelatingDelegate<'a, 'tcx> {\n }\n \n impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n+    fn span(&self) -> Span {\n+        self.cause.span\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -686,4 +719,14 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n     fn forbid_inference_vars() -> bool {\n         true\n     }\n+\n+    fn register_opaque_type(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected: bool) {\n+        self.obligations.push(self.infcx.opaque_ty_obligation(\n+            a,\n+            b,\n+            a_is_expected,\n+            self.param_env,\n+            self.cause.clone(),\n+        ));\n+    }\n }"}, {"sha": "5668b6c10b000e97f6ac8831addb98b258ba1866", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -51,6 +51,12 @@ pub struct CombineFields<'infcx, 'tcx> {\n     pub cause: Option<ty::relate::Cause>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub obligations: PredicateObligations<'tcx>,\n+    /// Whether we should define opaque types\n+    /// or just treat them opaquely.\n+    /// Currently only used to prevent predicate\n+    /// matching from matching anything against opaque\n+    /// types.\n+    pub define_opaque_types: bool,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -322,6 +328,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     /// will first instantiate `b_vid` with a *generalized* version\n     /// of `a_ty`. Generalization introduces other inference\n     /// variables wherever subtyping could occur.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn instantiate(\n         &mut self,\n         a_ty: Ty<'tcx>,\n@@ -334,8 +341,6 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // Get the actual variable that b_vid has been inferred to\n         debug_assert!(self.infcx.inner.borrow_mut().type_variables().probe(b_vid).is_unknown());\n \n-        debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n-\n         // Generalize type of `a_ty` appropriately depending on the\n         // direction.  As an example, assume:\n         //\n@@ -348,10 +353,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // variables. (Down below, we will relate `a_ty <: b_ty`,\n         // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n         let Generalization { ty: b_ty, needs_wf } = self.generalize(a_ty, b_vid, dir)?;\n-        debug!(\n-            \"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n-            a_ty, dir, b_vid, b_ty\n-        );\n+        debug!(?b_ty);\n         self.infcx.inner.borrow_mut().type_variables().instantiate(b_vid, b_ty);\n \n         if needs_wf {\n@@ -392,13 +394,13 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     /// Preconditions:\n     ///\n     /// - `for_vid` is a \"root vid\"\n+    #[instrument(skip(self), level = \"trace\")]\n     fn generalize(\n         &self,\n         ty: Ty<'tcx>,\n         for_vid: ty::TyVid,\n         dir: RelationDir,\n     ) -> RelateResult<'tcx, Generalization<'tcx>> {\n-        debug!(\"generalize(ty={:?}, for_vid={:?}, dir={:?}\", ty, for_vid, dir);\n         // Determine the ambient variance within which `ty` appears.\n         // The surrounding equation is:\n         //\n@@ -412,7 +414,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             RelationDir::SupertypeOf => ty::Contravariant,\n         };\n \n-        debug!(\"generalize: ambient_variance = {:?}\", ambient_variance);\n+        trace!(?ambient_variance);\n \n         let for_universe = match self.infcx.inner.borrow_mut().type_variables().probe(for_vid) {\n             v @ TypeVariableValue::Known { .. } => {\n@@ -421,8 +423,8 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             TypeVariableValue::Unknown { universe } => universe,\n         };\n \n-        debug!(\"generalize: for_universe = {:?}\", for_universe);\n-        debug!(\"generalize: trace = {:?}\", self.trace);\n+        trace!(?for_universe);\n+        trace!(?self.trace);\n \n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n@@ -439,12 +441,12 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         let ty = match generalize.relate(ty, ty) {\n             Ok(ty) => ty,\n             Err(e) => {\n-                debug!(\"generalize: failure {:?}\", e);\n+                debug!(?e, \"failure\");\n                 return Err(e);\n             }\n         };\n         let needs_wf = generalize.needs_wf;\n-        debug!(\"generalize: success {{ {:?}, {:?} }}\", ty, needs_wf);\n+        trace!(?ty, ?needs_wf, \"success\");\n         Ok(Generalization { ty, needs_wf })\n     }\n "}, {"sha": "9f6c6d3184533c2f9fe674f35cb51d49d32ee007", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -66,18 +66,19 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.relate(a, b)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n         if a == b {\n             return Ok(a);\n         }\n \n+        trace!(a = ?a.kind(), b = ?b.kind());\n+\n         let infcx = self.fields.infcx;\n+\n         let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n         let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n \n-        debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n-\n         match (a.kind(), b.kind()) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n                 infcx.inner.borrow_mut().type_variables().equate(a_id, b_id);\n@@ -91,6 +92,21 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n                 self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n             }\n \n+            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+                self.fields.infcx.super_combine_tys(self, a, b)?;\n+            }\n+            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n+                if self.fields.define_opaque_types && did.is_local() =>\n+            {\n+                self.fields.obligations.push(infcx.opaque_ty_obligation(\n+                    a,\n+                    b,\n+                    self.a_is_expected(),\n+                    self.param_env(),\n+                    self.fields.trace.cause.clone(),\n+                ));\n+            }\n+\n             _ => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n             }"}, {"sha": "c4c4eab261e86de313bfc901c565ed3fd4853477", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,7 +4,7 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, PredicateObligation};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -111,12 +111,20 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n         &self.fields.trace.cause\n     }\n \n+    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>) {\n+        self.fields.obligations.extend(obligations)\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(v, a)?;\n         sub.relate(v, b)?;\n         Ok(())\n     }\n+\n+    fn define_opaque_types(&self) -> bool {\n+        self.fields.define_opaque_types\n+    }\n }\n \n impl<'tcx> ConstEquateRelation<'tcx> for Glb<'_, '_, 'tcx> {"}, {"sha": "6bda44f0ef256cad3a40d4a5f22ff1d22d26f90a", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -22,7 +22,7 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::InferCtxt;\n \n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, PredicateObligation};\n use rustc_middle::ty::relate::{RelateResult, TypeRelation};\n use rustc_middle::ty::TyVar;\n use rustc_middle::ty::{self, Ty};\n@@ -32,6 +32,10 @@ pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n \n     fn cause(&self) -> &ObligationCause<'tcx>;\n \n+    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>);\n+\n+    fn define_opaque_types(&self) -> bool;\n+\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n     //\n@@ -41,6 +45,7 @@ pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n+#[instrument(skip(this), level = \"debug\")]\n pub fn super_lattice_tys<'a, 'tcx: 'a, L>(\n     this: &mut L,\n     a: Ty<'tcx>,\n@@ -49,15 +54,17 @@ pub fn super_lattice_tys<'a, 'tcx: 'a, L>(\n where\n     L: LatticeDir<'a, 'tcx>,\n {\n-    debug!(\"{}.lattice_tys({:?}, {:?})\", this.tag(), a, b);\n+    debug!(\"{}\", this.tag());\n \n     if a == b {\n         return Ok(a);\n     }\n \n     let infcx = this.infcx();\n+\n     let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n     let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n+\n     match (a.kind(), b.kind()) {\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to\n@@ -94,6 +101,22 @@ where\n             Ok(v)\n         }\n \n+        (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+            infcx.super_combine_tys(this, a, b)\n+        }\n+        (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n+            if this.define_opaque_types() && did.is_local() =>\n+        {\n+            this.add_obligations(vec![infcx.opaque_ty_obligation(\n+                a,\n+                b,\n+                this.a_is_expected(),\n+                this.param_env(),\n+                this.cause().clone(),\n+            )]);\n+            Ok(a)\n+        }\n+\n         _ => infcx.super_combine_tys(this, a, b),\n     }\n }"}, {"sha": "bbd8e00146905e991e99051a11db70e329fef1af", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,7 +4,7 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, PredicateObligation};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -117,10 +117,18 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n         &self.fields.trace.cause\n     }\n \n+    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>) {\n+        self.fields.obligations.extend(obligations)\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(a, v)?;\n         sub.relate(b, v)?;\n         Ok(())\n     }\n+\n+    fn define_opaque_types(&self) -> bool {\n+        self.fields.define_opaque_types\n+    }\n }"}, {"sha": "fa17a2d66f1176d1c46e451911c3f94178d8969a", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -5,7 +5,7 @@ pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n \n-use self::opaque_types::OpaqueTypeMap;\n+use self::opaque_types::OpaqueTypeStorage;\n pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n \n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n@@ -192,18 +192,8 @@ pub struct InferCtxtInner<'tcx> {\n \n     undo_log: InferCtxtUndoLogs<'tcx>,\n \n-    // Opaque types found in explicit return types and their\n-    // associated fresh inference variable. Writeback resolves these\n-    // variables to get the concrete type, which can be used to\n-    // 'de-opaque' OpaqueTypeDecl outside of type inference.\n-    pub opaque_types: OpaqueTypeMap<'tcx>,\n-\n-    /// A map from inference variables created from opaque\n-    /// type instantiations (`ty::Infer`) to the actual opaque\n-    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n-    /// opaque type inference variables to their corresponding\n-    /// opaque type.\n-    pub opaque_types_vars: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n+    /// Caches for opaque type inference.\n+    pub opaque_type_storage: OpaqueTypeStorage<'tcx>,\n }\n \n impl<'tcx> InferCtxtInner<'tcx> {\n@@ -217,8 +207,7 @@ impl<'tcx> InferCtxtInner<'tcx> {\n             float_unification_storage: ut::UnificationTableStorage::new(),\n             region_constraint_storage: Some(RegionConstraintStorage::new()),\n             region_obligations: vec![],\n-            opaque_types: Default::default(),\n-            opaque_types_vars: Default::default(),\n+            opaque_type_storage: Default::default(),\n         }\n     }\n \n@@ -237,6 +226,11 @@ impl<'tcx> InferCtxtInner<'tcx> {\n         self.type_variable_storage.with_log(&mut self.undo_log)\n     }\n \n+    #[inline]\n+    pub fn opaque_types(&mut self) -> opaque_types::OpaqueTypeTable<'_, 'tcx> {\n+        self.opaque_type_storage.with_log(&mut self.undo_log)\n+    }\n+\n     #[inline]\n     fn int_unification_table(\n         &mut self,\n@@ -297,6 +291,10 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// to the outside until the end up in an `InferCtxt` for typeck or borrowck.\n     pub defining_use_anchor: Option<LocalDefId>,\n \n+    /// Used by WF-checking to not have to figure out hidden types itself, but\n+    /// to just invoke type_of to get the already computed hidden type from typeck.\n+    pub reveal_defining_opaque_types: bool,\n+\n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n     /// used for reading closure kinds/signatures as they are inferred,\n@@ -552,6 +550,7 @@ pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n     defining_use_anchor: Option<LocalDefId>,\n+    reveal_defining_opaque_types: bool,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -560,7 +559,12 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder { tcx: self, defining_use_anchor: None, fresh_typeck_results: None }\n+        InferCtxtBuilder {\n+            tcx: self,\n+            defining_use_anchor: None,\n+            fresh_typeck_results: None,\n+            reveal_defining_opaque_types: false,\n+        }\n     }\n }\n \n@@ -584,6 +588,13 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    /// WF-checking doesn't need to recompute opaque types and can instead use\n+    /// the type_of query to get them from typeck.\n+    pub fn reveal_defining_opaque_types(mut self) -> Self {\n+        self.reveal_defining_opaque_types = true;\n+        self\n+    }\n+\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -608,11 +619,17 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n-        let InferCtxtBuilder { tcx, defining_use_anchor, ref fresh_typeck_results } = *self;\n+        let InferCtxtBuilder {\n+            tcx,\n+            defining_use_anchor,\n+            reveal_defining_opaque_types,\n+            ref fresh_typeck_results,\n+        } = *self;\n         let in_progress_typeck_results = fresh_typeck_results.as_ref();\n         f(InferCtxt {\n             tcx,\n             defining_use_anchor,\n+            reveal_defining_opaque_types,\n             in_progress_typeck_results,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),\n@@ -734,13 +751,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &'a self,\n         trace: TypeTrace<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n+        define_opaque_types: bool,\n     ) -> CombineFields<'a, 'tcx> {\n         CombineFields {\n             infcx: self,\n             trace,\n             cause: None,\n             param_env,\n             obligations: PredicateObligations::new(),\n+            define_opaque_types,\n         }\n     }\n \n@@ -1056,12 +1075,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tcx.mk_ty_var(self.next_ty_var_id(origin))\n     }\n \n+    pub fn next_ty_var_id_in_universe(\n+        &self,\n+        origin: TypeVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> TyVid {\n+        self.inner.borrow_mut().type_variables().new_var(universe, origin)\n+    }\n+\n     pub fn next_ty_var_in_universe(\n         &self,\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.inner.borrow_mut().type_variables().new_var(universe, origin);\n+        let vid = self.next_ty_var_id_in_universe(origin, universe);\n         self.tcx.mk_ty_var(vid)\n     }\n "}, {"sha": "3a288516664e380ad1371902797a273d161b3601", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -24,11 +24,13 @@\n use crate::infer::combine::ConstEquateRelation;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n+use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n+use rustc_span::Span;\n use std::fmt::Debug;\n use std::ops::ControlFlow;\n \n@@ -75,6 +77,7 @@ where\n \n pub trait TypeRelatingDelegate<'tcx> {\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n+    fn span(&self) -> Span;\n \n     /// Push a constraint `sup: sub` -- this constraint must be\n     /// satisfied for the two types to be related. `sub` and `sup` may\n@@ -87,6 +90,8 @@ pub trait TypeRelatingDelegate<'tcx> {\n         info: ty::VarianceDiagInfo<'tcx>,\n     );\n \n+    fn register_opaque_type(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected: bool);\n+\n     fn const_equate(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>);\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n@@ -277,7 +282,6 @@ where\n         projection_ty: ty::ProjectionTy<'tcx>,\n         value_ty: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n-        use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n         use rustc_span::DUMMY_SP;\n \n         match *value_ty.kind() {\n@@ -286,6 +290,8 @@ where\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: DUMMY_SP,\n                 });\n+                // FIXME(lazy-normalization): This will always ICE, because the recursive\n+                // call will end up in the _ arm below.\n                 self.relate_projection_ty(projection_ty, var);\n                 self.relate_projection_ty(other_projection_ty, var);\n                 var\n@@ -531,6 +537,8 @@ where\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, mut b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        let infcx = self.infcx;\n+\n         let a = self.infcx.shallow_resolve(a);\n \n         if !D::forbid_inference_vars() {\n@@ -559,6 +567,35 @@ where\n \n             (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var((vid, b)),\n \n+            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+                self.infcx.super_combine_tys(self, a, b)\n+            }\n+            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..)) if did.is_local() => {\n+                let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n+                let mut generalize = |ty, ty_is_expected| {\n+                    let var = infcx.next_ty_var_id_in_universe(\n+                        TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::MiscVariable,\n+                            span: self.delegate.span(),\n+                        },\n+                        ty::UniverseIndex::ROOT,\n+                    );\n+                    if ty_is_expected {\n+                        self.relate_ty_var((ty, var))\n+                    } else {\n+                        self.relate_ty_var((var, ty))\n+                    }\n+                };\n+                let (a, b) = match (a.kind(), b.kind()) {\n+                    (&ty::Opaque(..), _) => (a, generalize(b, false)?),\n+                    (_, &ty::Opaque(..)) => (generalize(a, true)?, b),\n+                    _ => unreachable!(),\n+                };\n+                self.delegate.register_opaque_type(a, b, true);\n+                trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n+                Ok(a)\n+            }\n+\n             (&ty::Projection(projection_ty), _)\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {"}, {"sha": "46420fbe0c305c5afe04e6c8c2240790e2416f81", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 238, "deletions": 223, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,10 +1,11 @@\n-use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits;\n+use crate::traits::{self, PredicateObligation};\n+use hir::def_id::{DefId, LocalDefId};\n+use hir::OpaqueTyOrigin;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n-use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n@@ -14,14 +15,28 @@ use std::ops::ControlFlow;\n \n pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n \n+mod table;\n+\n+pub use table::{OpaqueTypeStorage, OpaqueTypeTable};\n+\n+use super::InferResult;\n+\n /// Information about the opaque types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n /// appear in the return type).\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct OpaqueTypeDecl<'tcx> {\n-    /// The opaque type (`ty::Opaque`) for this declaration.\n-    pub opaque_type: Ty<'tcx>,\n+    /// The hidden types that have been inferred for this opaque type.\n+    /// There can be multiple, but they are all `lub`ed together at the end\n+    /// to obtain the canonical hidden type.\n+    pub hidden_type: OpaqueHiddenType<'tcx>,\n+\n+    /// The origin of the opaque type.\n+    pub origin: hir::OpaqueTyOrigin,\n+}\n \n+#[derive(Copy, Clone, Debug, TypeFoldable)]\n+pub struct OpaqueHiddenType<'tcx> {\n     /// The span of this particular definition of the opaque type. So\n     /// for example:\n     ///\n@@ -35,7 +50,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// In cases where the fn returns `(impl Trait, impl Trait)` or\n     /// other such combinations, the result is currently\n     /// over-approximated, but better than nothing.\n-    pub definition_span: Span,\n+    pub span: Span,\n \n     /// The type variable that represents the value of the opaque type\n     /// that we require. In other words, after we compile this function,\n@@ -49,54 +64,132 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// those that are arguments to `Foo` in the constraint above. (In\n     /// other words, `?C` should not include `'b`, even though it's a\n     /// lifetime parameter on `foo`.)\n-    pub concrete_ty: Ty<'tcx>,\n-\n-    /// The origin of the opaque type.\n-    pub origin: hir::OpaqueTyOrigin,\n+    pub ty: Ty<'tcx>,\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    /// Replaces all opaque types in `value` with fresh inference variables\n-    /// and creates appropriate obligations. For example, given the input:\n-    ///\n-    ///     impl Iterator<Item = impl Debug>\n-    ///\n-    /// this method would create two type variables, `?0` and `?1`. It would\n-    /// return the type `?0` but also the obligations:\n-    ///\n-    ///     ?0: Iterator<Item = ?1>\n-    ///     ?1: Debug\n-    ///\n-    /// Moreover, it returns an `OpaqueTypeMap` that would map `?0` to\n-    /// info about the `impl Iterator<..>` type and `?1` to info about\n-    /// the `impl Debug` type.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `parent_def_id` -- the `DefId` of the function in which the opaque type\n-    ///   is defined\n-    /// - `body_id` -- the body-id with which the resulting obligations should\n-    ///   be associated\n-    /// - `param_env` -- the in-scope parameter environment to be used for\n-    ///   obligations\n-    /// - `value` -- the value within which we are instantiating opaque types\n-    /// - `value_span` -- the span where the value came from, used in error reporting\n-    pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n+    pub fn handle_opaque_type(\n         &self,\n-        body_id: hir::HirId,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n-        value_span: Span,\n-    ) -> InferOk<'tcx, T> {\n-        debug!(\n-            \"instantiate_opaque_types(value={:?}, body_id={:?}, \\\n-             param_env={:?}, value_span={:?})\",\n-            value, body_id, param_env, value_span,\n-        );\n-        let mut instantiator =\n-            Instantiator { infcx: self, body_id, param_env, value_span, obligations: vec![] };\n-        let value = instantiator.instantiate_opaque_types_in_map(value);\n-        InferOk { value, obligations: instantiator.obligations }\n+    ) -> InferResult<'tcx, ()> {\n+        if a.references_error() || b.references_error() {\n+            return Ok(InferOk { value: (), obligations: vec![] });\n+        }\n+        if self.defining_use_anchor.is_some() {\n+            let process = |a: Ty<'tcx>, b: Ty<'tcx>| match *a.kind() {\n+                ty::Opaque(def_id, substs) => {\n+                    if let ty::Opaque(did2, _) = *b.kind() {\n+                        // We could accept this, but there are various ways to handle this situation, and we don't\n+                        // want to make a decision on it right now. Likely this case is so super rare anyway, that\n+                        // no one encounters it in practice.\n+                        // It does occur however in `fn fut() -> impl Future<Output = i32> { async { 42 } }`,\n+                        // where it is of no concern, so we only check for TAITs.\n+                        if let Some(OpaqueTyOrigin::TyAlias) =\n+                            self.opaque_type_origin(did2, cause.span)\n+                        {\n+                            self.tcx\n+                                .sess\n+                                .struct_span_err(\n+                                    cause.span,\n+                                    \"opaque type's hidden type cannot be another opaque type from the same scope\",\n+                                )\n+                                .span_label(cause.span, \"one of the two opaque types used here has to be outside its defining scope\")\n+                                .span_note(\n+                                    self.tcx.def_span(def_id),\n+                                    \"opaque type whose hidden type is being assigned\",\n+                                )\n+                                .span_note(\n+                                    self.tcx.def_span(did2),\n+                                    \"opaque type being used as hidden type\",\n+                                )\n+                                .emit();\n+                        }\n+                    }\n+                    Some(self.register_hidden_type(\n+                        OpaqueTypeKey { def_id, substs },\n+                        cause.clone(),\n+                        param_env,\n+                        b,\n+                        // Check that this is `impl Trait` type is\n+                        // declared by `parent_def_id` -- i.e., one whose\n+                        // value we are inferring.  At present, this is\n+                        // always true during the first phase of\n+                        // type-check, but not always true later on during\n+                        // NLL. Once we support named opaque types more fully,\n+                        // this same scenario will be able to arise during all phases.\n+                        //\n+                        // Here is an example using type alias `impl Trait`\n+                        // that indicates the distinction we are checking for:\n+                        //\n+                        // ```rust\n+                        // mod a {\n+                        //   pub type Foo = impl Iterator;\n+                        //   pub fn make_foo() -> Foo { .. }\n+                        // }\n+                        //\n+                        // mod b {\n+                        //   fn foo() -> a::Foo { a::make_foo() }\n+                        // }\n+                        // ```\n+                        //\n+                        // Here, the return type of `foo` references an\n+                        // `Opaque` indeed, but not one whose value is\n+                        // presently being inferred. You can get into a\n+                        // similar situation with closure return types\n+                        // today:\n+                        //\n+                        // ```rust\n+                        // fn foo() -> impl Iterator { .. }\n+                        // fn bar() {\n+                        //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                        // }\n+                        // ```\n+                        self.opaque_type_origin(def_id, cause.span)?,\n+                    ))\n+                }\n+                _ => None,\n+            };\n+            if let Some(res) = process(a, b) {\n+                res\n+            } else if let Some(res) = process(b, a) {\n+                res\n+            } else {\n+                // Rerun equality check, but this time error out due to\n+                // different types.\n+                match self.at(cause, param_env).define_opaque_types(false).eq(a, b) {\n+                    Ok(_) => span_bug!(\n+                        cause.span,\n+                        \"opaque types are never equal to anything but themselves: {:#?}\",\n+                        (a, b)\n+                    ),\n+                    Err(e) => Err(e),\n+                }\n+            }\n+        } else {\n+            let (opaque_type, hidden_ty) = match (a.kind(), b.kind()) {\n+                (ty::Opaque(..), _) => (a, b),\n+                (_, ty::Opaque(..)) => (b, a),\n+                types => span_bug!(\n+                    cause.span,\n+                    \"opaque type obligations only work for opaque types: {:#?}\",\n+                    types\n+                ),\n+            };\n+            let key = opaque_type.expect_opaque_type();\n+            let origin = self.opaque_ty_origin_unchecked(key.def_id, cause.span);\n+            let prev = self.inner.borrow_mut().opaque_types().register(\n+                key,\n+                OpaqueHiddenType { ty: hidden_ty, span: cause.span },\n+                origin,\n+            );\n+            match prev {\n+                Some(prev) => self.at(cause, param_env).eq(prev, hidden_ty),\n+                None => Ok(InferOk { value: (), obligations: vec![] }),\n+            }\n+        }\n     }\n \n     /// Given the map `opaque_types` containing the opaque\n@@ -231,51 +324,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// but this is not necessary, because the opaque type we\n     /// create will be allowed to reference `T`. So we only generate a\n     /// constraint that `'0: 'a`.\n-    ///\n-    /// # The `free_region_relations` parameter\n-    ///\n-    /// The `free_region_relations` argument is used to find the\n-    /// \"minimum\" of the regions supplied to a given opaque type.\n-    /// It must be a relation that can answer whether `'a <= 'b`,\n-    /// where `'a` and `'b` are regions that appear in the \"substs\"\n-    /// for the opaque type references (the `<'a>` in `Foo1<'a>`).\n-    ///\n-    /// Note that we do not impose the constraints based on the\n-    /// generic regions from the `Foo1` definition (e.g., `'x`). This\n-    /// is because the constraints we are imposing here is basically\n-    /// the concern of the one generating the constraining type C1,\n-    /// which is the current function. It also means that we can\n-    /// take \"implied bounds\" into account in some cases:\n-    ///\n-    /// ```text\n-    /// trait SomeTrait<'a, 'b> { }\n-    /// fn foo<'a, 'b>(_: &'a &'b u32) -> impl SomeTrait<'a, 'b> { .. }\n-    /// ```\n-    ///\n-    /// Here, the fact that `'b: 'a` is known only because of the\n-    /// implied bounds from the `&'a &'b u32` parameter, and is not\n-    /// \"inherent\" to the opaque type definition.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n-    /// - `free_region_relations` -- something that can be used to relate\n-    ///   the free regions (`'a`) that appear in the impl trait.\n     #[instrument(level = \"debug\", skip(self))]\n-    pub fn constrain_opaque_type(\n+    pub fn register_member_constraints(\n         &self,\n+        param_env: ty::ParamEnv<'tcx>,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n-        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        concrete_ty: Ty<'tcx>,\n+        span: Span,\n     ) {\n         let def_id = opaque_type_key.def_id;\n \n         let tcx = self.tcx;\n \n-        let concrete_ty = self.resolve_vars_if_possible(opaque_defn.concrete_ty);\n+        let concrete_ty = self.resolve_vars_if_possible(concrete_ty);\n \n         debug!(?concrete_ty);\n \n-        let first_own_region = match opaque_defn.origin {\n+        let first_own_region = match self.opaque_ty_origin_unchecked(def_id, span) {\n             hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {\n                 // We lower\n                 //\n@@ -319,7 +384,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             op: |r| {\n                 self.member_constraint(\n                     opaque_type_key.def_id,\n-                    opaque_defn.definition_span,\n+                    span,\n                     concrete_ty,\n                     r,\n                     &choice_regions,\n@@ -328,15 +393,34 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         });\n     }\n \n-    fn opaque_type_origin(&self, def_id: LocalDefId) -> Option<hir::OpaqueTyOrigin> {\n-        let tcx = self.tcx;\n-        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    pub fn opaque_ty_obligation(\n+        &self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        a_is_expected: bool,\n+        param_env: ty::ParamEnv<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+    ) -> PredicateObligation<'tcx> {\n+        let (a, b) = if a_is_expected { (a, b) } else { (b, a) };\n+        PredicateObligation::new(\n+            cause,\n+            param_env,\n+            self.tcx.mk_predicate(ty::Binder::dummy(ty::PredicateKind::OpaqueType(a, b))),\n+        )\n+    }\n+\n+    #[instrument(skip(self), level = \"trace\")]\n+    pub fn opaque_type_origin(&self, opaque_def_id: DefId, span: Span) -> Option<OpaqueTyOrigin> {\n+        let def_id = opaque_def_id.as_local()?;\n+        let opaque_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let parent_def_id = self.defining_use_anchor?;\n-        let item_kind = &tcx.hir().expect_item(def_id).kind;\n+        let item_kind = &self.tcx.hir().expect_item(def_id).kind;\n+\n         let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n             span_bug!(\n-                tcx.def_span(def_id),\n-                \"weird opaque type: {:#?}\",\n+                span,\n+                \"weird opaque type: {:#?}, {:#?}\",\n+                opaque_def_id,\n                 item_kind\n             )\n         };\n@@ -347,11 +431,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n             // Named `type Foo = impl Bar;`\n             hir::OpaqueTyOrigin::TyAlias => {\n-                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n+                may_define_opaque_type(self.tcx, parent_def_id, opaque_hir_id)\n             }\n         };\n+        trace!(?origin);\n         in_definition_scope.then_some(*origin)\n     }\n+\n+    #[instrument(skip(self), level = \"trace\")]\n+    fn opaque_ty_origin_unchecked(&self, opaque_def_id: DefId, span: Span) -> OpaqueTyOrigin {\n+        let def_id = opaque_def_id.as_local().unwrap();\n+        let origin = match self.tcx.hir().expect_item(def_id).kind {\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => origin,\n+            ref itemkind => {\n+                span_bug!(span, \"weird opaque type: {:?}, {:#?}\", opaque_def_id, itemkind)\n+            }\n+        };\n+        trace!(?origin);\n+        origin\n+    }\n+\n+    pub fn opaque_types(&self) -> OpaqueTypeMap<'tcx> {\n+        self.inner.borrow().opaque_type_storage.opaque_types()\n+    }\n }\n \n // Visitor that requires that (almost) all regions in the type visited outlive\n@@ -426,180 +528,93 @@ where\n     }\n }\n \n-struct Instantiator<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    body_id: hir::HirId,\n-    param_env: ty::ParamEnv<'tcx>,\n-    value_span: Span,\n-    obligations: Vec<traits::PredicateObligation<'tcx>>,\n+pub enum UseKind {\n+    DefiningUse,\n+    OpaqueUse,\n }\n \n-impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n-    fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n-        let tcx = self.infcx.tcx;\n-        value.fold_with(&mut BottomUpFolder {\n-            tcx,\n-            ty_op: |ty| {\n-                if ty.references_error() {\n-                    return tcx.ty_error();\n-                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n-                    // Check that this is `impl Trait` type is\n-                    // declared by `parent_def_id` -- i.e., one whose\n-                    // value we are inferring.  At present, this is\n-                    // always true during the first phase of\n-                    // type-check, but not always true later on during\n-                    // NLL. Once we support named opaque types more fully,\n-                    // this same scenario will be able to arise during all phases.\n-                    //\n-                    // Here is an example using type alias `impl Trait`\n-                    // that indicates the distinction we are checking for:\n-                    //\n-                    // ```rust\n-                    // mod a {\n-                    //   pub type Foo = impl Iterator;\n-                    //   pub fn make_foo() -> Foo { .. }\n-                    // }\n-                    //\n-                    // mod b {\n-                    //   fn foo() -> a::Foo { a::make_foo() }\n-                    // }\n-                    // ```\n-                    //\n-                    // Here, the return type of `foo` references an\n-                    // `Opaque` indeed, but not one whose value is\n-                    // presently being inferred. You can get into a\n-                    // similar situation with closure return types\n-                    // today:\n-                    //\n-                    // ```rust\n-                    // fn foo() -> impl Iterator { .. }\n-                    // fn bar() {\n-                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                    // }\n-                    // ```\n-                    if let Some(def_id) = def_id.as_local() {\n-                        if let Some(origin) = self.infcx.opaque_type_origin(def_id) {\n-                            let opaque_type_key =\n-                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n-                        }\n-\n-                        debug!(\n-                            \"instantiate_opaque_types_in_map: \\\n-                             encountered opaque outside its definition scope \\\n-                             def_id={:?}\",\n-                            def_id,\n-                        );\n-                    }\n-                }\n-\n-                ty\n-            },\n-            lt_op: |lt| lt,\n-            ct_op: |ct| ct,\n-        })\n+impl UseKind {\n+    pub fn is_defining(self) -> bool {\n+        match self {\n+            UseKind::DefiningUse => true,\n+            UseKind::OpaqueUse => false,\n+        }\n     }\n+}\n \n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n-    fn fold_opaque_ty(\n-        &mut self,\n-        ty: Ty<'tcx>,\n+    fn register_hidden_type(\n+        &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n         origin: hir::OpaqueTyOrigin,\n-    ) -> Ty<'tcx> {\n-        let infcx = self.infcx;\n-        let tcx = infcx.tcx;\n+    ) -> InferResult<'tcx, ()> {\n+        let tcx = self.tcx;\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n-        // Use the same type variable if the exact same opaque type appears more\n-        // than once in the return type (e.g., if it's passed to a type alias).\n-        if let Some(opaque_defn) = infcx.inner.borrow().opaque_types.get(&opaque_type_key) {\n-            debug!(\"re-using cached concrete type {:?}\", opaque_defn.concrete_ty.kind());\n-            return opaque_defn.concrete_ty;\n-        }\n-\n-        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::TypeInference,\n-            span: self.value_span,\n-        });\n-\n         // Ideally, we'd get the span where *this specific `ty` came\n         // from*, but right now we just use the span from the overall\n         // value being folded. In simple cases like `-> impl Foo`,\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n-        let definition_span = self.value_span;\n+        let span = cause.span;\n \n-        {\n-            let mut infcx = self.infcx.inner.borrow_mut();\n-            infcx.opaque_types.insert(\n-                OpaqueTypeKey { def_id, substs },\n-                OpaqueTypeDecl { opaque_type: ty, definition_span, concrete_ty: ty_var, origin },\n-            );\n-            infcx.opaque_types_vars.insert(ty_var, ty);\n+        let mut obligations = vec![];\n+        let prev = self.inner.borrow_mut().opaque_types().register(\n+            OpaqueTypeKey { def_id, substs },\n+            OpaqueHiddenType { ty: hidden_ty, span },\n+            origin,\n+        );\n+        if let Some(prev) = prev {\n+            obligations = self.at(&cause, param_env).eq(prev, hidden_ty)?.obligations;\n         }\n \n-        debug!(\"generated new type inference var {:?}\", ty_var.kind());\n-\n         let item_bounds = tcx.explicit_item_bounds(def_id);\n \n-        self.obligations.reserve(item_bounds.len());\n         for (predicate, _) in item_bounds {\n             debug!(?predicate);\n             let predicate = predicate.subst(tcx, substs);\n-            debug!(?predicate);\n \n             let predicate = predicate.fold_with(&mut BottomUpFolder {\n                 tcx,\n                 ty_op: |ty| match *ty.kind() {\n-                    // Replace all other mentions of the same opaque type with the hidden type,\n-                    // as the bounds must hold on the hidden type after all.\n-                    ty::Opaque(def_id2, substs2) if def_id == def_id2 && substs == substs2 => {\n-                        ty_var\n-                    }\n-                    // Instantiate nested instances of `impl Trait`.\n-                    ty::Opaque(..) => self.instantiate_opaque_types_in_map(ty),\n-                    _ => ty,\n-                },\n-                lt_op: |lt| lt,\n-                ct_op: |ct| ct,\n-            });\n-\n-            // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n-            let predicate = predicate.fold_with(&mut BottomUpFolder {\n-                tcx,\n-                ty_op: |ty| match ty.kind() {\n+                    // We can't normalize associated types from `rustc_infer`,\n+                    // but we can eagerly register inference variables for them.\n                     ty::Projection(projection_ty) if !projection_ty.has_escaping_bound_vars() => {\n-                        infcx.infer_projection(\n-                            self.param_env,\n-                            *projection_ty,\n-                            traits::ObligationCause::misc(self.value_span, self.body_id),\n+                        self.infer_projection(\n+                            param_env,\n+                            projection_ty,\n+                            cause.clone(),\n                             0,\n-                            &mut self.obligations,\n+                            &mut obligations,\n                         )\n                     }\n+                    // Replace all other mentions of the same opaque type with the hidden type,\n+                    // as the bounds must hold on the hidden type after all.\n+                    ty::Opaque(def_id2, substs2) if def_id == def_id2 && substs == substs2 => {\n+                        hidden_ty\n+                    }\n                     _ => ty,\n                 },\n                 lt_op: |lt| lt,\n                 ct_op: |ct| ct,\n             });\n-            debug!(?predicate);\n \n             if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n                 if projection.term.references_error() {\n-                    return tcx.ty_error();\n+                    // No point on adding these obligations since there's a type error involved.\n+                    return Ok(InferOk { value: (), obligations: vec![] });\n                 }\n+                trace!(\"{:#?}\", projection.term);\n             }\n-\n-            let cause =\n-                traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);\n-\n             // Require that the predicate holds for the concrete type.\n             debug!(?predicate);\n-            self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n+            obligations.push(traits::Obligation::new(cause.clone(), param_env, predicate));\n         }\n-\n-        ty_var\n+        Ok(InferOk { value: (), obligations })\n     }\n }\n "}, {"sha": "9b8f225ce367b650c28b5e0daa1cae3e64023d8b", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,88 @@\n+use rustc_data_structures::undo_log::UndoLogs;\n+use rustc_hir::OpaqueTyOrigin;\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty};\n+use rustc_span::DUMMY_SP;\n+\n+use crate::infer::{InferCtxtUndoLogs, UndoLog};\n+\n+use super::{OpaqueHiddenType, OpaqueTypeDecl, OpaqueTypeMap};\n+\n+#[derive(Default, Debug)]\n+pub struct OpaqueTypeStorage<'tcx> {\n+    // Opaque types found in explicit return types and their\n+    // associated fresh inference variable. Writeback resolves these\n+    // variables to get the concrete type, which can be used to\n+    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n+    pub opaque_types: OpaqueTypeMap<'tcx>,\n+}\n+\n+impl<'tcx> OpaqueTypeStorage<'tcx> {\n+    #[instrument(level = \"debug\")]\n+    pub(crate) fn remove(&mut self, key: OpaqueTypeKey<'tcx>, idx: Option<OpaqueHiddenType<'tcx>>) {\n+        if let Some(idx) = idx {\n+            self.opaque_types.get_mut(&key).unwrap().hidden_type = idx;\n+        } else {\n+            match self.opaque_types.remove(&key) {\n+                None => bug!(\"reverted opaque type inference that was never registered: {:?}\", key),\n+                Some(_) => {}\n+            }\n+        }\n+    }\n+\n+    pub fn get_decl(&self, key: &OpaqueTypeKey<'tcx>) -> Option<&OpaqueTypeDecl<'tcx>> {\n+        self.opaque_types.get(key)\n+    }\n+\n+    pub fn opaque_types(&self) -> OpaqueTypeMap<'tcx> {\n+        self.opaque_types.clone()\n+    }\n+\n+    #[instrument(level = \"debug\")]\n+    pub fn take_opaque_types(&mut self) -> OpaqueTypeMap<'tcx> {\n+        std::mem::take(&mut self.opaque_types)\n+    }\n+\n+    #[inline]\n+    pub(crate) fn with_log<'a>(\n+        &'a mut self,\n+        undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n+    ) -> OpaqueTypeTable<'a, 'tcx> {\n+        OpaqueTypeTable { storage: self, undo_log }\n+    }\n+}\n+\n+impl<'tcx> Drop for OpaqueTypeStorage<'tcx> {\n+    fn drop(&mut self) {\n+        if !self.opaque_types.is_empty() {\n+            ty::tls::with(|tcx| {\n+                tcx.sess.delay_span_bug(DUMMY_SP, &format!(\"{:?}\", self.opaque_types))\n+            });\n+        }\n+    }\n+}\n+\n+pub struct OpaqueTypeTable<'a, 'tcx> {\n+    storage: &'a mut OpaqueTypeStorage<'tcx>,\n+\n+    undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n+}\n+\n+impl<'a, 'tcx> OpaqueTypeTable<'a, 'tcx> {\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn register(\n+        &mut self,\n+        key: OpaqueTypeKey<'tcx>,\n+        hidden_type: OpaqueHiddenType<'tcx>,\n+        origin: OpaqueTyOrigin,\n+    ) -> Option<Ty<'tcx>> {\n+        if let Some(decl) = self.storage.opaque_types.get_mut(&key) {\n+            let prev = std::mem::replace(&mut decl.hidden_type, hidden_type);\n+            self.undo_log.push(UndoLog::OpaqueTypes(key, Some(prev)));\n+            return Some(prev.ty);\n+        }\n+        let decl = OpaqueTypeDecl { hidden_type, origin };\n+        self.storage.opaque_types.insert(key, decl);\n+        self.undo_log.push(UndoLog::OpaqueTypes(key, None));\n+        None\n+    }\n+}"}, {"sha": "b60ffc1878be44a38f776b0d48e8a1c14ea648b3", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -28,6 +28,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n                 Some(OutlivesBound::RegionSubRegion(r_b, r_a))"}, {"sha": "d554d7d935c52c570d7873e9d321a2c12bb405ae", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -153,6 +153,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// This function may have to perform normalizations, and hence it\n     /// returns an `InferOk` with subobligations that must be\n     /// processed.\n+    #[instrument(level = \"debug\", skip(self, region_bound_pairs_map))]\n     pub fn process_registered_region_obligations(\n         &self,\n         region_bound_pairs_map: &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n@@ -164,8 +165,6 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             \"cannot process registered region obligations in a snapshot\"\n         );\n \n-        debug!(?param_env, \"process_registered_region_obligations()\");\n-\n         let my_region_obligations = self.take_registered_region_obligations();\n \n         for (body_id, RegionObligation { sup_type, sub_region, origin }) in my_region_obligations {"}, {"sha": "e0a8219beede1804189c126ae68242efb65707ec", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -2,6 +2,7 @@ use super::combine::{CombineFields, RelationDir};\n use super::SubregionOrigin;\n \n use crate::infer::combine::ConstEquateRelation;\n+use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::traits::Obligation;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n@@ -74,16 +75,16 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n-\n         if a == b {\n             return Ok(a);\n         }\n \n         let infcx = self.fields.infcx;\n         let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n         let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n+\n         match (a.kind(), b.kind()) {\n             (&ty::Infer(TyVar(_)), &ty::Infer(TyVar(_))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n@@ -121,6 +122,40 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 Ok(self.tcx().ty_error())\n             }\n \n+            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+                self.fields.infcx.super_combine_tys(self, a, b)?;\n+                Ok(a)\n+            }\n+            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n+                if self.fields.define_opaque_types && did.is_local() =>\n+            {\n+                let mut generalize = |ty, ty_is_expected| {\n+                    let var = infcx.next_ty_var_id_in_universe(\n+                        TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::MiscVariable,\n+                            span: self.fields.trace.cause.span,\n+                        },\n+                        ty::UniverseIndex::ROOT,\n+                    );\n+                    self.fields.instantiate(ty, RelationDir::SubtypeOf, var, ty_is_expected)?;\n+                    Ok(infcx.tcx.mk_ty_var(var))\n+                };\n+                let (a, b) = if self.a_is_expected { (a, b) } else { (b, a) };\n+                let (a, b) = match (a.kind(), b.kind()) {\n+                    (&ty::Opaque(..), _) => (a, generalize(b, true)?),\n+                    (_, &ty::Opaque(..)) => (generalize(a, false)?, b),\n+                    _ => unreachable!(),\n+                };\n+                self.fields.obligations.push(infcx.opaque_ty_obligation(\n+                    a,\n+                    b,\n+                    true,\n+                    self.param_env(),\n+                    self.fields.trace.cause.clone(),\n+                ));\n+                Ok(a)\n+            }\n+\n             _ => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n                 Ok(a)"}, {"sha": "02b15baf8fb2dba45fc4221e23271b3fd76a1644", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,20 +4,23 @@ use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::undo_log::{Rollback, UndoLogs};\n use rustc_data_structures::unify as ut;\n use rustc_middle::infer::unify_key::RegionVidKey;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, OpaqueTypeKey};\n \n use crate::{\n     infer::{region_constraints, type_variable, InferCtxtInner},\n     traits,\n };\n \n+use super::opaque_types::OpaqueHiddenType;\n+\n pub struct Snapshot<'tcx> {\n     pub(crate) undo_len: usize,\n     _marker: PhantomData<&'tcx ()>,\n }\n \n /// Records the \"undo\" data for a single operation that affects some form of inference variable.\n pub(crate) enum UndoLog<'tcx> {\n+    OpaqueTypes(OpaqueTypeKey<'tcx>, Option<OpaqueHiddenType<'tcx>>),\n     TypeVariables(type_variable::UndoLog<'tcx>),\n     ConstUnificationTable(sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>),\n     IntUnificationTable(sv::UndoLog<ut::Delegate<ty::IntVid>>),\n@@ -64,6 +67,7 @@ impl_from! {\n impl<'tcx> Rollback<UndoLog<'tcx>> for InferCtxtInner<'tcx> {\n     fn reverse(&mut self, undo: UndoLog<'tcx>) {\n         match undo {\n+            UndoLog::OpaqueTypes(key, idx) => self.opaque_type_storage.remove(key, idx),\n             UndoLog::TypeVariables(undo) => self.type_variable_storage.reverse(undo),\n             UndoLog::ConstUnificationTable(undo) => self.const_unification_storage.reverse(undo),\n             UndoLog::IntUnificationTable(undo) => self.int_unification_storage.reverse(undo),"}, {"sha": "6600d5e4d0279a3f3303ab0eeada9d47f9e11f71", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -167,6 +167,9 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could.\n             }\n+            ty::PredicateKind::OpaqueType(..) => {\n+                todo!(\"{:#?}\", obligation)\n+            }\n             ty::PredicateKind::ObjectSafe(..) => {\n                 // Currently, we do not elaborate object-safe\n                 // predicates."}, {"sha": "44e3da11826cd00c08d92f99a97c907dcf8bd72e", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1654,6 +1654,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     Coerce(..) |\n                     ConstEvaluatable(..) |\n                     ConstEquate(..) |\n+                    OpaqueType(..) |\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n                 if predicate.is_global() {"}, {"sha": "2fc901bdbff34db5a8c4411b511f842a1cbe36f2", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -178,6 +178,12 @@ pub struct QueryResponse<'tcx, R> {\n     pub var_values: CanonicalVarValues<'tcx>,\n     pub region_constraints: QueryRegionConstraints<'tcx>,\n     pub certainty: Certainty,\n+    /// List of opaque types which we tried to compare to another type.\n+    /// Inside the query we don't know yet whether the opaque type actually\n+    /// should get its hidden type inferred. So we bubble the opaque type\n+    /// and the type it was compared against upwards and let the query caller\n+    /// handle it.\n+    pub opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n     pub value: R,\n }\n "}, {"sha": "2642bddb9a4d33509467e6151330a203107e4a45", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -53,17 +53,17 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         self.relate(a, b)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn regions(\n         &mut self,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n         Ok(a)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n         if a == b {\n             return Ok(a);\n         }"}, {"sha": "694b7d2b817cfc4ff8407f4fd179bcaad32bac7f", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -30,6 +30,7 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -464,9 +465,13 @@ pub struct TypeckResults<'tcx> {\n     /// this field will be set to `Some(ErrorReported)`.\n     pub tainted_by_errors: Option<ErrorReported>,\n \n-    /// All the opaque types that are restricted to concrete types\n-    /// by this function.\n-    pub concrete_opaque_types: FxHashSet<DefId>,\n+    /// All the opaque types that have hidden types set\n+    /// by this function. For return-position-impl-trait we also store the\n+    /// type here, so that mir-borrowck can figure out hidden types,\n+    /// even if they are only set in dead code (which doesn't show up in MIR).\n+    /// For type-alias-impl-trait, this map is only used to prevent query cycles,\n+    /// so the hidden types are all `None`.\n+    pub concrete_opaque_types: VecMap<DefId, Option<Ty<'tcx>>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "7394bc5b2d8dd45c8382748b95d4096a2094aef7", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -265,6 +265,10 @@ impl FlagComputation {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 self.add_ty(ty);\n             }\n+            ty::PredicateKind::OpaqueType(opaque, ty) => {\n+                self.add_ty(opaque);\n+                self.add_ty(ty);\n+            }\n         }\n     }\n "}, {"sha": "2fd0ca423cc944ff4de0ad0b6c59e0cc0e515d96", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1207,15 +1207,11 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     type BreakTy = FoundFlags;\n \n     #[inline]\n-    #[instrument(level = \"trace\")]\n-    fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\n-            \"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\",\n-            t,\n-            t.flags(),\n-            self.flags\n-        );\n-        if t.flags().intersects(self.flags) {\n+    #[instrument(skip(self), level = \"trace\")]\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = t.flags();\n+        trace!(t.flags=?t.flags());\n+        if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n             ControlFlow::CONTINUE\n@@ -1235,7 +1231,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(level = \"trace\")]\n+    #[instrument(skip(self), level = \"trace\")]\n     fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = FlagComputation::for_const(c);\n         trace!(r.flags=?flags);"}, {"sha": "8bf760179e680e6188827e3f8ada18ddc8c0bfbc", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -627,6 +627,11 @@ pub enum PredicateKind<'tcx> {\n     ///\n     /// Only used for Chalk.\n     TypeWellFormedFromEnv(Ty<'tcx>),\n+\n+    /// Represents a hidden type assignment for an opaque type.\n+    /// Such obligations get processed by checking whether the item currently being\n+    /// type-checked may acually define it.\n+    OpaqueType(Ty<'tcx>, Ty<'tcx>),\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -986,6 +991,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::TypeOutlives(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n+            | PredicateKind::OpaqueType(..)\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n@@ -1004,6 +1010,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::ClosureKind(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n+            | PredicateKind::OpaqueType(..)\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n@@ -1044,7 +1051,18 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable, TypeFoldable)]\n+#[derive(\n+    Copy,\n+    Clone,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    HashStable,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    Lift\n+)]\n pub struct OpaqueTypeKey<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "6521957ec944c36b9b26a7fdbe31fa530666a5c0", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -644,20 +644,23 @@ pub trait PrettyPrinter<'tcx>:\n                     return Ok(self);\n                 }\n \n-                return with_no_queries(|| {\n-                    let def_key = self.tcx().def_key(def_id);\n-                    if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                        p!(write(\"{}\", name));\n-                        // FIXME(eddyb) print this with `print_def_path`.\n-                        if !substs.is_empty() {\n-                            p!(\"::\");\n-                            p!(generic_delimiters(|cx| cx.comma_sep(substs.iter())));\n+                let parent = self.tcx().parent(def_id).expect(\"opaque types always have a parent\");\n+                match self.tcx().def_kind(parent) {\n+                    DefKind::TyAlias | DefKind::AssocTy => {\n+                        if let ty::Opaque(d, _) = *self.tcx().type_of(parent).kind() {\n+                            if d == def_id {\n+                                // If the type alias directly starts with the `impl` of the\n+                                // opaque type we're printing, then skip the `::{opaque#1}`.\n+                                p!(print_def_path(parent, substs));\n+                                return Ok(self);\n+                            }\n                         }\n+                        // Complex opaque type, e.g. `type Foo = (i32, impl Debug);`\n+                        p!(print_def_path(def_id, substs));\n                         return Ok(self);\n                     }\n-\n-                    self.pretty_print_opaque_impl_type(def_id, substs)\n-                });\n+                    _ => return self.pretty_print_opaque_impl_type(def_id, substs),\n+                }\n             }\n             ty::Str => p!(\"str\"),\n             ty::Generator(did, substs, movability) => {\n@@ -2607,6 +2610,9 @@ define_print_and_forward_display! {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n+            ty::PredicateKind::OpaqueType(a, b) => {\n+                p!(\"opaque type assigment with `\", print(a), \"` == `\", print(b) ,\"`\")\n+            }\n         }\n     }\n "}, {"sha": "ef54832791d41a23558edad81edd6606442b39a8", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -191,6 +191,9 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 write!(f, \"TypeWellFormedFromEnv({:?})\", ty)\n             }\n+            ty::PredicateKind::OpaqueType(a, b) => {\n+                write!(f, \"OpaqueType({:?}, {:?})\", a.kind(), b.kind())\n+            }\n         }\n     }\n }\n@@ -463,6 +466,9 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 tcx.lift(ty).map(ty::PredicateKind::TypeWellFormedFromEnv)\n             }\n+            ty::PredicateKind::OpaqueType(opaque, ty) => {\n+                Some(ty::PredicateKind::OpaqueType(tcx.lift(opaque)?, tcx.lift(ty)?))\n+            }\n         }\n     }\n }"}, {"sha": "6b187f7da4c6d2f18781748fc0fe1abcb849c71b", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -152,6 +152,7 @@ pub enum TyKind<'tcx> {\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n+    /// For the order of the substs see the `ClosureSubsts` type's documentation.\n     Closure(DefId, SubstsRef<'tcx>),\n \n     /// The anonymous type of a generator. Used to represent the type of\n@@ -1815,6 +1816,13 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    pub fn expect_opaque_type(&self) -> ty::OpaqueTypeKey<'tcx> {\n+        match *self.kind() {\n+            Opaque(def_id, substs) => ty::OpaqueTypeKey { def_id, substs },\n+            _ => bug!(\"`expect_opaque_type` called on non-opaque type: {}\", self),\n+        }\n+    }\n+\n     pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind() {\n             Adt(def, substs) => {"}, {"sha": "8cb19baa29230d15652b48fe8ec33a076b795c05", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,8 @@\n use crate::build::matches::ArmHasGuard;\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n+use rustc_middle::{mir::*, ty};\n use rustc_session::lint::builtin::UNSAFE_OP_IN_UNSAFE_FN;\n use rustc_session::lint::Level;\n use rustc_span::Span;\n@@ -192,7 +192,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // This return type is usually `()`, unless the block is diverging, in which case the\n             // return type is `!`. For the unit type, we need to actually return the unit, but in\n             // the case of `!`, no return value is required, as the block will never return.\n-            if destination_ty.is_unit() {\n+            // Opaque types of empty bodies also need this unit assignment, in order to infer that their\n+            // type is actually unit. Otherwise there will be no defining use found in the MIR.\n+            if destination_ty.is_unit() || matches!(destination_ty.kind(), ty::Opaque(..)) {\n                 // We only want to assign an implicit `()` as the return value of the block if the\n                 // block does not diverge. (Otherwise, we may try to assign a unit to a `!`-type.)\n                 this.cfg.push_assign_unit(block, source_info, destination, this.tcx);"}, {"sha": "36f2a80773ea3af84b3a2384c600119d44e4178a", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -186,7 +186,6 @@ impl<K: DepKind> EncoderState<K> {\n         }\n     }\n \n-    #[instrument(level = \"debug\", skip(self, record_graph))]\n     fn encode_node(\n         &mut self,\n         node: &NodeInfo<K>,\n@@ -213,7 +212,6 @@ impl<K: DepKind> EncoderState<K> {\n             stat.edge_counter += edge_count as u64;\n         }\n \n-        debug!(?index, ?node);\n         let encoder = &mut self.encoder;\n         if self.result.is_ok() {\n             self.result = node.encode(encoder);"}, {"sha": "cd12430a2a249c5e0579a6c20b2fc2f67701c91a", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// purpose of this function is to do that translation.\n     ///\n     /// (*) C1 and C2 were introduced in the comments on\n-    /// `constrain_opaque_type`. Read that comment for more context.\n+    /// `register_member_constraints`. Read that comment for more context.\n     ///\n     /// # Parameters\n     ///\n@@ -48,6 +48,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         instantiated_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Ty<'tcx> {\n+        if self.is_tainted_by_errors() {\n+            return self.tcx.ty_error();\n+        }\n+\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n         // Use substs to build up a reverse map from regions to their\n@@ -67,7 +71,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // after producing an error for each of them.\n         let definition_ty = instantiated_ty.fold_with(&mut ReverseMapper::new(\n             self.tcx,\n-            self.is_tainted_by_errors(),\n             def_id,\n             map,\n             instantiated_ty,\n@@ -82,10 +85,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n struct ReverseMapper<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n-    /// If errors have already been reported in this fn, we suppress\n-    /// our own errors because they are sometimes derivative.\n-    tainted_by_errors: bool,\n-\n     opaque_type_def_id: DefId,\n     map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n     map_missing_regions_to_empty: bool,\n@@ -100,15 +99,13 @@ struct ReverseMapper<'tcx> {\n impl<'tcx> ReverseMapper<'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n-        tainted_by_errors: bool,\n         opaque_type_def_id: DefId,\n         map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n         hidden_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Self {\n         Self {\n             tcx,\n-            tainted_by_errors,\n             opaque_type_def_id,\n             map,\n             map_missing_regions_to_empty: false,\n@@ -167,9 +164,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n             Some(GenericArgKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None if self.map_missing_regions_to_empty || self.tainted_by_errors => {\n-                self.tcx.lifetimes.re_root_empty\n-            }\n+            None if self.map_missing_regions_to_empty => self.tcx.lifetimes.re_root_empty,\n             None if generics.parent.is_some() => {\n                 if let Some(hidden_ty) = self.hidden_ty.take() {\n                     unexpected_hidden_region_diagnostic(\n@@ -359,6 +354,7 @@ crate fn required_region_bounds<'tcx>(\n                 | ty::PredicateKind::RegionOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n                     // Search for a bound of the form `erased_self_ty"}, {"sha": "da04fb2cd2104241d99dc0ae180a2fb774c39baf", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -853,6 +853,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n             };\n         }"}, {"sha": "04a7da06063ba03098efd7a6e17a74d5d95cb817", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -90,6 +90,11 @@ pub fn codegen_fulfill_obligation<'tcx>(\n         });\n         let impl_source = drain_fulfillment_cx_or_panic(&infcx, &mut fulfill_cx, impl_source);\n \n+        // We may constrain the hidden types of opaque types in this query, but this is\n+        // not information our callers need, as all that information is handled by borrowck\n+        // and typeck.\n+        drop(infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types());\n+\n         debug!(\"Cache miss: {:?} => {:?}\", trait_ref, impl_source);\n         Ok(impl_source)\n     })"}, {"sha": "8624137d77687692f4041d78b8fd141d669b0403", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -775,6 +775,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         span,\n                         \"TypeWellFormedFromEnv predicate should only exist in the environment\"\n                     ),\n+\n+                    ty::PredicateKind::OpaqueType(..) => {\n+                        todo!(\"{:#?}\", obligation);\n+                    }\n                 }\n             }\n "}, {"sha": "51b8c9aca78b3d3b2bb231b20eca41e65b34f64d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1328,6 +1328,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ty::Generator(..) => \"generator\",\n             _ => \"function\",\n         };\n+        let span = self.tcx.sess.source_map().guess_head_span(span);\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -1680,6 +1681,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ));\n \n             let original_span = err.span.primary_span().unwrap();\n+            let original_span = self.tcx.sess.source_map().guess_head_span(original_span);\n             let mut span = MultiSpan::from_span(original_span);\n \n             let message = outer_generator"}, {"sha": "274f8a3ef79fa138d4c84caa74495b87f5d3539c", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -397,6 +397,9 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n+                ty::PredicateKind::OpaqueType(..) => {\n+                    todo!(\"{:#?}\", obligation);\n+                }\n             },\n             Some(pred) => match pred {\n                 ty::PredicateKind::Trait(data) => {\n@@ -642,6 +645,20 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n+                ty::PredicateKind::OpaqueType(a, b) => {\n+                    match self.selcx.infcx().handle_opaque_type(\n+                        a,\n+                        b,\n+                        &obligation.cause,\n+                        obligation.param_env,\n+                    ) {\n+                        Ok(value) => ProcessResult::Changed(mk_pending(value.obligations)),\n+                        Err(err) => ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(\n+                            ExpectedFound::new(true, a, b),\n+                            err,\n+                        )),\n+                    }\n+                }\n             },\n         }\n     }"}, {"sha": "cd6f381333ad0c4c21da8b6e5e892a3c3eb7a5d7", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -313,6 +313,7 @@ fn predicate_references_self<'tcx>(\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::OpaqueType(..)\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }\n@@ -347,6 +348,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n         }\n     })"}, {"sha": "3aa5ee366f78fa23d4f7284fcd2f2225a35cea5d", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -3,7 +3,7 @@ use crate::infer::{InferCtxt, InferOk};\n use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::query::type_op::TypeOpOutput;\n use crate::traits::query::Fallible;\n-use crate::traits::{ObligationCause, TraitEngine};\n+use crate::traits::TraitEngine;\n use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::DUMMY_SP;\n \n@@ -60,7 +60,6 @@ fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n ) -> Fallible<TypeOpOutput<'tcx, Op>> {\n     let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-    let dummy_body_id = ObligationCause::dummy().body_id;\n \n     // During NLL, we expect that nobody will register region\n     // obligations **except** as part of a custom type op (and, at the\n@@ -75,7 +74,6 @@ fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     );\n \n     let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n-    debug_assert!(obligations.iter().all(|o| o.cause.body_id == dummy_body_id));\n     fulfill_cx.register_predicate_obligations(infcx, obligations);\n     let errors = fulfill_cx.select_all_or_error(infcx);\n     if !errors.is_empty() {"}, {"sha": "0c5d764e79d0cb25a472294b607a3dbb71ce5e48", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -254,6 +254,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n+            debug!(ty = ?obligation.predicate.skip_binder().self_ty(), \"ambiguous inference var or opaque type\");\n             // Self is a type variable (e.g., `_: AsRef<str>`).\n             //\n             // This is somewhat problematic, as the current scheme can't really"}, {"sha": "a183a20a2fed0b5458f5b6ee74325d290057de1a", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -37,6 +37,7 @@ use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n+use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n@@ -697,6 +698,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n                 }\n+                ty::PredicateKind::OpaqueType(a, b) => {\n+                    match self.infcx().handle_opaque_type(\n+                        a,\n+                        b,\n+                        &obligation.cause,\n+                        obligation.param_env,\n+                    ) {\n+                        Ok(res) => {\n+                            self.evaluate_predicates_recursively(previous_stack, res.obligations)\n+                        }\n+                        Err(_) => Ok(EvaluatedToErr),\n+                    }\n+                }\n             }\n         });\n \n@@ -1337,6 +1351,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, param_env, cache_fresh_trait_pred, dep_node), level = \"debug\")]\n     fn insert_candidate_cache(\n         &mut self,\n         mut param_env: ty::ParamEnv<'tcx>,\n@@ -1377,17 +1392,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// a projection, look at the bounds of `T::Bar`, see if we can find a\n     /// `Baz` bound. We return indexes into the list returned by\n     /// `tcx.item_bounds` for any applicable bounds.\n+    #[instrument(level = \"debug\", skip(self))]\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> smallvec::SmallVec<[usize; 2]> {\n         let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n         let placeholder_trait_predicate =\n             self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n-        debug!(\n-            ?placeholder_trait_predicate,\n-            \"match_projection_obligation_against_definition_bounds\"\n-        );\n+        debug!(?placeholder_trait_predicate);\n \n         let tcx = self.infcx.tcx;\n         let (def_id, substs) = match *placeholder_trait_predicate.trait_ref.self_ty().kind() {\n@@ -1438,7 +1451,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n             .collect();\n \n-        debug!(?matching_bounds, \"match_projection_obligation_against_definition_bounds\");\n+        debug!(?matching_bounds);\n         matching_bounds\n     }\n \n@@ -1468,6 +1481,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         });\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n+            .define_opaque_types(false)\n             .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n             .map(|InferOk { obligations: _, value: () }| {\n                 // This method is called within a probe, so we can't have\n@@ -1523,6 +1537,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n+            .define_opaque_types(false)\n             .sup(obligation.predicate, infer_projection)\n             .map_or(false, |InferOk { obligations, value: () }| {\n                 self.evaluate_predicates_recursively(\n@@ -2081,11 +2096,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.match_impl(impl_def_id, obligation) {\n             Ok(substs) => substs,\n             Err(()) => {\n-                bug!(\n-                    \"Impl {:?} was matchable against {:?} but now is not\",\n-                    impl_def_id,\n-                    obligation\n+                self.infcx.tcx.sess.delay_span_bug(\n+                    obligation.cause.span,\n+                    &format!(\n+                        \"Impl {:?} was matchable against {:?} but now is not\",\n+                        impl_def_id, obligation\n+                    ),\n                 );\n+                let value = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);\n+                let err = self.tcx().ty_error();\n+                let value = value.fold_with(&mut BottomUpFolder {\n+                    tcx: self.tcx(),\n+                    ty_op: |_| err,\n+                    lt_op: |l| l,\n+                    ct_op: |c| c,\n+                });\n+                Normalized { value, obligations: vec![] }\n             }\n         }\n     }\n@@ -2222,6 +2248,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n+            // We don't want predicates for opaque types to just match all other types,\n+            // if there is an obligation on the opaque type, then that obligation must be met\n+            // opaquely. Otherwise we'd match any obligation to the opaque type and then error\n+            // out later.\n+            .define_opaque_types(false)\n             .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n             .map(|InferOk { obligations, .. }| obligations)\n             .map_err(|_| ())"}, {"sha": "68707fee44f99635bfbfe455034e8e61b03e56bb", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -146,6 +146,10 @@ pub fn predicate_obligations<'a, 'tcx>(\n             wf.compute(c1.into());\n             wf.compute(c2.into());\n         }\n+        ty::PredicateKind::OpaqueType(opaque, ty) => {\n+            wf.compute(opaque.into());\n+            wf.compute(ty.into());\n+        }\n         ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n             bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n         }"}, {"sha": "71ea77dc3791088caadda56d5db0e77fa79abb9f", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -110,6 +110,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n             };\n@@ -196,6 +197,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n             }\n@@ -610,6 +612,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }\n@@ -739,6 +742,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }"}, {"sha": "287538e0764d3d577d7726262f69d6107c01a75f", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -142,6 +142,7 @@ crate fn evaluate_goal<'tcx>(\n                 var_values: CanonicalVarValues { var_values },\n                 region_constraints: QueryRegionConstraints::default(),\n                 certainty: Certainty::Proven,\n+                opaque_types: vec![],\n                 value: (),\n             },\n         };\n@@ -170,6 +171,7 @@ crate fn evaluate_goal<'tcx>(\n                                     .make_identity(tcx),\n                                 region_constraints: QueryRegionConstraints::default(),\n                                 certainty: Certainty::Ambiguous,\n+                                opaque_types: vec![],\n                                 value: (),\n                             },\n                         };"}, {"sha": "1535a46a01b475b89dac7b17f678aeb5f482fc09", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -105,6 +105,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::OpaqueType(..)\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => vec![],\n                     ty::PredicateKind::WellFormed(arg) => {\n                         wf_args.push(arg);"}, {"sha": "c64e97074a6e02451066ff441eb2d7bc7d34f567", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -69,6 +69,7 @@ fn not_outlives_predicate<'tcx>(p: &ty::Predicate<'tcx>) -> bool {\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::OpaqueType(..)\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => true,\n     }\n }"}, {"sha": "741438b3d29cc773f02f9725fa7b78df3fc3ab6e", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -61,6 +61,14 @@ bitflags! {\n                                           | TypeFlags::HAS_CT_INFER.bits\n                                           | TypeFlags::HAS_TY_PLACEHOLDER.bits\n                                           | TypeFlags::HAS_CT_PLACEHOLDER.bits\n+                                          // The `evaluate_obligation` query does not return further\n+                                          // obligations. If it evaluates an obligation with an opaque\n+                                          // type, that opaque type may get compared to another type,\n+                                          // constraining it. We would lose this information.\n+                                          // FIXME: differentiate between crate-local opaque types\n+                                          // and opaque types from other crates, as only opaque types\n+                                          // from the local crate can possibly be a local name\n+                                          | TypeFlags::HAS_TY_OPAQUE.bits\n                                           // We consider 'freshened' types and constants\n                                           // to depend on a particular fn.\n                                           // The freshening process throws away information,"}, {"sha": "195fbd7752065298138b1d24f917366d03ea2880", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyS};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyS, TypeFoldable};\n use rustc_span::{MultiSpan, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n@@ -98,8 +98,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n             all_arms_diverge &= self.diverges.get();\n \n-            let opt_suggest_box_span =\n-                self.opt_suggest_box_span(arm.body.span, arm_ty, orig_expected);\n+            let opt_suggest_box_span = self.opt_suggest_box_span(arm_ty, orig_expected);\n \n             let (arm_span, semi_span) =\n                 self.get_appropriate_arm_semicolon_removal_span(&arms, i, prior_arm_ty, arm_ty);\n@@ -504,20 +503,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // provide a structured suggestion in that case.\n     pub(crate) fn opt_suggest_box_span(\n         &self,\n-        span: Span,\n         outer_ty: &'tcx TyS<'tcx>,\n         orig_expected: Expectation<'tcx>,\n     ) -> Option<Span> {\n-        match (orig_expected, self.ret_coercion_impl_trait.map(|ty| (self.body_id.owner, ty))) {\n-            (Expectation::ExpectHasType(expected), Some((_id, ty)))\n-                if self.in_tail_expr && self.can_coerce(outer_ty, expected) =>\n+        match orig_expected {\n+            Expectation::ExpectHasType(expected)\n+                if self.in_tail_expr\n+                    && self.ret_coercion.as_ref()?.borrow().merged_ty().has_opaque_types()\n+                    && self.can_coerce(outer_ty, expected) =>\n             {\n-                let impl_trait_ret_ty =\n-                    self.infcx.instantiate_opaque_types(self.body_id, self.param_env, ty, span);\n-                assert!(\n-                    impl_trait_ret_ty.obligations.is_empty(),\n-                    \"we should never get new obligations here\"\n-                );\n                 let obligations = self.fulfillment_cx.borrow().pending_obligations();\n                 let mut suggest_box = !obligations.is_empty();\n                 for o in obligations {"}, {"sha": "19c3f00ed9357c155fbbbd1539aa8eef7e26f5cf", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -545,7 +545,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Expectation<'tcx>,\n         fn_sig: ty::FnSig<'tcx>,\n     ) -> Ty<'tcx> {\n-        // `fn_sig` is the *signature* of the cosure being called. We\n+        // `fn_sig` is the *signature* of the closure being called. We\n         // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n         // do know the types expected for each argument and the return\n         // type."}, {"sha": "d10d3e43b5b18fc8f58941bcb16cf742baa53e85", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 15, "deletions": 37, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::layout::MAX_SIMD_LANES;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, OpaqueTypeKey, ParamEnv, RegionKind, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ParamEnv, RegionKind, Ty, TyCtxt};\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n@@ -81,8 +81,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n     can_be_generator: Option<hir::Movability>,\n     return_type_pre_known: bool,\n ) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n-    let mut fn_sig = fn_sig;\n-\n     // Create the function context. This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n@@ -95,21 +93,8 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     let declared_ret_ty = fn_sig.output();\n \n-    let revealed_ret_ty =\n-        fcx.instantiate_opaque_types_from_value(declared_ret_ty, decl.output.span());\n-    debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n-    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n+    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(declared_ret_ty)));\n     fcx.ret_type_span = Some(decl.output.span());\n-    if let ty::Opaque(..) = declared_ret_ty.kind() {\n-        fcx.ret_coercion_impl_trait = Some(declared_ret_ty);\n-    }\n-    fn_sig = tcx.mk_fn_sig(\n-        fn_sig.inputs().iter().cloned(),\n-        revealed_ret_ty,\n-        fn_sig.c_variadic,\n-        fn_sig.unsafety,\n-        fn_sig.abi,\n-    );\n \n     let span = body.value.span;\n \n@@ -251,7 +236,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n             fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::DynReturnFn, span });\n         debug!(\"actual_return_ty replaced with {:?}\", actual_return_ty);\n     }\n-    fcx.demand_suptype(span, revealed_ret_ty, actual_return_ty);\n+    fcx.demand_suptype(span, declared_ret_ty, actual_return_ty);\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n@@ -629,6 +614,8 @@ fn check_opaque_meets_bounds<'tcx>(\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n ) {\n+    let hidden_type = tcx.type_of(def_id).subst(tcx, substs);\n+\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let defining_use_anchor = match *origin {\n         hir::OpaqueTyOrigin::FnReturn(did) | hir::OpaqueTyOrigin::AsyncFn(did) => did,\n@@ -643,24 +630,12 @@ fn check_opaque_meets_bounds<'tcx>(\n \n         let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-        let _ = inh.register_infer_ok_obligations(\n-            infcx.instantiate_opaque_types(hir_id, param_env, opaque_ty, span),\n-        );\n-\n-        let opaque_type_map = infcx.inner.borrow().opaque_types.clone();\n-        for (OpaqueTypeKey { def_id, substs }, opaque_defn) in opaque_type_map {\n-            let hidden_type = tcx.type_of(def_id).subst(tcx, substs);\n-            trace!(?hidden_type);\n-            match infcx.at(&misc_cause, param_env).eq(opaque_defn.concrete_ty, hidden_type) {\n-                Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n-                Err(ty_err) => tcx.sess.delay_span_bug(\n-                    span,\n-                    &format!(\n-                        \"could not check bounds on revealed type `{}`:\\n{}\",\n-                        hidden_type, ty_err,\n-                    ),\n-                ),\n-            }\n+        match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n+            Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n+            Err(ty_err) => tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\"could not unify `{}` with revealed type:\\n{}\", hidden_type, ty_err,),\n+            ),\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n@@ -672,7 +647,7 @@ fn check_opaque_meets_bounds<'tcx>(\n \n         match origin {\n             // Checked when type checking the function containing them.\n-            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => return,\n+            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n             // Can have different predicates to their defining use\n             hir::OpaqueTyOrigin::TyAlias => {\n                 // Finally, resolve all regions. This catches wily misuses of\n@@ -681,6 +656,9 @@ fn check_opaque_meets_bounds<'tcx>(\n                 fcx.regionck_item(hir_id, span, FxHashSet::default());\n             }\n         }\n+\n+        // Clean up after ourselves\n+        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n     });\n }\n "}, {"sha": "d4336563b96037bf7c8ff948b4b6b8a1c3f05483", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 79, "deletions": 16, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -3,16 +3,20 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use crate::astconv::AstConv;\n+use crate::rustc_middle::ty::subst::Subst;\n+use hir::OpaqueTyOrigin;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n+use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n@@ -172,6 +176,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n+            ty::Opaque(def_id, substs) => {\n+                let bounds = self.tcx.explicit_item_bounds(def_id);\n+                let sig = bounds.iter().find_map(|(pred, span)| match pred.kind().skip_binder() {\n+                    ty::PredicateKind::Projection(proj_predicate) => self\n+                        .deduce_sig_from_projection(\n+                            Some(*span),\n+                            pred.kind().rebind(proj_predicate.subst(self.tcx, substs)),\n+                        ),\n+                    _ => None,\n+                });\n+\n+                let kind = bounds\n+                    .iter()\n+                    .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n+                        ty::PredicateKind::Trait(tp) => {\n+                            self.tcx.fn_trait_kind_from_lang_item(tp.def_id())\n+                        }\n+                        _ => None,\n+                    })\n+                    .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n+                trace!(?sig, ?kind);\n+                (sig, kind)\n+            }\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n@@ -197,10 +224,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         let expected_sig =\n             self.obligations_for_self_ty(expected_vid).find_map(|(_, obligation)| {\n-                debug!(\n-                    \"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n-                    obligation.predicate\n-                );\n+                debug!(?obligation.predicate);\n \n                 let bound_predicate = obligation.predicate.kind();\n                 if let ty::PredicateKind::Projection(proj_predicate) =\n@@ -401,9 +425,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // in this binder we are creating.\n         assert!(!expected_sig.sig.skip_binder().has_vars_bound_above(ty::INNERMOST));\n         let bound_sig = expected_sig.sig.map_bound(|sig| {\n+            let output = self.hide_parent_opaque_types(\n+                sig.output(),\n+                expected_sig.cause_span.unwrap_or(DUMMY_SP),\n+                body.id().hir_id,\n+            );\n             self.tcx.mk_fn_sig(\n                 sig.inputs().iter().cloned(),\n-                sig.output(),\n+                output,\n                 sig.c_variadic,\n                 hir::Unsafety::Normal,\n                 Abi::RustCall,\n@@ -590,6 +619,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => astconv.ty_infer(None, decl.output.span()),\n             },\n         };\n+        let supplied_return =\n+            self.hide_parent_opaque_types(supplied_return, decl.output.span(), body.id().hir_id);\n \n         let result = ty::Binder::bind_with_vars(\n             self.tcx.mk_fn_sig(\n@@ -610,45 +641,77 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         result\n     }\n \n+    fn hide_parent_opaque_types(&self, ty: Ty<'tcx>, span: Span, body_id: hir::HirId) -> Ty<'tcx> {\n+        ty.fold_with(&mut ty::fold::BottomUpFolder {\n+            tcx: self.infcx.tcx,\n+            lt_op: |lt| lt,\n+            ct_op: |ct| ct,\n+            ty_op: |ty| match *ty.kind() {\n+                // Closures can't create hidden types for opaque types of their parent, as they\n+                // do not have all the outlives information available. Also `type_of` looks for\n+                // hidden types in the owner (so the closure's parent), so it would not find these\n+                // definitions.\n+                ty::Opaque(def_id, _substs)\n+                    if matches!(\n+                        self.infcx.opaque_type_origin(def_id, DUMMY_SP),\n+                        Some(OpaqueTyOrigin::FnReturn(..))\n+                    ) =>\n+                {\n+                    let ty_var = self.next_ty_var(TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::TypeInference,\n+                        span,\n+                    });\n+                    let cause = ObligationCause::misc(span, body_id);\n+                    self.register_predicates(vec![self.infcx.opaque_ty_obligation(\n+                        ty,\n+                        ty_var,\n+                        true,\n+                        self.param_env,\n+                        cause,\n+                    )]);\n+                    ty_var\n+                }\n+                _ => ty,\n+            },\n+        })\n+    }\n+\n     /// Invoked when we are translating the generator that results\n     /// from desugaring an `async fn`. Returns the \"sugared\" return\n     /// type of the `async fn` -- that is, the return type that the\n     /// user specified. The \"desugared\" return type is an `impl\n     /// Future<Output = T>`, so we do this by searching through the\n     /// obligations to extract the `T`.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn deduce_future_output_from_obligations(&self, expr_def_id: DefId) -> Option<Ty<'tcx>> {\n-        debug!(\"deduce_future_output_from_obligations(expr_def_id={:?})\", expr_def_id);\n-\n         let ret_coercion = self.ret_coercion.as_ref().unwrap_or_else(|| {\n             span_bug!(self.tcx.def_span(expr_def_id), \"async fn generator outside of a fn\")\n         });\n \n-        // In practice, the return type of the surrounding function is\n-        // always a (not yet resolved) inference variable, because it\n-        // is the hidden type for an `impl Trait` that we are going to\n-        // be inferring.\n         let ret_ty = ret_coercion.borrow().expected_ty();\n         let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n-        let ret_vid = match *ret_ty.kind() {\n-            ty::Infer(ty::TyVar(ret_vid)) => ret_vid,\n+        let (def_id, substs) = match *ret_ty.kind() {\n+            ty::Opaque(def_id, substs) => (def_id, substs),\n             ty::Error(_) => return None,\n             _ => span_bug!(\n                 self.tcx.def_span(expr_def_id),\n                 \"async fn generator return type not an inference variable\"\n             ),\n         };\n \n+        let item_bounds = self.tcx.explicit_item_bounds(def_id);\n+\n         // Search for a pending obligation like\n         //\n         // `<R as Future>::Output = T`\n         //\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n-        let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            let bound_predicate = obligation.predicate.kind();\n+        let output_ty = item_bounds.iter().find_map(|&(predicate, span)| {\n+            let bound_predicate = predicate.subst(self.tcx, substs).kind();\n             if let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder() {\n                 self.deduce_future_output_from_projection(\n-                    obligation.cause.span,\n+                    span,\n                     bound_predicate.rebind(proj_predicate),\n                 )\n             } else {"}, {"sha": "8204a25e9112b71d99cea21425fefa753227178c", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1275,7 +1275,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n     /// Returns the current \"merged type\", representing our best-guess\n     /// at the LUB of the expressions we've seen so far (if any). This\n-    /// isn't *final* until you call `self.final()`, which will return\n+    /// isn't *final* until you call `self.complete()`, which will return\n     /// the merged type.\n     pub fn merged_ty(&self) -> Ty<'tcx> {\n         self.final_ty.unwrap_or(self.expected_ty)"}, {"sha": "9e1a70b7dfb929382497d1cdcbb5c15da3195694", "filename": "compiler/rustc_typeck/src/check/expectation.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,5 +1,6 @@\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::{self, Ty};\n+use rustc_span::DUMMY_SP;\n use rustc_span::{self, Span};\n \n use super::Expectation::*;\n@@ -43,7 +44,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     // when checking the 'then' block which are incompatible with the\n     // 'else' branch.\n     pub(super) fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n-        match *self {\n+        match self.strip_opaque(fcx) {\n             ExpectHasType(ety) => {\n                 let ety = fcx.shallow_resolve(ety);\n                 if !ety.is_ty_var() { ExpectHasType(ety) } else { NoExpectation }\n@@ -104,14 +105,35 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// for the program to type-check). `only_has_type` will return\n     /// such a constraint, if it exists.\n     pub(super) fn only_has_type(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n-        match self {\n-            ExpectHasType(ty) => Some(fcx.resolve_vars_if_possible(ty)),\n+        match self.strip_opaque(fcx) {\n+            ExpectHasType(ty) => Some(ty),\n             NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) | IsLast(_) => {\n                 None\n             }\n         }\n     }\n \n+    /// We must not treat opaque types as expected types in their defining scope, as that\n+    /// will break `fn foo() -> impl Trait { if cond { a } else { b } }` if `a` and `b` are\n+    /// only \"equal\" if they coerce to a common target, like two different function items\n+    /// coercing to a function pointer if they have the same signature.\n+    fn strip_opaque(self, fcx: &FnCtxt<'a, 'tcx>) -> Self {\n+        match self {\n+            ExpectHasType(ty) => {\n+                let ty = fcx.resolve_vars_if_possible(ty);\n+                match *ty.kind() {\n+                    ty::Opaque(def_id, _)\n+                        if fcx.infcx.opaque_type_origin(def_id, DUMMY_SP).is_some() =>\n+                    {\n+                        NoExpectation\n+                    }\n+                    _ => self,\n+                }\n+            }\n+            _ => self,\n+        }\n+    }\n+\n     /// Like `only_has_type`, but instead of returning `None` if no\n     /// hard constraint exists, creates a fresh type variable.\n     pub(super) fn coercion_target_type(self, fcx: &FnCtxt<'a, 'tcx>, span: Span) -> Ty<'tcx> {"}, {"sha": "74341fef38e27ee0760f68f46fad146547c8cb61", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -956,8 +956,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             let else_diverges = self.diverges.get();\n \n-            let opt_suggest_box_span =\n-                self.opt_suggest_box_span(else_expr.span, else_ty, orig_expected);\n+            let opt_suggest_box_span = self.opt_suggest_box_span(else_ty, orig_expected);\n             let if_cause =\n                 self.if_cause(sp, then_expr, else_expr, then_ty, else_ty, opt_suggest_box_span);\n "}, {"sha": "85132317824076160bf8b538e3d2f0ab582625fc", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             self.fulfillment_cx.borrow_mut().pending_obligations()\n         );\n \n-        // Check if we have any unsolved varibales. If not, no need for fallback.\n+        // Check if we have any unsolved variables. If not, no need for fallback.\n         let unsolved_variables = self.unsolved_variables();\n         if unsolved_variables.is_empty() {\n             return false;\n@@ -66,16 +66,6 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // refer to opaque types.\n         self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n \n-        // We now run fallback again, but this time we allow it to replace\n-        // unconstrained opaque type variables, in addition to performing\n-        // other kinds of fallback.\n-        for ty in &self.unsolved_variables() {\n-            fallback_has_occurred |= self.fallback_opaque_type_vars(ty);\n-        }\n-\n-        // See if we can make any more progress.\n-        self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n-\n         fallback_has_occurred\n     }\n \n@@ -136,59 +126,6 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         true\n     }\n \n-    /// Second round of fallback: Unconstrained type variables created\n-    /// from the instantiation of an opaque type fall back to the\n-    /// opaque type itself. This is a somewhat incomplete attempt to\n-    /// manage \"identity passthrough\" for `impl Trait` types.\n-    ///\n-    /// For example, in this code:\n-    ///\n-    ///```\n-    /// type MyType = impl Copy;\n-    /// fn defining_use() -> MyType { true }\n-    /// fn other_use() -> MyType { defining_use() }\n-    /// ```\n-    ///\n-    /// `defining_use` will constrain the instantiated inference\n-    /// variable to `bool`, while `other_use` will constrain\n-    /// the instantiated inference variable to `MyType`.\n-    ///\n-    /// When we process opaque types during writeback, we\n-    /// will handle cases like `other_use`, and not count\n-    /// them as defining usages\n-    ///\n-    /// However, we also need to handle cases like this:\n-    ///\n-    /// ```rust\n-    /// pub type Foo = impl Copy;\n-    /// fn produce() -> Option<Foo> {\n-    ///     None\n-    ///  }\n-    ///  ```\n-    ///\n-    /// In the above snippet, the inference variable created by\n-    /// instantiating `Option<Foo>` will be completely unconstrained.\n-    /// We treat this as a non-defining use by making the inference\n-    /// variable fall back to the opaque type itself.\n-    fn fallback_opaque_type_vars(&self, ty: Ty<'tcx>) -> bool {\n-        let span = self\n-            .infcx\n-            .type_var_origin(ty)\n-            .map(|origin| origin.span)\n-            .unwrap_or(rustc_span::DUMMY_SP);\n-        let oty = self.inner.borrow().opaque_types_vars.get(ty).copied();\n-        if let Some(opaque_ty) = oty {\n-            debug!(\n-                \"fallback_opaque_type_vars(ty={:?}): falling back to opaque type {:?}\",\n-                ty, opaque_ty\n-            );\n-            self.demand_eqtype(span, ty, opaque_ty);\n-            true\n-        } else {\n-            return false;\n-        }\n-    }\n-\n     /// The \"diverging fallback\" system is rather complicated. This is\n     /// a result of our need to balance 'do the right thing' with\n     /// backwards compatibility."}, {"sha": "e60893a658b3dc31b1211ebca0e5f1d9dda7de9d", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -367,23 +367,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (result, spans)\n     }\n \n-    /// Replaces the opaque types from the given value with type variables,\n-    /// and records the `OpaqueTypeMap` for later use during writeback. See\n-    /// `InferCtxt::instantiate_opaque_types` for more details.\n-    #[instrument(skip(self, value_span), level = \"debug\")]\n-    pub(in super::super) fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n-        &self,\n-        value: T,\n-        value_span: Span,\n-    ) -> T {\n-        self.register_infer_ok_obligations(self.instantiate_opaque_types(\n-            self.body_id,\n-            self.param_env,\n-            value,\n-            value_span,\n-        ))\n-    }\n-\n     /// Convenience method which tracks extra diagnostic information for normalization\n     /// that occurs as a result of WF checking. The `hir_id` is the `HirId` of the hir item\n     /// whose type is being wf-checked - this is used to construct a more precise span if\n@@ -720,6 +703,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // inference variable.\n                     ty::PredicateKind::ClosureKind(..) => None,\n                     ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+                    ty::PredicateKind::OpaqueType(..) => None,\n                 }\n             })\n             .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))"}, {"sha": "234775ab45269c7845443fd67a7e9c34003ab841", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -57,8 +57,6 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// any).\n     pub(super) ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n \n-    pub(super) ret_coercion_impl_trait: Option<Ty<'tcx>>,\n-\n     pub(super) ret_type_span: Option<Span>,\n \n     /// Used exclusively to reduce cost of advanced evaluation used for\n@@ -130,7 +128,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n-            ret_coercion_impl_trait: None,\n             ret_type_span: None,\n             in_tail_expr: false,\n             ret_coercion_span: Cell::new(None),"}, {"sha": "b775f24f8efd85f506b0b10cb01e720d0716873e", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -95,6 +95,13 @@ impl<'tcx> InheritedBuilder<'tcx> {\n         let def_id = self.def_id;\n         self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n     }\n+\n+    /// WF-checking doesn't need to recompute opaque types and can instead use\n+    /// the type_of query to get them from typeck.\n+    pub fn reveal_defining_opaque_types(mut self) -> Self {\n+        self.infcx = self.infcx.reveal_defining_opaque_types();\n+        self\n+    }\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n@@ -119,8 +126,8 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn register_predicate(&self, obligation: traits::PredicateObligation<'tcx>) {\n-        debug!(\"register_predicate({:?})\", obligation);\n         if obligation.has_escaping_bound_vars() {\n             span_bug!(obligation.cause.span, \"escaping bound vars in predicate {:?}\", obligation);\n         }"}, {"sha": "b8a45133fd7ea8361c896ef16db507e6d8c80542", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -858,6 +858,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 | ty::PredicateKind::TypeOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             }\n         });\n@@ -1477,6 +1478,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             TraitCandidate(trait_ref) => self.probe(|_| {\n                 let _ = self\n                     .at(&ObligationCause::dummy(), self.param_env)\n+                    .define_opaque_types(false)\n                     .sup(candidate.xform_self_ty, self_ty);\n                 match self.select_trait_candidate(trait_ref) {\n                     Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n@@ -1506,6 +1508,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // First check that the self type can be related.\n             let sub_obligations = match self\n                 .at(&ObligationCause::dummy(), self.param_env)\n+                .define_opaque_types(false)\n                 .sup(probe.xform_self_ty, self_ty)\n             {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n@@ -1653,6 +1656,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     );\n                     if self\n                         .at(&ObligationCause::dummy(), self.param_env)\n+                        .define_opaque_types(false)\n                         .sup(return_ty, xform_ret_ty)\n                         .is_err()\n                     {"}, {"sha": "d4be3889a7ae7e1dcee977a2f19324fdd4feba24", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -341,6 +341,7 @@ fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::T\n     typeck_with_fallback(tcx, def_id, fallback)\n }\n \n+#[instrument(skip(tcx, fallback))]\n fn typeck_with_fallback<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,"}, {"sha": "0482e8b895b5684711a42d5a1d5500d4f546d5df", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -335,11 +335,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     // Returns a list of `Ty`s for each upvar.\n     fn final_upvar_tys(&self, closure_id: DefId) -> Vec<Ty<'tcx>> {\n-        // Presently an unboxed closure type cannot \"escape\" out of a\n-        // function, so we will only encounter ones that originated in the\n-        // local crate or were inlined into it along with some function.\n-        // This may change if abstract return types of some sort are\n-        // implemented.\n         self.typeck_results\n             .borrow()\n             .closure_min_captures_flattened(closure_id)"}, {"sha": "c0fa673774ffdb3e125e9510c47a6767ffd40d55", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -895,7 +895,7 @@ fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<\n \n fn for_id(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> CheckWfFcxBuilder<'_> {\n     CheckWfFcxBuilder {\n-        inherited: Inherited::build(tcx, def_id),\n+        inherited: Inherited::build(tcx, def_id).reveal_defining_opaque_types(),\n         id: hir::HirId::make_owner(def_id),\n         span,\n         param_env: tcx.param_env(def_id),"}, {"sha": "e04c1423cdac81f567c8b41f119778c221c766a2", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 12, "deletions": 59, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -18,7 +18,6 @@ use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::{self, ClosureSizeProfileData, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n use std::mem;\n \n@@ -65,7 +64,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n-        wbcx.visit_opaque_types(body.value.span);\n+        wbcx.visit_opaque_types();\n         wbcx.visit_coercion_casts();\n         wbcx.visit_user_provided_tys();\n         wbcx.visit_user_provided_sigs();\n@@ -496,64 +495,18 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             fcx_typeck_results.generator_interior_types.clone();\n     }\n \n-    #[instrument(skip(self, span), level = \"debug\")]\n-    fn visit_opaque_types(&mut self, span: Span) {\n-        let opaque_types = self.fcx.infcx.inner.borrow().opaque_types.clone();\n-        for (opaque_type_key, opaque_defn) in opaque_types {\n-            let hir_id =\n-                self.tcx().hir().local_def_id_to_hir_id(opaque_type_key.def_id.expect_local());\n-            let instantiated_ty = self.resolve(opaque_defn.concrete_ty, &hir_id);\n-\n-            debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n-\n-            let opaque_type_key = self.fcx.fully_resolve(opaque_type_key).unwrap();\n-\n-            // Prevent:\n-            // * `fn foo<T>() -> Foo<T>`\n-            // * `fn foo<T: Bound + Other>() -> Foo<T>`\n-            // from being defining.\n-\n-            // Also replace all generic params with the ones from the opaque type\n-            // definition so that\n-            // ```rust\n-            // type Foo<T> = impl Baz + 'static;\n-            // fn foo<U>() -> Foo<U> { .. }\n-            // ```\n-            // figures out the concrete type with `U`, but the stored type is with `T`.\n-\n-            // FIXME: why are we calling this here? This seems too early, and duplicated.\n-            let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n-                opaque_type_key,\n-                instantiated_ty,\n-                span,\n-            );\n-\n-            let mut skip_add = false;\n-\n-            if let ty::Opaque(definition_ty_def_id, _substs) = *definition_ty.kind() {\n-                if opaque_defn.origin == hir::OpaqueTyOrigin::TyAlias {\n-                    if opaque_type_key.def_id == definition_ty_def_id {\n-                        debug!(\n-                            \"skipping adding concrete definition for opaque type {:?} {:?}\",\n-                            opaque_defn, opaque_type_key.def_id\n-                        );\n-                        skip_add = true;\n-                    }\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_opaque_types(&mut self) {\n+        let opaque_types =\n+            self.fcx.infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        for (opaque_type_key, decl) in opaque_types {\n+            let hidden_type = match decl.origin {\n+                hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_) => {\n+                    Some(self.resolve(decl.hidden_type.ty, &decl.hidden_type.span))\n                 }\n-            }\n-\n-            if opaque_type_key.substs.needs_infer() {\n-                span_bug!(span, \"{:#?} has inference variables\", opaque_type_key.substs)\n-            }\n-\n-            // We only want to add an entry into `concrete_opaque_types`\n-            // if we actually found a defining usage of this opaque type.\n-            // Otherwise, we do nothing - we'll either find a defining usage\n-            // in some other location, or we'll end up emitting an error due\n-            // to the lack of defining usage\n-            if !skip_add {\n-                self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id);\n-            }\n+                hir::OpaqueTyOrigin::TyAlias => None,\n+            };\n+            self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id, hidden_type);\n         }\n     }\n "}, {"sha": "912a16ffb8a13aca0efe3895f26fcbeb0ed49a73", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -389,28 +389,22 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         .get_value_matching(|(key, _)| key.def_id == def_id.to_def_id())\n                         .copied()\n                         .unwrap_or_else(|| {\n-                            tcx.sess.delay_span_bug(\n-                                DUMMY_SP,\n-                                &format!(\n-                                    \"owner {:?} has no opaque type for {:?} in its typeck results\",\n-                                    owner, def_id,\n-                                ),\n-                            );\n-                            if let Some(ErrorReported) =\n-                                tcx.typeck(owner).tainted_by_errors\n-                            {\n+                            let table = tcx.typeck(owner);\n+                            if let Some(ErrorReported) = table.tainted_by_errors {\n                                 // Some error in the\n                                 // owner fn prevented us from populating\n                                 // the `concrete_opaque_types` table.\n                                 tcx.ty_error()\n                             } else {\n-                                // We failed to resolve the opaque type or it\n-                                // resolves to itself. Return the non-revealed\n-                                // type, which should result in E0720.\n-                                tcx.mk_opaque(\n-                                    def_id.to_def_id(),\n-                                    InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n-                                )\n+                                table.concrete_opaque_types.get(&def_id.to_def_id()).copied().unwrap_or_else(|| {\n+                                    // We failed to resolve the opaque type or it\n+                                    // resolves to itself. We interpret this as the\n+                                    // no values of the hidden type ever being constructed,\n+                                    // so we can just make the hidden type be `!`.\n+                                    // For backwards compatibility reasons, we fall back to\n+                                    // `()` until we the diverging default is changed.\n+                                    Some(tcx.mk_diverging_default())\n+                                }).expect(\"RPIT always have a hidden type from typeck\")\n                             }\n                         });\n                     debug!(\"concrete_ty = {:?}\", concrete_ty);\n@@ -604,7 +598,21 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             }\n             // Calling `mir_borrowck` can lead to cycle errors through\n             // const-checking, avoid calling it if we don't have to.\n-            if !self.tcx.typeck(def_id).concrete_opaque_types.contains(&self.def_id) {\n+            // ```rust\n+            // type Foo = impl Fn() -> usize; // when computing type for this\n+            // const fn bar() -> Foo {\n+            //     || 0usize\n+            // }\n+            // const BAZR: Foo = bar(); // we would mir-borrowck this, causing cycles\n+            // // because we again need to reveal `Foo` so we can check whether the\n+            // // constant does not contain interior mutability.\n+            // ```\n+            let tables = self.tcx.typeck(def_id);\n+            if let Some(_) = tables.tainted_by_errors {\n+                self.found = Some((DUMMY_SP, self.tcx.ty_error()));\n+                return;\n+            }\n+            if tables.concrete_opaque_types.get(&self.def_id).is_none() {\n                 debug!(\"no constraints in typeck results\");\n                 return;\n             }\n@@ -658,23 +666,23 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            trace!(?it.def_id);\n             // The opaque type itself or its children are not within its reveal scope.\n             if it.def_id.to_def_id() != self.def_id {\n                 self.check(it.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            trace!(?it.def_id);\n             // The opaque type itself or its children are not within its reveal scope.\n             if it.def_id.to_def_id() != self.def_id {\n                 self.check(it.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            trace!(?it.def_id);\n             self.check(it.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n@@ -684,12 +692,12 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     let scope = tcx.hir().get_defining_scope(hir_id);\n     let mut locator = ConstraintLocator { def_id: def_id.to_def_id(), tcx, found: None };\n \n-    debug!(\"find_opaque_ty_constraints: scope={:?}\", scope);\n+    debug!(?scope);\n \n     if scope == hir::CRATE_HIR_ID {\n         tcx.hir().walk_toplevel_module(&mut locator);\n     } else {\n-        debug!(\"find_opaque_ty_constraints: scope={:?}\", tcx.hir().get(scope));\n+        trace!(\"scope={:#?}\", tcx.hir().get(scope));\n         match tcx.hir().get(scope) {\n             // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n             // This allows our visitor to process the defining item itself, causing\n@@ -716,7 +724,12 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n         Some((_, ty)) => ty,\n         None => {\n             let span = tcx.def_span(def_id);\n-            tcx.sess.span_err(span, \"could not find defining uses\");\n+            let name = tcx.item_name(tcx.parent(def_id.to_def_id()).unwrap());\n+            let label = format!(\n+                \"`{}` must be used in combination with a concrete type within the same module\",\n+                name\n+            );\n+            tcx.sess.struct_span_err(span, \"unconstrained opaque type\").note(&label).emit();\n             tcx.ty_error()\n         }\n     }"}, {"sha": "4227ed6ab3ad58af53068ef42a51ab51d20f74f0", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -427,6 +427,7 @@ fn trait_predicate_kind<'tcx>(\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::OpaqueType(..)\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }"}, {"sha": "7839ce5e4ff48e51739b2b23808eec60eab27c14", "filename": "compiler/rustc_typeck/src/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -59,6 +59,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     | ty::PredicateKind::Coerce(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::OpaqueType(..)\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => (),\n                 }\n             }"}, {"sha": "d9467e8fd6bc13f86c3c043f5d1f8bfdec1627df", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -147,6 +147,12 @@ fn main() {\n         cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n     }\n \n+    if let Ok(flags) = env::var(\"MAGIC_EXTRA_RUSTFLAGS\") {\n+        for flag in flags.split(' ') {\n+            cmd.arg(flag);\n+        }\n+    }\n+\n     let is_test = args.iter().any(|a| a == \"--test\");\n     if verbose > 2 {\n         let rust_env_vars ="}, {"sha": "66cbf884a027b735aa697ccf7a723f5b96c04a83", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -297,6 +297,7 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => panic!(\"not user writable\"),\n         }\n     }"}, {"sha": "31564a0cbd5c64a059d7d412301b2e493a9382ba", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -305,7 +305,7 @@ pub fn return_impl_trait() -> i32        {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig, optimized_mir\")]\n #[rustc_clean(cfg = \"cfail3\")]\n #[rustc_clean(cfg = \"cfail5\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig, optimized_mir\")]\n #[rustc_clean(cfg = \"cfail6\")]"}, {"sha": "67b97c21805e684cf757c1f0ef7d6d3af2e5ec37", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -30,7 +30,7 @@ impl Thing for AssocNoCopy {\n     type Out = Box<dyn Bar<Assoc: Copy>>;\n \n     fn func() -> Self::Out {\n-        //~^ ERROR the trait bound `String: Copy` is not satisfied\n         Box::new(AssocNoCopy)\n+        //~^ ERROR the trait bound `String: Copy` is not satisfied\n     }\n }"}, {"sha": "f1dcd34066dbc6bfda6d3db2cf565f5029f53ef2", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,10 @@\n error[E0277]: the trait bound `String: Copy` is not satisfied\n-  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:32:18\n+  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:33:9\n    |\n-LL |     fn func() -> Self::Out {\n-   |                  ^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+LL |         Box::new(AssocNoCopy)\n+   |         ^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+   = note: required for the cast to the object type `dyn Bar<Assoc = <AssocNoCopy as Thing>::Out::{opaque#0}>`\n \n error: aborting due to previous error\n "}, {"sha": "30e4c1a3c537ba944b33af3544a6f29adb310ec6", "filename": "src/test/ui/associated-types/impl-trait-return-missing-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -23,8 +23,8 @@ fn bar() -> impl Bar {\n }\n \n fn baz() -> impl Bar<Item = i32> {\n-//~^ ERROR type mismatch resolving `<impl Bar as Foo>::Item == i32`\n     bar()\n+    //~^ ERROR type mismatch resolving `<impl Bar as Foo>::Item == i32`\n }\n \n fn main() {"}, {"sha": "9523a54d954df0feb04d8715b818b744c4eba4fd", "filename": "src/test/ui/associated-types/impl-trait-return-missing-constraint.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,14 +1,16 @@\n error[E0271]: type mismatch resolving `<impl Bar as Foo>::Item == i32`\n-  --> $DIR/impl-trait-return-missing-constraint.rs:25:13\n+  --> $DIR/impl-trait-return-missing-constraint.rs:26:5\n    |\n LL | fn bar() -> impl Bar {\n-   |             -------- the found opaque type\n+   |             -------- the expected opaque type\n ...\n-LL | fn baz() -> impl Bar<Item = i32> {\n-   |             ^^^^^^^^^^^^^^^^^^^^ expected `i32`, found associated type\n+LL |     bar()\n+   |     ^^^^^ expected associated type, found `i32`\n    |\n-   = note:         expected type `i32`\n-           found associated type `<impl Bar as Foo>::Item`\n+   = note: expected associated type `<impl Bar as Foo>::Item`\n+                         found type `i32`\n+   = help: consider constraining the associated type `<impl Bar as Foo>::Item` to `i32` or calling a method that returns `<impl Bar as Foo>::Item`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n help: consider constraining the associated type `<impl Bar as Foo>::Item` to `i32`\n    |\n LL | fn bar() -> impl Bar<Item = i32> {"}, {"sha": "f21c811512416a34728af743624f6563dfe7def1", "filename": "src/test/ui/async-await/async-borrowck-escaping-block-error.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,10 +8,10 @@ LL |     Box::new(async { x } )\n    |                    may outlive borrowed value `x`\n    |\n note: async block is returned here\n-  --> $DIR/async-borrowck-escaping-block-error.rs:4:20\n+  --> $DIR/async-borrowck-escaping-block-error.rs:6:5\n    |\n-LL | fn test_boxed() -> Box<impl std::future::Future<Output = u32>> {\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     Box::new(async { x } )\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n help: to force the async block to take ownership of `x` (and any other referenced variables), use the `move` keyword\n    |\n LL |     Box::new(async move { x } )"}, {"sha": "7cb02e5cf383d14cefb08b06ce701fd9bd49ebb6", "filename": "src/test/ui/async-await/issue-64130-4-async-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -13,9 +13,9 @@ impl Client {\n async fn get() { }\n \n pub fn foo() -> impl Future + Send {\n-    //~^ ERROR future cannot be sent between threads safely\n     let client = Client(Box::new(true));\n     async move {\n+        //~^ ERROR future cannot be sent between threads safely\n         match client.status() {\n             200 => {\n                 let _x = get().await;"}, {"sha": "3a84907e0c04b31790fdf2742a4733ecc9a07ce2", "filename": "src/test/ui/async-await/issue-64130-4-async-move.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,8 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-64130-4-async-move.rs:15:17\n+  --> $DIR/issue-64130-4-async-move.rs:17:5\n    |\n-LL | pub fn foo() -> impl Future + Send {\n-   |                 ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n+LL |     async move {\n+   |     ^^^^^^^^^^ future created by async block is not `Send`\n    |\n    = help: the trait `Sync` is not implemented for `(dyn Any + Send + 'static)`\n note: future is not `Send` as this value is used across an await"}, {"sha": "631389e10f316a8f17e4284c3a9182a6aaae0e5e", "filename": "src/test/ui/async-await/issue-70818.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -2,8 +2,8 @@\n \n use std::future::Future;\n fn foo<T: Send, U>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {\n-//~^ Error future cannot be sent between threads safely\n     async { (ty, ty1) }\n+    //~^ Error future cannot be sent between threads safely\n }\n \n fn main() {}"}, {"sha": "cb50c70f99847a3984bf09b5ec42072ddc7eeb41", "filename": "src/test/ui/async-await/issue-70818.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,11 +1,11 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-70818.rs:4:38\n+  --> $DIR/issue-70818.rs:5:5\n    |\n-LL | fn foo<T: Send, U>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {\n-   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n+LL |     async { (ty, ty1) }\n+   |     ^^^^^ future created by async block is not `Send`\n    |\n note: captured value is not `Send`\n-  --> $DIR/issue-70818.rs:6:18\n+  --> $DIR/issue-70818.rs:5:18\n    |\n LL |     async { (ty, ty1) }\n    |                  ^^^ has type `U` which is not `Send`"}, {"sha": "494561229511ec5909fe2cdb882886c8d56e7392", "filename": "src/test/ui/async-await/issue-70935-complex-spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,8 +8,8 @@ async fn baz<T>(_c: impl FnMut() -> T) where T: Future<Output=()> {\n }\n \n fn foo(tx: std::sync::mpsc::Sender<i32>) -> impl Future + Send {\n-    //~^ ERROR: future cannot be sent between threads safely\n     async move {\n+        //~^ ERROR: future cannot be sent between threads safely\n         baz(|| async{\n             foo(tx.clone());\n         }).await;"}, {"sha": "ad61f21741bb5875e0af18628abc93281a664ea3", "filename": "src/test/ui/async-await/issue-70935-complex-spans.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,8 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-70935-complex-spans.rs:10:45\n+  --> $DIR/issue-70935-complex-spans.rs:11:5\n    |\n-LL | fn foo(tx: std::sync::mpsc::Sender<i32>) -> impl Future + Send {\n-   |                                             ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n+LL |     async move {\n+   |     ^^^^^^^^^^ future created by async block is not `Send`\n    |\n    = help: the trait `Sync` is not implemented for `Sender<i32>`\n note: future is not `Send` as this value is used across an await"}, {"sha": "cdb141c0e3ea2802c7efd1d6a3a368d832b5e64e", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.nll.stderr", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -14,12 +14,16 @@ LL | | }\n    = help: consider adding the following bound: `'a: 'b`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ret-impl-trait-one.rs:16:65\n+  --> $DIR/ret-impl-trait-one.rs:16:80\n    |\n-LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n-   |                                    --                           ^^^^^^^^^^^^^^\n-   |                                    |\n-   |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+LL |   async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n+   |  ____________________________________--__________________________________________^\n+   | |                                    |\n+   | |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+LL | |\n+LL | |     (a, b)\n+LL | | }\n+   | |_^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "2eb3a07059f7bf97d52310280da2d46bf2bbf14b", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.stderr", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,19 +1,26 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/ret-impl-trait-one.rs:10:65\n+  --> $DIR/ret-impl-trait-one.rs:10:85\n    |\n-LL | async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n-   |                                                      ------     ^^^^^^^^^^^^^^^^^^^\n-   |                                                      |          |\n-   |                                                      |          ...but data from `a` is returned here\n-   |                                                      this parameter and the return type are declared with different lifetimes...\n+LL |   async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n+   |  ______________________________________________________------_____-------------------_^\n+   | |                                                      |\n+   | |                                                      this parameter and the return type are declared with different lifetimes...\n+LL | |\n+LL | |     (a, b)\n+LL | | }\n+   | |_^ ...but data from `a` is returned here\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ret-impl-trait-one.rs:16:65\n+  --> $DIR/ret-impl-trait-one.rs:16:80\n    |\n-LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n-   |                                    --                           ^^^^^^^^^^^^^^\n-   |                                    |\n-   |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+LL |   async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n+   |  ____________________________________--__________________________________________^\n+   | |                                    |\n+   | |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+LL | |\n+LL | |     (a, b)\n+LL | | }\n+   | |_^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "cfb0ef1b33a2b69de5936a9cd44e51ce7b9c84f5", "filename": "src/test/ui/async-await/no-const-async.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -3,3 +3,4 @@\n \n pub const async fn x() {}\n //~^ ERROR functions cannot be both `const` and `async`\n+//~| ERROR cycle detected"}, {"sha": "fd76c282f9629c475253bc0197f6cd699999489b", "filename": "src/test/ui/async-await/no-const-async.stderr", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -7,5 +7,36 @@ LL | pub const async fn x() {}\n    |     |     `async` because of this\n    |     `const` because of this\n \n-error: aborting due to previous error\n+error[E0391]: cycle detected when computing type of `x::{opaque#0}`\n+  --> $DIR/no-const-async.rs:4:24\n+   |\n+LL | pub const async fn x() {}\n+   |                        ^\n+   |\n+note: ...which requires borrow-checking `x`...\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `x`...\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `x`...\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `x::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "edc4cb8ac5df37153345b5a8453538bb330da90a", "filename": "src/test/ui/async-await/recursive-async-impl-trait-type.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -2,7 +2,8 @@\n // Test that impl trait does not allow creating recursive types that are\n // otherwise forbidden when using `async` and `await`.\n \n-async fn recursive_async_function() -> () { //~ ERROR\n+async fn recursive_async_function() -> () {\n+    //~^ ERROR recursion in an `async fn` requires boxing\n     recursive_async_function().await;\n }\n "}, {"sha": "046f1dfea323878d1d1725abfac6ab76c724fbc4", "filename": "src/test/ui/async-await/suggest-missing-await.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -21,7 +21,6 @@ async fn dummy() {}\n async fn suggest_await_in_async_fn_return() {\n     dummy()\n     //~^ ERROR mismatched types [E0308]\n-    //~| HELP consider using a semicolon here\n     //~| HELP consider `await`ing on the `Future`\n     //~| SUGGESTION .await\n }"}, {"sha": "a60571dc11df6d4120041ad093068bb25197a461", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -33,13 +33,9 @@ help: consider `await`ing on the `Future`\n    |\n LL |     dummy().await\n    |            ++++++\n-help: consider using a semicolon here\n-   |\n-LL |     dummy();\n-   |            +\n \n error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/suggest-missing-await.rs:35:9\n+  --> $DIR/suggest-missing-await.rs:34:9\n    |\n LL |       let _x = if true {\n    |  ______________-\n@@ -53,15 +49,20 @@ LL | |\n LL | |     };\n    | |_____- `if` and `else` have incompatible types\n    |\n-   = note:   expected type `impl Future<Output = ()>`\n-           found unit type `()`\n+note: while checking the return type of the `async fn`\n+  --> $DIR/suggest-missing-await.rs:18:18\n+   |\n+LL | async fn dummy() {}\n+   |                  ^ checked the `Output` of this `async fn`, expected opaque type\n+   = note: expected opaque type `impl Future<Output = ()>`\n+                found unit type `()`\n help: consider `await`ing on the `Future`\n    |\n LL |         dummy().await\n    |                ++++++\n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/suggest-missing-await.rs:45:14\n+  --> $DIR/suggest-missing-await.rs:44:14\n    |\n LL |       let _x = match 0usize {\n    |  ______________-\n@@ -89,7 +90,7 @@ LL ~         1 => dummy().await,\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:53:9\n+  --> $DIR/suggest-missing-await.rs:52:9\n    |\n LL |         () => {}\n    |         ^^ expected opaque type, found `()`\n@@ -107,13 +108,13 @@ LL |     let _x = match dummy().await {\n    |                           ++++++\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:67:9\n+  --> $DIR/suggest-missing-await.rs:66:9\n    |\n LL |         Ok(_) => {}\n    |         ^^^^^ expected opaque type, found enum `Result`\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:57:28\n+  --> $DIR/suggest-missing-await.rs:56:28\n    |\n LL | async fn dummy_result() -> Result<(), ()> {\n    |                            ^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, expected opaque type\n@@ -125,13 +126,13 @@ LL |     match dummy_result().await {\n    |                         ++++++\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:69:9\n+  --> $DIR/suggest-missing-await.rs:68:9\n    |\n LL |         Err(_) => {}\n    |         ^^^^^^ expected opaque type, found enum `Result`\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:57:28\n+  --> $DIR/suggest-missing-await.rs:56:28\n    |\n LL | async fn dummy_result() -> Result<(), ()> {\n    |                            ^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, expected opaque type"}, {"sha": "ccf41adce6bd83f769dcb48e8b461691b84be03f", "filename": "src/test/ui/cast/casts-differing-anon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -18,5 +18,5 @@ fn main() {\n     // this is an `*mut fmt::Debug` in practice\n     let mut b_raw = Box::into_raw(b);\n     // ... and they should not be mixable\n-    b_raw = f_raw as *mut _; //~ ERROR is invalid\n+    b_raw = f_raw as *mut _; //~ ERROR mismatched types\n }"}, {"sha": "2d08903c5ef69c39b6007a32eb2ddf33f4cfd53f", "filename": "src/test/ui/cast/casts-differing-anon.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,11 +1,19 @@\n-error[E0606]: casting `*mut impl Debug + ?Sized` as `*mut impl Debug + ?Sized` is invalid\n+error[E0308]: mismatched types\n   --> $DIR/casts-differing-anon.rs:21:13\n    |\n+LL | fn foo() -> Box<impl fmt::Debug+?Sized> {\n+   |                 ---------------------- the found opaque type\n+...\n+LL | fn bar() -> Box<impl fmt::Debug+?Sized> {\n+   |                 ---------------------- the expected opaque type\n+...\n LL |     b_raw = f_raw as *mut _;\n-   |             ^^^^^^^^^^^^^^^\n+   |             ^^^^^ expected opaque type, found a different opaque type\n    |\n-   = note: vtable kinds may not match\n+   = note: expected opaque type `impl Debug + ?Sized` (opaque type at <$DIR/casts-differing-anon.rs:7:17>)\n+              found opaque type `impl Debug + ?Sized` (opaque type at <$DIR/casts-differing-anon.rs:3:17>)\n+   = note: distinct uses of `impl Trait` result in different opaque types\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0606`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "46379a3815a4db9b32188fdefbdc813025176b08", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/borrowck/borrowck-4.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,10 +8,10 @@ LL |        println!(\"{:?}\", p);\n    |                         - `p` is borrowed here\n    |\n note: closure is returned here\n-  --> $DIR/borrowck-4.rs:8:14\n+  --> $DIR/borrowck-4.rs:15:5\n    |\n-LL | fn foo () -> impl FnMut()->() {\n-   |              ^^^^^^^^^^^^^^^^\n+LL |     c\n+   |     ^\n help: to force the closure to take ownership of `p` (and any other referenced variables), use the `move` keyword\n    |\n LL |     let mut c = move || {"}, {"sha": "9dc486980aaca215af8098ac8f9d187ef8e0c4ed", "filename": "src/test/ui/conservative_impl_trait.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,11 @@\n error[E0277]: `()` is not an iterator\n-  --> $DIR/conservative_impl_trait.rs:3:33\n+  --> $DIR/conservative_impl_trait.rs:3:60\n    |\n-LL | fn will_ice(something: &u32) -> impl Iterator<Item = &u32> {\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ `()` is not an iterator\n+LL |   fn will_ice(something: &u32) -> impl Iterator<Item = &u32> {\n+   |  ____________________________________________________________^\n+LL | |\n+LL | | }\n+   | |_^ `()` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `()`\n "}, {"sha": "b3bd88ad7d5d8dd3e592978fcbc12a83a56bb394", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,8 +4,8 @@ trait Trait {}\n impl<const N: u32> Trait for Uwu<N> {}\n \n fn rawr() -> impl Trait {\n-    //~^ error: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n     Uwu::<10, 12>\n+    //~^ error: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n }\n \n trait Traitor<const N: u8 = 1, const M: u8 = N> { }\n@@ -15,13 +15,13 @@ impl Traitor<1, 2> for u64 {}\n \n \n fn uwu<const N: u8>() -> impl Traitor<N> {\n-    //~^ error: the trait bound `u32: Traitor<N, N>` is not satisfied\n     1_u32\n+    //~^ error: the trait bound `u32: Traitor<N, N>` is not satisfied\n }\n \n fn owo() -> impl Traitor {\n-    //~^ error: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n     1_u64\n+    //~^ error: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n }\n \n fn main() {"}, {"sha": "ec23952114cdfc0a6960cac6762acb13ae0b09a4", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,26 +1,26 @@\n error[E0277]: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:6:14\n+  --> $DIR/rp_impl_trait_fail.rs:7:5\n    |\n-LL | fn rawr() -> impl Trait {\n-   |              ^^^^^^^^^^ the trait `Trait` is not implemented for `Uwu<10_u32, 12_u32>`\n+LL |     Uwu::<10, 12>\n+   |     ^^^^^^^^^^^^^ the trait `Trait` is not implemented for `Uwu<10_u32, 12_u32>`\n    |\n    = help: the following implementations were found:\n              <Uwu<N> as Trait>\n \n error[E0277]: the trait bound `u32: Traitor<N, N>` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:17:26\n+  --> $DIR/rp_impl_trait_fail.rs:18:5\n    |\n-LL | fn uwu<const N: u8>() -> impl Traitor<N> {\n-   |                          ^^^^^^^^^^^^^^^ the trait `Traitor<N, N>` is not implemented for `u32`\n+LL |     1_u32\n+   |     ^^^^^ the trait `Traitor<N, N>` is not implemented for `u32`\n    |\n    = help: the following implementations were found:\n              <u32 as Traitor<N, 2_u8>>\n \n error[E0277]: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:22:13\n+  --> $DIR/rp_impl_trait_fail.rs:23:5\n    |\n-LL | fn owo() -> impl Traitor {\n-   |             ^^^^^^^^^^^^ the trait `Traitor<1_u8, 1_u8>` is not implemented for `u64`\n+LL |     1_u64\n+   |     ^^^^^ the trait `Traitor<1_u8, 1_u8>` is not implemented for `u64`\n    |\n    = help: the following implementations were found:\n              <u64 as Traitor<1_u8, 2_u8>>"}, {"sha": "eab5a6190ef51a0d62d4039bc6cb15ed1a67bfb2", "filename": "src/test/ui/entry-point/imported_main_const_fn_item_type_forbidden.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,11 +4,9 @@\n //~^^^ ERROR `main` function not found in crate\n pub mod foo {\n     type MainFn = impl Fn();\n-    //~^ ERROR could not find defining uses\n \n     fn bar() {}\n     pub const BAR: MainFn = bar;\n-    //~^ ERROR mismatched types [E0308]\n }\n \n use foo::BAR as main;"}, {"sha": "83a189e01e0132b8dc98ce68cdb4ca2f56ce97c4", "filename": "src/test/ui/entry-point/imported_main_const_fn_item_type_forbidden.stderr", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -12,25 +12,6 @@ LL | | use foo::BAR as main;\n    |       |\n    |       non-function item at `crate::main` is found\n \n-error[E0308]: mismatched types\n-  --> $DIR/imported_main_const_fn_item_type_forbidden.rs:10:29\n-   |\n-LL |     type MainFn = impl Fn();\n-   |                   --------- the expected opaque type\n-...\n-LL |     pub const BAR: MainFn = bar;\n-   |                             ^^^ expected opaque type, found fn item\n-   |\n-   = note: expected opaque type `impl Fn()`\n-                  found fn item `fn() {bar}`\n-\n-error: could not find defining uses\n-  --> $DIR/imported_main_const_fn_item_type_forbidden.rs:6:19\n-   |\n-LL |     type MainFn = impl Fn();\n-   |                   ^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0308, E0601.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0601`."}, {"sha": "6dfd7f6840f1b8807daef10c35f9dc063d8b9c84", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,13 +1,13 @@\n // ignore-compare-mode-chalk\n+// check-pass\n #![feature(type_alias_impl_trait)]\n use std::fmt::Debug;\n \n type Foo = impl Debug;\n-//~^ ERROR could not find defining uses\n \n struct Bar(Foo);\n fn define() -> Bar {\n-    Bar(42) //~ ERROR mismatched types\n+    Bar(42)\n }\n \n type Foo2 = impl Debug;\n@@ -17,21 +17,18 @@ fn define2() {\n }\n \n type Foo3 = impl Debug;\n-//~^ ERROR could not find defining uses\n \n fn define3(x: Foo3) {\n-    let y: i32 = x; //~ ERROR mismatched types\n+    let y: i32 = x;\n }\n fn define3_1() {\n-    define3(42) //~ ERROR mismatched types\n+    define3(42)\n }\n \n type Foo4 = impl Debug;\n-//~^ ERROR could not find defining uses\n \n fn define4() {\n     let y: Foo4 = 42;\n-    //~^ ERROR mismatched types [E0308]\n }\n \n fn main() {}"}, {"sha": "da3ddb1c50979f852528bc26518b9b028dd54c88", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.stderr", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1,73 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:10:9\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-...\n-LL |     Bar(42)\n-   |         ^^ expected opaque type, found integer\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `{integer}`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:23:18\n-   |\n-LL | type Foo3 = impl Debug;\n-   |             ---------- the found opaque type\n-...\n-LL |     let y: i32 = x;\n-   |            ---   ^ expected `i32`, found opaque type\n-   |            |\n-   |            expected due to this\n-   |\n-   = note:     expected type `i32`\n-           found opaque type `impl Debug`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:26:13\n-   |\n-LL | type Foo3 = impl Debug;\n-   |             ---------- the expected opaque type\n-...\n-LL |     define3(42)\n-   |             ^^ expected opaque type, found integer\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `{integer}`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:33:19\n-   |\n-LL | type Foo4 = impl Debug;\n-   |             ---------- the expected opaque type\n-...\n-LL |     let y: Foo4 = 42;\n-   |            ----   ^^ expected opaque type, found integer\n-   |            |\n-   |            expected due to this\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `{integer}`\n-\n-error: could not find defining uses\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:5:12\n-   |\n-LL | type Foo = impl Debug;\n-   |            ^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:19:13\n-   |\n-LL | type Foo3 = impl Debug;\n-   |             ^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:29:13\n-   |\n-LL | type Foo4 = impl Debug;\n-   |             ^^^^^^^^^^\n-\n-error: aborting due to 7 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "c4905995a860a59187a6a4779703efd49c78b4b4", "filename": "src/test/ui/generator/issue-88653.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -6,10 +6,10 @@\n use std::ops::Generator;\n \n fn foo(bar: bool) -> impl Generator<(bool,)> {\n-//~^ ERROR: type mismatch in generator arguments [E0631]\n-//~| NOTE: expected signature of `fn((bool,)) -> _`\n     |bar| {\n     //~^ NOTE: found signature of `fn(bool) -> _`\n+    //~| ERROR: type mismatch in generator arguments [E0631]\n+    //~| NOTE: expected signature of `fn((bool,)) -> _`\n         if bar {\n             yield bar;\n         }"}, {"sha": "eaa90a8e60a2351e542a2cc9ff6d98d769850b7a", "filename": "src/test/ui/generator/issue-88653.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,11 +1,11 @@\n error[E0631]: type mismatch in generator arguments\n-  --> $DIR/issue-88653.rs:8:22\n+  --> $DIR/issue-88653.rs:9:5\n    |\n-LL | fn foo(bar: bool) -> impl Generator<(bool,)> {\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^ expected signature of `fn((bool,)) -> _`\n-...\n LL |     |bar| {\n-   |     ----- found signature of `fn(bool) -> _`\n+   |     ^^^^^\n+   |     |\n+   |     expected signature of `fn((bool,)) -> _`\n+   |     found signature of `fn(bool) -> _`\n \n error: aborting due to previous error\n "}, {"sha": "d1b16b6e10da0fe05f5727e4e61cdb17d01ea137", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -2,8 +2,8 @@\n \n use std::ops::Generator;\n \n-fn foo() -> impl Generator<Return = i32> { //~ ERROR type mismatch\n-    || {\n+fn foo() -> impl Generator<Return = i32> {\n+    || { //~ ERROR type mismatch\n         if false {\n             return Ok(6);\n         }"}, {"sha": "3e78e5b53ba1fe818ec46970fc37e16fe33ed7ff", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.stderr", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -13,13 +13,19 @@ LL |             return Ok(6);\n    |                    ^^^^^\n \n error[E0271]: type mismatch resolving `<[generator@$DIR/type-mismatch-signature-deduction.rs:6:5: 14:6] as Generator>::Return == i32`\n-  --> $DIR/type-mismatch-signature-deduction.rs:5:13\n+  --> $DIR/type-mismatch-signature-deduction.rs:6:5\n    |\n-LL | fn foo() -> impl Generator<Return = i32> {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found enum `Result`\n+LL | /     || {\n+LL | |         if false {\n+LL | |             return Ok(6);\n+LL | |         }\n+...  |\n+LL | |         5\n+LL | |     }\n+   | |_____^ expected enum `Result`, found `i32`\n    |\n-   = note: expected type `i32`\n-              found enum `Result<{integer}, _>`\n+   = note: expected enum `Result<{integer}, _>`\n+              found type `i32`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c65f3fb2aa0a114aa6edc8a3c8dfd3869e8070e7", "filename": "src/test/ui/generic-associated-types/issue-87258_a.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -16,7 +16,8 @@ pub trait Trait2 {\n \n impl<'c, S: Trait2> Trait2 for &'c mut S {\n     type FooFuture<'a> = impl Trait1;\n-    fn foo<'a>() -> Self::FooFuture<'a> { //~ ERROR\n+    //~^ ERROR unconstrained opaque type\n+    fn foo<'a>() -> Self::FooFuture<'a> {\n         Struct(unimplemented!())\n     }\n }"}, {"sha": "db3a5c819cbf3d7d317f533e3ac33a30fd84f130", "filename": "src/test/ui/generic-associated-types/issue-87258_a.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,11 +1,10 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-87258_a.rs:19:21\n+error: unconstrained opaque type\n+  --> $DIR/issue-87258_a.rs:18:26\n    |\n-LL |     fn foo<'a>() -> Self::FooFuture<'a> {\n-   |                     ^^^^^^^^^^^^^^^^^^^\n+LL |     type FooFuture<'a> = impl Trait1;\n+   |                          ^^^^^^^^^^^\n    |\n-   = note: hidden type `Struct<'_>` captures lifetime '_#7r\n+   = note: `FooFuture` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "f59e0d7665942f7cc68fe1df2b93c62b9b422e05", "filename": "src/test/ui/generic-associated-types/issue-87258_b.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -15,10 +15,11 @@ pub trait Trait2 {\n }\n \n type Helper<'xenon, 'yttrium, KABOOM: Trait2> = impl Trait1;\n+//~^ ERROR unconstrained opaque type\n \n impl<'c, S: Trait2> Trait2 for &'c mut S {\n     type FooFuture<'a> = Helper<'c, 'a, S>;\n-    fn foo<'a>() -> Self::FooFuture<'a> { //~ ERROR\n+    fn foo<'a>() -> Self::FooFuture<'a> {\n         Struct(unimplemented!())\n     }\n }"}, {"sha": "9faccc96124bc9648c915ce51078e78bdb48587b", "filename": "src/test/ui/generic-associated-types/issue-87258_b.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,11 +1,10 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-87258_b.rs:21:21\n+error: unconstrained opaque type\n+  --> $DIR/issue-87258_b.rs:17:49\n    |\n-LL |     fn foo<'a>() -> Self::FooFuture<'a> {\n-   |                     ^^^^^^^^^^^^^^^^^^^\n+LL | type Helper<'xenon, 'yttrium, KABOOM: Trait2> = impl Trait1;\n+   |                                                 ^^^^^^^^^^^\n    |\n-   = note: hidden type `Struct<'_>` captures lifetime '_#7r\n+   = note: `Helper` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "ea1bd2be4529d238096d67386b64e1f0872a6f81", "filename": "src/test/ui/generic-associated-types/issue-88595.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -18,7 +18,6 @@ struct C;\n impl<'a> A<'a> for C {\n     type B<'b> = impl Clone;\n     //~^ ERROR: lifetime bound not satisfied\n-    //~| ERROR: could not find defining uses\n \n     fn a(&'a self) -> Self::B<'a> {} //~ ERROR: non-defining opaque type use in defining scope\n }"}, {"sha": "e1d55fa228c2efe696621558719839bf9bdef054", "filename": "src/test/ui/generic-associated-types/issue-88595.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -16,10 +16,10 @@ LL |     type B<'b> = impl Clone;\n    |            ^^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-88595.rs:23:23\n+  --> $DIR/issue-88595.rs:22:35\n    |\n LL |     fn a(&'a self) -> Self::B<'a> {}\n-   |                       ^^^^^^^^^^^\n+   |                                   ^^\n    |\n note: lifetime used multiple times\n   --> $DIR/issue-88595.rs:18:6\n@@ -29,12 +29,6 @@ LL | impl<'a> A<'a> for C {\n LL |     type B<'b> = impl Clone;\n    |            ^^\n \n-error: could not find defining uses\n-  --> $DIR/issue-88595.rs:19:18\n-   |\n-LL |     type B<'b> = impl Clone;\n-   |                  ^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0478`."}, {"sha": "f8c89829e1646760dbebe5ea832c34b7406f707d", "filename": "src/test/ui/generic-associated-types/issue-92096.migrate.stderr", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,18 +1,20 @@\n error[E0311]: the parameter type `C` may not live long enough\n-  --> $DIR/issue-92096.rs:20:33\n+  --> $DIR/issue-92096.rs:24:5\n    |\n LL | fn call_connect<C>(c: &'_ C) -> impl '_ + Future + Send\n-   |                 -               ^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n-   |                 |\n-   |                 help: consider adding an explicit lifetime bound...: `C: 'a`\n+   |                 - help: consider adding an explicit lifetime bound...: `C: 'a`\n+...\n+LL |     async move { c.connect().await }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n \n error[E0311]: the parameter type `C` may not live long enough\n-  --> $DIR/issue-92096.rs:20:33\n+  --> $DIR/issue-92096.rs:24:5\n    |\n LL | fn call_connect<C>(c: &'_ C) -> impl '_ + Future + Send\n-   |                 -               ^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n-   |                 |\n-   |                 help: consider adding an explicit lifetime bound...: `C: 'a`\n+   |                 - help: consider adding an explicit lifetime bound...: `C: 'a`\n+...\n+LL |     async move { c.connect().await }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2bc1af5506ffd50876bd11eb68b819021799bc33", "filename": "src/test/ui/generic-associated-types/issue-92096.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -18,12 +18,12 @@ trait Client {\n }\n \n fn call_connect<C>(c: &'_ C) -> impl '_ + Future + Send\n-//[migrate]~^ ERROR the parameter\n-//[migrate]~| ERROR the parameter\n where\n     C: Client + Send + Sync,\n {\n     async move { c.connect().await }\n+    //[migrate]~^ ERROR the parameter\n+    //[migrate]~| ERROR the parameter\n }\n \n fn main() {}"}, {"sha": "d2452abab02549987b5352dfcd8624a60d307108", "filename": "src/test/ui/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -11,6 +11,7 @@ fn main() {\n // return type, which can't depend on the obligation.\n fn cycle1() -> impl Clone {\n     //~^ ERROR cycle detected\n+    //~| ERROR cycle detected\n     send(cycle2().clone());\n \n     Rc::new(Cell::new(5))"}, {"sha": "14db864f1c28af51ad3dcbf60085e9860f920818", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 97, "deletions": 15, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -30,47 +30,129 @@ note: ...which requires building MIR for `cycle1`...\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:14:5\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires computing type of `cycle2::{opaque#0}`...\n+  --> $DIR/auto-trait-leak.rs:20:16\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   |                ^^^^^^^^^^\n+note: ...which requires borrow-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing MIR for `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires computing type of `cycle1::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/auto-trait-leak.rs:1:1\n+   |\n+LL | / use std::cell::Cell;\n+LL | | use std::rc::Rc;\n+LL | |\n+LL | | fn send<T: Send>(_: T) {}\n+...  |\n+LL | |     Rc::new(String::from(\"foo\"))\n+LL | | }\n+   | |_^\n+\n+error[E0391]: cycle detected when computing type of `cycle1::{opaque#0}`\n+  --> $DIR/auto-trait-leak.rs:12:16\n    |\n-LL |     send(cycle2().clone());\n-   |     ^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n+LL | fn cycle1() -> impl Clone {\n+   |                ^^^^^^^^^^\n+   |\n+note: ...which requires borrow-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing MIR for `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires computing type of `cycle2::{opaque#0}`...\n-  --> $DIR/auto-trait-leak.rs:19:16\n+  --> $DIR/auto-trait-leak.rs:20:16\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n note: ...which requires borrow-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires unsafety-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires building MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:5\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n-LL |     send(cycle1().clone());\n-   |     ^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which again requires computing type of `cycle1::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/auto-trait-leak.rs:1:1\n@@ -84,6 +166,6 @@ LL | |     Rc::new(String::from(\"foo\"))\n LL | | }\n    | |_^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0391`."}, {"sha": "35994e4a5ba3f5b7556ef82e9cbb6c0def9e12e6", "filename": "src/test/ui/impl-trait/auto-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -19,7 +19,7 @@ impl<T: Send> AnotherTrait for T {}\n // (We treat opaque types as \"foreign types\" that could grow more impls\n // in the future.)\n impl AnotherTrait for D<OpaqueType> {\n-    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n }\n \n fn main() {}"}, {"sha": "81009413c9a268f550e356fe32381bf0e3526a88", "filename": "src/test/ui/impl-trait/auto-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,11 +1,11 @@\n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n   --> $DIR/auto-trait.rs:21:1\n    |\n LL | impl<T: Send> AnotherTrait for T {}\n    | -------------------------------- first implementation here\n ...\n LL | impl AnotherTrait for D<OpaqueType> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<impl OpaqueTrait>`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n \n error: aborting due to previous error\n "}, {"sha": "20ddad0547ef2b8eddf2db970ab1427360ac24ce", "filename": "src/test/ui/impl-trait/bound-normalization-fail.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -23,8 +23,8 @@ mod impl_trait {\n \n     /// `T::Assoc` can't be normalized any further here.\n     fn foo_fail<T: Trait>() -> impl FooLike<Output = T::Assoc> {\n-        //~^ ERROR: type mismatch\n         Foo(())\n+        //~^ ERROR: type mismatch\n     }\n }\n \n@@ -39,9 +39,9 @@ mod lifetimes {\n \n     /// Missing bound constraining `Assoc`, `T::Assoc` can't be normalized further.\n     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n-        //~^ ERROR: type mismatch\n-        //~^^ ERROR `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n+        //~^ ERROR `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n         Foo(())\n+        //~^ ERROR: type mismatch\n     }\n }\n "}, {"sha": "01fb853e1d1f7b568846dbac312974818acd8cfc", "filename": "src/test/ui/impl-trait/bound-normalization-fail.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,16 +1,16 @@\n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:25:32\n+  --> $DIR/bound-normalization-fail.rs:26:9\n    |\n-LL |     fn foo_fail<T: Trait>() -> impl FooLike<Output = T::Assoc> {\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n+LL |         Foo(())\n+   |         ^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n    |\n-note: expected this to be `<T as impl_trait::Trait>::Assoc`\n+note: expected this to be `()`\n   --> $DIR/bound-normalization-fail.rs:14:19\n    |\n LL |     type Output = T;\n    |                   ^\n-   = note: expected associated type `<T as impl_trait::Trait>::Assoc`\n-                    found unit type `()`\n+   = note:    expected unit type `()`\n+           found associated type `<T as impl_trait::Trait>::Assoc`\n help: consider constraining the associated type `<T as impl_trait::Trait>::Assoc` to `()`\n    |\n LL |     fn foo_fail<T: Trait<Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {\n@@ -23,18 +23,18 @@ LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:41:41\n+  --> $DIR/bound-normalization-fail.rs:43:9\n    |\n-LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n+LL |         Foo(())\n+   |         ^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n    |\n-note: expected this to be `<T as lifetimes::Trait<'static>>::Assoc`\n+note: expected this to be `()`\n   --> $DIR/bound-normalization-fail.rs:14:19\n    |\n LL |     type Output = T;\n    |                   ^\n-   = note: expected associated type `<T as lifetimes::Trait<'static>>::Assoc`\n-                    found unit type `()`\n+   = note:    expected unit type `()`\n+           found associated type `<T as lifetimes::Trait<'static>>::Assoc`\n help: consider constraining the associated type `<T as lifetimes::Trait<'static>>::Assoc` to `()`\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a, Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {"}, {"sha": "750687e2322284fc055ad262e08b0edd6254ed10", "filename": "src/test/ui/impl-trait/does-not-live-long-enough.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -7,10 +7,10 @@ LL |         self.data.iter().filter(|s| s.starts_with(prefix)).map(|s| s.as_ref\n    |                                 may outlive borrowed value `prefix`\n    |\n note: closure is returned here\n-  --> $DIR/does-not-live-long-enough.rs:5:55\n+  --> $DIR/does-not-live-long-enough.rs:6:9\n    |\n-LL |     fn started_with<'a>(&'a self, prefix: &'a str) -> impl Iterator<Item=&'a str> {\n-   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         self.data.iter().filter(|s| s.starts_with(prefix)).map(|s| s.as_ref())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: to force the closure to take ownership of `prefix` (and any other referenced variables), use the `move` keyword\n    |\n LL |         self.data.iter().filter(move |s| s.starts_with(prefix)).map(|s| s.as_ref())"}, {"sha": "59770c10da2b2e14ab039a20c45618bc5283208d", "filename": "src/test/ui/impl-trait/equality.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -17,8 +17,8 @@ fn two(x: bool) -> impl Foo {\n     //~| expected `i32`, found `u32`\n }\n \n-fn sum_to(n: u32) -> impl Foo { //~ ERROR type annotations needed\n-    if n == 0 {\n+fn sum_to(n: u32) -> impl Foo {\n+    if n == 0 { //~ ERROR type annotations needed\n         0\n     } else {\n         n + sum_to(n - 1)"}, {"sha": "4032fbbceba4ce27dc5b930a86fc14d719a81748", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -12,19 +12,13 @@ error[E0308]: mismatched types\n   --> $DIR/equality.rs:15:5\n    |\n LL | fn two(x: bool) -> impl Foo {\n-   |                    -------- expected because this return type...\n-LL |     if x {\n-LL |         return 1_i32;\n-   |                ----- ...is found to be `i32` here\n-LL |     }\n+   |                    -------- the expected opaque type\n+...\n LL |     0_u32\n    |     ^^^^^ expected `i32`, found `u32`\n    |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: if the trait `Foo` were object safe, you could return a boxed trait object\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n+   = note: expected opaque type `impl Foo`\n+                     found type `u32`\n \n error[E0277]: cannot add `impl Foo` to `u32`\n   --> $DIR/equality.rs:24:11\n@@ -35,10 +29,15 @@ LL |         n + sum_to(n - 1)\n    = help: the trait `Add<impl Foo>` is not implemented for `u32`\n \n error[E0283]: type annotations needed\n-  --> $DIR/equality.rs:20:22\n-   |\n-LL | fn sum_to(n: u32) -> impl Foo {\n-   |                      ^^^^^^^^ cannot infer type for type `{integer}`\n+  --> $DIR/equality.rs:21:5\n+   |\n+LL | /     if n == 0 {\n+LL | |         0\n+LL | |     } else {\n+LL | |         n + sum_to(n - 1)\n+LL | |\n+LL | |     }\n+   | |_____^ cannot infer type for type `{integer}`\n    |\n    = note: multiple `impl`s satisfying `{integer}: ToString` found in the `alloc` crate:\n            - impl ToString for i8;"}, {"sha": "fd33fa7c674f185e97a24a70987892b6e9af0b95", "filename": "src/test/ui/impl-trait/equality2.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -15,9 +15,7 @@ LL | fn hide<T: Foo>(x: T) -> impl Foo {\n    |                          -------- the found opaque type\n ...\n LL |     let _: u32 = hide(0_u32);\n-   |            ---   ^^^^^^^^^^^ expected `u32`, found opaque type\n-   |            |\n-   |            expected due to this\n+   |                  ^^^^^^^^^^^ expected `u32`, found opaque type\n    |\n    = note:     expected type `u32`\n            found opaque type `impl Foo`"}, {"sha": "1e6eb5bb355888c04904570ec6cd6232dd1814db", "filename": "src/test/ui/impl-trait/fallback.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+fn take_edge_counters(\n+    x: &mut Option<Vec<i32>>,\n+) -> Option<impl Iterator<Item = i32>> {\n+    x.take().map_or(None, |m| Some(m.into_iter()))\n+}\n+\n+fn main() {}"}, {"sha": "ae07c89276861140342005edf0fa90f54650ad45", "filename": "src/test/ui/impl-trait/hidden-lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -26,8 +26,8 @@ impl<T> Swap for Rc<RefCell<T>> {\n // Here we are hiding `'b` making the caller believe that `&'a mut &'s T` and\n // `&'a mut &'l T` are the same type.\n fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n-    //~^ ERROR hidden type\n     x\n+    //~^ ERROR hidden type\n }\n \n fn dangle_ref() -> &'static [i32; 3] {\n@@ -43,8 +43,8 @@ fn dangle_ref() -> &'static [i32; 3] {\n // This is different to the previous example because the concrete return type\n // only has a single lifetime.\n fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n-    //~^ ERROR hidden type\n     x\n+    //~^ ERROR hidden type\n }\n \n fn dangle_rc_refcell() -> &'static [i32; 3] {"}, {"sha": "97652f5462ef02487b72a2c6dc7588a4eed0f37d", "filename": "src/test/ui/impl-trait/hidden-lifetimes.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,23 +1,23 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/hidden-lifetimes.rs:28:54\n+  --> $DIR/hidden-lifetimes.rs:29:5\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n-   |                 --                                   ^^^^^^^^^^^^^^\n-   |                 |\n-   |                 hidden type `&'a mut &'b T` captures the lifetime `'b` as defined here\n+   |                 -- hidden type `&'a mut &'b T` captures the lifetime `'b` as defined here\n+LL |     x\n+   |     ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a + 'b {\n    |                                                                     ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/hidden-lifetimes.rs:45:70\n+  --> $DIR/hidden-lifetimes.rs:46:5\n    |\n LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n-   |                        --                                            ^^^^^^^^^^^^^^\n-   |                        |\n-   |                        hidden type `Rc<RefCell<&'b T>>` captures the lifetime `'b` as defined here\n+   |                        -- hidden type `Rc<RefCell<&'b T>>` captures the lifetime `'b` as defined here\n+LL |     x\n+   |     ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "a75b9b43b3e8bae8b0544bd387dab33c1348d104", "filename": "src/test/ui/impl-trait/issue-55872-1.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -10,11 +10,10 @@ impl<S: Default> Bar for S {\n     type E = impl Copy;\n \n     fn foo<T: Default>() -> Self::E {\n-        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-        //~| ERROR impl has stricter requirements than trait\n-        //~| ERROR the trait bound `S: Copy` is not satisfied in `(S, T)` [E0277]\n-        //~| ERROR the trait bound `T: Copy` is not satisfied in `(S, T)` [E0277]\n+        //~^ ERROR impl has stricter requirements than trait\n         (S::default(), T::default())\n+        //~^ ERROR the trait bound `S: Copy` is not satisfied in `(S, T)` [E0277]\n+        //~| ERROR the trait bound `T: Copy` is not satisfied in `(S, T)` [E0277]\n     }\n }\n "}, {"sha": "efc57da746132600900295431238ac4498bf995d", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,10 +8,10 @@ LL |     fn foo<T: Default>() -> Self::E {\n    |               ^^^^^^^ impl has extra requirement `T: Default`\n \n error[E0277]: the trait bound `S: Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:12:29\n+  --> $DIR/issue-55872-1.rs:14:9\n    |\n-LL |     fn foo<T: Default>() -> Self::E {\n-   |                             ^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `S`\n+LL |         (S::default(), T::default())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `S`\n    |\n    = note: required because it appears within the type `(S, T)`\n help: consider further restricting this bound\n@@ -20,31 +20,18 @@ LL | impl<S: Default + std::marker::Copy> Bar for S {\n    |                 +++++++++++++++++++\n \n error[E0277]: the trait bound `T: Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:12:29\n+  --> $DIR/issue-55872-1.rs:14:9\n    |\n-LL |     fn foo<T: Default>() -> Self::E {\n-   |                             ^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `T`\n+LL |         (S::default(), T::default())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `T`\n    |\n    = note: required because it appears within the type `(S, T)`\n help: consider further restricting this bound\n    |\n LL |     fn foo<T: Default + std::marker::Copy>() -> Self::E {\n    |                       +++++++++++++++++++\n \n-error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872-1.rs:12:37\n-   |\n-LL |       fn foo<T: Default>() -> Self::E {\n-   |  _____________________________________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |\n-LL | |         (S::default(), T::default())\n-LL | |     }\n-   | |_____^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0276, E0277.\n For more information about an error, try `rustc --explain E0276`."}, {"sha": "f0bc0b5272784dbfcf73c1bafdd92b6424aacf30", "filename": "src/test/ui/impl-trait/issue-55872-2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,17 +4,16 @@\n #![feature(type_alias_impl_trait)]\n \n pub trait Bar {\n-    type E: Copy;\n+    type E: Send;\n \n     fn foo<T>() -> Self::E;\n }\n \n impl<S> Bar for S {\n-    type E = impl std::marker::Copy;\n+    type E = impl std::marker::Send;\n     fn foo<T>() -> Self::E {\n-        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-        //~| ERROR the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied\n         async {}\n+        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n     }\n }\n "}, {"sha": "71090bdbf8061909314c83d226b5f9125424b410", "filename": "src/test/ui/impl-trait/issue-55872-2.stderr", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,20 +1,8 @@\n-error[E0277]: the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied\n-  --> $DIR/issue-55872-2.rs:14:20\n-   |\n-LL |     fn foo<T>() -> Self::E {\n-   |                    ^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = [async output]>`\n-\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872-2.rs:14:28\n+  --> $DIR/issue-55872-2.rs:15:9\n    |\n-LL |       fn foo<T>() -> Self::E {\n-   |  ____________________________^\n-LL | |\n-LL | |\n-LL | |         async {}\n-LL | |     }\n-   | |_____^\n+LL |         async {}\n+   |         ^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "f50b31ff496ae25be1bb756a0685e56d29840e02", "filename": "src/test/ui/impl-trait/issue-55872-3.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,20 @@\n+// edition:2018\n+// ignore-compare-mode-chalk\n+\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait Bar {\n+    type E: Copy;\n+\n+    fn foo<T>() -> Self::E;\n+}\n+\n+impl<S> Bar for S {\n+    type E = impl std::marker::Copy;\n+    fn foo<T>() -> Self::E {\n+        async {}\n+        //~^ ERROR the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied [E0277]\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "bafd31f0083e8edec2106e267002116a7e338adb", "filename": "src/test/ui/impl-trait/issue-55872-3.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,9 @@\n+error[E0277]: the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied\n+  --> $DIR/issue-55872-3.rs:15:9\n+   |\n+LL |         async {}\n+   |         ^^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = [async output]>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "65874d22ac6f3c92ae393da33488a801f334dce9", "filename": "src/test/ui/impl-trait/issue-55872.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -11,8 +11,8 @@ impl<S> Bar for S {\n     type E = impl Copy;\n \n     fn foo<T>() -> Self::E {\n-        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n         || ()\n+        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n     }\n }\n "}, {"sha": "7abcf6a05942268c5eb875a073fc3663497ef653", "filename": "src/test/ui/impl-trait/issue-55872.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,12 +1,8 @@\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872.rs:13:28\n+  --> $DIR/issue-55872.rs:14:9\n    |\n-LL |       fn foo<T>() -> Self::E {\n-   |  ____________________________^\n-LL | |\n-LL | |         || ()\n-LL | |     }\n-   | |_____^\n+LL |         || ()\n+   |         ^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "cf2c8b7e415408faac524e65a15070252072d169", "filename": "src/test/ui/impl-trait/issue-72911.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -5,7 +5,7 @@ pub struct Lint {}\n impl Lint {}\n \n pub fn gather_all() -> impl Iterator<Item = Lint> {\n-    //~^ ERROR: cannot resolve opaque type\n+    //~^ ERROR `()` is not an iterator\n     lint_files().flat_map(|f| gather_from_file(&f))\n }\n "}, {"sha": "4a990286d966d2c0ad009200b3ce9dbcc496dff8", "filename": "src/test/ui/impl-trait/issue-72911.stderr", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -10,25 +10,15 @@ error[E0433]: failed to resolve: use of undeclared crate or module `foo`\n LL | fn lint_files() -> impl Iterator<Item = foo::MissingItem> {\n    |                                         ^^^ use of undeclared crate or module `foo`\n \n-error[E0720]: cannot resolve opaque type\n+error[E0277]: `()` is not an iterator\n   --> $DIR/issue-72911.rs:7:24\n    |\n LL | pub fn gather_all() -> impl Iterator<Item = Lint> {\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ recursive opaque type\n-LL |\n-LL |     lint_files().flat_map(|f| gather_from_file(&f))\n-   |     -----------------------------------------------\n-   |     |\n-   |     returning here with type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n-   |     returning here with type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n-...\n-LL | fn gather_from_file(dir_entry: &foo::MissingItem) -> impl Iterator<Item = Lint> {\n-   |                                                      -------------------------- returning this opaque type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n-...\n-LL | fn lint_files() -> impl Iterator<Item = foo::MissingItem> {\n-   |                    -------------------------------------- returning this opaque type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ `()` is not an iterator\n+   |\n+   = help: the trait `Iterator` is not implemented for `()`\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0433, E0720.\n-For more information about an error, try `rustc --explain E0433`.\n+Some errors have detailed explanations: E0277, E0433.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "8169cfafac71127665f97b6138b61fea1188f89b", "filename": "src/test/ui/impl-trait/issues/issue-70877.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,7 +4,7 @@ type FooArg<'a> = &'a dyn ToString;\n type FooRet = impl std::fmt::Debug;\n \n type FooItem = Box<dyn Fn(FooArg) -> FooRet>;\n-type Foo = impl Iterator<Item = FooItem>; //~ ERROR: type mismatch\n+type Foo = impl Iterator<Item = FooItem>;\n \n #[repr(C)]\n struct Bar(u8);\n@@ -28,7 +28,7 @@ fn ham() -> Foo {\n fn oof() -> impl std::fmt::Debug {\n     let mut bar = ham();\n     let func = bar.next().unwrap();\n-    return func(&\"oof\");\n+    return func(&\"oof\"); //~ ERROR opaque type's hidden type cannot be another opaque type\n }\n \n fn main() {"}, {"sha": "8813bff3c353e3c656efc75d246b37af50949431", "filename": "src/test/ui/impl-trait/issues/issue-70877.stderr", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,20 +1,19 @@\n-error[E0271]: type mismatch resolving `<Bar as Iterator>::Item == Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n-  --> $DIR/issue-70877.rs:7:12\n+error: opaque type's hidden type cannot be another opaque type from the same scope\n+  --> $DIR/issue-70877.rs:31:12\n    |\n-LL | type FooRet = impl std::fmt::Debug;\n-   |               -------------------- the found opaque type\n-...\n-LL | type Foo = impl Iterator<Item = FooItem>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Bar as Iterator>::Item == Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n+LL |     return func(&\"oof\");\n+   |            ^^^^^^^^^^^^ one of the two opaque types used here has to be outside its defining scope\n+   |\n+note: opaque type whose hidden type is being assigned\n+  --> $DIR/issue-70877.rs:28:13\n    |\n-note: expected this to be `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n-  --> $DIR/issue-70877.rs:13:17\n+LL | fn oof() -> impl std::fmt::Debug {\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+note: opaque type being used as hidden type\n+  --> $DIR/issue-70877.rs:4:15\n    |\n-LL |     type Item = FooItem;\n-   |                 ^^^^^^^\n-   = note: expected struct `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n-              found struct `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> impl Debug + 'static)>`\n+LL | type FooRet = impl std::fmt::Debug;\n+   |               ^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0271`."}, {"sha": "b13ab6bad7fbed4e25354efeafa036b46e826ac6", "filename": "src/test/ui/impl-trait/issues/issue-78722.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -10,7 +10,8 @@ struct Bug {\n             async {}\n         }\n         let f: F = async { 1 };\n-        //~^ ERROR mismatched types [E0308]\n+        //~^ ERROR `async` blocks are not allowed in constants\n+        //~| ERROR destructors cannot be evaluated at compile-time\n         1\n     }],\n }"}, {"sha": "975c771759f9ba04bf5fbcd808f0b5fd7f8a7b3a", "filename": "src/test/ui/impl-trait/issues/issue-78722.stderr", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,23 +1,22 @@\n-error[E0308]: mismatched types\n+error[E0658]: `async` blocks are not allowed in constants\n   --> $DIR/issue-78722.rs:12:20\n    |\n-LL | type F = impl core::future::Future<Output = u8>;\n-   |          -------------------------------------- the expected opaque type\n-...\n LL |         let f: F = async { 1 };\n-   |                -   ^^^^^^^^^^^ expected opaque type, found a different opaque type\n-   |                |\n-   |                expected due to this\n-   |\n-  ::: $SRC_DIR/core/src/future/mod.rs:LL:COL\n+   |                    ^^^^^^^^^^^\n    |\n-LL | pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n-   |                                           ------------------------------- the found opaque type\n+   = note: see issue #85368 <https://github.com/rust-lang/rust/issues/85368> for more information\n+   = help: add `#![feature(const_async_blocks)]` to the crate attributes to enable\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/issue-78722.rs:12:13\n    |\n-   = note: expected opaque type `impl Future<Output = u8>`\n-              found opaque type `impl Future<Output = [async output]>`\n-   = note: distinct uses of `impl Trait` result in different opaque types\n+LL |         let f: F = async { 1 };\n+   |             ^ constants cannot evaluate destructors\n+...\n+LL |     }],\n+   |     - value is dropped here\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0493, E0658.\n+For more information about an error, try `rustc --explain E0493`."}, {"sha": "0786e66ca8b06c6969184d2160f97a18bd5c1a3f", "filename": "src/test/ui/impl-trait/issues/issue-86201.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,10 +1,10 @@\n #![feature(unboxed_closures)]\n #![feature(type_alias_impl_trait)]\n \n+// check-pass\n+\n type FunType = impl Fn<()>;\n-//~^ ERROR could not find defining uses\n static STATIC_FN: FunType = some_fn;\n-//~^ ERROR mismatched types\n \n fn some_fn() {}\n "}, {"sha": "b1460096ded66d3119023e21099d1886ce602f53", "filename": "src/test/ui/impl-trait/issues/issue-86201.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1,21 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-86201.rs:6:29\n-   |\n-LL | type FunType = impl Fn<()>;\n-   |                ----------- the expected opaque type\n-LL |\n-LL | static STATIC_FN: FunType = some_fn;\n-   |                             ^^^^^^^ expected opaque type, found fn item\n-   |\n-   = note: expected opaque type `impl Fn<()>`\n-                  found fn item `fn() {some_fn}`\n-\n-error: could not find defining uses\n-  --> $DIR/issue-86201.rs:4:16\n-   |\n-LL | type FunType = impl Fn<()>;\n-   |                ^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "86323add77905060d354e973e935172f4ce16787", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.nll.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,39 @@\n+error: higher-ranked subtype error\n+  --> $DIR/issue-88236-2.rs:17:5\n+   |\n+LL |     &()\n+   |     ^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/issue-88236-2.rs:17:5\n+   |\n+LL |     &()\n+   |     ^^^\n+\n+error: lifetime may not live long enough\n+  --> $DIR/issue-88236-2.rs:20:5\n+   |\n+LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {\n+   |                  -- lifetime `'b` defined here\n+LL |     x\n+   |     ^ returning this value requires that `'b` must outlive `'static`\n+   |\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'b`, add `'b` as a bound\n+   |\n+LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> + 'b {\n+   |                                                                                  ++++\n+\n+error: higher-ranked subtype error\n+  --> $DIR/issue-88236-2.rs:20:5\n+   |\n+LL |     x\n+   |     ^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/issue-88236-2.rs:20:5\n+   |\n+LL |     x\n+   |     ^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "f89ab7fbd364b92496e340662b88999eae63bbfa", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,23 @@\n+// this used to cause stack overflows\n+\n+trait Hrtb<'a> {\n+    type Assoc;\n+}\n+\n+impl<'a> Hrtb<'a> for () {\n+    type Assoc = ();\n+}\n+\n+impl<'a> Hrtb<'a> for &'a () {\n+    type Assoc = ();\n+}\n+\n+fn make_impl() -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {}\n+fn make_weird_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {\n+    &() //~ ERROR implementation of `Hrtb` is not general enough\n+}\n+fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {\n+    x //~ ERROR implementation of `Hrtb` is not general enough\n+}\n+\n+fn main() {}"}, {"sha": "95c4a52803698345694324dc36c62cc5c2fdcbf1", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,20 @@\n+error: implementation of `Hrtb` is not general enough\n+  --> $DIR/issue-88236-2.rs:17:5\n+   |\n+LL |     &()\n+   |     ^^^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `Hrtb<'0>` would have to be implemented for the type `&()`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'1>` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n+\n+error: implementation of `Hrtb` is not general enough\n+  --> $DIR/issue-88236-2.rs:20:5\n+   |\n+LL |     x\n+   |     ^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `&()` must implement `Hrtb<'0>`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'_>` is actually implemented for the type `&()`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "2ea35270a7e3b5cc0e6784bc8bff5375d7e693d4", "filename": "src/test/ui/impl-trait/issues/issue-88236.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+// this used to cause stack overflows\n+\n+trait Hrtb<'a> {\n+    type Assoc;\n+}\n+\n+impl<'a> Hrtb<'a> for () {\n+    type Assoc = ();\n+}\n+\n+impl<'a> Hrtb<'a> for &'a () {\n+    type Assoc = ();\n+}\n+\n+fn make_impl() -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {}\n+\n+fn main() {}"}, {"sha": "834f2dc6cb5b6dfde14de37e2e7cd83d73e9c85e", "filename": "src/test/ui/impl-trait/lifetimes2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+pub fn keys<'a>(x: &'a Result<u32, u32>) -> impl std::fmt::Debug + 'a {\n+    match x {\n+        Ok(map) => Ok(map),\n+        Err(map) => Err(map),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f5aaf1185211b44d67e06cc6b7deffa351b64ea0", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,7 +8,6 @@ impl<T: Copy> Copy for CopyIfEq<T, T> {}\n type E<'a, 'b> = impl Sized;\n \n fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n     let v = CopyIfEq::<*mut _, *mut _>(&mut { x }, &mut y);\n \n     // This assignment requires that `x` and `y` have the same type due to the\n@@ -21,6 +20,7 @@ fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n         let _: &'b i32 = *u.0;\n     }\n     u.0\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn main() {}"}, {"sha": "b837b64110365d47585e9d702a7d52c2f51d33ca", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,10 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/error-handling-2.rs:10:60\n+  --> $DIR/error-handling-2.rs:22:5\n    |\n LL | fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n-   |        --                                                  ^^^^^^^^^\n-   |        |\n-   |        hidden type `*mut &'a i32` captures the lifetime `'a` as defined here\n+   |        -- hidden type `*mut &'a i32` captures the lifetime `'a` as defined here\n+...\n+LL |     u.0\n+   |     ^^^\n \n error: aborting due to previous error\n "}, {"sha": "47e05bce0f8de747a9f1baa6c588917459f0bf8b", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -14,7 +14,6 @@ struct Ordinary<'a>(&'a u8);\n // by both `'a` and `'b`.\n \n fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n-//~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n where\n     'a: 'e,\n     'b: 'd,\n@@ -27,6 +26,7 @@ where\n     // 'a in ['d, 'e]\n     // ```\n     if condition() { a } else { b }\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn condition() -> bool {"}, {"sha": "15476c706a7f2eab942c6a0ef53faea811766d05", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,10 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ordinary-bounds-unrelated.rs:16:74\n+  --> $DIR/ordinary-bounds-unrelated.rs:28:33\n    |\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n-   |                     --                                                   ^^^^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+   |                     -- hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+...\n+LL |     if condition() { a } else { b }\n+   |                                 ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "321cb8c92a1774eb825e44c5d681cf48d24a5481", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -16,7 +16,6 @@ struct Ordinary<'a>(&'a u8);\n // consider the loans for both `'a` and `'b` alive.\n \n fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n-//~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n {\n     // We return a value:\n     //\n@@ -30,6 +29,7 @@ fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n     //\n     // We are forced to pick that '0 = 'e, because only 'e is outlived by *both* 'a and 'b.\n     if condition() { a } else { b }\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn condition() -> bool {"}, {"sha": "7315aa8e9d4787f617c65d33e42b24eee4614f08", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,10 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ordinary-bounds-unsuited.rs:18:62\n+  --> $DIR/ordinary-bounds-unsuited.rs:31:33\n    |\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n-   |                     --                                       ^^^^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+   |                     -- hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+...\n+LL |     if condition() { a } else { b }\n+   |                                 ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "eb38f84d4afec35c89c6ba4b691f2fe53d5c553d", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----     ^^^^^^^^^\n+   |              ----                 ^\n    |              |\n    |              hidden type `&i32` captures the anonymous lifetime defined here\n    |\n@@ -12,10 +12,10 @@ LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |             --                 ^^^^^^^^^\n+   |             --                             ^\n    |             |\n    |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n    |\n@@ -67,23 +67,23 @@ LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    = help: consider replacing `'a` with `'static`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:34:5\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-   |                              --                             ^^^^^^^^^^^^^^^^\n-   |                              |\n-   |                              hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:35:5: 35:31]` captures the lifetime `'b` as defined here\n+   |                              -- hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:34:5: 34:31]` captures the lifetime `'b` as defined here\n+LL |     move |_| println!(\"{}\", y)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) + 'b {\n    |                                                                              ++++\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:38:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:39:5\n    |\n-LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                                   ^^^^^^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n "}, {"sha": "02ea0255912ab390240ee006707eaa443e8f8d8a", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -31,13 +31,13 @@ fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x } //~ ERRO\n // Tests that a closure type containing 'b cannot be returned from a type where\n // only 'a was expected.\n fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-    //~^ ERROR: captures lifetime that does not appear in bounds\n     move |_| println!(\"{}\", y)\n+    //~^ ERROR: captures lifetime that does not appear in bounds\n }\n \n fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-    //~^ ERROR the parameter type `T` may not live long enough\n     x\n+    //~^ ERROR the parameter type `T` may not live long enough\n }\n \n fn main() {}"}, {"sha": "77ba0bf908763a90128278f93036c4aa5a8189f7", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----     ^^^^^^^^^\n+   |              ----                 ^\n    |              |\n    |              hidden type `&i32` captures the anonymous lifetime defined here\n    |\n@@ -12,10 +12,10 @@ LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |             --                 ^^^^^^^^^\n+   |             --                             ^\n    |             |\n    |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n    |\n@@ -28,15 +28,10 @@ error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'sta\n   --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n    |\n LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n-   |               ----                           ^ ...is used here...\n+   |               ----                           ^ ...is used and required to live as long as `'static` here\n    |               |\n    |               this data with an anonymous lifetime `'_`...\n    |\n-note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:9:24\n-   |\n-LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n-   |                        ^^^^^^^^^^^^^^^^^^^\n help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn elided2(x: &i32) -> impl Copy + '_ { x }\n@@ -50,15 +45,10 @@ error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:11:55\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n-   |                     -------                           ^ ...is used here...\n+   |                     -------                           ^ ...is used and required to live as long as `'static` here\n    |                     |\n    |                     this data with lifetime `'a`...\n    |\n-note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:11:33\n-   |\n-LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n-   |                                 ^^^^^^^^^^^^^^^^^^^\n help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'a { x }\n@@ -69,10 +59,10 @@ LL | fn explicit2<'a>(x: &'static i32) -> impl Copy + 'static { x }\n    |                     ~~~~~~~~~~~~\n \n error[E0621]: explicit lifetime required in the type of `x`\n-  --> $DIR/must_outlive_least_region_or_bound.rs:13:24\n+  --> $DIR/must_outlive_least_region_or_bound.rs:13:41\n    |\n LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n-   |               ----     ^^^^^^^^^^^^^^ lifetime `'a` required\n+   |               ----                      ^ lifetime `'a` required\n    |               |\n    |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n \n@@ -95,13 +85,8 @@ error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:29:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-   |                      ------- this data with lifetime `'a`...        ^ ...is used here...\n-   |\n-note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:29:34\n+   |                      ------- this data with lifetime `'a`...        ^ ...is used and required to live as long as `'static` here\n    |\n-LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'a { x }\n@@ -112,25 +97,25 @@ LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x\n    |                      ~~~~~~~~~~~~\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:34:5\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-   |                              --                             ^^^^^^^^^^^^^^^^\n-   |                              |\n-   |                              hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:35:5: 35:31]` captures the lifetime `'b` as defined here\n+   |                              -- hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:34:5: 34:31]` captures the lifetime `'b` as defined here\n+LL |     move |_| println!(\"{}\", y)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) + 'b {\n    |                                                                              ++++\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:38:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:39:5\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |                                 |\n-   |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n+   |                                 -- help: consider adding an explicit lifetime bound...: `T: 'static +`\n+LL |     x\n+   |     ^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/must_outlive_least_region_or_bound.rs:16:50"}, {"sha": "70e24a3a9d029b946073b198b4d1cbf7583381a1", "filename": "src/test/ui/impl-trait/negative-reasoning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -17,7 +17,7 @@ impl<T: std::fmt::Debug> AnotherTrait for T {}\n \n // This is in error, because we cannot assume that `OpaqueType: !Debug`\n impl AnotherTrait for D<OpaqueType> {\n-    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n }\n \n fn main() {}"}, {"sha": "6b8cc9e7374239c2c14036bf2ce6bfd6628323ad", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,13 +1,13 @@\n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n   --> $DIR/negative-reasoning.rs:19:1\n    |\n LL | impl<T: std::fmt::Debug> AnotherTrait for T {}\n    | ------------------------------------------- first implementation here\n ...\n LL | impl AnotherTrait for D<OpaqueType> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<impl OpaqueTrait>`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n    |\n-   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `impl OpaqueTrait` in future versions\n+   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "6eac2dece1f12677ee643ded3eab515470c414a9", "filename": "src/test/ui/impl-trait/nested_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,6 +4,7 @@ fn fine(x: impl Into<u32>) -> impl Into<u32> { x }\n \n fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n //~^ ERROR nested `impl Trait` is not allowed\n+//~| ERROR `impl Into<u32>` doesn't implement `Debug`\n \n fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n //~^ ERROR nested `impl Trait` is not allowed\n@@ -16,6 +17,7 @@ struct X;\n impl X {\n     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n     //~^ ERROR nested `impl Trait` is not allowed\n+    //~| ERROR `impl Into<u32>` doesn't implement `Debug`\n }\n \n fn allowed_in_assoc_type() -> impl Iterator<Item=impl Fn()> {"}, {"sha": "87ff4ffc4fb17c8b319cf4c794ee6e043dade6d8", "filename": "src/test/ui/impl-trait/nested_impl_trait.stderr", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,7 +8,7 @@ LL | fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n    |                                              outer `impl Trait`\n \n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/nested_impl_trait.rs:8:42\n+  --> $DIR/nested_impl_trait.rs:9:42\n    |\n LL | fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n    |                                ----------^^^^^^^^^^-\n@@ -17,7 +17,7 @@ LL | fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n    |                                outer `impl Trait`\n \n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/nested_impl_trait.rs:12:37\n+  --> $DIR/nested_impl_trait.rs:13:37\n    |\n LL | fn bad_in_arg_position(_: impl Into<impl Debug>) { }\n    |                           ----------^^^^^^^^^^-\n@@ -26,7 +26,7 @@ LL | fn bad_in_arg_position(_: impl Into<impl Debug>) { }\n    |                           outer `impl Trait`\n \n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/nested_impl_trait.rs:17:44\n+  --> $DIR/nested_impl_trait.rs:18:44\n    |\n LL |     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n    |                                  ----------^^^^^^^^^^-\n@@ -35,18 +35,40 @@ LL |     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n    |                                  outer `impl Trait`\n \n error[E0562]: `impl Trait` not allowed outside of function and method return types\n-  --> $DIR/nested_impl_trait.rs:8:32\n+  --> $DIR/nested_impl_trait.rs:9:32\n    |\n LL | fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n    |                                ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and method return types\n-  --> $DIR/nested_impl_trait.rs:25:42\n+  --> $DIR/nested_impl_trait.rs:27:42\n    |\n LL | fn allowed_in_ret_type() -> impl Fn() -> impl Into<u32> {\n    |                                          ^^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error[E0277]: `impl Into<u32>` doesn't implement `Debug`\n+  --> $DIR/nested_impl_trait.rs:5:70\n+   |\n+LL | fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n+   |                                                                      ^ `impl Into<u32>` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+help: consider further restricting this bound\n+   |\n+LL | fn bad_in_ret_position(x: impl Into<u32> + std::fmt::Debug) -> impl Into<impl Debug> { x }\n+   |                                          +++++++++++++++++\n+\n+error[E0277]: `impl Into<u32>` doesn't implement `Debug`\n+  --> $DIR/nested_impl_trait.rs:18:58\n+   |\n+LL |     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n+   |                                                          ^ `impl Into<u32>` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+help: consider further restricting this bound\n+   |\n+LL |     fn bad(x: impl Into<u32> + std::fmt::Debug) -> impl Into<impl Debug> { x }\n+   |                              +++++++++++++++++\n+\n+error: aborting due to 8 previous errors\n \n-Some errors have detailed explanations: E0562, E0666.\n-For more information about an error, try `rustc --explain E0562`.\n+Some errors have detailed explanations: E0277, E0562, E0666.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "b2f7166f0ae3a19f0311b5bd487dd7354e9b8568", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-impl-trait.stderr", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -2,46 +2,25 @@ error[E0308]: mismatched types\n   --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:36:5\n    |\n LL | fn can() -> impl NotObjectSafe {\n-   |             ------------------ expected because this return type...\n-LL |     if true {\n-LL |         return A;\n-   |                - ...is found to be `A` here\n-LL |     }\n+   |             ------------------ the expected opaque type\n+...\n LL |     B\n    |     ^ expected struct `A`, found struct `B`\n    |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: if the trait `NotObjectSafe` were object safe, you could return a boxed trait object\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n+   = note: expected opaque type `impl NotObjectSafe`\n+                   found struct `B`\n \n error[E0308]: mismatched types\n   --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:43:5\n    |\n LL | fn cat() -> impl ObjectSafe {\n-   |             --------------- expected because this return type...\n-LL |     if true {\n-LL |         return A;\n-   |                - ...is found to be `A` here\n-LL |     }\n+   |             --------------- the expected opaque type\n+...\n LL |     B\n    |     ^ expected struct `A`, found struct `B`\n    |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn cat() -> Box<dyn ObjectSafe> {\n-   |             ~~~~~~~           +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         return Box::new(A);\n-LL |     }\n-LL ~     Box::new(B)\n-   |\n+   = note: expected opaque type `impl ObjectSafe`\n+                   found struct `B`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9f9a6c784e638d64607e03e57c7e70c76db0715e", "filename": "src/test/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -14,10 +14,10 @@ fn bar() -> impl std::fmt::Display {\n }\n \n fn baz() -> impl std::fmt::Display {\n-    if false {\n+    if false { //~ ERROR mismatched types\n         return 0i32;\n     } else {\n-        1u32 //~ ERROR mismatched types\n+        1u32\n     }\n }\n \n@@ -30,9 +30,9 @@ fn qux() -> impl std::fmt::Display {\n }\n \n fn bat() -> impl std::fmt::Display {\n-    match 13 {\n+    match 13 { //~ ERROR mismatched types\n         0 => return 0i32,\n-        _ => 1u32, //~ ERROR mismatched types\n+        _ => 1u32,\n     }\n }\n \n@@ -45,12 +45,12 @@ fn can() -> impl std::fmt::Display {\n }\n \n fn cat() -> impl std::fmt::Display {\n-    match 13 {\n+    match 13 { //~ ERROR mismatched types\n         0 => {\n             return 0i32;\n         }\n         _ => {\n-            1u32 //~ ERROR mismatched types\n+            1u32\n         }\n     }\n }"}, {"sha": "db0d446e559a3415e0876866b7b4e5a1207567b4", "filename": "src/test/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 45, "deletions": 145, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -2,82 +2,40 @@ error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:5:5\n    |\n LL | fn foo() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     if false {\n-LL |         return 0i32;\n-   |                ---- ...is found to be `i32` here\n-LL |     }\n+   |             ---------------------- the expected opaque type\n+...\n LL |     1u32\n    |     ^^^^ expected `i32`, found `u32`\n    |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn foo() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         return Box::new(0i32);\n-LL |     }\n-LL ~     Box::new(1u32)\n-   |\n+   = note: expected opaque type `impl std::fmt::Display`\n+                     found type `u32`\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:12:16\n    |\n LL | fn bar() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     if false {\n-LL |         return 0i32;\n-   |                ---- ...is found to be `i32` here\n-LL |     } else {\n+   |             ---------------------- the expected opaque type\n+...\n LL |         return 1u32;\n    |                ^^^^ expected `i32`, found `u32`\n    |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn bar() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         return Box::new(0i32);\n-LL |     } else {\n-LL ~         return Box::new(1u32);\n-   |\n+   = note: expected opaque type `impl std::fmt::Display`\n+                     found type `u32`\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:20:9\n-   |\n-LL | fn baz() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     if false {\n-LL |         return 0i32;\n-   |                ---- ...is found to be `i32` here\n-LL |     } else {\n-LL |         1u32\n-   |         ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn baz() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:17:5\n    |\n-LL ~         return Box::new(0i32);\n-LL |     } else {\n-LL ~         Box::new(1u32)\n+LL |   fn baz() -> impl std::fmt::Display {\n+   |               ---------------------- the expected opaque type\n+LL | /     if false {\n+LL | |         return 0i32;\n+LL | |     } else {\n+LL | |         1u32\n+LL | |     }\n+   | |_____^ expected `i32`, found `u32`\n    |\n+   = note: expected opaque type `impl std::fmt::Display`\n+                     found type `u32`\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:28:9\n@@ -103,87 +61,50 @@ LL ~         Box::new(1u32)\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:35:14\n-   |\n-LL | fn bat() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     match 13 {\n-LL |         0 => return 0i32,\n-   |                     ---- ...is found to be `i32` here\n-LL |         _ => 1u32,\n-   |              ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn bat() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:33:5\n    |\n-LL ~         0 => return Box::new(0i32),\n-LL ~         _ => Box::new(1u32),\n+LL |   fn bat() -> impl std::fmt::Display {\n+   |               ---------------------- the expected opaque type\n+LL | /     match 13 {\n+LL | |         0 => return 0i32,\n+LL | |         _ => 1u32,\n+LL | |     }\n+   | |_____^ expected `i32`, found `u32`\n    |\n+   = note: expected opaque type `impl std::fmt::Display`\n+                     found type `u32`\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:40:5\n    |\n LL |   fn can() -> impl std::fmt::Display {\n-   |               ---------------------- expected because this return type...\n+   |               ---------------------- the expected opaque type\n LL | /     match 13 {\n LL | |         0 => return 0i32,\n-   | |                     ---- ...is found to be `i32` here\n LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____^ expected `i32`, found `u32`\n    |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn can() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~     Box::new(match 13 {\n-LL ~         0 => return Box::new(0i32),\n-LL |         1 => 1u32,\n-LL |         _ => 2u32,\n-LL ~     })\n-   |\n+   = note: expected opaque type `impl std::fmt::Display`\n+                     found type `u32`\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:53:13\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:48:5\n    |\n-LL | fn cat() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-...\n-LL |             return 0i32;\n-   |                    ---- ...is found to be `i32` here\n-...\n-LL |             1u32\n-   |             ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn cat() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~             return Box::new(0i32);\n-LL |         }\n-LL |         _ => {\n-LL ~             Box::new(1u32)\n+LL |   fn cat() -> impl std::fmt::Display {\n+   |               ---------------------- the expected opaque type\n+LL | /     match 13 {\n+LL | |         0 => {\n+LL | |             return 0i32;\n+LL | |         }\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^ expected `i32`, found `u32`\n    |\n+   = note: expected opaque type `impl std::fmt::Display`\n+                     found type `u32`\n \n error[E0308]: `match` arms have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:61:14\n@@ -196,16 +117,6 @@ LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____- `match` arms have incompatible types\n-   |\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn dog() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         0 => Box::new(0i32),\n-LL ~         1 => Box::new(1u32),\n-   |\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:97:9\n@@ -218,17 +129,6 @@ LL | |         1u32\n    | |         ^^^^ expected `i32`, found `u32`\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n-   |\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn apt() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         Box::new(0i32)\n-LL |     } else {\n-LL ~         Box::new(1u32)\n-   |\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:66:13"}, {"sha": "2e7cb21592cb0b714cfacf8a28d7c3b3ce3a859d", "filename": "src/test/ui/impl-trait/projection-mismatch-in-impl-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -11,8 +11,8 @@ pub trait Test {}\n impl<T> Test for T where T: Super<Assoc = ()> {}\n \n fn test() -> impl Test {\n-    //~^ERROR type mismatch resolving `<() as Super>::Assoc == ()`\n     ()\n+    //~^ERROR type mismatch resolving `<() as Super>::Assoc == ()`\n }\n \n fn main() {"}, {"sha": "5ef1e9abef6319538191a4af186185341c3e9b6e", "filename": "src/test/ui/impl-trait/projection-mismatch-in-impl-where-clause.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,10 +1,10 @@\n error[E0271]: type mismatch resolving `<() as Super>::Assoc == ()`\n-  --> $DIR/projection-mismatch-in-impl-where-clause.rs:13:14\n+  --> $DIR/projection-mismatch-in-impl-where-clause.rs:14:5\n    |\n-LL | fn test() -> impl Test {\n-   |              ^^^^^^^^^ type mismatch resolving `<() as Super>::Assoc == ()`\n+LL |     ()\n+   |     ^^ type mismatch resolving `<() as Super>::Assoc == ()`\n    |\n-note: expected this to be `()`\n+note: expected this to be `u8`\n   --> $DIR/projection-mismatch-in-impl-where-clause.rs:6:18\n    |\n LL |     type Assoc = u8;"}, {"sha": "211f7972dbca890e17e5af268e44acce89defd36", "filename": "src/test/ui/impl-trait/question_mark.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+fn foo() -> impl MyTrait {\n+    panic!();\n+    MyStruct\n+}\n+\n+struct MyStruct;\n+trait MyTrait {}\n+\n+impl MyTrait for MyStruct {}\n+\n+fn main() {}"}, {"sha": "540a280f0a319d8303a3071b786b987edd2ea5a4", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,9 +1,8 @@\n-// Test that an `impl Trait` type that expands to itself is an error.\n+// check-pass\n \n #![allow(unconditional_recursion)]\n \n fn test() -> impl Sized {\n-    //~^ ERROR E0720\n     test()\n }\n "}, {"sha": "5a3027ec751a91126268ddd7bc3eb8691c248246", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1,12 +0,0 @@\n-error[E0720]: cannot resolve opaque type\n-  --> $DIR/recursive-impl-trait-type-direct.rs:5:14\n-   |\n-LL | fn test() -> impl Sized {\n-   |              ^^^^^^^^^^ recursive opaque type\n-LL |\n-LL |     test()\n-   |     ------ returning here with type `impl Sized`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0720`."}, {"sha": "ffc0cd9d10c34fc9e4bbbf05b38769b5f1b95e5b", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-indirect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -5,7 +5,7 @@\n #![allow(unconditional_recursion)]\n \n fn option(i: i32) -> impl Sized {\n-    //~^ ERROR\n+    //~^ ERROR cannot resolve opaque type\n     if i < 0 { None } else { Some((option(i - 1), i)) }\n }\n "}, {"sha": "a60e34c17b671aa0f8057e97913a68b1cd70f949", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,29 @@\n+#![feature(type_alias_impl_trait)]\n+\n+mod a {\n+    type Foo = impl PartialEq<(Foo, i32)>;\n+    //~^ ERROR unconstrained opaque type\n+\n+    struct Bar;\n+\n+    impl PartialEq<(Bar, i32)> for Bar {\n+        fn eq(&self, _other: &(Foo, i32)) -> bool {\n+            true\n+        }\n+    }\n+}\n+\n+mod b {\n+    type Foo = impl PartialEq<(Foo, i32)>;\n+    //~^ ERROR unconstrained opaque type\n+\n+    struct Bar;\n+\n+    impl PartialEq<(Foo, i32)> for Bar {\n+        fn eq(&self, _other: &(Bar, i32)) -> bool {\n+            true\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "eae7d38d1162b72ec217394d909dd600baf6bc66", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,18 @@\n+error: unconstrained opaque type\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:4:16\n+   |\n+LL |     type Foo = impl PartialEq<(Foo, i32)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Foo` must be used in combination with a concrete type within the same module\n+\n+error: unconstrained opaque type\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:17:16\n+   |\n+LL |     type Foo = impl PartialEq<(Foo, i32)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Foo` must be used in combination with a concrete type within the same module\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "bdabc13c36a96ee17791ea11dd5315156be89cdd", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,37 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+mod direct {\n+    type Foo = impl PartialEq<(Foo, i32)>;\n+\n+    struct Bar;\n+\n+    impl PartialEq<(Foo, i32)> for Bar {\n+        fn eq(&self, _other: &(Foo, i32)) -> bool {\n+            true\n+        }\n+    }\n+\n+    fn foo() -> Foo {\n+        Bar\n+    }\n+}\n+\n+mod indirect {\n+    type Foo = impl PartialEq<(Foo, i32)>;\n+\n+    struct Bar;\n+\n+    impl PartialEq<(Bar, i32)> for Bar {\n+        fn eq(&self, _other: &(Bar, i32)) -> bool {\n+            true\n+        }\n+    }\n+\n+    fn foo() -> Foo {\n+        Bar\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "18e3a5bcaa449df00b1f6295a4601448b37a3504", "filename": "src/test/ui/impl-trait/region-escape-via-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -13,10 +13,10 @@ trait Trait<'a> { }\n impl Trait<'b> for Cell<&'a u32> { }\n \n fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0700]\n where 'x: 'y\n {\n     x\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0700]\n }\n \n fn main() { }"}, {"sha": "690d049ec8f620bc1de240d1f61197562e646779", "filename": "src/test/ui/impl-trait/region-escape-via-bound.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,11 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/region-escape-via-bound.rs:15:29\n+  --> $DIR/region-escape-via-bound.rs:18:5\n    |\n-LL | fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n-   |                             ^^^^^^^^^^^^^^\n-LL |\n LL | where 'x: 'y\n    |       -- hidden type `Cell<&'x u32>` captures the lifetime `'x` as defined here\n+LL | {\n+LL |     x\n+   |     ^\n    |\n help: to declare that the `impl Trait` captures `'x`, you can add an explicit `'x` lifetime bound\n    |"}, {"sha": "f940c1949d0b8345be0c2102b0702330e97bae2d", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,14 +4,14 @@ struct A {\n \n impl A {\n     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n+        self.x.iter().map(|a| a.0)\n         //~^ ERROR: captures lifetime that does not appear in bounds\n         //~| ERROR: captures lifetime that does not appear in bounds\n-        self.x.iter().map(|a| a.0)\n     }\n     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n+        self.x.iter().map(|a| a.0)\n         //~^ ERROR: captures lifetime that does not appear in bounds\n         //~| ERROR: captures lifetime that does not appear in bounds\n-        self.x.iter().map(|a| a.0)\n     }\n }\n "}, {"sha": "bc8e39f9c504cf7380ce0cdbe7325a1735a694d6", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,49 +1,49 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:6:35\n+  --> $DIR/static-return-lifetime-infered.rs:7:9\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         -----     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                         |\n-   |                         hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:9:27: 9:34]>` captures the anonymous lifetime defined here\n+   |                         ----- hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:7:27: 7:34]>` captures the anonymous lifetime defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:6:35\n+  --> $DIR/static-return-lifetime-infered.rs:7:9\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         -----     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                         |\n-   |                         hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:9:27: 9:34]>` captures the anonymous lifetime defined here\n+   |                         ----- hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:7:27: 7:34]>` captures the anonymous lifetime defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:11:37\n+  --> $DIR/static-return-lifetime-infered.rs:12:9\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                    --               ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                    |\n-   |                    hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:14:27: 14:34]>` captures the lifetime `'a` as defined here\n+   |                    -- hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:12:27: 12:34]>` captures the lifetime `'a` as defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                                             ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:11:37\n+  --> $DIR/static-return-lifetime-infered.rs:12:9\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                    --               ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                    |\n-   |                    hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:14:27: 14:34]>` captures the lifetime `'a` as defined here\n+   |                    -- hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:12:27: 12:34]>` captures the lifetime `'a` as defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'a` lifetime bound\n    |"}, {"sha": "6eb2a11b22c5f359e89099183bcdd64c9c54f301", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,19 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type A = impl Foo;\n+type B = impl Foo;\n+\n+trait Foo {}\n+\n+fn muh(x: A) -> B {\n+    if false {\n+        return Bar; // B's hidden type is Bar\n+    }\n+    x // A's hidden type is `Bar`, because all the hidden types of `B` are compared with each other\n+    //~^ ERROR opaque type's hidden type cannot be another opaque type\n+}\n+\n+struct Bar;\n+impl Foo for Bar {}\n+\n+fn main() {}"}, {"sha": "1a42ac525a6a8f12f60f5a7b47f7ca4bf09d7714", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,19 @@\n+error: opaque type's hidden type cannot be another opaque type from the same scope\n+  --> $DIR/two_tait_defining_each_other.rs:12:5\n+   |\n+LL |     x // A's hidden type is `Bar`, because all the hidden types of `B` are compared with each other\n+   |     ^ one of the two opaque types used here has to be outside its defining scope\n+   |\n+note: opaque type whose hidden type is being assigned\n+  --> $DIR/two_tait_defining_each_other.rs:4:10\n+   |\n+LL | type B = impl Foo;\n+   |          ^^^^^^^^\n+note: opaque type being used as hidden type\n+  --> $DIR/two_tait_defining_each_other.rs:3:10\n+   |\n+LL | type A = impl Foo;\n+   |          ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "3b16d0f5e047f4fe9a4850b3a157f8a1b8e159ab", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,16 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type A = impl Foo;\n+type B = impl Foo;\n+\n+trait Foo {}\n+\n+fn muh(x: A) -> B {\n+    x // B's hidden type is A (opaquely)\n+    //~^ ERROR opaque type's hidden type cannot be another opaque type\n+}\n+\n+struct Bar;\n+impl Foo for Bar {}\n+\n+fn main() {}"}, {"sha": "ef2089a6c5b176c2132d4b708df92f5ab25fd9d9", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other2.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,19 @@\n+error: opaque type's hidden type cannot be another opaque type from the same scope\n+  --> $DIR/two_tait_defining_each_other2.rs:9:5\n+   |\n+LL |     x // B's hidden type is A (opaquely)\n+   |     ^ one of the two opaque types used here has to be outside its defining scope\n+   |\n+note: opaque type whose hidden type is being assigned\n+  --> $DIR/two_tait_defining_each_other2.rs:4:10\n+   |\n+LL | type B = impl Foo;\n+   |          ^^^^^^^^\n+note: opaque type being used as hidden type\n+  --> $DIR/two_tait_defining_each_other2.rs:3:10\n+   |\n+LL | type A = impl Foo;\n+   |          ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "37f8ae1b84b55f50cd7ada951e389cd9b269d007", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other3.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,19 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type A = impl Foo;\n+type B = impl Foo;\n+\n+trait Foo {}\n+\n+fn muh(x: A) -> B {\n+    if false {\n+        return x;  // B's hidden type is A (opaquely)\n+        //~^ ERROR opaque type's hidden type cannot be another opaque type\n+    }\n+    Bar // A's hidden type is `Bar`, because all the return types are compared with each other\n+}\n+\n+struct Bar;\n+impl Foo for Bar {}\n+\n+fn main() {}"}, {"sha": "b06dc16d5e700c505e179dc37298a1881b473d2e", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other3.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,19 @@\n+error: opaque type's hidden type cannot be another opaque type from the same scope\n+  --> $DIR/two_tait_defining_each_other3.rs:10:16\n+   |\n+LL |         return x;  // B's hidden type is A (opaquely)\n+   |                ^ one of the two opaque types used here has to be outside its defining scope\n+   |\n+note: opaque type whose hidden type is being assigned\n+  --> $DIR/two_tait_defining_each_other3.rs:4:10\n+   |\n+LL | type B = impl Foo;\n+   |          ^^^^^^^^\n+note: opaque type being used as hidden type\n+  --> $DIR/two_tait_defining_each_other3.rs:3:10\n+   |\n+LL | type A = impl Foo;\n+   |          ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "e0b77544d439d0b0279f5276c20db6ae5b81845b", "filename": "src/test/ui/impl-trait/type_parameters_captured.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,8 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/type_parameters_captured.rs:7:20\n+  --> $DIR/type_parameters_captured.rs:8:5\n    |\n-LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |                    ^^^^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n "}, {"sha": "81ee7d3f8a561dc5436d1d4b32990348b3fc58fa", "filename": "src/test/ui/impl-trait/type_parameters_captured.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -5,8 +5,8 @@ impl<T> Any for T {}\n \n // Check that type parameters are captured and not considered 'static\n fn foo<T>(x: T) -> impl Any + 'static {\n-    //~^ ERROR the parameter type `T` may not live long enough\n     x\n+    //~^ ERROR the parameter type `T` may not live long enough\n }\n \n fn main() {}"}, {"sha": "c0de4f4b4a0c5edcaff88849391435fc031ae264", "filename": "src/test/ui/impl-trait/type_parameters_captured.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,10 +1,10 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/type_parameters_captured.rs:7:20\n+  --> $DIR/type_parameters_captured.rs:8:5\n    |\n LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |        -           ^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |        |\n-   |        help: consider adding an explicit lifetime bound...: `T: 'static`\n+   |        - help: consider adding an explicit lifetime bound...: `T: 'static`\n+LL |     x\n+   |     ^ ...so that the type `T` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "d5a87b5d468340b3673d52c926b971597a9cc834", "filename": "src/test/ui/impl-trait/where-allowed-2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,7 @@\n-//! Ideally, these tests would go in `where-allowed.rs`, but we bail out\n-//! too early to display them.\n use std::fmt::Debug;\n \n-// Disallowed\n-fn in_adt_in_return() -> Vec<impl Debug> { panic!() } //~ ERROR cannot resolve opaque type\n+// check-pass\n+\n+fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n \n fn main() {}"}, {"sha": "b8e06725cbcdd6493683dc2ca34fd4d775d5cc27", "filename": "src/test/ui/impl-trait/where-allowed-2.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1,13 +0,0 @@\n-error[E0720]: cannot resolve opaque type\n-  --> $DIR/where-allowed-2.rs:6:30\n-   |\n-LL | fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-   |                              ^^^^^^^^^^    -------- this returned value is of `!` type\n-   |                              |\n-   |                              cannot resolve opaque type\n-   |\n-   = help: this error will resolve once the item's body returns a concrete type\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0720`."}, {"sha": "89e07037afd424bf797e17bec9917a39d0c332f1", "filename": "src/test/ui/issues-71798.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fissues-71798.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fissues-71798.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues-71798.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,5 +1,6 @@\n fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n-    *x //~^ ERROR `u32` is not a future\n+    *x\n+    //~^ ERROR `u32` is not a future\n }\n \n fn main() {"}, {"sha": "1efa886436e0d3ed8eea9a73c62ee4ae0b458b2a", "filename": "src/test/ui/issues-71798.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fissues-71798.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fissues-71798.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues-71798.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,14 +1,14 @@\n error[E0425]: cannot find value `u` in this scope\n-  --> $DIR/issues-71798.rs:6:24\n+  --> $DIR/issues-71798.rs:7:24\n    |\n LL |     let _ = test_ref & u;\n    |                        ^ not found in this scope\n \n error[E0277]: `u32` is not a future\n-  --> $DIR/issues-71798.rs:1:25\n+  --> $DIR/issues-71798.rs:2:5\n    |\n-LL | fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `u32` is not a future\n+LL |     *x\n+   |     ^^ `u32` is not a future\n    |\n    = help: the trait `Future` is not implemented for `u32`\n    = note: u32 must be a future or must implement `IntoFuture` to be awaited"}, {"sha": "e5f26822f26708c43b30e1af545b6a218f7a521c", "filename": "src/test/ui/lang-items/lang-item-missing-generator.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,8 @@\n error: requires `generator` lang_item\n-  --> $DIR/lang-item-missing-generator.rs:15:17\n+  --> $DIR/lang-item-missing-generator.rs:15:22\n    |\n LL | pub fn abc() -> impl FnOnce(f32) {\n-   |                 ^^^^^^^^^^^^^^^^\n+   |                      ^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "84bfa2d848755a9c64991d460bc917b985ead622", "filename": "src/test/ui/lazy-type-alias-impl-trait/freeze_cycle.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,46 @@\n+// check-pass\n+\n+#![feature(gen_future, generator_trait, negative_impls, const_fn_trait_bound, const_impl_trait)]\n+\n+use std::ops::{Generator, GeneratorState};\n+use std::task::{Poll, Context};\n+use std::future::{Future};\n+use std::ptr::NonNull;\n+use std::pin::Pin;\n+\n+fn main() {}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub struct ResumeTy(NonNull<Context<'static>>);\n+\n+unsafe impl Send for ResumeTy {}\n+\n+unsafe impl Sync for ResumeTy {}\n+\n+pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n+where\n+    T: Generator<ResumeTy, Yield = ()>,\n+{\n+    struct GenFuture<T: Generator<ResumeTy, Yield = ()>>(T);\n+\n+    // We rely on the fact that async/await futures are immovable in order to create\n+    // self-referential borrows in the underlying generator.\n+    impl<T: Generator<ResumeTy, Yield = ()>> !Unpin for GenFuture<T> {}\n+\n+    impl<T: Generator<ResumeTy, Yield = ()>> Future for GenFuture<T> {\n+        type Output = T::Return;\n+        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+            // SAFETY: Safe because we're !Unpin + !Drop, and this is just a field projection.\n+            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n+\n+            // Resume the generator, turning the `&mut Context` into a `NonNull` raw pointer. The\n+            // `.await` lowering will safely cast that back to a `&mut Context`.\n+            match gen.resume(ResumeTy(NonNull::from(cx).cast::<Context<'static>>())) {\n+                GeneratorState::Yielded(()) => Poll::Pending,\n+                GeneratorState::Complete(x) => Poll::Ready(x),\n+            }\n+        }\n+    }\n+\n+    GenFuture(gen)\n+}"}, {"sha": "d07d732c78570c74368044af764d6983cee5652c", "filename": "src/test/ui/lazy-type-alias-impl-trait/infer_cross_function.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+\n+fn main() {}\n+\n+trait Reader {}\n+\n+struct Unit<R>(R);\n+struct ResDwarf<R>(R);\n+\n+struct Context<R: Reader> {\n+    dwarf: ResDwarf<R>,\n+}\n+\n+struct Range;\n+\n+struct ResUnit<R>(R);\n+\n+impl<R: Reader + 'static> Context<R> {\n+    fn find_dwarf_unit(&self, probe: u64) -> Option<&Unit<R>> {\n+        let x = self.find_units(probe);\n+        None\n+    }\n+\n+    fn find_units(&self, probe: u64) -> impl Iterator<Item = &ResUnit<R>> {\n+        std::iter::empty()\n+    }\n+}"}, {"sha": "f75a88aa8f0645da33663b44e051b2a00a682f69", "filename": "src/test/ui/lazy-type-alias-impl-trait/lifetime_inference.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+\n+fn main() {}\n+\n+fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+    move || iter.nth(step)\n+}"}, {"sha": "f8291112739c116d0550b51f13b281a5747c40b8", "filename": "src/test/ui/lazy-type-alias-impl-trait/nested.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+fn main() {}\n+\n+struct RawTableInner<A> {\n+    alloc: A,\n+}\n+\n+impl<A> RawTableInner<A> {\n+    fn prepare_resize(\n+        self,\n+    ) -> ScopeGuard<Self, impl FnMut(&mut Self)> {\n+        ScopeGuard { dropfn: move |self_| {}, value: self,  }\n+    }\n+}\n+\n+pub struct ScopeGuard<T, F>\n+where\n+    F: FnMut(&mut T),\n+{\n+    dropfn: F,\n+    value: T,\n+}"}, {"sha": "8d03b5158d66278c4521a579b743d3574d0c2ade", "filename": "src/test/ui/lazy-type-alias-impl-trait/opaque_vs_opaque.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+fn main() {}\n+\n+fn filter_fold<T, Acc, PRED: FnMut(&T) -> bool, FOLD: FnMut(Acc, T) -> Acc>(\n+    mut predicate: PRED,\n+    mut fold: FOLD,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n+}"}, {"sha": "007101498238d7f12fc52fabec521565a7b97056", "filename": "src/test/ui/lazy-type-alias-impl-trait/unsized_sized_opaque.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+fn main() {}\n+\n+pub struct PairSlices<'a, 'b, T> {\n+    pub(crate) a0: &'a mut [T],\n+    pub(crate) a1: &'a mut [T],\n+    pub(crate) b0: &'b [T],\n+    pub(crate) b1: &'b [T],\n+}\n+\n+impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n+    pub fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n+        IntoIterator::into_iter([self.b0, self.b1])\n+    }\n+}"}, {"sha": "fd49b4842a74f6036e52865310a179f9c9db7264", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -6,8 +6,8 @@ trait Future {\n use std::error::Error;\n \n fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n-//~^ ERROR not satisfied\n     Ok(())\n+    //~^ ERROR not satisfied\n }\n \n fn main() {}"}, {"sha": "7f8384d7eca8d90e511deba1a542ffd2eb14bb11", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Result<(), _>: Future` is not satisfied\n-  --> $DIR/lifetime-elision-return-type-trait.rs:8:13\n+  --> $DIR/lifetime-elision-return-type-trait.rs:9:5\n    |\n-LL | fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Future` is not implemented for `Result<(), _>`\n+LL |     Ok(())\n+   |     ^^^^^^ the trait `Future` is not implemented for `Result<(), _>`\n \n error: aborting due to previous error\n "}, {"sha": "13dab7ed954f85b5ec7a13da761a91ab95f42c84", "filename": "src/test/ui/lint/inline-trait-and-foreign-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -23,7 +23,7 @@ impl Trait for () {\n     type T = Self;\n \n     #[inline] //~ ERROR attribute should be applied to function or closure\n-    type U = impl Trait; //~ ERROR could not find defining uses\n+    type U = impl Trait; //~ ERROR unconstrained opaque type\n }\n \n extern \"C\" {"}, {"sha": "fc7e89e4f4cce6dae3bf812d0c727aa7ef1c5746", "filename": "src/test/ui/lint/inline-trait-and-foreign-items.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -61,11 +61,13 @@ LL |     #[inline]\n LL |     type T;\n    |     ------- not a function or closure\n \n-error: could not find defining uses\n+error: unconstrained opaque type\n   --> $DIR/inline-trait-and-foreign-items.rs:26:14\n    |\n LL |     type U = impl Trait;\n    |              ^^^^^^^^^^\n+   |\n+   = note: `U` must be used in combination with a concrete type within the same module\n \n error: aborting due to 6 previous errors; 2 warnings emitted\n "}, {"sha": "691047c8a405b56551985c1b26f21aa99f6efbb1", "filename": "src/test/ui/lint/lint-ctypes-73249-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -23,7 +23,7 @@ pub struct A<T: Foo> {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> A<()>; //~ ERROR: uses type `impl Baz`\n+    pub fn lint_me() -> A<()>; //~ ERROR: uses type `Qux`\n }\n \n fn main() {}"}, {"sha": "7c85e9fa85c632cfc27d83171e2617dc5e6eaf41", "filename": "src/test/ui/lint/lint-ctypes-73249-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+error: `extern` block uses type `Qux`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73249-2.rs:26:25\n    |\n LL |     pub fn lint_me() -> A<()>;"}, {"sha": "ef8ab7e03d2f07277c0105a158398ebc231d7a04", "filename": "src/test/ui/lint/lint-ctypes-73249-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -17,7 +17,7 @@ pub struct A {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> A; //~ ERROR: uses type `impl Baz`\n+    pub fn lint_me() -> A; //~ ERROR: uses type `Qux`\n }\n \n fn main() {}"}, {"sha": "83e2a233c43355aab8670baf6591a89c49ac7b44", "filename": "src/test/ui/lint/lint-ctypes-73249-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+error: `extern` block uses type `Qux`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73249-3.rs:20:25\n    |\n LL |     pub fn lint_me() -> A;"}, {"sha": "083fb6c5fb16dcc447c250aa1ebebecc39ac1b8f", "filename": "src/test/ui/lint/lint-ctypes-73249-5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -17,7 +17,7 @@ pub struct A {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> A; //~ ERROR: uses type `impl Baz`\n+    pub fn lint_me() -> A; //~ ERROR: uses type `Qux`\n }\n \n fn main() {}"}, {"sha": "37781d78cf28c03513b830662d90e6b2ff5efbaa", "filename": "src/test/ui/lint/lint-ctypes-73249-5.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+error: `extern` block uses type `Qux`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73249-5.rs:20:25\n    |\n LL |     pub fn lint_me() -> A;"}, {"sha": "145ba784f7c66955e5a3a8ee068c9e188388bd8a", "filename": "src/test/ui/lint/lint-ctypes-73251-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -20,7 +20,7 @@ fn assign() -> Qux {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> <u32 as Foo>::Assoc; //~ ERROR: uses type `impl Baz`\n+    pub fn lint_me() -> <u32 as Foo>::Assoc; //~ ERROR: uses type `Qux`\n }\n \n fn main() {}"}, {"sha": "76b19d37e21a6d9eaeb5fddf3ec26b2d72f161ae", "filename": "src/test/ui/lint/lint-ctypes-73251-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+error: `extern` block uses type `Qux`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73251-1.rs:23:25\n    |\n LL |     pub fn lint_me() -> <u32 as Foo>::Assoc;"}, {"sha": "df71a94579624bd51dc28637579094a281210639", "filename": "src/test/ui/lint/lint-ctypes-73251-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -33,7 +33,7 @@ fn use_of_b() -> AliasB {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> <AliasB as TraitB>::Assoc; //~ ERROR: uses type `impl TraitA<Assoc = u32>`\n+    pub fn lint_me() -> <AliasB as TraitB>::Assoc; //~ ERROR: uses type `AliasA`\n }\n \n fn main() {}"}, {"sha": "64f0fb2d892a45d31448a07da8a1bf46be8ded0c", "filename": "src/test/ui/lint/lint-ctypes-73251-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl TraitA<Assoc = u32>`, which is not FFI-safe\n+error: `extern` block uses type `AliasA`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73251-2.rs:36:25\n    |\n LL |     pub fn lint_me() -> <AliasB as TraitB>::Assoc;"}, {"sha": "b7cc38e99fc37bdddacf11c89dfb60a9c5bdee91", "filename": "src/test/ui/lint/opaque-ty-ffi-unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -9,7 +9,7 @@ pub fn ret_closure() -> A {\n \n extern \"C\" {\n     pub fn a(_: A);\n-    //~^ ERROR `extern` block uses type `impl Fn()`, which is not FFI-safe [improper_ctypes]\n+    //~^ ERROR `extern` block uses type `A`, which is not FFI-safe [improper_ctypes]\n }\n \n fn main() {}"}, {"sha": "62d00fd6835eee19568dc430c5a4b0de43d9d3f1", "filename": "src/test/ui/lint/opaque-ty-ffi-unsafe.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl Fn()`, which is not FFI-safe\n+error: `extern` block uses type `A`, which is not FFI-safe\n   --> $DIR/opaque-ty-ffi-unsafe.rs:11:17\n    |\n LL |     pub fn a(_: A);"}, {"sha": "7d020841180012580290b044c221ea6b79b2df02", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -6,7 +6,8 @@ fn main() {}\n \n trait T {}\n \n-fn should_ret_unit() -> impl T {\n-    //~^ ERROR the trait bound `(): T` is not satisfied\n-    panic!()\n+fn should_ret_unit() {\n+    foo(panic!()) //~ ERROR\n }\n+\n+fn foo(_: impl T) {}"}, {"sha": "54abed383000dc8134137db45fa06923d8cfe74e", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,14 @@\n error[E0277]: the trait bound `(): T` is not satisfied\n-  --> $DIR/feature-gate-never_type_fallback.rs:9:25\n+  --> $DIR/feature-gate-never_type_fallback.rs:10:5\n    |\n-LL | fn should_ret_unit() -> impl T {\n-   |                         ^^^^^^ the trait `T` is not implemented for `()`\n+LL |     foo(panic!())\n+   |     ^^^ the trait `T` is not implemented for `()`\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/feature-gate-never_type_fallback.rs:13:16\n+   |\n+LL | fn foo(_: impl T) {}\n+   |                ^ required by this bound in `foo`\n \n error: aborting due to previous error\n "}, {"sha": "cc9520c1b24c8818d8584b08c193f1764b997ae5", "filename": "src/test/ui/never_type/impl_trait_fallback.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+fn main() {}\n+\n+trait T {}\n+impl T for () {}\n+\n+fn should_ret_unit() -> impl T {\n+    panic!()\n+}"}, {"sha": "f73d953bdbd0b6e10aaf2d268e53d2a802a315de", "filename": "src/test/ui/never_type/impl_trait_fallback2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,21 @@\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {}\n+\n+trait T {}\n+impl T for i32 {}\n+\n+fn should_ret_unit() -> impl T {\n+    //~^ ERROR `(): T` is not satisfied\n+    panic!()\n+}\n+\n+type Foo = impl T;\n+\n+fn a() -> Foo {\n+    panic!()\n+}\n+\n+fn b() -> Foo {\n+    42\n+}"}, {"sha": "2f50b9d245900f0bb1f6c90c68085b3f755b06e5", "filename": "src/test/ui/never_type/impl_trait_fallback2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,9 @@\n+error[E0277]: the trait bound `(): T` is not satisfied\n+  --> $DIR/impl_trait_fallback2.rs:8:25\n+   |\n+LL | fn should_ret_unit() -> impl T {\n+   |                         ^^^^^^ the trait `T` is not implemented for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "26ce9b93105e6fc3ed4c3c8f2c6e576b4bae96aa", "filename": "src/test/ui/never_type/impl_trait_fallback3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,15 @@\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {}\n+\n+trait T {\n+    type Assoc;\n+}\n+\n+type Foo = impl T;\n+//~^ ERROR unconstrained opaque type\n+\n+fn a() -> Foo {\n+    // This is not a defining use, it doesn't actually constrain the opaque type.\n+    panic!()\n+}"}, {"sha": "121019d5f69aefe3739137e5f63c63b78a6a8030", "filename": "src/test/ui/never_type/impl_trait_fallback3.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,10 @@\n+error: unconstrained opaque type\n+  --> $DIR/impl_trait_fallback3.rs:9:12\n+   |\n+LL | type Foo = impl T;\n+   |            ^^^^^^\n+   |\n+   = note: `Foo` must be used in combination with a concrete type within the same module\n+\n+error: aborting due to previous error\n+"}, {"sha": "fe62773fa02dbd2be3cb1f9d8e03a4faf45357cf", "filename": "src/test/ui/never_type/impl_trait_fallback4.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,24 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait T {\n+    type Assoc: Cake;\n+}\n+\n+trait Cake: std::fmt::Display {\n+    fn cake() -> Self;\n+}\n+\n+type Foo = impl T;\n+\n+fn foo() -> impl T {\n+    //~^ ERROR `(): T` is not satisfied\n+    panic!()\n+}\n+\n+fn a() -> Foo {\n+    foo()\n+}\n+\n+fn main() {\n+    println!(\"{}\", <Foo as T>::Assoc::cake());\n+}"}, {"sha": "f2e216e9044c00a50eac5adb4728813370bc3881", "filename": "src/test/ui/never_type/impl_trait_fallback4.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,9 @@\n+error[E0277]: the trait bound `(): T` is not satisfied\n+  --> $DIR/impl_trait_fallback4.rs:13:13\n+   |\n+LL | fn foo() -> impl T {\n+   |             ^^^^^^ the trait `T` is not implemented for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2f4cbf8322bbd13f648cc30c708c8f1eae2f7683", "filename": "src/test/ui/nll/issue-52113.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -29,9 +29,9 @@ fn produce3<'a, 'b: 'a>(data: &'a mut Vec<&'a u32>, value: &'b u32) -> impl Bazi\n fn produce_err<'a, 'b: 'a>(data: &'b mut Vec<&'b u32>, value: &'a u32) -> impl Bazinga + 'b {\n     let x = move || {\n         let value: &'a u32 = value;\n-        data.push(value);\n+        data.push(value); //~ ERROR lifetime may not live long enough\n     };\n-    x //~ ERROR lifetime may not live long enough\n+    x\n }\n \n fn main() {}"}, {"sha": "42ff1866893e6d923e707653ad8db4c3b6e204e7", "filename": "src/test/ui/nll/issue-52113.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,13 +1,13 @@\n error: lifetime may not live long enough\n-  --> $DIR/issue-52113.rs:34:5\n+  --> $DIR/issue-52113.rs:32:9\n    |\n LL | fn produce_err<'a, 'b: 'a>(data: &'b mut Vec<&'b u32>, value: &'a u32) -> impl Bazinga + 'b {\n    |                --  -- lifetime `'b` defined here\n    |                |\n    |                lifetime `'a` defined here\n ...\n-LL |     x\n-   |     ^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n+LL |         data.push(value);\n+   |         ^^^^^^^^^^^^^^^^ argument requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n "}, {"sha": "97dc016068bed85abe50f1e81c3ff81c9ccaf4c2", "filename": "src/test/ui/nll/issue-73159-rpit-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -7,8 +7,8 @@ struct Foo<'a>(&'a [u8]);\n \n impl<'a> Foo<'a> {\n     fn make_it(&self) -> impl Iterator<Item = u8> {\n-        //~^ ERROR: captures lifetime that does not appear in bounds\n         self.0.iter().copied()\n+        //~^ ERROR: captures lifetime that does not appear in bounds\n     }\n }\n "}, {"sha": "a3e9c0b44c21078c76a54e23a4bbeb177dac259a", "filename": "src/test/ui/nll/issue-73159-rpit-static.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,10 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-73159-rpit-static.rs:9:26\n+  --> $DIR/issue-73159-rpit-static.rs:10:9\n    |\n LL | impl<'a> Foo<'a> {\n    |      -- hidden type `Copied<std::slice::Iter<'a, u8>>` captures the lifetime `'a` as defined here\n LL |     fn make_it(&self) -> impl Iterator<Item = u8> {\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         self.0.iter().copied()\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "c04185d08142481a928ae978c214943acaff011b", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,8 +8,8 @@ trait Foo<'a> {\n impl<'a, T> Foo<'a> for T { }\n \n fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n-//~^ ERROR captures lifetime that does not appear in bounds\n     x\n+    //~^ ERROR captures lifetime that does not appear in bounds\n }\n \n fn main() {}"}, {"sha": "42d9f057aaa08dcf8773d4765bf4546f6509383d", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,10 +1,10 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/impl-trait-captures.rs:10:25\n+  --> $DIR/impl-trait-captures.rs:11:5\n    |\n LL | fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n-   |                  --     ^^^^^^^^^^^^\n-   |                  |\n-   |                  hidden type `&ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0)) T` captures the anonymous lifetime defined here\n+   |                  -- hidden type `&ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0)) T` captures the anonymous lifetime defined here\n+LL |     x\n+   |     ^\n    |\n help: to declare that the `impl Trait` captures `ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0))`, you can add an explicit `ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0))` lifetime bound\n    |"}, {"sha": "3548ad03a7d3d9fc6a7578dc21bf59f646d6f251", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -5,11 +5,11 @@\n use std::fmt::Debug;\n \n fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n-    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n where\n     T: Debug,\n {\n     x\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n }\n \n fn correct_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n@@ -20,11 +20,11 @@ where\n }\n \n fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n-    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n where\n     T: 'b + Debug,\n {\n     x\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n }\n \n fn outlives_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a"}, {"sha": "31ee540cce9f70ccf63bcd4f9baed4e8f5276ae7", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,16 +1,16 @@\n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/impl-trait-outlives.rs:7:35\n+  --> $DIR/impl-trait-outlives.rs:11:5\n    |\n-LL | fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n-   |                                   ^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'a`...\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/impl-trait-outlives.rs:22:42\n+  --> $DIR/impl-trait-outlives.rs:26:5\n    |\n-LL | fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n-   |                                          ^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'a`...\n "}, {"sha": "cf5d3dab4aadad1f5b3e73b5f4b98db565906d25", "filename": "src/test/ui/parser/fn-header-semantic-fail.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -9,8 +9,9 @@ fn main() {\n     unsafe fn ff2() {} // OK.\n     const fn ff3() {} // OK.\n     extern \"C\" fn ff4() {} // OK.\n-    const async unsafe extern \"C\" fn ff5() {} // OK.\n+    const async unsafe extern \"C\" fn ff5() {}\n     //~^ ERROR functions cannot be both `const` and `async`\n+    //~| ERROR cycle detected\n \n     trait X {\n         async fn ft1(); //~ ERROR functions in traits cannot be declared `async`\n@@ -26,15 +27,14 @@ fn main() {\n     struct Y;\n     impl X for Y {\n         async fn ft1() {} //~ ERROR functions in traits cannot be declared `async`\n-        //~^ ERROR method `ft1` has an incompatible type for trait\n         unsafe fn ft2() {} // OK.\n         const fn ft3() {} //~ ERROR functions in traits cannot be declared const\n         extern \"C\" fn ft4() {}\n         const async unsafe extern \"C\" fn ft5() {}\n         //~^ ERROR functions in traits cannot be declared `async`\n         //~| ERROR functions in traits cannot be declared const\n-        //~| ERROR method `ft5` has an incompatible type for trait\n         //~| ERROR functions cannot be both `const` and `async`\n+        //~| ERROR cycle detected\n     }\n \n     impl Y {\n@@ -44,6 +44,7 @@ fn main() {\n         extern \"C\" fn fi4() {} // OK.\n         const async unsafe extern \"C\" fn fi5() {}\n         //~^ ERROR functions cannot be both `const` and `async`\n+        //~| ERROR cycle detected\n     }\n \n     extern \"C\" {"}, {"sha": "1d7460b8d36057c584527abe95a40628c3fc01f9", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 113, "deletions": 41, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,14 +1,14 @@\n error: functions cannot be both `const` and `async`\n   --> $DIR/fn-header-semantic-fail.rs:12:5\n    |\n-LL |     const async unsafe extern \"C\" fn ff5() {} // OK.\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n    |     ^^^^^-^^^^^------------------------------\n    |     |     |\n    |     |     `async` because of this\n    |     `const` because of this\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:16:9\n+  --> $DIR/fn-header-semantic-fail.rs:17:9\n    |\n LL |         async fn ft1();\n    |         -----^^^^^^^^^^\n@@ -19,19 +19,19 @@ LL |         async fn ft1();\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:18:9\n+  --> $DIR/fn-header-semantic-fail.rs:19:9\n    |\n LL |         const fn ft3();\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:20:9\n+  --> $DIR/fn-header-semantic-fail.rs:21:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:20:9\n+  --> $DIR/fn-header-semantic-fail.rs:21:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^^-----^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -42,7 +42,7 @@ LL |         const async unsafe extern \"C\" fn ft5();\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:20:9\n+  --> $DIR/fn-header-semantic-fail.rs:21:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^-^^^^^----------------------------\n@@ -51,7 +51,7 @@ LL |         const async unsafe extern \"C\" fn ft5();\n    |         `const` because of this\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:28:9\n+  --> $DIR/fn-header-semantic-fail.rs:29:9\n    |\n LL |         async fn ft1() {}\n    |         -----^^^^^^^^^^^^\n@@ -103,7 +103,7 @@ LL |         const async unsafe extern \"C\" fn fi5() {}\n    |         `const` because of this\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:50:18\n+  --> $DIR/fn-header-semantic-fail.rs:51:18\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -116,7 +116,7 @@ LL |         fn fe1();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:51:19\n+  --> $DIR/fn-header-semantic-fail.rs:52:19\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -130,7 +130,7 @@ LL |         fn fe2();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:52:18\n+  --> $DIR/fn-header-semantic-fail.rs:53:18\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -144,7 +144,7 @@ LL |         fn fe3();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:53:23\n+  --> $DIR/fn-header-semantic-fail.rs:54:23\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -158,7 +158,7 @@ LL |         fn fe4();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:54:42\n+  --> $DIR/fn-header-semantic-fail.rs:55:42\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -172,51 +172,123 @@ LL |         fn fe5();\n    |         ~~\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:54:9\n+  --> $DIR/fn-header-semantic-fail.rs:55:9\n    |\n LL |         const async unsafe extern \"C\" fn fe5();\n    |         ^^^^^-^^^^^----------------------------\n    |         |     |\n    |         |     `async` because of this\n    |         `const` because of this\n \n-error[E0053]: method `ft1` has an incompatible type for trait\n-  --> $DIR/fn-header-semantic-fail.rs:28:24\n+error[E0391]: cycle detected when computing type of `main::ff5::{opaque#0}`\n+  --> $DIR/fn-header-semantic-fail.rs:12:44\n    |\n-LL |         async fn ft1() {}\n-   |                        ^\n-   |                        |\n-   |                        checked the `Output` of this `async fn`, found opaque type\n-   |                        expected `()`, found opaque type\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |                                            ^\n    |\n-   = note: while checking the return type of the `async fn`\n-note: type in trait\n-  --> $DIR/fn-header-semantic-fail.rs:16:23\n+note: ...which requires borrow-checking `main::ff5`...\n+  --> $DIR/fn-header-semantic-fail.rs:12:5\n    |\n-LL |         async fn ft1();\n-   |                       ^\n-   = note: expected fn pointer `fn()`\n-              found fn pointer `fn() -> impl Future<Output = ()>`\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `main::ff5`...\n+  --> $DIR/fn-header-semantic-fail.rs:12:5\n+   |\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `main::ff5`...\n+  --> $DIR/fn-header-semantic-fail.rs:12:5\n+   |\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `main::ff5::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/fn-header-semantic-fail.rs:5:1\n+   |\n+LL | / #![feature(const_extern_fn)]\n+LL | |\n+LL | | fn main() {\n+LL | |     async fn ff1() {} // OK.\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n \n-error[E0053]: method `ft5` has an incompatible type for trait\n+error[E0391]: cycle detected when computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5::{opaque#0}`\n   --> $DIR/fn-header-semantic-fail.rs:33:48\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |                                                ^\n-   |                                                |\n-   |                                                checked the `Output` of this `async fn`, found opaque type\n-   |                                                expected `()`, found opaque type\n    |\n-   = note: while checking the return type of the `async fn`\n-note: type in trait\n-  --> $DIR/fn-header-semantic-fail.rs:20:47\n+note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5`...\n+  --> $DIR/fn-header-semantic-fail.rs:33:9\n    |\n-LL |         const async unsafe extern \"C\" fn ft5();\n-   |                                               ^\n-   = note: expected fn pointer `unsafe extern \"C\" fn()`\n-              found fn pointer `unsafe extern \"C\" fn() -> impl Future<Output = ()>`\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5`...\n+  --> $DIR/fn-header-semantic-fail.rs:33:9\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5`...\n+  --> $DIR/fn-header-semantic-fail.rs:33:9\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/fn-header-semantic-fail.rs:5:1\n+   |\n+LL | / #![feature(const_extern_fn)]\n+LL | |\n+LL | | fn main() {\n+LL | |     async fn ff1() {} // OK.\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0391]: cycle detected when computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5::{opaque#0}`\n+  --> $DIR/fn-header-semantic-fail.rs:45:48\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |                                                ^\n+   |\n+note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5`...\n+  --> $DIR/fn-header-semantic-fail.rs:45:9\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5`...\n+  --> $DIR/fn-header-semantic-fail.rs:45:9\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5`...\n+  --> $DIR/fn-header-semantic-fail.rs:45:9\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/fn-header-semantic-fail.rs:5:1\n+   |\n+LL | / #![feature(const_extern_fn)]\n+LL | |\n+LL | | fn main() {\n+LL | |     async fn ff1() {} // OK.\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 21 previous errors\n \n-Some errors have detailed explanations: E0053, E0379, E0706.\n-For more information about an error, try `rustc --explain E0053`.\n+Some errors have detailed explanations: E0379, E0391, E0706.\n+For more information about an error, try `rustc --explain E0379`."}, {"sha": "68ea4a026d7bf3622e0f9e3d6117e977c05a07ad", "filename": "src/test/ui/polymorphization/generators.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -32,7 +32,6 @@ where\n \n #[rustc_polymorphize_error]\n pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-    //~^ ERROR item has unused generic parameters\n     || {\n         //~^ ERROR item has unused generic parameters\n         yield 1;\n@@ -58,7 +57,6 @@ pub fn used_type_in_return<R: Default>() -> impl Generator<(), Yield = u32, Retu\n \n #[rustc_polymorphize_error]\n pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-    //~^ ERROR item has unused generic parameters\n     || {\n         //~^ ERROR item has unused generic parameters\n         yield 1;"}, {"sha": "1152bcb0734a63490ef7a65683f52b7de7afc8a0", "filename": "src/test/ui/polymorphization/generators.stderr", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,11 +8,10 @@ LL | #![feature(generic_const_exprs, generators, generator_trait, rustc_attrs)]\n    = note: see issue #76560 <https://github.com/rust-lang/rust/issues/76560> for more information\n \n error: item has unused generic parameters\n-  --> $DIR/generators.rs:36:5\n+  --> $DIR/generators.rs:35:5\n    |\n LL |   pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n    |                      - generic parameter `T` is unused\n-LL |\n LL | /     || {\n LL | |\n LL | |         yield 1;\n@@ -21,29 +20,16 @@ LL | |     }\n    | |_____^\n \n error: item has unused generic parameters\n-  --> $DIR/generators.rs:34:8\n-   |\n-LL | pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-   |        ^^^^^^^^^^^ - generic parameter `T` is unused\n-\n-error: item has unused generic parameters\n-  --> $DIR/generators.rs:62:5\n+  --> $DIR/generators.rs:60:5\n    |\n LL |   pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n    |                             - generic parameter `T` is unused\n-LL |\n LL | /     || {\n LL | |\n LL | |         yield 1;\n LL | |         2\n LL | |     }\n    | |_____^\n \n-error: item has unused generic parameters\n-  --> $DIR/generators.rs:60:8\n-   |\n-LL | pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-   |        ^^^^^^^^^^^^       - generic parameter `T` is unused\n-\n-error: aborting due to 4 previous errors; 1 warning emitted\n+error: aborting due to 2 previous errors; 1 warning emitted\n "}, {"sha": "49462f52fb4c2355375bd633eb76b28dcd730501", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -14,7 +14,6 @@ trait B {\n impl B for A {\n     async fn associated(); //~ ERROR without body\n     //~^ ERROR cannot be declared `async`\n-    //~| ERROR incompatible type for trait\n }\n \n fn main() {}"}, {"sha": "a473f42fc2cf805ffdd235531abac1672d17c56a", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.stderr", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -44,25 +44,6 @@ LL |     async fn associated();\n    = note: `async` trait functions are not currently supported\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n-error[E0053]: method `associated` has an incompatible type for trait\n-  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:15:26\n-   |\n-LL |     async fn associated();\n-   |                          ^\n-   |                          |\n-   |                          checked the `Output` of this `async fn`, found opaque type\n-   |                          expected `()`, found opaque type\n-   |\n-   = note: while checking the return type of the `async fn`\n-note: type in trait\n-  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:11:26\n-   |\n-LL |     async fn associated();\n-   |                          ^\n-   = note: expected fn pointer `fn()`\n-              found fn pointer `fn() -> impl Future<Output = ()>`\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0053, E0706.\n-For more information about an error, try `rustc --explain E0053`.\n+For more information about this error, try `rustc --explain E0706`."}, {"sha": "30479580f11a3c0122291b0020d1738bf15406f4", "filename": "src/test/ui/save-analysis/issue-68621.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -11,7 +11,7 @@ trait Service {\n struct Struct;\n \n impl Service for Struct {\n-    type Future = impl Trait; //~ ERROR: could not find defining uses\n+    type Future = impl Trait; //~ ERROR: unconstrained opaque type\n }\n \n fn main() {}"}, {"sha": "4a4bf9a6996bc489aade43388ffe581b7185de76", "filename": "src/test/ui/save-analysis/issue-68621.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,10 @@\n-error: could not find defining uses\n+error: unconstrained opaque type\n   --> $DIR/issue-68621.rs:14:19\n    |\n LL |     type Future = impl Trait;\n    |                   ^^^^^^^^^^\n+   |\n+   = note: `Future` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n "}, {"sha": "570a08cb58768ff9c1fc6ded908cade51d391b22", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:37\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:48\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                          -          ^^^^^^^^^^\n+   |                          -                     ^^^^^^^^\n    |                          |\n    |                          hidden type `Pin<&Foo>` captures the lifetime `'_` as defined here\n    |"}, {"sha": "abdc650c68e78d46b85949e92ba38e38c448123a", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:31\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:44\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                    -----      ^^^^^^^^^^\n+   |                    -----                   ^^^^\n    |                    |\n    |                    hidden type `Pin<&Foo>` captures the anonymous lifetime defined here\n    |"}, {"sha": "07c1d8bccbaba1e39ed3a8358cc194b60e0950e4", "filename": "src/test/ui/suggestions/impl-trait-return-trailing-semicolon.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,10 +1,11 @@\n error[E0277]: the trait bound `(): Bar` is not satisfied\n-  --> $DIR/impl-trait-return-trailing-semicolon.rs:3:13\n+  --> $DIR/impl-trait-return-trailing-semicolon.rs:3:22\n    |\n-LL | fn foo() -> impl Bar {\n-   |             ^^^^^^^^ the trait `Bar` is not implemented for `()`\n-LL |     5;\n-   |      - consider removing this semicolon\n+LL |   fn foo() -> impl Bar {\n+   |  ______________________^\n+LL | |     5;\n+LL | | }\n+   | |_^ the trait `Bar` is not implemented for `()`\n \n error: aborting due to previous error\n "}, {"sha": "f13e653cb06bda42de0288a36c7535ace1cf5322", "filename": "src/test/ui/suggestions/issue-81098.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,19 +1,23 @@\n error[E0277]: `()` doesn't implement `std::fmt::Display`\n-  --> $DIR/issue-81098.rs:3:13\n+  --> $DIR/issue-81098.rs:3:37\n    |\n-LL | fn wat() -> impl core::fmt::Display {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ `()` cannot be formatted with the default formatter\n+LL |   fn wat() -> impl core::fmt::Display {\n+   |  _____________________________________^\n+LL | |     fn why() {}\n+LL | | }\n+   | |_^ `()` cannot be formatted with the default formatter\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `()`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n \n error[E0277]: `()` doesn't implement `std::fmt::Display`\n-  --> $DIR/issue-81098.rs:9:12\n+  --> $DIR/issue-81098.rs:9:36\n    |\n-LL | fn ok() -> impl core::fmt::Display {\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^ `()` cannot be formatted with the default formatter\n-LL |     1;\n-   |      - consider removing this semicolon\n+LL |   fn ok() -> impl core::fmt::Display {\n+   |  ____________________________________^\n+LL | |     1;\n+LL | | }\n+   | |_^ `()` cannot be formatted with the default formatter\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `()`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead"}, {"sha": "c7f1215c8cc44f30b8aec22e940928972783711f", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.stderr", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -7,13 +7,18 @@ LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used here...\n+   |                        ...is used and required to live as long as `'static` here\n    |\n-note: ...and is required to live as long as `'static` here\n+note: `'static` lifetime requirement introduced by the return type\n   --> $DIR/trait-object-nested-in-impl-trait.rs:27:23\n    |\n-LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________- because of this returned expression\n help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n@@ -32,13 +37,18 @@ LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used here...\n+   |                        ...is used and required to live as long as `'static` here\n    |\n-note: ...and is required to live as long as `'static` here\n+note: `'static` lifetime requirement introduced by the return type\n   --> $DIR/trait-object-nested-in-impl-trait.rs:38:23\n    |\n-LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________- because of this returned expression\n help: to declare that the trait object captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> + '_ {\n@@ -53,13 +63,18 @@ LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used here...\n+   |                        ...is used and required to live as long as `'static` here\n    |\n-note: ...and is required to live as long as `'static` here\n+note: `'static` lifetime requirement introduced by the return type\n   --> $DIR/trait-object-nested-in-impl-trait.rs:49:30\n    |\n-LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________- because of this returned expression\n help: to declare that the trait object captures data from argument `self`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> + 'a {\n@@ -74,13 +89,18 @@ LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used here...\n+   |                        ...is used and required to live as long as `'static` here\n    |\n-note: ...and is required to live as long as `'static` here\n+note: `'static` lifetime requirement introduced by the return type\n   --> $DIR/trait-object-nested-in-impl-trait.rs:60:30\n    |\n-LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________- because of this returned expression\n help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {"}, {"sha": "a02664ad7ca69e8f1cb405cfd6d93bfe9cb501e9", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -16,6 +16,9 @@ fn extra_semicolon() {\n async fn async_dummy() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n //~| NOTE while checking the return type of the `async fn`\n //~| NOTE in this expansion of desugaring of `async` block or function\n+//~| NOTE while checking the return type of the `async fn`\n+//~| NOTE in this expansion of desugaring of `async` block or function\n+//~| NOTE checked the `Output` of this `async fn`, expected opaque type\n async fn async_dummy2() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n //~| NOTE checked the `Output` of this `async fn`, found opaque type\n //~| NOTE while checking the return type of the `async fn`\n@@ -31,7 +34,7 @@ async fn async_extra_semicolon_same() {\n         }\n         false => async_dummy(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected `()`, found opaque type\n-        //~| NOTE expected type `()`\n+        //~| NOTE expected unit type `()`\n         //~| HELP consider `await`ing on the `Future`\n     };\n }\n@@ -44,7 +47,7 @@ async fn async_extra_semicolon_different() {\n         }\n         false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected `()`, found opaque type\n-        //~| NOTE expected type `()`\n+        //~| NOTE expected unit type `()`\n         //~| HELP consider `await`ing on the `Future`\n     };\n }\n@@ -55,7 +58,7 @@ async fn async_different_futures() {\n         //~| HELP consider `await`ing on both `Future`s\n         false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected opaque type, found a different opaque type\n-        //~| NOTE expected type `impl Future<Output = ()>`\n+        //~| NOTE expected opaque type `impl Future<Output = ()>`\n         //~| NOTE distinct uses of `impl Trait` result in different opaque types\n     };\n }"}, {"sha": "4c4b782bd6fb17047767617efbe86e64c2906b3d", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.stderr", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:32:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:35:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -20,8 +20,8 @@ note: while checking the return type of the `async fn`\n    |\n LL | async fn async_dummy() {}\n    |                        ^ checked the `Output` of this `async fn`, found opaque type\n-   = note:     expected type `()`\n-           found opaque type `impl Future<Output = ()>`\n+   = note: expected unit type `()`\n+            found opaque type `impl Future<Output = ()>`\n help: consider `await`ing on the `Future`\n    |\n LL |         false => async_dummy().await,\n@@ -33,7 +33,7 @@ LL +             async_dummy()\n    | \n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:45:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:48:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -50,12 +50,12 @@ LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/match-prev-arm-needing-semi.rs:19:25\n+  --> $DIR/match-prev-arm-needing-semi.rs:22:25\n    |\n LL | async fn async_dummy2() {}\n    |                         ^ checked the `Output` of this `async fn`, found opaque type\n-   = note:     expected type `()`\n-           found opaque type `impl Future<Output = ()>`\n+   = note: expected unit type `()`\n+            found opaque type `impl Future<Output = ()>`\n help: consider `await`ing on the `Future`\n    |\n LL |         false => async_dummy2().await,\n@@ -69,7 +69,7 @@ LL ~         false => Box::new(async_dummy2()),\n    |\n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:56:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:59:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -84,12 +84,17 @@ LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/match-prev-arm-needing-semi.rs:19:25\n+  --> $DIR/match-prev-arm-needing-semi.rs:16:24\n+   |\n+LL | async fn async_dummy() {}\n+   |                        ^ checked the `Output` of this `async fn`, expected opaque type\n+note: while checking the return type of the `async fn`\n+  --> $DIR/match-prev-arm-needing-semi.rs:22:25\n    |\n LL | async fn async_dummy2() {}\n    |                         ^ checked the `Output` of this `async fn`, found opaque type\n-   = note:     expected type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:16:24>)\n-           found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:19:25>)\n+   = note: expected opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:16:24>)\n+              found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:22:25>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n help: consider `await`ing on both `Future`s\n    |"}, {"sha": "133ffb058739250011df2fe7c15174346a1213d9", "filename": "src/test/ui/suggestions/opaque-type-error.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/opaque-type-error.rs:20:9\n    |\n+LL |   fn thing_one() -> impl Future<Output = Result<(), ()>> {\n+   |                     ------------------------------------ the expected opaque type\n+...\n LL |   fn thing_two() -> impl Future<Output = Result<(), ()>> {\n    |                     ------------------------------------ the found opaque type\n ...\n@@ -13,8 +16,8 @@ LL | |         thing_two()\n LL | |     }.await\n    | |_____- `if` and `else` have incompatible types\n    |\n-   = note:     expected type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:8:19>)\n-           found opaque type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:12:19>)\n+   = note: expected opaque type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:8:19>)\n+              found opaque type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:12:19>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n help: consider `await`ing on both `Future`s\n    |"}, {"sha": "04320e72076830aab187c2e7b7dbf43e08d73051", "filename": "src/test/ui/traits/alias/issue-83613.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,6 +8,6 @@ fn mk_opaque() -> OpaqueType {\n trait AnotherTrait {}\n impl<T: Send> AnotherTrait for T {}\n impl AnotherTrait for OpaqueType {}\n-//~^ ERROR conflicting implementations of trait `AnotherTrait` for type `impl OpaqueTrait`\n+//~^ ERROR conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n //~| ERROR cannot implement trait on type alias impl trait\n fn main() {}"}, {"sha": "4f19e6607c8d9f3256b34b61a969316754d8e956", "filename": "src/test/ui/traits/alias/issue-83613.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -10,13 +10,13 @@ note: type alias impl trait defined here\n LL | type OpaqueType = impl OpaqueTrait;\n    |                   ^^^^^^^^^^^^^^^^\n \n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `impl OpaqueTrait`\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n   --> $DIR/issue-83613.rs:10:1\n    |\n LL | impl<T: Send> AnotherTrait for T {}\n    | -------------------------------- first implementation here\n LL | impl AnotherTrait for OpaqueType {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `impl OpaqueTrait`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `OpaqueType`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "185207b9800bbc0c41b4f53d5d7e1fb106965e2c", "filename": "src/test/ui/type-alias-impl-trait/argument-types.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,14 +1,12 @@\n #![feature(type_alias_impl_trait)]\n #![allow(dead_code)]\n-\n+// check-pass\n use std::fmt::Debug;\n \n type Foo = impl Debug;\n \n-// FIXME: This should compile, but it currently doesn't\n fn foo1(mut x: Foo) {\n     x = 22_u32;\n-    //~^ ERROR: mismatched types [E0308]\n }\n \n fn foo2(mut x: Foo) {"}, {"sha": "a87e44a048b250c09704b31158b51aacf0c8a60c", "filename": "src/test/ui/type-alias-impl-trait/argument-types.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1,17 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/argument-types.rs:10:9\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-...\n-LL | fn foo1(mut x: Foo) {\n-   |                --- expected due to this parameter type\n-LL |     x = 22_u32;\n-   |         ^^^^^^ expected opaque type, found `u32`\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `u32`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "0664275b2ad0a359520c9df3d97743000f2b5f54", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage2.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -2,15 +2,15 @@ error[E0277]: `Rc<u32>` cannot be sent between threads safely\n   --> $DIR/auto-trait-leakage2.rs:17:13\n    |\n LL |     type Foo = impl std::fmt::Debug;\n-   |                -------------------- within this `impl Debug`\n+   |                -------------------- within this `Foo`\n ...\n LL |     is_send(m::foo());\n    |     ------- ^^^^^^^^ `Rc<u32>` cannot be sent between threads safely\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: within `impl Debug`, the trait `Send` is not implemented for `Rc<u32>`\n-   = note: required because it appears within the type `impl Debug`\n+   = help: within `Foo`, the trait `Send` is not implemented for `Rc<u32>`\n+   = note: required because it appears within the type `Foo`\n note: required by a bound in `is_send`\n   --> $DIR/auto-trait-leakage2.rs:14:15\n    |"}, {"sha": "b456b1445e7845ebbe29bf76a8514dd2bd57d4a6", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -6,6 +6,7 @@\n mod m {\n     type Foo = impl std::fmt::Debug;\n     //~^ ERROR: cycle detected when computing type of `m::Foo::{opaque#0}` [E0391]\n+    //~| ERROR: cycle detected when computing type of `m::Foo::{opaque#0}` [E0391]\n \n     pub fn foo() -> Foo {\n         22_u32"}, {"sha": "4c44875b4a548eb85a4d3a51fbe115d571b87d78", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage3.stderr", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -5,18 +5,35 @@ LL |     type Foo = impl std::fmt::Debug;\n    |                ^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires type-checking `m::bar`...\n-  --> $DIR/auto-trait-leakage3.rs:15:9\n+  --> $DIR/auto-trait-leakage3.rs:15:5\n    |\n-LL |         is_send(foo());\n-   |         ^^^^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::fmt::Debug: core::marker::Send`...\n+LL |     pub fn bar() {\n+   |     ^^^^^^^^^^^^\n    = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in module `m`\n   --> $DIR/auto-trait-leakage3.rs:6:1\n    |\n LL | mod m {\n    | ^^^^^\n \n-error: aborting due to previous error\n+error[E0391]: cycle detected when computing type of `m::Foo::{opaque#0}`\n+  --> $DIR/auto-trait-leakage3.rs:7:16\n+   |\n+LL |     type Foo = impl std::fmt::Debug;\n+   |                ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires type-checking `m::bar`...\n+  --> $DIR/auto-trait-leakage3.rs:15:5\n+   |\n+LL |     pub fn bar() {\n+   |     ^^^^^^^^^^^^\n+   = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in module `m`\n+  --> $DIR/auto-trait-leakage3.rs:6:1\n+   |\n+LL | mod m {\n+   | ^^^^^\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0391`."}, {"sha": "4d2890b5de583c48bc63a8e6d727e4d3516f03f1", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -7,13 +7,12 @@ trait TraitWithAssoc {\n }\n \n type Foo<V> = impl Trait<V>;\n-//~^ ERROR could not find defining uses\n \n trait Trait<U> {}\n \n impl<W> Trait<W> for () {}\n \n fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     ()\n+    //~^ ERROR non-defining opaque type use\n }"}, {"sha": "c405b1f6af2057428a78bf0dc88993d954d99ad7", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,20 +1,14 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/bound_reduction2.rs:16:46\n+  --> $DIR/bound_reduction2.rs:16:5\n    |\n-LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   |                                              ^^^^^^^^^^^^^\n+LL |     ()\n+   |     ^^\n    |\n note: used non-generic type `<T as TraitWithAssoc>::Assoc` for generic parameter\n   --> $DIR/bound_reduction2.rs:9:10\n    |\n LL | type Foo<V> = impl Trait<V>;\n    |          ^\n \n-error: could not find defining uses\n-  --> $DIR/bound_reduction2.rs:9:15\n-   |\n-LL | type Foo<V> = impl Trait<V>;\n-   |               ^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "83d22161e4e75617fb3845576e8b6843d0eb966a", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,11 +4,11 @@\n #![feature(type_alias_impl_trait)]\n \n type X<'a> = impl Into<&'static str> + From<&'a str>;\n-//~^ ERROR mismatched types\n \n fn f<'a: 'static>(t: &'a str) -> X<'a> {\n     //~^ WARNING unnecessary lifetime parameter\n     t\n+    //~^ ERROR non-defining opaque type use\n }\n \n fn extend_lt<'a>(o: &'a str) -> &'static str {"}, {"sha": "d87ef2ec79c1a26bd14f122938098e1605769ab1", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked.stderr", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,26 +1,19 @@\n warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/bounds-are-checked.rs:9:6\n+  --> $DIR/bounds-are-checked.rs:8:6\n    |\n LL | fn f<'a: 'static>(t: &'a str) -> X<'a> {\n    |      ^^^^^^^^^^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n \n-error[E0308]: mismatched types\n-  --> $DIR/bounds-are-checked.rs:6:14\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/bounds-are-checked.rs:10:5\n    |\n LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected trait `From<&'a str>`\n-              found trait `From<&'static str>`\n-note: the lifetime `'a` as defined here...\n-  --> $DIR/bounds-are-checked.rs:6:8\n-   |\n-LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n-   |        ^^\n-   = note: ...does not necessarily outlive the static lifetime\n+   |        -- cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+...\n+LL |     t\n+   |     ^\n \n error: aborting due to previous error; 1 warning emitted\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "6febd07157aa60fdbdcda2d5f8698e4ba7f78b00", "filename": "src/test/ui/type-alias-impl-trait/declared_but_never_defined.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -3,4 +3,4 @@\n fn main() {}\n \n // declared but never defined\n-type Bar = impl std::fmt::Debug; //~ ERROR could not find defining uses\n+type Bar = impl std::fmt::Debug; //~ ERROR unconstrained opaque type"}, {"sha": "60bc24320a301c25bf90ce300ee2a1813351d4b4", "filename": "src/test/ui/type-alias-impl-trait/declared_but_never_defined.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,10 @@\n-error: could not find defining uses\n+error: unconstrained opaque type\n   --> $DIR/declared_but_never_defined.rs:6:12\n    |\n LL | type Bar = impl std::fmt::Debug;\n    |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Bar` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n "}, {"sha": "5bda5f0fceaaa6dba9dd7e78fa2e554ee3d2ebb2", "filename": "src/test/ui/type-alias-impl-trait/declared_but_not_defined_in_scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -4,7 +4,7 @@ fn main() {}\n \n mod boo {\n     // declared in module but not defined inside of it\n-    pub type Boo = impl ::std::fmt::Debug; //~ ERROR could not find defining uses\n+    pub type Boo = impl ::std::fmt::Debug; //~ ERROR unconstrained opaque type\n }\n \n fn bomp() -> boo::Boo {"}, {"sha": "26308c6ff6b1511936c671cb83239f649595cb4a", "filename": "src/test/ui/type-alias-impl-trait/declared_but_not_defined_in_scope.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,22 +1,22 @@\n-error: could not find defining uses\n+error: unconstrained opaque type\n   --> $DIR/declared_but_not_defined_in_scope.rs:7:20\n    |\n LL |     pub type Boo = impl ::std::fmt::Debug;\n    |                    ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Boo` must be used in combination with a concrete type within the same module\n \n error[E0308]: mismatched types\n   --> $DIR/declared_but_not_defined_in_scope.rs:11:5\n    |\n LL |     pub type Boo = impl ::std::fmt::Debug;\n    |                    ---------------------- the expected opaque type\n ...\n-LL | fn bomp() -> boo::Boo {\n-   |              -------- expected `impl Debug` because of return type\n LL |     \"\"\n    |     ^^ expected opaque type, found `&str`\n    |\n-   = note: expected opaque type `impl Debug`\n-                found reference `&'static str`\n+   = note: expected opaque type `Boo`\n+                found reference `&str`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7740f774ebca4ad58af5c3869026abc758ce473d", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,5 +1,5 @@\n #![feature(type_alias_impl_trait)]\n-\n+// check-pass\n fn main() {}\n \n // two definitions with different types\n@@ -10,11 +10,9 @@ fn foo() -> Foo {\n }\n \n fn bar() -> Foo {\n-    //~^ ERROR concrete type differs from previous\n     panic!()\n }\n \n fn boo() -> Foo {\n-    //~^ ERROR concrete type differs from previous\n     loop {}\n }"}, {"sha": "6274029e4f524b0772100efea89953411b7bb57e", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type.stderr", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1,26 +0,0 @@\n-error: concrete type differs from previous defining opaque type use\n-  --> $DIR/different_defining_uses_never_type.rs:12:1\n-   |\n-LL | fn bar() -> Foo {\n-   | ^^^^^^^^^^^^^^^ expected `&'static str`, got `()`\n-   |\n-note: previous use here\n-  --> $DIR/different_defining_uses_never_type.rs:8:1\n-   |\n-LL | fn foo() -> Foo {\n-   | ^^^^^^^^^^^^^^^\n-\n-error: concrete type differs from previous defining opaque type use\n-  --> $DIR/different_defining_uses_never_type.rs:17:1\n-   |\n-LL | fn boo() -> Foo {\n-   | ^^^^^^^^^^^^^^^ expected `&'static str`, got `()`\n-   |\n-note: previous use here\n-  --> $DIR/different_defining_uses_never_type.rs:8:1\n-   |\n-LL | fn foo() -> Foo {\n-   | ^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "d7e93335f47faaa2b4f4f08f7e676e44cda0ba8d", "filename": "src/test/ui/type-alias-impl-trait/fallback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,5 +1,5 @@\n-// Tests that we correctly handle the instantiated\n-// inference variable being completely unconstrained.\n+// Tests that we correctly handle opaque types being used opaquely,\n+// even within their defining scope.\n //\n // check-pass\n #![feature(type_alias_impl_trait)]"}, {"sha": "d99ed58127bd44e127e390f73958b1f9f1aaddd3", "filename": "src/test/ui/type-alias-impl-trait/field-types.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,20 +1,18 @@\n #![feature(type_alias_impl_trait)]\n #![allow(dead_code)]\n \n-// FIXME This should compile, but it currently doesn't\n+// check-pass\n \n use std::fmt::Debug;\n \n type Foo = impl Debug;\n-//~^ ERROR: could not find defining uses\n \n struct Bar {\n     foo: Foo,\n }\n \n fn bar() -> Bar {\n     Bar { foo: \"foo\" }\n-    //~^ ERROR: mismatched types [E0308]\n }\n \n fn main() {}"}, {"sha": "18c2abbdf37213900b5df5746159f6059519ce26", "filename": "src/test/ui/type-alias-impl-trait/field-types.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.stderr?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1,21 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/field-types.rs:16:16\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-...\n-LL |     Bar { foo: \"foo\" }\n-   |                ^^^^^ expected opaque type, found `&str`\n-   |\n-   = note: expected opaque type `impl Debug`\n-                found reference `&'static str`\n-\n-error: could not find defining uses\n-  --> $DIR/field-types.rs:8:12\n-   |\n-LL | type Foo = impl Debug;\n-   |            ^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "c9b9e128f88e2af5930ded809662381f75202870", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_lifetime_param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -3,9 +3,9 @@\n fn main() {}\n \n type Two<'a, 'b> = impl std::fmt::Debug;\n-//~^ ERROR could not find defining uses\n+\n \n fn one<'a>(t: &'a ()) -> Two<'a, 'a> {\n-    //~^ ERROR non-defining opaque type use\n     t\n+    //~^ ERROR non-defining opaque type use\n }"}, {"sha": "222aaea78d9829a60638027746bcfeab425718f3", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_lifetime_param.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,20 +1,14 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_lifetime_param.rs:8:26\n+  --> $DIR/generic_duplicate_lifetime_param.rs:9:5\n    |\n-LL | fn one<'a>(t: &'a ()) -> Two<'a, 'a> {\n-   |                          ^^^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n note: lifetime used multiple times\n   --> $DIR/generic_duplicate_lifetime_param.rs:5:10\n    |\n LL | type Two<'a, 'b> = impl std::fmt::Debug;\n    |          ^^  ^^\n \n-error: could not find defining uses\n-  --> $DIR/generic_duplicate_lifetime_param.rs:5:20\n-   |\n-LL | type Two<'a, 'b> = impl std::fmt::Debug;\n-   |                    ^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "093c1c231861f1893fb4c0e68d35a21546575ddc", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -6,23 +6,23 @@ fn main() {}\n \n // test that unused generic parameters are ok\n type TwoTys<T, U> = impl Debug;\n-//~^ ERROR could not find defining uses\n+\n type TwoLifetimes<'a, 'b> = impl Debug;\n-//~^ ERROR could not find defining uses\n+\n type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n-//~^ ERROR could not find defining uses\n+\n \n fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     t\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     t\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn one_const<const N: usize>(t: *mut [u8; N]) -> TwoConsts<N, N> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     t\n+    //~^ ERROR non-defining opaque type use in defining scope\n }"}, {"sha": "922e41e0f688344b8a0ad57c80fa7926f758f699", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.stderr", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,56 +1,38 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:15:30\n+  --> $DIR/generic_duplicate_param_use.rs:16:5\n    |\n-LL | fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n-   |                              ^^^^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n note: type used multiple times\n   --> $DIR/generic_duplicate_param_use.rs:8:13\n    |\n LL | type TwoTys<T, U> = impl Debug;\n    |             ^  ^\n \n-error: could not find defining uses\n-  --> $DIR/generic_duplicate_param_use.rs:8:21\n-   |\n-LL | type TwoTys<T, U> = impl Debug;\n-   |                     ^^^^^^^^^^\n-\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:20:36\n+  --> $DIR/generic_duplicate_param_use.rs:21:5\n    |\n-LL | fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {\n-   |                                    ^^^^^^^^^^^^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n note: lifetime used multiple times\n   --> $DIR/generic_duplicate_param_use.rs:10:19\n    |\n LL | type TwoLifetimes<'a, 'b> = impl Debug;\n    |                   ^^  ^^\n \n-error: could not find defining uses\n-  --> $DIR/generic_duplicate_param_use.rs:10:29\n-   |\n-LL | type TwoLifetimes<'a, 'b> = impl Debug;\n-   |                             ^^^^^^^^^^\n-\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:25:50\n+  --> $DIR/generic_duplicate_param_use.rs:26:5\n    |\n-LL | fn one_const<const N: usize>(t: *mut [u8; N]) -> TwoConsts<N, N> {\n-   |                                                  ^^^^^^^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n note: constant used multiple times\n   --> $DIR/generic_duplicate_param_use.rs:12:22\n    |\n LL | type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n    |                      ^               ^\n \n-error: could not find defining uses\n-  --> $DIR/generic_duplicate_param_use.rs:12:50\n-   |\n-LL | type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n-   |                                                  ^^^^^^^^^^\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "81bf9770d02a8b3cf7367f6f3407a3febcb9d470", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,11 +8,6 @@ fn main() {}\n type Two<T, U> = impl Debug;\n //~^ ERROR `T` doesn't implement `Debug`\n \n-fn one<T: Debug>(t: T) -> Two<T, T> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n-    t\n-}\n-\n fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n     t\n }"}, {"sha": "84aa260b099b65c9f63bea169118d3c4dfe0ef6d", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,15 +1,3 @@\n-error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use2.rs:11:27\n-   |\n-LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n-   |                           ^^^^^^^^^\n-   |\n-note: type used multiple times\n-  --> $DIR/generic_duplicate_param_use2.rs:8:10\n-   |\n-LL | type Two<T, U> = impl Debug;\n-   |          ^  ^\n-\n error[E0277]: `T` doesn't implement `Debug`\n   --> $DIR/generic_duplicate_param_use2.rs:8:18\n    |\n@@ -21,6 +9,6 @@ help: consider restricting type parameter `T`\n LL | type Two<T: std::fmt::Debug, U> = impl Debug;\n    |           +++++++++++++++++\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "c95692182c2780a0dc3faba27906c5cd79e52b37", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,11 +8,6 @@ fn main() {}\n type Two<T, U> = impl Debug;\n //~^ ERROR `T` doesn't implement `Debug`\n \n-fn one<T: Debug>(t: T) -> Two<T, T> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n-    t\n-}\n-\n fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n     t\n }"}, {"sha": "e5a70fa8ce56e38e4b06000d7839e876af427308", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,23 +1,11 @@\n-error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use3.rs:11:27\n-   |\n-LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n-   |                           ^^^^^^^^^\n-   |\n-note: type used multiple times\n-  --> $DIR/generic_duplicate_param_use3.rs:8:10\n-   |\n-LL | type Two<T, U> = impl Debug;\n-   |          ^  ^\n-\n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/generic_duplicate_param_use3.rs:20:1\n+  --> $DIR/generic_duplicate_param_use3.rs:15:1\n    |\n LL | fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `T`, got `U`\n    |\n note: previous use here\n-  --> $DIR/generic_duplicate_param_use3.rs:16:1\n+  --> $DIR/generic_duplicate_param_use3.rs:11:1\n    |\n LL | fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -33,6 +21,6 @@ help: consider restricting type parameter `T`\n LL | type Two<T: std::fmt::Debug, U> = impl Debug;\n    |           +++++++++++++++++\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "aee2550e9078a8ed23e7c27bc20046b1e817bd70", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -8,11 +8,6 @@ fn main() {}\n type Two<T, U> = impl Debug;\n //~^ ERROR `U` doesn't implement `Debug`\n \n-fn one<T: Debug>(t: T) -> Two<T, T> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n-    t\n-}\n-\n fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n     u\n }"}, {"sha": "0491d61030e3442f75741deeb9f0c8588c8959ce", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,15 +1,3 @@\n-error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use4.rs:11:27\n-   |\n-LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n-   |                           ^^^^^^^^^\n-   |\n-note: type used multiple times\n-  --> $DIR/generic_duplicate_param_use4.rs:8:10\n-   |\n-LL | type Two<T, U> = impl Debug;\n-   |          ^  ^\n-\n error[E0277]: `U` doesn't implement `Debug`\n   --> $DIR/generic_duplicate_param_use4.rs:8:18\n    |\n@@ -21,6 +9,6 @@ help: consider restricting type parameter `U`\n LL | type Two<T, U: std::fmt::Debug> = impl Debug;\n    |              +++++++++++++++++\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "f39741a6a625cc2d693309227e45982ad3515156", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -5,25 +5,25 @@ use std::fmt::Debug;\n fn main() {}\n \n type OneTy<T> = impl Debug;\n-//~^ ERROR could not find defining uses\n+\n type OneLifetime<'a> = impl Debug;\n-//~^ ERROR could not find defining uses\n+\n type OneConst<const X: usize> = impl Debug;\n-//~^ ERROR could not find defining uses\n+\n \n // Not defining uses, because they doesn't define *all* possible generics.\n \n fn concrete_ty() -> OneTy<u32> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     5u32\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn concrete_lifetime() -> OneLifetime<'static> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     6u32\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn concrete_const() -> OneConst<{ 123 }> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     7u32\n+    //~^ ERROR non-defining opaque type use in defining scope\n }"}, {"sha": "36694900c17b4af5615f2b501cd68e15af2c4ce2", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.stderr", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,53 +1,35 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:16:21\n+  --> $DIR/generic_nondefining_use.rs:17:5\n    |\n-LL | fn concrete_ty() -> OneTy<u32> {\n-   |                     ^^^^^^^^^^\n+LL |     5u32\n+   |     ^^^^\n    |\n note: used non-generic type `u32` for generic parameter\n   --> $DIR/generic_nondefining_use.rs:7:12\n    |\n LL | type OneTy<T> = impl Debug;\n    |            ^\n \n-error: could not find defining uses\n-  --> $DIR/generic_nondefining_use.rs:7:17\n-   |\n-LL | type OneTy<T> = impl Debug;\n-   |                 ^^^^^^^^^^\n-\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:21:27\n+  --> $DIR/generic_nondefining_use.rs:22:5\n    |\n LL | type OneLifetime<'a> = impl Debug;\n    |                  -- cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n ...\n-LL | fn concrete_lifetime() -> OneLifetime<'static> {\n-   |                           ^^^^^^^^^^^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/generic_nondefining_use.rs:9:24\n-   |\n-LL | type OneLifetime<'a> = impl Debug;\n-   |                        ^^^^^^^^^^\n+LL |     6u32\n+   |     ^^^^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:26:24\n+  --> $DIR/generic_nondefining_use.rs:27:5\n    |\n-LL | fn concrete_const() -> OneConst<{ 123 }> {\n-   |                        ^^^^^^^^^^^^^^^^^\n+LL |     7u32\n+   |     ^^^^\n    |\n note: used non-generic constant `123_usize` for generic parameter\n   --> $DIR/generic_nondefining_use.rs:11:21\n    |\n LL | type OneConst<const X: usize> = impl Debug;\n    |                     ^\n \n-error: could not find defining uses\n-  --> $DIR/generic_nondefining_use.rs:11:33\n-   |\n-LL | type OneConst<const X: usize> = impl Debug;\n-   |                                 ^^^^^^^^^^\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "c70f473cff57890ebdb6ba49478610756d9e6902", "filename": "src/test/ui/type-alias-impl-trait/generic_not_used.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -6,6 +6,6 @@ type WrongGeneric<T: 'static> = impl 'static;\n //~^ ERROR: at least one trait must be specified\n \n fn wrong_generic<U: 'static, V: 'static>(_: U, v: V) -> WrongGeneric<U> {\n-    //~^ ERROR type parameter `V` is part of concrete type but not used in parameter list\n     v\n+    //~^ ERROR type parameter `V` is part of concrete type but not used in parameter list\n }"}, {"sha": "fd720239a5239adb002b24137a9bb4f58d4594b8", "filename": "src/test/ui/type-alias-impl-trait/generic_not_used.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -5,14 +5,10 @@ LL | type WrongGeneric<T: 'static> = impl 'static;\n    |                                 ^^^^^^^^^^^^\n \n error: type parameter `V` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/generic_not_used.rs:8:73\n+  --> $DIR/generic_not_used.rs:9:5\n    |\n-LL |   fn wrong_generic<U: 'static, V: 'static>(_: U, v: V) -> WrongGeneric<U> {\n-   |  _________________________________________________________________________^\n-LL | |\n-LL | |     v\n-LL | | }\n-   | |_^\n+LL |     v\n+   |     ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "dc85db66d32ba4d9adad945b9a9c4ef848712567", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.nll.stderr", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,41 +1,29 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:10:24\n    |\n LL | type WrongGeneric<T> = impl 'static;\n    |                        ^^^^^^^^^^^^\n \n-error[E0308]: mismatched types\n+error: non-defining opaque type use in defining scope\n   --> $DIR/generic_type_does_not_live_long_enough.rs:6:18\n    |\n LL |     let z: i32 = x;\n-   |            ---   ^ expected `i32`, found opaque type\n-   |            |\n-   |            expected due to this\n-...\n-LL | type WrongGeneric<T> = impl 'static;\n-   |                        ------------ the found opaque type\n-   |\n-   = note:     expected type `i32`\n-           found opaque type `impl Sized`\n-\n-error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:12:30\n+   |                  ^\n    |\n-LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n-   |                              ^^^^^^^^^^^^^^^\n+note: used non-generic type `&'static i32` for generic parameter\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:10:19\n    |\n-   = help: consider adding an explicit lifetime bound `T: 'static`...\n+LL | type WrongGeneric<T> = impl 'static;\n+   |                   ^\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:14:5\n    |\n-LL | type WrongGeneric<T> = impl 'static;\n-   |                        ^^^^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n-   = note: ...so that the type `T` will meet its required lifetime bounds\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0308, E0310.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "cb90776472b5dc543fd395548d0cbe41082ca61f", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -3,13 +3,14 @@\n fn main() {\n     let y = 42;\n     let x = wrong_generic(&y);\n-    let z: i32 = x; //~ ERROR mismatched types\n+    let z: i32 = x;\n+    //~^ ERROR non-defining opaque type use\n }\n \n type WrongGeneric<T> = impl 'static;\n //~^ ERROR: at least one trait must be specified\n \n fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n-    //~^ ERROR the parameter type `T` may not live long enough\n     t\n+    //~^ ERROR the parameter type `T` may not live long enough\n }"}, {"sha": "15ec2eed3da4b0d521b2ea5e834841dc50969134", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.stderr", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,32 +1,29 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:10:24\n    |\n LL | type WrongGeneric<T> = impl 'static;\n    |                        ^^^^^^^^^^^^\n \n-error[E0308]: mismatched types\n+error: non-defining opaque type use in defining scope\n   --> $DIR/generic_type_does_not_live_long_enough.rs:6:18\n    |\n LL |     let z: i32 = x;\n-   |            ---   ^ expected `i32`, found opaque type\n-   |            |\n-   |            expected due to this\n-...\n-LL | type WrongGeneric<T> = impl 'static;\n-   |                        ------------ the found opaque type\n+   |                  ^\n+   |\n+note: used non-generic type `&'static i32` for generic parameter\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:10:19\n    |\n-   = note:     expected type `i32`\n-           found opaque type `impl Sized`\n+LL | type WrongGeneric<T> = impl 'static;\n+   |                   ^\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:12:30\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:14:5\n    |\n LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n-   |                  -           ^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |                  |\n-   |                  help: consider adding an explicit lifetime bound...: `T: 'static`\n+   |                  - help: consider adding an explicit lifetime bound...: `T: 'static`\n+LL |     t\n+   |     ^ ...so that the type `T` will meet its required lifetime bounds\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0308, E0310.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "608572978a3511028bd6aee0d4b00ae4eeb0471a", "filename": "src/test/ui/type-alias-impl-trait/inference-cycle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -3,7 +3,8 @@\n \n mod m {\n     type Foo = impl std::fmt::Debug;\n-    //~^ ERROR: cycle detected when computing type of `m::Foo::{opaque#0}` [E0391]\n+    //~^ ERROR cycle detected\n+    //~| ERROR cycle detected\n \n     // Cycle: error today, but it'd be nice if it eventually worked\n \n@@ -17,7 +18,6 @@ mod m {\n \n     fn baz() {\n         let f: Foo = 22_u32;\n-        //~^ ERROR: mismatched types [E0308]\n     }\n \n     fn is_send<T: Send>(_: T) {}"}, {"sha": "3ed86fae8a18de54ec6d4c4ba3ba522a49360ae5", "filename": "src/test/ui/type-alias-impl-trait/inference-cycle.stderr", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -5,33 +5,35 @@ LL |     type Foo = impl std::fmt::Debug;\n    |                ^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires type-checking `m::bar`...\n-  --> $DIR/inference-cycle.rs:15:9\n+  --> $DIR/inference-cycle.rs:15:5\n    |\n-LL |         is_send(foo()); // Today: error\n-   |         ^^^^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::fmt::Debug: core::marker::Send`...\n+LL |     pub fn bar() {\n+   |     ^^^^^^^^^^^^\n    = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in module `m`\n   --> $DIR/inference-cycle.rs:4:1\n    |\n LL | mod m {\n    | ^^^^^\n \n-error[E0308]: mismatched types\n-  --> $DIR/inference-cycle.rs:19:22\n+error[E0391]: cycle detected when computing type of `m::Foo::{opaque#0}`\n+  --> $DIR/inference-cycle.rs:5:16\n    |\n LL |     type Foo = impl std::fmt::Debug;\n-   |                -------------------- the expected opaque type\n-...\n-LL |         let f: Foo = 22_u32;\n-   |                ---   ^^^^^^ expected opaque type, found `u32`\n-   |                |\n-   |                expected due to this\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `u32`\n+   |                ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires type-checking `m::bar`...\n+  --> $DIR/inference-cycle.rs:15:5\n+   |\n+LL |     pub fn bar() {\n+   |     ^^^^^^^^^^^^\n+   = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in module `m`\n+  --> $DIR/inference-cycle.rs:4:1\n+   |\n+LL | mod m {\n+   | ^^^^^\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0308, E0391.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "34be42027440904a206ea52cc130dbb0268634a6", "filename": "src/test/ui/type-alias-impl-trait/issue-53598.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -18,8 +18,8 @@ impl Foo for S2 {\n     type Item = impl Debug;\n \n     fn foo<T: Debug>(_: T) -> Self::Item {\n-        //~^ Error type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n         S::<T>(Default::default())\n+        //~^ Error type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n     }\n }\n "}, {"sha": "34f0aa0d98d9ab781fb346b9592bca16dcc87f95", "filename": "src/test/ui/type-alias-impl-trait/issue-53598.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,12 +1,8 @@\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-53598.rs:20:42\n+  --> $DIR/issue-53598.rs:21:9\n    |\n-LL |       fn foo<T: Debug>(_: T) -> Self::Item {\n-   |  __________________________________________^\n-LL | |\n-LL | |         S::<T>(Default::default())\n-LL | |     }\n-   | |_____^\n+LL |         S::<T>(Default::default())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "1538274d45cb22a5c3b9db37c3f9b5c06ac23a82", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.nll.stderr", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,38 +1,14 @@\n error: higher-ranked subtype error\n-  --> $DIR/issue-57611-trait-alias.rs:21:9\n+  --> $DIR/issue-57611-trait-alias.rs:20:9\n    |\n LL |         |x| x\n    |         ^^^^^\n \n error: higher-ranked subtype error\n-  --> $DIR/issue-57611-trait-alias.rs:21:9\n+  --> $DIR/issue-57611-trait-alias.rs:20:9\n    |\n LL |         |x| x\n    |         ^^^^^\n \n-error[E0308]: mismatched types\n-  --> $DIR/issue-57611-trait-alias.rs:17:16\n-   |\n-LL |     type Bar = impl Baz<Self, Self>;\n-   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n-   |\n-   = note: expected type `for<'r> Fn<(&'r X,)>`\n-              found type `Fn<(&'static X,)>`\n-note: this closure does not fulfill the lifetime requirements\n-  --> $DIR/issue-57611-trait-alias.rs:21:9\n-   |\n-LL |         |x| x\n-   |         ^^^^^\n-\n-error: implementation of `FnOnce` is not general enough\n-  --> $DIR/issue-57611-trait-alias.rs:17:16\n-   |\n-LL |     type Bar = impl Baz<Self, Self>;\n-   |                ^^^^^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n-   |\n-   = note: closure with signature `fn(&'static X) -> &'static X` must implement `FnOnce<(&'0 X,)>`, for any lifetime `'0`...\n-   = note: ...but it actually implements `FnOnce<(&'static X,)>`\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "7c6e764248479544c20025f46403e2bb04741252", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -17,8 +17,8 @@ impl Foo for X {\n     type Bar = impl Baz<Self, Self>;\n \n     fn bar(&self) -> Self::Bar {\n-        //~^ ERROR implementation of `FnOnce` is not general enough\n         |x| x\n+        //~^ ERROR implementation of `FnOnce` is not general enough\n     }\n }\n "}, {"sha": "45329ea292dcf6791c327d5c0c742135f9dccb8a", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,8 +1,8 @@\n error: implementation of `FnOnce` is not general enough\n-  --> $DIR/issue-57611-trait-alias.rs:19:22\n+  --> $DIR/issue-57611-trait-alias.rs:20:9\n    |\n-LL |     fn bar(&self) -> Self::Bar {\n-   |                      ^^^^^^^^^ implementation of `FnOnce` is not general enough\n+LL |         |x| x\n+   |         ^^^^^ implementation of `FnOnce` is not general enough\n    |\n    = note: closure with signature `fn(&'2 X) -> &X` must implement `FnOnce<(&'1 X,)>`, for any lifetime `'1`...\n    = note: ...but it actually implements `FnOnce<(&'2 X,)>`, for some specific lifetime `'2`"}, {"sha": "ba8bda76cecf6cf5473af6e0e9beafec3bb2a037", "filename": "src/test/ui/type-alias-impl-trait/issue-57700.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -14,8 +14,8 @@ impl<C> Foo for C {\n     type Bar = impl Foo;\n \n     fn foo(self: impl Deref<Target = Self>) -> Self::Bar {\n-        //~^ Error type parameter `impl Deref<Target = Self>` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n         self\n+        //~^ Error type parameter `impl Deref<Target = Self>` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n     }\n }\n "}, {"sha": "56ad997f843142e7de6f4213810ea76a4003aad2", "filename": "src/test/ui/type-alias-impl-trait/issue-57700.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,12 +1,8 @@\n error: type parameter `impl Deref<Target = Self>` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-57700.rs:16:58\n+  --> $DIR/issue-57700.rs:17:9\n    |\n-LL |       fn foo(self: impl Deref<Target = Self>) -> Self::Bar {\n-   |  __________________________________________________________^\n-LL | |\n-LL | |         self\n-LL | |     }\n-   | |_____^\n+LL |         self\n+   |         ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e4ba7f8e2a6238c87f13b61086309a636baf6820", "filename": "src/test/ui/type-alias-impl-trait/issue-58951-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951-2.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+mod defining_use_scope {\n+    pub type A = impl Iterator;\n+\n+    pub fn def_a() -> A {\n+        0..1\n+    }\n+}\n+use defining_use_scope::*;\n+\n+pub fn use_a() {\n+    def_a().map(|x| x);\n+}\n+\n+fn main() {}"}, {"sha": "37a2f28ce074fed466fbb7dcb3f4b95ef7a0a7cd", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -11,7 +11,6 @@ impl Bug for &() {\n \n     const FUN: fn() -> Self::Item = || ();\n     //~^ ERROR the trait bound `(): Bug` is not satisfied\n-    //~| ERROR non-defining opaque type use in defining scope\n }\n \n fn main() {}"}, {"sha": "3666b6e97ecfddbfe748d9c1c3d198186327ba78", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -11,21 +11,12 @@ error[E0277]: the trait bound `(): Bug` is not satisfied\n   --> $DIR/issue-60371.rs:12:40\n    |\n LL |     const FUN: fn() -> Self::Item = || ();\n-   |                                        ^ the trait `Bug` is not implemented for `()`\n+   |                                        ^^ the trait `Bug` is not implemented for `()`\n    |\n    = help: the following implementations were found:\n              <&() as Bug>\n \n-error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-60371.rs:12:37\n-   |\n-LL | impl Bug for &() {\n-   |              - cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n-...\n-LL |     const FUN: fn() -> Self::Item = || ();\n-   |                                     ^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0277, E0658.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "4fc7679311a2e55b031dd0cf0c460c979476212b", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -6,7 +6,6 @@ trait IterBits {\n }\n \n type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n-//~^ ERROR could not find defining uses\n \n impl<T: Copy, E> IterBits for T\n where\n@@ -18,8 +17,8 @@ where\n {\n     type BitsIter = IterBitsIter<T, E, u8>;\n     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-        //~^ ERROR non-defining opaque type use in defining scope\n         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n+        //~^ ERROR non-defining opaque type use in defining scope\n     }\n }\n "}, {"sha": "bbc93657be32f27501c851460adbfb0554ee0826", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,20 +1,14 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-60564.rs:20:34\n+  --> $DIR/issue-60564.rs:20:9\n    |\n-LL |     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-   |                                  ^^^^^^^^^^^^^^\n+LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: used non-generic type `u8` for generic parameter\n   --> $DIR/issue-60564.rs:8:25\n    |\n LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n    |                         ^\n \n-error: could not find defining uses\n-  --> $DIR/issue-60564.rs:8:30\n-   |\n-LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "057a908bbee7477ebc76e1a4fee02e37ca103e98", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -5,7 +5,10 @@\n type Closure = impl FnOnce();\n \n fn c() -> Closure {\n-    || -> Closure { || () } //~ ERROR: mismatched types\n+    || -> Closure { || () }\n+    //~^ ERROR: mismatched types\n+    //~| ERROR: mismatched types\n+    //~| ERROR: expected a `FnOnce<()>` closure, found `()`\n }\n \n fn main() {}"}, {"sha": "4b7dbbd6a56cc2f9d7a89c4d80ea326407f9f32b", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.stderr", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc3bddbe0d0e374d05e7003e662bba1742dbae/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr?ref=e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "patch": "@@ -1,17 +1,34 @@\n+error[E0277]: expected a `FnOnce<()>` closure, found `()`\n+  --> $DIR/issue-63279.rs:8:11\n+   |\n+LL |     || -> Closure { || () }\n+   |           ^^^^^^^ expected an `FnOnce<()>` closure, found `()`\n+   |\n+   = help: the trait `FnOnce<()>` is not implemented for `()`\n+   = note: wrap the `()` in a closure with no arguments: `|| { /* code */ }`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-63279.rs:8:21\n+   |\n+LL |     || -> Closure { || () }\n+   |                     ^^^^^ expected `()`, found closure\n+   |\n+   = note: expected unit type `()`\n+                found closure `[closure@$DIR/issue-63279.rs:8:21: 8:26]`\n+\n error[E0308]: mismatched types\n   --> $DIR/issue-63279.rs:8:5\n    |\n LL | type Closure = impl FnOnce();\n-   |                ------------- the found opaque type\n+   |                ------------- the expected opaque type\n ...\n LL |     || -> Closure { || () }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found a different closure\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found closure\n    |\n-   = note: expected type `[closure@$DIR/issue-63279.rs:8:21: 8:26]`\n-           found closure `[closure@$DIR/issue-63279.rs:8:5: 8:28]`\n-   = note: no two closures, even if identical, have the same type\n-   = help: consider boxing your closure and/or using it as a trait object\n+   = note: expected opaque type `Closure`\n+                  found closure `[closure@$DIR/issue-63279.rs:8:5: 8:28]`\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0277, E0308.\n+For more information about an error, try `rustc --explain E0277`."}]}