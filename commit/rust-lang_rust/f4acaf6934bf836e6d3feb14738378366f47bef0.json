{"sha": "f4acaf6934bf836e6d3feb14738378366f47bef0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YWNhZjY5MzRiZjgzNmU2ZDNmZWIxNDczODM3ODM2NmY0N2JlZjA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-18T18:30:40Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-18T18:41:44Z"}, "message": "Only look for a matching method when normal field access fails\n\nWe should probalby warn when defining a method foo on {foo: int} etc.\n\nThis should reduce the amount of useless typevars that are allocated.\n\nIssue #1227", "tree": {"sha": "736fc558d90143d84d62e73cd1159edccb2e4ce7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/736fc558d90143d84d62e73cd1159edccb2e4ce7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4acaf6934bf836e6d3feb14738378366f47bef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4acaf6934bf836e6d3feb14738378366f47bef0", "html_url": "https://github.com/rust-lang/rust/commit/f4acaf6934bf836e6d3feb14738378366f47bef0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4acaf6934bf836e6d3feb14738378366f47bef0/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b36ade1367a2dbca69386b58d225ceafa6a90d57", "url": "https://api.github.com/repos/rust-lang/rust/commits/b36ade1367a2dbca69386b58d225ceafa6a90d57", "html_url": "https://github.com/rust-lang/rust/commit/b36ade1367a2dbca69386b58d225ceafa6a90d57"}], "stats": {"total": 215, "additions": 120, "deletions": 95}, "files": [{"sha": "acec464e6f8e895c53f5bdf80fcdb81ce91ca8d1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f4acaf6934bf836e6d3feb14738378366f47bef0", "patch": "@@ -2759,7 +2759,7 @@ fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n     let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n     let mths = alt ty::struct(tcx, o_ty) { ty::ty_obj(ms) { ms } };\n \n-    let ix = ty::method_idx(ccx.sess, bcx.sp, field, mths);\n+    let ix = option::get(ty::method_idx(field, mths));\n     let vtbl = Load(bcx, GEPi(bcx, o, [0, abi::obj_field_vtbl]));\n     let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n     vtbl = PointerCast(bcx, vtbl, vtbl_type);\n@@ -2782,7 +2782,7 @@ fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let {bcx, val, ty} = autoderef(bcx, val, ty::expr_ty(bcx_tcx(bcx), base));\n     let fields = alt ty::struct(bcx_tcx(bcx), ty) { ty::ty_rec(fs) { fs } };\n-    let ix = ty::field_idx(bcx_ccx(bcx).sess, bcx.sp, field, fields);\n+    let ix = option::get(ty::field_idx(field, fields));\n     // Silly check\n     check type_is_tup_like(bcx, ty);\n     let {bcx, val} = GEP_tup_like(bcx, ty, val, [0, ix as int]);"}, {"sha": "6e00521ef3b0a1a73676ad114a15d6f8b806ff66", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=f4acaf6934bf836e6d3feb14738378366f47bef0", "patch": "@@ -413,8 +413,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             alt ty::struct(ccx.tcx, rec_ty) { ty::ty_rec(fields) { fields } };\n         let rec_vals = [];\n         for field_name: ast::ident in rec_fields {\n-            let ix: uint =\n-                ty::field_idx(ccx.sess, dummy_sp(), field_name, fields);\n+            let ix = option::get(ty::field_idx(field_name, fields));\n             // not sure how to get rid of this check\n             check type_is_tup_like(bcx, rec_ty);\n             let r = trans::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n@@ -722,8 +721,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         let rec_fields =\n             alt ty::struct(ccx.tcx, rec_ty) { ty::ty_rec(fields) { fields } };\n         for f: ast::field_pat in fields {\n-            let ix: uint =\n-                ty::field_idx(ccx.sess, pat.span, f.ident, rec_fields);\n+            let ix = option::get(ty::field_idx(f.ident, rec_fields));\n             // how to get rid of this check?\n             check type_is_tup_like(bcx, rec_ty);\n             let r = trans::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);"}, {"sha": "b8c80da9ac71c296d0d531af19aa7ee9539294af", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=f4acaf6934bf836e6d3feb14738378366f47bef0", "patch": "@@ -642,7 +642,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     let ix: uint = 0u;\n     alt ty::struct(bcx_tcx(bcx), outer_obj_ty) {\n       ty::ty_obj(methods) {\n-        ix = ty::method_idx(cx.ccx.sess, sp, m.ident, methods);\n+        ix = option::get(ty::method_idx(m.ident, methods));\n       }\n       _ {\n         // Shouldn't happen.\n@@ -787,7 +787,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     let ix: uint = 0u;\n     alt ty::struct(bcx_tcx(bcx), inner_obj_ty) {\n       ty::ty_obj(methods) {\n-        ix = ty::method_idx(cx.ccx.sess, sp, m.ident, methods);\n+        ix = option::get(ty::method_idx(m.ident, methods));\n       }\n       _ {\n         // Shouldn't happen."}, {"sha": "521b73f3c11d2845edb5482af64c3e48f0b2ee66", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f4acaf6934bf836e6d3feb14738378366f47bef0", "patch": "@@ -1698,11 +1698,10 @@ fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n     }\n }\n \n-fn field_idx(sess: session::session, sp: span, id: ast::ident,\n-             fields: [field]) -> uint {\n-    let i: uint = 0u;\n-    for f: field in fields { if str::eq(f.ident, id) { ret i; } i += 1u; }\n-    sess.span_fatal(sp, \"unknown field '\" + id + \"' of record\");\n+fn field_idx(id: ast::ident, fields: [field]) -> option::t<uint> {\n+    let i = 0u;\n+    for f in fields { if f.ident == id { ret some(i); } i += 1u; }\n+    ret none;\n }\n \n fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n@@ -1715,11 +1714,10 @@ fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n     }\n }\n \n-fn method_idx(sess: session::session, sp: span, id: ast::ident,\n-              meths: [method]) -> uint {\n-    let i: uint = 0u;\n-    for m: method in meths { if str::eq(m.ident, id) { ret i; } i += 1u; }\n-    sess.span_fatal(sp, \"unknown method '\" + id + \"' of obj\");\n+fn method_idx(id: ast::ident, meths: [method]) -> option::t<uint> {\n+    let i = 0u;\n+    for m in meths { if m.ident == id { ret some(i); } i += 1u; }\n+    ret none;\n }\n \n fn sort_methods(meths: [method]) -> [method] {"}, {"sha": "ffe5004002edfa45a6c590d02262a575863ddaa1", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 76, "deletions": 68, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f4acaf6934bf836e6d3feb14738378366f47bef0", "patch": "@@ -1466,30 +1466,32 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n     -> option::t<{method: @resolve::method_info, ids: [int]}> {\n     let result = none;\n     std::list::iter(isc) {|impls|\n+        if option::is_some(result) { ret; }\n         for @{did, methods, _} in *impls {\n-            let (n_tps, self_ty) = if did.crate == ast::local_crate {\n-                alt fcx.ccx.tcx.items.get(did.node) {\n-                  ast_map::node_item(@{node: ast::item_impl(tps, st, _), _}) {\n-                    (vec::len(tps), ast_ty_to_ty_crate(fcx.ccx, st))\n-                  }\n-                }\n-            } else {\n-                let tpt = csearch::get_type(fcx.ccx.tcx, did);\n-                (vec::len(tpt.kinds), tpt.ty)\n-            };\n-            let {ids, ty: self_ty} = if n_tps > 0u {\n-                bind_params_in_type(ast_util::dummy_sp(), fcx.ccx.tcx,\n-                                    bind next_ty_var_id(fcx), self_ty, n_tps)\n-            } else { {ids: [], ty: self_ty} };\n-            // FIXME[impl] Don't unify in the current fcx, use\n-            // scratch context\n-            alt unify::unify(fcx, ty, self_ty) {\n-              ures_ok(_) {\n-                for m in methods {\n-                    if m.ident == name {\n-                        result = some({method: m, ids: ids});\n-                        ret;\n+            alt vec::find(methods, {|m| m.ident == name}) {\n+              some(m) {\n+                let (n_tps, self_ty) = if did.crate == ast::local_crate {\n+                    alt fcx.ccx.tcx.items.get(did.node) {\n+                      ast_map::node_item(@{node: ast::item_impl(tps, st, _),\n+                                           _}) {\n+                        (vec::len(tps), ast_ty_to_ty_crate(fcx.ccx, st))\n+                      }\n                     }\n+                } else {\n+                    let tpt = csearch::get_type(fcx.ccx.tcx, did);\n+                    (vec::len(tpt.kinds), tpt.ty)\n+                };\n+                let {ids, ty: self_ty} = if n_tps > 0u {\n+                    bind_params_in_type(ast_util::dummy_sp(), fcx.ccx.tcx,\n+                                        bind next_ty_var_id(fcx), self_ty,\n+                                        n_tps)\n+                } else { {ids: [], ty: self_ty} };\n+                alt unify::unify(fcx, ty, self_ty) {\n+                  ures_ok(_) {\n+                    result = some({method: m, ids: ids});\n+                    ret;\n+                  }\n+                  _ {}\n                 }\n               }\n               _ {}\n@@ -2128,60 +2130,66 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_field(base, field) {\n         bot |= check_expr(fcx, base);\n-        let base_t = expr_ty(tcx, base);\n-        let iscope = fcx.ccx.impl_map.get(expr.id);\n-        alt lookup_method(fcx, iscope, field, base_t) {\n-          some({method, ids}) {\n-            let fty = if method.did.crate == ast::local_crate {\n-                alt tcx.items.get(method.did.node) {\n-                  ast_map::node_method(m) {\n-                    let mt = ty_of_method(tcx, m_check, m);\n-                    ty::mk_fn(tcx, mt.proto, mt.inputs,\n-                              mt.output, mt.cf, mt.constrs)\n-                  }\n-                }\n-            } else { csearch::get_type(tcx, method.did).ty };\n-            let ids = ids;\n-            if method.n_tps > 0u {\n-                let b = bind_params_in_type(expr.span, tcx,\n-                                            bind next_ty_var_id(fcx),\n-                                            fty, method.n_tps);\n-                ids += b.ids;\n-                fty = b.ty;\n-            }\n-            let substs = vec::map(ids, {|id| ty::mk_var(tcx, id)});\n-            write::ty_fixup(fcx, id, {substs: some(substs), ty: fty});\n-            fcx.ccx.method_map.insert(id, method.did);\n-          }\n-          _ {\n-            base_t = do_autoderef(fcx, expr.span, base_t);\n-            alt structure_of(fcx, expr.span, base_t) {\n-              ty::ty_rec(fields) {\n-                let ix = ty::field_idx(tcx.sess, expr.span, field, fields);\n-                if ix >= vec::len::<ty::field>(fields) {\n-                    tcx.sess.span_fatal(expr.span, \"bad index on record\");\n-                }\n+        let expr_t = expr_ty(tcx, base);\n+        let base_t = do_autoderef(fcx, expr.span, expr_t);\n+        let handled = false;\n+        alt structure_of(fcx, expr.span, base_t) {\n+          ty::ty_rec(fields) {\n+            alt ty::field_idx(field, fields) {\n+              some(ix) {\n                 write::ty_only_fixup(fcx, id, fields[ix].mt.ty);\n+                handled = true;\n               }\n-              ty::ty_obj(methods) {\n-                let ix = ty::method_idx(tcx.sess, expr.span, field, methods);\n-                if ix >= vec::len::<ty::method>(methods) {\n-                    tcx.sess.span_fatal(expr.span, \"bad index on obj\");\n-                }\n+              _ {}\n+            }\n+          }\n+          ty::ty_obj(methods) {\n+            alt ty::method_idx(field, methods) {\n+              some(ix) {\n                 let meth = methods[ix];\n-                let t = ty::mk_fn(tcx, meth.proto, meth.inputs, meth.output,\n-                                  meth.cf, meth.constrs);\n+                let t = ty::mk_fn(tcx, meth.proto, meth.inputs,\n+                                  meth.output, meth.cf, meth.constrs);\n                 write::ty_only_fixup(fcx, id, t);\n+                handled = true;\n               }\n-              _ {\n-                let t_err = resolve_type_vars_if_possible(fcx, base_t);\n-                let msg = #fmt[\"attempted field access on type %s, but no \\\n-                                method implementation was found\",\n-                               ty_to_str(tcx, t_err)];\n+              _ {}\n+            }\n+          }\n+          _ {}\n+        }\n+        if !handled {\n+            let iscope = fcx.ccx.impl_map.get(expr.id);\n+            alt lookup_method(fcx, iscope, field, expr_t) {\n+              some({method, ids}) {\n+                let fty = if method.did.crate == ast::local_crate {\n+                    alt tcx.items.get(method.did.node) {\n+                      ast_map::node_method(m) {\n+                        let mt = ty_of_method(tcx, m_check, m);\n+                        ty::mk_fn(tcx, mt.proto, mt.inputs,\n+                                  mt.output, mt.cf, mt.constrs)\n+                      }\n+                    }\n+                } else { csearch::get_type(tcx, method.did).ty };\n+                let ids = ids;\n+                if method.n_tps > 0u {\n+                    let b = bind_params_in_type(expr.span, tcx,\n+                                                bind next_ty_var_id(fcx),\n+                                                fty, method.n_tps);\n+                    ids += b.ids;\n+                    fty = b.ty;\n+                }\n+                let substs = vec::map(ids, {|id| ty::mk_var(tcx, id)});\n+                write::ty_fixup(fcx, id, {substs: some(substs), ty: fty});\n+                fcx.ccx.method_map.insert(id, method.did);\n+              }\n+              none. {\n+                let t_err = resolve_type_vars_if_possible(fcx, expr_t);\n+                let msg = #fmt[\"attempted access of field %s on type %s, but \\\n+                                no method implementation was found\",\n+                               field, ty_to_str(tcx, t_err)];\n                 tcx.sess.span_fatal(expr.span, msg);\n               }\n             }\n-          }\n         }\n       }\n       ast::expr_index(base, idx) {"}, {"sha": "9b3d047d43575f9b793501c04c9495d078865b24", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=f4acaf6934bf836e6d3feb14738378366f47bef0", "patch": "@@ -467,11 +467,10 @@ fn print_item(s: ps, &&item: @ast::item) {\n         space(s.s);\n         bopen(s);\n         for meth: @ast::method in _obj.methods {\n-            let typarams: [ast::ty_param] = [];\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, meth.span.lo);\n             print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n-                     meth.node.ident, typarams, []);\n+                     meth.node.ident, meth.node.tps, []);\n             word(s.s, \" \");\n             print_block(s, meth.node.meth.body);\n         }\n@@ -490,7 +489,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, meth.span.lo);\n             print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n-                     meth.node.ident, [], []);\n+                     meth.node.ident, meth.node.tps, []);\n             word(s.s, \" \");\n             print_block(s, meth.node.meth.body);\n         }\n@@ -964,11 +963,10 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n \n         // Methods\n         for meth: @ast::method in anon_obj.methods {\n-            let typarams: [ast::ty_param] = [];\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, meth.span.lo);\n             print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n-                     meth.node.ident, typarams, []);\n+                     meth.node.ident, meth.node.tps, []);\n             word(s.s, \" \");\n             print_block(s, meth.node.meth.body);\n         }"}, {"sha": "cb6557dea8ce266f31e3bb6fad151b8f026813c0", "filename": "src/test/compile-fail/direct-obj-fn-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs?ref=f4acaf6934bf836e6d3feb14738378366f47bef0", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: attempted field access\n+// error-pattern: attempted access of field hello\n \n obj x() {\n     fn hello() { log \"hello\"; }"}, {"sha": "21069a4832e27b08f942187a682e345be1731fde", "filename": "src/test/compile-fail/self-missing-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs?ref=f4acaf6934bf836e6d3feb14738378366f47bef0", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:attempted field access on type fn\n+// error-pattern:attempted access of field m on type fn\n fn main() {\n \n   obj foo() {"}, {"sha": "9e2c54003fe64dcd83a3f1417fc67fba7e42018a", "filename": "src/test/compile-fail/vec-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-field.rs?ref=f4acaf6934bf836e6d3feb14738378366f47bef0", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:attempted field access on type [int]\n+// error-pattern:attempted access of field some_field_name on type [int]\n // issue #367\n \n fn f() {"}, {"sha": "9d245a22bb7a7c5c1908cadc67c4e57d75f6d39b", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4acaf6934bf836e6d3feb14738378366f47bef0/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=f4acaf6934bf836e6d3feb14738378366f47bef0", "patch": "@@ -9,10 +9,33 @@ mod b {\n     impl baz for str { fn plus() -> int { 200 } }\n }\n \n+impl util for uint {\n+    fn str() -> str { uint::str(self) }\n+    fn times(f: block(uint)) {\n+        let c = 0u;\n+        while c < self { f(c); c += 1u; }\n+    }\n+}\n+\n+impl util<T> for [T] {\n+    fn len() -> uint { vec::len(self) }\n+    fn iter(f: block(T)) { for x in self { f(x); } }\n+    fn map<U>(f: block(T) -> U) -> [U] {\n+        let r = [];\n+        for elt in self { r += [f(elt)]; }\n+        r\n+    }\n+}\n+\n fn main() {\n     impl foo for int { fn plus() -> int { self + 10 } }\n     assert 10.plus() == 20;\n     assert 10u.plus() == 30;\n     assert \"hi\".plus() == 200;\n-}\n \n+    assert [1].len().str() == \"1\";\n+    assert [3, 4].map({|a| a + 4})[0] == 7;\n+    let x = 0u;\n+    10u.times {|_n| x += 2u;}\n+    assert x == 20u;\n+}"}]}