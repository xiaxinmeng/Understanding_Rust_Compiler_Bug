{"sha": "d6a9793722c1ab6066f4f71224aac078b54f03c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YTk3OTM3MjJjMWFiNjA2NmY0ZjcxMjI0YWFjMDc4YjU0ZjAzYzA=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2019-07-06T06:59:59Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2019-07-07T18:31:38Z"}, "message": "Use const generics for array impls, restricted to 0..=32\n\n- uses a never-stable core::array::LengthAtMost32 to bound the impls\n- includes a custom error message to avoid mentioning LengthAtMost32 too often\n- doesn't use macros for the slice implementations to avoid #62433", "tree": {"sha": "5b5b0c2a6ca83be7756b4066ad26df4cc30a0ca3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b5b0c2a6ca83be7756b4066ad26df4cc30a0ca3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6a9793722c1ab6066f4f71224aac078b54f03c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6a9793722c1ab6066f4f71224aac078b54f03c0", "html_url": "https://github.com/rust-lang/rust/commit/d6a9793722c1ab6066f4f71224aac078b54f03c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6a9793722c1ab6066f4f71224aac078b54f03c0/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "481068a707679257e2a738b40987246e0420e787", "url": "https://api.github.com/repos/rust-lang/rust/commits/481068a707679257e2a738b40987246e0420e787", "html_url": "https://github.com/rust-lang/rust/commit/481068a707679257e2a738b40987246e0420e787"}], "stats": {"total": 487, "additions": 479, "deletions": 8}, "files": [{"sha": "144543be7c465a00b31c8f0d09afd5a2a8b6ee9a", "filename": "src/libcore/array.rs", "status": "modified", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=d6a9793722c1ab6066f4f71224aac078b54f03c0", "patch": "@@ -81,6 +81,7 @@ impl From<Infallible> for TryFromSliceError {\n     }\n }\n \n+#[cfg(bootstrap)]\n macro_rules! __impl_slice_eq1 {\n     ($Lhs: ty, $Rhs: ty) => {\n         __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n@@ -96,6 +97,7 @@ macro_rules! __impl_slice_eq1 {\n     }\n }\n \n+#[cfg(bootstrap)]\n macro_rules! __impl_slice_eq2 {\n     ($Lhs: ty, $Rhs: ty) => {\n         __impl_slice_eq2! { $Lhs, $Rhs, Sized }\n@@ -114,6 +116,7 @@ macro_rules! __impl_slice_eq2 {\n }\n \n // macro for implementing n-element array functions and operations\n+#[cfg(bootstrap)]\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n@@ -264,6 +267,323 @@ macro_rules! array_impls {\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+mod impls_using_const_generics {\n+    use super::*;\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T, const N: usize> AsRef<[T]> for [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        #[inline]\n+        fn as_ref(&self) -> &[T] {\n+            &self[..]\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T, const N: usize> AsMut<[T]> for [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        #[inline]\n+        fn as_mut(&mut self) -> &mut [T] {\n+            &mut self[..]\n+        }\n+    }\n+\n+    #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n+    impl<T, const N: usize> Borrow<[T]> for [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        fn borrow(&self) -> &[T] {\n+            self\n+        }\n+    }\n+\n+    #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n+    impl<T, const N: usize> BorrowMut<[T]> for [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        fn borrow_mut(&mut self) -> &mut [T] {\n+            self\n+        }\n+    }\n+\n+    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+    impl<T, const N: usize> TryFrom<&[T]> for [T; N]\n+    where\n+        T: Copy,\n+        [T; N]: LengthAtMost32,\n+    {\n+        type Error = TryFromSliceError;\n+\n+        fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {\n+            <&Self>::try_from(slice).map(|r| *r)\n+        }\n+    }\n+\n+    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+    impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        type Error = TryFromSliceError;\n+\n+        fn try_from(slice: &[T]) -> Result<&[T; N], TryFromSliceError> {\n+            if slice.len() == N {\n+                let ptr = slice.as_ptr() as *const [T; N];\n+                unsafe { Ok(&*ptr) }\n+            } else {\n+                Err(TryFromSliceError(()))\n+            }\n+        }\n+    }\n+\n+    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+    impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        type Error = TryFromSliceError;\n+\n+        fn try_from(slice: &mut [T]) -> Result<&mut [T; N], TryFromSliceError> {\n+            if slice.len() == N {\n+                let ptr = slice.as_mut_ptr() as *mut [T; N];\n+                unsafe { Ok(&mut *ptr) }\n+            } else {\n+                Err(TryFromSliceError(()))\n+            }\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: Hash, const N: usize> Hash for [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+            Hash::hash(&self[..], state)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: fmt::Debug, const N: usize> fmt::Debug for [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            fmt::Debug::fmt(&&self[..], f)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T, const N: usize> IntoIterator for &'a [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        type Item = &'a T;\n+        type IntoIter = Iter<'a, T>;\n+\n+        fn into_iter(self) -> Iter<'a, T> {\n+            self.iter()\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T, const N: usize> IntoIterator for &'a mut [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        type Item = &'a mut T;\n+        type IntoIter = IterMut<'a, T>;\n+\n+        fn into_iter(self) -> IterMut<'a, T> {\n+            self.iter_mut()\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, 'b, A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n+    where\n+        A: PartialEq<B>,\n+        [A; N]: LengthAtMost32,\n+        [B; N]: LengthAtMost32,\n+    {\n+        #[inline]\n+        fn eq(&self, other: &[B; N]) -> bool {\n+            self[..] == other[..]\n+        }\n+        #[inline]\n+        fn ne(&self, other: &[B; N]) -> bool {\n+            self[..] != other[..]\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, 'b, A, B, const N: usize> PartialEq<[B]> for [A; N]\n+    where\n+        A: PartialEq<B>,\n+        [A; N]: LengthAtMost32,\n+    {\n+        #[inline]\n+        fn eq(&self, other: &[B]) -> bool {\n+            self[..] == other[..]\n+        }\n+        #[inline]\n+        fn ne(&self, other: &[B]) -> bool {\n+            self[..] != other[..]\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for [B]\n+    where\n+        B: PartialEq<A>,\n+        [A; N]: LengthAtMost32,\n+    {\n+        #[inline]\n+        fn eq(&self, other: &[A; N]) -> bool {\n+            self[..] == other[..]\n+        }\n+        #[inline]\n+        fn ne(&self, other: &[A; N]) -> bool {\n+            self[..] != other[..]\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, 'b, A, B, const N: usize> PartialEq<&'b [B]> for [A; N]\n+    where\n+        A: PartialEq<B>,\n+        [A; N]: LengthAtMost32,\n+    {\n+        #[inline]\n+        fn eq(&self, other: &&'b [B]) -> bool {\n+            self[..] == other[..]\n+        }\n+        #[inline]\n+        fn ne(&self, other: &&'b [B]) -> bool {\n+            self[..] != other[..]\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b [B]\n+    where\n+        B: PartialEq<A>,\n+        [A; N]: LengthAtMost32,\n+    {\n+        #[inline]\n+        fn eq(&self, other: &[A; N]) -> bool {\n+            self[..] == other[..]\n+        }\n+        #[inline]\n+        fn ne(&self, other: &[A; N]) -> bool {\n+            self[..] != other[..]\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, 'b, A, B, const N: usize> PartialEq<&'b mut [B]> for [A; N]\n+    where\n+        A: PartialEq<B>,\n+        [A; N]: LengthAtMost32,\n+    {\n+        #[inline]\n+        fn eq(&self, other: &&'b mut [B]) -> bool {\n+            self[..] == other[..]\n+        }\n+        #[inline]\n+        fn ne(&self, other: &&'b mut [B]) -> bool {\n+            self[..] != other[..]\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b mut [B]\n+    where\n+        B: PartialEq<A>,\n+        [A; N]: LengthAtMost32,\n+    {\n+        #[inline]\n+        fn eq(&self, other: &[A; N]) -> bool {\n+            self[..] == other[..]\n+        }\n+        #[inline]\n+        fn ne(&self, other: &[A; N]) -> bool {\n+            self[..] != other[..]\n+        }\n+    }\n+\n+    // NOTE: some less important impls are omitted to reduce code bloat\n+    // __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n+    // __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: Eq, const N: usize> Eq for [T; N] where [T; N]: LengthAtMost32 {}\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: PartialOrd, const N: usize> PartialOrd for [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        #[inline]\n+        fn partial_cmp(&self, other: &[T; N]) -> Option<Ordering> {\n+            PartialOrd::partial_cmp(&&self[..], &&other[..])\n+        }\n+        #[inline]\n+        fn lt(&self, other: &[T; N]) -> bool {\n+            PartialOrd::lt(&&self[..], &&other[..])\n+        }\n+        #[inline]\n+        fn le(&self, other: &[T; N]) -> bool {\n+            PartialOrd::le(&&self[..], &&other[..])\n+        }\n+        #[inline]\n+        fn ge(&self, other: &[T; N]) -> bool {\n+            PartialOrd::ge(&&self[..], &&other[..])\n+        }\n+        #[inline]\n+        fn gt(&self, other: &[T; N]) -> bool {\n+            PartialOrd::gt(&&self[..], &&other[..])\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: Ord, const N: usize> Ord for [T; N]\n+    where\n+        [T; N]: LengthAtMost32,\n+    {\n+        #[inline]\n+        fn cmp(&self, other: &[T; N]) -> Ordering {\n+            Ord::cmp(&&self[..], &&other[..])\n+        }\n+    }\n+}\n+\n+/// Implemented for lengths where trait impls are allowed on arrays in core/std\n+#[rustc_on_unimplemented(\n+    message=\"arrays only have std trait implementations for lengths 0..=32\",\n+)]\n+#[unstable(feature = \"const_generic_impls_guard\", issue = \"0\",\n+    reason = \"will never be stable, just a temporary step until const generics are stable\")]\n+#[cfg(not(bootstrap))]\n+pub trait LengthAtMost32 {}\n+\n+#[cfg(not(bootstrap))]\n+macro_rules! array_impls {\n+    ($($N:literal)+) => {\n+        $(\n+            #[unstable(feature = \"const_generic_impls_guard\", issue = \"0\")]\n+            impl<T> LengthAtMost32 for [T; $N] {}\n+        )+\n+    }\n+}\n+\n array_impls! {\n      0  1  2  3  4  5  6  7  8  9\n     10 11 12 13 14 15 16 17 18 19"}, {"sha": "278a63081a146b942deadedbf89a257269821c55", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=d6a9793722c1ab6066f4f71224aac078b54f03c0", "patch": "@@ -74,6 +74,7 @@\n #![feature(concat_idents)]\n #![feature(const_fn)]\n #![feature(const_fn_union)]\n+#![cfg_attr(not(bootstrap), feature(const_generics))]\n #![feature(custom_inner_attributes)]\n #![feature(doc_cfg)]\n #![feature(doc_spotlight)]"}, {"sha": "9998bb84ca0c0dd7fd9a73dff129074c08244b20", "filename": "src/test/ui/const-generics/array-impls/core-traits-impls-length-32.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-impls-length-32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-impls-length-32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-impls-length-32.rs?ref=d6a9793722c1ab6066f4f71224aac078b54f03c0", "patch": "@@ -0,0 +1,66 @@\n+// check-pass\n+\n+pub fn yes_as_ref() -> impl AsRef<[u8]> {\n+    [0; 32]\n+}\n+\n+pub fn yes_as_mut() -> impl AsMut<[u8]> {\n+    [0; 32]\n+}\n+\n+pub fn yes_borrow() -> impl std::borrow::Borrow<[u8]> {\n+    [0; 32]\n+}\n+\n+pub fn yes_borrow_mut() -> impl std::borrow::BorrowMut<[u8]> {\n+    [0; 32]\n+}\n+\n+pub fn yes_try_from_slice() -> impl std::convert::TryFrom<&'static [u8]> {\n+    [0; 32]\n+}\n+\n+pub fn yes_ref_try_from_slice() -> impl std::convert::TryFrom<&'static [u8]> {\n+    let a: &'static _ = &[0; 32];\n+    a\n+}\n+\n+pub fn yes_hash() -> impl std::hash::Hash {\n+    [0; 32]\n+}\n+\n+pub fn yes_debug() -> impl std::fmt::Debug {\n+    [0; 32]\n+}\n+\n+pub fn yes_ref_into_iterator() -> impl IntoIterator<Item=&'static u8> {\n+    let a: &'static _ = &[0; 32];\n+    a\n+}\n+\n+pub fn yes_partial_eq() -> impl PartialEq<[u8; 32]> {\n+    [0; 32]\n+}\n+\n+pub fn yes_partial_eq_slice() -> impl PartialEq<[u8]> {\n+    [0; 32]\n+}\n+\n+pub fn yes_slice_partial_eq() -> impl PartialEq<[u8; 32]> {\n+    let a: &'static _ = &[0; 32];\n+    &a[..]\n+}\n+\n+pub fn yes_eq() -> impl Eq {\n+    [0; 32]\n+}\n+\n+pub fn yes_partial_ord() -> impl PartialOrd<[u8; 32]> {\n+    [0; 32]\n+}\n+\n+pub fn yes_ord() -> impl Ord {\n+    [0; 32]\n+}\n+\n+fn main() {}"}, {"sha": "8397d204f35cf76e9239a904fd4d865da38607c2", "filename": "src/test/ui/const-generics/array-impls/core-traits-no-impls-length-33.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.rs?ref=d6a9793722c1ab6066f4f71224aac078b54f03c0", "patch": "@@ -0,0 +1,29 @@\n+pub fn no_debug() {\n+    println!(\"{:?}\", [0_usize; 33]);\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_hash() {\n+    use std::collections::HashSet;\n+    let mut set = HashSet::new();\n+    set.insert([0_usize; 33]);\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_partial_eq() -> bool {\n+    [0_usize; 33] == [1_usize; 33]\n+    //~^ ERROR binary operation `==` cannot be applied to type `[usize; 33]`\n+}\n+\n+pub fn no_partial_ord() -> bool {\n+    [0_usize; 33] < [1_usize; 33]\n+    //~^ ERROR binary operation `<` cannot be applied to type `[usize; 33]`\n+}\n+\n+pub fn no_into_iterator() {\n+    for _ in &[0_usize; 33] {\n+        //~^ ERROR the trait bound `&[usize; 33]: std::iter::IntoIterator` is not satisfied\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "09652d99e8ea5a9eee467484f21426b7652709bc", "filename": "src/test/ui/const-generics/array-impls/core-traits-no-impls-length-33.stderr", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr?ref=d6a9793722c1ab6066f4f71224aac078b54f03c0", "patch": "@@ -0,0 +1,54 @@\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/core-traits-no-impls-length-33.rs:2:22\n+   |\n+LL |     println!(\"{:?}\", [0_usize; 33]);\n+   |                      ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[usize; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::fmt::Debug` for `[usize; 33]`\n+   = note: required by `std::fmt::Debug::fmt`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/core-traits-no-impls-length-33.rs:9:9\n+   |\n+LL |     set.insert([0_usize; 33]);\n+   |         ^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[usize; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::cmp::Eq` for `[usize; 33]`\n+\n+error[E0369]: binary operation `==` cannot be applied to type `[usize; 33]`\n+  --> $DIR/core-traits-no-impls-length-33.rs:14:19\n+   |\n+LL |     [0_usize; 33] == [1_usize; 33]\n+   |     ------------- ^^ ------------- [usize; 33]\n+   |     |\n+   |     [usize; 33]\n+   |\n+   = note: an implementation of `std::cmp::PartialEq` might be missing for `[usize; 33]`\n+\n+error[E0369]: binary operation `<` cannot be applied to type `[usize; 33]`\n+  --> $DIR/core-traits-no-impls-length-33.rs:19:19\n+   |\n+LL |     [0_usize; 33] < [1_usize; 33]\n+   |     ------------- ^ ------------- [usize; 33]\n+   |     |\n+   |     [usize; 33]\n+   |\n+   = note: an implementation of `std::cmp::PartialOrd` might be missing for `[usize; 33]`\n+\n+error[E0277]: the trait bound `&[usize; 33]: std::iter::IntoIterator` is not satisfied\n+  --> $DIR/core-traits-no-impls-length-33.rs:24:14\n+   |\n+LL |     for _ in &[0_usize; 33] {\n+   |              ^^^^^^^^^^^^^^ the trait `std::iter::IntoIterator` is not implemented for `&[usize; 33]`\n+   |\n+   = help: the following implementations were found:\n+             <&'a [T; _] as std::iter::IntoIterator>\n+             <&'a [T] as std::iter::IntoIterator>\n+             <&'a mut [T; _] as std::iter::IntoIterator>\n+             <&'a mut [T] as std::iter::IntoIterator>\n+   = note: required by `std::iter::IntoIterator::into_iter`\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0277, E0369.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "d9a4411b4f9817c5239cf7ece2378593cff5d3e2", "filename": "src/test/ui/const-generics/broken-mir-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.rs?ref=d6a9793722c1ab6066f4f71224aac078b54f03c0", "patch": "@@ -4,6 +4,7 @@\n use std::fmt::Debug;\n \n #[derive(Debug)]\n-struct S<T: Debug, const N: usize>([T; N]); //~ ERROR `[T; _]` doesn't implement `std::fmt::Debug`\n+struct S<T: Debug, const N: usize>([T; N]);\n+//~^ ERROR arrays only have std trait implementations for lengths 0..=32\n \n fn main() {}"}, {"sha": "7cad4017712b2cd6faf546f45399d4434818ccbc", "filename": "src/test/ui/const-generics/broken-mir-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr?ref=d6a9793722c1ab6066f4f71224aac078b54f03c0", "patch": "@@ -4,13 +4,13 @@ warning: the feature `const_generics` is incomplete and may cause the compiler t\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n \n-error[E0277]: `[T; _]` doesn't implement `std::fmt::Debug`\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n   --> $DIR/broken-mir-2.rs:7:36\n    |\n LL | struct S<T: Debug, const N: usize>([T; N]);\n-   |                                    ^^^^^^ `[T; _]` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |                                    ^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[T; _]`\n    |\n-   = help: the trait `std::fmt::Debug` is not implemented for `[T; _]`\n+   = note: required because of the requirements on the impl of `std::fmt::Debug` for `[T; _]`\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `&[T; _]`\n    = note: required for the cast to the object type `dyn std::fmt::Debug`\n "}, {"sha": "eee634c15644bfab28b57f843e4608a0096ee655", "filename": "src/test/ui/const-generics/derive-debug-array-wrapper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.rs?ref=d6a9793722c1ab6066f4f71224aac078b54f03c0", "patch": "@@ -3,7 +3,7 @@\n \n #[derive(Debug)]\n struct X<const N: usize> {\n-    a: [u32; N], //~ ERROR `[u32; _]` doesn't implement `std::fmt::Debug`\n+    a: [u32; N], //~ ERROR arrays only have std trait implementations for lengths 0..=32\n }\n \n fn main() {}"}, {"sha": "799ab145edf38d03d527f5cca24954b93ce525f4", "filename": "src/test/ui/const-generics/derive-debug-array-wrapper.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6a9793722c1ab6066f4f71224aac078b54f03c0/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.stderr?ref=d6a9793722c1ab6066f4f71224aac078b54f03c0", "patch": "@@ -4,13 +4,13 @@ warning: the feature `const_generics` is incomplete and may cause the compiler t\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n \n-error[E0277]: `[u32; _]` doesn't implement `std::fmt::Debug`\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n   --> $DIR/derive-debug-array-wrapper.rs:6:5\n    |\n LL |     a: [u32; N],\n-   |     ^^^^^^^^^^^ `[u32; _]` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |     ^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[u32; _]`\n    |\n-   = help: the trait `std::fmt::Debug` is not implemented for `[u32; _]`\n+   = note: required because of the requirements on the impl of `std::fmt::Debug` for `[u32; _]`\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `&[u32; _]`\n    = note: required for the cast to the object type `dyn std::fmt::Debug`\n "}]}