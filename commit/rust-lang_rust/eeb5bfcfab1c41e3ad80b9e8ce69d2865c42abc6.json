{"sha": "eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYjViZmNmYWIxYzQxZTNhZDgwYjllOGNlNjlkMjg2NWM0MmFiYzY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-05T15:09:45Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-05T15:09:45Z"}, "message": "Cleanup decl_check", "tree": {"sha": "20e8eec1fa68ec9d285fb805371aee8e29de6f41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20e8eec1fa68ec9d285fb805371aee8e29de6f41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6", "html_url": "https://github.com/rust-lang/rust/commit/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac5958485e5e77b020b3ebe0c100df5a5fe6ca08", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08", "html_url": "https://github.com/rust-lang/rust/commit/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08"}], "stats": {"total": 318, "additions": 154, "deletions": 164}, "files": [{"sha": "1ceae965fabd03bffd367b2e11cb2d8cb8d2d320", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6", "patch": "@@ -17,9 +17,9 @@ checksum = \"ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e\"\n \n [[package]]\n name = \"always-assert\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"727786f78c5bc0cda8011831616589f72084cb16b7df4213a997b78749b55a60\"\n+checksum = \"fbf688625d06217d5b1bb0ea9d9c44a1635fd0ee3534466388d18203174f4d11\"\n dependencies = [\n  \"log\",\n ]"}, {"sha": "08483760c55977626f9758006734b27149453032", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6", "patch": "@@ -345,6 +345,37 @@ impl fmt::Display for CaseType {\n     }\n }\n \n+#[derive(Debug)]\n+pub enum IdentType {\n+    Argument,\n+    Constant,\n+    Enum,\n+    Field,\n+    Function,\n+    StaticVariable,\n+    Structure,\n+    Variable,\n+    Variant,\n+}\n+\n+impl fmt::Display for IdentType {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let repr = match self {\n+            IdentType::Argument => \"Argument\",\n+            IdentType::Constant => \"Constant\",\n+            IdentType::Enum => \"Enum\",\n+            IdentType::Field => \"Field\",\n+            IdentType::Function => \"Function\",\n+            IdentType::StaticVariable => \"Static variable\",\n+            IdentType::Structure => \"Structure\",\n+            IdentType::Variable => \"Variable\",\n+            IdentType::Variant => \"Variant\",\n+        };\n+\n+        write!(f, \"{}\", repr)\n+    }\n+}\n+\n // Diagnostic: incorrect-ident-case\n //\n // This diagnostic is triggered if an item name doesn't follow https://doc.rust-lang.org/1.0.0/style/style/naming/README.html[Rust naming convention].\n@@ -353,7 +384,7 @@ pub struct IncorrectCase {\n     pub file: HirFileId,\n     pub ident: AstPtr<ast::Name>,\n     pub expected_case: CaseType,\n-    pub ident_type: String,\n+    pub ident_type: IdentType,\n     pub ident_text: String,\n     pub suggested_text: String,\n }"}, {"sha": "6773ddea3468664d0ce519cb50339acff7c9fbe5", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 119, "deletions": 160, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6", "patch": "@@ -23,6 +23,7 @@ use hir_expand::{\n     diagnostics::DiagnosticSink,\n     name::{AsName, Name},\n };\n+use stdx::{always, never};\n use syntax::{\n     ast::{self, NameOwner},\n     AstNode, AstPtr,\n@@ -31,7 +32,7 @@ use test_utils::mark;\n \n use crate::{\n     db::HirDatabase,\n-    diagnostics::{decl_check::case_conv::*, CaseType, IncorrectCase},\n+    diagnostics::{decl_check::case_conv::*, CaseType, IdentType, IncorrectCase},\n };\n \n mod allow {\n@@ -40,7 +41,7 @@ mod allow {\n     pub(super) const NON_CAMEL_CASE_TYPES: &str = \"non_camel_case_types\";\n }\n \n-pub(super) struct DeclValidator<'a, 'b: 'a> {\n+pub(super) struct DeclValidator<'a, 'b> {\n     db: &'a dyn HirDatabase,\n     krate: CrateId,\n     sink: &'a mut DiagnosticSink<'b>,\n@@ -77,7 +78,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n             AdtId::StructId(struct_id) => self.validate_struct(struct_id),\n             AdtId::EnumId(enum_id) => self.validate_enum(enum_id),\n             AdtId::UnionId(_) => {\n-                // Unions aren't yet supported by this validator.\n+                // FIXME: Unions aren't yet supported by this validator.\n             }\n         }\n     }\n@@ -111,63 +112,50 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n         // Check the function name.\n         let function_name = data.name.to_string();\n-        let fn_name_replacement = if let Some(new_name) = to_lower_snake_case(&function_name) {\n-            let replacement = Replacement {\n-                current_name: data.name.clone(),\n-                suggested_text: new_name,\n-                expected_case: CaseType::LowerSnakeCase,\n-            };\n-            Some(replacement)\n-        } else {\n-            None\n-        };\n+        let fn_name_replacement = to_lower_snake_case(&function_name).map(|new_name| Replacement {\n+            current_name: data.name.clone(),\n+            suggested_text: new_name,\n+            expected_case: CaseType::LowerSnakeCase,\n+        });\n \n         // Check the param names.\n-        let mut fn_param_replacements = Vec::new();\n-\n-        for pat_id in body.params.iter().cloned() {\n-            let pat = &body[pat_id];\n-\n-            let param_name = match pat {\n-                Pat::Bind { name, .. } => name,\n-                _ => continue,\n-            };\n-\n-            let name = param_name.to_string();\n-            if let Some(new_name) = to_lower_snake_case(&name) {\n-                let replacement = Replacement {\n+        let fn_param_replacements = body\n+            .params\n+            .iter()\n+            .filter_map(|&id| match &body[id] {\n+                Pat::Bind { name, .. } => Some(name),\n+                _ => None,\n+            })\n+            .filter_map(|param_name| {\n+                Some(Replacement {\n                     current_name: param_name.clone(),\n-                    suggested_text: new_name,\n+                    suggested_text: to_lower_snake_case(&param_name.to_string())?,\n                     expected_case: CaseType::LowerSnakeCase,\n-                };\n-                fn_param_replacements.push(replacement);\n-            }\n-        }\n+                })\n+            })\n+            .collect();\n \n         // Check the patterns inside the function body.\n-        let mut pats_replacements = Vec::new();\n-\n-        for (pat_idx, pat) in body.pats.iter() {\n-            if body.params.contains(&pat_idx) {\n-                // We aren't interested in function parameters, we've processed them above.\n-                continue;\n-            }\n-\n-            let bind_name = match pat {\n-                Pat::Bind { name, .. } => name,\n-                _ => continue,\n-            };\n-\n-            let name = bind_name.to_string();\n-            if let Some(new_name) = to_lower_snake_case(&name) {\n-                let replacement = Replacement {\n-                    current_name: bind_name.clone(),\n-                    suggested_text: new_name,\n-                    expected_case: CaseType::LowerSnakeCase,\n-                };\n-                pats_replacements.push((pat_idx, replacement));\n-            }\n-        }\n+        let pats_replacements = body\n+            .pats\n+            .iter()\n+            // We aren't interested in function parameters, we've processed them above.\n+            .filter(|(pat_idx, _)| !body.params.contains(&pat_idx))\n+            .filter_map(|(id, pat)| match pat {\n+                Pat::Bind { name, .. } => Some((id, name)),\n+                _ => None,\n+            })\n+            .filter_map(|(id, bind_name)| {\n+                Some((\n+                    id,\n+                    Replacement {\n+                        current_name: bind_name.clone(),\n+                        suggested_text: to_lower_snake_case(&bind_name.to_string())?,\n+                        expected_case: CaseType::LowerSnakeCase,\n+                    },\n+                ))\n+            })\n+            .collect();\n \n         // If there is at least one element to spawn a warning on, go to the source map and generate a warning.\n         self.create_incorrect_case_diagnostic_for_func(\n@@ -199,8 +187,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n             let ast_ptr = match fn_src.value.name() {\n                 Some(name) => name,\n                 None => {\n-                    // We don't want rust-analyzer to panic over this, but it is definitely some kind of error in the logic.\n-                    log::error!(\n+                    never!(\n                         \"Replacement ({:?}) was generated for a function without a name: {:?}\",\n                         replacement,\n                         fn_src\n@@ -211,7 +198,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n             let diagnostic = IncorrectCase {\n                 file: fn_src.file_id,\n-                ident_type: \"Function\".to_string(),\n+                ident_type: IdentType::Function,\n                 ident: AstPtr::new(&ast_ptr).into(),\n                 expected_case: replacement.expected_case,\n                 ident_text: replacement.current_name.to_string(),\n@@ -225,12 +212,12 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n         let fn_params_list = match fn_src.value.param_list() {\n             Some(params) => params,\n             None => {\n-                if !fn_param_replacements.is_empty() {\n-                    log::error!(\n-                        \"Replacements ({:?}) were generated for a function parameters which had no parameters list: {:?}\",\n-                        fn_param_replacements, fn_src\n-                    );\n-                }\n+                always!(\n+                    fn_param_replacements.is_empty(),\n+                    \"Replacements ({:?}) were generated for a function parameters which had no parameters list: {:?}\",\n+                    fn_param_replacements,\n+                    fn_src\n+                );\n                 return;\n             }\n         };\n@@ -240,23 +227,25 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n             // actual params list, but just some of them (ones that named correctly) are skipped.\n             let ast_ptr: ast::Name = loop {\n                 match fn_params_iter.next() {\n-                    Some(element)\n-                        if pat_equals_to_name(element.pat(), &param_to_rename.current_name) =>\n-                    {\n-                        if let ast::Pat::IdentPat(pat) = element.pat().unwrap() {\n-                            break pat.name().unwrap();\n-                        } else {\n-                            // This is critical. If we consider this parameter the expected one,\n-                            // it **must** have a name.\n-                            panic!(\n-                                \"Pattern {:?} equals to expected replacement {:?}, but has no name\",\n-                                element, param_to_rename\n-                            );\n+                    Some(element) => {\n+                        if let Some(ast::Pat::IdentPat(pat)) = element.pat() {\n+                            if pat.to_string() == param_to_rename.current_name.to_string() {\n+                                if let Some(name) = pat.name() {\n+                                    break name;\n+                                }\n+                                // This is critical. If we consider this parameter the expected one,\n+                                // it **must** have a name.\n+                                never!(\n+                                    \"Pattern {:?} equals to expected replacement {:?}, but has no name\",\n+                                    element,\n+                                    param_to_rename\n+                                );\n+                                return;\n+                            }\n                         }\n                     }\n-                    Some(_) => {}\n                     None => {\n-                        log::error!(\n+                        never!(\n                             \"Replacement ({:?}) was generated for a function parameter which was not found: {:?}\",\n                             param_to_rename, fn_src\n                         );\n@@ -267,7 +256,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n             let diagnostic = IncorrectCase {\n                 file: fn_src.file_id,\n-                ident_type: \"Argument\".to_string(),\n+                ident_type: IdentType::Argument,\n                 ident: AstPtr::new(&ast_ptr).into(),\n                 expected_case: param_to_rename.expected_case,\n                 ident_text: param_to_rename.current_name.to_string(),\n@@ -309,8 +298,8 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n                         // We have to check that it's either `let var = ...` or `var @ Variant(_)` statement,\n                         // because e.g. match arms are patterns as well.\n                         // In other words, we check that it's a named variable binding.\n-                        let is_binding = ast::LetStmt::cast(parent.clone()).is_some()\n-                            || (ast::MatchArm::cast(parent).is_some()\n+                        let is_binding = ast::LetStmt::can_cast(parent.kind())\n+                            || (ast::MatchArm::can_cast(parent.kind())\n                                 && ident_pat.at_token().is_some());\n                         if !is_binding {\n                             // This pattern is not an actual variable declaration, e.g. `Some(val) => {..}` match arm.\n@@ -319,7 +308,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n                         let diagnostic = IncorrectCase {\n                             file: source_ptr.file_id,\n-                            ident_type: \"Variable\".to_string(),\n+                            ident_type: IdentType::Variable,\n                             ident: AstPtr::new(&name_ast).into(),\n                             expected_case: replacement.expected_case,\n                             ident_text: replacement.current_name.to_string(),\n@@ -341,17 +330,12 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n         // Check the structure name.\n         let struct_name = data.name.to_string();\n-        let struct_name_replacement = if let Some(new_name) = to_camel_case(&struct_name) {\n-            let replacement = Replacement {\n+        let struct_name_replacement = if !non_camel_case_allowed {\n+            to_camel_case(&struct_name).map(|new_name| Replacement {\n                 current_name: data.name.clone(),\n                 suggested_text: new_name,\n                 expected_case: CaseType::UpperCamelCase,\n-            };\n-            if non_camel_case_allowed {\n-                None\n-            } else {\n-                Some(replacement)\n-            }\n+            })\n         } else {\n             None\n         };\n@@ -403,8 +387,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n             let ast_ptr = match struct_src.value.name() {\n                 Some(name) => name,\n                 None => {\n-                    // We don't want rust-analyzer to panic over this, but it is definitely some kind of error in the logic.\n-                    log::error!(\n+                    never!(\n                         \"Replacement ({:?}) was generated for a structure without a name: {:?}\",\n                         replacement,\n                         struct_src\n@@ -415,7 +398,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n             let diagnostic = IncorrectCase {\n                 file: struct_src.file_id,\n-                ident_type: \"Structure\".to_string(),\n+                ident_type: IdentType::Structure,\n                 ident: AstPtr::new(&ast_ptr).into(),\n                 expected_case: replacement.expected_case,\n                 ident_text: replacement.current_name.to_string(),\n@@ -428,12 +411,12 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n         let struct_fields_list = match struct_src.value.field_list() {\n             Some(ast::FieldList::RecordFieldList(fields)) => fields,\n             _ => {\n-                if !struct_fields_replacements.is_empty() {\n-                    log::error!(\n-                        \"Replacements ({:?}) were generated for a structure fields which had no fields list: {:?}\",\n-                        struct_fields_replacements, struct_src\n-                    );\n-                }\n+                always!(\n+                    struct_fields_replacements.is_empty(),\n+                    \"Replacements ({:?}) were generated for a structure fields which had no fields list: {:?}\",\n+                    struct_fields_replacements,\n+                    struct_src\n+                );\n                 return;\n             }\n         };\n@@ -442,13 +425,14 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n             // We assume that parameters in replacement are in the same order as in the\n             // actual params list, but just some of them (ones that named correctly) are skipped.\n             let ast_ptr = loop {\n-                match struct_fields_iter.next() {\n-                    Some(element) if names_equal(element.name(), &field_to_rename.current_name) => {\n-                        break element.name().unwrap()\n+                match struct_fields_iter.next().and_then(|field| field.name()) {\n+                    Some(field_name) => {\n+                        if field_name.as_name() == field_to_rename.current_name {\n+                            break field_name;\n+                        }\n                     }\n-                    Some(_) => {}\n                     None => {\n-                        log::error!(\n+                        never!(\n                             \"Replacement ({:?}) was generated for a structure field which was not found: {:?}\",\n                             field_to_rename, struct_src\n                         );\n@@ -459,7 +443,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n             let diagnostic = IncorrectCase {\n                 file: struct_src.file_id,\n-                ident_type: \"Field\".to_string(),\n+                ident_type: IdentType::Field,\n                 ident: AstPtr::new(&ast_ptr).into(),\n                 expected_case: field_to_rename.expected_case,\n                 ident_text: field_to_rename.current_name.to_string(),\n@@ -480,31 +464,24 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n         // Check the enum name.\n         let enum_name = data.name.to_string();\n-        let enum_name_replacement = if let Some(new_name) = to_camel_case(&enum_name) {\n-            let replacement = Replacement {\n-                current_name: data.name.clone(),\n-                suggested_text: new_name,\n-                expected_case: CaseType::UpperCamelCase,\n-            };\n-            Some(replacement)\n-        } else {\n-            None\n-        };\n+        let enum_name_replacement = to_camel_case(&enum_name).map(|new_name| Replacement {\n+            current_name: data.name.clone(),\n+            suggested_text: new_name,\n+            expected_case: CaseType::UpperCamelCase,\n+        });\n \n         // Check the field names.\n-        let mut enum_fields_replacements = Vec::new();\n-\n-        for (_, variant) in data.variants.iter() {\n-            let variant_name = variant.name.to_string();\n-            if let Some(new_name) = to_camel_case(&variant_name) {\n-                let replacement = Replacement {\n+        let enum_fields_replacements = data\n+            .variants\n+            .iter()\n+            .filter_map(|(_, variant)| {\n+                Some(Replacement {\n                     current_name: variant.name.clone(),\n-                    suggested_text: new_name,\n+                    suggested_text: to_camel_case(&variant.name.to_string())?,\n                     expected_case: CaseType::UpperCamelCase,\n-                };\n-                enum_fields_replacements.push(replacement);\n-            }\n-        }\n+                })\n+            })\n+            .collect();\n \n         // If there is at least one element to spawn a warning on, go to the source map and generate a warning.\n         self.create_incorrect_case_diagnostic_for_enum(\n@@ -534,8 +511,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n             let ast_ptr = match enum_src.value.name() {\n                 Some(name) => name,\n                 None => {\n-                    // We don't want rust-analyzer to panic over this, but it is definitely some kind of error in the logic.\n-                    log::error!(\n+                    never!(\n                         \"Replacement ({:?}) was generated for a enum without a name: {:?}\",\n                         replacement,\n                         enum_src\n@@ -546,7 +522,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n             let diagnostic = IncorrectCase {\n                 file: enum_src.file_id,\n-                ident_type: \"Enum\".to_string(),\n+                ident_type: IdentType::Enum,\n                 ident: AstPtr::new(&ast_ptr).into(),\n                 expected_case: replacement.expected_case,\n                 ident_text: replacement.current_name.to_string(),\n@@ -559,12 +535,12 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n         let enum_variants_list = match enum_src.value.variant_list() {\n             Some(variants) => variants,\n             _ => {\n-                if !enum_variants_replacements.is_empty() {\n-                    log::error!(\n-                        \"Replacements ({:?}) were generated for a enum variants which had no fields list: {:?}\",\n-                        enum_variants_replacements, enum_src\n-                    );\n-                }\n+                always!(\n+                    enum_variants_replacements.is_empty(),\n+                    \"Replacements ({:?}) were generated for a enum variants which had no fields list: {:?}\",\n+                    enum_variants_replacements,\n+                    enum_src\n+                );\n                 return;\n             }\n         };\n@@ -573,15 +549,14 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n             // We assume that parameters in replacement are in the same order as in the\n             // actual params list, but just some of them (ones that named correctly) are skipped.\n             let ast_ptr = loop {\n-                match enum_variants_iter.next() {\n-                    Some(variant)\n-                        if names_equal(variant.name(), &variant_to_rename.current_name) =>\n-                    {\n-                        break variant.name().unwrap()\n+                match enum_variants_iter.next().and_then(|v| v.name()) {\n+                    Some(variant_name) => {\n+                        if variant_name.as_name() == variant_to_rename.current_name {\n+                            break variant_name;\n+                        }\n                     }\n-                    Some(_) => {}\n                     None => {\n-                        log::error!(\n+                        never!(\n                             \"Replacement ({:?}) was generated for a enum variant which was not found: {:?}\",\n                             variant_to_rename, enum_src\n                         );\n@@ -592,7 +567,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n             let diagnostic = IncorrectCase {\n                 file: enum_src.file_id,\n-                ident_type: \"Variant\".to_string(),\n+                ident_type: IdentType::Variant,\n                 ident: AstPtr::new(&ast_ptr).into(),\n                 expected_case: variant_to_rename.expected_case,\n                 ident_text: variant_to_rename.current_name.to_string(),\n@@ -637,7 +612,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n         let diagnostic = IncorrectCase {\n             file: const_src.file_id,\n-            ident_type: \"Constant\".to_string(),\n+            ident_type: IdentType::Constant,\n             ident: AstPtr::new(&ast_ptr).into(),\n             expected_case: replacement.expected_case,\n             ident_text: replacement.current_name.to_string(),\n@@ -685,7 +660,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n         let diagnostic = IncorrectCase {\n             file: static_src.file_id,\n-            ident_type: \"Static variable\".to_string(),\n+            ident_type: IdentType::StaticVariable,\n             ident: AstPtr::new(&ast_ptr).into(),\n             expected_case: replacement.expected_case,\n             ident_text: replacement.current_name.to_string(),\n@@ -696,22 +671,6 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n     }\n }\n \n-fn names_equal(left: Option<ast::Name>, right: &Name) -> bool {\n-    if let Some(left) = left {\n-        &left.as_name() == right\n-    } else {\n-        false\n-    }\n-}\n-\n-fn pat_equals_to_name(pat: Option<ast::Pat>, name: &Name) -> bool {\n-    if let Some(ast::Pat::IdentPat(ident)) = pat {\n-        ident.to_string() == name.to_string()\n-    } else {\n-        false\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test_utils::mark;"}, {"sha": "d28b5e65814ace45c8acc899bc752b0cbc776368", "filename": "crates/stdx/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6/crates%2Fstdx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6/crates%2Fstdx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2FCargo.toml?ref=eeb5bfcfab1c41e3ad80b9e8ce69d2865c42abc6", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n backtrace = { version = \"0.3.44\", optional = true }\n-always-assert = { version = \"0.1.1\", features = [\"log\"] }\n+always-assert = { version = \"0.1.2\", features = [\"log\"] }\n # Think twice before adding anything here\n \n [features]"}]}