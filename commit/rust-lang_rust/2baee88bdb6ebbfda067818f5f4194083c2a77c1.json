{"sha": "2baee88bdb6ebbfda067818f5f4194083c2a77c1", "node_id": "C_kwDOAAsO6NoAKDJiYWVlODhiZGI2ZWJiZmRhMDY3ODE4ZjVmNDE5NDA4M2MyYTc3YzE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-27T17:53:29Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-04T00:51:50Z"}, "message": "Address comments", "tree": {"sha": "fb03b82d0b132ace89d825514a5a7bdb9829021a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb03b82d0b132ace89d825514a5a7bdb9829021a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2baee88bdb6ebbfda067818f5f4194083c2a77c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2baee88bdb6ebbfda067818f5f4194083c2a77c1", "html_url": "https://github.com/rust-lang/rust/commit/2baee88bdb6ebbfda067818f5f4194083c2a77c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2baee88bdb6ebbfda067818f5f4194083c2a77c1/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7690fe3bc66cae219301368650317936f0d4e3a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7690fe3bc66cae219301368650317936f0d4e3a9", "html_url": "https://github.com/rust-lang/rust/commit/7690fe3bc66cae219301368650317936f0d4e3a9"}], "stats": {"total": 169, "additions": 52, "deletions": 117}, "files": [{"sha": "50cd13a2ccc8a462b28d35faddb94998e00efa93", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2baee88bdb6ebbfda067818f5f4194083c2a77c1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baee88bdb6ebbfda067818f5f4194083c2a77c1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=2baee88bdb6ebbfda067818f5f4194083c2a77c1", "patch": "@@ -535,12 +535,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // x += 1;\n             // ```\n             !i.contains(span)\n-                    // We filter these to avoid incorrect main message on `match-cfg-fake-edges.rs`\n-                        && !visitor\n-                            .errors\n-                            .iter()\n-                            .map(|(sp, _)| *sp)\n-                            .any(|sp| span < sp && !sp.contains(span))\n+            // We filter these to avoid incorrect main message on `match-cfg-fake-edges.rs`\n+            && !visitor\n+                .errors\n+                .iter()\n+                .map(|(sp, _)| *sp)\n+                .any(|sp| span < sp && !sp.contains(span))\n         }) {\n             show_assign_sugg = true;\n             \"isn't initialized\""}, {"sha": "567a9814fccbf3dd712e61d39df4d198de855453", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 61, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2baee88bdb6ebbfda067818f5f4194083c2a77c1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baee88bdb6ebbfda067818f5f4194083c2a77c1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=2baee88bdb6ebbfda067818f5f4194083c2a77c1", "patch": "@@ -4,9 +4,9 @@\n \n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n+use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{self as hir, Item, ItemKind, Node};\n use rustc_infer::infer::{\n     error_reporting::nice_region_error::{\n         self, find_anon_type, find_param_with_region, suggest_adding_lifetime_params,\n@@ -291,65 +291,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         outlives_suggestion.add_suggestion(self);\n     }\n \n-    fn get_impl_ident_and_self_ty_from_trait(\n-        &self,\n-        def_id: DefId,\n-        trait_objects: &FxIndexSet<DefId>,\n-    ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n-        let tcx = self.infcx.tcx;\n-        match tcx.hir().get_if_local(def_id) {\n-            Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n-                {\n-                    Some(Node::Item(Item {\n-                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                        ..\n-                    })) => Some((impl_item.ident, self_ty)),\n-                    _ => None,\n-                }\n-            }\n-            Some(Node::TraitItem(trait_item)) => {\n-                let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did.def_id) {\n-                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n-                        // The method being called is defined in the `trait`, but the `'static`\n-                        // obligation comes from the `impl`. Find that `impl` so that we can point\n-                        // at it in the suggestion.\n-                        let trait_did = trait_did.to_def_id();\n-                        match tcx.hir().trait_impls(trait_did).iter().find_map(|&impl_did| {\n-                            match tcx.hir().get_if_local(impl_did.to_def_id()) {\n-                                Some(Node::Item(Item {\n-                                    kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                                    ..\n-                                })) if trait_objects.iter().all(|did| {\n-                                    // FIXME: we should check `self_ty` against the receiver\n-                                    // type in the `UnifyReceiver` context, but for now, use\n-                                    // this imperfect proxy. This will fail if there are\n-                                    // multiple `impl`s for the same trait like\n-                                    // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n-                                    // In that case, only the first one will get suggestions.\n-                                    let mut traits = vec![];\n-                                    let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n-                                    hir_v.visit_ty(self_ty);\n-                                    !traits.is_empty()\n-                                }) =>\n-                                {\n-                                    Some(self_ty)\n-                                }\n-                                _ => None,\n-                            }\n-                        }) {\n-                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n-                            _ => None,\n-                        }\n-                    }\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n-\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n@@ -844,7 +785,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         visitor.visit_ty(param.param_ty);\n \n         let Some((ident, self_ty)) =\n-            self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &visitor.0) else {return};\n+            NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, instance.def_id(), &visitor.0) else { return; };\n \n         self.suggest_constrain_dyn_trait_in_impl(diag, &visitor.0, ident, self_ty);\n     }"}, {"sha": "d9cdfa9dd4fc9973151c55ecbf98837c65cfbe1e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 43, "deletions": 49, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/2baee88bdb6ebbfda067818f5f4194083c2a77c1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baee88bdb6ebbfda067818f5f4194083c2a77c1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=2baee88bdb6ebbfda067818f5f4194083c2a77c1", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             let mut v = TraitObjectVisitor(FxIndexSet::default());\n             v.visit_ty(param.param_ty);\n             if let Some((ident, self_ty)) =\n-                self.get_impl_ident_and_self_ty_from_trait(item_def_id, &v.0)\n+                NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, item_def_id, &v.0)\n                 && self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty)\n             {\n                 override_error_code = Some(ident.name);\n@@ -390,60 +390,54 @@ pub fn suggest_new_region_bound(\n }\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    fn get_impl_ident_and_self_ty_from_trait(\n-        &self,\n+    pub fn get_impl_ident_and_self_ty_from_trait(\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         trait_objects: &FxIndexSet<DefId>,\n     ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n-        let tcx = self.tcx();\n-        match tcx.hir().get_if_local(def_id) {\n-            Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n+        match tcx.hir().get_if_local(def_id)? {\n+            Node::ImplItem(impl_item) => {\n+                let impl_did = tcx.hir().get_parent_item(impl_item.hir_id());\n+                if let hir::OwnerNode::Item(Item {\n+                    kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                    ..\n+                }) = tcx.hir().owner(impl_did)\n                 {\n-                    Some(Node::Item(Item {\n-                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                        ..\n-                    })) => Some((impl_item.ident, self_ty)),\n-                    _ => None,\n+                    Some((impl_item.ident, self_ty))\n+                } else {\n+                    None\n                 }\n             }\n-            Some(Node::TraitItem(trait_item)) => {\n-                let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did.def_id) {\n-                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n-                        // The method being called is defined in the `trait`, but the `'static`\n-                        // obligation comes from the `impl`. Find that `impl` so that we can point\n-                        // at it in the suggestion.\n-                        let trait_did = trait_did.to_def_id();\n-                        match tcx.hir().trait_impls(trait_did).iter().find_map(|&impl_did| {\n-                            match tcx.hir().get_if_local(impl_did.to_def_id()) {\n-                                Some(Node::Item(Item {\n-                                    kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                                    ..\n-                                })) if trait_objects.iter().all(|did| {\n-                                    // FIXME: we should check `self_ty` against the receiver\n-                                    // type in the `UnifyReceiver` context, but for now, use\n-                                    // this imperfect proxy. This will fail if there are\n-                                    // multiple `impl`s for the same trait like\n-                                    // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n-                                    // In that case, only the first one will get suggestions.\n-                                    let mut traits = vec![];\n-                                    let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n-                                    hir_v.visit_ty(self_ty);\n-                                    !traits.is_empty()\n-                                }) =>\n-                                {\n-                                    Some(self_ty)\n-                                }\n-                                _ => None,\n-                            }\n-                        }) {\n-                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n-                            _ => None,\n-                        }\n+            Node::TraitItem(trait_item) => {\n+                let trait_id = tcx.hir().get_parent_item(trait_item.hir_id());\n+                debug_assert_eq!(tcx.def_kind(trait_id.def_id), hir::def::DefKind::Trait);\n+                // The method being called is defined in the `trait`, but the `'static`\n+                // obligation comes from the `impl`. Find that `impl` so that we can point\n+                // at it in the suggestion.\n+                let trait_did = trait_id.to_def_id();\n+                tcx.hir().trait_impls(trait_did).iter().find_map(|&impl_did| {\n+                    if let Node::Item(Item {\n+                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                        ..\n+                    }) = tcx.hir().find_by_def_id(impl_did)?\n+                        && trait_objects.iter().all(|did| {\n+                            // FIXME: we should check `self_ty` against the receiver\n+                            // type in the `UnifyReceiver` context, but for now, use\n+                            // this imperfect proxy. This will fail if there are\n+                            // multiple `impl`s for the same trait like\n+                            // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n+                            // In that case, only the first one will get suggestions.\n+                            let mut traits = vec![];\n+                            let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n+                            hir_v.visit_ty(self_ty);\n+                            !traits.is_empty()\n+                        })\n+                    {\n+                        Some((trait_item.ident, *self_ty))\n+                    } else {\n+                        None\n                     }\n-                    _ => None,\n-                }\n+                })\n             }\n             _ => None,\n         }\n@@ -474,7 +468,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         // Get the `Ident` of the method being called and the corresponding `impl` (to point at\n         // `Bar` in `impl Foo for dyn Bar {}` and the definition of the method being called).\n-        let Some((ident, self_ty)) = self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &v.0) else {\n+        let Some((ident, self_ty)) = NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, instance.def_id(), &v.0) else {\n             return false;\n         };\n "}, {"sha": "525079681ca5cec4eee3f16787df9760519508df", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2baee88bdb6ebbfda067818f5f4194083c2a77c1/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baee88bdb6ebbfda067818f5f4194083c2a77c1/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=2baee88bdb6ebbfda067818f5f4194083c2a77c1", "patch": "@@ -276,10 +276,10 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     {\n                         let def_id = trait_ref.def_id;\n                         is_def_must_use(cx, def_id, span)\n+                            .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n                     } else {\n                         None\n                     }\n-                    .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n                 }),\n                 ty::Tuple(tys) => {\n                     let elem_exprs = if let hir::ExprKind::Tup(elem_exprs) = expr.kind {"}]}