{"sha": "934634eacc2721e482672a99f91ed458580eb978", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNDYzNGVhY2MyNzIxZTQ4MjY3MmE5OWY5MWVkNDU4NTgwZWI5Nzg=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-22T23:25:52Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-09-18T19:23:01Z"}, "message": "More logging", "tree": {"sha": "0f2504cfd1ae54e339dc116b49902714d020adeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f2504cfd1ae54e339dc116b49902714d020adeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/934634eacc2721e482672a99f91ed458580eb978", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/934634eacc2721e482672a99f91ed458580eb978", "html_url": "https://github.com/rust-lang/rust/commit/934634eacc2721e482672a99f91ed458580eb978", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/934634eacc2721e482672a99f91ed458580eb978/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88538adf9ae1886d9b5c1f45d55b2f76bd6435bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/88538adf9ae1886d9b5c1f45d55b2f76bd6435bd", "html_url": "https://github.com/rust-lang/rust/commit/88538adf9ae1886d9b5c1f45d55b2f76bd6435bd"}], "stats": {"total": 80, "additions": 59, "deletions": 21}, "files": [{"sha": "d8f62e350627037930d3d5128b89977a46ed3825", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "modified", "additions": 59, "deletions": 21, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/934634eacc2721e482672a99f91ed458580eb978/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/934634eacc2721e482672a99f91ed458580eb978/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=934634eacc2721e482672a99f91ed458580eb978", "patch": "@@ -95,12 +95,13 @@\n //! [previous attempt]: https://github.com/rust-lang/rust/pull/47954\n //! [subsequent approach]: https://github.com/rust-lang/rust/pull/71003\n \n-use crate::dataflow::{self, Analysis};\n+use crate::dataflow::impls::{MaybeInitializedLocals, MaybeLiveLocals};\n+use crate::dataflow::Analysis;\n use crate::{\n     transform::{MirPass, MirSource},\n     util::{dump_mir, PassWhere},\n };\n-use dataflow::impls::{MaybeInitializedLocals, MaybeLiveLocals};\n+use itertools::Itertools;\n use rustc_data_structures::unify::{InPlaceUnificationTable, UnifyKey};\n use rustc_index::{\n     bit_set::{BitMatrix, BitSet},\n@@ -255,12 +256,14 @@ impl Replacements<'tcx> {\n \n             // We still return `Err` in any case, as `src` and `dest` do not need to be unified\n             // *again*.\n+            trace!(\"push({:?}): already unified\", candidate);\n             return Err(());\n         }\n \n         let entry = &mut self.map[candidate.src];\n         if entry.is_some() {\n             // We're already replacing `src` with something else, so this candidate is out.\n+            trace!(\"push({:?}): src already has replacement\", candidate);\n             return Err(());\n         }\n \n@@ -270,6 +273,7 @@ impl Replacements<'tcx> {\n         self.kill.insert(candidate.src);\n         self.kill.insert(candidate.dest.local);\n \n+        trace!(\"push({:?}): accepted\", candidate);\n         Ok(())\n     }\n \n@@ -535,7 +539,7 @@ impl Conflicts<'a> {\n \n                 trace!(\"record conflicts at {:?}\", loc);\n \n-                this.record_conflicts(&mut live_and_init_locals[statement_index]);\n+                this.record_dataflow_conflicts(&mut live_and_init_locals[statement_index]);\n             }\n \n             init.seek_to_block_end(block);\n@@ -544,13 +548,13 @@ impl Conflicts<'a> {\n             conflicts.intersect(live.get());\n             trace!(\"record conflicts at end of {:?}\", block);\n \n-            this.record_conflicts(&mut conflicts);\n+            this.record_dataflow_conflicts(&mut conflicts);\n         }\n \n         this\n     }\n \n-    fn record_conflicts(&mut self, new_conflicts: &mut BitSet<Local>) {\n+    fn record_dataflow_conflicts(&mut self, new_conflicts: &mut BitSet<Local>) {\n         // Remove all locals that are not candidates.\n         new_conflicts.intersect(self.relevant_locals);\n \n@@ -559,6 +563,12 @@ impl Conflicts<'a> {\n         }\n     }\n \n+    fn record_local_conflict(&mut self, a: Local, b: Local, why: &str) {\n+        trace!(\"conflict {:?} <-> {:?} due to {}\", a, b, why);\n+        self.matrix.insert(a, b);\n+        self.matrix.insert(b, a);\n+    }\n+\n     /// Records locals that must not overlap during the evaluation of `stmt`. These locals conflict\n     /// and must not be merged.\n     fn record_statement_conflicts(&mut self, stmt: &Statement<'_>) {\n@@ -575,8 +585,11 @@ impl Conflicts<'a> {\n                         if !in_place.is_indirect() {\n                             for out_place in &*asm.outputs {\n                                 if !out_place.is_indirect() && !in_place.is_indirect() {\n-                                    self.matrix.insert(in_place.local, out_place.local);\n-                                    self.matrix.insert(out_place.local, in_place.local);\n+                                    self.record_local_conflict(\n+                                        in_place.local,\n+                                        out_place.local,\n+                                        \"aliasing llvm_asm! operands\",\n+                                    );\n                                 }\n                             }\n                         }\n@@ -599,16 +612,22 @@ impl Conflicts<'a> {\n             TerminatorKind::DropAndReplace { location, value, target: _, unwind: _ } => {\n                 if let Some(place) = value.place() {\n                     if !place.is_indirect() && !location.is_indirect() {\n-                        self.matrix.insert(place.local, location.local);\n-                        self.matrix.insert(location.local, place.local);\n+                        self.record_local_conflict(\n+                            place.local,\n+                            location.local,\n+                            \"DropAndReplace operand overlap\",\n+                        );\n                     }\n                 }\n             }\n             TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n                 if let Some(place) = value.place() {\n                     if !place.is_indirect() && !resume_arg.is_indirect() {\n-                        self.matrix.insert(place.local, resume_arg.local);\n-                        self.matrix.insert(resume_arg.local, place.local);\n+                        self.record_local_conflict(\n+                            place.local,\n+                            resume_arg.local,\n+                            \"Yield operand overlap\",\n+                        );\n                     }\n                 }\n             }\n@@ -623,8 +642,11 @@ impl Conflicts<'a> {\n                 for arg in args.iter().chain(Some(func)) {\n                     if let Some(place) = arg.place() {\n                         if !place.is_indirect() && !dest_place.is_indirect() {\n-                            self.matrix.insert(dest_place.local, place.local);\n-                            self.matrix.insert(place.local, dest_place.local);\n+                            self.record_local_conflict(\n+                                dest_place.local,\n+                                place.local,\n+                                \"call dest/arg overlap\",\n+                            );\n                         }\n                     }\n                 }\n@@ -653,8 +675,11 @@ impl Conflicts<'a> {\n                                     InlineAsmOperand::In { reg: _, value } => {\n                                         if let Some(p) = value.place() {\n                                             if !p.is_indirect() && !dest_place.is_indirect() {\n-                                                self.matrix.insert(p.local, dest_place.local);\n-                                                self.matrix.insert(dest_place.local, p.local);\n+                                                self.record_local_conflict(\n+                                                    p.local,\n+                                                    dest_place.local,\n+                                                    \"asm! operand overlap\",\n+                                                );\n                                             }\n                                         }\n                                     }\n@@ -664,8 +689,11 @@ impl Conflicts<'a> {\n                                         place: Some(place),\n                                     } => {\n                                         if !place.is_indirect() && !dest_place.is_indirect() {\n-                                            self.matrix.insert(place.local, dest_place.local);\n-                                            self.matrix.insert(dest_place.local, place.local);\n+                                            self.record_local_conflict(\n+                                                place.local,\n+                                                dest_place.local,\n+                                                \"asm! operand overlap\",\n+                                            );\n                                         }\n                                     }\n                                     InlineAsmOperand::InOut {\n@@ -676,15 +704,21 @@ impl Conflicts<'a> {\n                                     } => {\n                                         if let Some(place) = in_value.place() {\n                                             if !place.is_indirect() && !dest_place.is_indirect() {\n-                                                self.matrix.insert(place.local, dest_place.local);\n-                                                self.matrix.insert(dest_place.local, place.local);\n+                                                self.record_local_conflict(\n+                                                    place.local,\n+                                                    dest_place.local,\n+                                                    \"asm! operand overlap\",\n+                                                );\n                                             }\n                                         }\n \n                                         if let Some(place) = out_place {\n                                             if !place.is_indirect() && !dest_place.is_indirect() {\n-                                                self.matrix.insert(place.local, dest_place.local);\n-                                                self.matrix.insert(dest_place.local, place.local);\n+                                                self.record_local_conflict(\n+                                                    place.local,\n+                                                    dest_place.local,\n+                                                    \"asm! operand overlap\",\n+                                                );\n                                             }\n                                         }\n                                     }\n@@ -750,6 +784,10 @@ impl Conflicts<'a> {\n         // FIXME: This might be somewhat slow. Conflict graphs are undirected, maybe we can use\n         // something with union-find to speed this up?\n \n+        trace!(\"unify({:?}, {:?})\", a, b);\n+        trace!(\"{:?} conflicts: {:?}\", a, self.matrix.iter(a).format(\", \"));\n+        trace!(\"{:?} conflicts: {:?}\", b, self.matrix.iter(b).format(\", \"));\n+\n         // Make all locals that conflict with `a` also conflict with `b`, and vice versa.\n         self.unify_cache.clear();\n         for conflicts_with_a in self.matrix.iter(a) {"}]}