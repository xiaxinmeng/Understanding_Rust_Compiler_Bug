{"sha": "934079180da6e75ee2398d0342857797df5c7a49", "node_id": "C_kwDOAAsO6NoAKDkzNDA3OTE4MGRhNmU3NWVlMjM5OGQwMzQyODU3Nzk3ZGY1YzdhNDk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-28T19:05:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-28T19:05:14Z"}, "message": "Rollup merge of #94248 - compiler-errors:fix-while-loop-bad-delay, r=petrochenkov\n\nFix ICE when passing block to while-loop condition\n\nWe were incorrectly delaying a bug when we passed _any_ block (that evaluated to `()`) to a while loop. This PR makes the check a bit more sophisticated.\n\nWe should only suppress the error here in cases that are equivalent to those we find in #93574 (i.e. only while loop conditions that have destructuring assignment expressions in them).\n\nFixes #93997\ncc `@estebank` who added this code\n\nI would not be opposed to removing the delay-bug altogether, and just emitting this error always. I much prefer duplicate errors over no errors.", "tree": {"sha": "1982c006c70c27582bd99e9d3b1d50f5146548c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1982c006c70c27582bd99e9d3b1d50f5146548c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/934079180da6e75ee2398d0342857797df5c7a49", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiHRzrCRBK7hj4Ov3rIwAAUDUIAJ/SxLcTr76tAbCadl5QAjZ1\nJoV1xvKhnmqOknQ60UiYDmv0OHo72Bpc+NqaigkNtOaelkGt9lXmG4YR5vEdlh3N\nUNIv5Uw1PF4/MwYEMn7miCBNUMJDuUKmFD85Ng2RUrQivyzEfcWIShNz3q4MccZh\ngpnzuYzTZM2y1Slb9nCDz6BgEIotc7L2NgI9cGEoNe+KIwhkTl046VyrbvWeWfHy\n848MsPotncyOolJj3KXxfMNc5jXj4u+mqmSuKnEDqb7nhNsDXDEykNug+DVdsWoD\n3980eT66+mcKCKFDX6uETL/zY8Be6Xck0qYSoZSIamYH5B92NAdt5DuDZiCPk40=\n=Y6ks\n-----END PGP SIGNATURE-----\n", "payload": "tree 1982c006c70c27582bd99e9d3b1d50f5146548c7\nparent a040e2f4f5104e8e3188735fea4f6d0b2632251e\nparent 025b7c433c109dad2c84f1cbeae422a3ffbd01b6\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1646075114 +0100\ncommitter GitHub <noreply@github.com> 1646075114 +0100\n\nRollup merge of #94248 - compiler-errors:fix-while-loop-bad-delay, r=petrochenkov\n\nFix ICE when passing block to while-loop condition\n\nWe were incorrectly delaying a bug when we passed _any_ block (that evaluated to `()`) to a while loop. This PR makes the check a bit more sophisticated.\n\nWe should only suppress the error here in cases that are equivalent to those we find in #93574 (i.e. only while loop conditions that have destructuring assignment expressions in them).\n\nFixes #93997\ncc `@estebank` who added this code\n\nI would not be opposed to removing the delay-bug altogether, and just emitting this error always. I much prefer duplicate errors over no errors.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/934079180da6e75ee2398d0342857797df5c7a49", "html_url": "https://github.com/rust-lang/rust/commit/934079180da6e75ee2398d0342857797df5c7a49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/934079180da6e75ee2398d0342857797df5c7a49/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a040e2f4f5104e8e3188735fea4f6d0b2632251e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a040e2f4f5104e8e3188735fea4f6d0b2632251e", "html_url": "https://github.com/rust-lang/rust/commit/a040e2f4f5104e8e3188735fea4f6d0b2632251e"}, {"sha": "025b7c433c109dad2c84f1cbeae422a3ffbd01b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/025b7c433c109dad2c84f1cbeae422a3ffbd01b6", "html_url": "https://github.com/rust-lang/rust/commit/025b7c433c109dad2c84f1cbeae422a3ffbd01b6"}], "stats": {"total": 182, "additions": 111, "deletions": 71}, "files": [{"sha": "f3aa40b9ad11e9f5a86fa56202c0c63ca41abe58", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/934079180da6e75ee2398d0342857797df5c7a49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/934079180da6e75ee2398d0342857797df5c7a49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=934079180da6e75ee2398d0342857797df5c7a49", "patch": "@@ -840,7 +840,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         err.span_label(lhs.span, \"cannot assign to this expression\");\n \n-        let mut parent = self.tcx.hir().get_parent_node(lhs.hir_id);\n+        self.comes_from_while_condition(lhs.hir_id, |expr| {\n+            err.span_suggestion_verbose(\n+                expr.span.shrink_to_lo(),\n+                \"you might have meant to use pattern destructuring\",\n+                \"let \".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        });\n+\n+        err.emit();\n+    }\n+\n+    // Check if an expression `original_expr_id` comes from the condition of a while loop,\n+    // as opposed from the body of a while loop, which we can naively check by iterating\n+    // parents until we find a loop...\n+    pub(super) fn comes_from_while_condition(\n+        &self,\n+        original_expr_id: HirId,\n+        then: impl FnOnce(&hir::Expr<'_>),\n+    ) {\n+        let mut parent = self.tcx.hir().get_parent_node(original_expr_id);\n         while let Some(node) = self.tcx.hir().find(parent) {\n             match node {\n                 hir::Node::Expr(hir::Expr {\n@@ -861,21 +881,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ),\n                     ..\n                 }) => {\n-                    // Check if our lhs is a child of the condition of a while loop\n-                    let expr_is_ancestor = std::iter::successors(Some(lhs.hir_id), |id| {\n+                    // Check if our original expression is a child of the condition of a while loop\n+                    let expr_is_ancestor = std::iter::successors(Some(original_expr_id), |id| {\n                         self.tcx.hir().find_parent_node(*id)\n                     })\n                     .take_while(|id| *id != parent)\n                     .any(|id| id == expr.hir_id);\n                     // if it is, then we have a situation like `while Some(0) = value.get(0) {`,\n                     // where `while let` was more likely intended.\n                     if expr_is_ancestor {\n-                        err.span_suggestion_verbose(\n-                            expr.span.shrink_to_lo(),\n-                            \"you might have meant to use pattern destructuring\",\n-                            \"let \".to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n+                        then(expr);\n                     }\n                     break;\n                 }\n@@ -888,8 +903,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n         }\n-\n-        err.emit();\n     }\n \n     // A generic function for checking the 'then' and 'else' clauses in an 'if'"}, {"sha": "f5d110903e6e37e811c23f1616f42652e7ab2aec", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 74, "deletions": 60, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/934079180da6e75ee2398d0342857797df5c7a49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/934079180da6e75ee2398d0342857797df5c7a49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=934079180da6e75ee2398d0342857797df5c7a49", "patch": "@@ -768,55 +768,57 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let prev_diverges = self.diverges.get();\n         let ctxt = BreakableCtxt { coerce: Some(coerce), may_break: false };\n \n-        let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n-            for (pos, s) in blk.stmts.iter().enumerate() {\n-                self.check_stmt(s, blk.stmts.len() - 1 == pos);\n-            }\n+        let (ctxt, ()) =\n+            self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n+                for (pos, s) in blk.stmts.iter().enumerate() {\n+                    self.check_stmt(s, blk.stmts.len() - 1 == pos);\n+                }\n \n-            // check the tail expression **without** holding the\n-            // `enclosing_breakables` lock below.\n-            let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n-\n-            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n-            let coerce = ctxt.coerce.as_mut().unwrap();\n-            if let Some(tail_expr_ty) = tail_expr_ty {\n-                let tail_expr = tail_expr.unwrap();\n-                let span = self.get_expr_coercion_span(tail_expr);\n-                let cause = self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n-                coerce.coerce(self, &cause, tail_expr, tail_expr_ty);\n-            } else {\n-                // Subtle: if there is no explicit tail expression,\n-                // that is typically equivalent to a tail expression\n-                // of `()` -- except if the block diverges. In that\n-                // case, there is no value supplied from the tail\n-                // expression (assuming there are no other breaks,\n-                // this implies that the type of the block will be\n-                // `!`).\n-                //\n-                // #41425 -- label the implicit `()` as being the\n-                // \"found type\" here, rather than the \"expected type\".\n-                if !self.diverges.get().is_always() {\n-                    // #50009 -- Do not point at the entire fn block span, point at the return type\n-                    // span, as it is the cause of the requirement, and\n-                    // `consider_hint_about_removing_semicolon` will point at the last expression\n-                    // if it were a relevant part of the error. This improves usability in editors\n-                    // that highlight errors inline.\n-                    let mut sp = blk.span;\n-                    let mut fn_span = None;\n-                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n-                        let ret_sp = decl.output.span();\n-                        if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n-                            // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n-                            // output would otherwise be incorrect and even misleading. Make sure\n-                            // the span we're aiming at correspond to a `fn` body.\n-                            if block_sp == blk.span {\n-                                sp = ret_sp;\n-                                fn_span = Some(ident.span);\n+                // check the tail expression **without** holding the\n+                // `enclosing_breakables` lock below.\n+                let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n+\n+                let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n+                let coerce = ctxt.coerce.as_mut().unwrap();\n+                if let Some(tail_expr_ty) = tail_expr_ty {\n+                    let tail_expr = tail_expr.unwrap();\n+                    let span = self.get_expr_coercion_span(tail_expr);\n+                    let cause =\n+                        self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n+                    coerce.coerce(self, &cause, tail_expr, tail_expr_ty);\n+                } else {\n+                    // Subtle: if there is no explicit tail expression,\n+                    // that is typically equivalent to a tail expression\n+                    // of `()` -- except if the block diverges. In that\n+                    // case, there is no value supplied from the tail\n+                    // expression (assuming there are no other breaks,\n+                    // this implies that the type of the block will be\n+                    // `!`).\n+                    //\n+                    // #41425 -- label the implicit `()` as being the\n+                    // \"found type\" here, rather than the \"expected type\".\n+                    if !self.diverges.get().is_always() {\n+                        // #50009 -- Do not point at the entire fn block span, point at the return type\n+                        // span, as it is the cause of the requirement, and\n+                        // `consider_hint_about_removing_semicolon` will point at the last expression\n+                        // if it were a relevant part of the error. This improves usability in editors\n+                        // that highlight errors inline.\n+                        let mut sp = blk.span;\n+                        let mut fn_span = None;\n+                        if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n+                            let ret_sp = decl.output.span();\n+                            if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n+                                // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n+                                // output would otherwise be incorrect and even misleading. Make sure\n+                                // the span we're aiming at correspond to a `fn` body.\n+                                if block_sp == blk.span {\n+                                    sp = ret_sp;\n+                                    fn_span = Some(ident.span);\n+                                }\n                             }\n                         }\n-                    }\n-                    coerce.coerce_forced_unit(\n+                        coerce.coerce_forced_unit(\n                         self,\n                         &self.misc(sp),\n                         &mut |err| {\n@@ -825,19 +827,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 if expected_ty == self.tcx.types.bool {\n                                     // If this is caused by a missing `let` in a `while let`,\n                                     // silence this redundant error, as we already emit E0070.\n-                                    let parent = self.tcx.hir().get_parent_node(blk.hir_id);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    match self.tcx.hir().find(parent) {\n-                                        Some(hir::Node::Expr(hir::Expr {\n-                                            kind: hir::ExprKind::Loop(_, _, hir::LoopSource::While, _),\n-                                            ..\n-                                        })) => {\n+\n+                                    // Our block must be a `assign desugar local; assignment`\n+                                    if let Some(hir::Node::Block(hir::Block {\n+                                        stmts:\n+                                            [hir::Stmt {\n+                                                kind:\n+                                                    hir::StmtKind::Local(hir::Local {\n+                                                        source: hir::LocalSource::AssignDesugar(_),\n+                                                        ..\n+                                                    }),\n+                                                ..\n+                                            }, hir::Stmt {\n+                                                kind:\n+                                                    hir::StmtKind::Expr(hir::Expr {\n+                                                        kind: hir::ExprKind::Assign(..),\n+                                                        ..\n+                                                    }),\n+                                                ..\n+                                            }],\n+                                        ..\n+                                    })) = self.tcx.hir().find(blk.hir_id)\n+                                    {\n+                                        self.comes_from_while_condition(blk.hir_id, |_| {\n                                             err.downgrade_to_delayed_bug();\n-                                        }\n-                                        _ => {}\n+                                        })\n                                     }\n                                 }\n                             }\n@@ -851,9 +865,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         },\n                         false,\n                     );\n+                    }\n                 }\n-            }\n-        });\n+            });\n \n         if ctxt.may_break {\n             // If we can break from the block, then the block's exit is always reachable"}, {"sha": "929759766f279f8707806036e838931ae59960bc", "filename": "src/test/ui/typeck/while-loop-block-cond.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/934079180da6e75ee2398d0342857797df5c7a49/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/934079180da6e75ee2398d0342857797df5c7a49/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.rs?ref=934079180da6e75ee2398d0342857797df5c7a49", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    while {} {}\n+    //~^ ERROR mismatched types [E0308]\n+}"}, {"sha": "598273af9cfc4c5d6f70e44eff0c1b3d00f94b03", "filename": "src/test/ui/typeck/while-loop-block-cond.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/934079180da6e75ee2398d0342857797df5c7a49/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/934079180da6e75ee2398d0342857797df5c7a49/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.stderr?ref=934079180da6e75ee2398d0342857797df5c7a49", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/while-loop-block-cond.rs:2:11\n+   |\n+LL |     while {} {}\n+   |           ^^ expected `bool`, found `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}