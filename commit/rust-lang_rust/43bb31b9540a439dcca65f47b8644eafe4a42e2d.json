{"sha": "43bb31b9540a439dcca65f47b8644eafe4a42e2d", "node_id": "C_kwDOAAsO6NoAKDQzYmIzMWI5NTQwYTQzOWRjY2E2NWY0N2I4NjQ0ZWFmZTRhNDJlMmQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-12T20:19:25Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-07-06T20:50:55Z"}, "message": "Allow to create definitions inside the query system.", "tree": {"sha": "8c707ae5bb7b76fd39b0b0b811e50fd336e5cd17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c707ae5bb7b76fd39b0b0b811e50fd336e5cd17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43bb31b9540a439dcca65f47b8644eafe4a42e2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43bb31b9540a439dcca65f47b8644eafe4a42e2d", "html_url": "https://github.com/rust-lang/rust/commit/43bb31b9540a439dcca65f47b8644eafe4a42e2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43bb31b9540a439dcca65f47b8644eafe4a42e2d/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dcb616888aac50d55160b025266d555dad937d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dcb616888aac50d55160b025266d555dad937d9", "html_url": "https://github.com/rust-lang/rust/commit/3dcb616888aac50d55160b025266d555dad937d9"}], "stats": {"total": 416, "additions": 263, "deletions": 153}, "files": [{"sha": "8fc8118849baef066ba68165e7ddb6dd92229822", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/type_map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -93,8 +93,9 @@ impl<'tcx> UniqueTypeId<'tcx> {\n     /// Right now this takes the form of a hex-encoded opaque hash value.\n     pub fn generate_unique_id_string(self, tcx: TyCtxt<'tcx>) -> String {\n         let mut hasher = StableHasher::new();\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        hcx.while_hashing_spans(false, |hcx| self.hash_stable(hcx, &mut hasher));\n+        tcx.with_stable_hashing_context(|mut hcx| {\n+            hcx.while_hashing_spans(false, |hcx| self.hash_stable(hcx, &mut hasher))\n+        });\n         hasher.finish::<Fingerprint>().to_hex()\n     }\n "}, {"sha": "8cd5a0fc24759efd8178d138f8a30449539bac29", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -701,16 +701,20 @@ fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: ty::Const<'tcx>, output: &mut S\n                 // If we cannot evaluate the constant to a known type, we fall back\n                 // to emitting a stable hash value of the constant. This isn't very pretty\n                 // but we get a deterministic, virtually unique value for the constant.\n-                let hcx = &mut tcx.create_stable_hashing_context();\n-                let mut hasher = StableHasher::new();\n-                let ct = ct.eval(tcx, ty::ParamEnv::reveal_all());\n-                hcx.while_hashing_spans(false, |hcx| ct.to_valtree().hash_stable(hcx, &mut hasher));\n+                //\n                 // Let's only emit 64 bits of the hash value. That should be plenty for\n                 // avoiding collisions and will make the emitted type names shorter.\n-                // Note: Don't use `StableHashResult` impl of `u64` here directly, since that\n-                // would lead to endianness problems.\n-                let hash: u128 = hasher.finish();\n-                let hash_short = (hash.to_le() as u64).to_le();\n+                let hash_short = tcx.with_stable_hashing_context(|mut hcx| {\n+                    let mut hasher = StableHasher::new();\n+                    let ct = ct.eval(tcx, ty::ParamEnv::reveal_all());\n+                    hcx.while_hashing_spans(false, |hcx| {\n+                        ct.to_valtree().hash_stable(hcx, &mut hasher)\n+                    });\n+                    // Note: Don't use `StableHashResult` impl of `u64` here directly, since that\n+                    // would lead to endianness problems.\n+                    let hash: u128 = hasher.finish();\n+                    (hash.to_le() as u64).to_le()\n+                });\n \n                 if cpp_like_debuginfo(tcx) {\n                     write!(output, \"CONST${:x}\", hash_short)"}, {"sha": "0a2d2b40709041873c0739f6a51bafe03bba9254", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -10,6 +10,7 @@\n #![feature(array_windows)]\n #![feature(associated_type_bounds)]\n #![feature(auto_traits)]\n+#![feature(cell_leak)]\n #![feature(control_flow_enum)]\n #![feature(extend_one)]\n #![feature(let_else)]"}, {"sha": "cf0940df9e487c66a18b2a3c1b5ee31502824e02", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -539,6 +539,33 @@ impl<T> RwLock<T> {\n     pub fn borrow_mut(&self) -> WriteGuard<'_, T> {\n         self.write()\n     }\n+\n+    #[cfg(not(parallel_compiler))]\n+    #[inline(always)]\n+    pub fn clone_guard<'a>(rg: &ReadGuard<'a, T>) -> ReadGuard<'a, T> {\n+        ReadGuard::clone(rg)\n+    }\n+\n+    #[cfg(parallel_compiler)]\n+    #[inline(always)]\n+    pub fn clone_guard<'a>(rg: &ReadGuard<'a, T>) -> ReadGuard<'a, T> {\n+        ReadGuard::rwlock(&rg).read()\n+    }\n+\n+    #[cfg(not(parallel_compiler))]\n+    #[inline(always)]\n+    pub fn leak(&self) -> &T {\n+        ReadGuard::leak(self.read())\n+    }\n+\n+    #[cfg(parallel_compiler)]\n+    #[inline(always)]\n+    pub fn leak(&self) -> &T {\n+        let guard = self.read();\n+        let ret = unsafe { &*(&*guard as *const T) };\n+        std::mem::forget(guard);\n+        ret\n+    }\n }\n \n // FIXME: Probably a bad idea"}, {"sha": "7e07898ff52f1d5f58c227fdf5eb0aae303b78aa", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_def_path_table(&mut self) {\n-        let table = self.tcx.definitions_untracked().def_path_table();\n+        let table = self.tcx.def_path_table();\n         if self.is_proc_macro {\n             for def_index in std::iter::once(CRATE_DEF_INDEX)\n                 .chain(self.tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index))\n@@ -443,9 +443,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_def_path_hash_map(&mut self) -> LazyValue<DefPathHashMapRef<'static>> {\n-        self.lazy(DefPathHashMapRef::BorrowedFromTcx(\n-            self.tcx.definitions_untracked().def_path_hash_to_def_index_map(),\n-        ))\n+        self.lazy(DefPathHashMapRef::BorrowedFromTcx(self.tcx.def_path_hash_to_def_index_map()))\n     }\n \n     fn encode_source_map(&mut self) -> LazyArray<rustc_span::SourceFile> {\n@@ -614,7 +612,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let interpret_alloc_index_bytes = self.position() - i;\n \n         // Encode the proc macro data. This affects 'tables',\n-        // so we need to do this before we encode the tables\n+        // so we need to do this before we encode the tables.\n+        // This overwrites def_keys, so it must happen after encode_def_path_table.\n         i = self.position();\n         let proc_macro_data = self.encode_proc_macros();\n         let proc_macro_data_bytes = self.position() - i;\n@@ -992,8 +991,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             return;\n         }\n         let tcx = self.tcx;\n-        let hir = tcx.hir();\n-        for local_id in hir.iter_local_def_id() {\n+        for local_id in tcx.iter_local_def_id() {\n             let def_id = local_id.to_def_id();\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n@@ -1854,12 +1852,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"EncodeContext::encode_traits_and_impls()\");\n         empty_proc_macro!(self);\n         let tcx = self.tcx;\n-        let mut ctx = tcx.create_stable_hashing_context();\n         let mut all_impls: Vec<_> = tcx.crate_inherent_impls(()).incoherent_impls.iter().collect();\n-        all_impls.sort_by_cached_key(|&(&simp, _)| {\n-            let mut hasher = StableHasher::new();\n-            simp.hash_stable(&mut ctx, &mut hasher);\n-            hasher.finish::<Fingerprint>();\n+        tcx.with_stable_hashing_context(|mut ctx| {\n+            all_impls.sort_by_cached_key(|&(&simp, _)| {\n+                let mut hasher = StableHasher::new();\n+                simp.hash_stable(&mut ctx, &mut hasher);\n+                hasher.finish::<Fingerprint>()\n+            })\n         });\n         let all_impls: Vec<_> = all_impls\n             .into_iter()"}, {"sha": "5f3f1a3bc6c3ac9e5cb827460aa21c25af980132", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -71,8 +71,8 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     type DepKind = DepKind;\n \n     #[inline]\n-    fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        TyCtxt::create_stable_hashing_context(*self)\n+    fn with_stable_hashing_context<R>(&self, f: impl FnOnce(StableHashingContext<'_>) -> R) -> R {\n+        TyCtxt::with_stable_hashing_context(*self, f)\n     }\n \n     #[inline]"}, {"sha": "3ac302ef0ed359b3581364755ec5c9b57eb2754d", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -218,13 +218,6 @@ impl<'hir> Map<'hir> {\n         self.tcx.local_def_id_to_hir_id(def_id)\n     }\n \n-    pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'hir {\n-        // Create a dependency to the crate to be sure we re-execute this when the amount of\n-        // definitions change.\n-        self.tcx.ensure().hir_crate(());\n-        self.tcx.definitions_untracked().iter_local_def_id()\n-    }\n-\n     /// Do not call this function directly. The query should be called.\n     pub(super) fn opt_def_kind(self, local_def_id: LocalDefId) -> Option<DefKind> {\n         let hir_id = self.local_def_id_to_hir_id(local_def_id);\n@@ -1141,34 +1134,35 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n \n     source_file_names.sort_unstable();\n \n-    let mut hcx = tcx.create_stable_hashing_context();\n-    let mut stable_hasher = StableHasher::new();\n-    hir_body_hash.hash_stable(&mut hcx, &mut stable_hasher);\n-    upstream_crates.hash_stable(&mut hcx, &mut stable_hasher);\n-    source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\n-    if tcx.sess.opts.debugging_opts.incremental_relative_spans {\n-        let definitions = &tcx.definitions_untracked();\n-        let mut owner_spans: Vec<_> = krate\n-            .owners\n-            .iter_enumerated()\n-            .filter_map(|(def_id, info)| {\n-                let _ = info.as_owner()?;\n-                let def_path_hash = definitions.def_path_hash(def_id);\n-                let span = resolutions.source_span[def_id];\n-                debug_assert_eq!(span.parent(), None);\n-                Some((def_path_hash, span))\n-            })\n-            .collect();\n-        owner_spans.sort_unstable_by_key(|bn| bn.0);\n-        owner_spans.hash_stable(&mut hcx, &mut stable_hasher);\n-    }\n-    tcx.sess.opts.dep_tracking_hash(true).hash_stable(&mut hcx, &mut stable_hasher);\n-    tcx.sess.local_stable_crate_id().hash_stable(&mut hcx, &mut stable_hasher);\n-    // Hash visibility information since it does not appear in HIR.\n-    resolutions.visibilities.hash_stable(&mut hcx, &mut stable_hasher);\n-    resolutions.has_pub_restricted.hash_stable(&mut hcx, &mut stable_hasher);\n+    let crate_hash: Fingerprint = tcx.with_stable_hashing_context(|mut hcx| {\n+        let mut stable_hasher = StableHasher::new();\n+        hir_body_hash.hash_stable(&mut hcx, &mut stable_hasher);\n+        upstream_crates.hash_stable(&mut hcx, &mut stable_hasher);\n+        source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\n+        if tcx.sess.opts.debugging_opts.incremental_relative_spans {\n+            let definitions = tcx.definitions_untracked();\n+            let mut owner_spans: Vec<_> = krate\n+                .owners\n+                .iter_enumerated()\n+                .filter_map(|(def_id, info)| {\n+                    let _ = info.as_owner()?;\n+                    let def_path_hash = definitions.def_path_hash(def_id);\n+                    let span = resolutions.source_span[def_id];\n+                    debug_assert_eq!(span.parent(), None);\n+                    Some((def_path_hash, span))\n+                })\n+                .collect();\n+            owner_spans.sort_unstable_by_key(|bn| bn.0);\n+            owner_spans.hash_stable(&mut hcx, &mut stable_hasher);\n+        }\n+        tcx.sess.opts.dep_tracking_hash(true).hash_stable(&mut hcx, &mut stable_hasher);\n+        tcx.sess.local_stable_crate_id().hash_stable(&mut hcx, &mut stable_hasher);\n+        // Hash visibility information since it does not appear in HIR.\n+        resolutions.visibilities.hash_stable(&mut hcx, &mut stable_hasher);\n+        resolutions.has_pub_restricted.hash_stable(&mut hcx, &mut stable_hasher);\n+        stable_hasher.finish()\n+    });\n \n-    let crate_hash: Fingerprint = stable_hasher.finish();\n     Svh::new(crate_hash.to_smaller_hash())\n }\n "}, {"sha": "abc639136d6d2c92ee3e0de007ad3b154ae044f8", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -20,6 +20,12 @@ rustc_queries! {\n         desc { \"trigger a delay span bug\" }\n     }\n \n+    /// Create a new definition within the incr. comp. engine.\n+    query register_def(_: ty::RawLocalDefId) -> LocalDefId {\n+        eval_always\n+        desc { \"register a DefId with the incr. comp. engine\" }\n+    }\n+\n     query resolutions(_: ()) -> &'tcx ty::ResolverOutputs {\n         eval_always\n         no_hash"}, {"sha": "60329fc6eea40850fc1eff519659a5deadcc850a", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 94, "deletions": 19, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -32,12 +32,13 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n-use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n+use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, RwLock, WorkerLocal};\n use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{DecorateLint, ErrorGuaranteed, LintDiagnosticBuilder, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::definitions::Definitions;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n@@ -122,6 +123,9 @@ impl<'tcx> Interner for TyCtxt<'tcx> {\n     type PlaceholderRegion = ty::PlaceholderRegion;\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n+pub struct RawLocalDefId(LocalDefId);\n+\n /// A type that is not publicly constructable. This prevents people from making [`TyKind::Error`]s\n /// except through the error-reporting functions on a [`tcx`][TyCtxt].\n #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n@@ -1069,7 +1073,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n-    definitions: rustc_hir::definitions::Definitions,\n+    definitions: RwLock<Definitions>,\n     cstore: Box<CrateStoreDyn>,\n \n     /// Output of the resolver.\n@@ -1233,7 +1237,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         s: &'tcx Session,\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n-        definitions: rustc_hir::definitions::Definitions,\n+        definitions: Definitions,\n         cstore: Box<CrateStoreDyn>,\n         untracked_resolutions: ty::ResolverOutputs,\n         krate: &'tcx hir::Crate<'tcx>,\n@@ -1265,7 +1269,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             arena,\n             interners,\n             dep_graph,\n-            definitions,\n+            definitions: RwLock::new(definitions),\n             cstore,\n             untracked_resolutions,\n             prof: s.prof.clone(),\n@@ -1368,7 +1372,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn def_key(self, id: DefId) -> rustc_hir::definitions::DefKey {\n         // Accessing the DefKey is ok, since it is part of DefPathHash.\n         if let Some(id) = id.as_local() {\n-            self.definitions.def_key(id)\n+            self.definitions_untracked().def_key(id)\n         } else {\n             self.cstore.def_key(id)\n         }\n@@ -1382,7 +1386,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn def_path(self, id: DefId) -> rustc_hir::definitions::DefPath {\n         // Accessing the DefPath is ok, since it is part of DefPathHash.\n         if let Some(id) = id.as_local() {\n-            self.definitions.def_path(id)\n+            self.definitions_untracked().def_path(id)\n         } else {\n             self.cstore.def_path(id)\n         }\n@@ -1392,7 +1396,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn def_path_hash(self, def_id: DefId) -> rustc_hir::definitions::DefPathHash {\n         // Accessing the DefPathHash is ok, it is incr. comp. stable.\n         if let Some(def_id) = def_id.as_local() {\n-            self.definitions.def_path_hash(def_id)\n+            self.definitions_untracked().def_path_hash(def_id)\n         } else {\n             self.cstore.def_path_hash(def_id)\n         }\n@@ -1429,7 +1433,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // If this is a DefPathHash from the local crate, we can look up the\n         // DefId in the tcx's `Definitions`.\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n-            self.definitions.local_def_path_hash_to_def_id(hash, err).to_def_id()\n+            self.definitions.read().local_def_path_hash_to_def_id(hash, err).to_def_id()\n         } else {\n             // If this is a DefPathHash from an upstream crate, let the CrateStore map\n             // it to a DefId.\n@@ -1460,6 +1464,65 @@ impl<'tcx> TyCtxt<'tcx> {\n         )\n     }\n \n+    /// Create a new definition within the incr. comp. engine.\n+    pub fn create_def(self, parent: LocalDefId, data: hir::definitions::DefPathData) -> LocalDefId {\n+        // The following call has the side effect of modifying the tables inside `definitions`.\n+        // These very tables are relied on by the incr. comp. engine to decode DepNodes and to\n+        // decode the on-disk cache.\n+        let def_id = self.definitions.write().create_def(parent, data);\n+\n+        // We need to ensure that these side effects are re-run by the incr. comp. engine.\n+        // When the incr. comp. engine considers marking this query as green, eval_always requires\n+        // we run the function to run.  To invoke it, the parameter cannot be reconstructed from\n+        // the DepNode, so the caller query is run.  Luckily, we are inside the caller query,\n+        // therefore the definition is properly created.\n+        debug_assert!({\n+            use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n+            self.is_eval_always(crate::dep_graph::DepKind::register_def)\n+                && !<RawLocalDefId as DepNodeParams<TyCtxt<'_>>>::fingerprint_style()\n+                    .reconstructible()\n+        });\n+\n+        // Any LocalDefId which is used within queries, either as key or result, either:\n+        // - has been created before the construction of the TyCtxt;\n+        // - has been created by this call to `register_def`.\n+        // As a consequence, this LocalDefId is always re-created before it is needed by the incr.\n+        // comp. engine itself.\n+        self.register_def(RawLocalDefId(def_id))\n+    }\n+\n+    pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'tcx {\n+        // Create a dependency to the crate to be sure we re-execute this when the amount of\n+        // definitions change.\n+        self.ensure().hir_crate(());\n+        // Leak a read lock once we start iterating on definitions, to prevent adding new onces\n+        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n+        let definitions = self.definitions.leak();\n+        definitions.iter_local_def_id()\n+    }\n+\n+    pub fn def_path_table(self) -> &'tcx rustc_hir::definitions::DefPathTable {\n+        // Create a dependency to the crate to be sure we reexcute this when the amount of\n+        // definitions change.\n+        self.ensure().hir_crate(());\n+        // Leak a read lock once we start iterating on definitions, to prevent adding new onces\n+        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n+        let definitions = self.definitions.leak();\n+        definitions.def_path_table()\n+    }\n+\n+    pub fn def_path_hash_to_def_index_map(\n+        self,\n+    ) -> &'tcx rustc_hir::def_path_hash_map::DefPathHashMap {\n+        // Create a dependency to the crate to be sure we reexcute this when the amount of\n+        // definitions change.\n+        self.ensure().hir_crate(());\n+        // Leak a read lock once we start iterating on definitions, to prevent adding new onces\n+        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n+        let definitions = self.definitions.leak();\n+        definitions.def_path_hash_to_def_index_map()\n+    }\n+\n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     pub fn cstore_untracked(self) -> &'tcx CrateStoreDyn {\n@@ -1468,8 +1531,9 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n-    pub fn definitions_untracked(self) -> &'tcx hir::definitions::Definitions {\n-        &self.definitions\n+    #[inline]\n+    pub fn definitions_untracked(self) -> ReadGuard<'tcx, Definitions> {\n+        self.definitions.read()\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n@@ -1480,23 +1544,33 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline(always)]\n-    pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        StableHashingContext::new(\n+    pub fn with_stable_hashing_context<R>(\n+        self,\n+        f: impl FnOnce(StableHashingContext<'_>) -> R,\n+    ) -> R {\n+        let definitions = self.definitions_untracked();\n+        let hcx = StableHashingContext::new(\n             self.sess,\n-            &self.definitions,\n+            &*definitions,\n             &*self.cstore,\n             &self.untracked_resolutions.source_span,\n-        )\n+        );\n+        f(hcx)\n     }\n \n     #[inline(always)]\n-    pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        StableHashingContext::ignore_spans(\n+    pub fn with_no_span_stable_hashing_context<R>(\n+        self,\n+        f: impl FnOnce(StableHashingContext<'_>) -> R,\n+    ) -> R {\n+        let definitions = self.definitions_untracked();\n+        let hcx = StableHashingContext::ignore_spans(\n             self.sess,\n-            &self.definitions,\n+            &*definitions,\n             &*self.cstore,\n             &self.untracked_resolutions.source_span,\n-        )\n+        );\n+        f(hcx)\n     }\n \n     pub fn serialize_query_result_cache(self, encoder: FileEncoder) -> FileEncodeResult {\n@@ -2304,7 +2378,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.interners.intern_ty(\n             st,\n             self.sess,\n-            &self.definitions,\n+            &self.definitions.read(),\n             &*self.cstore,\n             // This is only used to create a stable hashing context.\n             &self.untracked_resolutions.source_span,\n@@ -2953,4 +3027,5 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         // We want to check if the panic handler was defined in this crate\n         tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())\n     };\n+    providers.register_def = |_, raw_id| raw_id.0;\n }"}, {"sha": "e00cf3ff9bebca79cd6edb172366de7ef5087dd7", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -72,8 +72,8 @@ pub use self::consts::{\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n     CtxtInterners, DelaySpanBugEmitted, FreeRegionInfo, GeneratorDiagnosticData,\n-    GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TypeckResults, UserType,\n-    UserTypeAnnotationIndex,\n+    GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, RawLocalDefId, TyCtxt,\n+    TypeckResults, UserType, UserTypeAnnotationIndex,\n };\n pub use self::instance::{Instance, InstanceDef};\n pub use self::list::List;"}, {"sha": "0e581d7f1f7edf3caf17e38cb2adae313e532900", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -142,16 +142,16 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n-        let mut hasher = StableHasher::new();\n-        let mut hcx = self.create_stable_hashing_context();\n-\n         // We want the type_id be independent of the types free regions, so we\n         // erase them. The erase_regions() call will also anonymize bound\n         // regions, which is desirable too.\n         let ty = self.erase_regions(ty);\n \n-        hcx.while_hashing_spans(false, |hcx| ty.hash_stable(hcx, &mut hasher));\n-        hasher.finish()\n+        self.with_stable_hashing_context(|mut hcx| {\n+            let mut hasher = StableHasher::new();\n+            hcx.while_hashing_spans(false, |hcx| ty.hash_stable(hcx, &mut hasher));\n+            hasher.finish()\n+        })\n     }\n \n     pub fn res_generics_def_id(self, res: Res) -> Option<DefId> {"}, {"sha": "88ad5b7ef148227bf151995bc6faf5c5f1a6e644", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -15,7 +15,6 @@ use spans::{CoverageSpan, CoverageSpans};\n use crate::MirPass;\n \n use rustc_data_structures::graph::WithNumNodes;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_index::vec::IndexVec;\n use rustc_middle::hir;\n@@ -576,12 +575,6 @@ fn get_body_span<'tcx>(\n \n fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n     // FIXME(cjgillot) Stop hashing HIR manually here.\n-    let mut hcx = tcx.create_no_span_stable_hashing_context();\n-    let mut stable_hasher = StableHasher::new();\n     let owner = hir_body.id().hir_id.owner;\n-    let bodies = &tcx.hir_owner_nodes(owner).unwrap().bodies;\n-    hcx.with_hir_bodies(false, owner, bodies, |hcx| {\n-        hir_body.value.hash_stable(hcx, &mut stable_hasher)\n-    });\n-    stable_hasher.finish()\n+    tcx.hir_owner_nodes(owner).unwrap().hash_including_bodies.to_smaller_hash()\n }"}, {"sha": "8f049a182eeaf593ec4af7a09343f3d0ec2cfec9", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -588,7 +588,7 @@ impl<'tcx> Inliner<'tcx> {\n                 );\n                 expn_data.def_site = callee_body.span;\n                 let expn_data =\n-                    LocalExpnId::fresh(expn_data, self.tcx.create_stable_hashing_context());\n+                    self.tcx.with_stable_hashing_context(|hcx| LocalExpnId::fresh(expn_data, hcx));\n                 let mut integrator = Integrator {\n                     args: &args,\n                     new_locals: Local::new(caller_body.local_decls.len())..,"}, {"sha": "c3fbba4456e1e4efe1cd1ac91f874b7fce597f49", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -39,6 +39,17 @@ impl Key for () {\n     }\n }\n \n+impl Key for ty::RawLocalDefId {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl<'tcx> Key for ty::InstanceDef<'tcx> {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "4c25075327f0149af69fab7e6183b0ceae85a552", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -653,12 +653,11 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n             #[cfg(debug_assertions)]\n             {\n                 use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-                let mut hcx = decoder.tcx.create_stable_hashing_context();\n-                let mut hasher = StableHasher::new();\n-                hcx.while_hashing_spans(true, |hcx| {\n-                    expn_id.expn_data().hash_stable(hcx, &mut hasher)\n+                let local_hash: u64 = decoder.tcx.with_stable_hashing_context(|mut hcx| {\n+                    let mut hasher = StableHasher::new();\n+                    expn_id.expn_data().hash_stable(&mut hcx, &mut hasher);\n+                    hasher.finish()\n                 });\n-                let local_hash: u64 = hasher.finish();\n                 debug_assert_eq!(hash.local_hash(), local_hash);\n             }\n "}, {"sha": "d0fef364eafd8c1a12dffbeca5334e67761834e3", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -291,11 +291,12 @@ macro_rules! define_queries {\n                         .and_then(|def_id| tcx.opt_def_kind(def_id))\n                 };\n                 let hash = || {\n-                    let mut hcx = tcx.create_stable_hashing_context();\n-                    let mut hasher = StableHasher::new();\n-                    std::mem::discriminant(&kind).hash_stable(&mut hcx, &mut hasher);\n-                    key.hash_stable(&mut hcx, &mut hasher);\n-                    hasher.finish::<u64>()\n+                    tcx.with_stable_hashing_context(|mut hcx|{\n+                        let mut hasher = StableHasher::new();\n+                        std::mem::discriminant(&kind).hash_stable(&mut hcx, &mut hasher);\n+                        key.hash_stable(&mut hcx, &mut hasher);\n+                        hasher.finish::<u64>()\n+                    })\n                 };\n \n                 QueryStackFrame::new(name, description, span, def_kind, hash)"}, {"sha": "c6210095b60fc0153ce9c79a8eb5b9c48b81cdfd", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -131,12 +131,11 @@ where\n \n     #[inline(always)]\n     default fn to_fingerprint(&self, tcx: Ctxt) -> Fingerprint {\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n-\n-        self.hash_stable(&mut hcx, &mut hasher);\n-\n-        hasher.finish()\n+        tcx.with_stable_hashing_context(|mut hcx| {\n+            let mut hasher = StableHasher::new();\n+            self.hash_stable(&mut hcx, &mut hasher);\n+            hasher.finish()\n+        })\n     }\n \n     #[inline(always)]"}, {"sha": "0e1419f8a483a397174e355d8472c3ec293d03a8", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -328,10 +328,8 @@ impl<K: DepKind> DepGraph<K> {\n \n         let dcx = cx.dep_context();\n         let hashing_timer = dcx.profiler().incr_result_hashing();\n-        let current_fingerprint = hash_result.map(|f| {\n-            let mut hcx = dcx.create_stable_hashing_context();\n-            f(&mut hcx, &result)\n-        });\n+        let current_fingerprint =\n+            hash_result.map(|f| dcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, &result)));\n \n         let print_status = cfg!(debug_assertions) && dcx.sess().opts.debugging_opts.dep_tasks;\n "}, {"sha": "345ada263e4d23435bc2f78afd70b10b9d0f3b4b", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -23,7 +23,7 @@ pub trait DepContext: Copy {\n     type DepKind: self::DepKind;\n \n     /// Create a hashing context for hashing new results.\n-    fn create_stable_hashing_context(&self) -> StableHashingContext<'_>;\n+    fn with_stable_hashing_context<R>(&self, f: impl FnOnce(StableHashingContext<'_>) -> R) -> R;\n \n     /// Access the DepGraph.\n     fn dep_graph(&self) -> &DepGraph<Self::DepKind>;"}, {"sha": "89b9a80ee4dfa044c7c32064febca23179bf49ad", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -1,4 +1,5 @@\n use crate::ich;\n+\n use rustc_ast as ast;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, HashingControls, StableHasher};"}, {"sha": "bbcd00be943a274bd180e869852f7605ec137be4", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -542,8 +542,7 @@ fn incremental_verify_ich<CTX, K, V: Debug>(\n \n     debug!(\"BEGIN verify_ich({:?})\", dep_node);\n     let new_hash = query.hash_result.map_or(Fingerprint::ZERO, |f| {\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        f(&mut hcx, result)\n+        tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n     let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n     debug!(\"END verify_ich({:?})\", dep_node);"}, {"sha": "e3045c9321d1c74474ec44616c63408beb2d113c", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -96,47 +96,48 @@ fn get_symbol_hash<'tcx>(\n     let substs = instance.substs;\n     debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n \n-    let mut hasher = StableHasher::new();\n-    let mut hcx = tcx.create_stable_hashing_context();\n-\n-    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n-        // the main symbol name is not necessarily unique; hash in the\n-        // compiler's internal def-path, guaranteeing each symbol has a\n-        // truly unique path\n-        tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n-\n-        // Include the main item-type. Note that, in this case, the\n-        // assertions about `needs_subst` may not hold, but this item-type\n-        // ought to be the same for every reference anyway.\n-        assert!(!item_type.has_erasable_regions());\n-        hcx.while_hashing_spans(false, |hcx| {\n-            item_type.hash_stable(hcx, &mut hasher);\n-\n-            // If this is a function, we hash the signature as well.\n-            // This is not *strictly* needed, but it may help in some\n-            // situations, see the `run-make/a-b-a-linker-guard` test.\n-            if let ty::FnDef(..) = item_type.kind() {\n-                item_type.fn_sig(tcx).hash_stable(hcx, &mut hasher);\n-            }\n+    tcx.with_stable_hashing_context(|mut hcx| {\n+        let mut hasher = StableHasher::new();\n+\n+        record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n+            // the main symbol name is not necessarily unique; hash in the\n+            // compiler's internal def-path, guaranteeing each symbol has a\n+            // truly unique path\n+            tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n+\n+            // Include the main item-type. Note that, in this case, the\n+            // assertions about `needs_subst` may not hold, but this item-type\n+            // ought to be the same for every reference anyway.\n+            assert!(!item_type.has_erasable_regions());\n+            hcx.while_hashing_spans(false, |hcx| {\n+                item_type.hash_stable(hcx, &mut hasher);\n+\n+                // If this is a function, we hash the signature as well.\n+                // This is not *strictly* needed, but it may help in some\n+                // situations, see the `run-make/a-b-a-linker-guard` test.\n+                if let ty::FnDef(..) = item_type.kind() {\n+                    item_type.fn_sig(tcx).hash_stable(hcx, &mut hasher);\n+                }\n \n-            // also include any type parameters (for generic items)\n-            substs.hash_stable(hcx, &mut hasher);\n+                // also include any type parameters (for generic items)\n+                substs.hash_stable(hcx, &mut hasher);\n \n-            if let Some(instantiating_crate) = instantiating_crate {\n-                tcx.def_path_hash(instantiating_crate.as_def_id())\n-                    .stable_crate_id()\n-                    .hash_stable(hcx, &mut hasher);\n-            }\n+                if let Some(instantiating_crate) = instantiating_crate {\n+                    tcx.def_path_hash(instantiating_crate.as_def_id())\n+                        .stable_crate_id()\n+                        .hash_stable(hcx, &mut hasher);\n+                }\n \n-            // We want to avoid accidental collision between different types of instances.\n-            // Especially, `VtableShim`s and `ReifyShim`s may overlap with their original\n-            // instances without this.\n-            discriminant(&instance.def).hash_stable(hcx, &mut hasher);\n+                // We want to avoid accidental collision between different types of instances.\n+                // Especially, `VtableShim`s and `ReifyShim`s may overlap with their original\n+                // instances without this.\n+                discriminant(&instance.def).hash_stable(hcx, &mut hasher);\n+            });\n         });\n-    });\n \n-    // 64 bits should be enough to avoid collisions.\n-    hasher.finish::<u64>()\n+        // 64 bits should be enough to avoid collisions.\n+        hasher.finish::<u64>()\n+    })\n }\n \n // Follow C++ namespace-mangling style, see"}, {"sha": "0172ef5700b62f480354682cac21b9df3353871d", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43bb31b9540a439dcca65f47b8644eafe4a42e2d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bb31b9540a439dcca65f47b8644eafe4a42e2d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=43bb31b9540a439dcca65f47b8644eafe4a42e2d", "patch": "@@ -53,7 +53,8 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n             None,\n             None,\n         );\n-        let expn_id = LocalExpnId::fresh(expn_data, self.cx.tcx.create_stable_hashing_context());\n+        let expn_id =\n+            self.cx.tcx.with_stable_hashing_context(|hcx| LocalExpnId::fresh(expn_data, hcx));\n         let span = DUMMY_SP.fresh_expansion(expn_id);\n \n         let is_empty = rustc_driver::catch_fatal_errors(|| {"}]}