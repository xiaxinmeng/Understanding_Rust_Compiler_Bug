{"sha": "616bfb6f15c377bc8850030f6239f14b8608b554", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNmJmYjZmMTVjMzc3YmM4ODUwMDMwZjYyMzlmMTRiODYwOGI1NTQ=", "commit": {"author": {"name": "Daniel Campbell", "email": "campbelldj@hotmail.com", "date": "2016-01-21T22:58:09Z"}, "committer": {"name": "DanielJCampbell", "email": "campbelldj@hotmail.com", "date": "2016-01-22T06:12:51Z"}, "message": "Extended save-analysis to support generated code, alterned some spans in format_args! and derive to maintain compatability", "tree": {"sha": "b24ab418c157d98adeeb67ebc5f4ebd418df8746", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b24ab418c157d98adeeb67ebc5f4ebd418df8746"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/616bfb6f15c377bc8850030f6239f14b8608b554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/616bfb6f15c377bc8850030f6239f14b8608b554", "html_url": "https://github.com/rust-lang/rust/commit/616bfb6f15c377bc8850030f6239f14b8608b554", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/616bfb6f15c377bc8850030f6239f14b8608b554/comments", "author": {"login": "DanielJCampbell", "id": 5915731, "node_id": "MDQ6VXNlcjU5MTU3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/5915731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DanielJCampbell", "html_url": "https://github.com/DanielJCampbell", "followers_url": "https://api.github.com/users/DanielJCampbell/followers", "following_url": "https://api.github.com/users/DanielJCampbell/following{/other_user}", "gists_url": "https://api.github.com/users/DanielJCampbell/gists{/gist_id}", "starred_url": "https://api.github.com/users/DanielJCampbell/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DanielJCampbell/subscriptions", "organizations_url": "https://api.github.com/users/DanielJCampbell/orgs", "repos_url": "https://api.github.com/users/DanielJCampbell/repos", "events_url": "https://api.github.com/users/DanielJCampbell/events{/privacy}", "received_events_url": "https://api.github.com/users/DanielJCampbell/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DanielJCampbell", "id": 5915731, "node_id": "MDQ6VXNlcjU5MTU3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/5915731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DanielJCampbell", "html_url": "https://github.com/DanielJCampbell", "followers_url": "https://api.github.com/users/DanielJCampbell/followers", "following_url": "https://api.github.com/users/DanielJCampbell/following{/other_user}", "gists_url": "https://api.github.com/users/DanielJCampbell/gists{/gist_id}", "starred_url": "https://api.github.com/users/DanielJCampbell/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DanielJCampbell/subscriptions", "organizations_url": "https://api.github.com/users/DanielJCampbell/orgs", "repos_url": "https://api.github.com/users/DanielJCampbell/repos", "events_url": "https://api.github.com/users/DanielJCampbell/events{/privacy}", "received_events_url": "https://api.github.com/users/DanielJCampbell/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ae76b363c1c109b1e2ab363f92ef9db80b18075", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ae76b363c1c109b1e2ab363f92ef9db80b18075", "html_url": "https://github.com/rust-lang/rust/commit/9ae76b363c1c109b1e2ab363f92ef9db80b18075"}], "stats": {"total": 446, "additions": 248, "deletions": 198}, "files": [{"sha": "2968f86d2c49d095dc764a9a5d01042586cb76b9", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 86, "deletions": 127, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=616bfb6f15c377bc8850030f6239f14b8608b554", "patch": "@@ -135,6 +135,9 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         // always using the first ones. So, only error out if we don't have enough spans.\n         // What could go wrong...?\n         if spans.len() < path.segments.len() {\n+            if generated_code(path.span) {\n+                return vec!();\n+            }\n             error!(\"Mis-calculated spans for path '{}'. Found {} spans, expected {}. Found spans:\",\n                    path_to_string(path),\n                    spans.len(),\n@@ -308,28 +311,26 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                       id: ast::NodeId,\n                       name: ast::Name,\n                       span: Span) {\n-        if generated_code(span) {\n-            return;\n-        }\n-\n         debug!(\"process_method: {}:{}\", id, name);\n \n-        let method_data = self.save_ctxt.get_method_data(id, name, span);\n+        if let Some(method_data) = self.save_ctxt.get_method_data(id, name, span) {\n \n-        if body.is_some() {\n-            self.fmt.method_str(span,\n-                                Some(method_data.span),\n-                                method_data.id,\n-                                &method_data.qualname,\n-                                method_data.declaration,\n-                                method_data.scope);\n-            self.process_formals(&sig.decl.inputs, &method_data.qualname);\n-        } else {\n-            self.fmt.method_decl_str(span,\n-                                     Some(method_data.span),\n-                                     method_data.id,\n-                                     &method_data.qualname,\n-                                     method_data.scope);\n+            if body.is_some() {\n+                self.fmt.method_str(span,\n+                                    Some(method_data.span),\n+                                    method_data.id,\n+                                    &method_data.qualname,\n+                                    method_data.declaration,\n+                                    method_data.scope);\n+                self.process_formals(&sig.decl.inputs, &method_data.qualname);\n+            } else {\n+                self.fmt.method_decl_str(span,\n+                                         Some(method_data.span),\n+                                         method_data.id,\n+                                         &method_data.qualname,\n+                                         method_data.scope);\n+            }\n+            self.process_generic_params(&sig.generics, span, &method_data.qualname, id);\n         }\n \n         // walk arg and return types\n@@ -345,8 +346,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         if let Some(body) = body {\n             self.nest(id, |v| v.visit_block(body));\n         }\n-\n-        self.process_generic_params(&sig.generics, span, &method_data.qualname, id);\n     }\n \n     fn process_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n@@ -402,17 +401,17 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                   decl: &ast::FnDecl,\n                   ty_params: &ast::Generics,\n                   body: &ast::Block) {\n-        let fn_data = self.save_ctxt.get_item_data(item);\n-        down_cast_data!(fn_data, FunctionData, self, item.span);\n-        self.fmt.fn_str(item.span,\n-                        Some(fn_data.span),\n-                        fn_data.id,\n-                        &fn_data.qualname,\n-                        fn_data.scope);\n-\n-\n-        self.process_formals(&decl.inputs, &fn_data.qualname);\n-        self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n+        if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n+            down_cast_data!(fn_data, FunctionData, self, item.span);\n+            self.fmt.fn_str(item.span,\n+                            Some(fn_data.span),\n+                            fn_data.id,\n+                            &fn_data.qualname,\n+                            fn_data.scope);\n+\n+            self.process_formals(&decl.inputs, &fn_data.qualname);\n+            self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n+        }\n \n         for arg in &decl.inputs {\n             self.visit_ty(&arg.ty);\n@@ -426,17 +425,17 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn process_static_or_const_item(&mut self, item: &ast::Item, typ: &ast::Ty, expr: &ast::Expr) {\n-        let var_data = self.save_ctxt.get_item_data(item);\n-        down_cast_data!(var_data, VariableData, self, item.span);\n-        self.fmt.static_str(item.span,\n-                            Some(var_data.span),\n-                            var_data.id,\n-                            &var_data.name,\n-                            &var_data.qualname,\n-                            &var_data.value,\n-                            &var_data.type_value,\n-                            var_data.scope);\n-\n+        if let Some(var_data) = self.save_ctxt.get_item_data(item) {\n+            down_cast_data!(var_data, VariableData, self, item.span);\n+            self.fmt.static_str(item.span,\n+                                Some(var_data.span),\n+                                var_data.id,\n+                                &var_data.name,\n+                                &var_data.qualname,\n+                                &var_data.value,\n+                                &var_data.type_value,\n+                                var_data.scope);\n+        }\n         self.visit_ty(&typ);\n         self.visit_expr(expr);\n     }\n@@ -495,6 +494,10 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     enum_definition: &ast::EnumDef,\n                     ty_params: &ast::Generics) {\n         let enum_data = self.save_ctxt.get_item_data(item);\n+        let enum_data = match enum_data {\n+            None => return,\n+            Some(data) => data,\n+        };\n         down_cast_data!(enum_data, EnumData, self, item.span);\n         self.fmt.enum_str(item.span,\n                           Some(enum_data.span),\n@@ -533,36 +536,36 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     trait_ref: &Option<ast::TraitRef>,\n                     typ: &ast::Ty,\n                     impl_items: &[P<ast::ImplItem>]) {\n-        let impl_data = self.save_ctxt.get_item_data(item);\n-        down_cast_data!(impl_data, ImplData, self, item.span);\n-        match impl_data.self_ref {\n-            Some(ref self_ref) => {\n+        let mut has_self_ref = false;\n+        if let Some(impl_data) = self.save_ctxt.get_item_data(item) {\n+            down_cast_data!(impl_data, ImplData, self, item.span);\n+            if let Some(ref self_ref) = impl_data.self_ref {\n+                has_self_ref = true;\n                 self.fmt.ref_str(recorder::TypeRef,\n                                  item.span,\n                                  Some(self_ref.span),\n                                  self_ref.ref_id,\n                                  self_ref.scope);\n             }\n-            None => {\n-                self.visit_ty(&typ);\n+            if let Some(ref trait_ref_data) = impl_data.trait_ref {\n+                self.fmt.ref_str(recorder::TypeRef,\n+                                 item.span,\n+                                 Some(trait_ref_data.span),\n+                                 trait_ref_data.ref_id,\n+                                 trait_ref_data.scope);\n+                visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n             }\n+\n+            self.fmt.impl_str(item.span,\n+                              Some(impl_data.span),\n+                              impl_data.id,\n+                              impl_data.self_ref.map(|data| data.ref_id),\n+                              impl_data.trait_ref.map(|data| data.ref_id),\n+                              impl_data.scope);\n         }\n-        if let Some(ref trait_ref_data) = impl_data.trait_ref {\n-            self.fmt.ref_str(recorder::TypeRef,\n-                             item.span,\n-                             Some(trait_ref_data.span),\n-                             trait_ref_data.ref_id,\n-                             trait_ref_data.scope);\n-            visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n+        if !has_self_ref {\n+            self.visit_ty(&typ);\n         }\n-\n-        self.fmt.impl_str(item.span,\n-                          Some(impl_data.span),\n-                          impl_data.id,\n-                          impl_data.self_ref.map(|data| data.ref_id),\n-                          impl_data.trait_ref.map(|data| data.ref_id),\n-                          impl_data.scope);\n-\n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n             self.visit_impl_item(impl_item);\n@@ -619,22 +622,23 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n     // `item` is the module in question, represented as an item.\n     fn process_mod(&mut self, item: &ast::Item) {\n-        let mod_data = self.save_ctxt.get_item_data(item);\n-        down_cast_data!(mod_data, ModData, self, item.span);\n-        self.fmt.mod_str(item.span,\n-                         Some(mod_data.span),\n-                         mod_data.id,\n-                         &mod_data.qualname,\n-                         mod_data.scope,\n-                         &mod_data.filename);\n+        if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n+            down_cast_data!(mod_data, ModData, self, item.span);\n+            self.fmt.mod_str(item.span,\n+                             Some(mod_data.span),\n+                             mod_data.id,\n+                             &mod_data.qualname,\n+                             mod_data.scope,\n+                             &mod_data.filename);\n+        }\n     }\n \n     fn process_path(&mut self, id: NodeId, path: &ast::Path, ref_kind: Option<recorder::Row>) {\n-        if generated_code(path.span) {\n+        let path_data = self.save_ctxt.get_path_data(id, path);\n+        if generated_code(path.span) && path_data.is_none() {\n             return;\n         }\n \n-        let path_data = self.save_ctxt.get_path_data(id, path);\n         let path_data = match path_data {\n             Some(pd) => pd,\n             None => {\n@@ -705,10 +709,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                           fields: &Vec<ast::Field>,\n                           variant: ty::VariantDef,\n                           base: &Option<P<ast::Expr>>) {\n-        if generated_code(path.span) {\n-            return\n-        }\n-\n         self.write_sub_paths_truncated(path, false);\n \n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n@@ -721,16 +721,15 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             let scope = self.save_ctxt.enclosing_scope(ex.id);\n \n             for field in fields {\n-                if generated_code(field.ident.span) {\n-                    continue;\n-                }\n+                if let Some(field_data) = self.save_ctxt\n+                                              .get_field_ref_data(field, variant, scope) {\n \n-                let field_data = self.save_ctxt.get_field_ref_data(field, variant, scope);\n-                self.fmt.ref_str(recorder::VarRef,\n-                                 field.ident.span,\n-                                 Some(field_data.span),\n-                                 field_data.ref_id,\n-                                 field_data.scope);\n+                    self.fmt.ref_str(recorder::VarRef,\n+                                     field.ident.span,\n+                                     Some(field_data.span),\n+                                     field_data.ref_id,\n+                                     field_data.scope);\n+                }\n \n                 self.visit_expr(&field.expr)\n             }\n@@ -754,10 +753,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn process_pat(&mut self, p: &ast::Pat) {\n-        if generated_code(p.span) {\n-            return;\n-        }\n-\n         match p.node {\n             ast::PatStruct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n@@ -766,10 +761,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 let variant = adt.variant_of_def(def);\n \n                 for &Spanned { node: ref field, span } in fields {\n-                    if generated_code(span) {\n-                        continue;\n-                    }\n-\n                     let sub_span = self.span.span_for_first_ident(span);\n                     if let Some(f) = variant.find_field_named(field.ident.name) {\n                         self.fmt.ref_str(recorder::VarRef, span, sub_span, f.did, self.cur_scope);\n@@ -813,10 +804,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        if generated_code(item.span) {\n-            return\n-        }\n-\n         match item.node {\n             ast::ItemUse(ref use_item) => {\n                 match use_item.node {\n@@ -1011,10 +998,6 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n-        if generated_code(t.span) {\n-            return\n-        }\n-\n         match t.node {\n             ast::TyPath(_, ref path) => {\n                 match self.lookup_type_ref(t.id) {\n@@ -1034,10 +1017,6 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, ex: &ast::Expr) {\n-        if generated_code(ex.span) {\n-            return\n-        }\n-\n         match ex.node {\n             ast::ExprCall(ref _f, ref _args) => {\n                 // Don't need to do anything for function calls,\n@@ -1056,10 +1035,6 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             }\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n             ast::ExprField(ref sub_ex, _) => {\n-                if generated_code(sub_ex.span) {\n-                    return\n-                }\n-\n                 self.visit_expr(&sub_ex);\n \n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n@@ -1072,10 +1047,6 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 }\n             }\n             ast::ExprTupField(ref sub_ex, idx) => {\n-                if generated_code(sub_ex.span) {\n-                    return\n-                }\n-\n                 self.visit_expr(&**sub_ex);\n \n                 let hir_node = lower_expr(self.save_ctxt.lcx, sub_ex);\n@@ -1096,10 +1067,6 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 }\n             }\n             ast::ExprClosure(_, ref decl, ref body) => {\n-                if generated_code(body.span) {\n-                    return\n-                }\n-\n                 let mut id = String::from(\"$\");\n                 id.push_str(&ex.id.to_string());\n                 self.process_formals(&decl.inputs, &id);\n@@ -1196,18 +1163,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn visit_stmt(&mut self, s: &ast::Stmt) {\n-        if generated_code(s.span) {\n-            return\n-        }\n-\n         visit::walk_stmt(self, s)\n     }\n \n     fn visit_local(&mut self, l: &ast::Local) {\n-        if generated_code(l.span) {\n-            return\n-        }\n-\n         let value = self.span.snippet(l.span);\n         self.process_var_decl(&l.pat, value);\n "}, {"sha": "37b23d6ee9ce9a9b74dce531d3694fd92da20542", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=616bfb6f15c377bc8850030f6239f14b8608b554", "patch": "@@ -30,7 +30,7 @@ use syntax::print::pprust::ty_to_string;\n \n use self::span_utils::SpanUtils;\n \n-\n+#[macro_use]\n pub mod span_utils;\n pub mod recorder;\n \n@@ -209,21 +209,21 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         result\n     }\n \n-    pub fn get_item_data(&self, item: &ast::Item) -> Data {\n+    pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n         match item.node {\n             ast::ItemFn(..) => {\n                 let name = self.tcx.map.path_to_string(item.id);\n                 let qualname = format!(\"::{}\", name);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n-\n-                Data::FunctionData(FunctionData {\n+                filter!(self.span_utils, sub_span, item.span, None);\n+                Some(Data::FunctionData(FunctionData {\n                     id: item.id,\n                     name: name,\n                     qualname: qualname,\n                     declaration: None,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n-                })\n+                }))\n             }\n             ast::ItemStatic(ref typ, mt, ref expr) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n@@ -235,30 +235,30 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 };\n \n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keyword);\n-\n-                Data::VariableData(VariableData {\n+                filter!(self.span_utils, sub_span, item.span, None);\n+                Some(Data::VariableData(VariableData {\n                     id: item.id,\n                     name: item.ident.to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n                     value: value,\n                     type_value: ty_to_string(&typ),\n-                })\n+                }))\n             }\n             ast::ItemConst(ref typ, ref expr) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Const);\n-\n-                Data::VariableData(VariableData {\n+                filter!(self.span_utils, sub_span, item.span, None);\n+                Some(Data::VariableData(VariableData {\n                     id: item.id,\n                     name: item.ident.to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n                     value: self.span_utils.snippet(expr.span),\n                     type_value: ty_to_string(&typ),\n-                })\n+                }))\n             }\n             ast::ItemMod(ref m) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n@@ -267,28 +267,28 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let filename = cm.span_to_filename(m.inner);\n \n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Mod);\n-\n-                Data::ModData(ModData {\n+                filter!(self.span_utils, sub_span, item.span, None);\n+                Some(Data::ModData(ModData {\n                     id: item.id,\n                     name: item.ident.to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n                     filename: filename,\n-                })\n+                }))\n             }\n             ast::ItemEnum(..) => {\n                 let enum_name = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let val = self.span_utils.snippet(item.span);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Enum);\n-\n-                Data::EnumData(EnumData {\n+                filter!(self.span_utils, sub_span, item.span, None);\n+                Some(Data::EnumData(EnumData {\n                     id: item.id,\n                     value: val,\n                     span: sub_span.unwrap(),\n                     qualname: enum_name,\n                     scope: self.enclosing_scope(item.id),\n-                })\n+                }))\n             }\n             ast::ItemImpl(_, _, _, ref trait_ref, ref typ, _) => {\n                 let mut type_data = None;\n@@ -299,10 +299,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 match typ.node {\n                     // Common case impl for a struct or something basic.\n                     ast::TyPath(None, ref path) => {\n-                        sub_span = self.span_utils.sub_span_for_type_name(path.span).unwrap();\n+                        sub_span = self.span_utils.sub_span_for_type_name(path.span);\n+                        filter!(self.span_utils, sub_span, path.span, None);\n                         type_data = self.lookup_ref_id(typ.id).map(|id| {\n                             TypeRefData {\n-                                span: sub_span,\n+                                span: sub_span.unwrap(),\n                                 scope: parent,\n                                 ref_id: id,\n                             }\n@@ -311,20 +312,21 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     _ => {\n                         // Less useful case, impl for a compound type.\n                         let span = typ.span;\n-                        sub_span = self.span_utils.sub_span_for_type_name(span).unwrap_or(span);\n+                        sub_span = self.span_utils.sub_span_for_type_name(span).or(Some(span));\n                     }\n                 }\n \n                 let trait_data = trait_ref.as_ref()\n                                           .and_then(|tr| self.get_trait_ref_data(tr, parent));\n \n-                Data::ImplData(ImplData {\n+                filter!(self.span_utils, sub_span, typ.span, None);\n+                Some(Data::ImplData(ImplData {\n                     id: item.id,\n-                    span: sub_span,\n+                    span: sub_span.unwrap(),\n                     scope: parent,\n                     trait_ref: trait_data,\n                     self_ref: type_data,\n-                })\n+                }))\n             }\n             _ => {\n                 // FIXME\n@@ -333,12 +335,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_field_data(&self, field: &ast::StructField, scope: NodeId) -> Option<VariableData> {\n+    pub fn get_field_data(&self, field: &ast::StructField,\n+                          scope: NodeId) -> Option<VariableData> {\n         match field.node.kind {\n             ast::NamedField(ident, _) => {\n                 let qualname = format!(\"::{}::{}\", self.tcx.map.path_to_string(scope), ident);\n                 let typ = self.tcx.node_types().get(&field.node.id).unwrap().to_string();\n                 let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n+                filter!(self.span_utils, sub_span, field.span, None);\n                 Some(VariableData {\n                     id: field.node.id,\n                     name: ident.to_string(),\n@@ -355,7 +359,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     // FIXME would be nice to take a MethodItem here, but the ast provides both\n     // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self, id: ast::NodeId, name: ast::Name, span: Span) -> FunctionData {\n+    pub fn get_method_data(&self, id: ast::NodeId,\n+                           name: ast::Name, span: Span) -> Option<FunctionData> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let qualname = match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n@@ -430,29 +435,30 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         });\n \n         let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n-\n-        FunctionData {\n+        filter!(self.span_utils, sub_span, span, None);\n+        Some(FunctionData {\n             id: id,\n             name: name.to_string(),\n             qualname: qualname,\n             declaration: decl_id,\n             span: sub_span.unwrap(),\n             scope: self.enclosing_scope(id),\n-        }\n+        })\n     }\n \n     pub fn get_trait_ref_data(&self,\n                               trait_ref: &ast::TraitRef,\n                               parent: NodeId)\n                               -> Option<TypeRefData> {\n-        self.lookup_ref_id(trait_ref.ref_id).map(|def_id| {\n+        self.lookup_ref_id(trait_ref.ref_id).and_then(|def_id| {\n             let span = trait_ref.path.span;\n-            let sub_span = self.span_utils.sub_span_for_type_name(span).unwrap_or(span);\n-            TypeRefData {\n-                span: sub_span,\n+            let sub_span = self.span_utils.sub_span_for_type_name(span).or(Some(span));\n+            filter!(self.span_utils, sub_span, span, None);\n+            Some(TypeRefData {\n+                span: sub_span.unwrap(),\n                 scope: parent,\n                 ref_id: def_id,\n-            }\n+            })\n         })\n     }\n \n@@ -465,6 +471,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ty::TyStruct(def, _) => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n+                        filter!(self.span_utils, sub_span, expr.span, None);\n                         return Some(Data::VariableRefData(VariableRefData {\n                             name: ident.node.to_string(),\n                             span: sub_span.unwrap(),\n@@ -484,6 +491,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 match *ty {\n                     ty::TyStruct(def, _) => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n+                        filter!(self.span_utils, sub_span, path.span, None);\n                         Some(Data::TypeRefData(TypeRefData {\n                             span: sub_span.unwrap(),\n                             scope: self.enclosing_scope(expr.id),\n@@ -506,6 +514,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n                 };\n                 let sub_span = self.span_utils.sub_span_for_meth_name(expr.span);\n+                filter!(self.span_utils, sub_span, expr.span, None);\n                 let parent = self.enclosing_scope(expr.id);\n                 Some(Data::MethodCallData(MethodCallData {\n                     span: sub_span.unwrap(),\n@@ -532,6 +541,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n         let def = def_map.get(&id).unwrap().full_def();\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n+        filter!(self.span_utils, sub_span, path.span, None);\n         match def {\n             Def::Upvar(..) |\n             Def::Local(..) |\n@@ -559,6 +569,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             Def::Method(decl_id) => {\n                 let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n+                filter!(self.span_utils, sub_span, path.span, None);\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.impl_or_trait_item(decl_id);\n                     match ti.container() {\n@@ -628,16 +639,17 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                               field_ref: &ast::Field,\n                               variant: ty::VariantDef,\n                               parent: NodeId)\n-                              -> VariableRefData {\n+                              -> Option<VariableRefData> {\n         let f = variant.field_named(field_ref.ident.node.name);\n         // We don't really need a sub-span here, but no harm done\n         let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n-        VariableRefData {\n+        filter!(self.span_utils, sub_span, field_ref.ident.span, None);\n+        Some(VariableRefData {\n             name: field_ref.ident.node.to_string(),\n             span: sub_span.unwrap(),\n             scope: parent,\n             ref_id: f.did,\n-        }\n+        })\n     }\n \n     pub fn get_data_for_id(&self, _id: &NodeId) -> Data {\n@@ -677,17 +689,15 @@ impl PathCollector {\n \n impl<'v> Visitor<'v> for PathCollector {\n     fn visit_pat(&mut self, p: &ast::Pat) {\n-        if generated_code(p.span) {\n-            return;\n-        }\n-\n         match p.node {\n             ast::PatStruct(ref path, _, _) => {\n-                self.collected_paths.push((p.id, path.clone(), ast::MutMutable, recorder::TypeRef));\n+                self.collected_paths.push((p.id, path.clone(),\n+                                           ast::MutMutable, recorder::TypeRef));\n             }\n             ast::PatEnum(ref path, _) |\n             ast::PatQPath(_, ref path) => {\n-                self.collected_paths.push((p.id, path.clone(), ast::MutMutable, recorder::VarRef));\n+                self.collected_paths.push((p.id, path.clone(),\n+                                           ast::MutMutable, recorder::VarRef));\n             }\n             ast::PatIdent(bm, ref path1, _) => {\n                 debug!(\"PathCollector, visit ident in pat {}: {:?} {:?}\",\n@@ -719,10 +729,6 @@ pub fn process_crate<'l, 'tcx>(tcx: &'l ty::ctxt<'tcx>,\n                                odir: Option<&Path>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n-    if generated_code(krate.span) {\n-        return;\n-    }\n-\n     assert!(analysis.glob_map.is_some());\n \n     info!(\"Dumping crate {}\", cratename);\n@@ -780,8 +786,8 @@ fn escape(s: String) -> String {\n     s.replace(\"\\\"\", \"\\\"\\\"\")\n }\n \n-// If the expression is a macro expansion or other generated code, run screaming\n-// and don't index.\n+// Helper function to determine if a span came from a\n+// macro expansion or syntax extension.\n pub fn generated_code(span: Span) -> bool {\n     span.expn_id != NO_EXPANSION || span == DUMMY_SP\n }"}, {"sha": "682a74c8f0c38a8ba9bb121bad1bc332cb795791", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=616bfb6f15c377bc8850030f6239f14b8608b554", "patch": "@@ -318,6 +318,7 @@ impl<'a, 'tcx: 'a> FmtStrs<'a, 'tcx> {\n                             span: Span,\n                             sub_span: Option<Span>,\n                             values: Vec<String>) {\n+        filter!(self.span, sub_span, span);\n         match sub_span {\n             Some(sub_span) => self.record_with_span(kind, span, sub_span, values),\n             None => {"}, {"sha": "344431032d6947e85926dbd035a72a1c3fd1ef1b", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=616bfb6f15c377bc8850030f6239f14b8608b554", "patch": "@@ -66,13 +66,6 @@ impl<'a> SpanUtils<'a> {\n     // sub_span starts at span.lo, so we need to adjust the positions etc.\n     // If sub_span is None, we don't need to adjust.\n     pub fn make_sub_span(&self, span: Span, sub_span: Option<Span>) -> Option<Span> {\n-        let loc = self.sess.codemap().lookup_char_pos(span.lo);\n-        assert!(!generated_code(span),\n-                \"generated code; we should not be processing this `{}` in {}, line {}\",\n-                self.snippet(span),\n-                loc.file.name,\n-                loc.line);\n-\n         match sub_span {\n             None => None,\n             Some(sub) => {\n@@ -81,7 +74,7 @@ impl<'a> SpanUtils<'a> {\n                 Some(Span {\n                     lo: base + self.sess.codemap().lookup_byte_offset(sub.lo).pos,\n                     hi: base + self.sess.codemap().lookup_byte_offset(sub.hi).pos,\n-                    expn_id: NO_EXPANSION,\n+                    expn_id: span.expn_id,\n                 })\n             }\n         }\n@@ -259,6 +252,9 @@ impl<'a> SpanUtils<'a> {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 if bracket_count != 0 {\n+                    if generated_code(span) {\n+                        return vec!();\n+                    }\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n                     self.sess.span_bug(span,\n                                        &format!(\"Mis-counted brackets when breaking path? \\\n@@ -358,19 +354,12 @@ impl<'a> SpanUtils<'a> {\n     // Returns a list of the spans of idents in a path.\n     // E.g., For foo::bar<x,t>::baz, we return [foo, bar, baz] (well, their spans)\n     pub fn spans_for_path_segments(&self, path: &ast::Path) -> Vec<Span> {\n-        if generated_code(path.span) {\n-            return vec!();\n-        }\n-\n         self.spans_with_brackets(path.span, 0, -1)\n     }\n \n     // Return an owned vector of the subspans of the param identifier\n     // tokens found in span.\n     pub fn spans_for_ty_params(&self, span: Span, number: isize) -> Vec<Span> {\n-        if generated_code(span) {\n-            return vec!();\n-        }\n         // Type params are nested within one level of brackets:\n         // i.e. we want Vec<A, B> from Foo<A, B<T,U>>\n         self.spans_with_brackets(span, 1, number)\n@@ -388,4 +377,40 @@ impl<'a> SpanUtils<'a> {\n             self.sess.bug(\"span errors reached 1000, giving up\");\n         }\n     }\n+\n+    /// Return true if the span is generated code, and\n+    /// it is not a subspan of the root callsite.\n+    ///\n+    /// Used to filter out spans of minimal value,\n+    /// such as references to macro internal variables.\n+    pub fn filter_generated(&self, sub_span: Option<Span>, parent: Span) -> bool {\n+        if !generated_code(parent) {\n+            if sub_span.is_none() {\n+                // Edge case - this occurs on generated code with incorrect expansion info.\n+                return true;\n+            }\n+            return false;\n+        }\n+        // If sub_span is none, filter out generated code.\n+        if sub_span.is_none() {\n+            return true;\n+        }\n+        // A generated span is deemed invalid if it is not a sub-span of the root\n+        // callsite. This filters out macro internal variables and most malformed spans.\n+        let span = self.sess.codemap().source_callsite(parent);\n+        !(parent.lo >= span.lo && parent.hi <= span.hi)\n+    }\n+}\n+\n+macro_rules! filter {\n+    ($util: expr, $span: ident, $parent: expr, None) => {\n+        if $util.filter_generated($span, $parent) {\n+            return None;\n+        }\n+    };\n+    ($util: expr, $span: ident, $parent: expr) => {\n+        if $util.filter_generated($span, $parent) {\n+            return;\n+        }\n+    };\n }"}, {"sha": "432c1688536bb1d28f998fa48d280b31bb7d07cc", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=616bfb6f15c377bc8850030f6239f14b8608b554", "patch": "@@ -858,10 +858,15 @@ impl CodeMap {\n         let span_str = self.span_to_string(sp);\n         let mut span_snip = self.span_to_snippet(sp)\n             .unwrap_or(\"Snippet unavailable\".to_owned());\n-        if span_snip.len() > 50 {\n-            span_snip.truncate(50);\n+\n+        // Truncate by code points - in worst case this will be more than 50 characters,\n+        // but ensures at least 50 characters and respects byte boundaries.\n+        let char_vec: Vec<(usize, char)> = span_snip.char_indices().collect();\n+        if char_vec.len() > 50 {\n+            span_snip.truncate(char_vec[49].0);\n             span_snip.push_str(\"...\");\n         }\n+\n         output.push_str(&format!(\"{}{}\\n{}`{}`\\n\", indent, span_str, indent, span_snip));\n \n         if sp.expn_id == NO_EXPANSION || sp.expn_id == COMMAND_LINE_EXPN {\n@@ -909,6 +914,22 @@ impl CodeMap {\n         output\n     }\n \n+    /// Return the source span - this is either the supplied span, or the span for\n+    /// the macro callsite that expanded to it.\n+    pub fn source_callsite(&self, sp: Span) -> Span {\n+        let mut span = sp;\n+        while span.expn_id != NO_EXPANSION && span.expn_id != COMMAND_LINE_EXPN {\n+            if let Some(callsite) = self.with_expn_info(span.expn_id,\n+                                               |ei| ei.map(|ei| ei.call_site.clone())) {\n+                span = callsite;\n+            }\n+            else {\n+                break;\n+            }\n+        }\n+        span\n+    }\n+\n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n         self.lookup_char_pos(sp.lo).file.name.to_string()\n     }"}, {"sha": "008067f39a3524a0aa3f68113719fa09164d5507", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=616bfb6f15c377bc8850030f6239f14b8608b554", "patch": "@@ -13,7 +13,7 @@ use deriving::generic::ty::*;\n \n use syntax::ast;\n use syntax::ast::{MetaItem, Expr};\n-use syntax::codemap::{Span, respan};\n+use syntax::codemap::{Span, respan, DUMMY_SP};\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n@@ -87,7 +87,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                                                fmt,\n                                                token::str_to_ident(\"debug_tuple\"),\n                                                vec![name]);\n-                stmts.push(cx.stmt_let(span, true, builder, expr));\n+                stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n                 for field in fields {\n                     // Use double indirection to make sure this works for unsized types\n@@ -109,7 +109,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                                                fmt,\n                                                token::str_to_ident(\"debug_struct\"),\n                                                vec![name]);\n-                stmts.push(cx.stmt_let(span, true, builder, expr));\n+                stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n                 for field in fields {\n                     let name = cx.expr_lit(field.span, ast::Lit_::LitStr("}, {"sha": "77bf90abbcc1441338ca1a3043c895eb17721794", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=616bfb6f15c377bc8850030f6239f14b8608b554", "patch": "@@ -14,7 +14,7 @@ use self::Position::*;\n use fmt_macros as parse;\n \n use syntax::ast;\n-use syntax::codemap::{Span, respan};\n+use syntax::codemap::{Span, respan, DUMMY_SP};\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n@@ -501,7 +501,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             };\n \n             let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n-            pats.push(self.ecx.pat_ident(e.span, name));\n+            pats.push(self.ecx.pat_ident(DUMMY_SP, name));\n             locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n                                             self.ecx.expr_ident(e.span, name)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n@@ -518,7 +518,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n             let lname = self.ecx.ident_of(&format!(\"__arg{}\",\n                                                   *name));\n-            pats.push(self.ecx.pat_ident(e.span, lname));\n+            pats.push(self.ecx.pat_ident(DUMMY_SP, lname));\n             names[*self.name_positions.get(name).unwrap()] =\n                 Some(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n                                          self.ecx.expr_ident(e.span, lname)));"}, {"sha": "7a1c200ba20e89f8245ed026f66da24ce4e4c94f", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616bfb6f15c377bc8850030f6239f14b8608b554/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=616bfb6f15c377bc8850030f6239f14b8608b554", "patch": "@@ -287,6 +287,26 @@ pub struct blah {\n     used_link_args: RefCell<[&'static str; 0]>,\n }\n \n+#[macro_use]\n+mod macro_use_test {\n+    macro_rules! test_rec {\n+        (q, $src: expr) => {{\n+            print!(\"{}\", $src);\n+            test_rec!($src);\n+        }};\n+        ($src: expr) => {\n+            print!(\"{}\", $src);\n+        };\n+    }\n+\n+    macro_rules! internal_vars {\n+        ($src: ident) => {{\n+            let mut x = $src;\n+            x += 100;\n+        }};\n+    }\n+}\n+\n fn main() { // foo\n     let s = box some_fields {field1: 43};\n     hello((43, \"a\".to_string()), *s);\n@@ -356,6 +376,11 @@ fn main() { // foo\n     while let Some(z) = None {\n         foo_foo(z);\n     }\n+\n+    let mut x = 4;\n+    test_rec!(q, \"Hello\");\n+    assert_eq!(x, 4);\n+    internal_vars!(x);\n }\n \n fn foo_foo(_: i32) {}\n@@ -398,3 +423,16 @@ impl Error + 'static + Send {\n         <Error + 'static>::is::<T>(self)\n     }\n }\n+extern crate serialize;\n+#[derive(Clone, Copy, Hash, Encodable, Decodable, PartialEq, Eq, PartialOrd, Ord, Debug, Default)]\n+struct AllDerives(i32);\n+\n+fn test_format_args() {\n+    let x = 1;\n+    let y = 2;\n+    let name = \"Joe Blogg\";\n+    println!(\"Hello {}\", name);\n+    print!(\"Hello {0}\", name);\n+    print!(\"{0} + {} = {}\", x, y);\n+    print!(\"x is {}, y is {1}, name is {n}\", x, y, n = name);\n+}\n\\ No newline at end of file"}]}