{"sha": "1e22a55ff25612753665a76eb3b83628379334a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMjJhNTVmZjI1NjEyNzUzNjY1YTc2ZWIzYjgzNjI4Mzc5MzM0YTA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-03T16:50:25Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-03T16:50:25Z"}, "message": "Code sketch and comment notes on textual crate signatures.", "tree": {"sha": "a051f47d2326dfce3b4e8f26abe88dac5563dd44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a051f47d2326dfce3b4e8f26abe88dac5563dd44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e22a55ff25612753665a76eb3b83628379334a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e22a55ff25612753665a76eb3b83628379334a0", "html_url": "https://github.com/rust-lang/rust/commit/1e22a55ff25612753665a76eb3b83628379334a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e22a55ff25612753665a76eb3b83628379334a0/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7abf6eb7c67dfb43540fdcafd6f1e69bdd2a6849", "url": "https://api.github.com/repos/rust-lang/rust/commits/7abf6eb7c67dfb43540fdcafd6f1e69bdd2a6849", "html_url": "https://github.com/rust-lang/rust/commit/7abf6eb7c67dfb43540fdcafd6f1e69bdd2a6849"}], "stats": {"total": 244, "additions": 244, "deletions": 0}, "files": [{"sha": "a4769e83ed1e4006c75d868406d83c46791228b5", "filename": "src/boot/driver/lib.ml", "status": "modified", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/1e22a55ff25612753665a76eb3b83628379334a0/src%2Fboot%2Fdriver%2Flib.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1e22a55ff25612753665a76eb3b83628379334a0/src%2Fboot%2Fdriver%2Flib.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Flib.ml?ref=1e22a55ff25612753665a76eb3b83628379334a0", "patch": "@@ -1,4 +1,5 @@\n open Common;;\n+open Fmt;;\n \n let log (sess:Session.sess) =\n   Session.log \"lib\"\n@@ -12,6 +13,224 @@ let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n   else ()\n ;;\n \n+(*\n+ * Stuff associated with 'crate interfaces'.\n+ * \n+ * The interface of a crate used to be defined by the accompanying DWARF\n+ * structure in the object file. This was an experiment -- we talked to\n+ * DWARF hackers before hand and they thought it worth trying -- which did\n+ * work, and had the advantage of economy of metadata-emitting, but several\n+ * downsides:\n+ *\n+ *   - The reader -- which we want a copy of at runtime in the linker -- has\n+ *     to know how to read DWARF. It's not the simplest format.\n+ * \n+ *   - The complexity of the encoding meant we didn't always keep pace with\n+ *     the AST, and maintaining any degree of inter-change compatibility was\n+ *     going ot be a serious challenge.\n+ * \n+ *   - Diagnostic tools are atrocious, as is the definition of\n+ *     well-formedness. It's largely trial and error when talking to gdb,\n+ *     say.\n+ * \n+ *   - Because it was doing double-duty as *driving linkage*, we were never\n+ *     going to get to the linkage efficiency of native symbols (hash\n+ *     lookup) anyway. Runtime linkage -- even when lazy -- really ought to\n+ *     be fast.\n+ * \n+ *   - LLVM, our \"main\" backend (in rustc) does not really want to make\n+ *     promises about preserving dwarf.\n+ *\n+ *   - LLVM also *is* going to emit native symbols; complete with relocs and\n+ *     such.  We'd actually have to do *extra work* to inhibit that.\n+ *\n+ *   - Most tools are set up to think of DWARF as \"debug\", meaning\n+ *     \"optional\", and may well strip it or otherwise mangle it.\n+ *\n+ *   - Many tools want native symbols anyways, and don't know how to look at\n+ *     DWARF.\n+ * \n+ *   - All the tooling arguments go double on win32. Pretty much only\n+ *     objdump and gdb understand DWARF-in-PE. Everything else is just blank\n+ *     stares.\n+ * \n+ * For all these reasons we're moving to a self-made format for describing\n+ * our interfaces. This will be stored in the .note.rust section as we\n+ * presently store the meta tags. The encoding is ASCII-compatible (the set\n+ * of \"numbers\" to encode is small enough, especially compared to dwarf,\n+ * that we can just use a text form) and is very easy to read with a simple\n+ * byte-at-a-time parser.\n+ * \n+ *)\n+\n+(*\n+ * Encoding goals:\n+ *\n+ *   - Simple. Minimal state or read-ambiguity in reader.\n+ *\n+ *   - Compact. Shouldn't add a lot to the size of the binary to glue this\n+ *     on to it.\n+ *\n+ *   - Front-end-y. Doesn't need to contain much beyond parse-level of the\n+ *     crate's exported items; it'll be fed into the front-end of the\n+ *     pipeline anyway. No need to have all types or names resolved.\n+ *\n+ *   - Testable. Human-legible and easy to identify/fix/test errors in.\n+ *\n+ *   - Very fast to read the 'identifying' prefix (version, meta tags, hash)\n+ *\n+ *   - Tolerably fast to read in its entirety.\n+ *\n+ *   - Safe from version-drift (or at least able to notice it and abort).\n+ * \n+ * Anti-goals:\n+ * \n+ *   - Random access.\n+ * \n+ *   - Generality to other languages.\n+ *\n+ * Structure:\n+ *\n+ *   - Line oriented.\n+ *\n+ *   - Whitespace-separated and whitespace-agnostic. Indent for legibility.\n+ *\n+ *   - Each line is a record. A record is either a full item, an item bracket,\n+ *     a comment, or metadata.\n+ *\n+ *     - First byte describes type of record, unless first byte is +, in which\n+ *       case it's oh-no-we-ran-out-of-tags and it's followed by 2 type-bytes.\n+ *       (Continue to +++ if you happen to run out *there* as well. You\n+ *       won't.)\n+ *\n+ *       - Metadata type is !\n+ *\n+ *       - Comment type is #\n+ *\n+ *       - Full item types are: y for type, c for const, f for fn, i for iter,\n+ *         g for tag constructor.\n+ *\n+ *       - Item brackets are those that open/close a scope of\n+ *         sub-records. These would be obj (o), mod (m), tag (t) to open. The\n+ *         closer is always '.'.  So a mod looks like:\n+ *\n+ *            m foo\n+ *                c bar\n+ *            .\n+ * \n+ *     - After first byte of openers and full items is whitespace, then an\n+ *       ident.\n+ *\n+ *     - After that, if it's a ty, fn, iter, obj or tag, there may be [, a\n+ *        list of comma-separated ty param names, and ].\n+ *\n+ *     - After that, if it's a fn, iter, obj or tag constructor, there is a (,\n+ *       a list of comma-separated type-encoded slot/ident pairs, and a ).\n+ *\n+ *     - After that, if it's a fn or iter, there's a '->' and a type-encoded\n+ *       output.\n+ *\n+ *     - After that, a newline '\\n'.\n+ *\n+ *     - Type encoding is a longer issue! We'll get to that.\n+ *)\n+\n+let fmt_iface (ff:Format.formatter) (crate:Ast.crate) : unit =\n+  let fmt_ty_param ff (p:Ast.ty_param identified) : unit =\n+    fmt ff \"%s\" (fst p.node)\n+  in\n+  let rec fmt_ty ff (t:Ast.ty) : unit =\n+    match t with\n+        Ast.TY_any -> fmt ff \"a\"\n+      | Ast.TY_nil -> fmt ff \"n\"\n+      | Ast.TY_bool -> fmt ff \"b\"\n+      | Ast.TY_mach tm -> fmt ff \"%s\" (string_of_ty_mach tm)\n+      | Ast.TY_int -> fmt ff \"i\"\n+      | Ast.TY_uint -> fmt ff \"u\"\n+      | Ast.TY_char -> fmt ff \"c\"\n+      | Ast.TY_str -> fmt ff \"s\"\n+\n+      | Ast.TY_tup ttup ->\n+          fmt_bracketed_arr_sep \"(\" \")\" \",\"\n+            fmt_ty ff ttup\n+      | Ast.TY_vec ty ->\n+          fmt ff \"v[\"; fmt_ty ff ty; fmt ff \"]\"\n+      | Ast.TY_chan ty ->\n+          fmt ff \"C[\"; fmt_ty ff ty; fmt ff \"]\"\n+\n+      | Ast.TY_port ty ->\n+          fmt ff \"P[\"; fmt_ty ff ty; fmt ff \"]\"\n+\n+      | Ast.TY_task ->\n+          fmt ff \"T\"\n+\n+      | Ast.TY_named n -> fmt ff \":\"; fmt_name ff n\n+      | Ast.TY_type -> fmt ff \"Y\"\n+\n+      | Ast.TY_box t -> fmt ff \"@@\"; fmt_ty ff t\n+      | Ast.TY_mutable t -> fmt ff \"~\"; fmt_ty ff t\n+\n+      (* FIXME: finish this. *)\n+      | Ast.TY_rec _\n+      | Ast.TY_tag _\n+      | Ast.TY_fn _\n+      | Ast.TY_obj _\n+      | Ast.TY_native _\n+      | Ast.TY_param _\n+      | Ast.TY_constrained _ -> fmt ff \"Z\"\n+\n+  and fmt_name ff n =\n+    match n with\n+        Ast.NAME_base (Ast.BASE_ident id) -> fmt ff \"%s\" id\n+      | Ast.NAME_base (Ast.BASE_temp _) -> failwith \"temp in fmt_name\"\n+      | Ast.NAME_base (Ast.BASE_app (id, tys)) ->\n+          fmt ff \"%s\" id;\n+          fmt_bracketed_arr_sep \"[\" \"]\" \",\"\n+            fmt_ty ff tys;\n+      | Ast.NAME_ext (n, Ast.COMP_ident id) ->\n+          fmt_name ff n;\n+          fmt ff \".%s\" id\n+      | Ast.NAME_ext (n, Ast.COMP_app (id, tys)) ->\n+          fmt_name ff n;\n+          fmt ff \".%s\" id;\n+          fmt_bracketed_arr_sep \"[\" \"]\" \",\"\n+            fmt_ty ff tys;\n+      | Ast.NAME_ext (n, Ast.COMP_idx i) ->\n+          fmt_name ff n;\n+          fmt ff \"._%d\" i\n+  in\n+  let rec fmt_mod_item (id:Ast.ident) (mi:Ast.mod_item) : unit =\n+    let i c = fmt ff \"@\\n%c %s\" c id in\n+\n+    let o c = fmt ff \"@\\n\"; fmt_obox ff; fmt ff \"%c %s\" c id in\n+    let p _ =\n+      if (Array.length mi.node.Ast.decl_params) <> 0\n+      then\n+        fmt_bracketed_arr_sep \"[\" \"]\" \",\"\n+          fmt_ty_param ff mi.node.Ast.decl_params\n+    in\n+    let c _ =  fmt_cbox ff; fmt ff \"@\\n.\" in\n+    match mi.node.Ast.decl_item with\n+        Ast.MOD_ITEM_type _ -> i 'y'; p()\n+      | Ast.MOD_ITEM_tag _ -> i 'g'; p()\n+      | Ast.MOD_ITEM_fn _ -> i 'f'; p();\n+      | Ast.MOD_ITEM_const _ -> i 'c'\n+      | Ast.MOD_ITEM_obj _ ->\n+          o 'o'; p();\n+          c ()\n+      | Ast.MOD_ITEM_mod (_, items) ->\n+          o 'm';\n+          fmt_mod_items items;\n+          c ()\n+  and fmt_mod_items items =\n+    sorted_htab_iter fmt_mod_item items\n+  in\n+  let (_,items) = crate.node.Ast.crate_items in\n+    fmt_mod_items items\n+;;\n+\n+(* Mechanisms for scanning libraries. *)\n+\n (* FIXME (issue #67): move these to sess. *)\n let ar_cache = Hashtbl.create 0 ;;\n let sects_cache = Hashtbl.create 0;;"}, {"sha": "82057766b37ff625a35d22d9cf684f7cdb3a58cf", "filename": "src/boot/driver/main.ml", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1e22a55ff25612753665a76eb3b83628379334a0/src%2Fboot%2Fdriver%2Fmain.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1e22a55ff25612753665a76eb3b83628379334a0/src%2Fboot%2Fdriver%2Fmain.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fmain.ml?ref=1e22a55ff25612753665a76eb3b83628379334a0", "patch": "@@ -33,6 +33,7 @@ let (sess:Session.sess) =\n     Session.sess_log_lex = false;\n     Session.sess_log_parse = false;\n     Session.sess_log_ast = false;\n+    Session.sess_log_sig = false;\n     Session.sess_log_passes = false;\n     Session.sess_log_resolve = false;\n     Session.sess_log_type = false;\n@@ -116,6 +117,7 @@ let dump_sig (filename:filename) : unit =\n     exit 0\n ;;\n \n+\n let dump_meta (filename:filename) : unit =\n   begin\n     match Lib.get_meta sess filename with\n@@ -168,6 +170,8 @@ let argspecs =\n        \"-lparse\"    \"log parsing\");\n     (flag (fun _ -> sess.Session.sess_log_ast <- true)\n        \"-last\"      \"log AST\");\n+    (flag (fun _ -> sess.Session.sess_log_sig <- true)\n+       \"-lsig\"      \"log signature\");\n     (flag (fun _ -> sess.Session.sess_log_passes <- true)\n        \"-lpasses\"  \"log passes at high-level\");\n     (flag (fun _ -> sess.Session.sess_log_resolve <- true)\n@@ -358,6 +362,17 @@ then\n     Format.set_margin 80;\n     Printf.fprintf stdout \"%s\\n\" (Fmt.fmt_to_str Ast.fmt_crate crate)\n   end\n+;;\n+\n+if sess.Session.sess_log_sig\n+then\n+  begin\n+    Printf.fprintf stdout \"Post-parse signature:\\n\";\n+    Format.set_margin 80;\n+    Printf.fprintf stdout \"%s\\n\" (Fmt.fmt_to_str Lib.fmt_iface crate);\n+  end\n+;;\n+\n \n let list_to_seq ls = Asm.SEQ (Array.of_list ls);;\n let select_insns (quads:Il.quads) : Asm.frag ="}, {"sha": "d79b7d2067d681a7e0b50aa98a53cce5a638919a", "filename": "src/boot/driver/session.ml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e22a55ff25612753665a76eb3b83628379334a0/src%2Fboot%2Fdriver%2Fsession.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1e22a55ff25612753665a76eb3b83628379334a0/src%2Fboot%2Fdriver%2Fsession.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fsession.ml?ref=1e22a55ff25612753665a76eb3b83628379334a0", "patch": "@@ -19,6 +19,7 @@ type sess =\n   mutable sess_log_lex: bool;\n   mutable sess_log_parse: bool;\n   mutable sess_log_ast: bool;\n+  mutable sess_log_sig: bool;\n   mutable sess_log_passes: bool;\n   mutable sess_log_resolve: bool;\n   mutable sess_log_type: bool;"}, {"sha": "7a95573cd4ed484dba365911b74d2e9cd277f1fd", "filename": "src/boot/util/common.ml", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e22a55ff25612753665a76eb3b83628379334a0/src%2Fboot%2Futil%2Fcommon.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1e22a55ff25612753665a76eb3b83628379334a0/src%2Fboot%2Futil%2Fcommon.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Futil%2Fcommon.ml?ref=1e22a55ff25612753665a76eb3b83628379334a0", "patch": "@@ -218,6 +218,15 @@ let sorted_htab_keys (tab:('a, 'b) Hashtbl.t) : 'a array =\n     keys\n ;;\n \n+let sorted_htab_iter\n+    (f:'a -> 'b -> unit)\n+    (tab:('a, 'b) Hashtbl.t)\n+    : unit =\n+  Array.iter\n+    (fun k -> f k (Hashtbl.find tab k))\n+    (sorted_htab_keys tab)\n+;;\n+\n let htab_vals (htab:('a,'b) Hashtbl.t) : ('b list)  =\n   Hashtbl.fold (fun _ v accum -> v :: accum) htab []\n ;;"}]}