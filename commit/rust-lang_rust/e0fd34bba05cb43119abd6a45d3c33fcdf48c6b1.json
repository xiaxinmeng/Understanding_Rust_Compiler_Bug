{"sha": "e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZmQzNGJiYTA1Y2I0MzExOWFiZDZhNDVkM2MzM2ZjZGY0OGM2YjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-09T23:11:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-09T23:11:51Z"}, "message": "Auto merge of #33523 - Manishearth:rollup, r=Manishearth\n\nRollup of 10 pull requests\n\n- Successful merges: #33129, #33224, #33370, #33383, #33431, #33474, #33480, #33496, #33509, #33514\n- Failed merges:", "tree": {"sha": "bba6328b56f6a5e4086c4fb73ae57d55c20c3c31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bba6328b56f6a5e4086c4fb73ae57d55c20c3c31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "html_url": "https://github.com/rust-lang/rust/commit/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e7cb8bc31413c9ea08c67c4d66318a7e9cbfb66", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e7cb8bc31413c9ea08c67c4d66318a7e9cbfb66", "html_url": "https://github.com/rust-lang/rust/commit/0e7cb8bc31413c9ea08c67c4d66318a7e9cbfb66"}, {"sha": "52f48bdcb5260fa82df840c8224338dd28b7b818", "url": "https://api.github.com/repos/rust-lang/rust/commits/52f48bdcb5260fa82df840c8224338dd28b7b818", "html_url": "https://github.com/rust-lang/rust/commit/52f48bdcb5260fa82df840c8224338dd28b7b818"}], "stats": {"total": 2031, "additions": 1106, "deletions": 925}, "files": [{"sha": "a10e98fac7adfafbb918bad27083d2e1ffaa39f3", "filename": "src/doc/book/error-handling.md", "status": "modified", "additions": 61, "deletions": 59, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Fdoc%2Fbook%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Fdoc%2Fbook%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ferror-handling.md?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -1573,8 +1573,9 @@ detail on Getopts, but there is [some good documentation][15]\n describing it. The short story is that Getopts generates an argument\n parser and a help message from a vector of options (The fact that it\n is a vector is hidden behind a struct and a set of methods). Once the\n-parsing is done, we can decode the program arguments into a Rust\n-struct. From there, we can get information about the flags, for\n+parsing is done, the parser returns a struct that records matches\n+for defined options, and remaining \"free\" arguments.\n+From there, we can get information about the flags, for\n instance, whether they were passed in, and what arguments they\n had. Here's our program with the appropriate `extern crate`\n statements, and the basic argument setup for Getopts:\n@@ -1605,8 +1606,8 @@ fn main() {\n         print_usage(&program, opts);\n         return;\n     }\n-    let data_path = &args[1];\n-    let city = &args[2];\n+    let data_path = &matches.free[0];\n+    let city: &str = &matches.free[1];\n \n     // Do stuff with information\n }\n@@ -1680,8 +1681,8 @@ fn main() {\n         return;\n     }\n \n-    let data_path = &args[1];\n-    let city: &str = &args[2];\n+    let data_path = &matches.free[0];\n+    let city: &str = &matches.free[1];\n \n     let file = File::open(data_path).unwrap();\n     let mut rdr = csv::Reader::from_reader(file);\n@@ -1792,13 +1793,15 @@ fn main() {\n         Ok(m)  => { m }\n         Err(e) => { panic!(e.to_string()) }\n     };\n+\n     if matches.opt_present(\"h\") {\n         print_usage(&program, opts);\n         return;\n     }\n \n-    let data_path = &args[1];\n-    let city = &args[2];\n+    let data_path = &matches.free[0];\n+    let city: &str = &matches.free[1];\n+\n     for pop in search(data_path, city) {\n         println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n     }\n@@ -1876,14 +1879,14 @@ when calling `search`:\n \n ```rust,ignore\n ...\n-match search(&data_file, &city) {\n-    Ok(pops) => {\n-        for pop in pops {\n-            println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n+    match search(data_path, city) {\n+        Ok(pops) => {\n+            for pop in pops {\n+                println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n+            }\n         }\n+        Err(err) => println!(\"{}\", err)\n     }\n-    Err(err) => println!(\"{}\", err)\n-}\n ...\n ```\n \n@@ -1914,43 +1917,37 @@ fn print_usage(program: &str, opts: Options) {\n     println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <city>\", program)));\n }\n ```\n-The next part is going to be only a little harder:\n+Of course we need to adapt the argument handling code:\n \n ```rust,ignore\n ...\n-let mut opts = Options::new();\n-opts.optopt(\"f\", \"file\", \"Choose an input file, instead of using STDIN.\", \"NAME\");\n-opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n-...\n-let file = matches.opt_str(\"f\");\n-let data_file = &file.as_ref().map(Path::new);\n-\n-let city = if !matches.free.is_empty() {\n-    &matches.free[0]\n-} else {\n-    print_usage(&program, opts);\n-    return;\n-};\n-\n-match search(data_file, city) {\n-    Ok(pops) => {\n-        for pop in pops {\n-            println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n+    let mut opts = Options::new();\n+    opts.optopt(\"f\", \"file\", \"Choose an input file, instead of using STDIN.\", \"NAME\");\n+    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n+    ...\n+    let data_path = matches.opt_str(\"f\");\n+\n+    let city = if !matches.free.is_empty() {\n+        &matches.free[0]\n+    } else {\n+        print_usage(&program, opts);\n+        return;\n+    };\n+\n+    match search(&data_path, city) {\n+        Ok(pops) => {\n+            for pop in pops {\n+                println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n+            }\n         }\n+        Err(err) => println!(\"{}\", err)\n     }\n-    Err(err) => println!(\"{}\", err)\n-}\n ...\n ```\n \n-In this piece of code, we take `file` (which has the type\n-`Option<String>`), and convert it to a type that `search` can use, in\n-this case, `&Option<AsRef<Path>>`. To do this, we take a reference of\n-file, and map `Path::new` onto it. In this case, `as_ref()` converts\n-the `Option<String>` into an `Option<&str>`, and from there, we can\n-execute `Path::new` to the content of the optional, and return the\n-optional of the new value. Once we have that, it is a simple matter of\n-getting the `city` argument and executing `search`.\n+We've made the user experience a bit nicer by showing the usage message,\n+instead of a panic from an out-of-bounds index, when `city`, the\n+remaining free argument, is not present.\n \n Modifying `search` is slightly trickier. The `csv` crate can build a\n parser out of\n@@ -2000,6 +1997,8 @@ enum CliError {\n And now for impls on `Display` and `Error`:\n \n ```rust,ignore\n+use std::fmt;\n+\n impl fmt::Display for CliError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -2020,13 +2019,13 @@ impl Error for CliError {\n         }\n     }\n \n-    fn cause(&self) -> Option<&error::Error> {\n-        match *self {            \n+    fn cause(&self) -> Option<&Error> {\n+        match *self {\n             CliError::Io(ref err) => Some(err),\n-            CliError::Parse(ref err) => Some(err),\n-            // Our custom error doesn't have an underlying cause, but we could\n-            // modify it so that it does.\n-            CliError::NotFound() => None,\n+            CliError::Csv(ref err) => Some(err),\n+            // Our custom error doesn't have an underlying cause,\n+            // but we could modify it so that it does.\n+            CliError::NotFound => None,\n         }\n     }\n }\n@@ -2122,24 +2121,27 @@ string and add a flag to the Option variable. Once we've done that, Getopts does\n \n ```rust,ignore\n ...\n-let mut opts = Options::new();\n-opts.optopt(\"f\", \"file\", \"Choose an input file, instead of using STDIN.\", \"NAME\");\n-opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n-opts.optflag(\"q\", \"quiet\", \"Silences errors and warnings.\");\n+    let mut opts = Options::new();\n+    opts.optopt(\"f\", \"file\", \"Choose an input file, instead of using STDIN.\", \"NAME\");\n+    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n+    opts.optflag(\"q\", \"quiet\", \"Silences errors and warnings.\");\n ...\n ```\n \n Now we only need to implement our \u201cquiet\u201d functionality. This requires us to\n tweak the case analysis in `main`:\n \n ```rust,ignore\n-match search(&args.arg_data_path, &args.arg_city) {\n-    Err(CliError::NotFound) if args.flag_quiet => process::exit(1),\n-    Err(err) => panic!(\"{}\", err),\n-    Ok(pops) => for pop in pops {\n-        println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n+use std::process;\n+...\n+    match search(&data_path, city) {\n+        Err(CliError::NotFound) if matches.opt_present(\"q\") => process::exit(1),\n+        Err(err) => panic!(\"{}\", err),\n+        Ok(pops) => for pop in pops {\n+            println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n+        }\n     }\n-}\n+...\n ```\n \n Certainly, we don't want to be quiet if there was an IO error or if the data"}, {"sha": "c2eafa1b90f12331477052a6fbf7be0cdbf8217b", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -52,7 +52,7 @@ fn test_from_utf8() {\n                String::from(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n     let xs = b\"hello\\xFF\".to_vec();\n-    let err = String::from_utf8(xs).err().unwrap();\n+    let err = String::from_utf8(xs).unwrap_err();\n     assert_eq!(err.into_bytes(), b\"hello\\xff\".to_vec());\n }\n "}, {"sha": "940d7e911ff3c87b627554dcbb753c6225a92278", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -735,7 +735,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             infer::Reborrow(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0312,\n-                    \"lifetime of reference outlines \\\n+                    \"lifetime of reference outlives \\\n                      lifetime of borrowed content...\");\n                 self.tcx.note_and_explain_region(&mut err,\n                     \"...the reference is valid for \","}, {"sha": "8d9b88e899be26974252f228d82dc0eac5be83d2", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -653,6 +653,101 @@ You can find more information about borrowing in the rust-book:\n http://doc.rust-lang.org/stable/book/references-and-borrowing.html\n \"##,\n \n+E0509: r##\"\n+This error occurs when an attempt is made to move out of a value whose type\n+implements the `Drop` trait.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+struct FancyNum {\n+    num: usize\n+}\n+\n+struct DropStruct {\n+    fancy: FancyNum\n+}\n+\n+impl Drop for DropStruct {\n+    fn drop(&mut self) {\n+        // Destruct DropStruct, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n+    let fancy_field = drop_struct.fancy; // Error E0509\n+    println!(\"Fancy: {}\", fancy_field.num);\n+    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n+}\n+```\n+\n+Here, we tried to move a field out of a struct of type `DropStruct` which\n+implements the `Drop` trait. However, a struct cannot be dropped if one or\n+more of its fields have been moved.\n+\n+Structs implementing the `Drop` trait have an implicit destructor that gets\n+called when they go out of scope. This destructor may use the fields of the\n+struct, so moving out of the struct could make it impossible to run the\n+destructor. Therefore, we must think of all values whose type implements the\n+`Drop` trait as single units whose fields cannot be moved.\n+\n+This error can be fixed by creating a reference to the fields of a struct,\n+enum, or tuple using the `ref` keyword:\n+\n+```\n+struct FancyNum {\n+    num: usize\n+}\n+\n+struct DropStruct {\n+    fancy: FancyNum\n+}\n+\n+impl Drop for DropStruct {\n+    fn drop(&mut self) {\n+        // Destruct DropStruct, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n+    let ref fancy_field = drop_struct.fancy; // No more errors!\n+    println!(\"Fancy: {}\", fancy_field.num);\n+    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n+}\n+```\n+\n+Note that this technique can also be used in the arms of a match expression:\n+\n+```\n+struct FancyNum {\n+    num: usize\n+}\n+\n+enum DropEnum {\n+    Fancy(FancyNum)\n+}\n+\n+impl Drop for DropEnum {\n+    fn drop(&mut self) {\n+        // Destruct DropEnum, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    // Creates and enum of type `DropEnum`, which implements `Drop`\n+    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\n+    match drop_enum {\n+        // Creates a reference to the inside of `DropEnum::Fancy`\n+        DropEnum::Fancy(ref fancy_field) => // No error!\n+            println!(\"It was fancy-- {}!\", fancy_field.num),\n+    }\n+    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\n+}\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n@@ -664,6 +759,5 @@ register_diagnostics! {\n     E0504, // cannot move `..` into closure because it is borrowed\n     E0505, // cannot move out of `..` because it is borrowed\n     E0508, // cannot move out of type `..`, a non-copy fixed-size array\n-    E0509, // cannot move out of type `..`, which defines the `Drop` trait\n     E0524, // two closures require unique access to `..` at the same time\n }"}, {"sha": "351486220528952eae1c86f36257182369671e96", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 86, "deletions": 4, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -497,6 +497,91 @@ impl Bar {\n ```\n \"##,\n \n+E0408: r##\"\n+An \"or\" pattern was used where the variable bindings are not consistently bound\n+across patterns.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+match x {\n+    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is\n+                                      //        not bound in pattern #2\n+    _ => ()\n+}\n+```\n+\n+Here, `y` is bound to the contents of the `Some` and can be used within the\n+block corresponding to the match arm. However, in case `x` is `None`, we have\n+not specified what `y` is, and the block will use a nonexistent variable.\n+\n+To fix this error, either split into multiple match arms:\n+\n+```\n+let x = Some(1);\n+match x {\n+    Some(y) => { /* use y */ }\n+    None => { /* ... */ }\n+}\n+```\n+\n+or, bind the variable to a field of the same type in all sub-patterns of the\n+or pattern:\n+\n+```\n+let x = (0, 2);\n+match x {\n+    (0, y) | (y, 0) => { /* use y */}\n+    _ => {}\n+}\n+```\n+\n+In this example, if `x` matches the pattern `(0, _)`, the second field is set\n+to `y`. If it matches `(_, 0)`, the first field is set to `y`; so in all\n+cases `y` is set to some value.\n+\"##,\n+\n+E0409: r##\"\n+An \"or\" pattern was used where the variable bindings are not consistently bound\n+across patterns.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+let x = (0, 2);\n+match x {\n+    (0, ref y) | (y, 0) => { /* use y */} // error: variable `y` is bound with\n+                                          //        different mode in pattern #2\n+                                          //        than in pattern #1\n+    _ => ()\n+}\n+```\n+\n+Here, `y` is bound by-value in one case and by-reference in the other.\n+\n+To fix this error, just use the same mode in both cases.\n+Generally using `ref` or `ref mut` where not already used will fix this:\n+\n+```ignore\n+let x = (0, 2);\n+match x {\n+    (0, ref y) | (ref y, 0) => { /* use y */}\n+    _ => ()\n+}\n+```\n+\n+Alternatively, split the pattern:\n+\n+```\n+let x = (0, 2);\n+match x {\n+    (y, 0) => { /* use y */ }\n+    (0, ref y) => { /* use y */}\n+    _ => ()\n+}\n+```\n+\"##,\n+\n E0411: r##\"\n The `Self` keyword was used outside an impl or a trait. Erroneous code example:\n \n@@ -1145,10 +1230,7 @@ register_diagnostics! {\n //  E0258,\n     E0402, // cannot use an outer type parameter in this context\n     E0406, // undeclared associated type\n-    E0408, // variable from pattern #1 is not bound in pattern #\n-    E0409, // variable is bound with different mode in pattern # than in\n-           // pattern #1\n-    E0410, // variable from pattern is not bound in pattern 1\n+//  E0410, merged into 408\n     E0418, // is not an enum variant, struct or const\n     E0420, // is not an associated const\n     E0421, // unresolved associated const"}, {"sha": "e3c2a9300baf83beb1ade0215b497dcf950a4555", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -126,12 +126,10 @@ enum ResolutionError<'a> {\n     TypeNotMemberOfTrait(Name, &'a str),\n     /// error E0438: const is not a member of trait\n     ConstNotMemberOfTrait(Name, &'a str),\n-    /// error E0408: variable `{}` from pattern #1 is not bound in pattern\n-    VariableNotBoundInPattern(Name, usize),\n+    /// error E0408: variable `{}` from pattern #{} is not bound in pattern #{}\n+    VariableNotBoundInPattern(Name, usize, usize),\n     /// error E0409: variable is bound with different mode in pattern #{} than in pattern #1\n     VariableBoundWithDifferentMode(Name, usize),\n-    /// error E0410: variable from pattern is not bound in pattern #1\n-    VariableNotBoundInParentPattern(Name, usize),\n     /// error E0411: use of `Self` outside of an impl or trait\n     SelfUsedOutsideImplOrTrait,\n     /// error E0412: use of undeclared\n@@ -272,13 +270,14 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                              const_,\n                              trait_)\n         }\n-        ResolutionError::VariableNotBoundInPattern(variable_name, pattern_number) => {\n+        ResolutionError::VariableNotBoundInPattern(variable_name, from, to) => {\n             struct_span_err!(resolver.session,\n                              span,\n                              E0408,\n-                             \"variable `{}` from pattern #1 is not bound in pattern #{}\",\n+                             \"variable `{}` from pattern #{} is not bound in pattern #{}\",\n                              variable_name,\n-                             pattern_number)\n+                             from,\n+                             to)\n         }\n         ResolutionError::VariableBoundWithDifferentMode(variable_name, pattern_number) => {\n             struct_span_err!(resolver.session,\n@@ -289,14 +288,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                              variable_name,\n                              pattern_number)\n         }\n-        ResolutionError::VariableNotBoundInParentPattern(variable_name, pattern_number) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0410,\n-                             \"variable `{}` from pattern #{} is not bound in pattern #1\",\n-                             variable_name,\n-                             pattern_number)\n-        }\n         ResolutionError::SelfUsedOutsideImplOrTrait => {\n             struct_span_err!(resolver.session,\n                              span,\n@@ -2038,7 +2029,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         resolve_error(self,\n                                       p.span,\n-                                      ResolutionError::VariableNotBoundInPattern(key, i + 1));\n+                                      ResolutionError::VariableNotBoundInPattern(key, 1, i + 1));\n                     }\n                     Some(binding_i) => {\n                         if binding_0.binding_mode != binding_i.binding_mode {\n@@ -2055,7 +2046,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if !map_0.contains_key(&key) {\n                     resolve_error(self,\n                                   binding.span,\n-                                  ResolutionError::VariableNotBoundInParentPattern(key, i + 1));\n+                                  ResolutionError::VariableNotBoundInPattern(key, i + 1, 1));\n                 }\n             }\n         }"}, {"sha": "ac658af4006b1fe089bd8de4d5f701af12a81214", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 51, "deletions": 56, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -10,25 +10,20 @@\n \n use std::io::Write;\n \n-use rustc::hir::def_id::{DefId, DefIndex};\n-use syntax::codemap::Span;\n-\n-use super::data::*;\n+use super::external_data::*;\n use super::dump::Dump;\n-use super::span_utils::SpanUtils;\n \n-pub struct CsvDumper<'tcx, 'b, W: 'b> {\n-    output: &'b mut W,\n-    span: SpanUtils<'tcx>\n+pub struct CsvDumper<'b, W: 'b> {\n+    output: &'b mut W\n }\n \n-impl<'a, 'b, W: Write> CsvDumper<'a, 'b, W> {\n-    pub fn new(writer: &'b mut W, span: SpanUtils<'a>) -> CsvDumper<'a, 'b, W> {\n-        CsvDumper { output: writer, span: span }\n+impl<'b, W: Write> CsvDumper<'b, W> {\n+    pub fn new(writer: &'b mut W) -> CsvDumper<'b, W> {\n+        CsvDumper { output: writer }\n     }\n \n-    fn record(&mut self, kind: &str, span: Span, values: String) {\n-        let span_str = self.span.extent_str(span);\n+    fn record(&mut self, kind: &str, span: SpanData, values: String) {\n+        let span_str = span_extent_str(span);\n         if let Err(_) = write!(self.output, \"{},{}{}\\n\", kind, span_str, values) {\n             error!(\"Error writing output\");\n         }\n@@ -41,7 +36,7 @@ impl<'a, 'b, W: Write> CsvDumper<'a, 'b, W> {\n     }\n }\n \n-impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n+impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     fn crate_prelude(&mut self, data: CratePreludeData) {\n         let values = make_values_str(&[\n             (\"name\", &data.crate_name),\n@@ -65,8 +60,8 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn enum_data(&mut self, data: EnumData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n@@ -78,9 +73,9 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn extern_crate(&mut self, data: ExternCrateData) {\n-        let id = data.id.to_string();\n+        let id = data.id.index.as_u32().to_string();\n         let crate_num = data.crate_num.to_string();\n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"name\", &data.name),\n@@ -96,12 +91,12 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         let self_ref = data.self_ref.unwrap_or(null_def_id());\n         let trait_ref = data.trait_ref.unwrap_or(null_def_id());\n \n-        let id = data.id.to_string();\n+        let id = data.id.index.as_u32().to_string();\n         let ref_id = self_ref.index.as_usize().to_string();\n         let ref_id_crate = self_ref.krate.to_string();\n         let trait_id = trait_ref.index.as_usize().to_string();\n         let trait_id_crate = trait_ref.krate.to_string();\n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"refid\", &ref_id),\n@@ -117,8 +112,8 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     fn inheritance(&mut self, data: InheritanceData) {\n        let base_id = data.base_id.index.as_usize().to_string();\n        let base_crate = data.base_id.krate.to_string();\n-       let deriv_id = data.deriv_id.to_string();\n-       let deriv_crate = 0.to_string();\n+       let deriv_id = data.deriv_id.index.as_u32().to_string();\n+       let deriv_crate = data.deriv_id.krate.to_string();\n        let values = make_values_str(&[\n            (\"base\", &base_id),\n            (\"basecrate\", &base_crate),\n@@ -135,8 +130,8 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n             None => (String::new(), String::new())\n         };\n \n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n@@ -151,7 +146,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     fn function_ref(&mut self, data: FunctionRefData) {\n         let ref_id = data.ref_id.index.as_usize().to_string();\n         let ref_crate = data.ref_id.krate.to_string();\n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n             (\"refidcrate\", &ref_crate),\n@@ -166,7 +161,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         let ref_id = data.ref_id.index.as_usize().to_string();\n         let ref_crate = data.ref_id.krate.to_string();\n         let qualname = String::new();\n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n             (\"refidcrate\", &ref_crate),\n@@ -178,8 +173,8 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn method(&mut self, data: MethodData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n@@ -199,7 +194,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n \n         let def_id = ref_id.index.as_usize().to_string();\n         let def_crate = ref_id.krate.to_string();\n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"refid\", &def_id),\n             (\"refidcrate\", &def_crate),\n@@ -221,7 +216,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn macro_use(&mut self, data: MacroUseData) {\n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"callee_name\", &data.name),\n             (\"qualname\", &data.qualname),\n@@ -232,8 +227,8 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn mod_data(&mut self, data: ModData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n@@ -250,7 +245,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n             None => (0.to_string(), 0.to_string())\n         };\n \n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n             (\"refidcrate\", &ref_crate),\n@@ -262,9 +257,9 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn struct_data(&mut self, data: StructData) {\n-        let id = data.id.to_string();\n-        let ctor_id = data.ctor_id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let ctor_id = data.ctor_id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"ctor_id\", &ctor_id),\n@@ -277,8 +272,8 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn struct_variant(&mut self, data: StructVariantData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"ctor_id\", &id),\n@@ -292,8 +287,8 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn trait_data(&mut self, data: TraitData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n@@ -305,8 +300,8 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn tuple_variant(&mut self, data: TupleVariantData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"name\", &data.name),\n@@ -325,7 +320,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n             None => (0.to_string(), 0.to_string())\n         };\n \n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n             (\"refidcrate\", &ref_crate),\n@@ -337,7 +332,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn typedef(&mut self, data: TypedefData) {\n-        let id = data.id.to_string();\n+        let id = data.id.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n@@ -350,10 +345,10 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     fn use_data(&mut self, data: UseData) {\n         let mod_id = data.mod_id.unwrap_or(null_def_id());\n \n-        let id = data.id.to_string();\n+        let id = data.id.index.as_u32().to_string();\n         let ref_id = mod_id.index.as_usize().to_string();\n         let ref_crate = mod_id.krate.to_string();\n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"refid\", &ref_id),\n@@ -368,8 +363,8 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     fn use_glob(&mut self, data: UseGlobData) {\n         let names = data.names.join(\", \");\n \n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"value\", &names),\n@@ -380,8 +375,8 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn variable(&mut self, data: VariableData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"name\", &data.name),\n@@ -397,7 +392,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     fn variable_ref(&mut self, data: VariableRefData) {\n         let ref_id = data.ref_id.index.as_usize().to_string();\n         let ref_crate = data.ref_id.krate.to_string();\n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n             (\"refidcrate\", &ref_crate),\n@@ -431,9 +426,9 @@ fn make_values_str(pairs: &[(&'static str, &str)]) -> String {\n     })\n }\n \n-fn null_def_id() -> DefId {\n-    DefId {\n-        krate: 0,\n-        index: DefIndex::new(0),\n-    }\n+fn span_extent_str(span: SpanData) -> String {\n+    format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{}\\\n+             file_line_end,{},file_col_end,{},byte_end,{}\",\n+             span.file_name, span.line_start, span.column_start, span.byte_start,\n+             span.line_end, span.column_end, span.byte_end)\n }"}, {"sha": "19f9ba95b35d618082b932e6edb9273fa146be88", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 1, "deletions": 87, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -14,39 +14,8 @@\n //! retrieve the data from a crate.\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty;\n use syntax::ast::{CrateNum, NodeId};\n-use syntax::codemap::{Span, CodeMap};\n-\n-#[derive(Debug, Clone, RustcEncodable)]\n-pub struct SpanData {\n-    file_name: String,\n-    byte_start: u32,\n-    byte_end: u32,\n-    /// 1-based.\n-    line_start: usize,\n-    line_end: usize,\n-    /// 1-based, character offset.\n-    column_start: usize,\n-    column_end: usize,\n-}\n-\n-impl SpanData {\n-    pub fn from_span(span: Span, cm: &CodeMap) -> SpanData {\n-        let start = cm.lookup_char_pos(span.lo);\n-        let end = cm.lookup_char_pos(span.hi);\n-\n-        SpanData {\n-            file_name: start.file.name.clone(),\n-            byte_start: span.lo.0,\n-            byte_end: span.hi.0,\n-            line_start: start.line,\n-            line_end: end.line,\n-            column_start: start.col.0 + 1,\n-            column_end: end.col.0 + 1,\n-        }\n-    }\n-}\n+use syntax::codemap::Span;\n \n pub struct CrateData {\n     pub name: String,\n@@ -357,58 +326,3 @@ pub struct VariableRefData {\n     pub scope: NodeId,\n     pub ref_id: DefId,\n }\n-\n-// Emitted ids are used to cross-reference items across crates. DefIds and\n-// NodeIds do not usually correspond in any way. The strategy is to use the\n-// index from the DefId as a crate-local id. However, within a crate, DefId\n-// indices and NodeIds can overlap. So, we must adjust the NodeIds. If an\n-// item can be identified by a DefId as well as a NodeId, then we use the\n-// DefId index as the id. If it can't, then we have to use the NodeId, but\n-// need to adjust it so it will not clash with any possible DefId index.\n-pub fn normalize_node_id<'a>(tcx: &ty::TyCtxt<'a>, id: NodeId) -> usize {\n-    match tcx.map.opt_local_def_id(id) {\n-        Some(id) => id.index.as_usize(),\n-        None => id as usize + tcx.map.num_local_def_ids()\n-    }\n-}\n-\n-// Macro to implement a normalize() function (see below for usage)\n-macro_rules! impl_normalize {\n-    ($($t:ty => $($field:ident),*);*) => {\n-        $(\n-            impl $t {\n-                pub fn normalize<'a>(mut self, tcx: &ty::TyCtxt<'a>) -> $t {\n-                    $(\n-                        self.$field = normalize_node_id(tcx, self.$field) as u32;\n-                    )*\n-                    self\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-impl_normalize! {\n-    EnumData => id, scope;\n-    ExternCrateData => id, scope;\n-    FunctionCallData => scope;\n-    FunctionData => id, scope;\n-    FunctionRefData => scope;\n-    ImplData => id, scope;\n-    InheritanceData => deriv_id;\n-    MacroUseData => scope;\n-    MethodCallData => scope;\n-    MethodData => id, scope;\n-    ModData => id, scope;\n-    ModRefData => scope;\n-    StructData => ctor_id, id, scope;\n-    StructVariantData => id, scope;\n-    TupleVariantData => id, scope;\n-    TraitData => id, scope;\n-    TypedefData => id;\n-    TypeRefData => scope;\n-    UseData => id, scope;\n-    UseGlobData => id, scope;\n-    VariableData => id;\n-    VariableRefData => scope\n-}"}, {"sha": "adbf1e0a35ec1be9d82ccf87caa18e8369303a28", "filename": "src/librustc_save_analysis/dump.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::data::*;\n+use super::external_data::*;\n \n pub trait Dump {\n     fn crate_prelude(&mut self, CratePreludeData) {}"}, {"sha": "7a411969363e9e40f95ed016f0d20e8e18363fb3", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 54, "deletions": 57, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -45,6 +45,7 @@ use syntax::ptr::P;\n use super::{escape, generated_code, SaveContext, PathCollector};\n use super::data::*;\n use super::dump::Dump;\n+use super::external_data::Lower;\n use super::span_utils::SpanUtils;\n use super::recorder;\n \n@@ -133,7 +134,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             span: krate.span,\n         };\n \n-        self.dumper.crate_prelude(data);\n+        self.dumper.crate_prelude(data.lower(self.tcx));\n     }\n \n     // Return all non-empty prefixes of a path.\n@@ -203,7 +204,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname,\n                 scope: self.cur_scope,\n                 ref_id: None\n-            }.normalize(&self.tcx));\n+            }.lower(self.tcx));\n         }\n     }\n \n@@ -228,7 +229,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname,\n                 scope: self.cur_scope,\n                 ref_id: None\n-            }.normalize(&self.tcx));\n+            }.lower(self.tcx));\n         }\n     }\n \n@@ -249,7 +250,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             span: *span,\n             qualname: qualname.to_owned(),\n             scope: 0\n-        });\n+        }.lower(self.tcx));\n \n         // write the other sub-paths\n         if len <= 2 {\n@@ -262,7 +263,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname.to_owned(),\n                 scope: self.cur_scope,\n                 ref_id: None\n-            }.normalize(&self.tcx));\n+            }.lower(self.tcx));\n         }\n     }\n \n@@ -304,7 +305,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     ref_id: Some(def_id),\n                     scope: scope,\n                     qualname: String::new()\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n             Def::Struct(..) |\n             Def::Enum(..) |\n@@ -316,7 +317,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     ref_id: Some(def_id),\n                     scope: scope,\n                     qualname: String::new()\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n             Def::Static(_, _) |\n             Def::Const(_) |\n@@ -329,14 +330,14 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     ref_id: def_id,\n                     scope: scope,\n                     name: String::new()\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n             Def::Fn(..) => {\n                 self.dumper.function_ref(FunctionRefData {\n                     span: sub_span.expect(\"No span found for fn ref\"),\n                     ref_id: def_id,\n                     scope: scope\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n             Def::SelfTy(..) |\n             Def::Label(_) |\n@@ -371,7 +372,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         type_value: typ,\n                         value: String::new(),\n                         scope: 0\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n             }\n         }\n@@ -389,7 +390,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n             if body.is_some() {\n                 if !self.span.filter_generated(Some(method_data.span), span) {\n-                    self.dumper.function(method_data.clone().normalize(&self.tcx));\n+                    self.dumper.function(method_data.clone().lower(self.tcx));\n                 }\n                 self.process_formals(&sig.decl.inputs, &method_data.qualname);\n             } else {\n@@ -399,7 +400,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         span: method_data.span,\n                         scope: method_data.scope,\n                         qualname: method_data.qualname.clone(),\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n             }\n             self.process_generic_params(&sig.generics, span, &method_data.qualname, id);\n@@ -424,7 +425,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref, self.cur_scope);\n         if let Some(trait_ref_data) = trait_ref_data {\n             if !self.span.filter_generated(Some(trait_ref_data.span), trait_ref.path.span) {\n-                self.dumper.type_ref(trait_ref_data.normalize(&self.tcx));\n+                self.dumper.type_ref(trait_ref_data.lower(self.tcx));\n             }\n \n             visit::walk_path(self, &trait_ref.path);\n@@ -435,9 +436,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(mut field_data) = field_data {\n             if !self.span.filter_generated(Some(field_data.span), field.span) {\n-                field_data.scope = normalize_node_id(&self.tcx, field_data.scope) as u32;\n                 field_data.value = String::new();\n-                self.dumper.variable(field_data.normalize(&self.tcx));\n+                self.dumper.variable(field_data.lower(self.tcx));\n             }\n         }\n     }\n@@ -466,7 +466,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     id: param.id,\n                     qualname: name,\n                     value: String::new()\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n         }\n         self.visit_generics(generics);\n@@ -480,7 +480,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(fn_data, FunctionData, item.span);\n             if !self.span.filter_generated(Some(fn_data.span), item.span) {\n-                self.dumper.function(fn_data.clone().normalize(&self.tcx));\n+                self.dumper.function(fn_data.clone().lower(self.tcx));\n             }\n \n             self.process_formals(&decl.inputs, &fn_data.qualname);\n@@ -502,9 +502,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(var_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(var_data, VariableData, item.span);\n             if !self.span.filter_generated(Some(var_data.span), item.span) {\n-                let mut var_data = var_data;\n-                var_data.scope = normalize_node_id(&self.tcx, var_data.scope) as u32;\n-                self.dumper.variable(var_data.normalize(&self.tcx));\n+                self.dumper.variable(var_data.lower(self.tcx));\n             }\n         }\n         self.visit_ty(&typ);\n@@ -529,8 +527,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname,\n                 value: self.span.snippet(expr.span),\n                 type_value: ty_to_string(&typ),\n-                scope: normalize_node_id(&self.tcx, self.cur_scope) as u32\n-            }.normalize(&self.tcx));\n+                scope: self.cur_scope\n+            }.lower(self.tcx));\n         }\n \n         // walk type and init value\n@@ -554,7 +552,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n                 value: val\n-            }.normalize(&self.tcx));\n+            }.lower(self.tcx));\n         }\n \n \n@@ -577,9 +575,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Some(data) => data,\n         };\n         down_cast_data!(enum_data, EnumData, item.span);\n-        let normalized = enum_data.clone().normalize(&self.tcx);\n-        if !self.span.filter_generated(Some(normalized.span), item.span) {\n-            self.dumper.enum_data(normalized);\n+        if !self.span.filter_generated(Some(enum_data.span), item.span) {\n+            self.dumper.enum_data(enum_data.clone().lower(self.tcx));\n         }\n \n         for variant in &enum_definition.variants {\n@@ -600,7 +597,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n                             scope: enum_data.scope\n-                        }.normalize(&self.tcx));\n+                        }.lower(self.tcx));\n                     }\n                 }\n                 _ => {\n@@ -614,7 +611,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n                             scope: enum_data.scope\n-                        }.normalize(&self.tcx));\n+                        }.lower(self.tcx));\n                     }\n                 }\n             }\n@@ -640,12 +637,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if let Some(ref self_ref) = impl_data.self_ref {\n                 has_self_ref = true;\n                 if !self.span.filter_generated(Some(self_ref.span), item.span) {\n-                    self.dumper.type_ref(self_ref.clone().normalize(&self.tcx));\n+                    self.dumper.type_ref(self_ref.clone().lower(self.tcx));\n                 }\n             }\n             if let Some(ref trait_ref_data) = impl_data.trait_ref {\n                 if !self.span.filter_generated(Some(trait_ref_data.span), item.span) {\n-                    self.dumper.type_ref(trait_ref_data.clone().normalize(&self.tcx));\n+                    self.dumper.type_ref(trait_ref_data.clone().lower(self.tcx));\n                 }\n \n                 visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n@@ -658,7 +655,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     scope: impl_data.scope,\n                     trait_ref: impl_data.trait_ref.map(|d| d.ref_id.unwrap()),\n                     self_ref: impl_data.self_ref.map(|d| d.ref_id.unwrap())\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n         }\n         if !has_self_ref {\n@@ -685,7 +682,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n                 value: val\n-            }.normalize(&self.tcx));\n+            }.lower(self.tcx));\n         }\n \n         // super-traits\n@@ -708,7 +705,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         ref_id: Some(id),\n                         scope: self.cur_scope,\n                         qualname: String::new()\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n \n                 if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n@@ -717,7 +714,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         span: sub_span,\n                         base_id: id,\n                         deriv_id: item.id\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n             }\n         }\n@@ -734,7 +731,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, ModData, item.span);\n             if !self.span.filter_generated(Some(mod_data.span), item.span) {\n-                self.dumper.mod_data(mod_data.normalize(&self.tcx));\n+                self.dumper.mod_data(mod_data.lower(self.tcx));\n             }\n         }\n     }\n@@ -765,42 +762,42 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                 ref_id: Some(vrd.ref_id),\n                                 scope: vrd.scope,\n                                 qualname: String::new()\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                         Some(recorder::FnRef) => {\n                             self.dumper.function_ref(FunctionRefData {\n                                 span: vrd.span,\n                                 ref_id: vrd.ref_id,\n                                 scope: vrd.scope\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                         Some(recorder::ModRef) => {\n                             self.dumper.mod_ref( ModRefData {\n                                 span: vrd.span,\n                                 ref_id: Some(vrd.ref_id),\n                                 scope: vrd.scope,\n                                 qualname: String::new()\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                         Some(recorder::VarRef) | None\n-                            => self.dumper.variable_ref(vrd.normalize(&self.tcx))\n+                            => self.dumper.variable_ref(vrd.lower(self.tcx))\n                     }\n                 }\n \n             }\n             Data::TypeRefData(trd) => {\n                 if !self.span.filter_generated(Some(trd.span), path.span) {\n-                    self.dumper.type_ref(trd.normalize(&self.tcx));\n+                    self.dumper.type_ref(trd.lower(self.tcx));\n                 }\n             }\n             Data::MethodCallData(mcd) => {\n                 if !self.span.filter_generated(Some(mcd.span), path.span) {\n-                    self.dumper.method_call(mcd.normalize(&self.tcx));\n+                    self.dumper.method_call(mcd.lower(self.tcx));\n                 }\n             }\n             Data::FunctionCallData(fcd) => {\n                 if !self.span.filter_generated(Some(fcd.span), path.span) {\n-                    self.dumper.function_call(fcd.normalize(&self.tcx));\n+                    self.dumper.function_call(fcd.lower(self.tcx));\n                 }\n             }\n             _ => {\n@@ -842,7 +839,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(struct_lit_data, TypeRefData, ex.span);\n             if !self.span.filter_generated(Some(struct_lit_data.span), ex.span) {\n-                self.dumper.type_ref(struct_lit_data.normalize(&self.tcx));\n+                self.dumper.type_ref(struct_lit_data.lower(self.tcx));\n             }\n \n             let scope = self.save_ctxt.enclosing_scope(ex.id);\n@@ -852,7 +849,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                               .get_field_ref_data(field, variant, scope) {\n \n                     if !self.span.filter_generated(Some(field_data.span), field.ident.span) {\n-                        self.dumper.variable_ref(field_data.normalize(&self.tcx));\n+                        self.dumper.variable_ref(field_data.lower(self.tcx));\n                     }\n                 }\n \n@@ -867,7 +864,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(mcd, MethodCallData, ex.span);\n             if !self.span.filter_generated(Some(mcd.span), ex.span) {\n-                self.dumper.method_call(mcd.normalize(&self.tcx));\n+                self.dumper.method_call(mcd.lower(self.tcx));\n             }\n         }\n \n@@ -892,7 +889,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                 ref_id: f.did,\n                                 scope: self.cur_scope,\n                                 name: String::new()\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                     }\n                     self.visit_pat(&field.pat);\n@@ -931,7 +928,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     value: value,\n                     type_value: typ,\n                     scope: 0\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n         }\n     }\n@@ -961,7 +958,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     span: sub_span,\n                     name: data.name.clone(),\n                     qualname: qualname.clone()\n-                });\n+                }.lower(self.tcx));\n             }\n         }\n         if !self.mac_uses.contains(&data.span) {\n@@ -974,7 +971,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     scope: data.scope,\n                     callee_span: data.callee_span,\n                     imported: data.imported\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n         }\n     }\n@@ -1014,7 +1011,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                                 mod_id: mod_id,\n                                 name: ident.to_string(),\n                                 scope: self.cur_scope\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                         self.write_sub_paths_truncated(path, true);\n                     }\n@@ -1037,7 +1034,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                                 id: item.id,\n                                 names: names,\n                                 scope: self.cur_scope\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                         self.write_sub_paths(path, true);\n                     }\n@@ -1081,7 +1078,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                         location: location,\n                         span: alias_span.expect(\"No span found for extern crate\"),\n                         scope: self.cur_scope,\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n             }\n             Fn(ref decl, _, _, _, ref ty_params, ref body) =>\n@@ -1115,7 +1112,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                         id: item.id,\n                         qualname: qualname.clone(),\n                         value: value\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n \n                 self.visit_ty(&ty);\n@@ -1195,7 +1192,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                             ref_id: Some(id),\n                             scope: self.cur_scope,\n                             qualname: String::new()\n-                        }.normalize(&self.tcx));\n+                        }.lower(self.tcx));\n                     }\n                 }\n \n@@ -1232,7 +1229,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n                     down_cast_data!(field_data, VariableRefData, ex.span);\n                     if !self.span.filter_generated(Some(field_data.span), ex.span) {\n-                        self.dumper.variable_ref(field_data.normalize(&self.tcx));\n+                        self.dumper.variable_ref(field_data.lower(self.tcx));\n                     }\n                 }\n             }\n@@ -1250,7 +1247,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                                 ref_id: def.struct_variant().fields[idx.node].did,\n                                 scope: self.cur_scope,\n                                 name: String::new()\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                     }\n                     ty::TyTuple(_) => {}\n@@ -1343,7 +1340,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                             value: value,\n                             type_value: String::new(),\n                             scope: 0\n-                        }.normalize(&self.tcx));\n+                        }.lower(self.tcx));\n                     }\n                 }\n                 Def::Variant(..) | Def::Enum(..) |"}, {"sha": "db4bd1d6d730821623532854f454183f60b70a33", "filename": "src/librustc_save_analysis/external_data.rs", "status": "added", "additions": 618, "deletions": 0, "changes": 618, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -0,0 +1,618 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc::hir::map::Map;\n+use rustc::ty::TyCtxt;\n+use syntax::ast::{CrateNum, NodeId};\n+use syntax::codemap::{Span, CodeMap};\n+\n+use super::data;\n+\n+// FIXME: this should be pub(crate), but the current snapshot doesn't allow it yet\n+pub trait Lower {\n+    type Target;\n+    fn lower(self, tcx: &TyCtxt) -> Self::Target;\n+}\n+\n+fn make_def_id(id: NodeId, map: &Map) -> DefId {\n+    map.opt_local_def_id(id).unwrap_or(null_def_id())\n+}\n+\n+pub fn null_def_id() -> DefId {\n+    DefId { krate: u32::max_value(), index: DefIndex::from_u32(u32::max_value()) }\n+}\n+\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct SpanData {\n+    pub file_name: String,\n+    pub byte_start: u32,\n+    pub byte_end: u32,\n+    /// 1-based.\n+    pub line_start: usize,\n+    pub line_end: usize,\n+    /// 1-based, character offset.\n+    pub column_start: usize,\n+    pub column_end: usize,\n+}\n+\n+impl SpanData {\n+    pub fn from_span(span: Span, cm: &CodeMap) -> SpanData {\n+        let start = cm.lookup_char_pos(span.lo);\n+        let end = cm.lookup_char_pos(span.hi);\n+\n+        SpanData {\n+            file_name: start.file.name.clone(),\n+            byte_start: span.lo.0,\n+            byte_end: span.hi.0,\n+            line_start: start.line,\n+            line_end: end.line,\n+            column_start: start.col.0 + 1,\n+            column_end: end.col.0 + 1,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct CratePreludeData {\n+    pub crate_name: String,\n+    pub crate_root: String,\n+    pub external_crates: Vec<data::ExternalCrateData>,\n+    pub span: SpanData,\n+}\n+\n+impl Lower for data::CratePreludeData {\n+    type Target = CratePreludeData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> CratePreludeData {\n+        CratePreludeData {\n+            crate_name: self.crate_name,\n+            crate_root: self.crate_root,\n+            external_crates: self.external_crates,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+        }\n+    }\n+}\n+\n+/// Data for enum declarations.\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct EnumData {\n+    pub id: DefId,\n+    pub value: String,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: DefId,\n+}\n+\n+impl Lower for data::EnumData {\n+    type Target = EnumData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> EnumData {\n+        EnumData {\n+            id: make_def_id(self.id, &tcx.map),\n+            value: self.value,\n+            qualname: self.qualname,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+/// Data for extern crates.\n+#[derive(Debug, RustcEncodable)]\n+pub struct ExternCrateData {\n+    pub id: DefId,\n+    pub name: String,\n+    pub crate_num: CrateNum,\n+    pub location: String,\n+    pub span: SpanData,\n+    pub scope: DefId,\n+}\n+\n+impl Lower for data::ExternCrateData {\n+    type Target = ExternCrateData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> ExternCrateData {\n+        ExternCrateData {\n+            id: make_def_id(self.id, &tcx.map),\n+            name: self.name,\n+            crate_num: self.crate_num,\n+            location: self.location,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+/// Data about a function call.\n+#[derive(Debug, RustcEncodable)]\n+pub struct FunctionCallData {\n+    pub span: SpanData,\n+    pub scope: DefId,\n+    pub ref_id: DefId,\n+}\n+\n+impl Lower for data::FunctionCallData {\n+    type Target = FunctionCallData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> FunctionCallData {\n+        FunctionCallData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n+        }\n+    }\n+}\n+\n+/// Data for all kinds of functions and methods.\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct FunctionData {\n+    pub id: DefId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub declaration: Option<DefId>,\n+    pub span: SpanData,\n+    pub scope: DefId,\n+}\n+\n+impl Lower for data::FunctionData {\n+    type Target = FunctionData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> FunctionData {\n+        FunctionData {\n+            id: make_def_id(self.id, &tcx.map),\n+            name: self.name,\n+            qualname: self.qualname,\n+            declaration: self.declaration,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+/// Data about a function call.\n+#[derive(Debug, RustcEncodable)]\n+pub struct FunctionRefData {\n+    pub span: SpanData,\n+    pub scope: DefId,\n+    pub ref_id: DefId,\n+}\n+\n+impl Lower for data::FunctionRefData {\n+    type Target = FunctionRefData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> FunctionRefData {\n+        FunctionRefData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n+        }\n+    }\n+}\n+#[derive(Debug, RustcEncodable)]\n+pub struct ImplData {\n+    pub id: DefId,\n+    pub span: SpanData,\n+    pub scope: DefId,\n+    pub trait_ref: Option<DefId>,\n+    pub self_ref: Option<DefId>,\n+}\n+\n+impl Lower for data::ImplData {\n+    type Target = ImplData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> ImplData {\n+        ImplData {\n+            id: make_def_id(self.id, &tcx.map),\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            trait_ref: self.trait_ref,\n+            self_ref: self.self_ref,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct InheritanceData {\n+    pub span: SpanData,\n+    pub base_id: DefId,\n+    pub deriv_id: DefId\n+}\n+\n+impl Lower for data::InheritanceData {\n+    type Target = InheritanceData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> InheritanceData {\n+        InheritanceData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            base_id: self.base_id,\n+            deriv_id: make_def_id(self.deriv_id, &tcx.map)\n+        }\n+    }\n+}\n+\n+/// Data about a macro declaration.\n+#[derive(Debug, RustcEncodable)]\n+pub struct MacroData {\n+    pub span: SpanData,\n+    pub name: String,\n+    pub qualname: String,\n+}\n+\n+impl Lower for data::MacroData {\n+    type Target = MacroData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> MacroData {\n+        MacroData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+/// Data about a macro use.\n+#[derive(Debug, RustcEncodable)]\n+pub struct MacroUseData {\n+    pub span: SpanData,\n+    pub name: String,\n+    pub qualname: String,\n+    // Because macro expansion happens before ref-ids are determined,\n+    // we use the callee span to reference the associated macro definition.\n+    pub callee_span: SpanData,\n+    pub scope: DefId,\n+    pub imported: bool,\n+}\n+\n+impl Lower for data::MacroUseData {\n+    type Target = MacroUseData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> MacroUseData {\n+        MacroUseData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n+            qualname: self.qualname,\n+            callee_span: SpanData::from_span(self.callee_span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            imported: self.imported,\n+        }\n+    }\n+}\n+\n+/// Data about a method call.\n+#[derive(Debug, RustcEncodable)]\n+pub struct MethodCallData {\n+    pub span: SpanData,\n+    pub scope: DefId,\n+    pub ref_id: Option<DefId>,\n+    pub decl_id: Option<DefId>,\n+}\n+\n+impl Lower for data::MethodCallData {\n+    type Target = MethodCallData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> MethodCallData {\n+        MethodCallData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n+            decl_id: self.decl_id,\n+        }\n+    }\n+}\n+\n+/// Data for method declarations (methods with a body are treated as functions).\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct MethodData {\n+    pub id: DefId,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: DefId,\n+}\n+\n+impl Lower for data::MethodData {\n+    type Target = MethodData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> MethodData {\n+        MethodData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+/// Data for modules.\n+#[derive(Debug, RustcEncodable)]\n+pub struct ModData {\n+    pub id: DefId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: DefId,\n+    pub filename: String,\n+}\n+\n+impl Lower for data::ModData {\n+    type Target = ModData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> ModData {\n+        ModData {\n+            id: make_def_id(self.id, &tcx.map),\n+            name: self.name,\n+            qualname: self.qualname,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            filename: self.filename,\n+        }\n+    }\n+}\n+\n+/// Data for a reference to a module.\n+#[derive(Debug, RustcEncodable)]\n+pub struct ModRefData {\n+    pub span: SpanData,\n+    pub scope: DefId,\n+    pub ref_id: Option<DefId>,\n+    pub qualname: String\n+}\n+\n+impl Lower for data::ModRefData {\n+    type Target = ModRefData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> ModRefData {\n+        ModRefData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct StructData {\n+    pub span: SpanData,\n+    pub id: DefId,\n+    pub ctor_id: DefId,\n+    pub qualname: String,\n+    pub scope: DefId,\n+    pub value: String\n+}\n+\n+impl Lower for data::StructData {\n+    type Target = StructData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> StructData {\n+        StructData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            id: make_def_id(self.id, &tcx.map),\n+            ctor_id: make_def_id(self.ctor_id, &tcx.map),\n+            qualname: self.qualname,\n+            scope: make_def_id(self.scope, &tcx.map),\n+            value: self.value\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct StructVariantData {\n+    pub span: SpanData,\n+    pub id: DefId,\n+    pub qualname: String,\n+    pub type_value: String,\n+    pub value: String,\n+    pub scope: DefId\n+}\n+\n+impl Lower for data::StructVariantData {\n+    type Target = StructVariantData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> StructVariantData {\n+        StructVariantData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            id: make_def_id(self.id, &tcx.map),\n+            qualname: self.qualname,\n+            type_value: self.type_value,\n+            value: self.value,\n+            scope: make_def_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct TraitData {\n+    pub span: SpanData,\n+    pub id: DefId,\n+    pub qualname: String,\n+    pub scope: DefId,\n+    pub value: String\n+}\n+\n+impl Lower for data::TraitData {\n+    type Target = TraitData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> TraitData {\n+        TraitData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            id: make_def_id(self.id, &tcx.map),\n+            qualname: self.qualname,\n+            scope: make_def_id(self.scope, &tcx.map),\n+            value: self.value,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct TupleVariantData {\n+    pub span: SpanData,\n+    pub id: DefId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub type_value: String,\n+    pub value: String,\n+    pub scope: DefId,\n+}\n+\n+impl Lower for data::TupleVariantData {\n+    type Target = TupleVariantData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> TupleVariantData {\n+        TupleVariantData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            id: make_def_id(self.id, &tcx.map),\n+            name: self.name,\n+            qualname: self.qualname,\n+            type_value: self.type_value,\n+            value: self.value,\n+            scope: make_def_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+/// Data for a typedef.\n+#[derive(Debug, RustcEncodable)]\n+pub struct TypedefData {\n+    pub id: DefId,\n+    pub span: SpanData,\n+    pub qualname: String,\n+    pub value: String,\n+}\n+\n+impl Lower for data::TypedefData {\n+    type Target = TypedefData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> TypedefData {\n+        TypedefData {\n+            id: make_def_id(self.id, &tcx.map),\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            qualname: self.qualname,\n+            value: self.value,\n+        }\n+    }\n+}\n+\n+/// Data for a reference to a type or trait.\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct TypeRefData {\n+    pub span: SpanData,\n+    pub scope: DefId,\n+    pub ref_id: Option<DefId>,\n+    pub qualname: String,\n+}\n+\n+impl Lower for data::TypeRefData {\n+    type Target = TypeRefData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> TypeRefData {\n+        TypeRefData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct UseData {\n+    pub id: DefId,\n+    pub span: SpanData,\n+    pub name: String,\n+    pub mod_id: Option<DefId>,\n+    pub scope: DefId\n+}\n+\n+impl Lower for data::UseData {\n+    type Target = UseData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> UseData {\n+        UseData {\n+            id: make_def_id(self.id, &tcx.map),\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n+            mod_id: self.mod_id,\n+            scope: make_def_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct UseGlobData {\n+    pub id: DefId,\n+    pub span: SpanData,\n+    pub names: Vec<String>,\n+    pub scope: DefId\n+}\n+\n+impl Lower for data::UseGlobData {\n+    type Target = UseGlobData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> UseGlobData {\n+        UseGlobData {\n+            id: make_def_id(self.id, &tcx.map),\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            names: self.names,\n+            scope: make_def_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+/// Data for local and global variables (consts and statics).\n+#[derive(Debug, RustcEncodable)]\n+pub struct VariableData {\n+    pub id: DefId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: DefId,\n+    pub value: String,\n+    pub type_value: String,\n+}\n+\n+impl Lower for data::VariableData {\n+    type Target = VariableData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> VariableData {\n+        VariableData {\n+            id: make_def_id(self.id, &tcx.map),\n+            name: self.name,\n+            qualname: self.qualname,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            value: self.value,\n+            type_value: self.type_value,\n+        }\n+    }\n+}\n+\n+/// Data for the use of some item (e.g., the use of a local variable, which\n+/// will refer to that variables declaration (by ref_id)).\n+#[derive(Debug, RustcEncodable)]\n+pub struct VariableRefData {\n+    pub name: String,\n+    pub span: SpanData,\n+    pub scope: DefId,\n+    pub ref_id: DefId,\n+}\n+\n+impl Lower for data::VariableRefData {\n+    type Target = VariableRefData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> VariableRefData {\n+        VariableRefData {\n+            name: self.name,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n+        }\n+    }\n+}"}, {"sha": "9ad2bcef4ed46601ebfde2496404d18973c093aa", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 8, "deletions": 577, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -11,29 +11,25 @@\n use std::io::Write;\n \n use rustc_serialize::json::as_json;\n-use syntax::codemap::CodeMap;\n \n-use syntax::ast::CrateNum;\n-\n-use super::data::{self, SpanData};\n+use super::external_data::*;\n use super::dump::Dump;\n \n-pub struct JsonDumper<'a, 'b, W: Write + 'b> {\n+pub struct JsonDumper<'b, W: Write + 'b> {\n     output: &'b mut W,\n-    codemap: &'a CodeMap,\n     first: bool,\n }\n \n-impl<'a, 'b, W: Write> JsonDumper<'a, 'b, W> {\n-    pub fn new(writer: &'b mut W, codemap: &'a CodeMap) -> JsonDumper<'a, 'b, W> {\n+impl<'b, W: Write> JsonDumper<'b, W> {\n+    pub fn new(writer: &'b mut W) -> JsonDumper<'b, W> {\n         if let Err(_) = write!(writer, \"[\") {\n             error!(\"Error writing output\");\n         }\n-        JsonDumper { output: writer, codemap:codemap, first: true }\n+        JsonDumper { output: writer, first: true }\n     }\n }\n \n-impl<'a, 'b, W: Write> Drop for JsonDumper<'a, 'b, W> {\n+impl<'b, W: Write> Drop for JsonDumper<'b, W> {\n     fn drop(&mut self) {\n         if let Err(_) = write!(self.output, \"]\") {\n             error!(\"Error writing output\");\n@@ -43,23 +39,22 @@ impl<'a, 'b, W: Write> Drop for JsonDumper<'a, 'b, W> {\n \n macro_rules! impl_fn {\n     ($fn_name: ident, $data_type: ident) => {\n-        fn $fn_name(&mut self, data: data::$data_type) {\n+        fn $fn_name(&mut self, data: $data_type) {\n             if self.first {\n                 self.first = false;\n             } else {\n                 if let Err(_) = write!(self.output, \",\") {\n                     error!(\"Error writing output\");\n                 }\n             }\n-            let data = data.lower(self.codemap);\n             if let Err(_) = write!(self.output, \"{}\", as_json(&data)) {\n                 error!(\"Error writing output '{}'\", as_json(&data));\n             }\n         }\n     }\n }\n \n-impl<'a, 'b, W: Write + 'b> Dump for JsonDumper<'a, 'b, W> {\n+impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n     impl_fn!(crate_prelude, CratePreludeData);\n     impl_fn!(enum_data, EnumData);\n     impl_fn!(extern_crate, ExternCrateData);\n@@ -85,567 +80,3 @@ impl<'a, 'b, W: Write + 'b> Dump for JsonDumper<'a, 'b, W> {\n     impl_fn!(variable, VariableData);\n     impl_fn!(variable_ref, VariableRefData);\n }\n-\n-trait Lower {\n-    type Target;\n-    fn lower(self, cm: &CodeMap) -> Self::Target;\n-}\n-\n-pub type Id = u32;\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct CratePreludeData {\n-    pub crate_name: String,\n-    pub crate_root: String,\n-    pub external_crates: Vec<data::ExternalCrateData>,\n-    pub span: SpanData,\n-}\n-\n-impl Lower for data::CratePreludeData {\n-    type Target = CratePreludeData;\n-\n-    fn lower(self, cm: &CodeMap) -> CratePreludeData {\n-        CratePreludeData {\n-            crate_name: self.crate_name,\n-            crate_root: self.crate_root,\n-            external_crates: self.external_crates,\n-            span: SpanData::from_span(self.span, cm),\n-        }\n-    }\n-}\n-\n-/// Data for enum declarations.\n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct EnumData {\n-    pub id: Id,\n-    pub value: String,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-}\n-\n-impl Lower for data::EnumData {\n-    type Target = EnumData;\n-\n-    fn lower(self, cm: &CodeMap) -> EnumData {\n-        EnumData {\n-            id: self.id,\n-            value: self.value,\n-            qualname: self.qualname,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-/// Data for extern crates.\n-#[derive(Debug, RustcEncodable)]\n-pub struct ExternCrateData {\n-    pub id: Id,\n-    pub name: String,\n-    pub crate_num: CrateNum,\n-    pub location: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-}\n-\n-impl Lower for data::ExternCrateData {\n-    type Target = ExternCrateData;\n-\n-    fn lower(self, cm: &CodeMap) -> ExternCrateData {\n-        ExternCrateData {\n-            id: self.id,\n-            name: self.name,\n-            crate_num: self.crate_num,\n-            location: self.location,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-/// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n-pub struct FunctionCallData {\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Id,\n-}\n-\n-impl Lower for data::FunctionCallData {\n-    type Target = FunctionCallData;\n-\n-    fn lower(self, cm: &CodeMap) -> FunctionCallData {\n-        FunctionCallData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.index.as_u32(),\n-        }\n-    }\n-}\n-\n-/// Data for all kinds of functions and methods.\n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct FunctionData {\n-    pub id: Id,\n-    pub name: String,\n-    pub qualname: String,\n-    pub declaration: Option<Id>,\n-    pub span: SpanData,\n-    pub scope: Id,\n-}\n-\n-impl Lower for data::FunctionData {\n-    type Target = FunctionData;\n-\n-    fn lower(self, cm: &CodeMap) -> FunctionData {\n-        FunctionData {\n-            id: self.id,\n-            name: self.name,\n-            qualname: self.qualname,\n-            declaration: self.declaration.map(|id| id.index.as_u32()),\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-/// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n-pub struct FunctionRefData {\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Id,\n-}\n-\n-impl Lower for data::FunctionRefData {\n-    type Target = FunctionRefData;\n-\n-    fn lower(self, cm: &CodeMap) -> FunctionRefData {\n-        FunctionRefData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.index.as_u32(),\n-        }\n-    }\n-}\n-#[derive(Debug, RustcEncodable)]\n-pub struct ImplData {\n-    pub id: Id,\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub trait_ref: Option<Id>,\n-    pub self_ref: Option<Id>,\n-}\n-\n-impl Lower for data::ImplData {\n-    type Target = ImplData;\n-\n-    fn lower(self, cm: &CodeMap) -> ImplData {\n-        ImplData {\n-            id: self.id,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            trait_ref: self.trait_ref.map(|id| id.index.as_u32()),\n-            self_ref: self.self_ref.map(|id| id.index.as_u32()),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct InheritanceData {\n-    pub span: SpanData,\n-    pub base_id: Id,\n-    pub deriv_id: Id\n-}\n-\n-impl Lower for data::InheritanceData {\n-    type Target = InheritanceData;\n-\n-    fn lower(self, cm: &CodeMap) -> InheritanceData {\n-        InheritanceData {\n-            span: SpanData::from_span(self.span, cm),\n-            base_id: self.base_id.index.as_u32(),\n-            deriv_id: self.deriv_id\n-        }\n-    }\n-}\n-\n-/// Data about a macro declaration.\n-#[derive(Debug, RustcEncodable)]\n-pub struct MacroData {\n-    pub span: SpanData,\n-    pub name: String,\n-    pub qualname: String,\n-}\n-\n-impl Lower for data::MacroData {\n-    type Target = MacroData;\n-\n-    fn lower(self, cm: &CodeMap) -> MacroData {\n-        MacroData {\n-            span: SpanData::from_span(self.span, cm),\n-            name: self.name,\n-            qualname: self.qualname,\n-        }\n-    }\n-}\n-\n-/// Data about a macro use.\n-#[derive(Debug, RustcEncodable)]\n-pub struct MacroUseData {\n-    pub span: SpanData,\n-    pub name: String,\n-    pub qualname: String,\n-    // Because macro expansion happens before ref-ids are determined,\n-    // we use the callee span to reference the associated macro definition.\n-    pub callee_span: SpanData,\n-    pub scope: Id,\n-    pub imported: bool,\n-}\n-\n-impl Lower for data::MacroUseData {\n-    type Target = MacroUseData;\n-\n-    fn lower(self, cm: &CodeMap) -> MacroUseData {\n-        MacroUseData {\n-            span: SpanData::from_span(self.span, cm),\n-            name: self.name,\n-            qualname: self.qualname,\n-            callee_span: SpanData::from_span(self.callee_span, cm),\n-            scope: self.scope,\n-            imported: self.imported,\n-        }\n-    }\n-}\n-\n-/// Data about a method call.\n-#[derive(Debug, RustcEncodable)]\n-pub struct MethodCallData {\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Option<Id>,\n-    pub decl_id: Option<Id>,\n-}\n-\n-impl Lower for data::MethodCallData {\n-    type Target = MethodCallData;\n-\n-    fn lower(self, cm: &CodeMap) -> MethodCallData {\n-        MethodCallData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.map(|id| id.index.as_u32()),\n-            decl_id: self.decl_id.map(|id| id.index.as_u32()),\n-        }\n-    }\n-}\n-\n-/// Data for method declarations (methods with a body are treated as functions).\n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct MethodData {\n-    pub id: Id,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-}\n-\n-impl Lower for data::MethodData {\n-    type Target = MethodData;\n-\n-    fn lower(self, cm: &CodeMap) -> MethodData {\n-        MethodData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            id: self.id,\n-            qualname: self.qualname,\n-        }\n-    }\n-}\n-\n-/// Data for modules.\n-#[derive(Debug, RustcEncodable)]\n-pub struct ModData {\n-    pub id: Id,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub filename: String,\n-}\n-\n-impl Lower for data::ModData {\n-    type Target = ModData;\n-\n-    fn lower(self, cm: &CodeMap) -> ModData {\n-        ModData {\n-            id: self.id,\n-            name: self.name,\n-            qualname: self.qualname,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            filename: self.filename,\n-        }\n-    }\n-}\n-\n-/// Data for a reference to a module.\n-#[derive(Debug, RustcEncodable)]\n-pub struct ModRefData {\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Option<Id>,\n-    pub qualname: String\n-}\n-\n-impl Lower for data::ModRefData {\n-    type Target = ModRefData;\n-\n-    fn lower(self, cm: &CodeMap) -> ModRefData {\n-        ModRefData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.map(|id| id.index.as_u32()),\n-            qualname: self.qualname,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct StructData {\n-    pub span: SpanData,\n-    pub id: Id,\n-    pub ctor_id: Id,\n-    pub qualname: String,\n-    pub scope: Id,\n-    pub value: String\n-}\n-\n-impl Lower for data::StructData {\n-    type Target = StructData;\n-\n-    fn lower(self, cm: &CodeMap) -> StructData {\n-        StructData {\n-            span: SpanData::from_span(self.span, cm),\n-            id: self.id,\n-            ctor_id: self.ctor_id,\n-            qualname: self.qualname,\n-            scope: self.scope,\n-            value: self.value\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct StructVariantData {\n-    pub span: SpanData,\n-    pub id: Id,\n-    pub qualname: String,\n-    pub type_value: String,\n-    pub value: String,\n-    pub scope: Id\n-}\n-\n-impl Lower for data::StructVariantData {\n-    type Target = StructVariantData;\n-\n-    fn lower(self, cm: &CodeMap) -> StructVariantData {\n-        StructVariantData {\n-            span: SpanData::from_span(self.span, cm),\n-            id: self.id,\n-            qualname: self.qualname,\n-            type_value: self.type_value,\n-            value: self.value,\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct TraitData {\n-    pub span: SpanData,\n-    pub id: Id,\n-    pub qualname: String,\n-    pub scope: Id,\n-    pub value: String\n-}\n-\n-impl Lower for data::TraitData {\n-    type Target = TraitData;\n-\n-    fn lower(self, cm: &CodeMap) -> TraitData {\n-        TraitData {\n-            span: SpanData::from_span(self.span, cm),\n-            id: self.id,\n-            qualname: self.qualname,\n-            scope: self.scope,\n-            value: self.value,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct TupleVariantData {\n-    pub span: SpanData,\n-    pub id: Id,\n-    pub name: String,\n-    pub qualname: String,\n-    pub type_value: String,\n-    pub value: String,\n-    pub scope: Id,\n-}\n-\n-impl Lower for data::TupleVariantData {\n-    type Target = TupleVariantData;\n-\n-    fn lower(self, cm: &CodeMap) -> TupleVariantData {\n-        TupleVariantData {\n-            span: SpanData::from_span(self.span, cm),\n-            id: self.id,\n-            name: self.name,\n-            qualname: self.qualname,\n-            type_value: self.type_value,\n-            value: self.value,\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-/// Data for a typedef.\n-#[derive(Debug, RustcEncodable)]\n-pub struct TypedefData {\n-    pub id: Id,\n-    pub span: SpanData,\n-    pub qualname: String,\n-    pub value: String,\n-}\n-\n-impl Lower for data::TypedefData {\n-    type Target = TypedefData;\n-\n-    fn lower(self, cm: &CodeMap) -> TypedefData {\n-        TypedefData {\n-            id: self.id,\n-            span: SpanData::from_span(self.span, cm),\n-            qualname: self.qualname,\n-            value: self.value,\n-        }\n-    }\n-}\n-\n-/// Data for a reference to a type or trait.\n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct TypeRefData {\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Option<Id>,\n-    pub qualname: String,\n-}\n-\n-impl Lower for data::TypeRefData {\n-    type Target = TypeRefData;\n-\n-    fn lower(self, cm: &CodeMap) -> TypeRefData {\n-        TypeRefData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.map(|id| id.index.as_u32()),\n-            qualname: self.qualname,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct UseData {\n-    pub id: Id,\n-    pub span: SpanData,\n-    pub name: String,\n-    pub mod_id: Option<Id>,\n-    pub scope: Id\n-}\n-\n-impl Lower for data::UseData {\n-    type Target = UseData;\n-\n-    fn lower(self, cm: &CodeMap) -> UseData {\n-        UseData {\n-            id: self.id,\n-            span: SpanData::from_span(self.span, cm),\n-            name: self.name,\n-            mod_id: self.mod_id.map(|id| id.index.as_u32()),\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct UseGlobData {\n-    pub id: Id,\n-    pub span: SpanData,\n-    pub names: Vec<String>,\n-    pub scope: Id\n-}\n-\n-impl Lower for data::UseGlobData {\n-    type Target = UseGlobData;\n-\n-    fn lower(self, cm: &CodeMap) -> UseGlobData {\n-        UseGlobData {\n-            id: self.id,\n-            span: SpanData::from_span(self.span, cm),\n-            names: self.names,\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-/// Data for local and global variables (consts and statics).\n-#[derive(Debug, RustcEncodable)]\n-pub struct VariableData {\n-    pub id: Id,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub value: String,\n-    pub type_value: String,\n-}\n-\n-impl Lower for data::VariableData {\n-    type Target = VariableData;\n-\n-    fn lower(self, cm: &CodeMap) -> VariableData {\n-        VariableData {\n-            id: self.id,\n-            name: self.name,\n-            qualname: self.qualname,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            value: self.value,\n-            type_value: self.type_value,\n-        }\n-    }\n-}\n-\n-/// Data for the use of some item (e.g., the use of a local variable, which\n-/// will refer to that variables declaration (by ref_id)).\n-#[derive(Debug, RustcEncodable)]\n-pub struct VariableRefData {\n-    pub name: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Id,\n-}\n-\n-impl Lower for data::VariableRefData {\n-    type Target = VariableRefData;\n-\n-    fn lower(self, cm: &CodeMap) -> VariableRefData {\n-        VariableRefData {\n-            name: self.name,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.index.as_u32(),\n-        }\n-    }\n-}"}, {"sha": "906923e5cad9586da1f860b02f1dcb829ec54717", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -28,6 +28,15 @@\n #[macro_use] extern crate syntax;\n extern crate serialize as rustc_serialize;\n \n+mod csv_dumper;\n+mod json_dumper;\n+mod data;\n+mod dump;\n+mod dump_visitor;\n+pub mod external_data;\n+#[macro_use]\n+pub mod span_utils;\n+\n use rustc::hir;\n use rustc::hir::map::NodeItem;\n use rustc::hir::def::Def;\n@@ -45,14 +54,6 @@ use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::ty_to_string;\n \n-mod csv_dumper;\n-mod json_dumper;\n-mod data;\n-mod dump;\n-mod dump_visitor;\n-#[macro_use]\n-pub mod span_utils;\n-\n pub use self::csv_dumper::CsvDumper;\n pub use self::json_dumper::JsonDumper;\n pub use self::data::*;\n@@ -748,7 +749,6 @@ pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n     root_path.pop();\n     let output = &mut output_file;\n \n-    let utils: SpanUtils<'tcx> = SpanUtils::new(&tcx.sess);\n     let save_ctxt = SaveContext::new(tcx);\n \n     macro_rules! dump {\n@@ -762,8 +762,8 @@ pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n     }\n \n     match format {\n-        Format::Csv => dump!(CsvDumper::new(output, utils)),\n-        Format::Json => dump!(JsonDumper::new(output, utils.sess.codemap())),\n+        Format::Csv => dump!(CsvDumper::new(output)),\n+        Format::Json => dump!(JsonDumper::new(output)),\n     }\n }\n "}, {"sha": "3028fb1bfa423e87cb924aff05ae4bef36ea9b9f", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -18,10 +18,8 @@ use std::path::Path;\n \n use syntax::ast;\n use syntax::codemap::*;\n-use syntax::parse::lexer;\n-use syntax::parse::lexer::{Reader, StringReader};\n-use syntax::parse::token;\n-use syntax::parse::token::{keywords, Token};\n+use syntax::parse::lexer::{self, Reader, StringReader};\n+use syntax::parse::token::{self, keywords, Token};\n \n #[derive(Clone)]\n pub struct SpanUtils<'a> {\n@@ -48,23 +46,6 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    // Standard string for extents/location.\n-    #[rustfmt_skip]\n-    pub fn extent_str(&self, span: Span) -> String {\n-        let lo_loc = self.sess.codemap().lookup_char_pos(span.lo);\n-        let hi_loc = self.sess.codemap().lookup_char_pos(span.hi);\n-        let lo_pos = self.sess.codemap().bytepos_to_file_charpos(span.lo);\n-        let hi_pos = self.sess.codemap().bytepos_to_file_charpos(span.hi);\n-        let lo_pos_byte = self.sess.codemap().lookup_byte_offset(span.lo).pos;\n-        let hi_pos_byte = self.sess.codemap().lookup_byte_offset(span.hi).pos;\n-\n-        format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},extent_start,{},extent_start_bytes,{},\\\n-                 file_line_end,{},file_col_end,{},extent_end,{},extent_end_bytes,{}\",\n-                SpanUtils::make_path_string(&lo_loc.file.name),\n-                lo_loc.line, lo_loc.col.to_usize(), lo_pos.to_usize(), lo_pos_byte.to_usize(),\n-                hi_loc.line, hi_loc.col.to_usize(), hi_pos.to_usize(), hi_pos_byte.to_usize())\n-    }\n-\n     // sub_span starts at span.lo, so we need to adjust the positions etc.\n     // If sub_span is None, we don't need to adjust.\n     pub fn make_sub_span(&self, span: Span, sub_span: Option<Span>) -> Option<Span> {"}, {"sha": "a47b66bf2f72ebf21d09b1007885c5d96be21ecb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -1540,6 +1540,13 @@ impl Type {\n             _ => None,\n         }\n     }\n+\n+    pub fn is_generic(&self) -> bool {\n+        match *self {\n+            ResolvedPath { is_generic, .. } => is_generic,\n+            _ => false,\n+        }\n+    }\n }\n \n impl GetDefId for Type {"}, {"sha": "6a2a0a37c1c05f9f3b15da9fcb7bca77f7ca1053", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -783,7 +783,7 @@ fn write_shared(cx: &Context,\n             try_err!(write!(&mut f, \"{}\", *implementor), &mydst);\n         }\n \n-        try_err!(write!(&mut f, r\"implementors['{}'] = [\", krate.name), &mydst);\n+        try_err!(write!(&mut f, r#\"implementors[\"{}\"] = [\"#, krate.name), &mydst);\n         for imp in imps {\n             // If the trait and implementation are in the same crate, then\n             // there's no need to emit information about it (there's inlining\n@@ -2144,7 +2144,7 @@ fn render_stability_since_raw<'a>(w: &mut fmt::Formatter,\n                                   containing_ver: Option<&'a str>) -> fmt::Result {\n     if let Some(v) = ver {\n         if containing_ver != ver && v.len() > 0 {\n-            write!(w, \"<span class=\\\"since\\\">{}</span>\",\n+            write!(w, \"<div class=\\\"since\\\">{}</div>\",\n                    v)?\n         }\n     }\n@@ -2545,13 +2545,16 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                render_header: bool, outer_version: Option<&str>) -> fmt::Result {\n     if render_header {\n         write!(w, \"<h3 class='impl'><span class='in-band'><code>{}</code>\", i.inner_impl())?;\n-        let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n-        render_stability_since_raw(w, since, outer_version)?;\n         write!(w, \"</span><span class='out-of-band'>\")?;\n+        let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n         if let Some(l) = (Item { item: &i.impl_item, cx: cx }).href() {\n+            write!(w, \"<div class='ghost'></div>\")?;\n+            render_stability_since_raw(w, since, outer_version)?;\n             write!(w, \"<a id='src-{}' class='srclink' \\\n                        href='{}' title='{}'>[src]</a>\",\n                    i.impl_item.def_id.index.as_usize(), l, \"goto source code\")?;\n+        } else {\n+            render_stability_since_raw(w, since, outer_version)?;\n         }\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;"}, {"sha": "4d65b91ed421c884f59c7f43fa5a78babda1ff1a", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -97,6 +97,7 @@ h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):no\n h1.fqn {\n     border-bottom: 1px dashed;\n     margin-top: 0;\n+    position: relative;\n }\n h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n     border-bottom: 1px solid;\n@@ -105,6 +106,7 @@ h3.impl, h3.method, h4.method, h3.type, h4.type {\n     font-weight: 600;\n     margin-top: 10px;\n     margin-bottom: 10px;\n+    position: relative;\n }\n h3.impl, h3.method, h3.type {\n     margin-top: 15px;\n@@ -265,20 +267,39 @@ nav.sub {\n \n .content .out-of-band {\n     font-size: 23px;\n-    width: 40%;\n     margin: 0px;\n     padding: 0px;\n     text-align: right;\n     display: inline-block;\n+    font-weight: normal;\n+    position: absolute;\n+    right: 0;\n+}\n+\n+h3.impl > .out-of-band {\n+    font-size: 21px;\n+}\n+\n+h4 > code, h3 > code {\n+    position: inherit;\n+}\n+\n+.in-band, code {\n+    z-index: 5;\n }\n \n .content .in-band {\n-    width: 60%;\n     margin: 0px;\n     padding: 0px;\n     display: inline-block;\n }\n \n+#main { position: relative; }\n+#main > .since {\n+    top: inherit;\n+    font-family: \"Fira Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n+}\n+\n .content table {\n     border-spacing: 0 5px;\n     border-collapse: separate;\n@@ -498,11 +519,13 @@ em.stab p {\n     opacity: 0.65;\n }\n \n-span.since {\n-    float: right;\n+.since {\n     font-weight: normal;\n     font-size: initial;\n     color: grey;\n+    position: absolute;\n+    right: 0;\n+    top: 0;\n }\n \n .variants_table {\n@@ -597,7 +620,19 @@ a.test-arrow {\n     color: #999;\n }\n \n+.ghost {\n+    display: none;\n+}\n+\n+.ghost + .since {\n+    position: initial;\n+    display: table-cell;\n+}\n \n+.since + .srclink {\n+    display: table-cell;\n+    padding-left: 10px;\n+}\n \n /* Media Queries */\n "}, {"sha": "59b2ff7e3d64911703ae8f1594264056671313c8", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -26,6 +26,9 @@ h1.fqn {\n h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n     border-bottom-color: #DDDDDD;\n }\n+.in-band, code {\n+    background-color: white;\n+}\n \n .docblock code {\n     background-color: #F5F5F5;"}, {"sha": "1980d1f9cc45fc54ab9ccffde89ed3938a580e7f", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -115,9 +115,9 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n \n             // trait impls for private items should be stripped\n             clean::ImplItem(clean::Impl{\n-                for_: clean::ResolvedPath{ did, .. }, ..\n+                for_: clean::ResolvedPath{ did, is_generic, .. }, ..\n             }) => {\n-                if did.is_local() && !self.access_levels.is_exported(did) {\n+                if did.is_local() && !is_generic && !self.access_levels.is_exported(did) {\n                     return None;\n                 }\n             }\n@@ -183,7 +183,9 @@ impl<'a> fold::DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = i.inner {\n             if let Some(did) = imp.for_.def_id() {\n-                if did.is_local() && !self.retained.contains(&did) {\n+                if did.is_local() && !imp.for_.is_generic() &&\n+                    !self.retained.contains(&did)\n+                {\n                     return None;\n                 }\n             }"}, {"sha": "90b2c6116038c4024c764499ee0107631dc00772", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -3948,7 +3948,7 @@ mod tests {\n         let mut mem_buf = string::String::new();\n         let mut encoder = Encoder::new(&mut mem_buf);\n         let result = hm.encode(&mut encoder);\n-        match result.err().unwrap() {\n+        match result.unwrap_err() {\n             EncoderError::BadHashmapKey => (),\n             _ => panic!(\"expected bad hash map key\")\n         }"}, {"sha": "c19fe1e1d2604a128b01c0a39113fc838bce3f45", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -1772,7 +1772,7 @@ mod tests {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"mkdir_error_twice\");\n         check!(fs::create_dir(dir));\n-        let e = fs::create_dir(dir).err().unwrap();\n+        let e = fs::create_dir(dir).unwrap_err();\n         assert_eq!(e.kind(), ErrorKind::AlreadyExists);\n     }\n "}, {"sha": "a92ca95f4ee7ef024925b51f20879d21b14d7f96", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -1127,7 +1127,7 @@ mod tests {\n             let mut writer = BufWriter::new(PanicWriter);\n             let _ = writer.write(b\"hello world\");\n             let _ = writer.flush();\n-        }).join().err().unwrap();\n+        }).join().unwrap_err();\n \n         assert_eq!(WRITES.load(Ordering::SeqCst), 1);\n     }"}, {"sha": "63b659d8db3b7b2aa85ada196f3c1cfb52b7f1f5", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -535,7 +535,7 @@ impl<T> Sender<T> {\n     ///\n     /// // This send will fail because the receiver is gone\n     /// drop(rx);\n-    /// assert_eq!(tx.send(1).err().unwrap().0, 1);\n+    /// assert_eq!(tx.send(1).unwrap_err().0, 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {"}, {"sha": "fbc6bfb6c8d9f5a1de3b16d5f459f84206bfeff9", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -594,7 +594,7 @@ mod test {\n             assert!(res.is_ok(),\n                     \"Op {} failed with 1 stack entry: {}\",\n                     cap,\n-                    res.err().unwrap());\n+                    res.unwrap_err());\n         }\n         let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n         for &cap in caps.iter() {\n@@ -610,7 +610,7 @@ mod test {\n             assert!(res.is_ok(),\n                     \"Binop {} failed with 2 stack entries: {}\",\n                     cap,\n-                    res.err().unwrap());\n+                    res.unwrap_err());\n         }\n     }\n \n@@ -625,15 +625,15 @@ mod test {\n         for &(op, bs) in v.iter() {\n             let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n-            assert!(res.is_ok(), res.err().unwrap());\n+            assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), vec![b'0' + bs[0]]);\n             let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n-            assert!(res.is_ok(), res.err().unwrap());\n+            assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), vec![b'0' + bs[1]]);\n             let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n-            assert!(res.is_ok(), res.err().unwrap());\n+            assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), vec![b'0' + bs[2]]);\n         }\n     }\n@@ -643,13 +643,13 @@ mod test {\n         let mut vars = Variables::new();\n         let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n         let res = expand(s, &[Number(1)], &mut vars);\n-        assert!(res.is_ok(), res.err().unwrap());\n+        assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(), \"\\\\E[31m\".bytes().collect::<Vec<_>>());\n         let res = expand(s, &[Number(8)], &mut vars);\n-        assert!(res.is_ok(), res.err().unwrap());\n+        assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(), \"\\\\E[90m\".bytes().collect::<Vec<_>>());\n         let res = expand(s, &[Number(42)], &mut vars);\n-        assert!(res.is_ok(), res.err().unwrap());\n+        assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(), \"\\\\E[38;5;42m\".bytes().collect::<Vec<_>>());\n     }\n "}, {"sha": "1cd785334f63a7e6f9171090b286f7414b66bcbb", "filename": "src/test/run-make/static-unwinding/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -25,7 +25,7 @@ fn main() {\n     thread::spawn(move|| {\n         let _a = A;\n         lib::callback(|| panic!());\n-    }).join().err().unwrap();\n+    }).join().unwrap_err();\n \n     unsafe {\n         assert_eq!(lib::statik, 1);"}, {"sha": "72f952fb6c0df389fc5e54e15bdb1270938177b8", "filename": "src/test/run-pass/command-before-exec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -62,7 +62,7 @@ fn main() {\n \n     let output = Command::new(&me).arg(\"bad\").before_exec(|| {\n         Err(Error::from_raw_os_error(102))\n-    }).output().err().unwrap();\n+    }).output().unwrap_err();\n     assert_eq!(output.raw_os_error(), Some(102));\n \n     let pid = unsafe { libc::getpid() };"}, {"sha": "e718046ebbcd7b53155214ed0996ec3f271ddb0c", "filename": "src/test/run-pass/no-landing-pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -27,6 +27,6 @@ fn main() {\n     thread::spawn(move|| -> () {\n         let _a = A;\n         panic!();\n-    }).join().err().unwrap();\n+    }).join().unwrap_err();\n     assert!(unsafe { !HIT });\n }"}, {"sha": "2c87c6b92686ca6beff5ec22a731364b745bb352", "filename": "src/test/run-pass/panic-recover-propagate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Fpanic-recover-propagate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Fpanic-recover-propagate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-recover-propagate.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -28,10 +28,10 @@ fn main() {\n             panic!(\"hi there\");\n         });\n \n-        panic::propagate(result.err().unwrap());\n+        panic::propagate(result.unwrap_err());\n     }).join();\n \n-    let msg = *result.err().unwrap().downcast::<&'static str>().unwrap();\n+    let msg = *result.unwrap_err().downcast::<&'static str>().unwrap();\n     assert_eq!(\"hi there\", msg);\n     assert_eq!(1, A.load(Ordering::SeqCst));\n }"}, {"sha": "3a93845a0620aaae27646a37dab8ed6e14ebfc32", "filename": "src/test/run-pass/sepcomp-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -39,5 +39,5 @@ mod b {\n }\n \n fn main() {\n-    thread::spawn(move|| { ::b::g() }).join().err().unwrap();\n+    thread::spawn(move|| { ::b::g() }).join().unwrap_err();\n }"}, {"sha": "c9133bae854081ac1e74bceae64fa9362ae58d85", "filename": "src/test/run-pass/terminate-in-initializer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -24,13 +24,13 @@ fn test_ret() { let _x: Box<isize> = return; }\n \n fn test_panic() {\n     fn f() { let _x: Box<isize> = panic!(); }\n-    thread::spawn(move|| f() ).join().err().unwrap();\n+    thread::spawn(move|| f() ).join().unwrap_err();\n }\n \n fn test_panic_indirect() {\n     fn f() -> ! { panic!(); }\n     fn g() { let _x: Box<isize> = f(); }\n-    thread::spawn(move|| g() ).join().err().unwrap();\n+    thread::spawn(move|| g() ).join().unwrap_err();\n }\n \n pub fn main() {"}, {"sha": "ec37be9420db73e248842b94b6a78744a348957d", "filename": "src/test/run-pass/unit-like-struct-drop-run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -30,6 +30,6 @@ pub fn main() {\n         let _b = Foo;\n     }).join();\n \n-    let s = x.err().unwrap().downcast::<&'static str>().unwrap();\n+    let s = x.unwrap_err().downcast::<&'static str>().unwrap();\n     assert_eq!(&**s, \"This panic should happen.\");\n }"}, {"sha": "d8b484f6b501bd705f4c2e3044b6b132e8a1065c", "filename": "src/test/rustdoc/issue-29503.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frustdoc%2Fissue-29503.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1/src%2Ftest%2Frustdoc%2Fissue-29503.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-29503.rs?ref=e0fd34bba05cb43119abd6a45d3c33fcdf48c6b1", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+// @has issue_29503/trait.MyTrait.html\n+pub trait MyTrait {\n+    fn my_string(&self) -> String;\n+}\n+\n+// @has - \"//ul[@id='implementors-list']/li\" \"impl<T> MyTrait for T where T: Debug\"\n+impl<T> MyTrait for T where T: fmt::Debug {\n+    fn my_string(&self) -> String {\n+        format!(\"{:?}\", self)\n+    }\n+}\n+\n+pub fn main() {\n+}"}]}