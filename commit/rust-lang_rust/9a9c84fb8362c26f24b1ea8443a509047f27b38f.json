{"sha": "9a9c84fb8362c26f24b1ea8443a509047f27b38f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhOWM4NGZiODM2MmMyNmYyNGIxZWE4NDQzYTUwOTA0N2YyN2IzOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-12T00:52:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-12T00:52:40Z"}, "message": "auto merge of #7688 : nikomatsakis/rust/issue-6298-dataflow-graph, r=graydon\n\nThis patch is a step towards #6298. It extracts the graph abstraction from region inference into a library, and then ports the region inference to use it. It also adds a control-flow graph abstraction that will eventually be used by dataflow. The CFG code is not yet used, but I figured better to add it so as to make later rebasing etc easier.", "tree": {"sha": "fe073e4df5fb72d742c663d9b48b56249f632c38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe073e4df5fb72d742c663d9b48b56249f632c38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a9c84fb8362c26f24b1ea8443a509047f27b38f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a9c84fb8362c26f24b1ea8443a509047f27b38f", "html_url": "https://github.com/rust-lang/rust/commit/9a9c84fb8362c26f24b1ea8443a509047f27b38f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a9c84fb8362c26f24b1ea8443a509047f27b38f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4478ded57c3a6cd86ad2e6b8cac1f6b4d46d1130", "url": "https://api.github.com/repos/rust-lang/rust/commits/4478ded57c3a6cd86ad2e6b8cac1f6b4d46d1130", "html_url": "https://github.com/rust-lang/rust/commit/4478ded57c3a6cd86ad2e6b8cac1f6b4d46d1130"}, {"sha": "3b911816ecacf2e80f4faaadeb577743e9070f7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b911816ecacf2e80f4faaadeb577743e9070f7f", "html_url": "https://github.com/rust-lang/rust/commit/3b911816ecacf2e80f4faaadeb577743e9070f7f"}], "stats": {"total": 1373, "additions": 1178, "deletions": 195}, "files": [{"sha": "9ecb4dcaf5e9f01b218c0eecde1540bd43aa32ef", "filename": "src/librustc/middle/cfg/construct.rs", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=9a9c84fb8362c26f24b1ea8443a509047f27b38f", "patch": "@@ -0,0 +1,523 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::cfg::*;\n+use middle::graph;\n+use middle::typeck;\n+use middle::ty;\n+use std::hashmap::HashMap;\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::opt_vec;\n+\n+struct CFGBuilder {\n+    tcx: ty::ctxt,\n+    method_map: typeck::method_map,\n+    exit_map: HashMap<ast::node_id, CFGIndex>,\n+    graph: CFGGraph,\n+    loop_scopes: ~[LoopScope],\n+}\n+\n+struct LoopScope {\n+    loop_id: ast::node_id,    // id of loop/while node\n+    continue_index: CFGIndex, // where to go on a `loop`\n+    break_index: CFGIndex,    // where to go on a `break\n+}\n+\n+pub fn construct(tcx: ty::ctxt,\n+                 method_map: typeck::method_map,\n+                 blk: &ast::blk) -> CFG {\n+    let mut cfg_builder = CFGBuilder {\n+        exit_map: HashMap::new(),\n+        graph: graph::Graph::new(),\n+        tcx: tcx,\n+        method_map: method_map,\n+        loop_scopes: ~[]\n+    };\n+    let entry = cfg_builder.add_node(0, []);\n+    let exit = cfg_builder.block(blk, entry);\n+    let CFGBuilder {exit_map, graph, _} = cfg_builder;\n+    CFG {exit_map: exit_map,\n+         graph: graph,\n+         entry: entry,\n+         exit: exit}\n+}\n+\n+impl CFGBuilder {\n+    fn block(&mut self, blk: &ast::blk, pred: CFGIndex) -> CFGIndex {\n+        let mut stmts_exit = pred;\n+        for blk.node.stmts.iter().advance |&stmt| {\n+            stmts_exit = self.stmt(stmt, stmts_exit);\n+        }\n+\n+        let expr_exit = self.opt_expr(blk.node.expr, stmts_exit);\n+\n+        self.add_node(blk.node.id, [expr_exit])\n+    }\n+\n+    fn stmt(&mut self, stmt: @ast::stmt, pred: CFGIndex) -> CFGIndex {\n+        match stmt.node {\n+            ast::stmt_decl(decl, _) => {\n+                self.decl(decl, pred)\n+            }\n+\n+            ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n+                self.expr(expr, pred)\n+            }\n+\n+            ast::stmt_mac(*) => {\n+                self.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n+            }\n+        }\n+    }\n+\n+    fn decl(&mut self, decl: @ast::decl, pred: CFGIndex) -> CFGIndex {\n+        match decl.node {\n+            ast::decl_local(local) => {\n+                let init_exit = self.opt_expr(local.node.init, pred);\n+                self.pat(local.node.pat, init_exit)\n+            }\n+\n+            ast::decl_item(_) => {\n+                pred\n+            }\n+        }\n+    }\n+\n+    fn pat(&mut self, pat: @ast::pat, pred: CFGIndex) -> CFGIndex {\n+        match pat.node {\n+            ast::pat_ident(_, _, None) |\n+            ast::pat_enum(_, None) |\n+            ast::pat_lit(*) |\n+            ast::pat_range(*) |\n+            ast::pat_wild => {\n+                self.add_node(pat.id, [pred])\n+            }\n+\n+            ast::pat_box(subpat) |\n+            ast::pat_uniq(subpat) |\n+            ast::pat_region(subpat) |\n+            ast::pat_ident(_, _, Some(subpat)) => {\n+                let subpat_exit = self.pat(subpat, pred);\n+                self.add_node(pat.id, [subpat_exit])\n+            }\n+\n+            ast::pat_enum(_, Some(ref subpats)) |\n+            ast::pat_tup(ref subpats) => {\n+                let pats_exit =\n+                    self.pats_all(subpats.iter().transform(|p| *p), pred);\n+                self.add_node(pat.id, [pats_exit])\n+            }\n+\n+            ast::pat_struct(_, ref subpats, _) => {\n+                let pats_exit =\n+                    self.pats_all(subpats.iter().transform(|f| f.pat), pred);\n+                self.add_node(pat.id, [pats_exit])\n+            }\n+\n+            ast::pat_vec(ref pre, ref vec, ref post) => {\n+                let pre_exit =\n+                    self.pats_all(pre.iter().transform(|p| *p), pred);\n+                let vec_exit =\n+                    self.pats_all(vec.iter().transform(|p| *p), pre_exit);\n+                let post_exit =\n+                    self.pats_all(post.iter().transform(|p| *p), vec_exit);\n+                self.add_node(pat.id, [post_exit])\n+            }\n+        }\n+    }\n+\n+    fn pats_all<I: Iterator<@ast::pat>>(&mut self,\n+                                        pats: I,\n+                                        pred: CFGIndex) -> CFGIndex {\n+        //! Handles case where all of the patterns must match.\n+        let mut pats = pats;\n+        pats.fold(pred, |pred, pat| self.pat(pat, pred))\n+    }\n+\n+    fn pats_any(&mut self,\n+                pats: &[@ast::pat],\n+                pred: CFGIndex) -> CFGIndex {\n+        //! Handles case where just one of the patterns must match.\n+\n+        if pats.len() == 1 {\n+            self.pat(pats[0], pred)\n+        } else {\n+            let collect = self.add_dummy_node([]);\n+            for pats.iter().advance |&pat| {\n+                let pat_exit = self.pat(pat, pred);\n+                self.add_contained_edge(pat_exit, collect);\n+            }\n+            collect\n+        }\n+    }\n+\n+    fn expr(&mut self, expr: @ast::expr, pred: CFGIndex) -> CFGIndex {\n+        match expr.node {\n+            ast::expr_block(ref blk) => {\n+                let blk_exit = self.block(blk, pred);\n+                self.add_node(expr.id, [blk_exit])\n+            }\n+\n+            ast::expr_if(cond, ref then, None) => {\n+                //\n+                //     [pred]\n+                //       |\n+                //       v 1\n+                //     [cond]\n+                //       |\n+                //      / \\\n+                //     /   \\\n+                //    v 2   *\n+                //  [then]  |\n+                //    |     |\n+                //    v 3   v 4\n+                //   [..expr..]\n+                //\n+                let cond_exit = self.expr(cond, pred);                // 1\n+                let then_exit = self.block(then, cond_exit);          // 2\n+                self.add_node(expr.id, [cond_exit, then_exit])        // 3,4\n+            }\n+\n+            ast::expr_if(cond, ref then, Some(otherwise)) => {\n+                //\n+                //     [pred]\n+                //       |\n+                //       v 1\n+                //     [cond]\n+                //       |\n+                //      / \\\n+                //     /   \\\n+                //    v 2   v 3\n+                //  [then][otherwise]\n+                //    |     |\n+                //    v 4   v 5\n+                //   [..expr..]\n+                //\n+                let cond_exit = self.expr(cond, pred);                // 1\n+                let then_exit = self.block(then, cond_exit);          // 2\n+                let else_exit = self.expr(otherwise, cond_exit);      // 3\n+                self.add_node(expr.id, [then_exit, else_exit])        // 4, 5\n+            }\n+\n+            ast::expr_while(cond, ref body) => {\n+                //\n+                //         [pred]\n+                //           |\n+                //           v 1\n+                //       [loopback] <--+ 5\n+                //           |         |\n+                //           v 2       |\n+                //   +-----[cond]      |\n+                //   |       |         |\n+                //   |       v 4       |\n+                //   |     [body] -----+\n+                //   v 3\n+                // [expr]\n+                //\n+                // Note that `break` and `loop` statements\n+                // may cause additional edges.\n+\n+                // NOTE: Is the condition considered part of the loop?\n+                let loopback = self.add_dummy_node([pred]);           // 1\n+                let cond_exit = self.expr(cond, loopback);            // 2\n+                let expr_exit = self.add_node(expr.id, [cond_exit]);  // 3\n+                self.loop_scopes.push(LoopScope {\n+                    loop_id: expr.id,\n+                    continue_index: loopback,\n+                    break_index: expr_exit\n+                });\n+                let body_exit = self.block(body, cond_exit);          // 4\n+                self.add_contained_edge(body_exit, loopback);         // 5\n+                expr_exit\n+            }\n+\n+            ast::expr_loop(ref body, _) => {\n+                //\n+                //     [pred]\n+                //       |\n+                //       v 1\n+                //   [loopback] <---+\n+                //       |      4   |\n+                //       v 3        |\n+                //     [body] ------+\n+                //\n+                //     [expr] 2\n+                //\n+                // Note that `break` and `loop` statements\n+                // may cause additional edges.\n+\n+                let loopback = self.add_dummy_node([pred]);           // 1\n+                let expr_exit = self.add_node(expr.id, []);           // 2\n+                self.loop_scopes.push(LoopScope {\n+                    loop_id: expr.id,\n+                    continue_index: loopback,\n+                    break_index: expr_exit,\n+                });\n+                let body_exit = self.block(body, loopback);           // 3\n+                self.add_contained_edge(body_exit, loopback);         // 4\n+                self.loop_scopes.pop();\n+                expr_exit\n+            }\n+\n+            ast::expr_match(discr, ref arms) => {\n+                //\n+                //     [pred]\n+                //       |\n+                //       v 1\n+                //    [discr]\n+                //       |\n+                //       v 2\n+                //    [guard1]\n+                //      /  \\\n+                //     |    \\\n+                //     v 3  |\n+                //  [pat1]  |\n+                //     |\n+                //     v 4  |\n+                // [body1]  v\n+                //     |  [guard2]\n+                //     |    /   \\\n+                //     | [body2] \\\n+                //     |    |   ...\n+                //     |    |    |\n+                //     v 5  v    v\n+                //   [....expr....]\n+                //\n+                let discr_exit = self.expr(discr, pred);                 // 1\n+\n+                let expr_exit = self.add_node(expr.id, []);\n+                let mut guard_exit = discr_exit;\n+                for arms.iter().advance |arm| {\n+                    guard_exit = self.opt_expr(arm.guard, guard_exit); // 2\n+                    let pats_exit = self.pats_any(arm.pats, guard_exit); // 3\n+                    let body_exit = self.block(&arm.body, pats_exit);    // 4\n+                    self.add_contained_edge(body_exit, expr_exit);       // 5\n+                }\n+                expr_exit\n+            }\n+\n+            ast::expr_binary(_, op, l, r) if ast_util::lazy_binop(op) => {\n+                //\n+                //     [pred]\n+                //       |\n+                //       v 1\n+                //      [l]\n+                //       |\n+                //      / \\\n+                //     /   \\\n+                //    v 2  *\n+                //   [r]   |\n+                //    |    |\n+                //    v 3  v 4\n+                //   [..exit..]\n+                //\n+                let l_exit = self.expr(l, pred);                         // 1\n+                let r_exit = self.expr(r, l_exit);                       // 2\n+                self.add_node(expr.id, [l_exit, r_exit])                 // 3,4\n+            }\n+\n+            ast::expr_ret(v) => {\n+                let v_exit = self.opt_expr(v, pred);\n+                let loop_scope = self.loop_scopes[0];\n+                self.add_exiting_edge(expr, v_exit,\n+                                      loop_scope, loop_scope.break_index);\n+                self.add_node(expr.id, [])\n+            }\n+\n+            ast::expr_break(label) => {\n+                let loop_scope = self.find_scope(expr, label);\n+                self.add_exiting_edge(expr, pred,\n+                                      loop_scope, loop_scope.break_index);\n+                self.add_node(expr.id, [])\n+            }\n+\n+            ast::expr_again(label) => {\n+                let loop_scope = self.find_scope(expr, label);\n+                self.add_exiting_edge(expr, pred,\n+                                      loop_scope, loop_scope.continue_index);\n+                self.add_node(expr.id, [])\n+            }\n+\n+            ast::expr_vec(ref elems, _) => {\n+                self.straightline(expr, pred, *elems)\n+            }\n+\n+            ast::expr_call(func, ref args, _) => {\n+                self.call(expr, pred, func, *args)\n+            }\n+\n+            ast::expr_method_call(_, rcvr, _, _, ref args, _) => {\n+                self.call(expr, pred, rcvr, *args)\n+            }\n+\n+            ast::expr_index(_, l, r) |\n+            ast::expr_binary(_, _, l, r) if self.is_method_call(expr) => {\n+                self.call(expr, pred, l, [r])\n+            }\n+\n+            ast::expr_unary(_, _, e) if self.is_method_call(expr) => {\n+                self.call(expr, pred, e, [])\n+            }\n+\n+            ast::expr_tup(ref exprs) => {\n+                self.straightline(expr, pred, *exprs)\n+            }\n+\n+            ast::expr_struct(_, ref fields, base) => {\n+                let base_exit = self.opt_expr(base, pred);\n+                let field_exprs: ~[@ast::expr] =\n+                    fields.iter().transform(|f| f.node.expr).collect();\n+                self.straightline(expr, base_exit, field_exprs)\n+            }\n+\n+            ast::expr_repeat(elem, count, _) => {\n+                self.straightline(expr, pred, [elem, count])\n+            }\n+\n+            ast::expr_assign(l, r) |\n+            ast::expr_assign_op(_, _, l, r) => {\n+                self.straightline(expr, pred, [r, l])\n+            }\n+\n+            ast::expr_log(l, r) |\n+            ast::expr_index(_, l, r) |\n+            ast::expr_binary(_, _, l, r) => { // NB: && and || handled earlier\n+                self.straightline(expr, pred, [l, r])\n+            }\n+\n+            ast::expr_addr_of(_, e) |\n+            ast::expr_copy(e) |\n+            ast::expr_loop_body(e) |\n+            ast::expr_do_body(e) |\n+            ast::expr_cast(e, _) |\n+            ast::expr_unary(_, _, e) |\n+            ast::expr_paren(e) |\n+            ast::expr_vstore(e, _) |\n+            ast::expr_field(e, _, _) => {\n+                self.straightline(expr, pred, [e])\n+            }\n+\n+            ast::expr_mac(*) |\n+            ast::expr_inline_asm(*) |\n+            ast::expr_self |\n+            ast::expr_fn_block(*) |\n+            ast::expr_lit(*) |\n+            ast::expr_path(*) => {\n+                self.straightline(expr, pred, [])\n+            }\n+        }\n+    }\n+\n+    fn call(&mut self,\n+            call_expr: @ast::expr,\n+            pred: CFGIndex,\n+            func_or_rcvr: @ast::expr,\n+            args: &[@ast::expr]) -> CFGIndex {\n+        let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n+        self.straightline(call_expr, func_or_rcvr_exit, args)\n+    }\n+\n+    fn exprs(&mut self,\n+             exprs: &[@ast::expr],\n+             pred: CFGIndex) -> CFGIndex {\n+        //! Constructs graph for `exprs` evaluated in order\n+\n+        exprs.iter().fold(pred, |p, &e| self.expr(e, p))\n+    }\n+\n+    fn opt_expr(&mut self,\n+                opt_expr: Option<@ast::expr>,\n+                pred: CFGIndex) -> CFGIndex {\n+        //! Constructs graph for `opt_expr` evaluated, if Some\n+\n+        opt_expr.iter().fold(pred, |p, &e| self.expr(e, p))\n+    }\n+\n+    fn straightline(&mut self,\n+                    expr: @ast::expr,\n+                    pred: CFGIndex,\n+                    subexprs: &[@ast::expr]) -> CFGIndex {\n+        //! Handles case of an expression that evaluates `subexprs` in order\n+\n+        let subexprs_exit = self.exprs(subexprs, pred);\n+        self.add_node(expr.id, [subexprs_exit])\n+    }\n+\n+    fn add_dummy_node(&mut self, preds: &[CFGIndex]) -> CFGIndex {\n+        self.add_node(0, preds)\n+    }\n+\n+    fn add_node(&mut self, id: ast::node_id, preds: &[CFGIndex]) -> CFGIndex {\n+        assert!(!self.exit_map.contains_key(&id));\n+        let node = self.graph.add_node(CFGNodeData {id: id});\n+        self.exit_map.insert(id, node);\n+        for preds.iter().advance |&pred| {\n+            self.add_contained_edge(pred, node);\n+        }\n+        node\n+    }\n+\n+    fn add_contained_edge(&mut self,\n+                          source: CFGIndex,\n+                          target: CFGIndex) {\n+        let data = CFGEdgeData {exiting_scopes: opt_vec::Empty};\n+        self.graph.add_edge(source, target, data);\n+    }\n+\n+    fn add_exiting_edge(&mut self,\n+                        from_expr: @ast::expr,\n+                        from_index: CFGIndex,\n+                        to_loop: LoopScope,\n+                        to_index: CFGIndex) {\n+        let mut data = CFGEdgeData {exiting_scopes: opt_vec::Empty};\n+        let mut scope_id = from_expr.id;\n+        while scope_id != to_loop.loop_id {\n+            data.exiting_scopes.push(scope_id);\n+            scope_id = self.tcx.region_maps.encl_scope(scope_id);\n+        }\n+        self.graph.add_edge(from_index, to_index, data);\n+    }\n+\n+    fn find_scope(&self,\n+                  expr: @ast::expr,\n+                  label: Option<ast::ident>) -> LoopScope {\n+        match label {\n+            None => {\n+                return *self.loop_scopes.last();\n+            }\n+\n+            Some(_) => {\n+                match self.tcx.def_map.find(&expr.id) {\n+                    Some(&ast::def_label(loop_id)) => {\n+                        for self.loop_scopes.iter().advance |l| {\n+                            if l.loop_id == loop_id {\n+                                return *l;\n+                            }\n+                        }\n+                        self.tcx.sess.span_bug(\n+                            expr.span,\n+                            fmt!(\"No loop scope for id %?\", loop_id));\n+                    }\n+\n+                    r => {\n+                        self.tcx.sess.span_bug(\n+                            expr.span,\n+                            fmt!(\"Bad entry `%?` in def_map for label\", r));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn is_method_call(&self, expr: &ast::expr) -> bool {\n+        self.method_map.contains_key(&expr.id)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "68aee78f28fe451477dd21199ea468148ee067a1", "filename": "src/librustc/middle/cfg/mod.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=9a9c84fb8362c26f24b1ea8443a509047f27b38f", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Module that constructs a control-flow graph representing an item.\n+Uses `Graph` as the underlying representation.\n+\n+*/\n+\n+use middle::graph;\n+use middle::ty;\n+use middle::typeck;\n+use std::hashmap::HashMap;\n+use syntax::ast;\n+use syntax::opt_vec::OptVec;\n+\n+mod construct;\n+\n+pub struct CFG {\n+    exit_map: HashMap<ast::node_id, CFGIndex>,\n+    graph: CFGGraph,\n+    entry: CFGIndex,\n+    exit: CFGIndex,\n+}\n+\n+pub struct CFGNodeData {\n+    id: ast::node_id\n+}\n+\n+pub struct CFGEdgeData {\n+    exiting_scopes: OptVec<ast::node_id>\n+}\n+\n+pub type CFGIndex = graph::NodeIndex;\n+\n+pub type CFGGraph = graph::Graph<CFGNodeData, CFGEdgeData>;\n+\n+pub type CFGNode = graph::Node<CFGNodeData>;\n+\n+pub type CFGEdge = graph::Edge<CFGEdgeData>;\n+\n+pub struct CFGIndices {\n+    entry: CFGIndex,\n+    exit: CFGIndex,\n+}\n+\n+impl CFG {\n+    pub fn new(tcx: ty::ctxt,\n+               method_map: typeck::method_map,\n+               blk: &ast::blk) -> CFG {\n+        construct::construct(tcx, method_map, blk)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "e37df6eda2d84036144bde6e5371686114b89612", "filename": "src/librustc/middle/graph.rs", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=9a9c84fb8362c26f24b1ea8443a509047f27b38f", "patch": "@@ -0,0 +1,410 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+A graph module for use in dataflow, region resolution, and elsewhere.\n+\n+# Interface details\n+\n+You customize the graph by specifying a \"node data\" type `N` and an\n+\"edge data\" type `E`. You can then later gain access (mutable or\n+immutable) to these \"user-data\" bits. Currently, you can only add\n+nodes or edges to the graph. You cannot remove or modify them once\n+added. This could be changed if we have a need.\n+\n+# Implementation details\n+\n+The main tricky thing about this code is the way that edges are\n+stored. The edges are stored in a central array, but they are also\n+threaded onto two linked lists for each node, one for incoming edges\n+and one for outgoing edges. Note that every edge is a member of some\n+incoming list and some outgoing list.  Basically you can load the\n+first index of the linked list from the node data structures (the\n+field `first_edge`) and then, for each edge, load the next index from\n+the field `next_edge`). Each of those fields is an array that should\n+be indexed by the direction (see the type `Direction`).\n+\n+*/\n+\n+use std::uint;\n+use std::vec;\n+\n+pub struct Graph<N,E> {\n+    priv nodes: ~[Node<N>],\n+    priv edges: ~[Edge<E>],\n+}\n+\n+pub struct Node<N> {\n+    priv first_edge: [EdgeIndex, ..2], // see module comment\n+    data: N,\n+}\n+\n+pub struct Edge<E> {\n+    priv next_edge: [EdgeIndex, ..2], // see module comment\n+    priv source: NodeIndex,\n+    priv target: NodeIndex,\n+    data: E,\n+}\n+\n+#[deriving(Eq)]\n+pub struct NodeIndex(uint);\n+pub static InvalidNodeIndex: NodeIndex = NodeIndex(uint::max_value);\n+\n+#[deriving(Eq)]\n+pub struct EdgeIndex(uint);\n+pub static InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::max_value);\n+\n+// Use a private field here to guarantee no more instances are created:\n+pub struct Direction { priv repr: uint }\n+pub static Outgoing: Direction = Direction { repr: 0 };\n+pub static Incoming: Direction = Direction { repr: 1 };\n+\n+impl<N,E> Graph<N,E> {\n+    pub fn new() -> Graph<N,E> {\n+        Graph {nodes: ~[], edges: ~[]}\n+    }\n+\n+    pub fn with_capacity(num_nodes: uint,\n+                         num_edges: uint) -> Graph<N,E> {\n+        Graph {nodes: vec::with_capacity(num_nodes),\n+               edges: vec::with_capacity(num_edges)}\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Simple accessors\n+\n+    #[inline]\n+    pub fn all_nodes<'a>(&'a self) -> &'a [Node<N>] {\n+        let nodes: &'a [Node<N>] = self.nodes;\n+        nodes\n+    }\n+\n+    #[inline]\n+    pub fn all_edges<'a>(&'a self) -> &'a [Edge<E>] {\n+        let edges: &'a [Edge<E>] = self.edges;\n+        edges\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Node construction\n+\n+    pub fn next_node_index(&self) -> NodeIndex {\n+        NodeIndex(self.nodes.len())\n+    }\n+\n+    pub fn add_node(&mut self, data: N) -> NodeIndex {\n+        let idx = self.next_node_index();\n+        self.nodes.push(Node {\n+            first_edge: [InvalidEdgeIndex, InvalidEdgeIndex],\n+            data: data\n+        });\n+        idx\n+    }\n+\n+    pub fn mut_node_data<'a>(&'a mut self, idx: NodeIndex) -> &'a mut N {\n+        &mut self.nodes[*idx].data\n+    }\n+\n+    pub fn node_data<'a>(&'a self, idx: NodeIndex) -> &'a N {\n+        &self.nodes[*idx].data\n+    }\n+\n+    pub fn node<'a>(&'a self, idx: NodeIndex) -> &'a Node<N> {\n+        &self.nodes[*idx]\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Edge construction and queries\n+\n+    pub fn next_edge_index(&self) -> EdgeIndex {\n+        EdgeIndex(self.edges.len())\n+    }\n+\n+    pub fn add_edge(&mut self,\n+                    source: NodeIndex,\n+                    target: NodeIndex,\n+                    data: E) -> EdgeIndex {\n+        let idx = self.next_edge_index();\n+\n+        // read current first of the list of edges from each node\n+        let source_first = self.nodes[*source].first_edge[Outgoing.repr];\n+        let target_first = self.nodes[*target].first_edge[Incoming.repr];\n+\n+        // create the new edge, with the previous firsts from each node\n+        // as the next pointers\n+        self.edges.push(Edge {\n+            next_edge: [source_first, target_first],\n+            source: source,\n+            target: target,\n+            data: data\n+        });\n+\n+        // adjust the firsts for each node target be the next object.\n+        self.nodes[*source].first_edge[Outgoing.repr] = idx;\n+        self.nodes[*target].first_edge[Incoming.repr] = idx;\n+\n+        return idx;\n+    }\n+\n+    pub fn mut_edge_data<'a>(&'a mut self, idx: EdgeIndex) -> &'a mut E {\n+        &mut self.edges[*idx].data\n+    }\n+\n+    pub fn edge_data<'a>(&'a self, idx: EdgeIndex) -> &'a E {\n+        &self.edges[*idx].data\n+    }\n+\n+    pub fn edge<'a>(&'a self, idx: EdgeIndex) -> &'a Edge<E> {\n+        &self.edges[*idx]\n+    }\n+\n+    pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n+        //! Accesses the index of the first edge adjacent to `node`.\n+        //! This is useful if you wish to modify the graph while walking\n+        //! the linked list of edges.\n+\n+        self.nodes[*node].first_edge[dir.repr]\n+    }\n+\n+    pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n+        //! Accesses the next edge in a given direction.\n+        //! This is useful if you wish to modify the graph while walking\n+        //! the linked list of edges.\n+\n+        self.edges[*edge].next_edge[dir.repr]\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Iterating over nodes, edges\n+\n+    pub fn each_node(&self, f: &fn(NodeIndex, &Node<N>) -> bool) -> bool {\n+        //! Iterates over all edges defined in the graph.\n+\n+        uint::range(0, self.nodes.len(),\n+                    |i| f(NodeIndex(i), &self.nodes[i]))\n+    }\n+\n+    pub fn each_edge(&self, f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+        //! Iterates over all edges defined in the graph.\n+\n+        uint::range(0, self.nodes.len(),\n+                    |i| f(EdgeIndex(i), &self.edges[i]))\n+    }\n+\n+    pub fn each_outgoing_edge(&self,\n+                              source: NodeIndex,\n+                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+        //! Iterates over all outgoing edges from the node `from`\n+\n+        self.each_adjacent_edge(source, Outgoing, f)\n+    }\n+\n+    pub fn each_incoming_edge(&self,\n+                              target: NodeIndex,\n+                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+        //! Iterates over all incoming edges to the node `target`\n+\n+        self.each_adjacent_edge(target, Incoming, f)\n+    }\n+\n+    pub fn each_adjacent_edge(&self,\n+                              node: NodeIndex,\n+                              dir: Direction,\n+                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+        //! Iterates over all edges adjacent to the node `node`\n+        //! in the direction `dir` (either `Outgoing` or `Incoming)\n+\n+        let mut edge_idx = self.first_adjacent(node, dir);\n+        while edge_idx != InvalidEdgeIndex {\n+            let edge = &self.edges[*edge_idx];\n+            if !f(edge_idx, edge) {\n+                return false;\n+            }\n+            edge_idx = edge.next_edge[dir.repr];\n+        }\n+        return true;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Fixed-point iteration\n+    //\n+    // A common use for graphs in our compiler is to perform\n+    // fixed-point iteration. In this case, each edge represents a\n+    // constaint, and the nodes themselves are associated with\n+    // variables or other bitsets. This method facilitates such a\n+    // computation.\n+\n+    pub fn iterate_until_fixed_point(&self,\n+                                     op: &fn(iter_index: uint,\n+                                             edge_index: EdgeIndex,\n+                                             edge: &Edge<E>) -> bool) {\n+        let mut iteration = 0;\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            iteration += 1;\n+            for self.edges.iter().enumerate().advance |(i, edge)| {\n+                changed |= op(iteration, EdgeIndex(i), edge);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn each_edge_index(max_edge_index: EdgeIndex, f: &fn(EdgeIndex) -> bool) {\n+    let mut i = 0;\n+    let n = *max_edge_index;\n+    while i < n {\n+        if !f(EdgeIndex(i)) {\n+            return;\n+        }\n+        i += 1;\n+    }\n+}\n+\n+impl<E> Edge<E> {\n+    pub fn source(&self) -> NodeIndex {\n+        self.source\n+    }\n+\n+    pub fn target(&self) -> NodeIndex {\n+        self.target\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use middle::graph::*;\n+\n+    type TestNode = Node<&'static str>;\n+    type TestEdge = Edge<&'static str>;\n+    type TestGraph = Graph<&'static str, &'static str>;\n+\n+    fn create_graph() -> TestGraph {\n+        let mut graph = Graph::new();\n+\n+        // Create a simple graph\n+        //\n+        //    A -+> B --> C\n+        //       |  |     ^\n+        //       |  v     |\n+        //       F  D --> E\n+\n+        let a = graph.add_node(\"A\");\n+        let b = graph.add_node(\"B\");\n+        let c = graph.add_node(\"C\");\n+        let d = graph.add_node(\"D\");\n+        let e = graph.add_node(\"E\");\n+        let f = graph.add_node(\"F\");\n+\n+        graph.add_edge(a, b, \"AB\");\n+        graph.add_edge(b, c, \"BC\");\n+        graph.add_edge(b, d, \"BD\");\n+        graph.add_edge(d, e, \"DE\");\n+        graph.add_edge(e, c, \"EC\");\n+        graph.add_edge(f, b, \"FB\");\n+\n+        return graph;\n+    }\n+\n+    #[test]\n+    fn each_node() {\n+        let graph = create_graph();\n+        let expected = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n+        for graph.each_node |idx, node| {\n+            assert_eq!(&expected[*idx], graph.node_data(idx));\n+            assert_eq!(expected[*idx], node.data);\n+        }\n+    }\n+\n+    #[test]\n+    fn each_edge() {\n+        let graph = create_graph();\n+        let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n+        for graph.each_edge |idx, edge| {\n+            assert_eq!(&expected[*idx], graph.edge_data(idx));\n+            assert_eq!(expected[*idx], edge.data);\n+        }\n+    }\n+\n+    fn test_adjacent_edges<N:Eq,E:Eq>(graph: &Graph<N,E>,\n+                                      start_index: NodeIndex,\n+                                      start_data: N,\n+                                      expected_incoming: &[(E,N)],\n+                                      expected_outgoing: &[(E,N)]) {\n+        assert_eq!(graph.node_data(start_index), &start_data);\n+\n+        let mut counter = 0;\n+        for graph.each_incoming_edge(start_index) |edge_index, edge| {\n+            assert_eq!(graph.edge_data(edge_index), &edge.data);\n+            assert!(counter < expected_incoming.len());\n+            debug!(\"counter=%? expected=%? edge_index=%? edge=%?\",\n+                   counter, expected_incoming[counter], edge_index, edge);\n+            match expected_incoming[counter] {\n+                (ref e, ref n) => {\n+                    assert_eq!(e, &edge.data);\n+                    assert_eq!(n, graph.node_data(edge.source));\n+                    assert_eq!(start_index, edge.target);\n+                }\n+            }\n+            counter += 1;\n+        }\n+        assert_eq!(counter, expected_incoming.len());\n+\n+        let mut counter = 0;\n+        for graph.each_outgoing_edge(start_index) |edge_index, edge| {\n+            assert_eq!(graph.edge_data(edge_index), &edge.data);\n+            assert!(counter < expected_outgoing.len());\n+            debug!(\"counter=%? expected=%? edge_index=%? edge=%?\",\n+                   counter, expected_outgoing[counter], edge_index, edge);\n+            match expected_outgoing[counter] {\n+                (ref e, ref n) => {\n+                    assert_eq!(e, &edge.data);\n+                    assert_eq!(start_index, edge.source);\n+                    assert_eq!(n, graph.node_data(edge.target));\n+                }\n+            }\n+            counter += 1;\n+        }\n+        assert_eq!(counter, expected_outgoing.len());\n+    }\n+\n+    #[test]\n+    fn each_adjacent_from_a() {\n+        let graph = create_graph();\n+        test_adjacent_edges(&graph, NodeIndex(0), \"A\",\n+                            [],\n+                            [(\"AB\", \"B\")]);\n+    }\n+\n+    #[test]\n+    fn each_adjacent_from_b() {\n+        let graph = create_graph();\n+        test_adjacent_edges(&graph, NodeIndex(1), \"B\",\n+                            [(\"FB\", \"F\"), (\"AB\", \"A\"),],\n+                            [(\"BD\", \"D\"), (\"BC\", \"C\"),]);\n+    }\n+\n+    #[test]\n+    fn each_adjacent_from_c() {\n+        let graph = create_graph();\n+        test_adjacent_edges(&graph, NodeIndex(2), \"C\",\n+                            [(\"EC\", \"E\"), (\"BC\", \"B\")],\n+                            []);\n+    }\n+\n+    #[test]\n+    fn each_adjacent_from_d() {\n+        let graph = create_graph();\n+        test_adjacent_edges(&graph, NodeIndex(3), \"D\",\n+                            [(\"BD\", \"B\")],\n+                            [(\"DE\", \"E\")]);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "4c401af8e8ed8eca3f93cb6b6a6d0c6fb5d179e4", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=9a9c84fb8362c26f24b1ea8443a509047f27b38f", "patch": "@@ -548,7 +548,6 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n \n     let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n-    let bcx = bcx;\n \n     // Load the vtable from the @Trait pair\n     debug!(\"(translating trait callee) loading vtable from pair %s\","}, {"sha": "21f3fdf7b2cfea39942a9997427e2ada86621fbf", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=9a9c84fb8362c26f24b1ea8443a509047f27b38f", "patch": "@@ -372,9 +372,9 @@ impl ErrorReporting for InferCtxt {\n                     sup,\n                     \"\");\n             }\n-            infer::ReferenceOutlivesReferent(ty, _) => {\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_err(\n-                    origin.span(),\n+                    span,\n                     fmt!(\"in type `%s`, pointer has a longer lifetime than \\\n                           the data it references\",\n                          ty.user_string(self.tcx)));"}, {"sha": "c3b35aba5181be6254e2d0956a77e058ef85a0f8", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 173, "deletions": 192, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=9a9c84fb8362c26f24b1ea8443a509047f27b38f", "patch": "@@ -18,6 +18,8 @@ use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n use middle::typeck::infer::cres;\n use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin};\n use middle::typeck::infer;\n+use middle::graph;\n+use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n use util::ppaux::{Repr};\n \n@@ -105,7 +107,7 @@ pub struct RegionVarBindings {\n     // This contains the results of inference.  It begins as an empty\n     // cell and only acquires a value after inference is complete.\n     // We use a cell vs a mutable option to circumvent borrowck errors.\n-    values: Cell<~[GraphNodeValue]>,\n+    values: Cell<~[VarValue]>,\n }\n \n pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n@@ -168,7 +170,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn num_vars(&mut self) -> uint {\n+    pub fn num_vars(&self) -> uint {\n         self.var_origins.len()\n     }\n \n@@ -705,127 +707,59 @@ impl RegionVarBindings {\n \n // ______________________________________________________________________\n \n-#[deriving(Eq)]\n-enum Direction { Incoming = 0, Outgoing = 1 }\n-\n #[deriving(Eq)]\n enum Classification { Expanding, Contracting }\n \n-enum GraphNodeValue { NoValue, Value(Region), ErrorValue }\n+enum VarValue { NoValue, Value(Region), ErrorValue }\n \n-struct GraphNode {\n-    origin: RegionVariableOrigin,\n+struct VarData {\n     classification: Classification,\n-    value: GraphNodeValue,\n-    head_edge: [uint, ..2],\n-}\n-\n-struct GraphEdge {\n-    next_edge: [uint, ..2],\n-    constraint: Constraint,\n-}\n-\n-struct Graph {\n-    nodes: ~[GraphNode],\n-    edges: ~[GraphEdge],\n+    value: VarValue,\n }\n \n struct RegionAndOrigin {\n     region: Region,\n     origin: SubregionOrigin,\n }\n \n+type RegionGraph = graph::Graph<(), Constraint>;\n+\n impl RegionVarBindings {\n-    fn infer_variable_values(&mut self,\n+    fn infer_variable_values(&self,\n                              errors: &mut OptVec<RegionResolutionError>)\n-                             -> ~[GraphNodeValue] {\n-        let mut graph = self.construct_graph();\n-        self.expansion(&mut graph);\n-        self.contraction(&mut graph);\n-        self.collect_concrete_region_errors(&graph, errors);\n-        self.extract_values_and_collect_conflicts(&graph, errors)\n+                             -> ~[VarValue] {\n+        let mut var_data = self.construct_var_data();\n+        self.expansion(var_data);\n+        self.contraction(var_data);\n+        self.collect_concrete_region_errors(errors);\n+        self.extract_values_and_collect_conflicts(var_data, errors)\n     }\n \n-    fn construct_graph(&mut self) -> Graph {\n-        let num_vars = self.num_vars();\n-        let num_edges = self.constraints.len();\n-\n-        let nodes = vec::from_fn(num_vars, |var_idx| {\n-            GraphNode {\n+    fn construct_var_data(&self) -> ~[VarData] {\n+        vec::from_fn(self.num_vars(), |_| {\n+            VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n                 // those nodes that have a concrete region predecessor to\n                 // Expanding.\n                 classification: Contracting,\n-                origin: self.var_origins[var_idx],\n                 value: NoValue,\n-                head_edge: [uint::max_value, uint::max_value]\n-            }\n-        });\n-\n-        // It would be nice to write this using map():\n-        let mut edges = vec::with_capacity(num_edges);\n-        for self.constraints.iter().advance |(constraint, _)| {\n-            edges.push(GraphEdge {\n-                next_edge: [uint::max_value, uint::max_value],\n-                constraint: *constraint,\n-            });\n-        }\n-\n-        let mut graph = Graph {\n-            nodes: nodes,\n-            edges: edges\n-        };\n-\n-        for uint::range(0, num_edges) |edge_idx| {\n-            match graph.edges[edge_idx].constraint {\n-              ConstrainVarSubVar(a_id, b_id) => {\n-                insert_edge(&mut graph, a_id, Outgoing, edge_idx);\n-                insert_edge(&mut graph, b_id, Incoming, edge_idx);\n-              }\n-              ConstrainRegSubVar(_, b_id) => {\n-                insert_edge(&mut graph, b_id, Incoming, edge_idx);\n-              }\n-              ConstrainVarSubReg(a_id, _) => {\n-                insert_edge(&mut graph, a_id, Outgoing, edge_idx);\n-              }\n-              ConstrainRegSubReg(*) => {\n-                  // Relations between two concrete regions do not\n-                  // require an edge in the graph.\n-              }\n             }\n-        }\n-\n-        return (graph);\n-\n-        fn insert_edge(graph: &mut Graph,\n-                       node_id: RegionVid,\n-                       edge_dir: Direction,\n-                       edge_idx: uint) {\n-            //! Insert edge `edge_idx` on the link list of edges in direction\n-            //! `edge_dir` for the node `node_id`\n-            let edge_dir = edge_dir as uint;\n-            assert_eq!(graph.edges[edge_idx].next_edge[edge_dir],\n-                       uint::max_value);\n-            let n = node_id.to_uint();\n-            let prev_head = graph.nodes[n].head_edge[edge_dir];\n-            graph.edges[edge_idx].next_edge[edge_dir] = prev_head;\n-            graph.nodes[n].head_edge[edge_dir] = edge_idx;\n-        }\n+        })\n     }\n \n-    fn expansion(&mut self, graph: &mut Graph) {\n-        do iterate_until_fixed_point(~\"Expansion\", graph) |nodes, edge| {\n-            match edge.constraint {\n+    fn expansion(&self, var_data: &mut [VarData]) {\n+        do self.iterate_until_fixed_point(\"Expansion\") |constraint| {\n+            match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n-                let b_node = &mut nodes[b_vid.to_uint()];\n-                self.expand_node(a_region, b_vid, b_node)\n+                let b_data = &mut var_data[b_vid.to_uint()];\n+                self.expand_node(a_region, b_vid, b_data)\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match nodes[a_vid.to_uint()].value {\n+                match var_data[a_vid.to_uint()].value {\n                   NoValue | ErrorValue => false,\n                   Value(a_region) => {\n-                    let b_node = &mut nodes[b_vid.to_uint()];\n+                    let b_node = &mut var_data[b_vid.to_uint()];\n                     self.expand_node(a_region, b_vid, b_node)\n                   }\n                 }\n@@ -842,20 +776,20 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn expand_node(&mut self,\n+    fn expand_node(&self,\n                    a_region: Region,\n                    b_vid: RegionVid,\n-                   b_node: &mut GraphNode)\n+                   b_data: &mut VarData)\n                    -> bool {\n         debug!(\"expand_node(%?, %? == %?)\",\n-               a_region, b_vid, b_node.value);\n+               a_region, b_vid, b_data.value);\n \n-        b_node.classification = Expanding;\n-        match b_node.value {\n+        b_data.classification = Expanding;\n+        match b_data.value {\n           NoValue => {\n             debug!(\"Setting initial value of %? to %?\", b_vid, a_region);\n \n-            b_node.value = Value(a_region);\n+            b_data.value = Value(a_region);\n             return true;\n           }\n \n@@ -868,7 +802,7 @@ impl RegionVarBindings {\n             debug!(\"Expanding value of %? from %? to %?\",\n                    b_vid, cur_region, lub);\n \n-            b_node.value = Value(lub);\n+            b_data.value = Value(lub);\n             return true;\n           }\n \n@@ -878,26 +812,26 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn contraction(&mut self,\n-                   graph: &mut Graph) {\n-        do iterate_until_fixed_point(~\"Contraction\", graph) |nodes, edge| {\n-            match edge.constraint {\n+    fn contraction(&self,\n+                   var_data: &mut [VarData]) {\n+        do self.iterate_until_fixed_point(\"Contraction\") |constraint| {\n+            match *constraint {\n               ConstrainRegSubVar(*) => {\n                 // This is an expansion constraint.  Ignore.\n                 false\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match nodes[b_vid.to_uint()].value {\n+                match var_data[b_vid.to_uint()].value {\n                   NoValue | ErrorValue => false,\n                   Value(b_region) => {\n-                    let a_node = &mut nodes[a_vid.to_uint()];\n-                    self.contract_node(a_vid, a_node, b_region)\n+                    let a_data = &mut var_data[a_vid.to_uint()];\n+                    self.contract_node(a_vid, a_data, b_region)\n                   }\n                 }\n               }\n               ConstrainVarSubReg(a_vid, b_region) => {\n-                let a_node = &mut nodes[a_vid.to_uint()];\n-                self.contract_node(a_vid, a_node, b_region)\n+                let a_data = &mut var_data[a_vid.to_uint()];\n+                self.contract_node(a_vid, a_data, b_region)\n               }\n               ConstrainRegSubReg(*) => {\n                 // No region variables involved. Ignore.\n@@ -907,18 +841,18 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn contract_node(&mut self,\n+    fn contract_node(&self,\n                      a_vid: RegionVid,\n-                     a_node: &mut GraphNode,\n+                     a_data: &mut VarData,\n                      b_region: Region)\n                      -> bool {\n         debug!(\"contract_node(%? == %?/%?, %?)\",\n-               a_vid, a_node.value, a_node.classification, b_region);\n+               a_vid, a_data.value, a_data.classification, b_region);\n \n-        return match a_node.value {\n+        return match a_data.value {\n             NoValue => {\n-                assert_eq!(a_node.classification, Contracting);\n-                a_node.value = Value(b_region);\n+                assert_eq!(a_data.classification, Contracting);\n+                a_data.value = Value(b_region);\n                 true // changed\n             }\n \n@@ -927,34 +861,34 @@ impl RegionVarBindings {\n             }\n \n             Value(a_region) => {\n-                match a_node.classification {\n+                match a_data.classification {\n                     Expanding => {\n-                        check_node(self, a_vid, a_node, a_region, b_region)\n+                        check_node(self, a_vid, a_data, a_region, b_region)\n                     }\n                     Contracting => {\n-                        adjust_node(self, a_vid, a_node, a_region, b_region)\n+                        adjust_node(self, a_vid, a_data, a_region, b_region)\n                     }\n                 }\n             }\n         };\n \n-        fn check_node(this: &mut RegionVarBindings,\n+        fn check_node(this: &RegionVarBindings,\n                       a_vid: RegionVid,\n-                      a_node: &mut GraphNode,\n+                      a_data: &mut VarData,\n                       a_region: Region,\n                       b_region: Region)\n                    -> bool {\n             if !this.is_subregion_of(a_region, b_region) {\n                 debug!(\"Setting %? to ErrorValue: %? not subregion of %?\",\n                        a_vid, a_region, b_region);\n-                a_node.value = ErrorValue;\n+                a_data.value = ErrorValue;\n             }\n             false\n         }\n \n-        fn adjust_node(this: &mut RegionVarBindings,\n+        fn adjust_node(this: &RegionVarBindings,\n                        a_vid: RegionVid,\n-                       a_node: &mut GraphNode,\n+                       a_data: &mut VarData,\n                        a_region: Region,\n                        b_region: Region)\n                     -> bool {\n@@ -965,31 +899,26 @@ impl RegionVarBindings {\n                     } else {\n                         debug!(\"Contracting value of %? from %? to %?\",\n                                a_vid, a_region, glb);\n-                        a_node.value = Value(glb);\n+                        a_data.value = Value(glb);\n                         true\n                     }\n                 }\n                 Err(_) => {\n                     debug!(\"Setting %? to ErrorValue: no glb of %?, %?\",\n                            a_vid, a_region, b_region);\n-                    a_node.value = ErrorValue;\n+                    a_data.value = ErrorValue;\n                     false\n                 }\n             }\n         }\n     }\n \n     fn collect_concrete_region_errors(\n-        &mut self,\n-        graph: &Graph,\n+        &self,\n         errors: &mut OptVec<RegionResolutionError>)\n     {\n-        let num_edges = graph.edges.len();\n-        for uint::range(0, num_edges) |edge_idx| {\n-            let edge = &graph.edges[edge_idx];\n-            let origin = self.constraints.get_copy(&edge.constraint);\n-\n-            let (sub, sup) = match edge.constraint {\n+        for self.constraints.iter().advance |(constraint, _)| {\n+            let (sub, sup) = match *constraint {\n                 ConstrainVarSubVar(*) |\n                 ConstrainRegSubVar(*) |\n                 ConstrainVarSubReg(*) => {\n@@ -1006,15 +935,16 @@ impl RegionVarBindings {\n \n             debug!(\"ConcreteFailure: !(sub <= sup): sub=%?, sup=%?\",\n                    sub, sup);\n+            let origin = self.constraints.get_copy(constraint);\n             errors.push(ConcreteFailure(origin, sub, sup));\n         }\n     }\n \n     fn extract_values_and_collect_conflicts(\n-        &mut self,\n-        graph: &Graph,\n+        &self,\n+        var_data: &[VarData],\n         errors: &mut OptVec<RegionResolutionError>)\n-        -> ~[GraphNodeValue]\n+        -> ~[VarValue]\n     {\n         debug!(\"extract_values_and_collect_conflicts()\");\n \n@@ -1029,10 +959,12 @@ impl RegionVarBindings {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = graph.nodes.map(|_| uint::max_value);\n+        let mut dup_vec = vec::from_elem(self.num_vars(), uint::max_value);\n+\n+        let mut opt_graph = None;\n \n-        graph.nodes.iter().enumerate().transform(|(idx, node)| {\n-            match node.value {\n+        for uint::range(0, self.num_vars()) |idx| {\n+            match var_data[idx].value {\n                 Value(_) => {\n                     /* Inference successful */\n                 }\n@@ -1066,37 +998,84 @@ impl RegionVarBindings {\n                        starts to create problems we'll have to revisit\n                        this portion of the code and think hard about it. =) */\n \n+                    if opt_graph.is_none() {\n+                        opt_graph = Some(self.construct_graph());\n+                    }\n+                    let graph = opt_graph.get_ref();\n+\n                     let node_vid = RegionVid { id: idx };\n-                    match node.classification {\n+                    match var_data[idx].classification {\n                         Expanding => {\n                             self.collect_error_for_expanding_node(\n-                                graph, dup_vec, node_vid, errors);\n+                                graph, var_data, dup_vec, node_vid, errors);\n                         }\n                         Contracting => {\n                             self.collect_error_for_contracting_node(\n-                                graph, dup_vec, node_vid, errors);\n+                                graph, var_data, dup_vec, node_vid, errors);\n                         }\n                     }\n                 }\n             }\n+        }\n \n-            node.value\n-        }).collect()\n+        vec::from_fn(self.num_vars(), |idx| var_data[idx].value)\n+    }\n+\n+    fn construct_graph(&self) -> RegionGraph {\n+        let num_vars = self.num_vars();\n+        let num_edges = self.constraints.len();\n+\n+        let mut graph = graph::Graph::with_capacity(num_vars + 1,\n+                                                    num_edges);\n+\n+        for uint::range(0, num_vars) |_| {\n+            graph.add_node(());\n+        }\n+        let dummy_idx = graph.add_node(());\n+\n+        for self.constraints.iter().advance |(constraint, _)| {\n+            match *constraint {\n+                ConstrainVarSubVar(a_id, b_id) => {\n+                    graph.add_edge(NodeIndex(a_id.to_uint()),\n+                                   NodeIndex(b_id.to_uint()),\n+                                   *constraint);\n+                }\n+                ConstrainRegSubVar(_, b_id) => {\n+                    graph.add_edge(dummy_idx,\n+                                   NodeIndex(b_id.to_uint()),\n+                                   *constraint);\n+                }\n+                ConstrainVarSubReg(a_id, _) => {\n+                    graph.add_edge(NodeIndex(a_id.to_uint()),\n+                                   dummy_idx,\n+                                   *constraint);\n+                }\n+                ConstrainRegSubReg(*) => {\n+                    // Relations between two concrete regions do not\n+                    // require an edge in the graph.\n+                }\n+            }\n+        }\n+\n+        return graph;\n     }\n \n     fn collect_error_for_expanding_node(\n-        &mut self,\n-        graph: &Graph,\n+        &self,\n+        graph: &RegionGraph,\n+        var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n         errors: &mut OptVec<RegionResolutionError>)\n     {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n         let (lower_bounds, lower_dup) =\n-            self.collect_concrete_regions(graph, node_idx, Incoming, dup_vec);\n+            self.collect_concrete_regions(graph, var_data, node_idx,\n+                                          graph::Incoming, dup_vec);\n         let (upper_bounds, upper_dup) =\n-            self.collect_concrete_regions(graph, node_idx, Outgoing, dup_vec);\n+            self.collect_concrete_regions(graph, var_data, node_idx,\n+                                          graph::Outgoing, dup_vec);\n \n         if lower_dup || upper_dup {\n             return;\n@@ -1127,16 +1106,18 @@ impl RegionVarBindings {\n     }\n \n     fn collect_error_for_contracting_node(\n-        &mut self,\n-        graph: &Graph,\n+        &self,\n+        graph: &RegionGraph,\n+        var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n         errors: &mut OptVec<RegionResolutionError>)\n     {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection.\n         let (upper_bounds, dup_found) =\n-            self.collect_concrete_regions(graph, node_idx, Outgoing, dup_vec);\n+            self.collect_concrete_regions(graph, var_data, node_idx,\n+                                          graph::Outgoing, dup_vec);\n \n         if dup_found {\n             return;\n@@ -1168,8 +1149,9 @@ impl RegionVarBindings {\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n-    fn collect_concrete_regions(&mut self,\n-                                graph: &Graph,\n+    fn collect_concrete_regions(&self,\n+                                graph: &RegionGraph,\n+                                var_data: &[VarData],\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n                                 dup_vec: &mut [uint])\n@@ -1194,7 +1176,7 @@ impl RegionVarBindings {\n \n         while !state.stack.is_empty() {\n             let node_idx = state.stack.pop();\n-            let classification = graph.nodes[node_idx.to_uint()].classification;\n+            let classification = var_data[node_idx.to_uint()].classification;\n \n             // check whether we've visited this node on some previous walk\n             if dup_vec[node_idx.to_uint()] == uint::max_value {\n@@ -1210,8 +1192,8 @@ impl RegionVarBindings {\n             // figure out the direction from which this node takes its\n             // values, and search for concrete regions etc in that direction\n             let dir = match classification {\n-                Expanding => Incoming,\n-                Contracting => Outgoing\n+                Expanding => graph::Incoming,\n+                Contracting => graph::Outgoing,\n             };\n \n             process_edges(self, &mut state, graph, node_idx, dir);\n@@ -1220,15 +1202,16 @@ impl RegionVarBindings {\n         let WalkState {result, dup_found, _} = state;\n         return (result, dup_found);\n \n-        fn process_edges(this: &mut RegionVarBindings,\n+        fn process_edges(this: &RegionVarBindings,\n                          state: &mut WalkState,\n-                         graph: &Graph,\n+                         graph: &RegionGraph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n             debug!(\"process_edges(source_vid=%?, dir=%?)\", source_vid, dir);\n \n-            for this.each_edge(graph, source_vid, dir) |edge| {\n-                match edge.constraint {\n+            let source_node_index = NodeIndex(source_vid.to_uint());\n+            for graph.each_adjacent_edge(source_node_index, dir) |_, edge| {\n+                match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n                         let opp_vid =\n                             if from_vid == source_vid {to_vid} else {from_vid};\n@@ -1241,7 +1224,7 @@ impl RegionVarBindings {\n                     ConstrainVarSubReg(_, region) => {\n                         state.result.push(RegionAndOrigin {\n                             region: region,\n-                            origin: this.constraints.get_copy(&edge.constraint)\n+                            origin: this.constraints.get_copy(&edge.data)\n                         });\n                     }\n \n@@ -1251,42 +1234,40 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn each_edge(&self,\n-                     graph: &Graph,\n-                     node_idx: RegionVid,\n-                     dir: Direction,\n-                     op: &fn(edge: &GraphEdge) -> bool)\n-                     -> bool {\n-        let mut edge_idx =\n-            graph.nodes[node_idx.to_uint()].head_edge[dir as uint];\n-        while edge_idx != uint::max_value {\n-            let edge_ptr = &graph.edges[edge_idx];\n-            if !op(edge_ptr) {\n-                return false;\n+    fn iterate_until_fixed_point(&self,\n+                                 tag: &str,\n+                                 body: &fn(constraint: &Constraint) -> bool) {\n+        let mut iteration = 0;\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            iteration += 1;\n+            debug!(\"---- %s Iteration #%u\", tag, iteration);\n+            for self.constraints.iter().advance |(constraint, _)| {\n+                let edge_changed = body(constraint);\n+                if edge_changed {\n+                    debug!(\"Updated due to constraint %s\",\n+                           constraint.repr(self.tcx));\n+                    changed = true;\n+                }\n             }\n-            edge_idx = edge_ptr.next_edge[dir as uint];\n         }\n-        return true;\n+        debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n     }\n+\n }\n \n-fn iterate_until_fixed_point(\n-    tag: ~str,\n-    graph: &mut Graph,\n-    body: &fn(nodes: &mut [GraphNode], edge: &GraphEdge) -> bool)\n-{\n-    let mut iteration = 0;\n-    let mut changed = true;\n-    let num_edges = graph.edges.len();\n-    while changed {\n-        changed = false;\n-        iteration += 1;\n-        debug!(\"---- %s Iteration #%u\", tag, iteration);\n-        for uint::range(0, num_edges) |edge_idx| {\n-            changed |= body(graph.nodes, &graph.edges[edge_idx]);\n-            debug!(\" >> Change after edge #%?: %?\",\n-                   edge_idx, graph.edges[edge_idx]);\n+impl Repr for Constraint {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            ConstrainVarSubVar(a, b) => fmt!(\"ConstrainVarSubVar(%s, %s)\",\n+                                             a.repr(tcx), b.repr(tcx)),\n+            ConstrainRegSubVar(a, b) => fmt!(\"ConstrainRegSubVar(%s, %s)\",\n+                                             a.repr(tcx), b.repr(tcx)),\n+            ConstrainVarSubReg(a, b) => fmt!(\"ConstrainVarSubReg(%s, %s)\",\n+                                             a.repr(tcx), b.repr(tcx)),\n+            ConstrainRegSubReg(a, b) => fmt!(\"ConstrainRegSubReg(%s, %s)\",\n+                                             a.repr(tcx), b.repr(tcx)),\n         }\n     }\n-    debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n }"}, {"sha": "542183e24db7632fef35d4925b4e2d577c836f8d", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=9a9c84fb8362c26f24b1ea8443a509047f27b38f", "patch": "@@ -74,6 +74,9 @@ pub mod middle {\n     pub mod entry;\n     pub mod effect;\n     pub mod reachable;\n+    pub mod graph;\n+    #[path = \"cfg/mod.rs\"]\n+    pub mod cfg;\n }\n \n pub mod front {"}, {"sha": "07dd19a3fed80b132e278d4102cb7242878cb220", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a9c84fb8362c26f24b1ea8443a509047f27b38f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9a9c84fb8362c26f24b1ea8443a509047f27b38f", "patch": "@@ -751,6 +751,12 @@ impl Repr for typeck::method_param {\n     }\n }\n \n+impl Repr for ty::RegionVid {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        fmt!(\"%?\", *self)\n+    }\n+}\n+\n impl Repr for ty::TraitStore {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {"}]}