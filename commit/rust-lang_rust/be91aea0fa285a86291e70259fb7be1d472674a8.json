{"sha": "be91aea0fa285a86291e70259fb7be1d472674a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlOTFhZWEwZmEyODVhODYyOTFlNzAyNTlmYjdiZTFkNDcyNjc0YTg=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-08-07T13:22:11Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-08-07T13:22:11Z"}, "message": "Rustup", "tree": {"sha": "7700d101d70d367b4315bb2eaa4c8b614a194728", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7700d101d70d367b4315bb2eaa4c8b614a194728"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be91aea0fa285a86291e70259fb7be1d472674a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be91aea0fa285a86291e70259fb7be1d472674a8", "html_url": "https://github.com/rust-lang/rust/commit/be91aea0fa285a86291e70259fb7be1d472674a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be91aea0fa285a86291e70259fb7be1d472674a8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b784c81e8e66f74d2f43a59010abddc59bfbc69d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b784c81e8e66f74d2f43a59010abddc59bfbc69d", "html_url": "https://github.com/rust-lang/rust/commit/b784c81e8e66f74d2f43a59010abddc59bfbc69d"}], "stats": {"total": 419, "additions": 206, "deletions": 213}, "files": [{"sha": "57d49b2e6bc5fbb1fd607d4e1419b925dc5488c9", "filename": "src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=be91aea0fa285a86291e70259fb7be1d472674a8", "patch": "@@ -3,6 +3,7 @@\n extern crate getopts;\n extern crate miri;\n extern crate rustc;\n+extern crate rustc_metadata;\n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_codegen_utils;\n@@ -12,7 +13,7 @@ extern crate syntax;\n extern crate log;\n \n use rustc::session::Session;\n-use rustc::middle::cstore::CrateStore;\n+use rustc_metadata::cstore::CStore;\n use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n use rustc_driver::driver::{CompileState, CompileController};\n use rustc::session::config::{self, Input, ErrorOutputType};\n@@ -70,7 +71,7 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         codegen_backend: &CodegenBackend,\n         matches: &getopts::Matches,\n         sess: &Session,\n-        cstore: &CrateStore,\n+        cstore: &CStore,\n         input: &Input,\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>,"}, {"sha": "11b0ae345c7fdbae9d9ac4ed8d54f7c3df6be406", "filename": "src/fn_call.rs", "status": "modified", "additions": 76, "deletions": 66, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=be91aea0fa285a86291e70259fb7be1d472674a8", "patch": "@@ -37,7 +37,7 @@ fn write_discriminant_value<'a, 'mir, 'tcx: 'a + 'mir>(\n                     .val;\n \n                 let (discr_dest, discr) = ecx.place_field(dest, mir::Field::new(0), layout)?;\n-                ecx.write_scalar(discr_dest, Scalar::from_u128(discr_val), discr.ty)?;\n+                ecx.write_scalar(discr_dest, Scalar::from_uint(discr_val, discr.size), discr.ty)?;\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n@@ -50,7 +50,7 @@ fn write_discriminant_value<'a, 'mir, 'tcx: 'a + 'mir>(\n                         ecx.place_field(dest, mir::Field::new(0), layout)?;\n                     let niche_value = ((variant_index - niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n-                    ecx.write_scalar(niche_dest, Scalar::from_u128(niche_value), niche.ty)?;\n+                    ecx.write_scalar(niche_dest, Scalar::from_uint(niche_value, niche.size), niche.ty)?;\n                 }\n             }\n         }\n@@ -88,7 +88,7 @@ pub trait EvalContextExt<'tcx> {\n         sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool>;\n \n-    fn write_null(&mut self, dest: Place, dest_ty: Ty<'tcx>) -> EvalResult<'tcx>;\n+    fn write_null(&mut self, dest: Place, dest_layout: TyLayout<'tcx>) -> EvalResult<'tcx>;\n }\n \n impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n@@ -138,7 +138,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             let amt = 128 - self.memory.pointer_size().bytes() * 8;\n             let (dest, return_to_block) = destination.unwrap();\n             let ty = self.tcx.types.usize;\n-            self.write_scalar(dest, Scalar::from_u128((n << amt) >> amt), ty)?;\n+            let ptr_size = self.memory.pointer_size();\n+            self.write_scalar(dest, Scalar::from_uint((n << amt) >> amt, ptr_size), ty)?;\n             self.goto_block(return_to_block);\n             return Ok(true);\n         }\n@@ -187,12 +188,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             Some(name) => name.as_str(),\n             None => self.tcx.item_name(def_id).as_str(),\n         };\n+        let dest_layout = self.layout_of(dest_ty)?;\n \n         match &link_name[..] {\n             \"malloc\" => {\n                 let size = self.value_to_scalar(args[0])?.to_usize(self)?;\n                 if size == 0 {\n-                    self.write_null(dest, dest_ty)?;\n+                    self.write_null(dest, dest_layout)?;\n                 } else {\n                     let align = self.tcx.data_layout.pointer_align;\n                     let ptr = self.memory.allocate(Size::from_bytes(size), align, MemoryKind::C.into())?;\n@@ -201,8 +203,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n \n             \"free\" => {\n-                let ptr = self.into_ptr(args[0].value)?;\n-                if !ptr.is_null()? {\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n+                if !ptr.is_null() {\n                     self.memory.deallocate(\n                         ptr.to_ptr()?,\n                         None,\n@@ -241,7 +243,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n             }\n             \"__rust_dealloc\" => {\n-                let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?.to_ptr()?;\n                 let old_size = self.value_to_scalar(args[1])?.to_usize(self)?;\n                 let align = self.value_to_scalar(args[2])?.to_usize(self)?;\n                 if old_size == 0 {\n@@ -257,7 +259,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 )?;\n             }\n             \"__rust_realloc\" => {\n-                let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?.to_ptr()?;\n                 let old_size = self.value_to_scalar(args[1])?.to_usize(self)?;\n                 let align = self.value_to_scalar(args[2])?.to_usize(self)?;\n                 let new_size = self.value_to_scalar(args[3])?.to_usize(self)?;\n@@ -300,7 +302,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n \n             \"dlsym\" => {\n                 let _handle = self.into_ptr(args[0].value)?;\n-                let symbol = self.into_ptr(args[1].value)?.to_ptr()?;\n+                let symbol = self.into_ptr(args[1].value)?.unwrap_or_err()?.to_ptr()?;\n                 let symbol_name = self.memory.read_c_str(symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n@@ -314,10 +316,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n                 // We abort on panic, so not much is going on here, but we still have to call the closure\n                 let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                let f = self.into_ptr(args[0].value)?.to_ptr()?;\n-                let data = self.into_ptr(args[1].value)?;\n+                let f = self.into_ptr(args[0].value)?.unwrap_or_err()?.to_ptr()?;\n+                let data = self.into_ptr(args[1].value)?.unwrap_or_err()?;\n                 let f_instance = self.memory.get_fn(f)?;\n-                self.write_null(dest, dest_ty)?;\n+                self.write_null(dest, dest_layout)?;\n \n                 // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n                 // and of course eval_main.\n@@ -343,7 +345,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 assert!(args.next().is_none(), \"__rust_maybe_catch_panic argument has more arguments than expected\");\n \n                 // We ourselves return 0\n-                self.write_null(dest, dest_ty)?;\n+                self.write_null(dest, dest_layout)?;\n \n                 // Don't fall through\n                 return Ok(());\n@@ -354,8 +356,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n \n             \"memcmp\" => {\n-                let left = self.into_ptr(args[0].value)?;\n-                let right = self.into_ptr(args[1].value)?;\n+                let left = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n+                let right = self.into_ptr(args[1].value)?.unwrap_or_err()?;\n                 let n = Size::from_bytes(self.value_to_scalar(args[2])?.to_usize(self)?);\n \n                 let result = {\n@@ -378,7 +380,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n \n             \"memrchr\" => {\n-                let ptr = self.into_ptr(args[0].value)?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 let val = self.value_to_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.value_to_scalar(args[2])?.to_usize(self)?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().rev().position(\n@@ -388,12 +390,12 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n-                    self.write_null(dest, dest_ty)?;\n+                    self.write_null(dest, dest_layout)?;\n                 }\n             }\n \n             \"memchr\" => {\n-                let ptr = self.into_ptr(args[0].value)?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 let val = self.value_to_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.value_to_scalar(args[2])?.to_usize(self)?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n@@ -403,17 +405,17 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     let new_ptr = ptr.ptr_offset(Size::from_bytes(idx as u64), &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n-                    self.write_null(dest, dest_ty)?;\n+                    self.write_null(dest, dest_layout)?;\n                 }\n             }\n \n             \"getenv\" => {\n                 let result = {\n-                    let name_ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n+                    let name_ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?.to_ptr()?;\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     match self.machine.env_vars.get(name) {\n                         Some(&var) => Scalar::Ptr(var),\n-                        None => Scalar::null(),\n+                        None => Scalar::null(self.memory.pointer_size()),\n                     }\n                 };\n                 self.write_scalar(dest, result, dest_ty)?;\n@@ -422,8 +424,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             \"unsetenv\" => {\n                 let mut success = None;\n                 {\n-                    let name_ptr = self.into_ptr(args[0].value)?;\n-                    if !name_ptr.is_null()? {\n+                    let name_ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n+                    if !name_ptr.is_null() {\n                         let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             success = Some(self.machine.env_vars.remove(name));\n@@ -434,19 +436,19 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     if let Some(var) = old {\n                         self.memory.deallocate(var, None, MemoryKind::Env.into())?;\n                     }\n-                    self.write_null(dest, dest_ty)?;\n+                    self.write_null(dest, dest_layout)?;\n                 } else {\n-                    self.write_scalar(dest, Scalar::from_i128(-1), dest_ty)?;\n+                    self.write_scalar(dest, Scalar::from_int(-1, dest_layout.size), dest_ty)?;\n                 }\n             }\n \n             \"setenv\" => {\n                 let mut new = None;\n                 {\n-                    let name_ptr = self.into_ptr(args[0].value)?;\n-                    let value_ptr = self.into_ptr(args[1].value)?.to_ptr()?;\n+                    let name_ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n+                    let value_ptr = self.into_ptr(args[1].value)?.unwrap_or_err()?.to_ptr()?;\n                     let value = self.memory.read_c_str(value_ptr)?;\n-                    if !name_ptr.is_null()? {\n+                    if !name_ptr.is_null() {\n                         let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             new = Some((name.to_owned(), value.to_owned()));\n@@ -470,15 +472,15 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     {\n                         self.memory.deallocate(var, None, MemoryKind::Env.into())?;\n                     }\n-                    self.write_null(dest, dest_ty)?;\n+                    self.write_null(dest, dest_layout)?;\n                 } else {\n-                    self.write_scalar(dest, Scalar::from_i128(-1), dest_ty)?;\n+                    self.write_scalar(dest, Scalar::from_int(-1, dest_layout.size), dest_ty)?;\n                 }\n             }\n \n             \"write\" => {\n                 let fd = self.value_to_scalar(args[0])?.to_bytes()?;\n-                let buf = self.into_ptr(args[1].value)?;\n+                let buf = self.into_ptr(args[1].value)?.unwrap_or_err()?;\n                 let n = self.value_to_scalar(args[2])?.to_bytes()? as u64;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 {\n@@ -502,31 +504,33 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 let ptr_size = self.memory.pointer_size();\n                 self.write_scalar(\n                     dest,\n-                    Scalar::from_isize(result, ptr_size),\n+                    Scalar::from_int(result, ptr_size),\n                     dest_ty,\n                 )?;\n             }\n \n             \"strlen\" => {\n-                let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?.to_ptr()?;\n                 let n = self.memory.read_c_str(ptr)?.len();\n                 let ptr_size = self.memory.pointer_size();\n-                self.write_scalar(dest, Scalar::from_usize(n as u64, ptr_size), dest_ty)?;\n+                self.write_scalar(dest, Scalar::from_uint(n as u64, ptr_size), dest_ty)?;\n             }\n \n             // Some things needed for sys::thread initialization to go through\n             \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n-                self.write_scalar(dest, Scalar::null(), dest_ty)?;\n+                let ptr_size = self.memory.pointer_size();\n+                self.write_scalar(dest, Scalar::null(ptr_size), dest_ty)?;\n             }\n \n             \"sysconf\" => {\n                 let name = self.value_to_scalar(args[0])?.to_usize(self)?;\n+                let ptr_size = self.memory.pointer_size();\n \n                 trace!(\"sysconf() called with name {}\", name);\n                 // cache the sysconf integers via miri's global cache\n                 let paths = &[\n-                    (&[\"libc\", \"_SC_PAGESIZE\"], Scalar::from_i128(4096)),\n-                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], Scalar::from_i128(-1)),\n+                    (&[\"libc\", \"_SC_PAGESIZE\"], Scalar::from_int(4096, ptr_size)),\n+                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], Scalar::from_int(-1, ptr_size)),\n                 ];\n                 let mut result = None;\n                 for &(path, path_value) in paths {\n@@ -554,43 +558,45 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n-                let key_ptr = self.into_ptr(args[0].value)?;\n-                let key_align = self.layout_of(args[0].ty)?.align;\n+                let key_ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match self.into_ptr(args[1].value)? {\n+                let dtor = match self.into_ptr(args[1].value)?.unwrap_or_err()? {\n                     Scalar::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n-                    Scalar::Bits { defined: 0, .. } => return err!(ReadUndefBytes),\n-                    Scalar::Bits { bits: 0, .. } => None,\n+                    Scalar::Bits { bits: 0, size } => {\n+                        assert_eq!(size as u64, self.memory.pointer_size().bytes());\n+                        None\n+                    },\n                     Scalar::Bits { .. } => return err!(ReadBytesAsPointer),\n                 };\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n                 let key_type = args[0].ty.builtin_deref(true)\n                                    .ok_or_else(|| EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n-                let key_size = self.layout_of(key_type)?.size;\n+                let key_layout = self.layout_of(key_type)?;\n \n                 // Create key and write it into the memory where key_ptr wants it\n                 let key = self.memory.create_tls_key(dtor) as u128;\n-                if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n+                if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n                 self.memory.write_scalar(\n                     key_ptr,\n-                    key_align,\n-                    Scalar::from_u128(key),\n-                    key_size,\n+                    key_layout.align,\n+                    Scalar::from_uint(key, key_layout.size).into(),\n+                    key_layout.size,\n+                    key_layout.align,\n                     false,\n                 )?;\n \n                 // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n+                self.write_null(dest, dest_layout)?;\n             }\n             \"pthread_key_delete\" => {\n                 let key = self.value_to_scalar(args[0])?.to_bytes()?;\n                 self.memory.delete_tls_key(key)?;\n                 // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n+                self.write_null(dest, dest_layout)?;\n             }\n             \"pthread_getspecific\" => {\n                 let key = self.value_to_scalar(args[0])?.to_bytes()?;\n@@ -599,11 +605,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n             \"pthread_setspecific\" => {\n                 let key = self.value_to_scalar(args[0])?.to_bytes()?;\n-                let new_ptr = self.into_ptr(args[1].value)?;\n+                let new_ptr = self.into_ptr(args[1].value)?.unwrap_or_err()?;\n                 self.memory.store_tls(key, new_ptr)?;\n \n                 // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n+                self.write_null(dest, dest_layout)?;\n             }\n \n             \"_tlv_atexit\" => {\n@@ -613,19 +619,20 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             // Stub out all the other pthread calls to just return 0\n             link_name if link_name.starts_with(\"pthread_\") => {\n                 debug!(\"ignoring C ABI call: {}\", link_name);\n-                self.write_null(dest, dest_ty)?;\n+                self.write_null(dest, dest_layout)?;\n             }\n \n             \"mmap\" => {\n                 // This is a horrible hack, but well... the guard page mechanism calls mmap and expects a particular return value, so we give it that value\n-                let addr = self.into_ptr(args[0].value)?;\n+                let addr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 self.write_ptr(dest, addr, dest_ty)?;\n             }\n \n             // Windows API subs\n             \"AddVectoredExceptionHandler\" => {\n                 // any non zero value works for the stdlib. This is just used for stackoverflows anyway\n-                self.write_scalar(dest, Scalar::from_u128(1), dest_ty)?;\n+                let ptr_size = self.memory.pointer_size();\n+                self.write_scalar(dest, Scalar::from_int(1, ptr_size), dest_ty)?;\n             },\n             \"GetModuleHandleW\" |\n             \"GetProcAddress\" |\n@@ -636,26 +643,28 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             \"DeleteCriticalSection\" |\n             \"SetLastError\" => {\n                 // pretend these do not exist/nothing happened, by returning zero\n-                self.write_scalar(dest, Scalar::from_u128(0), dest_ty)?;\n+                let ptr_size = self.memory.pointer_size();\n+                self.write_scalar(dest, Scalar::from_int(0, ptr_size), dest_ty)?;\n             },\n             \"GetLastError\" => {\n                 // this is c::ERROR_CALL_NOT_IMPLEMENTED\n-                self.write_scalar(dest, Scalar::from_u128(120), dest_ty)?;\n+                let ptr_size = self.memory.pointer_size();\n+                self.write_scalar(dest, Scalar::from_int(120, ptr_size), dest_ty)?;\n             },\n \n             // Windows TLS\n             \"TlsAlloc\" => {\n                 // This just creates a key; Windows does not natively support TLS dtors.\n \n-                // Figure out how large a TLS key actually is. This is c::DWORD.\n-                let key_size = self.layout_of(dest_ty)?.size;\n-\n                 // Create key and return it\n                 let key = self.memory.create_tls_key(None) as u128;\n-                if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n+\n+                // Figure out how large a TLS key actually is. This is c::DWORD.\n+                if dest_layout.size.bits() < 128 && key >= (1u128 << dest_layout.size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n-                self.write_scalar(dest, Scalar::from_u128(key), dest_ty)?;\n+                let ptr_size = self.memory.pointer_size();\n+                self.write_scalar(dest, Scalar::from_uint(key, ptr_size), dest_layout.ty)?;\n             }\n             \"TlsGetValue\" => {\n                 let key = self.value_to_scalar(args[0])?.to_bytes()?;\n@@ -664,11 +673,12 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n             \"TlsSetValue\" => {\n                 let key = self.value_to_scalar(args[0])?.to_bytes()?;\n-                let new_ptr = self.into_ptr(args[1].value)?;\n+                let new_ptr = self.into_ptr(args[1].value)?.unwrap_or_err()?;\n                 self.memory.store_tls(key, new_ptr)?;\n+                let ptr_size = self.memory.pointer_size();\n \n                 // Return success (1)\n-                self.write_scalar(dest, Scalar::from_u128(1), dest_ty)?;\n+                self.write_scalar(dest, Scalar::from_int(1, ptr_size), dest_ty)?;\n             }\n \n             // We can't execute anything else\n@@ -791,7 +801,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n         Ok(())\n     }\n \n-    fn write_null(&mut self, dest: Place, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n-        self.write_scalar(dest, Scalar::null(), dest_ty)\n+    fn write_null(&mut self, dest: Place, dest_layout: TyLayout<'tcx>) -> EvalResult<'tcx> {\n+        self.write_scalar(dest, Scalar::null(dest_layout.size), dest_layout.ty)\n     }\n }"}, {"sha": "8482c484608b741ad13dcc6fb538c99990b75940", "filename": "src/helpers.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=be91aea0fa285a86291e70259fb7be1d472674a8", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n         let offset = offset.overflowing_mul(pointee_size).0;\n-        ptr.ptr_wrapping_signed_offset(offset, self)\n+        Ok(ptr.ptr_wrapping_signed_offset(offset, self))\n     }\n \n     fn pointer_offset(\n@@ -65,7 +65,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n         // allocation.\n \n-        if ptr.is_null()? {\n+        if ptr.is_null() {\n             // NULL pointers must only be offset by 0\n             return if offset == 0 {\n                 Ok(ptr)\n@@ -80,7 +80,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n             if let Scalar::Ptr(ptr) = ptr {\n                 self.memory.check_bounds(ptr, false)?;\n-            } else if ptr.is_null()? {\n+            } else if ptr.is_null() {\n                 // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n                 return err!(InvalidNullPointerUsage);\n             }\n@@ -96,7 +96,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n     ) -> EvalResult<'tcx, i64> {\n         assert_eq!(value.ty, self.tcx.types.isize);\n         let raw = self.value_to_scalar(value)?.to_bits(self.memory.pointer_size())?;\n-        let raw = sign_extend(self.tcx.tcx, raw, self.tcx.types.isize)?;\n+        let raw = sign_extend(raw, self.layout_of(self.tcx.types.isize).unwrap());\n         Ok(raw as i64)\n     }\n \n@@ -114,7 +114,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n     ) -> EvalResult<'tcx, i32> {\n         assert_eq!(value.ty, self.tcx.types.i32);\n         let raw = self.value_to_scalar(value)?.to_bits(Size::from_bits(32))?;\n-        let raw = sign_extend(self.tcx.tcx, raw, self.tcx.types.i32)?;\n+        let raw = sign_extend(raw, self.layout_of(self.tcx.types.i32).unwrap());\n         Ok(raw as i32)\n     }\n "}, {"sha": "5c6e7f9b2dc1bbbe4e7e625e71b50cbe50e872a7", "filename": "src/intrinsic.rs", "status": "modified", "additions": 70, "deletions": 78, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=be91aea0fa285a86291e70259fb7be1d472674a8", "patch": "@@ -2,7 +2,7 @@ use rustc::mir;\n use rustc::ty::layout::{TyLayout, LayoutOf, Size, Primitive, Integer::*};\n use rustc::ty;\n \n-use rustc::mir::interpret::{EvalResult, Scalar, Value};\n+use rustc::mir::interpret::{EvalResult, Scalar, Value, ScalarMaybeUndef};\n use rustc_mir::interpret::{Place, PlaceExtra, HasMemory, EvalContext, ValTy};\n \n use helpers::EvalContextExt as HelperEvalContextExt;\n@@ -65,7 +65,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"arith_offset\" => {\n                 let offset = self.value_to_isize(args[1])?;\n-                let ptr = self.into_ptr(args[0].value)?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_layout.ty)?;\n             }\n@@ -81,7 +81,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"atomic_load_relaxed\" |\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n-                let ptr = self.into_ptr(args[0].value)?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 let align = self.layout_of(args[0].ty)?.align;\n \n                 let valty = ValTy {\n@@ -97,7 +97,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n                 let align = self.layout_of(ty)?.align;\n-                let dest = self.into_ptr(args[0].value)?;\n+                let dest = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 self.write_value_to_ptr(args[1].value, dest, align, ty)?;\n             }\n \n@@ -108,7 +108,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n                 let ty = substs.type_at(0);\n                 let align = self.layout_of(ty)?.align;\n-                let ptr = self.into_ptr(args[0].value)?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 let change = self.value_to_scalar(args[1])?;\n                 let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n@@ -118,7 +118,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 };\n                 self.write_scalar(dest, old, ty)?;\n                 self.write_scalar(\n-                    Place::from_scalar_ptr(ptr, align),\n+                    Place::from_scalar_ptr(ptr.into(), align),\n                     change,\n                     ty,\n                 )?;\n@@ -127,23 +127,23 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ty = substs.type_at(0);\n                 let align = self.layout_of(ty)?.align;\n-                let ptr = self.into_ptr(args[0].value)?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 let expect_old = self.value_to_scalar(args[1])?;\n                 let change = self.value_to_scalar(args[2])?;\n                 let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n-                    Value::Scalar(val) => val,\n+                    Value::Scalar(val) => val.unwrap_or_err()?,\n                     Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n                     Value::ScalarPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n                 };\n                 let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n                 let valty = ValTy {\n-                    value: Value::ScalarPair(old, val),\n+                    value: Value::ScalarPair(old.into(), val.into()),\n                     ty: dest_layout.ty,\n                 };\n                 self.write_value(valty, dest)?;\n                 self.write_scalar(\n-                    Place::from_scalar_ptr(ptr, dest_layout.align),\n+                    Place::from_scalar_ptr(ptr.into(), dest_layout.align),\n                     change,\n                     ty,\n                 )?;\n@@ -176,7 +176,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n                 let align = self.layout_of(ty)?.align;\n-                let ptr = self.into_ptr(args[0].value)?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 let change = self.value_to_scalar(args[1])?;\n                 let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n@@ -196,8 +196,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     _ => bug!(),\n                 };\n                 // FIXME: what do atomics do on overflow?\n-                let (val, _) = self.binary_op(op, old, ty, change, ty)?;\n-                self.write_scalar(Place::from_scalar_ptr(ptr, dest_layout.align), val, ty)?;\n+                let (val, _) = self.binary_op(op, old.unwrap_or_err()?, ty, change, ty)?;\n+                self.write_scalar(Place::from_scalar_ptr(ptr.into(), dest_layout.align), val, ty)?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -212,8 +212,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     // TODO: We do not even validate alignment for the 0-bytes case.  libstd relies on this in vec::IntoIter::next.\n                     // Also see the write_bytes intrinsic.\n                     let elem_align = elem_layout.align;\n-                    let src = self.into_ptr(args[0].value)?;\n-                    let dest = self.into_ptr(args[1].value)?;\n+                    let src = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n+                    let dest = self.into_ptr(args[1].value)?.unwrap_or_err()?;\n                     self.memory.copy(\n                         src,\n                         elem_align,\n@@ -250,7 +250,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let adt_align = self.layout_of(args[0].ty)?.align;\n                 let place = Place::from_scalar_ptr(adt_ptr, adt_align);\n                 let discr_val = self.read_discriminant_value(place, layout)?;\n-                self.write_scalar(dest, Scalar::from_u128(discr_val), dest_layout.ty)?;\n+                let ptr_size = self.memory.pointer_size();\n+                self.write_scalar(dest, Scalar::from_uint(discr_val, ptr_size), dest_layout.ty)?;\n             }\n \n             \"sinf32\" | \"fabsf32\" | \"cosf32\" | \"sqrtf32\" | \"expf32\" | \"exp2f32\" | \"logf32\" |\n@@ -320,7 +321,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let a = self.value_to_scalar(args[0])?;\n                 let b = self.value_to_scalar(args[1])?;\n                 // check x % y != 0\n-                if !self.binary_op(mir::BinOp::Rem, a, ty, b, ty)?.0.is_null()? {\n+                if !self.binary_op(mir::BinOp::Rem, a, ty, b, ty)?.0.is_null() {\n                     return err!(ValidationFailure(format!(\"exact_div: {:?} cannot be divided by {:?}\", a, b)));\n                 }\n                 let result = self.binary_op(mir::BinOp::Div, a, ty, b, ty)?;\n@@ -330,41 +331,24 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"likely\" | \"unlikely\" | \"forget\" => {}\n \n             \"init\" => {\n-                let size = dest_layout.size;\n-                let init = |this: &mut Self, val: Value| {\n-                    let zero_val = match val {\n-                        Value::ByRef(ptr, _) => {\n-                            // These writes have no alignment restriction anyway.\n-                            this.memory.write_repeat(ptr, 0, size)?;\n-                            val\n-                        }\n-                        // TODO(solson): Revisit this, it's fishy to check for Undef here.\n-                        Value::Scalar(Scalar::Bits { defined: 0, .. }) => {\n-                            match this.layout_of(dest_layout.ty)?.abi {\n-                                ty::layout::Abi::Scalar(_) => Value::Scalar(Scalar::null()),\n-                                _ => {\n-                                    // FIXME(oli-obk): pass TyLayout to alloc_ptr instead of Ty\n-                                    let ptr = this.alloc_ptr(dest_layout)?;\n-                                    let ptr = Scalar::Ptr(ptr);\n-                                    this.memory.write_repeat(ptr, 0, size)?;\n-                                    Value::ByRef(ptr, dest_layout.align)\n-                                }\n+                match dest {\n+                    Place::Local { frame, local } => {\n+                        match self.stack()[frame].locals[local].access()? {\n+                            Value::ByRef(ptr, _) => {\n+                                // These writes have no alignment restriction anyway.\n+                                self.memory.write_repeat(ptr, 0, dest_layout.size)?;\n+                            }\n+                            Value::Scalar(_) => self.write_value(ValTy { value: Value::Scalar(Scalar::null(dest_layout.size).into()), ty: dest_layout.ty }, dest)?,\n+                            Value::ScalarPair(..) => {\n+                                self.write_value(ValTy { value: Value::ScalarPair(Scalar::null(dest_layout.size).into(), Scalar::null(dest_layout.size).into()), ty: dest_layout.ty }, dest)?;\n                             }\n                         }\n-                        Value::Scalar(_) => Value::Scalar(Scalar::null()),\n-                        Value::ScalarPair(..) => {\n-                            Value::ScalarPair(Scalar::null(), Scalar::null())\n-                        }\n-                    };\n-                    Ok(zero_val)\n-                };\n-                match dest {\n-                    Place::Local { frame, local } => self.modify_local(frame, local, init)?,\n+                    },\n                     Place::Ptr {\n                         ptr,\n                         align: _align,\n                         extra: PlaceExtra::None,\n-                    } => self.memory.write_repeat(ptr, 0, size)?,\n+                    } => self.memory.write_repeat(ptr.unwrap_or_err()?, 0, dest_layout.size)?,\n                     Place::Ptr { .. } => {\n                         bug!(\"init intrinsic tried to write to fat or unaligned ptr target\")\n                     }\n@@ -374,21 +358,23 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_align = self.layout_of(elem_ty)?.align.abi();\n-                let align_val = Scalar::from_u128(elem_align as u128);\n+                let ptr_size = self.memory.pointer_size();\n+                let align_val = Scalar::from_uint(elem_align as u128, ptr_size);\n                 self.write_scalar(dest, align_val, dest_layout.ty)?;\n             }\n \n             \"pref_align_of\" => {\n                 let ty = substs.type_at(0);\n                 let layout = self.layout_of(ty)?;\n                 let align = layout.align.pref();\n-                let align_val = Scalar::from_u128(align as u128);\n+                let ptr_size = self.memory.pointer_size();\n+                let align_val = Scalar::from_uint(align as u128, ptr_size);\n                 self.write_scalar(dest, align_val, dest_layout.ty)?;\n             }\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = self.into_ptr(args[0].value)?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 let align = self.layout_of(args[0].ty)?.align;\n                 self.write_value_to_ptr(args[1].value, ptr, align, ty)?;\n             }\n@@ -406,7 +392,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"offset\" => {\n                 let offset = self.value_to_isize(args[1])?;\n-                let ptr = self.into_ptr(args[0].value)?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_layout.ty)?;\n             }\n@@ -517,16 +503,18 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n-                let size = self.layout_of(ty)?.size.bytes().into();\n-                self.write_scalar(dest, Scalar::from_u128(size), dest_layout.ty)?;\n+                let size = self.layout_of(ty)?.size.bytes();\n+                let ptr_size = self.memory.pointer_size();\n+                self.write_scalar(dest, Scalar::from_uint(size, ptr_size), dest_layout.ty)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (size, _) = self.size_and_align_of_dst(ty, args[0].value)?;\n+                let ptr_size = self.memory.pointer_size();\n                 self.write_scalar(\n                     dest,\n-                    Scalar::from_u128(size.bytes() as u128),\n+                    Scalar::from_uint(size.bytes() as u128, ptr_size),\n                     dest_layout.ty,\n                 )?;\n             }\n@@ -535,9 +523,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"align_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (_, align) = self.size_and_align_of_dst(ty, args[0].value)?;\n+                let ptr_size = self.memory.pointer_size();\n                 self.write_scalar(\n                     dest,\n-                    Scalar::from_u128(align.abi() as u128),\n+                    Scalar::from_uint(align.abi(), ptr_size),\n                     dest_layout.ty,\n                 )?;\n             }\n@@ -551,7 +540,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let n = self.tcx.type_id_hash(ty);\n-                self.write_scalar(dest, Scalar::Bits { bits: n as u128, defined: 64 }, dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::Bits { bits: n as u128, size: 8 }, dest_layout.ty)?;\n             }\n \n             \"transmute\" => {\n@@ -629,21 +618,24 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             }\n \n             \"uninit\" => {\n-                let size = dest_layout.size;\n-                let uninit = |this: &mut Self, val: Value| match val {\n-                    Value::ByRef(ptr, _) => {\n-                        this.memory.mark_definedness(ptr, size, false)?;\n-                        Ok(val)\n-                    }\n-                    _ => Ok(Value::Scalar(Scalar::undef())),\n-                };\n                 match dest {\n-                    Place::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n+                    Place::Local { frame, local } => {\n+                        match self.stack()[frame].locals[local].access()? {\n+                            Value::ByRef(ptr, _) => {\n+                                // These writes have no alignment restriction anyway.\n+                                self.memory.mark_definedness(ptr, dest_layout.size, false)?;\n+                            }\n+                            Value::Scalar(_) => self.write_value(ValTy { value: Value::Scalar(ScalarMaybeUndef::Undef), ty: dest_layout.ty }, dest)?,\n+                            Value::ScalarPair(..) => {\n+                                self.write_value(ValTy { value: Value::ScalarPair(ScalarMaybeUndef::Undef, ScalarMaybeUndef::Undef), ty: dest_layout.ty }, dest)?;\n+                            }\n+                        }\n+                    },\n                     Place::Ptr {\n                         ptr,\n                         align: _align,\n                         extra: PlaceExtra::None,\n-                    } => self.memory.mark_definedness(ptr, size, false)?,\n+                    } => self.memory.mark_definedness(ptr.unwrap_or_err()?, dest_layout.size, false)?,\n                     Place::Ptr { .. } => {\n                         bug!(\"uninit intrinsic tried to write to fat or unaligned ptr target\")\n                     }\n@@ -654,7 +646,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let ty = substs.type_at(0);\n                 let ty_layout = self.layout_of(ty)?;\n                 let val_byte = self.value_to_u8(args[1])?;\n-                let ptr = self.into_ptr(args[0].value)?;\n+                let ptr = self.into_ptr(args[0].value)?.unwrap_or_err()?;\n                 let count = self.value_to_usize(args[2])?;\n                 if count > 0 {\n                     // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n@@ -683,21 +675,21 @@ fn numeric_intrinsic<'tcx>(\n ) -> EvalResult<'tcx, Scalar> {\n     macro_rules! integer_intrinsic {\n         ($method:ident) => ({\n-            let result_bytes = match kind {\n-                Primitive::Int(I8, true) => (bytes as i8).$method() as u128,\n-                Primitive::Int(I8, false) => (bytes as u8).$method() as u128,\n-                Primitive::Int(I16, true) => (bytes as i16).$method() as u128,\n-                Primitive::Int(I16, false) => (bytes as u16).$method() as u128,\n-                Primitive::Int(I32, true) => (bytes as i32).$method() as u128,\n-                Primitive::Int(I32, false) => (bytes as u32).$method() as u128,\n-                Primitive::Int(I64, true) => (bytes as i64).$method() as u128,\n-                Primitive::Int(I64, false) => (bytes as u64).$method() as u128,\n-                Primitive::Int(I128, true) => (bytes as i128).$method() as u128,\n-                Primitive::Int(I128, false) => bytes.$method() as u128,\n+            let (result_bytes, size) = match kind {\n+                Primitive::Int(I8, true) => ((bytes as i8).$method() as u128, 1),\n+                Primitive::Int(I8, false) => ((bytes as u8).$method() as u128, 1),\n+                Primitive::Int(I16, true) => ((bytes as i16).$method() as u128, 2),\n+                Primitive::Int(I16, false) => ((bytes as u16).$method() as u128, 2),\n+                Primitive::Int(I32, true) => ((bytes as i32).$method() as u128, 4),\n+                Primitive::Int(I32, false) => ((bytes as u32).$method() as u128, 4),\n+                Primitive::Int(I64, true) => ((bytes as i64).$method() as u128, 8),\n+                Primitive::Int(I64, false) => ((bytes as u64).$method() as u128, 8),\n+                Primitive::Int(I128, true) => ((bytes as i128).$method() as u128, 16),\n+                Primitive::Int(I128, false) => (bytes.$method() as u128, 16),\n                 _ => bug!(\"invalid `{}` argument: {:?}\", name, bytes),\n             };\n \n-            Scalar::from_u128(result_bytes)\n+            Scalar::from_uint(result_bytes, Size::from_bytes(size))\n         });\n     }\n "}, {"sha": "b08f63e095d84902da4454cad93da571758670cc", "filename": "src/lib.rs", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=be91aea0fa285a86291e70259fb7be1d472674a8", "patch": "@@ -56,53 +56,43 @@ use range_map::RangeMap;\n use validation::{ValidationQuery, AbsPlace};\n \n pub trait ScalarExt {\n-    fn null() -> Self;\n+    fn null(size: Size) -> Self;\n     fn from_i32(i: i32) -> Self;\n-    fn from_u128(i: u128) -> Self;\n-    fn from_i128(i: i128) -> Self;\n-    fn from_usize(i: u64, ptr_size: Size) -> Self;\n-    fn from_isize(i: i64, ptr_size: Size) -> Self;\n+    fn from_uint(i: impl Into<u128>, ptr_size: Size) -> Self;\n+    fn from_int(i: impl Into<i128>, ptr_size: Size) -> Self;\n     fn from_f32(f: f32) -> Self;\n     fn from_f64(f: f64) -> Self;\n     fn to_usize<'a, 'mir, 'tcx>(self, ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>) -> EvalResult<'static, u64>;\n-    fn is_null(self) -> EvalResult<'static, bool>;\n+    fn is_null(self) -> bool;\n     /// HACK: this function just extracts all bits if `defined != 0`\n     /// Mainly used for args of C-functions and we should totally correctly fetch the size\n     /// of their arguments\n     fn to_bytes(self) -> EvalResult<'static, u128>;\n }\n \n impl ScalarExt for Scalar {\n-    fn null() -> Self {\n-        Scalar::Bits { bits: 0, defined: 128 }\n+    fn null(size: Size) -> Self {\n+        Scalar::Bits { bits: 0, size: size.bytes() as u8 }\n     }\n \n     fn from_i32(i: i32) -> Self {\n-        Scalar::Bits { bits: i as u32 as u128, defined: 32 }\n+        Scalar::Bits { bits: i as u32 as u128, size: 4 }\n     }\n \n-    fn from_u128(i: u128) -> Self {\n-        Scalar::Bits { bits: i, defined: 128 }\n+    fn from_uint(i: impl Into<u128>, ptr_size: Size) -> Self {\n+        Scalar::Bits { bits: i.into(), size: ptr_size.bytes() as u8 }\n     }\n \n-    fn from_i128(i: i128) -> Self {\n-        Scalar::Bits { bits: i as u128, defined: 128 }\n-    }\n-\n-    fn from_usize(i: u64, ptr_size: Size) -> Self {\n-        Scalar::Bits { bits: i as u128, defined: ptr_size.bits() as u8 }\n-    }\n-\n-    fn from_isize(i: i64, ptr_size: Size) -> Self {\n-        Scalar::Bits { bits: i as i128 as u128, defined: ptr_size.bits() as u8 }\n+    fn from_int(i: impl Into<i128>, ptr_size: Size) -> Self {\n+        Scalar::Bits { bits: i.into() as u128, size: ptr_size.bytes() as u8 }\n     }\n \n     fn from_f32(f: f32) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, defined: 32 }\n+        Scalar::Bits { bits: f.to_bits() as u128, size: 4 }\n     }\n \n     fn from_f64(f: f64) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, defined: 64 }\n+        Scalar::Bits { bits: f.to_bits() as u128, size: 8 }\n     }\n \n     fn to_usize<'a, 'mir, 'tcx>(self, ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>) -> EvalResult<'static, u64> {\n@@ -111,23 +101,19 @@ impl ScalarExt for Scalar {\n         Ok(b as u64)\n     }\n \n-    fn is_null(self) -> EvalResult<'static, bool> {\n+    fn is_null(self) -> bool {\n         match self {\n-            Scalar::Bits { bits, defined } => {\n-                if defined > 0 {\n-                    Ok(bits == 0)\n-                } else {\n-                    err!(ReadUndefBytes)\n-                }\n-            }\n-            Scalar::Ptr(_) => Ok(false)\n+            Scalar::Bits { bits, .. } => bits == 0,\n+            Scalar::Ptr(_) => false\n         }\n     }\n \n     fn to_bytes(self) -> EvalResult<'static, u128> {\n         match self {\n-            Scalar::Bits { defined: 0, .. } => err!(ReadUndefBytes),\n-            Scalar::Bits { bits, .. } => Ok(bits),\n+            Scalar::Bits { bits, size } => {\n+                assert_ne!(size, 0);\n+                Ok(bits)\n+            },\n             Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n         }\n     }\n@@ -155,6 +141,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n                 .to_owned(),\n         ));\n     }\n+    let ptr_size = ecx.memory.pointer_size();\n \n     if let Some(start_id) = start_wrapper {\n         let main_ret_ty = ecx.tcx.fn_sig(main_id).output();\n@@ -199,7 +186,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx.tcx));\n         ecx.write_value(\n             ValTy {\n-                value: Value::Scalar(Scalar::Ptr(main_ptr)),\n+                value: Value::Scalar(Scalar::Ptr(main_ptr).into()),\n                 ty: main_ptr_ty,\n             },\n             dest,\n@@ -208,17 +195,16 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         // Second argument (argc): 1\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         let ty = ecx.tcx.types.isize;\n-        ecx.write_scalar(dest, Scalar::from_u128(1), ty)?;\n+        ecx.write_scalar(dest, Scalar::from_int(1, ptr_size), ty)?;\n \n         // FIXME: extract main source file path\n         // Third argument (argv): &[b\"foo\"]\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n         let foo = ecx.memory.allocate_bytes(b\"foo\\0\");\n-        let ptr_size = ecx.memory.pointer_size();\n         let ptr_align = ecx.tcx.data_layout.pointer_align;\n         let foo_ptr = ecx.memory.allocate(ptr_size, ptr_align, MemoryKind::Stack)?;\n-        ecx.memory.write_scalar(foo_ptr.into(), ptr_align, Scalar::Ptr(foo), ptr_size, false)?;\n+        ecx.memory.write_scalar(foo_ptr.into(), ptr_align, Scalar::Ptr(foo).into(), ptr_size, ptr_align, false)?;\n         ecx.memory.mark_static_initialized(foo_ptr.alloc_id, Mutability::Immutable)?;\n         ecx.write_ptr(dest, foo_ptr.into(), ty)?;\n \n@@ -228,7 +214,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n             main_instance,\n             main_mir.span,\n             main_mir,\n-            Place::from_scalar_ptr(Scalar::from_u128(1), ty::layout::Align::from_bytes(1, 1).unwrap()),\n+            Place::from_scalar_ptr(Scalar::from_int(1, ptr_size).into(), ty::layout::Align::from_bytes(1, 1).unwrap()),\n             StackPopCleanup::None,\n         )?;\n \n@@ -294,7 +280,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 trace!(\"Frame {}\", i);\n                 trace!(\"    return: {:#?}\", frame.return_place);\n                 for (i, local) in frame.locals.iter().enumerate() {\n-                    if let Some(local) = local {\n+                    if let Ok(local) = local.access() {\n                         trace!(\"    local {}: {:?}\", i, local);\n                     }\n                 }\n@@ -519,15 +505,16 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n         let mut args = ecx.frame().mir.args_iter();\n         let usize = ecx.tcx.types.usize;\n+        let ptr_size = ecx.memory.pointer_size();\n \n         // First argument: size\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         ecx.write_value(\n             ValTy {\n-                value: Value::Scalar(Scalar::from_u128(match layout.size.bytes() {\n-                    0 => 1 as u128,\n-                    size => size as u128,\n-                })),\n+                value: Value::Scalar(Scalar::from_uint(match layout.size.bytes() {\n+                    0 => 1,\n+                    size => size,\n+                }, ptr_size).into()),\n                 ty: usize,\n             },\n             dest,\n@@ -537,7 +524,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         ecx.write_value(\n             ValTy {\n-                value: Value::Scalar(Scalar::from_u128(layout.align.abi().into())),\n+                value: Value::Scalar(Scalar::from_uint(layout.align.abi(), ptr_size).into()),\n                 ty: usize,\n             },\n             dest,"}, {"sha": "7be77771a7cafea4a745be212c9d0fdc75b7840e", "filename": "src/operator.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=be91aea0fa285a86291e70259fb7be1d472674a8", "patch": "@@ -116,9 +116,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                         Sub => {\n                             return self.binary_op(\n                                 Sub,\n-                                Scalar::Bits { bits: left.offset.bytes() as u128, defined: self.memory.pointer_size().bits() as u8 },\n+                                Scalar::Bits { bits: left.offset.bytes() as u128, size: self.memory.pointer_size().bytes() as u8 },\n                                 self.tcx.types.usize,\n-                                Scalar::Bits { bits: right.offset.bytes() as u128, defined: self.memory.pointer_size().bits() as u8 },\n+                                Scalar::Bits { bits: right.offset.bytes() as u128, size: self.memory.pointer_size().bytes() as u8 },\n                                 self.tcx.types.usize,\n                             ).map(Some)\n                         }\n@@ -182,12 +182,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             BitAnd if !signed => {\n                 let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align.abi() - 1);\n                 let right = right as u64;\n+                let ptr_size = self.memory.pointer_size().bytes() as u8;\n                 if right & base_mask == base_mask {\n                     // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n                     (Scalar::Ptr(Pointer::new(left.alloc_id, Size::from_bytes(left.offset.bytes() & right))), false)\n                 } else if right & base_mask == 0 {\n                     // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n-                    (Scalar::Bits { bits: (left.offset.bytes() & right) as u128, defined: 128 }, false)\n+                    (Scalar::Bits { bits: (left.offset.bytes() & right) as u128, size: ptr_size }, false)\n                 } else {\n                     return err!(ReadPointerAsBytes);\n                 }"}, {"sha": "9f0fb2c8f62a17701bea41b6b8b380bc8afe9c44", "filename": "src/tls.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=be91aea0fa285a86291e70259fb7be1d472674a8", "patch": "@@ -11,7 +11,7 @@ pub trait MemoryExt<'tcx> {\n     fn fetch_tls_dtor(\n         &mut self,\n         key: Option<TlsKey>,\n-    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Scalar, TlsKey)>>;\n+    ) -> Option<(ty::Instance<'tcx>, Scalar, TlsKey)>;\n }\n \n pub trait EvalContextExt<'tcx> {\n@@ -22,10 +22,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n     fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.data.next_thread_local;\n         self.data.next_thread_local += 1;\n+        let ptr_size = self.pointer_size();\n         self.data.thread_local.insert(\n             new_key,\n             TlsEntry {\n-                data: Scalar::null(),\n+                data: Scalar::null(ptr_size).into(),\n                 dtor,\n             },\n         );\n@@ -85,9 +86,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n     fn fetch_tls_dtor(\n         &mut self,\n         key: Option<TlsKey>,\n-    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Scalar, TlsKey)>> {\n+    ) -> Option<(ty::Instance<'tcx>, Scalar, TlsKey)> {\n         use std::collections::Bound::*;\n \n+        let ptr_size = self.pointer_size();\n         let thread_local = &mut self.data.thread_local;\n         let start = match key {\n             Some(key) => Excluded(key),\n@@ -96,21 +98,21 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n         for (&key, &mut TlsEntry { ref mut data, dtor }) in\n             thread_local.range_mut((start, Unbounded))\n         {\n-            if !data.is_null()? {\n+            if !data.is_null() {\n                 if let Some(dtor) = dtor {\n                     let ret = Some((dtor, *data, key));\n-                    *data = Scalar::null();\n-                    return Ok(ret);\n+                    *data = Scalar::null(ptr_size);\n+                    return ret;\n                 }\n             }\n         }\n-        Ok(None)\n+        None\n     }\n }\n \n impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n     fn run_tls_dtors(&mut self) -> EvalResult<'tcx> {\n-        let mut dtor = self.memory.fetch_tls_dtor(None)?;\n+        let mut dtor = self.memory.fetch_tls_dtor(None);\n         // FIXME: replace loop by some structure that works with stepping\n         while let Some((instance, ptr, key)) = dtor {\n             trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n@@ -134,9 +136,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             // step until out of stackframes\n             while self.step()? {}\n \n-            dtor = match self.memory.fetch_tls_dtor(Some(key))? {\n+            dtor = match self.memory.fetch_tls_dtor(Some(key)) {\n                 dtor @ Some(_) => dtor,\n-                None => self.memory.fetch_tls_dtor(None)?,\n+                None => self.memory.fetch_tls_dtor(None),\n             };\n         }\n         // FIXME: On a windows target, call `unsafe extern \"system\" fn on_tls_callback`."}, {"sha": "7f0abb9ae0bad40f78f1e6993965644c7b30c129", "filename": "src/validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91aea0fa285a86291e70259fb7be1d472674a8/src%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalidation.rs?ref=be91aea0fa285a86291e70259fb7be1d472674a8", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             Deref => Deref,\n             Field(f, _) => Field(f, ()),\n             Index(v) => {\n-                let value = self.frame().get_local(v)?;\n+                let value = self.frame().locals[v].access()?;\n                 let ty = self.tcx.tcx.types.usize;\n                 let n = self.value_to_scalar(ValTy { value, ty })?.to_usize(self)?;\n                 Index(n)\n@@ -480,7 +480,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n     ) -> EvalResult<'tcx> {\n         // Check alignment and non-NULLness\n         let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n-        let ptr = self.into_ptr(val)?;\n+        let ptr = self.into_ptr(val)?.unwrap_or_err()?;\n         self.memory.check_align(ptr, align)?;\n \n         // Recurse\n@@ -562,7 +562,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             };\n             // Handle locking\n             if len > 0 {\n-                let ptr = ptr.to_ptr()?;\n+                let ptr = ptr.unwrap_or_err()?.to_ptr()?;\n                 match query.mutbl {\n                     MutImmutable => {\n                         if mode.acquiring() {\n@@ -651,7 +651,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 }\n                 TyFnPtr(_sig) => {\n                     let ptr = self.read_place(query.place.1)?;\n-                    let ptr = self.into_ptr(ptr)?.to_ptr()?;\n+                    let ptr = self.into_ptr(ptr)?.unwrap_or_err()?.to_ptr()?;\n                     self.memory.get_fn(ptr)?;\n                     // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n                 }"}]}