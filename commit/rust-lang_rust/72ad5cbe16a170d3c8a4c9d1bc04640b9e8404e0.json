{"sha": "72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYWQ1Y2JlMTZhMTcwZDNjOGE0YzlkMWJjMDQ2NDBiOWU4NDA0ZTA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-08T15:00:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-08T15:00:53Z"}, "message": "Merge #8419 #8423\n\n8419: Move hir_ty to Chalk IR r=flodiebold a=flodiebold\n\nCloses #8313.\r\n\r\nThere's some further cleanups to do:\r\n - we're still using our `TypeWalk` in lots of places (not for mutating/folding though, just for walking)\r\n - we're still using our own canonicalization and unification and our `InferenceTable`\r\n - ~`ToChalk` still exists and gets called, it's just the identity in most cases now (I'll probably clean those up before merging this)~\n\n8423: Bump lsp-types and syn r=kjeremy a=kjeremy\n\nThis lsp-types now supports a default InsertTextMode for completion and a per-completion item commit_characters\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: kjeremy <kjeremy@gmail.com>", "tree": {"sha": "e6861877e958f3e82f1b3c0316c43a28cdfc317e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6861877e958f3e82f1b3c0316c43a28cdfc317e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgbxqlCRBK7hj4Ov3rIwAAdHIIAB1ytbgC0Q8ef8JzzzipE6Q7\nuoJFF6CH0wHv8ElcqdPeRAWbVoZktvKMPnEBP1bM96lD8Ol7Dbzb06YnW5pw6PaV\nZDetvFavQgFNi67jonb4UzNj6DFElYAr5V4RU1oUrAlIpjBcsJzG7jCnkJ5c1UVj\nQerkJ6rqQLIAKadnvMFEgfNQkq740jY9uizOmABhnO7/OxlFvuf9KLe6BkEJpCcr\nCamRMRqWpezo9KBs5S8ZdrrgETYPUlRDTYkG/CyVtQUAbvSNLs3yazvEkDcGGEMu\nQk0GHgEO0K6WYasVyyjJTYCsdNe1PePB1RcjWZ6xJAVYCA6h96bUNj1LZoSDpl0=\n=0uP1\n-----END PGP SIGNATURE-----\n", "payload": "tree e6861877e958f3e82f1b3c0316c43a28cdfc317e\nparent 5810299dba665f6077909208321703b580b7fe57\nparent d992736e796501b2a5ae232644924a3dfefede92\nparent 3634b2145c66316a9413dda93f9081dc32ecbec2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617894053 +0000\ncommitter GitHub <noreply@github.com> 1617894053 +0000\n\nMerge #8419 #8423\n\n8419: Move hir_ty to Chalk IR r=flodiebold a=flodiebold\n\nCloses #8313.\r\n\r\nThere's some further cleanups to do:\r\n - we're still using our `TypeWalk` in lots of places (not for mutating/folding though, just for walking)\r\n - we're still using our own canonicalization and unification and our `InferenceTable`\r\n - ~`ToChalk` still exists and gets called, it's just the identity in most cases now (I'll probably clean those up before merging this)~\n\n8423: Bump lsp-types and syn r=kjeremy a=kjeremy\n\nThis lsp-types now supports a default InsertTextMode for completion and a per-completion item commit_characters\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: kjeremy <kjeremy@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "html_url": "https://github.com/rust-lang/rust/commit/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5810299dba665f6077909208321703b580b7fe57", "url": "https://api.github.com/repos/rust-lang/rust/commits/5810299dba665f6077909208321703b580b7fe57", "html_url": "https://github.com/rust-lang/rust/commit/5810299dba665f6077909208321703b580b7fe57"}, {"sha": "d992736e796501b2a5ae232644924a3dfefede92", "url": "https://api.github.com/repos/rust-lang/rust/commits/d992736e796501b2a5ae232644924a3dfefede92", "html_url": "https://github.com/rust-lang/rust/commit/d992736e796501b2a5ae232644924a3dfefede92"}, {"sha": "3634b2145c66316a9413dda93f9081dc32ecbec2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3634b2145c66316a9413dda93f9081dc32ecbec2", "html_url": "https://github.com/rust-lang/rust/commit/3634b2145c66316a9413dda93f9081dc32ecbec2"}], "stats": {"total": 1894, "additions": 344, "deletions": 1550}, "files": [{"sha": "d7e6d3ac8c079668cc0f815022a9ccd47dcc5fbc", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -852,9 +852,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.88.0\"\n+version = \"0.89.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d8e8e042772e4e10b3785822f63c82399d0dd233825de44d2596f7fa86e023e0\"\n+checksum = \"07731ecd4ee0654728359a5b95e2a254c857876c04b85225496a35d60345daa7\"\n dependencies = [\n  \"bitflags\",\n  \"serde\",\n@@ -1577,9 +1577,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.68\"\n+version = \"1.0.69\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ce15dd3ed8aa2f8eeac4716d6ef5ab58b6b9256db41d7e1a0224c2788e8fd87\"\n+checksum = \"48fe99c6bd8b1cc636890bcc071842de909d902c81ac7dab53ba33c421ab8ffb\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "817a01db11519a1cdbd97db79dbff03ff39255e4", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -1903,7 +1903,9 @@ impl Type {\n                 | TyKind::Dyn(_)\n                 | TyKind::Function(_)\n                 | TyKind::Alias(_)\n-                | TyKind::Foreign(_) => false,\n+                | TyKind::Foreign(_)\n+                | TyKind::Generator(..)\n+                | TyKind::GeneratorWitness(..) => false,\n             }\n         }\n     }"}, {"sha": "e25ef866d7ba520584da85cab5df9fe705ce5e73", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -4,6 +4,7 @@ use std::iter;\n \n use chalk_ir::{\n     cast::{Cast, CastTo, Caster},\n+    fold::Fold,\n     interner::HasInterner,\n     AdtId, BoundVar, DebruijnIndex, Safety, Scalar,\n };\n@@ -13,7 +14,7 @@ use smallvec::SmallVec;\n use crate::{\n     db::HirDatabase, primitive, to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders,\n     CallableSig, FnPointer, FnSig, FnSubst, GenericArg, Interner, ProjectionTy, Substitution,\n-    TraitRef, Ty, TyDefId, TyExt, TyKind, TypeWalk, ValueTyDefId,\n+    TraitRef, Ty, TyDefId, TyExt, TyKind, ValueTyDefId,\n };\n \n /// This is a builder for `Ty` or anything that needs a `Substitution`.\n@@ -32,8 +33,7 @@ impl<D> TyBuilder<D> {\n \n     fn build_internal(self) -> (D, Substitution) {\n         assert_eq!(self.vec.len(), self.param_count);\n-        // FIXME: would be good to have a way to construct a chalk_ir::Substitution from the interned form\n-        let subst = Substitution::intern(self.vec);\n+        let subst = Substitution::from_iter(&Interner, self.vec);\n         (self.data, subst)\n     }\n \n@@ -141,7 +141,7 @@ impl TyBuilder<hir_def::AdtId> {\n                 self.vec.push(fallback().cast(&Interner));\n             } else {\n                 // each default can depend on the previous parameters\n-                let subst_so_far = Substitution::intern(self.vec.clone());\n+                let subst_so_far = Substitution::from_iter(&Interner, self.vec.clone());\n                 self.vec\n                     .push(default_ty.clone().substitute(&Interner, &subst_so_far).cast(&Interner));\n             }\n@@ -196,13 +196,13 @@ impl TyBuilder<TypeAliasId> {\n     }\n }\n \n-impl<T: TypeWalk + HasInterner<Interner = Interner>> TyBuilder<Binders<T>> {\n+impl<T: HasInterner<Interner = Interner> + Fold<Interner>> TyBuilder<Binders<T>> {\n     fn subst_binders(b: Binders<T>) -> Self {\n         let param_count = b.binders.len(&Interner);\n         TyBuilder::new(b, param_count)\n     }\n \n-    pub fn build(self) -> T {\n+    pub fn build(self) -> <T as Fold<Interner>>::Result {\n         let (b, subst) = self.build_internal();\n         b.substitute(&Interner, &subst)\n     }"}, {"sha": "f27dee3fdedf42c343b4228b3caf294008fcf88c", "filename": "crates/hir_ty/src/chalk_cast.rs", "status": "modified", "additions": 4, "deletions": 61, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Fchalk_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Fchalk_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_cast.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -1,11 +1,8 @@\n //! Implementations of the Chalk `Cast` trait for our types.\n \n-use chalk_ir::{\n-    cast::{Cast, CastTo},\n-    interner::HasInterner,\n-};\n+use chalk_ir::interner::HasInterner;\n \n-use crate::{AliasEq, DomainGoal, GenericArg, GenericArgData, Interner, TraitRef, Ty, WhereClause};\n+use crate::{CallableSig, ReturnTypeImplTraits};\n \n macro_rules! has_interner {\n     ($t:ty) => {\n@@ -15,59 +12,5 @@ macro_rules! has_interner {\n     };\n }\n \n-has_interner!(WhereClause);\n-has_interner!(DomainGoal);\n-has_interner!(GenericArg);\n-has_interner!(Ty);\n-\n-impl CastTo<WhereClause> for TraitRef {\n-    fn cast_to(self, _interner: &Interner) -> WhereClause {\n-        WhereClause::Implemented(self)\n-    }\n-}\n-\n-impl CastTo<WhereClause> for AliasEq {\n-    fn cast_to(self, _interner: &Interner) -> WhereClause {\n-        WhereClause::AliasEq(self)\n-    }\n-}\n-\n-impl CastTo<DomainGoal> for WhereClause {\n-    fn cast_to(self, _interner: &Interner) -> DomainGoal {\n-        DomainGoal::Holds(self)\n-    }\n-}\n-\n-impl CastTo<GenericArg> for Ty {\n-    fn cast_to(self, interner: &Interner) -> GenericArg {\n-        GenericArg::new(interner, GenericArgData::Ty(self))\n-    }\n-}\n-\n-macro_rules! transitive_impl {\n-    ($a:ty, $b:ty, $c:ty) => {\n-        impl CastTo<$c> for $a {\n-            fn cast_to(self, interner: &Interner) -> $c {\n-                self.cast::<$b>(interner).cast(interner)\n-            }\n-        }\n-    };\n-}\n-\n-// In Chalk, these can be done as blanket impls, but that doesn't work here\n-// because of coherence\n-\n-transitive_impl!(TraitRef, WhereClause, DomainGoal);\n-transitive_impl!(AliasEq, WhereClause, DomainGoal);\n-\n-macro_rules! reflexive_impl {\n-    ($a:ty) => {\n-        impl CastTo<$a> for $a {\n-            fn cast_to(self, _interner: &Interner) -> $a {\n-                self\n-            }\n-        }\n-    };\n-}\n-\n-reflexive_impl!(GenericArg);\n+has_interner!(CallableSig);\n+has_interner!(ReturnTypeImplTraits);"}, {"sha": "d7a3977e53b98653445b4680939a97eaf6d64a82", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -287,6 +287,8 @@ impl HirDisplay for GenericArg {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         match self.interned() {\n             crate::GenericArgData::Ty(ty) => ty.hir_fmt(f),\n+            crate::GenericArgData::Lifetime(lt) => lt.hir_fmt(f),\n+            crate::GenericArgData::Const(c) => c.hir_fmt(f),\n         }\n     }\n }\n@@ -664,6 +666,8 @@ impl HirDisplay for Ty {\n                 write!(f, \"{{unknown}}\")?;\n             }\n             TyKind::InferenceVar(..) => write!(f, \"_\")?,\n+            TyKind::Generator(..) => write!(f, \"{{generator}}\")?,\n+            TyKind::GeneratorWitness(..) => write!(f, \"{{generator witness}}\")?,\n         }\n         Ok(())\n     }\n@@ -741,7 +745,7 @@ fn write_bounds_like_dyn_trait(\n                 if !first {\n                     write!(f, \" + \")?;\n                 }\n-                // We assume that the self type is $0 (i.e. the\n+                // We assume that the self type is ^0.0 (i.e. the\n                 // existential) here, which is the only thing that's\n                 // possible in actual Rust, and hence don't print it\n                 write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n@@ -783,6 +787,10 @@ fn write_bounds_like_dyn_trait(\n                 }\n                 ty.hir_fmt(f)?;\n             }\n+\n+            // FIXME implement these\n+            WhereClause::LifetimeOutlives(_) => {}\n+            WhereClause::TypeOutlives(_) => {}\n         }\n         first = false;\n     }\n@@ -837,6 +845,10 @@ impl HirDisplay for WhereClause {\n                 ty.hir_fmt(f)?;\n             }\n             WhereClause::AliasEq(_) => write!(f, \"{{error}}\")?,\n+\n+            // FIXME implement these\n+            WhereClause::TypeOutlives(..) => {}\n+            WhereClause::LifetimeOutlives(..) => {}\n         }\n         Ok(())\n     }\n@@ -881,9 +893,11 @@ impl HirDisplay for DomainGoal {\n             DomainGoal::Holds(wc) => {\n                 write!(f, \"Holds(\")?;\n                 wc.hir_fmt(f)?;\n-                write!(f, \")\")\n+                write!(f, \")\")?;\n             }\n+            _ => write!(f, \"?\")?,\n         }\n+        Ok(())\n     }\n }\n "}, {"sha": "bf2da2d4aee13f6ac73474d15736e4096ab3e67d", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -18,7 +18,7 @@ use std::mem;\n use std::ops::Index;\n use std::sync::Arc;\n \n-use chalk_ir::{cast::Cast, Mutability};\n+use chalk_ir::{cast::Cast, DebruijnIndex, Mutability};\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n@@ -38,11 +38,11 @@ use syntax::SmolStr;\n \n use super::{\n     DomainGoal, Guidance, InEnvironment, ProjectionTy, Solution, TraitEnvironment, TraitRef, Ty,\n-    TypeWalk,\n };\n use crate::{\n-    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n-    to_assoc_type_id, AliasEq, AliasTy, Canonical, Interner, TyBuilder, TyExt, TyKind,\n+    db::HirDatabase, fold_tys, infer::diagnostics::InferenceDiagnostic,\n+    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Canonical, Interner,\n+    TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -323,7 +323,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| self.insert_type_vars_shallow(ty))\n+        fold_tys(ty, |ty, _| self.insert_type_vars_shallow(ty), DebruijnIndex::INNERMOST)\n     }\n \n     fn resolve_obligations_as_possible(&mut self) {\n@@ -434,12 +434,16 @@ impl<'a> InferenceContext<'a> {\n     /// to do it as well.\n     fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n         let ty = self.resolve_ty_as_possible(ty);\n-        ty.fold(&mut |ty| match ty.kind(&Interner) {\n-            TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n-                self.normalize_projection_ty(proj_ty.clone())\n-            }\n-            _ => ty,\n-        })\n+        fold_tys(\n+            ty,\n+            |ty, _| match ty.kind(&Interner) {\n+                TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n+                    self.normalize_projection_ty(proj_ty.clone())\n+                }\n+                _ => ty,\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n     }\n \n     fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {"}, {"sha": "1f463a4255671033dc35f6275cd0b7f03ad01428", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -71,12 +71,14 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         // Pointer weakening and function to pointer\n-        match (from_ty.interned_mut(), to_ty.kind(&Interner)) {\n+        match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n             // `*mut T` -> `*const T`\n+            (TyKind::Raw(_, inner), TyKind::Raw(m2 @ Mutability::Not, ..)) => {\n+                from_ty = TyKind::Raw(*m2, inner.clone()).intern(&Interner);\n+            }\n             // `&mut T` -> `&T`\n-            (TyKind::Raw(m1, ..), TyKind::Raw(m2 @ Mutability::Not, ..))\n-            | (TyKind::Ref(m1, ..), TyKind::Ref(m2 @ Mutability::Not, ..)) => {\n-                *m1 = *m2;\n+            (TyKind::Ref(_, lt, inner), TyKind::Ref(m2 @ Mutability::Not, ..)) => {\n+                from_ty = TyKind::Ref(*m2, lt.clone(), inner.clone()).intern(&Interner);\n             }\n             // `&T` -> `*const T`\n             // `&mut T` -> `*mut T`/`*const T`"}, {"sha": "cbbfa8b5c3a25fcf5eddcdc418aa94c6a128e773", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -3,7 +3,7 @@\n use std::iter::{repeat, repeat_with};\n use std::{mem, sync::Arc};\n \n-use chalk_ir::{cast::Cast, Mutability, TyVariableKind};\n+use chalk_ir::{cast::Cast, fold::Shift, Mutability, TyVariableKind};\n use hir_def::{\n     expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     path::{GenericArg, GenericArgs},\n@@ -24,7 +24,6 @@ use crate::{\n     utils::{generics, Generics},\n     AdtId, Binders, CallableDefId, FnPointer, FnSig, FnSubst, InEnvironment, Interner,\n     ProjectionTyExt, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n-    TypeWalk,\n };\n \n use super::{"}, {"sha": "a887e20b0b08aabbfb7607f8804dae85d1856b32", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 90, "deletions": 76, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -2,14 +2,17 @@\n \n use std::borrow::Cow;\n \n-use chalk_ir::{FloatTy, IntTy, TyVariableKind, UniverseIndex, VariableKind};\n+use chalk_ir::{\n+    cast::Cast, fold::Fold, interner::HasInterner, FloatTy, IntTy, TyVariableKind, UniverseIndex,\n+    VariableKind,\n+};\n use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n \n use super::{DomainGoal, InferenceContext};\n use crate::{\n-    AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds, DebruijnIndex, FnPointer, FnSubst,\n-    InEnvironment, InferenceVar, Interner, Scalar, Substitution, Ty, TyExt, TyKind, TypeWalk,\n-    WhereClause,\n+    fold_tys, static_lifetime, AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds,\n+    DebruijnIndex, FnPointer, FnSubst, InEnvironment, InferenceVar, Interner, Scalar, Substitution,\n+    Ty, TyExt, TyKind, WhereClause,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -34,7 +37,10 @@ where\n }\n \n #[derive(Debug)]\n-pub(super) struct Canonicalized<T> {\n+pub(super) struct Canonicalized<T>\n+where\n+    T: HasInterner<Interner = Interner>,\n+{\n     pub(super) value: Canonical<T>,\n     free_vars: Vec<(InferenceVar, TyVariableKind)>,\n }\n@@ -48,9 +54,14 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n         })\n     }\n \n-    fn do_canonicalize<T: TypeWalk>(&mut self, t: T, binders: DebruijnIndex) -> T {\n-        t.fold_binders(\n-            &mut |ty, binders| match ty.kind(&Interner) {\n+    fn do_canonicalize<T: Fold<Interner, Result = T> + HasInterner<Interner = Interner>>(\n+        &mut self,\n+        t: T,\n+        binders: DebruijnIndex,\n+    ) -> T {\n+        fold_tys(\n+            t,\n+            |ty, binders| match ty.kind(&Interner) {\n                 &TyKind::InferenceVar(var, kind) => {\n                     let inner = from_inference_var(var);\n                     if self.var_stack.contains(&inner) {\n@@ -76,7 +87,10 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n         )\n     }\n \n-    fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n+    fn into_canonicalized<T: HasInterner<Interner = Interner>>(\n+        self,\n+        result: T,\n+    ) -> Canonicalized<T> {\n         let kinds = self\n             .free_vars\n             .iter()\n@@ -103,28 +117,18 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n             DomainGoal::Holds(wc) => {\n                 DomainGoal::Holds(self.do_canonicalize(wc, DebruijnIndex::INNERMOST))\n             }\n+            _ => unimplemented!(),\n         };\n         self.into_canonicalized(InEnvironment { goal: result, environment: obligation.environment })\n     }\n }\n \n-impl<T> Canonicalized<T> {\n+impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n     pub(super) fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n-        ty.fold_binders(\n-            &mut |ty, binders| {\n-                if let TyKind::BoundVar(bound) = ty.kind(&Interner) {\n-                    if bound.debruijn >= binders {\n-                        let (v, k) = self.free_vars[bound.index];\n-                        TyKind::InferenceVar(v, k).intern(&Interner)\n-                    } else {\n-                        ty\n-                    }\n-                } else {\n-                    ty\n-                }\n-            },\n-            DebruijnIndex::INNERMOST,\n-        )\n+        crate::fold_free_vars(ty, |bound, _binders| {\n+            let (v, k) = self.free_vars[bound.index];\n+            TyKind::InferenceVar(v, k).intern(&Interner)\n+        })\n     }\n \n     pub(super) fn apply_solution(\n@@ -136,15 +140,17 @@ impl<T> Canonicalized<T> {\n         let new_vars = Substitution::from_iter(\n             &Interner,\n             solution.binders.iter(&Interner).map(|k| match k.kind {\n-                VariableKind::Ty(TyVariableKind::General) => ctx.table.new_type_var(),\n-                VariableKind::Ty(TyVariableKind::Integer) => ctx.table.new_integer_var(),\n-                VariableKind::Ty(TyVariableKind::Float) => ctx.table.new_float_var(),\n-                // HACK: Chalk can sometimes return new lifetime variables. We\n-                // want to just skip them, but to not mess up the indices of\n-                // other variables, we'll just create a new type variable in\n-                // their place instead. This should not matter (we never see the\n-                // actual *uses* of the lifetime variable).\n-                VariableKind::Lifetime => ctx.table.new_type_var(),\n+                VariableKind::Ty(TyVariableKind::General) => {\n+                    ctx.table.new_type_var().cast(&Interner)\n+                }\n+                VariableKind::Ty(TyVariableKind::Integer) => {\n+                    ctx.table.new_integer_var().cast(&Interner)\n+                }\n+                VariableKind::Ty(TyVariableKind::Float) => {\n+                    ctx.table.new_float_var().cast(&Interner)\n+                }\n+                // Chalk can sometimes return new lifetime variables. We just use the static lifetime everywhere\n+                VariableKind::Lifetime => static_lifetime().cast(&Interner),\n                 _ => panic!(\"const variable in solution\"),\n             }),\n         );\n@@ -488,55 +494,63 @@ impl InferenceTable {\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n     fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty.kind(&Interner) {\n-            &TyKind::InferenceVar(tv, kind) => {\n-                let inner = from_inference_var(tv);\n-                if tv_stack.contains(&inner) {\n-                    cov_mark::hit!(type_var_cycles_resolve_as_possible);\n-                    // recursive type\n-                    return self.type_variable_table.fallback_value(tv, kind);\n-                }\n-                if let Some(known_ty) =\n-                    self.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_as_possible_inner(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    ty\n+        fold_tys(\n+            ty,\n+            |ty, _| match ty.kind(&Interner) {\n+                &TyKind::InferenceVar(tv, kind) => {\n+                    let inner = from_inference_var(tv);\n+                    if tv_stack.contains(&inner) {\n+                        cov_mark::hit!(type_var_cycles_resolve_as_possible);\n+                        // recursive type\n+                        return self.type_variable_table.fallback_value(tv, kind);\n+                    }\n+                    if let Some(known_ty) =\n+                        self.var_unification_table.inlined_probe_value(inner).known()\n+                    {\n+                        // known_ty may contain other variables that are known by now\n+                        tv_stack.push(inner);\n+                        let result = self.resolve_ty_as_possible_inner(tv_stack, known_ty.clone());\n+                        tv_stack.pop();\n+                        result\n+                    } else {\n+                        ty\n+                    }\n                 }\n-            }\n-            _ => ty,\n-        })\n+                _ => ty,\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n     }\n \n     /// Resolves the type completely; type variables without known type are\n     /// replaced by TyKind::Unknown.\n     fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty.kind(&Interner) {\n-            &TyKind::InferenceVar(tv, kind) => {\n-                let inner = from_inference_var(tv);\n-                if tv_stack.contains(&inner) {\n-                    cov_mark::hit!(type_var_cycles_resolve_completely);\n-                    // recursive type\n-                    return self.type_variable_table.fallback_value(tv, kind);\n-                }\n-                if let Some(known_ty) =\n-                    self.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_completely_inner(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    self.type_variable_table.fallback_value(tv, kind)\n+        fold_tys(\n+            ty,\n+            |ty, _| match ty.kind(&Interner) {\n+                &TyKind::InferenceVar(tv, kind) => {\n+                    let inner = from_inference_var(tv);\n+                    if tv_stack.contains(&inner) {\n+                        cov_mark::hit!(type_var_cycles_resolve_completely);\n+                        // recursive type\n+                        return self.type_variable_table.fallback_value(tv, kind);\n+                    }\n+                    if let Some(known_ty) =\n+                        self.var_unification_table.inlined_probe_value(inner).known()\n+                    {\n+                        // known_ty may contain other variables that are known by now\n+                        tv_stack.push(inner);\n+                        let result = self.resolve_ty_completely_inner(tv_stack, known_ty.clone());\n+                        tv_stack.pop();\n+                        result\n+                    } else {\n+                        self.type_variable_table.fallback_value(tv, kind)\n+                    }\n                 }\n-            }\n-            _ => ty,\n-        })\n+                _ => ty,\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n     }\n }\n "}, {"sha": "874c9541139ee7ade5293678eeb46bd292c56821", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 118, "deletions": 10, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -1,5 +1,6 @@\n //! The type system. We currently use this to infer types for completion, hover\n //! information and various assists.\n+\n #[allow(unused)]\n macro_rules! eprintln {\n     ($($tt:tt)*) => { stdx::eprintln!($($tt)*) };\n@@ -17,7 +18,6 @@ mod chalk_cast;\n mod chalk_ext;\n mod builder;\n mod walk;\n-mod types;\n \n pub mod display;\n pub mod db;\n@@ -31,7 +31,11 @@ mod test_db;\n use std::sync::Arc;\n \n use base_db::salsa;\n-use chalk_ir::UintTy;\n+use chalk_ir::{\n+    fold::{Fold, Shift},\n+    interner::HasInterner,\n+    UintTy,\n+};\n use hir_def::{\n     expr::ExprId, type_ref::Rawness, ConstParamId, LifetimeParamId, TraitId, TypeAliasId,\n     TypeParamId,\n@@ -48,7 +52,6 @@ pub use lower::{\n     TyDefId, TyLoweringContext, ValueTyDefId,\n };\n pub use traits::{chalk::Interner, TraitEnvironment};\n-pub use types::*;\n pub use walk::TypeWalk;\n \n pub use chalk_ir::{\n@@ -65,6 +68,21 @@ pub type PlaceholderIndex = chalk_ir::PlaceholderIndex;\n pub type VariableKind = chalk_ir::VariableKind<Interner>;\n pub type VariableKinds = chalk_ir::VariableKinds<Interner>;\n pub type CanonicalVarKinds = chalk_ir::CanonicalVarKinds<Interner>;\n+pub type Binders<T> = chalk_ir::Binders<T>;\n+pub type Substitution = chalk_ir::Substitution<Interner>;\n+pub type GenericArg = chalk_ir::GenericArg<Interner>;\n+pub type GenericArgData = chalk_ir::GenericArgData<Interner>;\n+\n+pub type Ty = chalk_ir::Ty<Interner>;\n+pub type TyKind = chalk_ir::TyKind<Interner>;\n+pub type DynTy = chalk_ir::DynTy<Interner>;\n+pub type FnPointer = chalk_ir::FnPointer<Interner>;\n+// pub type FnSubst = chalk_ir::FnSubst<Interner>;\n+pub use chalk_ir::FnSubst;\n+pub type ProjectionTy = chalk_ir::ProjectionTy<Interner>;\n+pub type AliasTy = chalk_ir::AliasTy<Interner>;\n+pub type OpaqueTy = chalk_ir::OpaqueTy<Interner>;\n+pub type InferenceVar = chalk_ir::InferenceVar;\n \n pub type Lifetime = chalk_ir::Lifetime<Interner>;\n pub type LifetimeData = chalk_ir::LifetimeData<Interner>;\n@@ -79,9 +97,20 @@ pub type ChalkTraitId = chalk_ir::TraitId<Interner>;\n \n pub type FnSig = chalk_ir::FnSig<Interner>;\n \n+pub type InEnvironment<T> = chalk_ir::InEnvironment<T>;\n+pub type DomainGoal = chalk_ir::DomainGoal<Interner>;\n+pub type AliasEq = chalk_ir::AliasEq<Interner>;\n+pub type Solution = chalk_solve::Solution<Interner>;\n+pub type ConstrainedSubst = chalk_ir::ConstrainedSubst<Interner>;\n+pub type Guidance = chalk_solve::Guidance<Interner>;\n+pub type WhereClause = chalk_ir::WhereClause<Interner>;\n+\n // FIXME: get rid of this\n pub fn subst_prefix(s: &Substitution, n: usize) -> Substitution {\n-    Substitution::intern(s.interned()[..std::cmp::min(s.len(&Interner), n)].into())\n+    Substitution::from_iter(\n+        &Interner,\n+        s.interned()[..std::cmp::min(s.len(&Interner), n)].iter().cloned(),\n+    )\n }\n \n /// Return an index of a parameter in the generic type parameter list by it's id.\n@@ -91,12 +120,15 @@ pub fn param_idx(db: &dyn HirDatabase, id: TypeParamId) -> Option<usize> {\n \n pub fn wrap_empty_binders<T>(value: T) -> Binders<T>\n where\n-    T: TypeWalk,\n+    T: Fold<Interner, Result = T> + HasInterner<Interner = Interner>,\n {\n-    Binders::empty(&Interner, value.shifted_in_from(DebruijnIndex::ONE))\n+    Binders::empty(&Interner, value.shifted_in_from(&Interner, DebruijnIndex::ONE))\n }\n \n-pub fn make_only_type_binders<T>(num_vars: usize, value: T) -> Binders<T> {\n+pub fn make_only_type_binders<T: HasInterner<Interner = Interner>>(\n+    num_vars: usize,\n+    value: T,\n+) -> Binders<T> {\n     Binders::new(\n         VariableKinds::from_iter(\n             &Interner,\n@@ -108,7 +140,7 @@ pub fn make_only_type_binders<T>(num_vars: usize, value: T) -> Binders<T> {\n }\n \n // FIXME: get rid of this\n-pub fn make_canonical<T>(\n+pub fn make_canonical<T: HasInterner<Interner = Interner>>(\n     value: T,\n     kinds: impl IntoIterator<Item = TyVariableKind>,\n ) -> Canonical<T> {\n@@ -121,6 +153,14 @@ pub fn make_canonical<T>(\n     Canonical { value, binders: chalk_ir::CanonicalVarKinds::from_iter(&Interner, kinds) }\n }\n \n+pub type TraitRef = chalk_ir::TraitRef<Interner>;\n+\n+pub type QuantifiedWhereClause = Binders<WhereClause>;\n+\n+pub type QuantifiedWhereClauses = chalk_ir::QuantifiedWhereClauses<Interner>;\n+\n+pub type Canonical<T> = chalk_ir::Canonical<T>;\n+\n /// A function signature as seen by type inference: Several parameter types and\n /// one return type.\n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -144,7 +184,7 @@ impl CallableSig {\n             params_and_return: fn_ptr\n                 .substitution\n                 .clone()\n-                .shifted_out_to(DebruijnIndex::ONE)\n+                .shifted_out_to(&Interner, DebruijnIndex::ONE)\n                 .expect(\"unexpected lifetime vars in fn ptr\")\n                 .0\n                 .interned()\n@@ -164,7 +204,22 @@ impl CallableSig {\n     }\n }\n \n-impl Ty {}\n+impl Fold<Interner> for CallableSig {\n+    type Result = CallableSig;\n+\n+    fn fold_with<'i>(\n+        self,\n+        folder: &mut dyn chalk_ir::fold::Folder<'i, Interner>,\n+        outer_binder: DebruijnIndex,\n+    ) -> chalk_ir::Fallible<Self::Result>\n+    where\n+        Interner: 'i,\n+    {\n+        let vec = self.params_and_return.to_vec();\n+        let folded = vec.fold_with(folder, outer_binder)?;\n+        Ok(CallableSig { params_and_return: folded.into(), is_varargs: self.is_varargs })\n+    }\n+}\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub enum ImplTraitId {\n@@ -244,3 +299,56 @@ pub fn dummy_usize_const() -> Const {\n     }\n     .intern(&Interner)\n }\n+\n+pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + Fold<Interner>>(\n+    t: T,\n+    f: impl FnMut(BoundVar, DebruijnIndex) -> Ty,\n+) -> T::Result {\n+    use chalk_ir::{fold::Folder, Fallible};\n+    struct FreeVarFolder<F>(F);\n+    impl<'i, F: FnMut(BoundVar, DebruijnIndex) -> Ty + 'i> Folder<'i, Interner> for FreeVarFolder<F> {\n+        fn as_dyn(&mut self) -> &mut dyn Folder<'i, Interner> {\n+            self\n+        }\n+\n+        fn interner(&self) -> &'i Interner {\n+            &Interner\n+        }\n+\n+        fn fold_free_var_ty(\n+            &mut self,\n+            bound_var: BoundVar,\n+            outer_binder: DebruijnIndex,\n+        ) -> Fallible<Ty> {\n+            Ok(self.0(bound_var, outer_binder))\n+        }\n+    }\n+    t.fold_with(&mut FreeVarFolder(f), DebruijnIndex::INNERMOST).expect(\"fold failed unexpectedly\")\n+}\n+\n+pub(crate) fn fold_tys<T: HasInterner<Interner = Interner> + Fold<Interner>>(\n+    t: T,\n+    f: impl FnMut(Ty, DebruijnIndex) -> Ty,\n+    binders: DebruijnIndex,\n+) -> T::Result {\n+    use chalk_ir::{\n+        fold::{Folder, SuperFold},\n+        Fallible,\n+    };\n+    struct TyFolder<F>(F);\n+    impl<'i, F: FnMut(Ty, DebruijnIndex) -> Ty + 'i> Folder<'i, Interner> for TyFolder<F> {\n+        fn as_dyn(&mut self) -> &mut dyn Folder<'i, Interner> {\n+            self\n+        }\n+\n+        fn interner(&self) -> &'i Interner {\n+            &Interner\n+        }\n+\n+        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n+            let ty = ty.super_fold_with(self.as_dyn(), outer_binder)?;\n+            Ok(self.0(ty, outer_binder))\n+        }\n+    }\n+    t.fold_with(&mut TyFolder(f), binders).expect(\"fold failed unexpectedly\")\n+}"}, {"sha": "8a22d9ea35f5e482645a33765b542d005019d501", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -8,7 +8,7 @@\n use std::{iter, sync::Arc};\n \n use base_db::CrateId;\n-use chalk_ir::{cast::Cast, Mutability, Safety};\n+use chalk_ir::{cast::Cast, fold::Shift, interner::HasInterner, Mutability, Safety};\n use hir_def::{\n     adt::StructKind,\n     builtin_type::BuiltinType,\n@@ -35,7 +35,7 @@ use crate::{\n     AliasEq, AliasTy, Binders, BoundVar, CallableSig, DebruijnIndex, DynTy, FnPointer, FnSig,\n     FnSubst, ImplTraitId, OpaqueTy, PolyFnSig, ProjectionTy, QuantifiedWhereClause,\n     QuantifiedWhereClauses, ReturnTypeImplTrait, ReturnTypeImplTraits, Substitution,\n-    TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyKind, TypeWalk, WhereClause,\n+    TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyKind, WhereClause,\n };\n \n #[derive(Debug)]\n@@ -488,7 +488,7 @@ impl<'a> TyLoweringContext<'a> {\n                         };\n                         // We need to shift in the bound vars, since\n                         // associated_type_shorthand_candidates does not do that\n-                        let substs = substs.shifted_in_from(self.in_binders);\n+                        let substs = substs.shifted_in_from(&Interner, self.in_binders);\n                         // FIXME handle type parameters on the segment\n                         return Some(\n                             TyKind::Alias(AliasTy::Projection(ProjectionTy {\n@@ -847,7 +847,7 @@ pub fn associated_type_shorthand_candidates<R>(\n                 // FIXME: how to correctly handle higher-ranked bounds here?\n                 WhereClause::Implemented(tr) => search(\n                     tr.clone()\n-                        .shifted_out_to(DebruijnIndex::ONE)\n+                        .shifted_out_to(&Interner, DebruijnIndex::ONE)\n                         .expect(\"FIXME unexpected higher-ranked trait bound\"),\n                 ),\n                 _ => None,\n@@ -950,8 +950,7 @@ pub(crate) fn trait_environment_query(\n                 traits_in_scope\n                     .push((tr.self_type_parameter(&Interner).clone(), tr.hir_trait_id()));\n             }\n-            let program_clause: chalk_ir::ProgramClause<Interner> =\n-                pred.clone().to_chalk(db).cast(&Interner);\n+            let program_clause: chalk_ir::ProgramClause<Interner> = pred.clone().cast(&Interner);\n             clauses.push(program_clause.into_from_env_clause(&Interner));\n         }\n     }\n@@ -974,7 +973,7 @@ pub(crate) fn trait_environment_query(\n         let substs = TyBuilder::type_params_subst(db, trait_id);\n         let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution: substs };\n         let pred = WhereClause::Implemented(trait_ref);\n-        let program_clause: chalk_ir::ProgramClause<Interner> = pred.to_chalk(db).cast(&Interner);\n+        let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(&Interner);\n         clauses.push(program_clause.into_from_env_clause(&Interner));\n     }\n \n@@ -1016,22 +1015,16 @@ pub(crate) fn generic_defaults_query(\n                 p.default.as_ref().map_or(TyKind::Error.intern(&Interner), |t| ctx.lower_ty(t));\n \n             // Each default can only refer to previous parameters.\n-            ty = ty.fold_binders(\n-                &mut |ty, binders| match ty.kind(&Interner) {\n-                    TyKind::BoundVar(BoundVar { debruijn, index }) if *debruijn == binders => {\n-                        if *index >= idx {\n-                            // type variable default referring to parameter coming\n-                            // after it. This is forbidden (FIXME: report\n-                            // diagnostic)\n-                            TyKind::Error.intern(&Interner)\n-                        } else {\n-                            ty\n-                        }\n-                    }\n-                    _ => ty,\n-                },\n-                DebruijnIndex::INNERMOST,\n-            );\n+            ty = crate::fold_free_vars(ty, |bound, binders| {\n+                if bound.index >= idx && bound.debruijn == DebruijnIndex::INNERMOST {\n+                    // type variable default referring to parameter coming\n+                    // after it. This is forbidden (FIXME: report\n+                    // diagnostic)\n+                    TyKind::Error.intern(&Interner)\n+                } else {\n+                    bound.shifted_in_from(binders).to_ty(&Interner)\n+                }\n+            });\n \n             crate::make_only_type_binders(idx, ty)\n         })\n@@ -1307,6 +1300,6 @@ pub(crate) fn lower_to_chalk_mutability(m: hir_def::type_ref::Mutability) -> Mut\n     }\n }\n \n-fn make_binders<T>(generics: &Generics, value: T) -> Binders<T> {\n+fn make_binders<T: HasInterner<Interner = Interner>>(generics: &Generics, value: T) -> Binders<T> {\n     crate::make_only_type_binders(generics.len(), value)\n }"}, {"sha": "be3e4f09ab164196c00f4a922f7600b5811bca62", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -23,7 +23,7 @@ use crate::{\n     utils::all_super_traits,\n     AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, FnPointer, FnSig, ForeignDefId,\n     InEnvironment, Interner, Scalar, Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder,\n-    TyExt, TyKind, TypeWalk,\n+    TyExt, TyKind,\n };\n \n /// This is used as a key for indexing impls.\n@@ -757,20 +757,13 @@ pub(crate) fn inherent_impl_substs(\n /// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n /// num_vars_to_keep) by `TyKind::Unknown`.\n fn fallback_bound_vars(s: Substitution, num_vars_to_keep: usize) -> Substitution {\n-    s.fold_binders(\n-        &mut |ty, binders| {\n-            if let TyKind::BoundVar(bound) = ty.kind(&Interner) {\n-                if bound.index >= num_vars_to_keep && bound.debruijn >= binders {\n-                    TyKind::Error.intern(&Interner)\n-                } else {\n-                    ty\n-                }\n-            } else {\n-                ty\n-            }\n-        },\n-        DebruijnIndex::INNERMOST,\n-    )\n+    crate::fold_free_vars(s, |bound, binders| {\n+        if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n+            TyKind::Error.intern(&Interner)\n+        } else {\n+            bound.shifted_in_from(binders).to_ty(&Interner)\n+        }\n+    })\n }\n \n fn transform_receiver_ty("}, {"sha": "1cda72d2215d852141e5c427935e87aca6c7e27b", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -12,7 +12,7 @@ use crate::{\n     Solution, TraitRefExt, Ty, TyKind, WhereClause,\n };\n \n-use self::chalk::{from_chalk, Interner, ToChalk};\n+use self::chalk::Interner;\n \n pub(crate) mod chalk;\n \n@@ -81,6 +81,7 @@ pub(crate) fn trait_solve_query(\n             db.trait_data(it.hir_trait_id()).name.to_string()\n         }\n         DomainGoal::Holds(WhereClause::AliasEq(_)) => \"alias_eq\".to_string(),\n+        _ => \"??\".to_string(),\n     });\n     log::info!(\"trait_solve_query({})\", goal.value.goal.display(db));\n \n@@ -95,13 +96,12 @@ pub(crate) fn trait_solve_query(\n         }\n     }\n \n-    let canonical = goal.to_chalk(db).cast(&Interner);\n+    let canonical = goal.cast(&Interner);\n \n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)\n     let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };\n-    let solution = solve(db, krate, &u_canonical);\n-    solution.map(|solution| solution_from_chalk(db, solution))\n+    solve(db, krate, &u_canonical)\n }\n \n fn solve(\n@@ -169,26 +169,6 @@ fn is_chalk_print() -> bool {\n     std::env::var(\"CHALK_PRINT\").is_ok()\n }\n \n-fn solution_from_chalk(\n-    db: &dyn HirDatabase,\n-    solution: chalk_solve::Solution<Interner>,\n-) -> Solution {\n-    match solution {\n-        chalk_solve::Solution::Unique(constr_subst) => {\n-            Solution::Unique(from_chalk(db, constr_subst))\n-        }\n-        chalk_solve::Solution::Ambig(chalk_solve::Guidance::Definite(subst)) => {\n-            Solution::Ambig(Guidance::Definite(from_chalk(db, subst)))\n-        }\n-        chalk_solve::Solution::Ambig(chalk_solve::Guidance::Suggested(subst)) => {\n-            Solution::Ambig(Guidance::Suggested(from_chalk(db, subst)))\n-        }\n-        chalk_solve::Solution::Ambig(chalk_solve::Guidance::Unknown) => {\n-            Solution::Ambig(Guidance::Unknown)\n-        }\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum FnTrait {\n     FnOnce,"}, {"sha": "b8c390b2eab8d04e7b00ba9eb9b0c13c2f848d70", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -17,16 +17,14 @@ use super::ChalkContext;\n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n-    from_assoc_type_id,\n+    from_assoc_type_id, make_only_type_binders,\n     method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     to_assoc_type_id, to_chalk_trait_id,\n     utils::generics,\n     AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId, ProjectionTy, Substitution,\n     TraitRef, TraitRefExt, Ty, TyBuilder, TyExt, TyKind, WhereClause,\n };\n-use mapping::{\n-    convert_where_clauses, generic_predicate_to_inline_bound, make_binders, TypeAliasAsValue,\n-};\n+use mapping::{convert_where_clauses, generic_predicate_to_inline_bound, TypeAliasAsValue};\n \n pub use self::interner::Interner;\n pub(crate) use self::interner::*;\n@@ -86,7 +84,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n         let trait_: hir_def::TraitId = from_chalk(self.db, trait_id);\n \n-        let ty: Ty = from_chalk(self.db, parameters[0].assert_ty_ref(&Interner).clone());\n+        let ty: Ty = parameters[0].assert_ty_ref(&Interner).clone();\n \n         fn binder_kind(\n             ty: &Ty,\n@@ -187,16 +185,11 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                 let (datas, binders) = (*datas).as_ref().into_value_and_skipped_binders();\n                 let data = &datas.impl_traits[idx as usize];\n                 let bound = OpaqueTyDatumBound {\n-                    bounds: make_binders(\n-                        data.bounds\n-                            .skip_binders()\n-                            .iter()\n-                            .cloned()\n-                            .map(|b| b.to_chalk(self.db))\n-                            .collect(),\n+                    bounds: make_only_type_binders(\n                         1,\n+                        data.bounds.skip_binders().iter().cloned().collect(),\n                     ),\n-                    where_clauses: make_binders(vec![], 0),\n+                    where_clauses: make_only_type_binders(0, vec![]),\n                 };\n                 chalk_ir::Binders::new(binders, bound)\n             }\n@@ -244,25 +237,25 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                             .intern(&Interner),\n                     });\n                     let bound = OpaqueTyDatumBound {\n-                        bounds: make_binders(\n+                        bounds: make_only_type_binders(\n+                            1,\n                             vec![\n-                                crate::wrap_empty_binders(impl_bound).to_chalk(self.db),\n-                                crate::wrap_empty_binders(proj_bound).to_chalk(self.db),\n+                                crate::wrap_empty_binders(impl_bound),\n+                                crate::wrap_empty_binders(proj_bound),\n                             ],\n-                            1,\n                         ),\n-                        where_clauses: make_binders(vec![], 0),\n+                        where_clauses: make_only_type_binders(0, vec![]),\n                     };\n                     // The opaque type has 1 parameter.\n-                    make_binders(bound, 1)\n+                    make_only_type_binders(1, bound)\n                 } else {\n                     // If failed to find Symbol\u2019s value as variable is void: Future::Output, return empty bounds as fallback.\n                     let bound = OpaqueTyDatumBound {\n-                        bounds: make_binders(vec![], 0),\n-                        where_clauses: make_binders(vec![], 0),\n+                        bounds: make_only_type_binders(0, vec![]),\n+                        where_clauses: make_only_type_binders(0, vec![]),\n                     };\n                     // The opaque type has 1 parameter.\n-                    make_binders(bound, 1)\n+                    make_only_type_binders(1, bound)\n                 }\n             }\n         };\n@@ -272,7 +265,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n \n     fn hidden_opaque_type(&self, _id: chalk_ir::OpaqueTyId<Interner>) -> chalk_ir::Ty<Interner> {\n         // FIXME: actually provide the hidden type; it is relevant for auto traits\n-        TyKind::Error.intern(&Interner).to_chalk(self.db)\n+        TyKind::Error.intern(&Interner)\n     }\n \n     fn is_object_safe(&self, _trait_id: chalk_ir::TraitId<Interner>) -> bool {\n@@ -293,29 +286,28 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Binders<rust_ir::FnDefInputsAndOutputDatum<Interner>> {\n-        let sig_ty: Ty =\n-            from_chalk(self.db, substs.at(&Interner, 0).assert_ty_ref(&Interner).clone());\n+        let sig_ty = substs.at(&Interner, 0).assert_ty_ref(&Interner).clone();\n         let sig = &sig_ty.callable_sig(self.db).expect(\"first closure param should be fn ptr\");\n         let io = rust_ir::FnDefInputsAndOutputDatum {\n-            argument_types: sig.params().iter().map(|ty| ty.clone().to_chalk(self.db)).collect(),\n-            return_type: sig.ret().clone().to_chalk(self.db),\n+            argument_types: sig.params().iter().cloned().collect(),\n+            return_type: sig.ret().clone(),\n         };\n-        make_binders(io.shifted_in(&Interner), 0)\n+        make_only_type_binders(0, io.shifted_in(&Interner))\n     }\n     fn closure_upvars(\n         &self,\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Binders<chalk_ir::Ty<Interner>> {\n-        let ty = TyBuilder::unit().to_chalk(self.db);\n-        make_binders(ty, 0)\n+        let ty = TyBuilder::unit();\n+        make_only_type_binders(0, ty)\n     }\n     fn closure_fn_substitution(\n         &self,\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Substitution<Interner> {\n-        Substitution::empty(&Interner).to_chalk(self.db)\n+        Substitution::empty(&Interner)\n     }\n \n     fn trait_name(&self, trait_id: chalk_ir::TraitId<Interner>) -> String {\n@@ -410,10 +402,10 @@ pub(crate) fn associated_ty_data_query(\n     let where_clauses = convert_where_clauses(db, type_alias.into(), &bound_vars);\n     let bound_data = rust_ir::AssociatedTyDatumBound { bounds, where_clauses };\n     let datum = AssociatedTyDatum {\n-        trait_id: trait_.to_chalk(db),\n+        trait_id: to_chalk_trait_id(trait_),\n         id,\n         name: type_alias,\n-        binders: make_binders(bound_data, generic_params.len()),\n+        binders: make_only_type_binders(generic_params.len(), bound_data),\n     };\n     Arc::new(datum)\n }\n@@ -446,7 +438,7 @@ pub(crate) fn trait_datum_query(\n         lang_attr(db.upcast(), trait_).and_then(|name| well_known_trait_from_lang_attr(&name));\n     let trait_datum = TraitDatum {\n         id: trait_id,\n-        binders: make_binders(trait_datum_bound, bound_vars.len(&Interner)),\n+        binders: make_only_type_binders(bound_vars.len(&Interner), trait_datum_bound),\n         flags,\n         associated_ty_ids,\n         well_known,\n@@ -515,7 +507,7 @@ pub(crate) fn struct_datum_query(\n         // FIXME set ADT kind\n         kind: rust_ir::AdtKind::Struct,\n         id: struct_id,\n-        binders: make_binders(struct_datum_bound, num_params),\n+        binders: make_only_type_binders(num_params, struct_datum_bound),\n         flags,\n     };\n     Arc::new(struct_datum)\n@@ -563,7 +555,6 @@ fn impl_def_datum(\n         trait_ref.display(db),\n         where_clauses\n     );\n-    let trait_ref = trait_ref.to_chalk(db);\n \n     let polarity = if negative { rust_ir::Polarity::Negative } else { rust_ir::Polarity::Positive };\n \n@@ -585,7 +576,7 @@ fn impl_def_datum(\n         .collect();\n     debug!(\"impl_datum: {:?}\", impl_datum_bound);\n     let impl_datum = ImplDatum {\n-        binders: make_binders(impl_datum_bound, bound_vars.len(&Interner)),\n+        binders: make_only_type_binders(bound_vars.len(&Interner), impl_datum_bound),\n         impl_type,\n         polarity,\n         associated_ty_value_ids,\n@@ -624,7 +615,7 @@ fn type_alias_associated_ty_value(\n         .associated_type_by_name(&type_alias_data.name)\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n     let (ty, binders) = db.ty(type_alias.into()).into_value_and_skipped_binders();\n-    let value_bound = rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n+    let value_bound = rust_ir::AssociatedTyValueBound { ty };\n     let value = rust_ir::AssociatedTyValue {\n         impl_id: impl_id.to_chalk(db),\n         associated_ty_id: to_assoc_type_id(assoc_ty),\n@@ -645,13 +636,13 @@ pub(crate) fn fn_def_datum_query(\n     let where_clauses = convert_where_clauses(db, callable_def.into(), &bound_vars);\n     let bound = rust_ir::FnDefDatumBound {\n         // Note: Chalk doesn't actually use this information yet as far as I am aware, but we provide it anyway\n-        inputs_and_output: make_binders(\n+        inputs_and_output: make_only_type_binders(\n+            0,\n             rust_ir::FnDefInputsAndOutputDatum {\n-                argument_types: sig.params().iter().map(|ty| ty.clone().to_chalk(db)).collect(),\n-                return_type: sig.ret().clone().to_chalk(db),\n+                argument_types: sig.params().iter().cloned().collect(),\n+                return_type: sig.ret().clone(),\n             }\n             .shifted_in(&Interner),\n-            0,\n         ),\n         where_clauses,\n     };"}, {"sha": "7818f6387eb28347f3d82f8a53066429d19133da", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 8, "deletions": 423, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -3,233 +3,20 @@\n //! Chalk (in both directions); plus some helper functions for more specialized\n //! conversions.\n \n-use chalk_ir::{cast::Cast, interner::HasInterner};\n+use chalk_ir::cast::Cast;\n use chalk_solve::rust_ir;\n \n use base_db::salsa::InternKey;\n use hir_def::{GenericDefId, TypeAliasId};\n \n use crate::{\n-    db::HirDatabase, static_lifetime, AliasTy, CallableDefId, Canonical, ConstrainedSubst,\n-    DomainGoal, FnPointer, GenericArg, InEnvironment, OpaqueTy, ProjectionTy, ProjectionTyExt,\n-    QuantifiedWhereClause, Substitution, TraitRef, Ty, TypeWalk, WhereClause,\n+    db::HirDatabase, AliasTy, CallableDefId, ProjectionTyExt, QuantifiedWhereClause, Substitution,\n+    Ty, WhereClause,\n };\n \n use super::interner::*;\n use super::*;\n \n-impl ToChalk for Ty {\n-    type Chalk = chalk_ir::Ty<Interner>;\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n-        match self.into_inner() {\n-            TyKind::Ref(m, lt, ty) => {\n-                chalk_ir::TyKind::Ref(m, lt, ty.to_chalk(db)).intern(&Interner)\n-            }\n-            TyKind::Array(ty, size) => {\n-                chalk_ir::TyKind::Array(ty.to_chalk(db), size).intern(&Interner)\n-            }\n-            TyKind::Function(FnPointer { sig, substitution: substs, num_binders }) => {\n-                let substitution = chalk_ir::FnSubst(substs.0.to_chalk(db));\n-                chalk_ir::TyKind::Function(chalk_ir::FnPointer { num_binders, sig, substitution })\n-                    .intern(&Interner)\n-            }\n-            TyKind::AssociatedType(assoc_type_id, substs) => {\n-                let substitution = substs.to_chalk(db);\n-                chalk_ir::TyKind::AssociatedType(assoc_type_id, substitution).intern(&Interner)\n-            }\n-\n-            TyKind::OpaqueType(id, substs) => {\n-                let substitution = substs.to_chalk(db);\n-                chalk_ir::TyKind::OpaqueType(id, substitution).intern(&Interner)\n-            }\n-\n-            TyKind::Foreign(id) => chalk_ir::TyKind::Foreign(id).intern(&Interner),\n-\n-            TyKind::Scalar(scalar) => chalk_ir::TyKind::Scalar(scalar).intern(&Interner),\n-\n-            TyKind::Tuple(cardinality, substs) => {\n-                let substitution = substs.to_chalk(db);\n-                chalk_ir::TyKind::Tuple(cardinality, substitution).intern(&Interner)\n-            }\n-            TyKind::Raw(mutability, ty) => {\n-                let ty = ty.to_chalk(db);\n-                chalk_ir::TyKind::Raw(mutability, ty).intern(&Interner)\n-            }\n-            TyKind::Slice(ty) => chalk_ir::TyKind::Slice(ty.to_chalk(db)).intern(&Interner),\n-            TyKind::Str => chalk_ir::TyKind::Str.intern(&Interner),\n-            TyKind::FnDef(id, substs) => {\n-                let substitution = substs.to_chalk(db);\n-                chalk_ir::TyKind::FnDef(id, substitution).intern(&Interner)\n-            }\n-            TyKind::Never => chalk_ir::TyKind::Never.intern(&Interner),\n-\n-            TyKind::Closure(closure_id, substs) => {\n-                let substitution = substs.to_chalk(db);\n-                chalk_ir::TyKind::Closure(closure_id, substitution).intern(&Interner)\n-            }\n-\n-            TyKind::Adt(adt_id, substs) => {\n-                let substitution = substs.to_chalk(db);\n-                chalk_ir::TyKind::Adt(adt_id, substitution).intern(&Interner)\n-            }\n-            TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n-                chalk_ir::AliasTy::Projection(proj_ty.to_chalk(db))\n-                    .cast(&Interner)\n-                    .intern(&Interner)\n-            }\n-            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n-                chalk_ir::AliasTy::Opaque(opaque_ty.to_chalk(db)).cast(&Interner).intern(&Interner)\n-            }\n-            TyKind::Placeholder(idx) => idx.to_ty::<Interner>(&Interner),\n-            TyKind::BoundVar(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n-            TyKind::InferenceVar(..) => panic!(\"uncanonicalized infer ty\"),\n-            TyKind::Dyn(dyn_ty) => {\n-                let (bounds, binders) = dyn_ty.bounds.into_value_and_skipped_binders();\n-                let where_clauses = chalk_ir::QuantifiedWhereClauses::from_iter(\n-                    &Interner,\n-                    bounds.interned().iter().cloned().map(|p| p.to_chalk(db)),\n-                );\n-                let bounded_ty = chalk_ir::DynTy {\n-                    bounds: chalk_ir::Binders::new(binders, where_clauses),\n-                    lifetime: dyn_ty.lifetime,\n-                };\n-                chalk_ir::TyKind::Dyn(bounded_ty).intern(&Interner)\n-            }\n-            TyKind::Error => chalk_ir::TyKind::Error.intern(&Interner),\n-        }\n-    }\n-    fn from_chalk(db: &dyn HirDatabase, chalk: chalk_ir::Ty<Interner>) -> Self {\n-        match chalk.data(&Interner).kind.clone() {\n-            chalk_ir::TyKind::Error => TyKind::Error,\n-            chalk_ir::TyKind::Array(ty, size) => TyKind::Array(from_chalk(db, ty), size),\n-            chalk_ir::TyKind::Placeholder(idx) => TyKind::Placeholder(idx),\n-            chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Projection(proj)) => {\n-                TyKind::Alias(AliasTy::Projection(from_chalk(db, proj)))\n-            }\n-            chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(opaque_ty)) => {\n-                TyKind::Alias(AliasTy::Opaque(from_chalk(db, opaque_ty)))\n-            }\n-            chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n-                num_binders,\n-                sig,\n-                substitution,\n-                ..\n-            }) => {\n-                assert_eq!(num_binders, 0);\n-                let substs = crate::FnSubst(from_chalk(db, substitution.0));\n-                TyKind::Function(FnPointer { num_binders, sig, substitution: substs })\n-            }\n-            chalk_ir::TyKind::BoundVar(idx) => TyKind::BoundVar(idx),\n-            chalk_ir::TyKind::InferenceVar(_iv, _kind) => TyKind::Error,\n-            chalk_ir::TyKind::Dyn(dyn_ty) => {\n-                assert_eq!(dyn_ty.bounds.binders.len(&Interner), 1);\n-                let (bounds, binders) = dyn_ty.bounds.into_value_and_skipped_binders();\n-                let where_clauses = crate::QuantifiedWhereClauses::from_iter(\n-                    &Interner,\n-                    bounds.interned().iter().cloned().map(|p| from_chalk(db, p)),\n-                );\n-                TyKind::Dyn(crate::DynTy {\n-                    bounds: crate::Binders::new(binders, where_clauses),\n-                    // HACK: we sometimes get lifetime variables back in solutions\n-                    // from Chalk, and don't have the infrastructure to substitute\n-                    // them yet. So for now we just turn them into 'static right\n-                    // when we get them\n-                    lifetime: static_lifetime(),\n-                })\n-            }\n-\n-            chalk_ir::TyKind::Adt(adt_id, subst) => TyKind::Adt(adt_id, from_chalk(db, subst)),\n-            chalk_ir::TyKind::AssociatedType(type_id, subst) => {\n-                TyKind::AssociatedType(type_id, from_chalk(db, subst))\n-            }\n-\n-            chalk_ir::TyKind::OpaqueType(opaque_type_id, subst) => {\n-                TyKind::OpaqueType(opaque_type_id, from_chalk(db, subst))\n-            }\n-\n-            chalk_ir::TyKind::Scalar(scalar) => TyKind::Scalar(scalar),\n-            chalk_ir::TyKind::Tuple(cardinality, subst) => {\n-                TyKind::Tuple(cardinality, from_chalk(db, subst))\n-            }\n-            chalk_ir::TyKind::Raw(mutability, ty) => TyKind::Raw(mutability, from_chalk(db, ty)),\n-            chalk_ir::TyKind::Slice(ty) => TyKind::Slice(from_chalk(db, ty)),\n-            chalk_ir::TyKind::Ref(mutability, _lifetime, ty) => {\n-                // HACK: we sometimes get lifetime variables back in solutions\n-                // from Chalk, and don't have the infrastructure to substitute\n-                // them yet. So for now we just turn them into 'static right\n-                // when we get them\n-                TyKind::Ref(mutability, static_lifetime(), from_chalk(db, ty))\n-            }\n-            chalk_ir::TyKind::Str => TyKind::Str,\n-            chalk_ir::TyKind::Never => TyKind::Never,\n-\n-            chalk_ir::TyKind::FnDef(fn_def_id, subst) => {\n-                TyKind::FnDef(fn_def_id, from_chalk(db, subst))\n-            }\n-\n-            chalk_ir::TyKind::Closure(id, subst) => TyKind::Closure(id, from_chalk(db, subst)),\n-\n-            chalk_ir::TyKind::Foreign(foreign_def_id) => TyKind::Foreign(foreign_def_id),\n-            chalk_ir::TyKind::Generator(_, _) => unimplemented!(), // FIXME\n-            chalk_ir::TyKind::GeneratorWitness(_, _) => unimplemented!(), // FIXME\n-        }\n-        .intern(&Interner)\n-    }\n-}\n-\n-impl ToChalk for GenericArg {\n-    type Chalk = chalk_ir::GenericArg<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> Self::Chalk {\n-        match self.interned() {\n-            crate::GenericArgData::Ty(ty) => ty.clone().to_chalk(db).cast(&Interner),\n-        }\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n-        match chalk.interned() {\n-            chalk_ir::GenericArgData::Ty(ty) => Ty::from_chalk(db, ty.clone()).cast(&Interner),\n-            chalk_ir::GenericArgData::Lifetime(_) => unimplemented!(),\n-            chalk_ir::GenericArgData::Const(_) => unimplemented!(),\n-        }\n-    }\n-}\n-\n-impl ToChalk for Substitution {\n-    type Chalk = chalk_ir::Substitution<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Substitution<Interner> {\n-        chalk_ir::Substitution::from_iter(\n-            &Interner,\n-            self.iter(&Interner).map(|ty| ty.clone().to_chalk(db)),\n-        )\n-    }\n-\n-    fn from_chalk(\n-        db: &dyn HirDatabase,\n-        parameters: chalk_ir::Substitution<Interner>,\n-    ) -> Substitution {\n-        let tys = parameters.iter(&Interner).map(|p| from_chalk(db, p.clone())).collect();\n-        Substitution::intern(tys)\n-    }\n-}\n-\n-impl ToChalk for TraitRef {\n-    type Chalk = chalk_ir::TraitRef<Interner>;\n-\n-    fn to_chalk(self: TraitRef, db: &dyn HirDatabase) -> chalk_ir::TraitRef<Interner> {\n-        let trait_id = self.trait_id;\n-        let substitution = self.substitution.to_chalk(db);\n-        chalk_ir::TraitRef { trait_id, substitution }\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, trait_ref: chalk_ir::TraitRef<Interner>) -> Self {\n-        let trait_id = trait_ref.trait_id;\n-        let substs = from_chalk(db, trait_ref.substitution);\n-        TraitRef { trait_id, substitution: substs }\n-    }\n-}\n-\n impl ToChalk for hir_def::TraitId {\n     type Chalk = TraitId;\n \n@@ -283,208 +70,6 @@ impl ToChalk for TypeAliasAsValue {\n     }\n }\n \n-impl ToChalk for WhereClause {\n-    type Chalk = chalk_ir::WhereClause<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::WhereClause<Interner> {\n-        match self {\n-            WhereClause::Implemented(trait_ref) => {\n-                chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db))\n-            }\n-            WhereClause::AliasEq(alias_eq) => chalk_ir::WhereClause::AliasEq(alias_eq.to_chalk(db)),\n-        }\n-    }\n-\n-    fn from_chalk(\n-        db: &dyn HirDatabase,\n-        where_clause: chalk_ir::WhereClause<Interner>,\n-    ) -> WhereClause {\n-        match where_clause {\n-            chalk_ir::WhereClause::Implemented(tr) => WhereClause::Implemented(from_chalk(db, tr)),\n-            chalk_ir::WhereClause::AliasEq(alias_eq) => {\n-                WhereClause::AliasEq(from_chalk(db, alias_eq))\n-            }\n-\n-            chalk_ir::WhereClause::LifetimeOutlives(_) => {\n-                // we shouldn't get these from Chalk\n-                panic!(\"encountered LifetimeOutlives from Chalk\")\n-            }\n-\n-            chalk_ir::WhereClause::TypeOutlives(_) => {\n-                // we shouldn't get these from Chalk\n-                panic!(\"encountered TypeOutlives from Chalk\")\n-            }\n-        }\n-    }\n-}\n-\n-impl ToChalk for ProjectionTy {\n-    type Chalk = chalk_ir::ProjectionTy<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::ProjectionTy<Interner> {\n-        chalk_ir::ProjectionTy {\n-            associated_ty_id: self.associated_ty_id,\n-            substitution: self.substitution.to_chalk(db),\n-        }\n-    }\n-\n-    fn from_chalk(\n-        db: &dyn HirDatabase,\n-        projection_ty: chalk_ir::ProjectionTy<Interner>,\n-    ) -> ProjectionTy {\n-        ProjectionTy {\n-            associated_ty_id: projection_ty.associated_ty_id,\n-            substitution: from_chalk(db, projection_ty.substitution),\n-        }\n-    }\n-}\n-impl ToChalk for OpaqueTy {\n-    type Chalk = chalk_ir::OpaqueTy<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> Self::Chalk {\n-        chalk_ir::OpaqueTy {\n-            opaque_ty_id: self.opaque_ty_id,\n-            substitution: self.substitution.to_chalk(db),\n-        }\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n-        OpaqueTy {\n-            opaque_ty_id: chalk.opaque_ty_id,\n-            substitution: from_chalk(db, chalk.substitution),\n-        }\n-    }\n-}\n-\n-impl ToChalk for AliasTy {\n-    type Chalk = chalk_ir::AliasTy<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> Self::Chalk {\n-        match self {\n-            AliasTy::Projection(projection_ty) => {\n-                chalk_ir::AliasTy::Projection(projection_ty.to_chalk(db))\n-            }\n-            AliasTy::Opaque(opaque_ty) => chalk_ir::AliasTy::Opaque(opaque_ty.to_chalk(db)),\n-        }\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n-        match chalk {\n-            chalk_ir::AliasTy::Projection(projection_ty) => {\n-                AliasTy::Projection(from_chalk(db, projection_ty))\n-            }\n-            chalk_ir::AliasTy::Opaque(opaque_ty) => AliasTy::Opaque(from_chalk(db, opaque_ty)),\n-        }\n-    }\n-}\n-\n-impl ToChalk for AliasEq {\n-    type Chalk = chalk_ir::AliasEq<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::AliasEq<Interner> {\n-        chalk_ir::AliasEq { alias: self.alias.to_chalk(db), ty: self.ty.to_chalk(db) }\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, alias_eq: chalk_ir::AliasEq<Interner>) -> Self {\n-        AliasEq { alias: from_chalk(db, alias_eq.alias), ty: from_chalk(db, alias_eq.ty) }\n-    }\n-}\n-\n-impl ToChalk for DomainGoal {\n-    type Chalk = chalk_ir::DomainGoal<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::DomainGoal<Interner> {\n-        match self {\n-            DomainGoal::Holds(WhereClause::Implemented(tr)) => tr.to_chalk(db).cast(&Interner),\n-            DomainGoal::Holds(WhereClause::AliasEq(alias_eq)) => {\n-                alias_eq.to_chalk(db).cast(&Interner)\n-            }\n-        }\n-    }\n-\n-    fn from_chalk(_db: &dyn HirDatabase, _goal: chalk_ir::DomainGoal<Interner>) -> Self {\n-        unimplemented!()\n-    }\n-}\n-\n-impl<T> ToChalk for Canonical<T>\n-where\n-    T: ToChalk,\n-    T::Chalk: HasInterner<Interner = Interner>,\n-{\n-    type Chalk = chalk_ir::Canonical<T::Chalk>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n-        let value = self.value.to_chalk(db);\n-        chalk_ir::Canonical { value, binders: self.binders }\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, canonical: chalk_ir::Canonical<T::Chalk>) -> Canonical<T> {\n-        Canonical { binders: canonical.binders, value: from_chalk(db, canonical.value) }\n-    }\n-}\n-\n-impl<T: ToChalk> ToChalk for InEnvironment<T>\n-where\n-    T::Chalk: chalk_ir::interner::HasInterner<Interner = Interner>,\n-{\n-    type Chalk = chalk_ir::InEnvironment<T::Chalk>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::InEnvironment<T::Chalk> {\n-        chalk_ir::InEnvironment { environment: self.environment, goal: self.goal.to_chalk(db) }\n-    }\n-\n-    fn from_chalk(\n-        _db: &dyn HirDatabase,\n-        _in_env: chalk_ir::InEnvironment<T::Chalk>,\n-    ) -> InEnvironment<T> {\n-        unimplemented!()\n-    }\n-}\n-\n-impl<T: ToChalk> ToChalk for crate::Binders<T>\n-where\n-    T::Chalk: chalk_ir::interner::HasInterner<Interner = Interner>,\n-{\n-    type Chalk = chalk_ir::Binders<T::Chalk>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Binders<T::Chalk> {\n-        let (value, binders) = self.into_value_and_skipped_binders();\n-        chalk_ir::Binders::new(binders, value.to_chalk(db))\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, binders: chalk_ir::Binders<T::Chalk>) -> crate::Binders<T> {\n-        let (v, b) = binders.into_value_and_skipped_binders();\n-        crate::Binders::new(b, from_chalk(db, v))\n-    }\n-}\n-\n-impl ToChalk for crate::ConstrainedSubst {\n-    type Chalk = chalk_ir::ConstrainedSubst<Interner>;\n-\n-    fn to_chalk(self, _db: &dyn HirDatabase) -> Self::Chalk {\n-        unimplemented!()\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n-        ConstrainedSubst { subst: from_chalk(db, chalk.subst) }\n-    }\n-}\n-\n-pub(super) fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T>\n-where\n-    T: HasInterner<Interner = Interner>,\n-{\n-    chalk_ir::Binders::new(\n-        chalk_ir::VariableKinds::from_iter(\n-            &Interner,\n-            std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General))\n-                .take(num_vars),\n-        ),\n-        value,\n-    )\n-}\n-\n pub(super) fn convert_where_clauses(\n     db: &dyn HirDatabase,\n     def: GenericDefId,\n@@ -493,7 +78,7 @@ pub(super) fn convert_where_clauses(\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());\n     for pred in generic_predicates.iter() {\n-        result.push(pred.clone().substitute(&Interner, substs).to_chalk(db));\n+        result.push(pred.clone().substitute(&Interner, substs));\n     }\n     result\n }\n@@ -505,7 +90,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n ) -> Option<chalk_ir::Binders<rust_ir::InlineBound<Interner>>> {\n     // An InlineBound is like a GenericPredicate, except the self type is left out.\n     // We don't have a special type for this, but Chalk does.\n-    let self_ty_shifted_in = self_ty.clone().shifted_in_from(DebruijnIndex::ONE);\n+    let self_ty_shifted_in = self_ty.clone().shifted_in_from(&Interner, DebruijnIndex::ONE);\n     let (pred, binders) = pred.as_ref().into_value_and_skipped_binders();\n     match pred {\n         WhereClause::Implemented(trait_ref) => {\n@@ -516,7 +101,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n             }\n             let args_no_self = trait_ref.substitution.interned()[1..]\n                 .iter()\n-                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .map(|ty| ty.clone().cast(&Interner))\n                 .collect();\n             let trait_bound = rust_ir::TraitBound { trait_id: trait_ref.trait_id, args_no_self };\n             Some(chalk_ir::Binders::new(binders, rust_ir::InlineBound::TraitBound(trait_bound)))\n@@ -528,10 +113,10 @@ pub(super) fn generic_predicate_to_inline_bound(\n             let trait_ = projection_ty.trait_(db);\n             let args_no_self = projection_ty.substitution.interned()[1..]\n                 .iter()\n-                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .map(|ty| ty.clone().cast(&Interner))\n                 .collect();\n             let alias_eq_bound = rust_ir::AliasEqBound {\n-                value: ty.clone().to_chalk(db),\n+                value: ty.clone(),\n                 trait_bound: rust_ir::TraitBound { trait_id: trait_.to_chalk(db), args_no_self },\n                 associated_ty_id: projection_ty.associated_ty_id,\n                 parameters: Vec::new(), // FIXME we don't support generic associated types yet"}, {"sha": "89adad10848a0458da1ca7802df1db78a83bcb4e", "filename": "crates/hir_ty/src/types.rs", "status": "removed", "additions": 0, "deletions": 549, "changes": 549, "blob_url": "https://github.com/rust-lang/rust/blob/5810299dba665f6077909208321703b580b7fe57/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5810299dba665f6077909208321703b580b7fe57/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftypes.rs?ref=5810299dba665f6077909208321703b580b7fe57", "patch": "@@ -1,549 +0,0 @@\n-//! This is the home of `Ty` etc. until they get replaced by their chalk_ir\n-//! equivalents.\n-\n-use std::sync::Arc;\n-\n-use chalk_ir::{\n-    cast::{Cast, CastTo, Caster},\n-    BoundVar, Mutability, Scalar, TyVariableKind,\n-};\n-use smallvec::SmallVec;\n-\n-use crate::{\n-    AssocTypeId, CanonicalVarKinds, ChalkTraitId, ClosureId, Const, FnDefId, FnSig, ForeignDefId,\n-    Interner, Lifetime, OpaqueTyId, PlaceholderIndex, TypeWalk, VariableKind, VariableKinds,\n-};\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct OpaqueTy {\n-    pub opaque_ty_id: OpaqueTyId,\n-    pub substitution: Substitution,\n-}\n-\n-/// A \"projection\" type corresponds to an (unnormalized)\n-/// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n-/// trait and all its parameters are fully known.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct ProjectionTy {\n-    pub associated_ty_id: AssocTypeId,\n-    pub substitution: Substitution,\n-}\n-\n-impl ProjectionTy {\n-    pub fn self_type_parameter(&self, interner: &Interner) -> Ty {\n-        self.substitution.interned()[0].assert_ty_ref(interner).clone()\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct DynTy {\n-    /// The unknown self type.\n-    pub bounds: Binders<QuantifiedWhereClauses>,\n-    pub lifetime: Lifetime,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct FnPointer {\n-    pub num_binders: usize,\n-    pub sig: FnSig,\n-    pub substitution: FnSubst,\n-}\n-/// A wrapper for the substs on a Fn.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct FnSubst(pub Substitution);\n-\n-impl FnPointer {\n-    /// Represent the current `Fn` as if it was wrapped in `Binders`\n-    pub fn into_binders(self, interner: &Interner) -> Binders<FnSubst> {\n-        Binders::new(\n-            VariableKinds::from_iter(\n-                interner,\n-                (0..self.num_binders).map(|_| VariableKind::Lifetime),\n-            ),\n-            self.substitution,\n-        )\n-    }\n-\n-    /// Represent the current `Fn` as if it was wrapped in `Binders`\n-    pub fn as_binders(&self, interner: &Interner) -> Binders<&FnSubst> {\n-        Binders::new(\n-            VariableKinds::from_iter(\n-                interner,\n-                (0..self.num_binders).map(|_| VariableKind::Lifetime),\n-            ),\n-            &self.substitution,\n-        )\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum AliasTy {\n-    /// A \"projection\" type corresponds to an (unnormalized)\n-    /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n-    /// trait and all its parameters are fully known.\n-    Projection(ProjectionTy),\n-    /// An opaque type (`impl Trait`).\n-    ///\n-    /// This is currently only used for return type impl trait; each instance of\n-    /// `impl Trait` in a return type gets its own ID.\n-    Opaque(OpaqueTy),\n-}\n-\n-/// A type.\n-///\n-/// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n-/// the same thing (but in a different way).\n-///\n-/// This should be cheap to clone.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum TyKind {\n-    /// Structures, enumerations and unions.\n-    Adt(chalk_ir::AdtId<Interner>, Substitution),\n-\n-    /// Represents an associated item like `Iterator::Item`.  This is used\n-    /// when we have tried to normalize a projection like `T::Item` but\n-    /// couldn't find a better representation.  In that case, we generate\n-    /// an **application type** like `(Iterator::Item)<T>`.\n-    AssociatedType(AssocTypeId, Substitution),\n-\n-    /// a scalar type like `bool` or `u32`\n-    Scalar(Scalar),\n-\n-    /// A tuple type.  For example, `(i32, bool)`.\n-    Tuple(usize, Substitution),\n-\n-    /// An array with the given length. Written as `[T; n]`.\n-    Array(Ty, Const),\n-\n-    /// The pointee of an array slice.  Written as `[T]`.\n-    Slice(Ty),\n-\n-    /// A raw pointer. Written as `*mut T` or `*const T`\n-    Raw(Mutability, Ty),\n-\n-    /// A reference; a pointer with an associated lifetime. Written as\n-    /// `&'a mut T` or `&'a T`.\n-    Ref(Mutability, Lifetime, Ty),\n-\n-    /// This represents a placeholder for an opaque type in situations where we\n-    /// don't know the hidden type (i.e. currently almost always). This is\n-    /// analogous to the `AssociatedType` type constructor.\n-    /// It is also used as the type of async block, with one type parameter\n-    /// representing the Future::Output type.\n-    OpaqueType(OpaqueTyId, Substitution),\n-\n-    /// The anonymous type of a function declaration/definition. Each\n-    /// function has a unique type, which is output (for a function\n-    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n-    ///\n-    /// This includes tuple struct / enum variant constructors as well.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar = foo; // bar: fn() -> i32 {foo}\n-    /// ```\n-    FnDef(FnDefId, Substitution),\n-\n-    /// The pointee of a string slice. Written as `str`.\n-    Str,\n-\n-    /// The never type `!`.\n-    Never,\n-\n-    /// The type of a specific closure.\n-    ///\n-    /// The closure signature is stored in a `FnPtr` type in the first type\n-    /// parameter.\n-    Closure(ClosureId, Substitution),\n-\n-    /// Represents a foreign type declared in external blocks.\n-    Foreign(ForeignDefId),\n-\n-    /// A pointer to a function.  Written as `fn() -> i32`.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar: fn() -> i32 = foo;\n-    /// ```\n-    Function(FnPointer),\n-\n-    /// An \"alias\" type represents some form of type alias, such as:\n-    /// - An associated type projection like `<T as Iterator>::Item`\n-    /// - `impl Trait` types\n-    /// - Named type aliases like `type Foo<X> = Vec<X>`\n-    Alias(AliasTy),\n-\n-    /// A placeholder for a type parameter; for example, `T` in `fn f<T>(x: T)\n-    /// {}` when we're type-checking the body of that function. In this\n-    /// situation, we know this stands for *some* type, but don't know the exact\n-    /// type.\n-    Placeholder(PlaceholderIndex),\n-\n-    /// A bound type variable. This is used in various places: when representing\n-    /// some polymorphic type like the type of function `fn f<T>`, the type\n-    /// parameters get turned into variables; during trait resolution, inference\n-    /// variables get turned into bound variables and back; and in `Dyn` the\n-    /// `Self` type is represented with a bound variable as well.\n-    BoundVar(BoundVar),\n-\n-    /// A type variable used during type checking.\n-    InferenceVar(InferenceVar, TyVariableKind),\n-\n-    /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n-    ///\n-    /// The predicates are quantified over the `Self` type, i.e. `Ty::Bound(0)`\n-    /// represents the `Self` type inside the bounds. This is currently\n-    /// implicit; Chalk has the `Binders` struct to make it explicit, but it\n-    /// didn't seem worth the overhead yet.\n-    Dyn(DynTy),\n-\n-    /// A placeholder for a type which could not be computed; this is propagated\n-    /// to avoid useless error messages. Doubles as a placeholder where type\n-    /// variables are inserted before type checking, since we want to try to\n-    /// infer a better type here anyway -- for the IDE use case, we want to try\n-    /// to infer as much as possible even in the presence of type errors.\n-    Error,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Ty(Arc<TyKind>);\n-\n-impl TyKind {\n-    pub fn intern(self, _interner: &Interner) -> Ty {\n-        Ty(Arc::new(self))\n-    }\n-}\n-\n-impl Ty {\n-    pub fn kind(&self, _interner: &Interner) -> &TyKind {\n-        &self.0\n-    }\n-\n-    pub fn interned_mut(&mut self) -> &mut TyKind {\n-        Arc::make_mut(&mut self.0)\n-    }\n-\n-    pub fn into_inner(self) -> TyKind {\n-        Arc::try_unwrap(self.0).unwrap_or_else(|a| (*a).clone())\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct GenericArg {\n-    interned: GenericArgData,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericArgData {\n-    Ty(Ty),\n-}\n-\n-impl GenericArg {\n-    /// Constructs a generic argument using `GenericArgData`.\n-    pub fn new(_interner: &Interner, data: GenericArgData) -> Self {\n-        GenericArg { interned: data }\n-    }\n-\n-    /// Gets the interned value.\n-    pub fn interned(&self) -> &GenericArgData {\n-        &self.interned\n-    }\n-\n-    /// Asserts that this is a type argument.\n-    pub fn assert_ty_ref(&self, interner: &Interner) -> &Ty {\n-        self.ty(interner).unwrap()\n-    }\n-\n-    /// Checks whether the generic argument is a type.\n-    pub fn is_ty(&self, _interner: &Interner) -> bool {\n-        match self.interned() {\n-            GenericArgData::Ty(_) => true,\n-        }\n-    }\n-\n-    /// Returns the type if it is one, `None` otherwise.\n-    pub fn ty(&self, _interner: &Interner) -> Option<&Ty> {\n-        match self.interned() {\n-            GenericArgData::Ty(t) => Some(t),\n-        }\n-    }\n-\n-    pub fn interned_mut(&mut self) -> &mut GenericArgData {\n-        &mut self.interned\n-    }\n-}\n-\n-/// A list of substitutions for generic parameters.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Substitution(SmallVec<[GenericArg; 2]>);\n-\n-impl Substitution {\n-    pub fn interned(&self) -> &SmallVec<[GenericArg; 2]> {\n-        &self.0\n-    }\n-\n-    pub fn len(&self, _: &Interner) -> usize {\n-        self.0.len()\n-    }\n-\n-    pub fn is_empty(&self, _: &Interner) -> bool {\n-        self.0.is_empty()\n-    }\n-\n-    pub fn at(&self, _: &Interner, i: usize) -> &GenericArg {\n-        &self.0[i]\n-    }\n-\n-    pub fn empty(_: &Interner) -> Substitution {\n-        Substitution(SmallVec::new())\n-    }\n-\n-    pub fn iter(&self, _: &Interner) -> std::slice::Iter<'_, GenericArg> {\n-        self.0.iter()\n-    }\n-\n-    pub fn from1(_interner: &Interner, ty: Ty) -> Substitution {\n-        Substitution::intern({\n-            let mut v = SmallVec::new();\n-            v.push(ty.cast(&Interner));\n-            v\n-        })\n-    }\n-\n-    pub fn from_iter(\n-        interner: &Interner,\n-        elements: impl IntoIterator<Item = impl CastTo<GenericArg>>,\n-    ) -> Self {\n-        Substitution(elements.into_iter().casted(interner).collect())\n-    }\n-\n-    pub fn apply<T: TypeWalk>(&self, value: T, _interner: &Interner) -> T {\n-        value.subst_bound_vars(self)\n-    }\n-\n-    // Temporary helper functions, to be removed\n-    pub fn intern(interned: SmallVec<[GenericArg; 2]>) -> Substitution {\n-        Substitution(interned)\n-    }\n-\n-    pub fn interned_mut(&mut self) -> &mut SmallVec<[GenericArg; 2]> {\n-        &mut self.0\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Hash)]\n-pub struct Binders<T> {\n-    /// The binders that quantify over the value.\n-    pub binders: VariableKinds,\n-    value: T,\n-}\n-\n-impl<T> Binders<T> {\n-    pub fn new(binders: VariableKinds, value: T) -> Self {\n-        Self { binders, value }\n-    }\n-\n-    pub fn empty(_interner: &Interner, value: T) -> Self {\n-        crate::make_only_type_binders(0, value)\n-    }\n-\n-    pub fn as_ref(&self) -> Binders<&T> {\n-        Binders { binders: self.binders.clone(), value: &self.value }\n-    }\n-\n-    pub fn map<U>(self, f: impl FnOnce(T) -> U) -> Binders<U> {\n-        Binders { binders: self.binders, value: f(self.value) }\n-    }\n-\n-    pub fn filter_map<U>(self, f: impl FnOnce(T) -> Option<U>) -> Option<Binders<U>> {\n-        Some(Binders { binders: self.binders, value: f(self.value)? })\n-    }\n-\n-    pub fn skip_binders(&self) -> &T {\n-        &self.value\n-    }\n-\n-    pub fn into_value_and_skipped_binders(self) -> (T, VariableKinds) {\n-        (self.value, self.binders)\n-    }\n-\n-    /// Returns the number of binders.\n-    pub fn len(&self, interner: &Interner) -> usize {\n-        self.binders.len(interner)\n-    }\n-\n-    // Temporary helper function, to be removed\n-    pub fn skip_binders_mut(&mut self) -> &mut T {\n-        &mut self.value\n-    }\n-}\n-\n-impl<T: Clone> Binders<&T> {\n-    pub fn cloned(&self) -> Binders<T> {\n-        Binders::new(self.binders.clone(), self.value.clone())\n-    }\n-}\n-\n-impl<T: TypeWalk> Binders<T> {\n-    /// Substitutes all variables.\n-    pub fn substitute(self, interner: &Interner, subst: &Substitution) -> T {\n-        let (value, binders) = self.into_value_and_skipped_binders();\n-        assert_eq!(subst.len(interner), binders.len(interner));\n-        value.subst_bound_vars(subst)\n-    }\n-}\n-\n-impl<T: std::fmt::Debug> std::fmt::Debug for Binders<T> {\n-    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n-        let Binders { ref binders, ref value } = *self;\n-        write!(fmt, \"for{:?} \", binders.inner_debug(&Interner))?;\n-        std::fmt::Debug::fmt(value, fmt)\n-    }\n-}\n-\n-/// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct TraitRef {\n-    pub trait_id: ChalkTraitId,\n-    pub substitution: Substitution,\n-}\n-\n-impl TraitRef {\n-    pub fn self_type_parameter(&self, interner: &Interner) -> Ty {\n-        self.substitution.at(interner, 0).assert_ty_ref(interner).clone()\n-    }\n-}\n-\n-/// Like `generics::WherePredicate`, but with resolved types: A condition on the\n-/// parameters of a generic item.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum WhereClause {\n-    /// The given trait needs to be implemented for its type parameters.\n-    Implemented(TraitRef),\n-    /// An associated type bindings like in `Iterator<Item = T>`.\n-    AliasEq(AliasEq),\n-}\n-\n-pub type QuantifiedWhereClause = Binders<WhereClause>;\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct QuantifiedWhereClauses(Arc<[QuantifiedWhereClause]>);\n-\n-impl QuantifiedWhereClauses {\n-    pub fn from_iter(\n-        _interner: &Interner,\n-        elements: impl IntoIterator<Item = QuantifiedWhereClause>,\n-    ) -> Self {\n-        QuantifiedWhereClauses(elements.into_iter().collect())\n-    }\n-\n-    pub fn interned(&self) -> &Arc<[QuantifiedWhereClause]> {\n-        &self.0\n-    }\n-\n-    pub fn interned_mut(&mut self) -> &mut Arc<[QuantifiedWhereClause]> {\n-        &mut self.0\n-    }\n-}\n-\n-/// Basically a claim (currently not validated / checked) that the contained\n-/// type / trait ref contains no inference variables; any inference variables it\n-/// contained have been replaced by bound variables, and `kinds` tells us how\n-/// many there are and whether they were normal or float/int variables. This is\n-/// used to erase irrelevant differences between types before using them in\n-/// queries.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Canonical<T> {\n-    pub value: T,\n-    pub binders: CanonicalVarKinds,\n-}\n-\n-/// Something (usually a goal), along with an environment.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct InEnvironment<T> {\n-    pub environment: chalk_ir::Environment<Interner>,\n-    pub goal: T,\n-}\n-\n-impl<T> InEnvironment<T> {\n-    pub fn new(environment: &chalk_ir::Environment<Interner>, value: T) -> InEnvironment<T> {\n-        InEnvironment { environment: environment.clone(), goal: value }\n-    }\n-}\n-\n-/// Something that needs to be proven (by Chalk) during type checking, e.g. that\n-/// a certain type implements a certain trait. Proving the Obligation might\n-/// result in additional information about inference variables.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum DomainGoal {\n-    Holds(WhereClause),\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct AliasEq {\n-    pub alias: AliasTy,\n-    pub ty: Ty,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct ConstrainedSubst {\n-    pub subst: Substitution,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-/// A (possible) solution for a proposed goal.\n-pub enum Solution {\n-    /// The goal indeed holds, and there is a unique value for all existential\n-    /// variables.\n-    Unique(Canonical<ConstrainedSubst>),\n-\n-    /// The goal may be provable in multiple ways, but regardless we may have some guidance\n-    /// for type inference. In this case, we don't return any lifetime\n-    /// constraints, since we have not \"committed\" to any particular solution\n-    /// yet.\n-    Ambig(Guidance),\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-/// When a goal holds ambiguously (e.g., because there are multiple possible\n-/// solutions), we issue a set of *guidance* back to type inference.\n-pub enum Guidance {\n-    /// The existential variables *must* have the given values if the goal is\n-    /// ever to hold, but that alone isn't enough to guarantee the goal will\n-    /// actually hold.\n-    Definite(Canonical<Substitution>),\n-\n-    /// There are multiple plausible values for the existentials, but the ones\n-    /// here are suggested as the preferred choice heuristically. These should\n-    /// be used for inference fallback only.\n-    Suggested(Canonical<Substitution>),\n-\n-    /// There's no useful information to feed back to type inference\n-    Unknown,\n-}\n-\n-/// The kinds of placeholders we need during type inference. There's separate\n-/// values for general types, and for integer and float variables. The latter\n-/// two are used for inference of literal values (e.g. `100` could be one of\n-/// several integer types).\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub struct InferenceVar {\n-    index: u32,\n-}\n-\n-impl From<u32> for InferenceVar {\n-    fn from(index: u32) -> InferenceVar {\n-        InferenceVar { index }\n-    }\n-}\n-\n-impl InferenceVar {\n-    /// Gets the underlying index value.\n-    pub fn index(self) -> u32 {\n-        self.index\n-    }\n-}"}, {"sha": "5f6cb052af73ca9c68a6c33ad5a3f4c7ef9ec946", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -1,8 +1,7 @@\n //! Helper functions for working with def, which don't need to be a separate\n //! query, but can't be computed directly from `*Data` (ie, which need a `db`).\n-use std::sync::Arc;\n \n-use chalk_ir::{BoundVar, DebruijnIndex};\n+use chalk_ir::{fold::Shift, BoundVar, DebruijnIndex};\n use hir_def::{\n     db::DefDatabase,\n     generics::{\n@@ -16,9 +15,7 @@ use hir_def::{\n };\n use hir_expand::name::{name, Name};\n \n-use crate::{\n-    db::HirDatabase, Interner, Substitution, TraitRef, TraitRefExt, TyKind, TypeWalk, WhereClause,\n-};\n+use crate::{db::HirDatabase, Interner, Substitution, TraitRef, TraitRefExt, TyKind, WhereClause};\n \n fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     let resolver = trait_.resolver(db);\n@@ -69,7 +66,7 @@ fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<Tr\n                 // FIXME: how to correctly handle higher-ranked bounds here?\n                 WhereClause::Implemented(tr) => Some(\n                     tr.clone()\n-                        .shifted_out_to(DebruijnIndex::ONE)\n+                        .shifted_out_to(&Interner, DebruijnIndex::ONE)\n                         .expect(\"FIXME unexpected higher-ranked trait bound\"),\n                 ),\n                 _ => None,\n@@ -137,15 +134,6 @@ pub(super) fn associated_type_by_name_including_super_traits(\n     })\n }\n \n-/// Helper for mutating `Arc<[T]>` (i.e. `Arc::make_mut` for Arc slices).\n-/// The underlying values are cloned if there are other strong references.\n-pub(crate) fn make_mut_slice<T: Clone>(a: &mut Arc<[T]>) -> &mut [T] {\n-    if Arc::get_mut(a).is_none() {\n-        *a = a.iter().cloned().collect();\n-    }\n-    Arc::get_mut(a).unwrap()\n-}\n-\n pub(crate) fn generics(db: &dyn DefDatabase, def: GenericDefId) -> Generics {\n     let parent_generics = parent_generic_def(db, def).map(|def| Box::new(generics(db, def)));\n     Generics { def, params: db.generic_params(def), parent_generics }"}, {"sha": "6ef1d53368bc4048203fb094cfdce96a11589836", "filename": "crates/hir_ty/src/walk.rs", "status": "modified", "additions": 7, "deletions": 280, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fwalk.rs?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -1,138 +1,17 @@\n //! The `TypeWalk` trait (probably to be replaced by Chalk's `Fold` and\n //! `Visit`).\n \n-use std::mem;\n-\n-use chalk_ir::DebruijnIndex;\n+use chalk_ir::interner::HasInterner;\n \n use crate::{\n-    utils::make_mut_slice, AliasEq, AliasTy, Binders, CallableSig, FnSubst, GenericArg,\n-    GenericArgData, Interner, OpaqueTy, ProjectionTy, Substitution, TraitRef, Ty, TyKind,\n-    WhereClause,\n+    AliasEq, AliasTy, Binders, CallableSig, FnSubst, GenericArg, GenericArgData, Interner,\n+    OpaqueTy, ProjectionTy, Substitution, TraitRef, Ty, TyKind, WhereClause,\n };\n \n /// This allows walking structures that contain types to do something with those\n /// types, similar to Chalk's `Fold` trait.\n pub trait TypeWalk {\n     fn walk(&self, f: &mut impl FnMut(&Ty));\n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.walk_mut_binders(&mut |ty, _binders| f(ty), DebruijnIndex::INNERMOST);\n-    }\n-    /// Walk the type, counting entered binders.\n-    ///\n-    /// `TyKind::Bound` variables use DeBruijn indexing, which means that 0 refers\n-    /// to the innermost binder, 1 to the next, etc.. So when we want to\n-    /// substitute a certain bound variable, we can't just walk the whole type\n-    /// and blindly replace each instance of a certain index; when we 'enter'\n-    /// things that introduce new bound variables, we have to keep track of\n-    /// that. Currently, the only thing that introduces bound variables on our\n-    /// side are `TyKind::Dyn` and `TyKind::Opaque`, which each introduce a bound\n-    /// variable for the self type.\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    );\n-\n-    fn fold_binders(\n-        mut self,\n-        f: &mut impl FnMut(Ty, DebruijnIndex) -> Ty,\n-        binders: DebruijnIndex,\n-    ) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.walk_mut_binders(\n-            &mut |ty_mut, binders| {\n-                let ty = mem::replace(ty_mut, TyKind::Error.intern(&Interner));\n-                *ty_mut = f(ty, binders);\n-            },\n-            binders,\n-        );\n-        self\n-    }\n-\n-    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.walk_mut(&mut |ty_mut| {\n-            let ty = mem::replace(ty_mut, TyKind::Error.intern(&Interner));\n-            *ty_mut = f(ty);\n-        });\n-        self\n-    }\n-\n-    /// Substitutes `TyKind::Bound` vars with the given substitution.\n-    fn subst_bound_vars(self, substs: &Substitution) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.subst_bound_vars_at_depth(substs, DebruijnIndex::INNERMOST)\n-    }\n-\n-    /// Substitutes `TyKind::Bound` vars with the given substitution.\n-    fn subst_bound_vars_at_depth(mut self, substs: &Substitution, depth: DebruijnIndex) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.walk_mut_binders(\n-            &mut |ty, binders| {\n-                if let &mut TyKind::BoundVar(bound) = ty.interned_mut() {\n-                    if bound.debruijn >= binders {\n-                        *ty = substs.interned()[bound.index]\n-                            .assert_ty_ref(&Interner)\n-                            .clone()\n-                            .shifted_in_from(binders);\n-                    }\n-                }\n-            },\n-            depth,\n-        );\n-        self\n-    }\n-\n-    fn shifted_in(self, _interner: &Interner) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.shifted_in_from(DebruijnIndex::ONE)\n-    }\n-\n-    /// Shifts up debruijn indices of `TyKind::Bound` vars by `n`.\n-    fn shifted_in_from(self, n: DebruijnIndex) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.fold_binders(\n-            &mut |ty, binders| match ty.kind(&Interner) {\n-                TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n-                    TyKind::BoundVar(bound.shifted_in_from(n)).intern(&Interner)\n-                }\n-                _ => ty,\n-            },\n-            DebruijnIndex::INNERMOST,\n-        )\n-    }\n-\n-    /// Shifts debruijn indices of `TyKind::Bound` vars out (down) by `n`.\n-    fn shifted_out_to(self, n: DebruijnIndex) -> Option<Self>\n-    where\n-        Self: Sized + std::fmt::Debug,\n-    {\n-        Some(self.fold_binders(\n-            &mut |ty, binders| {\n-                match ty.kind(&Interner) {\n-                    TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n-                        TyKind::BoundVar(bound.shifted_out_to(n).unwrap_or(bound.clone()))\n-                            .intern(&Interner)\n-                    }\n-                    _ => ty,\n-                }\n-            },\n-            DebruijnIndex::INNERMOST,\n-        ))\n-    }\n }\n \n impl TypeWalk for Ty {\n@@ -174,45 +53,6 @@ impl TypeWalk for Ty {\n         }\n         f(self);\n     }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        match self.interned_mut() {\n-            TyKind::Alias(AliasTy::Projection(p_ty)) => {\n-                p_ty.substitution.walk_mut_binders(f, binders);\n-            }\n-            TyKind::Dyn(dyn_ty) => {\n-                for p in make_mut_slice(dyn_ty.bounds.skip_binders_mut().interned_mut()) {\n-                    p.walk_mut_binders(f, binders.shifted_in());\n-                }\n-            }\n-            TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n-                o_ty.substitution.walk_mut_binders(f, binders);\n-            }\n-            TyKind::Slice(ty)\n-            | TyKind::Array(ty, _)\n-            | TyKind::Ref(_, _, ty)\n-            | TyKind::Raw(_, ty) => {\n-                ty.walk_mut_binders(f, binders);\n-            }\n-            TyKind::Function(fn_pointer) => {\n-                fn_pointer.substitution.0.walk_mut_binders(f, binders.shifted_in());\n-            }\n-            TyKind::Adt(_, substs)\n-            | TyKind::FnDef(_, substs)\n-            | TyKind::Tuple(_, substs)\n-            | TyKind::OpaqueType(_, substs)\n-            | TyKind::AssociatedType(_, substs)\n-            | TyKind::Closure(.., substs) => {\n-                substs.walk_mut_binders(f, binders);\n-            }\n-            _ => {}\n-        }\n-        f(self, binders);\n-    }\n }\n \n impl<T: TypeWalk> TypeWalk for Vec<T> {\n@@ -221,43 +61,18 @@ impl<T: TypeWalk> TypeWalk for Vec<T> {\n             t.walk(f);\n         }\n     }\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        for t in self {\n-            t.walk_mut_binders(f, binders);\n-        }\n-    }\n }\n \n impl TypeWalk for OpaqueTy {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         self.substitution.walk(f);\n     }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        self.substitution.walk_mut_binders(f, binders);\n-    }\n }\n \n impl TypeWalk for ProjectionTy {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         self.substitution.walk(f);\n     }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        self.substitution.walk_mut_binders(f, binders);\n-    }\n }\n \n impl TypeWalk for AliasTy {\n@@ -267,17 +82,6 @@ impl TypeWalk for AliasTy {\n             AliasTy::Opaque(it) => it.walk(f),\n         }\n     }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        match self {\n-            AliasTy::Projection(it) => it.walk_mut_binders(f, binders),\n-            AliasTy::Opaque(it) => it.walk_mut_binders(f, binders),\n-        }\n-    }\n }\n \n impl TypeWalk for GenericArg {\n@@ -286,18 +90,7 @@ impl TypeWalk for GenericArg {\n             GenericArgData::Ty(ty) => {\n                 ty.walk(f);\n             }\n-        }\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        match self.interned_mut() {\n-            GenericArgData::Ty(ty) => {\n-                ty.walk_mut_binders(f, binders);\n-            }\n+            _ => {}\n         }\n     }\n }\n@@ -308,62 +101,26 @@ impl TypeWalk for Substitution {\n             t.walk(f);\n         }\n     }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        for t in self.interned_mut() {\n-            t.walk_mut_binders(f, binders);\n-        }\n-    }\n }\n \n-impl<T: TypeWalk> TypeWalk for Binders<T> {\n+impl<T: TypeWalk + HasInterner<Interner = Interner>> TypeWalk for Binders<T> {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         self.skip_binders().walk(f);\n     }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        self.skip_binders_mut().walk_mut_binders(f, binders.shifted_in())\n-    }\n }\n \n impl TypeWalk for TraitRef {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         self.substitution.walk(f);\n     }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        self.substitution.walk_mut_binders(f, binders);\n-    }\n }\n \n impl TypeWalk for WhereClause {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         match self {\n             WhereClause::Implemented(trait_ref) => trait_ref.walk(f),\n             WhereClause::AliasEq(alias_eq) => alias_eq.walk(f),\n-        }\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        match self {\n-            WhereClause::Implemented(trait_ref) => trait_ref.walk_mut_binders(f, binders),\n-            WhereClause::AliasEq(alias_eq) => alias_eq.walk_mut_binders(f, binders),\n+            _ => {}\n         }\n     }\n }\n@@ -374,16 +131,6 @@ impl TypeWalk for CallableSig {\n             t.walk(f);\n         }\n     }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        for t in make_mut_slice(&mut self.params_and_return) {\n-            t.walk_mut_binders(f, binders);\n-        }\n-    }\n }\n \n impl TypeWalk for AliasEq {\n@@ -394,30 +141,10 @@ impl TypeWalk for AliasEq {\n             AliasTy::Opaque(opaque) => opaque.walk(f),\n         }\n     }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        self.ty.walk_mut_binders(f, binders);\n-        match &mut self.alias {\n-            AliasTy::Projection(projection_ty) => projection_ty.walk_mut_binders(f, binders),\n-            AliasTy::Opaque(opaque) => opaque.walk_mut_binders(f, binders),\n-        }\n-    }\n }\n \n-impl TypeWalk for FnSubst {\n+impl TypeWalk for FnSubst<Interner> {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         self.0.walk(f)\n     }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        self.0.walk_mut_binders(f, binders)\n-    }\n }"}, {"sha": "0571a912cbafb1289d84a549f40493b9a78de84a", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=72ad5cbe16a170d3c8a4c9d1bc04640b9e8404e0", "patch": "@@ -22,7 +22,7 @@ env_logger = { version = \"0.8.1\", default-features = false }\n itertools = \"0.10.0\"\n jod-thread = \"0.1.0\"\n log = \"0.4.8\"\n-lsp-types = { version = \"0.88.0\", features = [\"proposed\"] }\n+lsp-types = { version = \"0.89.0\", features = [\"proposed\"] }\n parking_lot = \"0.11.0\"\n xflags = \"0.2.1\"\n oorandom = \"11.1.2\""}]}