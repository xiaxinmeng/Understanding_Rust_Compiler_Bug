{"sha": "fb87e7ceed416f59196619df322710dfe5ba9cb3", "node_id": "C_kwDOAAsO6NoAKGZiODdlN2NlZWQ0MTZmNTkxOTY2MTlkZjMyMjcxMGRmZTViYTljYjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-06T11:01:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-06T11:01:02Z"}, "message": "Rollup merge of #92360 - jackh726:param-heuristics-1, r=davidtwco\n\nSome cleanups around check_argument_types\n\nSplit out in ways from my rebase/continuation of #71827\n\nCommits are mostly self-explanatory and these changes should be fairly straightforward", "tree": {"sha": "1c550ea00a6edd72346eab1cb009d90946ac05ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c550ea00a6edd72346eab1cb009d90946ac05ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb87e7ceed416f59196619df322710dfe5ba9cb3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1svuCRBK7hj4Ov3rIwAACoYIACL8HinulGrwnAR3Q4NZKJTx\nngFGiztaphAJKC4+06a4hAYLxwKY5VRNbeXG2v4uD0qNsJNnCB2tBRTWD6oawFuV\nmZkysge483jN8pIv16pZg+tvIf5ZezYmcykqaevJcOiGZYeAU8lrAB980T18L3HX\npM74KBBd8VvhBqmVyRQZoGx4Nk0vbBq4HQR7qsNW8KZMy2yJge2lPcPZz0ytS2zS\neS1Ah2DrHY/RGQX3AW7IZg/S3bCEEN7N1ve/QXRNfkOptG9m4LWXDQUgjYQ/49zj\nTVgkdOfF/LTgxLvIu7UYDApeNxmTQ+/+bgKb5e63KEqtWFwfJqrvS4u6x5Ryf2E=\n=Jdx9\n-----END PGP SIGNATURE-----\n", "payload": "tree 1c550ea00a6edd72346eab1cb009d90946ac05ac\nparent 4d0b567efb3407af5bd9c7452ddec193f9792c56\nparent bbb8bde98939db872e2b6092c0bf0c97f23e9da2\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1641466862 +0100\ncommitter GitHub <noreply@github.com> 1641466862 +0100\n\nRollup merge of #92360 - jackh726:param-heuristics-1, r=davidtwco\n\nSome cleanups around check_argument_types\n\nSplit out in ways from my rebase/continuation of #71827\n\nCommits are mostly self-explanatory and these changes should be fairly straightforward\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb87e7ceed416f59196619df322710dfe5ba9cb3", "html_url": "https://github.com/rust-lang/rust/commit/fb87e7ceed416f59196619df322710dfe5ba9cb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb87e7ceed416f59196619df322710dfe5ba9cb3/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d0b567efb3407af5bd9c7452ddec193f9792c56", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d0b567efb3407af5bd9c7452ddec193f9792c56", "html_url": "https://github.com/rust-lang/rust/commit/4d0b567efb3407af5bd9c7452ddec193f9792c56"}, {"sha": "bbb8bde98939db872e2b6092c0bf0c97f23e9da2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb8bde98939db872e2b6092c0bf0c97f23e9da2", "html_url": "https://github.com/rust-lang/rust/commit/bbb8bde98939db872e2b6092c0bf0c97f23e9da2"}], "stats": {"total": 245, "additions": 137, "deletions": 108}, "files": [{"sha": "eea8f40635d74a416ee51b9f6159c164b4222737", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb87e7ceed416f59196619df322710dfe5ba9cb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb87e7ceed416f59196619df322710dfe5ba9cb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=fb87e7ceed416f59196619df322710dfe5ba9cb3", "patch": "@@ -496,7 +496,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             call_expr.span,\n             call_expr,\n             fn_sig.inputs(),\n-            &expected_arg_tys,\n+            expected_arg_tys,\n             arg_exprs,\n             fn_sig.c_variadic,\n             TupleArgumentsFlag::DontTupleArguments,\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             call_expr.span,\n             call_expr,\n             fn_sig.inputs(),\n-            &expected_arg_tys,\n+            expected_arg_tys,\n             arg_exprs,\n             fn_sig.c_variadic,\n             TupleArgumentsFlag::TupleArguments,"}, {"sha": "e796fe58170d2e2bddaa87b7fdd111b248455c34", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 121, "deletions": 106, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/fb87e7ceed416f59196619df322710dfe5ba9cb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb87e7ceed416f59196619df322710dfe5ba9cb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=fb87e7ceed416f59196619df322710dfe5ba9cb3", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 sp,\n                 expr,\n                 &err_inputs,\n-                &[],\n+                vec![],\n                 args_no_rcvr,\n                 false,\n                 tuple_arguments,\n@@ -73,7 +73,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let method = method.unwrap();\n         // HACK(eddyb) ignore self in the definition (see above).\n-        let expected_arg_tys = self.expected_inputs_for_expected_output(\n+        let expected_input_tys = self.expected_inputs_for_expected_output(\n             sp,\n             expected,\n             method.sig.output(),\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             sp,\n             expr,\n             &method.sig.inputs()[1..],\n-            &expected_arg_tys[..],\n+            expected_input_tys,\n             args_no_rcvr,\n             method.sig.c_variadic,\n             tuple_arguments,\n@@ -96,34 +96,43 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// method calls and overloaded operators.\n     pub(in super::super) fn check_argument_types(\n         &self,\n-        sp: Span,\n-        expr: &'tcx hir::Expr<'tcx>,\n-        fn_inputs: &[Ty<'tcx>],\n-        expected_arg_tys: &[Ty<'tcx>],\n-        args: &'tcx [hir::Expr<'tcx>],\n+        // Span enclosing the call site\n+        call_span: Span,\n+        // Expression of the call site\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        // Types (as defined in the *signature* of the target function)\n+        formal_input_tys: &[Ty<'tcx>],\n+        // More specific expected types, after unifying with caller output types\n+        expected_input_tys: Vec<Ty<'tcx>>,\n+        // The expressions for each provided argument\n+        provided_args: &'tcx [hir::Expr<'tcx>],\n+        // Whether the function is variadic, for example when imported from C\n         c_variadic: bool,\n+        // Whether the arguments have been bundled in a tuple (ex: closures)\n         tuple_arguments: TupleArgumentsFlag,\n-        def_id: Option<DefId>,\n+        // The DefId for the function being called, for better error messages\n+        fn_def_id: Option<DefId>,\n     ) {\n         let tcx = self.tcx;\n         // Grab the argument types, supplying fresh type variables\n         // if the wrong number of arguments were supplied\n-        let supplied_arg_count = if tuple_arguments == DontTupleArguments { args.len() } else { 1 };\n+        let supplied_arg_count =\n+            if tuple_arguments == DontTupleArguments { provided_args.len() } else { 1 };\n \n         // All the input types from the fn signature must outlive the call\n         // so as to validate implied bounds.\n-        for (&fn_input_ty, arg_expr) in iter::zip(fn_inputs, args) {\n+        for (&fn_input_ty, arg_expr) in iter::zip(formal_input_tys, provided_args) {\n             self.register_wf_obligation(fn_input_ty.into(), arg_expr.span, traits::MiscObligation);\n         }\n \n-        let expected_arg_count = fn_inputs.len();\n+        let expected_arg_count = formal_input_tys.len();\n \n         let param_count_error = |expected_count: usize,\n                                  arg_count: usize,\n                                  error_code: &str,\n                                  c_variadic: bool,\n                                  sugg_unit: bool| {\n-            let (span, start_span, args, ctor_of) = match &expr.kind {\n+            let (span, start_span, args, ctor_of) = match &call_expr.kind {\n                 hir::ExprKind::Call(\n                     hir::Expr {\n                         span,\n@@ -156,14 +165,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     &args[1..], // Skip the receiver.\n                     None,       // methods are never ctors\n                 ),\n-                k => span_bug!(sp, \"checking argument types on a non-call: `{:?}`\", k),\n+                k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n             };\n-            let arg_spans = if args.is_empty() {\n+            let arg_spans = if provided_args.is_empty() {\n                 // foo()\n                 // ^^^-- supplied 0 arguments\n                 // |\n                 // expected 2 arguments\n-                vec![tcx.sess.source_map().next_point(start_span).with_hi(sp.hi())]\n+                vec![tcx.sess.source_map().next_point(start_span).with_hi(call_span.hi())]\n             } else {\n                 // foo(1, 2, 3)\n                 // ^^^ -  -  - supplied 3 arguments\n@@ -196,7 +205,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n \n-            if let Some(def_id) = def_id {\n+            if let Some(def_id) = fn_def_id {\n                 if let Some(def_span) = tcx.def_ident_span(def_id) {\n                     let mut spans: MultiSpan = def_span.into();\n \n@@ -218,7 +227,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             if sugg_unit {\n-                let sugg_span = tcx.sess.source_map().end_point(expr.span);\n+                let sugg_span = tcx.sess.source_map().end_point(call_expr.span);\n                 // remove closing `)` from the span\n                 let sugg_span = sugg_span.shrink_to_lo();\n                 err.span_suggestion(\n@@ -240,164 +249,170 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.emit();\n         };\n \n-        let mut expected_arg_tys = expected_arg_tys.to_vec();\n-\n-        let formal_tys = if tuple_arguments == TupleArguments {\n-            let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n+        let (formal_input_tys, expected_input_tys) = if tuple_arguments == TupleArguments {\n+            let tuple_type = self.structurally_resolved_type(call_span, formal_input_tys[0]);\n             match tuple_type.kind() {\n-                ty::Tuple(arg_types) if arg_types.len() != args.len() => {\n-                    param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n-                    expected_arg_tys = vec![];\n-                    self.err_args(args.len())\n+                ty::Tuple(arg_types) if arg_types.len() != provided_args.len() => {\n+                    param_count_error(arg_types.len(), provided_args.len(), \"E0057\", false, false);\n+                    (self.err_args(provided_args.len()), vec![])\n                 }\n                 ty::Tuple(arg_types) => {\n-                    expected_arg_tys = match expected_arg_tys.get(0) {\n+                    let expected_input_tys = match expected_input_tys.get(0) {\n                         Some(&ty) => match ty.kind() {\n                             ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n                             _ => vec![],\n                         },\n                         None => vec![],\n                     };\n-                    arg_types.iter().map(|k| k.expect_ty()).collect()\n+                    (arg_types.iter().map(|k| k.expect_ty()).collect(), expected_input_tys)\n                 }\n                 _ => {\n                     struct_span_err!(\n                         tcx.sess,\n-                        sp,\n+                        call_span,\n                         E0059,\n                         \"cannot use call notation; the first type parameter \\\n                          for the function trait is neither a tuple nor unit\"\n                     )\n                     .emit();\n-                    expected_arg_tys = vec![];\n-                    self.err_args(args.len())\n+                    (self.err_args(provided_args.len()), vec![])\n                 }\n             }\n         } else if expected_arg_count == supplied_arg_count {\n-            fn_inputs.to_vec()\n+            (formal_input_tys.to_vec(), expected_input_tys)\n         } else if c_variadic {\n             if supplied_arg_count >= expected_arg_count {\n-                fn_inputs.to_vec()\n+                (formal_input_tys.to_vec(), expected_input_tys)\n             } else {\n                 param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n-                expected_arg_tys = vec![];\n-                self.err_args(supplied_arg_count)\n+                (self.err_args(supplied_arg_count), vec![])\n             }\n         } else {\n             // is the missing argument of type `()`?\n-            let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_vars_if_possible(expected_arg_tys[0]).is_unit()\n-            } else if fn_inputs.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_vars_if_possible(fn_inputs[0]).is_unit()\n+            let sugg_unit = if expected_input_tys.len() == 1 && supplied_arg_count == 0 {\n+                self.resolve_vars_if_possible(expected_input_tys[0]).is_unit()\n+            } else if formal_input_tys.len() == 1 && supplied_arg_count == 0 {\n+                self.resolve_vars_if_possible(formal_input_tys[0]).is_unit()\n             } else {\n                 false\n             };\n             param_count_error(expected_arg_count, supplied_arg_count, \"E0061\", false, sugg_unit);\n \n-            expected_arg_tys = vec![];\n-            self.err_args(supplied_arg_count)\n+            (self.err_args(supplied_arg_count), vec![])\n         };\n \n         debug!(\n-            \"check_argument_types: formal_tys={:?}\",\n-            formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>()\n+            \"check_argument_types: formal_input_tys={:?}\",\n+            formal_input_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>()\n         );\n \n-        // If there is no expectation, expect formal_tys.\n-        let expected_arg_tys =\n-            if !expected_arg_tys.is_empty() { expected_arg_tys } else { formal_tys.clone() };\n+        // If there is no expectation, expect formal_input_tys.\n+        let expected_input_tys = if !expected_input_tys.is_empty() {\n+            expected_input_tys\n+        } else {\n+            formal_input_tys.clone()\n+        };\n+\n+        assert_eq!(expected_input_tys.len(), formal_input_tys.len());\n \n+        // Keep track of the fully coerced argument types\n         let mut final_arg_types: Vec<(usize, Ty<'_>, Ty<'_>)> = vec![];\n \n+        // We introduce a helper function to demand that a given argument satisfy a given input\n+        // This is more complicated than just checking type equality, as arguments could be coerced\n+        // This version writes those types back so further type checking uses the narrowed types\n+        let demand_compatible = |idx, final_arg_types: &mut Vec<(usize, Ty<'tcx>, Ty<'tcx>)>| {\n+            let formal_input_ty: Ty<'tcx> = formal_input_tys[idx];\n+            let expected_input_ty: Ty<'tcx> = expected_input_tys[idx];\n+            let provided_arg = &provided_args[idx];\n+\n+            debug!(\"checking argument {}: {:?} = {:?}\", idx, provided_arg, formal_input_ty);\n+\n+            // The special-cased logic below has three functions:\n+            // 1. Provide as good of an expected type as possible.\n+            let expectation = Expectation::rvalue_hint(self, expected_input_ty);\n+\n+            let checked_ty = self.check_expr_with_expectation(provided_arg, expectation);\n+\n+            // 2. Coerce to the most detailed type that could be coerced\n+            //    to, which is `expected_ty` if `rvalue_hint` returns an\n+            //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n+            let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n+\n+            // Keep track of these for below\n+            final_arg_types.push((idx, checked_ty, coerced_ty));\n+\n+            // Cause selection errors caused by resolving a single argument to point at the\n+            // argument and not the call. This is otherwise redundant with the `demand_coerce`\n+            // call immediately after, but it lets us customize the span pointed to in the\n+            // fulfillment error to be more accurate.\n+            let _ =\n+                self.resolve_vars_with_obligations_and_mutate_fulfillment(coerced_ty, |errors| {\n+                    self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n+                    self.point_at_arg_instead_of_call_if_possible(\n+                        errors,\n+                        &final_arg_types,\n+                        call_expr,\n+                        call_span,\n+                        provided_args,\n+                    );\n+                });\n+\n+            // We're processing function arguments so we definitely want to use\n+            // two-phase borrows.\n+            self.demand_coerce(&provided_arg, checked_ty, coerced_ty, None, AllowTwoPhase::Yes);\n+\n+            // 3. Relate the expected type and the formal one,\n+            //    if the expected type was used for the coercion.\n+            self.demand_suptype(provided_arg.span, formal_input_ty, coerced_ty);\n+        };\n+\n         // Check the arguments.\n         // We do this in a pretty awful way: first we type-check any arguments\n         // that are not closures, then we type-check the closures. This is so\n         // that we have more information about the types of arguments when we\n         // type-check the functions. This isn't really the right way to do this.\n         for check_closures in [false, true] {\n-            debug!(\"check_closures={}\", check_closures);\n-\n             // More awful hacks: before we check argument types, try to do\n             // an \"opportunistic\" trait resolution of any trait bounds on\n             // the call. This helps coercions.\n             if check_closures {\n                 self.select_obligations_where_possible(false, |errors| {\n-                    self.point_at_type_arg_instead_of_call_if_possible(errors, expr);\n+                    self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                     self.point_at_arg_instead_of_call_if_possible(\n                         errors,\n                         &final_arg_types,\n-                        expr,\n-                        sp,\n-                        &args,\n+                        call_expr,\n+                        call_span,\n+                        &provided_args,\n                     );\n                 })\n             }\n \n-            // For C-variadic functions, we don't have a declared type for all of\n-            // the arguments hence we only do our usual type checking with\n-            // the arguments who's types we do know.\n-            let t = if c_variadic {\n-                expected_arg_count\n-            } else if tuple_arguments == TupleArguments {\n-                args.len()\n-            } else {\n-                supplied_arg_count\n-            };\n-            for (i, arg) in args.iter().take(t).enumerate() {\n+            let minimum_input_count = formal_input_tys.len();\n+            for (idx, arg) in provided_args.iter().enumerate() {\n                 // Warn only for the first loop (the \"no closures\" one).\n                 // Closure arguments themselves can't be diverging, but\n                 // a previous argument can, e.g., `foo(panic!(), || {})`.\n                 if !check_closures {\n                     self.warn_if_unreachable(arg.hir_id, arg.span, \"expression\");\n                 }\n \n-                let is_closure = matches!(arg.kind, ExprKind::Closure(..));\n+                // For C-variadic functions, we don't have a declared type for all of\n+                // the arguments hence we only do our usual type checking with\n+                // the arguments who's types we do know. However, we *can* check\n+                // for unreachable expressions (see above).\n+                // FIXME: unreachable warning current isn't emitted\n+                if idx >= minimum_input_count {\n+                    continue;\n+                }\n \n+                let is_closure = matches!(arg.kind, ExprKind::Closure(..));\n                 if is_closure != check_closures {\n                     continue;\n                 }\n \n-                let formal_ty = formal_tys[i];\n-                debug!(\"checking argument {}: {:?} = {:?}\", i, arg, formal_ty);\n-\n-                // The special-cased logic below has three functions:\n-                // 1. Provide as good of an expected type as possible.\n-                let expected = Expectation::rvalue_hint(self, expected_arg_tys[i]);\n-\n-                let checked_ty = self.check_expr_with_expectation(&arg, expected);\n-\n-                // 2. Coerce to the most detailed type that could be coerced\n-                //    to, which is `expected_ty` if `rvalue_hint` returns an\n-                //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n-                let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n-\n-                final_arg_types.push((i, checked_ty, coerce_ty));\n-\n-                // Cause selection errors caused by resolving a single argument to point at the\n-                // argument and not the call. This is otherwise redundant with the `demand_coerce`\n-                // call immediately after, but it lets us customize the span pointed to in the\n-                // fulfillment error to be more accurate.\n-                let _ = self.resolve_vars_with_obligations_and_mutate_fulfillment(\n-                    coerce_ty,\n-                    |errors| {\n-                        self.point_at_type_arg_instead_of_call_if_possible(errors, expr);\n-                        self.point_at_arg_instead_of_call_if_possible(\n-                            errors,\n-                            &final_arg_types,\n-                            expr,\n-                            sp,\n-                            args,\n-                        );\n-                    },\n-                );\n-\n-                // We're processing function arguments so we definitely want to use\n-                // two-phase borrows.\n-                self.demand_coerce(&arg, checked_ty, coerce_ty, None, AllowTwoPhase::Yes);\n-\n-                // 3. Relate the expected type and the formal one,\n-                //    if the expected type was used for the coercion.\n-                self.demand_suptype(arg.span, formal_ty, coerce_ty);\n+                demand_compatible(idx, &mut final_arg_types);\n             }\n         }\n \n@@ -410,7 +425,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 MissingCastForVariadicArg { sess, span, ty, cast_ty }.diagnostic().emit()\n             }\n \n-            for arg in args.iter().skip(expected_arg_count) {\n+            for arg in provided_args.iter().skip(expected_arg_count) {\n                 let arg_ty = self.check_expr(&arg);\n \n                 // There are a few types which get autopromoted when passed via varargs"}, {"sha": "f60f6f3e808725d447f21d0c551d3cda1f1376c3", "filename": "src/test/ui/c-variadic/variadic-unreachable-arg-error.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb87e7ceed416f59196619df322710dfe5ba9cb3/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-unreachable-arg-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb87e7ceed416f59196619df322710dfe5ba9cb3/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-unreachable-arg-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-unreachable-arg-error.rs?ref=fb87e7ceed416f59196619df322710dfe5ba9cb3", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+#![feature(c_variadic)]\n+\n+extern \"C\" {\n+    fn foo(f: isize, x: u8, ...);\n+}\n+\n+fn main() {\n+    unsafe {\n+        // FIXME: Ideally we could give an unreachable warning\n+        foo(1, loop {}, 1usize);\n+    }\n+}"}]}