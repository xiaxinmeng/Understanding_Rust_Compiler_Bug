{"sha": "02962b374ecefd6f2a75956f4fb18806531d1d51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyOTYyYjM3NGVjZWZkNmYyYTc1OTU2ZjRmYjE4ODA2NTMxZDFkNTE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-04T22:00:44Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-06-05T15:08:27Z"}, "message": "Implement return position impl trait / opaque type support\n\nThis is working, but I'm not that happy with how the lowering works. We might\nneed an additional representation between `TypeRef` and `Ty` where names are\nresolved and `impl Trait` bounds are separated out, but things like inference\nvariables don't exist and `impl Trait` is always represented the same\nway.\n\nAlso note that this doesn't implement correct handling of RPIT *inside* the\nfunction (which involves turning the `impl Trait`s into variables and creating\nobligations for them). That intermediate representation might help there as\nwell.", "tree": {"sha": "7c807d6a09db7e485ea39c3e67331b99829a364c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c807d6a09db7e485ea39c3e67331b99829a364c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02962b374ecefd6f2a75956f4fb18806531d1d51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02962b374ecefd6f2a75956f4fb18806531d1d51", "html_url": "https://github.com/rust-lang/rust/commit/02962b374ecefd6f2a75956f4fb18806531d1d51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02962b374ecefd6f2a75956f4fb18806531d1d51/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c52f527a1cef7d39c2b1c55b49dc5459d392a4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c52f527a1cef7d39c2b1c55b49dc5459d392a4d", "html_url": "https://github.com/rust-lang/rust/commit/9c52f527a1cef7d39c2b1c55b49dc5459d392a4d"}], "stats": {"total": 472, "additions": 395, "deletions": 77}, "files": [{"sha": "bf71d38d6b23258382dd78bb89b52bb0d82d608c", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=02962b374ecefd6f2a75956f4fb18806531d1d51", "patch": "@@ -3,8 +3,8 @@\n use std::sync::Arc;\n \n use hir_def::{\n-    db::DefDatabase, DefWithBodyId, GenericDefId, ImplId, LocalFieldId, TraitId, TypeParamId,\n-    VariantId,\n+    db::DefDatabase, DefWithBodyId, FunctionId, GenericDefId, ImplId, LocalFieldId, TraitId,\n+    TypeParamId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::{impl_intern_key, salsa, CrateId, Upcast};\n@@ -13,8 +13,8 @@ use ra_prof::profile;\n use crate::{\n     method_resolution::{CrateImplDefs, TyFingerprint},\n     traits::{chalk, AssocTyValue, Impl},\n-    Binders, CallableDef, GenericPredicate, InferenceResult, PolyFnSig, Substs, TraitRef, Ty,\n-    TyDefId, TypeCtor, ValueTyDefId,\n+    Binders, CallableDef, GenericPredicate, InferenceResult, OpaqueTyId, PolyFnSig,\n+    ReturnTypeImplTraits, Substs, TraitRef, Ty, TyDefId, TypeCtor, ValueTyDefId,\n };\n use hir_expand::name::Name;\n \n@@ -48,6 +48,12 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::callable_item_sig)]\n     fn callable_item_signature(&self, def: CallableDef) -> PolyFnSig;\n \n+    #[salsa::invoke(crate::lower::return_type_impl_traits)]\n+    fn return_type_impl_traits(\n+        &self,\n+        def: FunctionId,\n+    ) -> Option<Arc<Binders<ReturnTypeImplTraits>>>;\n+\n     #[salsa::invoke(crate::lower::generic_predicates_for_param_query)]\n     #[salsa::cycle(crate::lower::generic_predicates_for_param_recover)]\n     fn generic_predicates_for_param(\n@@ -80,6 +86,8 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::interned]\n     fn intern_type_param_id(&self, param_id: TypeParamId) -> GlobalTypeParamId;\n     #[salsa::interned]\n+    fn intern_impl_trait_id(&self, id: OpaqueTyId) -> InternedOpaqueTyId;\n+    #[salsa::interned]\n     fn intern_chalk_impl(&self, impl_: Impl) -> crate::traits::GlobalImplId;\n     #[salsa::interned]\n     fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> crate::traits::AssocTyValueId;\n@@ -142,3 +150,7 @@ fn hir_database_is_object_safe() {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct GlobalTypeParamId(salsa::InternId);\n impl_intern_key!(GlobalTypeParamId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct InternedOpaqueTyId(salsa::InternId);\n+impl_intern_key!(InternedOpaqueTyId);"}, {"sha": "3e63a2415d8c64fb94d8bb6bdf3d48e060f9d911", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=02962b374ecefd6f2a75956f4fb18806531d1d51", "patch": "@@ -359,6 +359,21 @@ impl HirDisplay for ApplicationTy {\n                     write!(f, \">\")?;\n                 }\n             }\n+            TypeCtor::OpaqueType(opaque_ty_id) => {\n+                let bounds = match opaque_ty_id {\n+                    crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n+                        let datas =\n+                            f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n+                        let data = (*datas)\n+                            .as_ref()\n+                            .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                        data.clone().subst(&self.parameters)\n+                    }\n+                };\n+                write!(f, \"impl \")?;\n+                write_bounds_like_dyn_trait(&bounds.value, f)?;\n+                // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n+            }\n             TypeCtor::Closure { .. } => {\n                 let sig = self.parameters[0].callable_sig(f.db);\n                 if let Some(sig) = sig {\n@@ -427,14 +442,24 @@ impl HirDisplay for Ty {\n                 }\n             }\n             Ty::Bound(idx) => write!(f, \"?{}.{}\", idx.debruijn.depth(), idx.index)?,\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                match self {\n-                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n-                    Ty::Opaque(_) => write!(f, \"impl \")?,\n-                    _ => unreachable!(),\n-                };\n+            Ty::Dyn(predicates) => {\n+                write!(f, \"dyn \")?;\n                 write_bounds_like_dyn_trait(predicates, f)?;\n             }\n+            Ty::Opaque(opaque_ty) => {\n+                let bounds = match opaque_ty.opaque_ty_id {\n+                    crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n+                        let datas =\n+                            f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n+                        let data = (*datas)\n+                            .as_ref()\n+                            .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                        data.clone().subst(&opaque_ty.parameters)\n+                    }\n+                };\n+                write!(f, \"impl \")?;\n+                write_bounds_like_dyn_trait(&bounds.value, f)?;\n+            }\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n             Ty::Infer(..) => write!(f, \"_\")?,\n         }"}, {"sha": "d9bf3c2f0f22b12dab0247184f56ae6da4e2b421", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=02962b374ecefd6f2a75956f4fb18806531d1d51", "patch": "@@ -39,8 +39,8 @@ use ra_syntax::SmolStr;\n use super::{\n     primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    ApplicationTy, GenericPredicate, InEnvironment, ProjectionTy, Substs, TraitEnvironment,\n-    TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n+    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    TypeWalk, Uncertain,\n };\n use crate::{\n     db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n@@ -383,25 +383,6 @@ impl<'a> InferenceContext<'a> {\n     ) -> Ty {\n         match assoc_ty {\n             Some(res_assoc_ty) => {\n-                // FIXME:\n-                // Check if inner_ty is is `impl Trait` and contained input TypeAlias id\n-                // this is a workaround while Chalk assoc type projection doesn't always work yet,\n-                // but once that is fixed I don't think we should keep this\n-                // (we'll probably change how associated types are resolved anyway)\n-                if let Ty::Opaque(ref predicates) = inner_ty {\n-                    for p in predicates.iter() {\n-                        if let GenericPredicate::Projection(projection) = p {\n-                            if projection.projection_ty.associated_ty == res_assoc_ty {\n-                                if let ty_app!(_, params) = &projection.ty {\n-                                    if params.len() == 0 {\n-                                        return projection.ty.clone();\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n                 let ty = self.table.new_type_var();\n                 let builder = Substs::build_for_def(self.db, res_assoc_ty)\n                     .push(inner_ty)"}, {"sha": "135976fcda9e17832a4c9d351cb8f1611e8c92c5", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 89, "deletions": 9, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=02962b374ecefd6f2a75956f4fb18806531d1d51", "patch": "@@ -147,6 +147,12 @@ pub enum TypeCtor {\n     /// an **application type** like `(Iterator::Item)<T>`.\n     AssociatedType(TypeAliasId),\n \n+    /// This represents a placeholder for an opaque type in situations where we\n+    /// don't know the hidden type (i.e. currently almost always). This is\n+    /// analogous to the `AssociatedType` type constructor. As with that one,\n+    /// these are only produced by Chalk.\n+    OpaqueType(OpaqueTyId),\n+\n     /// The type of a specific closure.\n     ///\n     /// The closure signature is stored in a `FnPtr` type in the first type\n@@ -194,6 +200,14 @@ impl TypeCtor {\n                 let generic_params = generics(db.upcast(), type_alias.into());\n                 generic_params.len()\n             }\n+            TypeCtor::OpaqueType(opaque_ty_id) => {\n+                match opaque_ty_id {\n+                    OpaqueTyId::ReturnTypeImplTrait(func, _) => {\n+                        let generic_params = generics(db.upcast(), func.into());\n+                        generic_params.len()\n+                    }\n+                }\n+            }\n             TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n             TypeCtor::Tuple { cardinality } => cardinality as usize,\n         }\n@@ -220,6 +234,11 @@ impl TypeCtor {\n             TypeCtor::AssociatedType(type_alias) => {\n                 Some(type_alias.lookup(db.upcast()).module(db.upcast()).krate)\n             }\n+            TypeCtor::OpaqueType(opaque_ty_id) => match opaque_ty_id {\n+                OpaqueTyId::ReturnTypeImplTrait(func, _) => {\n+                    Some(func.lookup(db.upcast()).module(db.upcast()).krate)\n+                }\n+            },\n         }\n     }\n \n@@ -241,6 +260,7 @@ impl TypeCtor {\n             TypeCtor::Adt(adt) => Some(adt.into()),\n             TypeCtor::FnDef(callable) => Some(callable.into()),\n             TypeCtor::AssociatedType(type_alias) => Some(type_alias.into()),\n+            TypeCtor::OpaqueType(_impl_trait_id) => None,\n         }\n     }\n }\n@@ -254,6 +274,12 @@ pub struct ApplicationTy {\n     pub parameters: Substs,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct OpaqueTy {\n+    pub opaque_ty_id: OpaqueTyId,\n+    pub parameters: Substs,\n+}\n+\n /// A \"projection\" type corresponds to an (unnormalized)\n /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n /// trait and all its parameters are fully known.\n@@ -308,6 +334,12 @@ pub enum Ty {\n     /// trait and all its parameters are fully known.\n     Projection(ProjectionTy),\n \n+    /// An opaque type (`impl Trait`).\n+    ///\n+    /// This is currently only used for return type impl trait; each instance of\n+    /// `impl Trait` in a return type gets its own ID.\n+    Opaque(OpaqueTy),\n+\n     /// A placeholder for a type parameter; for example, `T` in `fn f<T>(x: T)\n     /// {}` when we're type-checking the body of that function. In this\n     /// situation, we know this stands for *some* type, but don't know the exact\n@@ -332,12 +364,6 @@ pub enum Ty {\n     /// didn't seem worth the overhead yet.\n     Dyn(Arc<[GenericPredicate]>),\n \n-    /// An opaque type (`impl Trait`).\n-    ///\n-    /// The predicates are quantified over the `Self` type; see `Ty::Dyn` for\n-    /// more.\n-    Opaque(Arc<[GenericPredicate]>),\n-\n     /// A placeholder for a type which could not be computed; this is propagated\n     /// to avoid useless error messages. Doubles as a placeholder where type\n     /// variables are inserted before type checking, since we want to try to\n@@ -490,7 +516,7 @@ impl Deref for Substs {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Binders<T> {\n     pub num_binders: usize,\n     pub value: T,\n@@ -534,6 +560,20 @@ impl<T: TypeWalk> Binders<T> {\n     }\n }\n \n+impl<T: TypeWalk> TypeWalk for Binders<T> {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.value.walk(f);\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        self.value.walk_mut_binders(f, binders.shifted_in())\n+    }\n+}\n+\n /// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n /// Name to be bikeshedded: TraitBound? TraitImplements?\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -947,11 +987,16 @@ impl TypeWalk for Ty {\n                     t.walk(f);\n                 }\n             }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+            Ty::Dyn(predicates) => {\n                 for p in predicates.iter() {\n                     p.walk(f);\n                 }\n             }\n+            Ty::Opaque(o_ty) => {\n+                for t in o_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n             Ty::Placeholder { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n@@ -969,13 +1014,48 @@ impl TypeWalk for Ty {\n             Ty::Projection(p_ty) => {\n                 p_ty.parameters.walk_mut_binders(f, binders);\n             }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+            Ty::Dyn(predicates) => {\n                 for p in make_mut_slice(predicates) {\n                     p.walk_mut_binders(f, binders.shifted_in());\n                 }\n             }\n+            Ty::Opaque(o_ty) => {\n+                o_ty.parameters.walk_mut_binders(f, binders);\n+            }\n             Ty::Placeholder { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self, binders);\n     }\n }\n+\n+impl<T: TypeWalk> TypeWalk for Vec<T> {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self {\n+            t.walk(f);\n+        }\n+    }\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        for t in self {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum OpaqueTyId {\n+    ReturnTypeImplTrait(hir_def::FunctionId, u16),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct ReturnTypeImplTraits {\n+    pub(crate) impl_traits: Vec<ReturnTypeImplTrait>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub(crate) struct ReturnTypeImplTrait {\n+    pub(crate) bounds: Binders<Vec<GenericPredicate>>,\n+}"}, {"sha": "dfc018b0bc5e708c76967a58a9f26ca08ad6033b", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 122, "deletions": 21, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=02962b374ecefd6f2a75956f4fb18806531d1d51", "patch": "@@ -31,8 +31,9 @@ use crate::{\n         all_super_trait_refs, associated_type_by_name_including_super_traits, generics,\n         make_mut_slice, variant_data,\n     },\n-    Binders, BoundVar, DebruijnIndex, FnSig, GenericPredicate, PolyFnSig, ProjectionPredicate,\n-    ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n+    Binders, BoundVar, DebruijnIndex, FnSig, GenericPredicate, OpaqueTy, OpaqueTyId, PolyFnSig,\n+    ProjectionPredicate, ProjectionTy, ReturnTypeImplTrait, ReturnTypeImplTraits, Substs,\n+    TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n use hir_expand::name::Name;\n \n@@ -47,7 +48,16 @@ pub struct TyLoweringContext<'a> {\n     /// possible currently, so this should be fine for now.\n     pub type_param_mode: TypeParamLoweringMode,\n     pub impl_trait_mode: ImplTraitLoweringMode,\n-    pub impl_trait_counter: std::cell::Cell<u16>,\n+    impl_trait_counter: std::cell::Cell<u16>,\n+    /// When turning `impl Trait` into opaque types, we have to collect the\n+    /// bounds at the same time to get the IDs correct (without becoming too\n+    /// complicated). I don't like using interior mutability (as for the\n+    /// counter), but I've tried and failed to make the lifetimes work for\n+    /// passing around a `&mut TyLoweringContext`. The core problem is that\n+    /// we're grouping the mutable data (the counter and this field) together\n+    /// with the immutable context (the references to the DB and resolver).\n+    /// Splitting this up would be a possible fix.\n+    opaque_type_data: std::cell::RefCell<Vec<ReturnTypeImplTrait>>,\n }\n \n impl<'a> TyLoweringContext<'a> {\n@@ -56,26 +66,42 @@ impl<'a> TyLoweringContext<'a> {\n         let impl_trait_mode = ImplTraitLoweringMode::Disallowed;\n         let type_param_mode = TypeParamLoweringMode::Placeholder;\n         let in_binders = DebruijnIndex::INNERMOST;\n-        Self { db, resolver, in_binders, impl_trait_mode, impl_trait_counter, type_param_mode }\n+        let opaque_type_data = std::cell::RefCell::new(Vec::new());\n+        Self {\n+            db,\n+            resolver,\n+            in_binders,\n+            impl_trait_mode,\n+            impl_trait_counter,\n+            type_param_mode,\n+            opaque_type_data,\n+        }\n     }\n \n-    pub fn with_shifted_in<T>(\n+    pub fn with_debruijn<T>(\n         &self,\n         debruijn: DebruijnIndex,\n         f: impl FnOnce(&TyLoweringContext) -> T,\n     ) -> T {\n+        let opaque_ty_data_vec = self.opaque_type_data.replace(Vec::new());\n         let new_ctx = Self {\n-            in_binders: self.in_binders.shifted_in_from(debruijn),\n+            in_binders: debruijn,\n             impl_trait_counter: std::cell::Cell::new(self.impl_trait_counter.get()),\n+            opaque_type_data: std::cell::RefCell::new(opaque_ty_data_vec),\n             ..*self\n         };\n         let result = f(&new_ctx);\n         self.impl_trait_counter.set(new_ctx.impl_trait_counter.get());\n+        self.opaque_type_data.replace(new_ctx.opaque_type_data.into_inner());\n         result\n     }\n \n-    pub fn shifted_in(self, debruijn: DebruijnIndex) -> Self {\n-        Self { in_binders: self.in_binders.shifted_in_from(debruijn), ..self }\n+    pub fn with_shifted_in<T>(\n+        &self,\n+        debruijn: DebruijnIndex,\n+        f: impl FnOnce(&TyLoweringContext) -> T,\n+    ) -> T {\n+        self.with_debruijn(self.in_binders.shifted_in_from(debruijn), f)\n     }\n \n     pub fn with_impl_trait_mode(self, impl_trait_mode: ImplTraitLoweringMode) -> Self {\n@@ -167,20 +193,47 @@ impl Ty {\n             TypeRef::ImplTrait(bounds) => {\n                 match ctx.impl_trait_mode {\n                     ImplTraitLoweringMode::Opaque => {\n-                        let self_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n-                        let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-                            bounds\n-                                .iter()\n-                                .flat_map(|b| {\n-                                    GenericPredicate::from_type_bound(ctx, b, self_ty.clone())\n-                                })\n-                                .collect()\n-                        });\n-                        Ty::Opaque(predicates)\n+                        let idx = ctx.impl_trait_counter.get();\n+                        ctx.impl_trait_counter.set(idx + 1);\n+\n+                        assert!(idx as usize == ctx.opaque_type_data.borrow().len());\n+                        // this dance is to make sure the data is in the right\n+                        // place even if we encounter more opaque types while\n+                        // lowering the bounds\n+                        ctx.opaque_type_data\n+                            .borrow_mut()\n+                            .push(ReturnTypeImplTrait { bounds: Binders::new(1, Vec::new()) });\n+                        // We don't want to lower the bounds inside the binders\n+                        // we're currently in, because they don't end up inside\n+                        // those binders. E.g. when we have `impl Trait<impl\n+                        // OtherTrait<T>>`, the `impl OtherTrait<T>` can't refer\n+                        // to the self parameter from `impl Trait`, and the\n+                        // bounds aren't actually stored nested within each\n+                        // other, but separately. So if the `T` refers to a type\n+                        // parameter of the outer function, it's just one binder\n+                        // away instead of two.\n+                        let actual_opaque_type_data = ctx\n+                            .with_debruijn(DebruijnIndex::INNERMOST, |ctx| {\n+                                ReturnTypeImplTrait::from_hir(ctx, &bounds)\n+                            });\n+                        ctx.opaque_type_data.borrow_mut()[idx as usize] = actual_opaque_type_data;\n+\n+                        let func = match ctx.resolver.generic_def() {\n+                            Some(GenericDefId::FunctionId(f)) => f,\n+                            _ => {\n+                                // this shouldn't happen\n+                                return (Ty::Unknown, None);\n+                            }\n+                        };\n+                        let impl_trait_id = OpaqueTyId::ReturnTypeImplTrait(func, idx);\n+                        let generics = generics(ctx.db.upcast(), func.into());\n+                        let parameters = Substs::bound_vars(&generics, ctx.in_binders);\n+                        Ty::Opaque(OpaqueTy { opaque_ty_id: impl_trait_id, parameters })\n                     }\n                     ImplTraitLoweringMode::Param => {\n                         let idx = ctx.impl_trait_counter.get();\n-                        ctx.impl_trait_counter.set(idx + 1);\n+                        // FIXME we're probably doing something wrong here\n+                        ctx.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n                         if let Some(def) = ctx.resolver.generic_def() {\n                             let generics = generics(ctx.db.upcast(), def);\n                             let param = generics\n@@ -197,7 +250,8 @@ impl Ty {\n                     }\n                     ImplTraitLoweringMode::Variable => {\n                         let idx = ctx.impl_trait_counter.get();\n-                        ctx.impl_trait_counter.set(idx + 1);\n+                        // FIXME we're probably doing something wrong here\n+                        ctx.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n                         let (parent_params, self_params, list_params, _impl_trait_params) =\n                             if let Some(def) = ctx.resolver.generic_def() {\n                                 let generics = generics(ctx.db.upcast(), def);\n@@ -663,6 +717,29 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         })\n }\n \n+impl ReturnTypeImplTrait {\n+    fn from_hir(ctx: &TyLoweringContext, bounds: &[TypeBound]) -> Self {\n+        let self_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n+        let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n+            bounds\n+                .iter()\n+                .flat_map(|b| GenericPredicate::from_type_bound(ctx, b, self_ty.clone()))\n+                .collect()\n+        });\n+        ReturnTypeImplTrait { bounds: Binders::new(1, predicates) }\n+    }\n+}\n+\n+fn count_impl_traits(type_ref: &TypeRef) -> usize {\n+    let mut count = 0;\n+    type_ref.walk(&mut |type_ref| {\n+        if matches!(type_ref, TypeRef::ImplTrait(_)) {\n+            count += 1;\n+        }\n+    });\n+    count\n+}\n+\n /// Build the signature of a callable item (function, struct or enum variant).\n pub fn callable_item_sig(db: &dyn HirDatabase, def: CallableDef) -> PolyFnSig {\n     match def {\n@@ -864,7 +941,9 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n         .with_impl_trait_mode(ImplTraitLoweringMode::Variable)\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n     let params = data.params.iter().map(|tr| Ty::from_hir(&ctx_params, tr)).collect::<Vec<_>>();\n-    let ctx_ret = ctx_params.with_impl_trait_mode(ImplTraitLoweringMode::Opaque);\n+    let ctx_ret = TyLoweringContext::new(db, &resolver)\n+        .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n+        .with_type_param_mode(TypeParamLoweringMode::Variable);\n     let ret = Ty::from_hir(&ctx_ret, &data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n     let num_binders = generics.len();\n@@ -1084,3 +1163,25 @@ pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<\n         TraitRef::from_hir(&ctx, target_trait, Some(self_ty.value))?,\n     ))\n }\n+\n+pub(crate) fn return_type_impl_traits(\n+    db: &impl HirDatabase,\n+    def: hir_def::FunctionId,\n+) -> Option<Arc<Binders<ReturnTypeImplTraits>>> {\n+    // FIXME unify with fn_sig_for_fn instead of doing lowering twice, maybe\n+    let data = db.function_data(def);\n+    let resolver = def.resolver(db.upcast());\n+    let ctx_ret = TyLoweringContext::new(db, &resolver)\n+        .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n+        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let _ret = Ty::from_hir(&ctx_ret, &data.ret_type);\n+    let generics = generics(db.upcast(), def.into());\n+    let num_binders = generics.len();\n+    let return_type_impl_traits =\n+        ReturnTypeImplTraits { impl_traits: ctx_ret.opaque_type_data.into_inner() };\n+    if return_type_impl_traits.impl_traits.is_empty() {\n+        None\n+    } else {\n+        Some(Arc::new(Binders::new(num_binders, return_type_impl_traits)))\n+    }\n+}"}, {"sha": "d83dc6d79f407340713bf6f5a5267e1cfb0a066b", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=02962b374ecefd6f2a75956f4fb18806531d1d51", "patch": "@@ -1110,7 +1110,6 @@ fn test() {\n }\n \n #[test]\n-#[ignore]\n fn impl_trait() {\n     assert_snapshot!(\n         infer(r#\"\n@@ -1160,6 +1159,52 @@ fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n     );\n }\n \n+#[test]\n+fn return_pos_impl_trait() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Iterator {\n+    type Item;\n+    fn next(&mut self) -> Self::Item;\n+}\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+}\n+fn bar() -> (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>) { loop {} }\n+fn baz<T>(t: T) -> (impl Iterator<Item = impl Trait<T>>, impl Trait<T>) { loop {} }\n+\n+fn test() {\n+    // let (a, b) = bar();\n+    // a.next().foo();\n+    // b.foo();\n+    let (c, d) = baz(1u128);\n+    c.next();//.foo();\n+    // d.foo();\n+}\n+\"#),\n+        @r###\"\n+    50..54 'self': &mut Self\n+    102..106 'self': &Self\n+    185..196 '{ loop {} }': ({unknown}, {unknown})\n+    187..194 'loop {}': !\n+    192..194 '{}': ()\n+    207..208 't': T\n+    269..280 '{ loop {} }': ({unknown}, {unknown})\n+    271..278 'loop {}': !\n+    276..278 '{}': ()\n+    292..429 '{     ...o(); }': ()\n+    368..374 '(c, d)': (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n+    369..370 'c': impl Iterator<Item = impl Trait<u128>>\n+    372..373 'd': impl Trait<u128>\n+    377..380 'baz': fn baz<u128>(u128) -> (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n+    377..387 'baz(1u128)': (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n+    381..386 '1u128': u128\n+    393..394 'c': impl Iterator<Item = impl Trait<u128>>\n+    393..401 'c.next()': impl Trait<u128>\n+    \"###\n+    );\n+}\n+\n #[test]\n fn dyn_trait() {\n     assert_snapshot!("}, {"sha": "a72a82f5a23a49cdfa85555952f389599cad44e1", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=02962b374ecefd6f2a75956f4fb18806531d1d51", "patch": "@@ -4,7 +4,7 @@ use std::sync::Arc;\n use log::debug;\n \n use chalk_ir::{fold::shift::Shift, GenericArg, TypeName};\n-use chalk_solve::rust_ir::{self, WellKnownTrait};\n+use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n use hir_def::{\n     lang_item::{lang_attr, LangItemTarget},\n@@ -100,6 +100,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn associated_ty_value(&self, id: AssociatedTyValueId) -> Arc<AssociatedTyValue> {\n         self.db.associated_ty_value(self.krate, id)\n     }\n+\n     fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<Interner>> {\n         vec![]\n     }\n@@ -130,11 +131,34 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         self.db.program_clauses_for_chalk_env(self.krate, environment.clone())\n     }\n \n-    fn opaque_ty_data(\n-        &self,\n-        _id: chalk_ir::OpaqueTyId<Interner>,\n-    ) -> Arc<rust_ir::OpaqueTyDatum<Interner>> {\n-        unimplemented!()\n+    fn opaque_ty_data(&self, id: chalk_ir::OpaqueTyId<Interner>) -> Arc<OpaqueTyDatum> {\n+        let interned_id = crate::db::InternedOpaqueTyId::from(id);\n+        let full_id = self.db.lookup_intern_impl_trait_id(interned_id);\n+        let (func, idx) = match full_id {\n+            crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => (func, idx),\n+        };\n+        let datas =\n+            self.db.return_type_impl_traits(func).expect(\"impl trait id without impl traits\");\n+        let data = &datas.value.impl_traits[idx as usize];\n+        let bound = OpaqueTyDatumBound {\n+            bounds: make_binders(\n+                data.bounds\n+                    .value\n+                    .iter()\n+                    .cloned()\n+                    .filter(|b| !b.is_error())\n+                    .map(|b| b.to_chalk(self.db))\n+                    .collect(),\n+                1,\n+            ),\n+        };\n+        let num_vars = datas.num_binders;\n+        Arc::new(OpaqueTyDatum { opaque_ty_id: id, bound: make_binders(bound, num_vars) })\n+    }\n+\n+    fn hidden_opaque_type(&self, _id: chalk_ir::OpaqueTyId<Interner>) -> chalk_ir::Ty<Interner> {\n+        // FIXME: actually provide the hidden type; it is relevant for auto traits\n+        Ty::Unknown.to_chalk(self.db)\n     }\n \n     fn force_impl_for(\n@@ -150,10 +174,6 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         // FIXME: implement actual object safety\n         true\n     }\n-\n-    fn hidden_opaque_type(&self, _id: chalk_ir::OpaqueTyId<Interner>) -> chalk_ir::Ty<Interner> {\n-        Ty::Unknown.to_chalk(self.db)\n-    }\n }\n \n pub(crate) fn program_clauses_for_chalk_env_query(\n@@ -460,6 +480,18 @@ impl From<crate::traits::GlobalImplId> for ImplId {\n     }\n }\n \n+impl From<OpaqueTyId> for crate::db::InternedOpaqueTyId {\n+    fn from(id: OpaqueTyId) -> Self {\n+        InternKey::from_intern_id(id.0)\n+    }\n+}\n+\n+impl From<crate::db::InternedOpaqueTyId> for OpaqueTyId {\n+    fn from(id: crate::db::InternedOpaqueTyId) -> Self {\n+        chalk_ir::OpaqueTyId(id.as_intern_id())\n+    }\n+}\n+\n impl From<rust_ir::AssociatedTyValueId<Interner>> for crate::traits::AssocTyValueId {\n     fn from(id: rust_ir::AssociatedTyValueId<Interner>) -> Self {\n         Self::from_intern_id(id.0)"}, {"sha": "56aab640c85f4667b682971e6a2fbc98369b914f", "filename": "crates/ra_hir_ty/src/traits/chalk/interner.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs?ref=02962b374ecefd6f2a75956f4fb18806531d1d51", "patch": "@@ -22,6 +22,8 @@ pub type AssociatedTyValueId = chalk_solve::rust_ir::AssociatedTyValueId<Interne\n pub type AssociatedTyValue = chalk_solve::rust_ir::AssociatedTyValue<Interner>;\n pub type FnDefId = chalk_ir::FnDefId<Interner>;\n pub type FnDefDatum = chalk_solve::rust_ir::FnDefDatum<Interner>;\n+pub type OpaqueTyId = chalk_ir::OpaqueTyId<Interner>;\n+pub type OpaqueTyDatum = chalk_solve::rust_ir::OpaqueTyDatum<Interner>;\n \n impl chalk_ir::interner::Interner for Interner {\n     type InternedType = Box<chalk_ir::TyData<Self>>; // FIXME use Arc?"}, {"sha": "834360430318c532993718f5b0ae999910aafa3d", "filename": "crates/ra_hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=02962b374ecefd6f2a75956f4fb18806531d1d51", "patch": "@@ -16,8 +16,8 @@ use crate::{\n     db::HirDatabase,\n     primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain},\n     traits::{builtin, AssocTyValue, Canonical, Impl, Obligation},\n-    ApplicationTy, CallableDef, GenericPredicate, InEnvironment, ProjectionPredicate, ProjectionTy,\n-    Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    ApplicationTy, CallableDef, GenericPredicate, InEnvironment, OpaqueTy, OpaqueTyId,\n+    ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n };\n \n use super::interner::*;\n@@ -68,7 +68,16 @@ impl ToChalk for Ty {\n                 let bounded_ty = chalk_ir::DynTy { bounds: make_binders(where_clauses, 1) };\n                 chalk_ir::TyData::Dyn(bounded_ty).intern(&Interner)\n             }\n-            Ty::Opaque(_) | Ty::Unknown => {\n+            Ty::Opaque(opaque_ty) => {\n+                let opaque_ty_id = opaque_ty.opaque_ty_id.to_chalk(db);\n+                let substitution = opaque_ty.parameters.to_chalk(db);\n+                chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n+                    opaque_ty_id,\n+                    substitution,\n+                }))\n+                .intern(&Interner)\n+            }\n+            Ty::Unknown => {\n                 let substitution = chalk_ir::Substitution::empty(&Interner);\n                 let name = TypeName::Error;\n                 chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n@@ -98,7 +107,11 @@ impl ToChalk for Ty {\n                 let parameters = from_chalk(db, proj.substitution);\n                 Ty::Projection(ProjectionTy { associated_ty, parameters })\n             }\n-            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(_)) => unimplemented!(),\n+            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(opaque_ty)) => {\n+                let impl_trait_id = from_chalk(db, opaque_ty.opaque_ty_id);\n+                let parameters = from_chalk(db, opaque_ty.substitution);\n+                Ty::Opaque(OpaqueTy { opaque_ty_id: impl_trait_id, parameters })\n+            }\n             chalk_ir::TyData::Function(chalk_ir::Fn { num_binders: _, substitution }) => {\n                 let parameters: Substs = from_chalk(db, substitution);\n                 Ty::Apply(ApplicationTy {\n@@ -204,6 +217,21 @@ impl ToChalk for hir_def::TraitId {\n     }\n }\n \n+impl ToChalk for OpaqueTyId {\n+    type Chalk = chalk_ir::OpaqueTyId<Interner>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::OpaqueTyId<Interner> {\n+        db.intern_impl_trait_id(self).into()\n+    }\n+\n+    fn from_chalk(\n+        db: &dyn HirDatabase,\n+        opaque_ty_id: chalk_ir::OpaqueTyId<Interner>,\n+    ) -> OpaqueTyId {\n+        db.lookup_intern_impl_trait_id(opaque_ty_id.into())\n+    }\n+}\n+\n impl ToChalk for TypeCtor {\n     type Chalk = TypeName<Interner>;\n \n@@ -214,6 +242,11 @@ impl ToChalk for TypeCtor {\n                 TypeName::AssociatedType(type_id)\n             }\n \n+            TypeCtor::OpaqueType(impl_trait_id) => {\n+                let id = impl_trait_id.to_chalk(db);\n+                TypeName::OpaqueType(id)\n+            }\n+\n             TypeCtor::Bool => TypeName::Scalar(Scalar::Bool),\n             TypeCtor::Char => TypeName::Scalar(Scalar::Char),\n             TypeCtor::Int(Uncertain::Known(int_ty)) => TypeName::Scalar(int_ty_to_chalk(int_ty)),\n@@ -252,7 +285,9 @@ impl ToChalk for TypeCtor {\n         match type_name {\n             TypeName::Adt(struct_id) => db.lookup_intern_type_ctor(struct_id.into()),\n             TypeName::AssociatedType(type_id) => TypeCtor::AssociatedType(from_chalk(db, type_id)),\n-            TypeName::OpaqueType(_) => unreachable!(),\n+            TypeName::OpaqueType(opaque_type_id) => {\n+                TypeCtor::OpaqueType(from_chalk(db, opaque_type_id))\n+            }\n \n             TypeName::Scalar(Scalar::Bool) => TypeCtor::Bool,\n             TypeName::Scalar(Scalar::Char) => TypeCtor::Char,"}, {"sha": "556af70989fe8fe00de104e4e1fb9e78af638c76", "filename": "crates/ra_hir_ty/src/traits/chalk/tls.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02962b374ecefd6f2a75956f4fb18806531d1d51/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=02962b374ecefd6f2a75956f4fb18806531d1d51", "patch": "@@ -69,6 +69,11 @@ impl DebugContext<'_> {\n                 let name = self.0.type_alias_data(type_alias).name.clone();\n                 write!(f, \"{}::{}\", trait_name, name)?;\n             }\n+            TypeCtor::OpaqueType(opaque_ty_id) => match opaque_ty_id {\n+                crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n+                    write!(f, \"{{impl trait {} of {:?}}}\", idx, func)?;\n+                }\n+            },\n             TypeCtor::Closure { def, expr } => {\n                 write!(f, \"{{closure {:?} in \", expr.into_raw())?;\n                 match def {"}]}