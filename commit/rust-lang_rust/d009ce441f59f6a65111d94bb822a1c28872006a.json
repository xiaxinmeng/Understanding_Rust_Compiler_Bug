{"sha": "d009ce441f59f6a65111d94bb822a1c28872006a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMDljZTQ0MWY1OWY2YTY1MTExZDk0YmI4MjJhMWMyODg3MjAwNmE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-29T19:23:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-29T19:23:50Z"}, "message": "Rollup merge of #69702 - anyska:tylayout-rename, r=oli-obk\n\nRename TyLayout to TyAndLayout.", "tree": {"sha": "30e2edf958428b64fbf2f92228649010d12be919", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30e2edf958428b64fbf2f92228649010d12be919"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d009ce441f59f6a65111d94bb822a1c28872006a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJegPXHCRBK7hj4Ov3rIwAAdHIIABpD1BoJRaTEEokh5ifetCi0\ncTqaOuTnF+Z3A2qXM852NFBJ+p9OdElLrz1Ti6j66acXP0B7jyE8voTwhpuzTbp0\nV3OMJthD9FjpB3scOh2ga2i+WRh4A4zfjmKoz7tbRKBmqnQbpYncDDDzPSuZPfcB\nON4eExetZszMV8cLuA/DFHbryoH539qjG8esqEA2pausKlafI1X4kT5owY1NNGuz\nqAGZB9VEACTDjkBBM2ubdLr5HrVODVAB+K1I3GKvF6gYKcqCfgI6gqWkvJjatard\nOll8V5Kmjrvhh58uTcFIABKfA7OVxIsC9kGhf44o93lZpsVPZch8uMh8jo8MPQc=\n=0aXk\n-----END PGP SIGNATURE-----\n", "payload": "tree 30e2edf958428b64fbf2f92228649010d12be919\nparent 285519d412ef9c65df3bcd2de2b1a3d6ca16a255\nparent 50d2c3abd59af8cbed7e001b5b4e2f6a9a011112\nauthor Dylan DPC <dylan.dpc@gmail.com> 1585509830 +0200\ncommitter GitHub <noreply@github.com> 1585509830 +0200\n\nRollup merge of #69702 - anyska:tylayout-rename, r=oli-obk\n\nRename TyLayout to TyAndLayout.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d009ce441f59f6a65111d94bb822a1c28872006a", "html_url": "https://github.com/rust-lang/rust/commit/d009ce441f59f6a65111d94bb822a1c28872006a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d009ce441f59f6a65111d94bb822a1c28872006a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "285519d412ef9c65df3bcd2de2b1a3d6ca16a255", "url": "https://api.github.com/repos/rust-lang/rust/commits/285519d412ef9c65df3bcd2de2b1a3d6ca16a255", "html_url": "https://github.com/rust-lang/rust/commit/285519d412ef9c65df3bcd2de2b1a3d6ca16a255"}, {"sha": "50d2c3abd59af8cbed7e001b5b4e2f6a9a011112", "url": "https://api.github.com/repos/rust-lang/rust/commits/50d2c3abd59af8cbed7e001b5b4e2f6a9a011112", "html_url": "https://github.com/rust-lang/rust/commit/50d2c3abd59af8cbed7e001b5b4e2f6a9a011112"}], "stats": {"total": 583, "additions": 298, "deletions": 285}, "files": [{"sha": "bfe9ed200a154e21956bdf142e1062b0ed3330a7", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -270,7 +270,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n     fn univariant_uninterned(\n         &self,\n         ty: Ty<'tcx>,\n-        fields: &[TyLayout<'_>],\n+        fields: &[TyAndLayout<'_>],\n         repr: &ReprOptions,\n         kind: StructKind,\n     ) -> Result<Layout, LayoutError<'tcx>> {\n@@ -293,7 +293,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             let end =\n                 if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n             let optimizing = &mut inverse_memory_index[..end];\n-            let field_align = |f: &TyLayout<'_>| {\n+            let field_align = |f: &TyAndLayout<'_>| {\n                 if let Some(pack) = pack { f.align.abi.min(pack) } else { f.align.abi }\n             };\n             match kind {\n@@ -422,11 +422,15 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     (\n                         Some((\n                             i,\n-                            &TyLayout { layout: &Layout { abi: Abi::Scalar(ref a), .. }, .. },\n+                            &TyAndLayout {\n+                                layout: &Layout { abi: Abi::Scalar(ref a), .. }, ..\n+                            },\n                         )),\n                         Some((\n                             j,\n-                            &TyLayout { layout: &Layout { abi: Abi::Scalar(ref b), .. }, .. },\n+                            &TyAndLayout {\n+                                layout: &Layout { abi: Abi::Scalar(ref b), .. }, ..\n+                            },\n                         )),\n                         None,\n                     ) => {\n@@ -485,7 +489,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         };\n         let scalar = |value: Primitive| tcx.intern_layout(Layout::scalar(self, scalar_unit(value)));\n \n-        let univariant = |fields: &[TyLayout<'_>], repr: &ReprOptions, kind| {\n+        let univariant = |fields: &[TyAndLayout<'_>], repr: &ReprOptions, kind| {\n             Ok(tcx.intern_layout(self.univariant_uninterned(ty, fields, repr, kind)?))\n         };\n         debug_assert!(!ty.has_infer_types_or_consts());\n@@ -754,7 +758,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 // but *not* an encoding of the discriminant (e.g., a tag value).\n                 // See issue #49298 for more details on the need to leave space\n                 // for non-ZST uninhabited data (mostly partial initialization).\n-                let absent = |fields: &[TyLayout<'_>]| {\n+                let absent = |fields: &[TyAndLayout<'_>]| {\n                     let uninhabited = fields.iter().any(|f| f.abi.is_uninhabited());\n                     let is_zst = fields.iter().all(|f| f.is_zst());\n                     uninhabited && is_zst\n@@ -1404,7 +1408,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let discr_int_ty = discr_int.to_ty(tcx, false);\n         let discr = Scalar { value: Primitive::Int(discr_int, false), valid_range: 0..=max_discr };\n         let discr_layout = self.tcx.intern_layout(Layout::scalar(self, discr.clone()));\n-        let discr_layout = TyLayout { ty: discr_int_ty, layout: discr_layout };\n+        let discr_layout = TyAndLayout { ty: discr_int_ty, layout: discr_layout };\n \n         let promoted_layouts = ineligible_locals\n             .iter()\n@@ -1573,15 +1577,15 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n     /// This is invoked by the `layout_raw` query to record the final\n     /// layout of each type.\n     #[inline(always)]\n-    fn record_layout_for_printing(&self, layout: TyLayout<'tcx>) {\n+    fn record_layout_for_printing(&self, layout: TyAndLayout<'tcx>) {\n         // If we are running with `-Zprint-type-sizes`, maybe record layouts\n         // for dumping later.\n         if self.tcx.sess.opts.debugging_opts.print_type_sizes {\n             self.record_layout_for_printing_outlined(layout)\n         }\n     }\n \n-    fn record_layout_for_printing_outlined(&self, layout: TyLayout<'tcx>) {\n+    fn record_layout_for_printing_outlined(&self, layout: TyAndLayout<'tcx>) {\n         // Ignore layouts that are done with non-empty environments or\n         // non-monomorphic layouts, as the user only wants to see the stuff\n         // resulting from the final codegen session.\n@@ -1624,7 +1628,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let adt_kind = adt_def.adt_kind();\n         let adt_packed = adt_def.repr.pack.is_some();\n \n-        let build_variant_info = |n: Option<Ident>, flds: &[ast::Name], layout: TyLayout<'tcx>| {\n+        let build_variant_info = |n: Option<Ident>,\n+                                  flds: &[ast::Name],\n+                                  layout: TyAndLayout<'tcx>| {\n             let mut min_size = Size::ZERO;\n             let field_info: Vec<_> = flds\n                 .iter()\n@@ -1891,19 +1897,19 @@ impl<'tcx, T: HasTyCtxt<'tcx>> HasTyCtxt<'tcx> for LayoutCx<'tcx, T> {\n     }\n }\n \n-pub type TyLayout<'tcx> = ::rustc_target::abi::TyLayout<'tcx, Ty<'tcx>>;\n+pub type TyAndLayout<'tcx> = ::rustc_target::abi::TyAndLayout<'tcx, Ty<'tcx>>;\n \n impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx>> {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+    type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         let param_env = self.param_env.with_reveal_all();\n         let ty = self.tcx.normalize_erasing_regions(param_env, ty);\n         let layout = self.tcx.layout_raw(param_env.and(ty))?;\n-        let layout = TyLayout { ty, layout };\n+        let layout = TyAndLayout { ty, layout };\n \n         // N.B., this recording is normally disabled; when enabled, it\n         // can however trigger recursive invocations of `layout_of`.\n@@ -1919,15 +1925,15 @@ impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx>> {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+    type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         let param_env = self.param_env.with_reveal_all();\n         let ty = self.tcx.normalize_erasing_regions(param_env, ty);\n         let layout = self.tcx.layout_raw(param_env.and(ty))?;\n-        let layout = TyLayout { ty, layout };\n+        let layout = TyAndLayout { ty, layout };\n \n         // N.B., this recording is normally disabled; when enabled, it\n         // can however trigger recursive invocations of `layout_of`.\n@@ -1950,7 +1956,7 @@ impl TyCtxt<'tcx> {\n     pub fn layout_of(\n         self,\n         param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n+    ) -> Result<TyAndLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = LayoutCx { tcx: self, param_env: param_env_and_ty.param_env };\n         cx.layout_of(param_env_and_ty.value)\n     }\n@@ -1963,19 +1969,23 @@ impl ty::query::TyCtxtAt<'tcx> {\n     pub fn layout_of(\n         self,\n         param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n+    ) -> Result<TyAndLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = LayoutCx { tcx: self.at(self.span), param_env: param_env_and_ty.param_env };\n         cx.layout_of(param_env_and_ty.value)\n     }\n }\n \n-impl<'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n+impl<'tcx, C> TyAndLayoutMethods<'tcx, C> for Ty<'tcx>\n where\n-    C: LayoutOf<Ty = Ty<'tcx>, TyLayout: MaybeResult<TyLayout<'tcx>>>\n+    C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout: MaybeResult<TyAndLayout<'tcx>>>\n         + HasTyCtxt<'tcx>\n         + HasParamEnv<'tcx>,\n {\n-    fn for_variant(this: TyLayout<'tcx>, cx: &C, variant_index: VariantIdx) -> TyLayout<'tcx> {\n+    fn for_variant(\n+        this: TyAndLayout<'tcx>,\n+        cx: &C,\n+        variant_index: VariantIdx,\n+    ) -> TyAndLayout<'tcx> {\n         let layout = match this.variants {\n             Variants::Single { index }\n                 // If all variants but one are uninhabited, the variant layout is the enum layout.\n@@ -2013,14 +2023,14 @@ where\n \n         assert_eq!(layout.variants, Variants::Single { index: variant_index });\n \n-        TyLayout { ty: this.ty, layout }\n+        TyAndLayout { ty: this.ty, layout }\n     }\n \n-    fn field(this: TyLayout<'tcx>, cx: &C, i: usize) -> C::TyLayout {\n+    fn field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> C::TyAndLayout {\n         let tcx = cx.tcx();\n-        let discr_layout = |discr: &Scalar| -> C::TyLayout {\n+        let discr_layout = |discr: &Scalar| -> C::TyAndLayout {\n             let layout = Layout::scalar(cx, discr.clone());\n-            MaybeResult::from(Ok(TyLayout {\n+            MaybeResult::from(Ok(TyAndLayout {\n                 layout: tcx.intern_layout(layout),\n                 ty: discr.value.to_ty(tcx),\n             }))\n@@ -2037,7 +2047,7 @@ where\n             | ty::FnDef(..)\n             | ty::GeneratorWitness(..)\n             | ty::Foreign(..)\n-            | ty::Dynamic(..) => bug!(\"TyLayout::field_type({:?}): not applicable\", this),\n+            | ty::Dynamic(..) => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n \n             // Potentially-fat pointers.\n             ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n@@ -2080,7 +2090,7 @@ where\n                         ])\n                         */\n                     }\n-                    _ => bug!(\"TyLayout::field_type({:?}): not applicable\", this),\n+                    _ => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n                 }\n             }\n \n@@ -2132,11 +2142,11 @@ where\n             | ty::Opaque(..)\n             | ty::Param(_)\n             | ty::Infer(_)\n-            | ty::Error => bug!(\"TyLayout::field_type: unexpected type `{}`\", this.ty),\n+            | ty::Error => bug!(\"TyAndLayout::field_type: unexpected type `{}`\", this.ty),\n         })\n     }\n \n-    fn pointee_info_at(this: TyLayout<'tcx>, cx: &C, offset: Size) -> Option<PointeeInfo> {\n+    fn pointee_info_at(this: TyAndLayout<'tcx>, cx: &C, offset: Size) -> Option<PointeeInfo> {\n         match this.ty.kind {\n             ty::RawPtr(mt) if offset.bytes() == 0 => {\n                 cx.layout_of(mt.ty).to_result().ok().map(|layout| PointeeInfo {\n@@ -2337,7 +2347,7 @@ impl<'tcx> ty::Instance<'tcx> {\n \n pub trait FnAbiExt<'tcx, C>\n where\n-    C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+    C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n         + HasDataLayout\n         + HasTargetSpec\n         + HasTyCtxt<'tcx>\n@@ -2368,7 +2378,7 @@ where\n \n impl<'tcx, C> FnAbiExt<'tcx, C> for call::FnAbi<'tcx, Ty<'tcx>>\n where\n-    C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+    C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n         + HasDataLayout\n         + HasTargetSpec\n         + HasTyCtxt<'tcx>\n@@ -2518,7 +2528,7 @@ where\n         // Handle safe Rust thin and fat pointers.\n         let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n                                       scalar: &Scalar,\n-                                      layout: TyLayout<'tcx>,\n+                                      layout: TyAndLayout<'tcx>,\n                                       offset: Size,\n                                       is_return: bool| {\n             // Booleans are always an i1 that needs to be zero-extended."}, {"sha": "c743a08954927e162fb04b8bf0a53253184baa0b", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -7,7 +7,7 @@ use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n use libc::{c_char, c_uint};\n use log::debug;\n-use rustc::ty::layout::{self, Align, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, Size, TyAndLayout};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_codegen_ssa::base::to_immediate;\n use rustc_codegen_ssa::common::{IntPredicate, RealPredicate, TypeKind};\n@@ -86,9 +86,9 @@ impl HasTargetSpec for Builder<'_, '_, 'tcx> {\n \n impl ty::layout::LayoutOf for Builder<'_, '_, 'tcx> {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = TyLayout<'tcx>;\n+    type TyAndLayout = TyAndLayout<'tcx>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.cx.layout_of(ty)\n     }\n }"}, {"sha": "c28958e0b4b4f8a086d10ba67083c7781ba8782c", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -13,7 +13,7 @@ use rustc_codegen_ssa::traits::*;\n \n use crate::consts::const_alloc_to_llvm;\n use rustc::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n-use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size, TyLayout};\n+use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size, TyAndLayout};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n \n use libc::{c_char, c_uint};\n@@ -289,7 +289,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n     fn from_const_alloc(\n         &self,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n         alloc: &Allocation,\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {"}, {"sha": "3462153f42c7c2b527e248a10e2feb7d6add5fd4", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -9,7 +9,7 @@ use crate::value::Value;\n use rustc::bug;\n use rustc::mir::mono::CodegenUnit;\n use rustc::ty::layout::{\n-    HasParamEnv, LayoutError, LayoutOf, PointeeInfo, Size, TyLayout, VariantIdx,\n+    HasParamEnv, LayoutError, LayoutOf, PointeeInfo, Size, TyAndLayout, VariantIdx,\n };\n use rustc::ty::{self, Instance, Ty, TyCtxt};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n@@ -837,13 +837,13 @@ impl ty::layout::HasTyCtxt<'tcx> for CodegenCx<'ll, 'tcx> {\n \n impl LayoutOf for CodegenCx<'ll, 'tcx> {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = TyLayout<'tcx>;\n+    type TyAndLayout = TyAndLayout<'tcx>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.spanned_layout_of(ty, DUMMY_SP)\n     }\n \n-    fn spanned_layout_of(&self, ty: Ty<'tcx>, span: Span) -> Self::TyLayout {\n+    fn spanned_layout_of(&self, ty: Ty<'tcx>, span: Span) -> Self::TyAndLayout {\n         self.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap_or_else(|e| {\n             if let LayoutError::SizeOverflow(_) = e {\n                 self.sess().span_fatal(span, &e.to_string())"}, {"sha": "6d4309c9660ea2dc069b9e7f39c3e648e3a66582", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -25,7 +25,7 @@ use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc::mir::interpret::truncate;\n use rustc::mir::{self, Field, GeneratorLayout};\n use rustc::ty::layout::{\n-    self, Align, Integer, IntegerExt, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n+    self, Align, Integer, IntegerExt, LayoutOf, PrimitiveExt, Size, TyAndLayout, VariantIdx,\n };\n use rustc::ty::subst::{GenericArgKind, SubstsRef};\n use rustc::ty::Instance;\n@@ -1203,7 +1203,7 @@ fn prepare_tuple_metadata(\n //=-----------------------------------------------------------------------------\n \n struct UnionMemberDescriptionFactory<'tcx> {\n-    layout: TyLayout<'tcx>,\n+    layout: TyAndLayout<'tcx>,\n     variant: &'tcx ty::VariantDef,\n     span: Span,\n }\n@@ -1325,7 +1325,7 @@ fn generator_layout_and_saved_local_names(\n /// offset of zero bytes).\n struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     enum_type: Ty<'tcx>,\n-    layout: TyLayout<'tcx>,\n+    layout: TyAndLayout<'tcx>,\n     discriminant_type_metadata: Option<&'ll DIType>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n@@ -1494,7 +1494,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     fn compute_field_path<'a, 'tcx>(\n                         cx: &CodegenCx<'a, 'tcx>,\n                         name: &mut String,\n-                        layout: TyLayout<'tcx>,\n+                        layout: TyAndLayout<'tcx>,\n                         offset: Size,\n                         size: Size,\n                     ) {\n@@ -1695,7 +1695,7 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n /// `RecursiveTypeDescription`.\n fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    layout: layout::TyLayout<'tcx>,\n+    layout: layout::TyAndLayout<'tcx>,\n     variant: VariantInfo<'_, 'tcx>,\n     discriminant_info: EnumDiscriminantInfo<'ll>,\n     containing_scope: &'ll DIScope,"}, {"sha": "85e0f284e26c0fbe52d3db55bac28d9c9d797760", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -10,7 +10,7 @@ use rustc_codegen_ssa::traits::*;\n use crate::abi::{FnAbiLlvmExt, LlvmType};\n use crate::common;\n use crate::type_of::LayoutLlvmExt;\n-use rustc::ty::layout::{self, Align, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, Size, TyAndLayout};\n use rustc::ty::Ty;\n use rustc_ast::ast;\n use rustc_codegen_ssa::common::TypeKind;\n@@ -250,24 +250,24 @@ impl Type {\n }\n \n impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn backend_type(&self, layout: TyLayout<'tcx>) -> &'ll Type {\n+    fn backend_type(&self, layout: TyAndLayout<'tcx>) -> &'ll Type {\n         layout.llvm_type(self)\n     }\n-    fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> &'ll Type {\n+    fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> &'ll Type {\n         layout.immediate_llvm_type(self)\n     }\n-    fn is_backend_immediate(&self, layout: TyLayout<'tcx>) -> bool {\n+    fn is_backend_immediate(&self, layout: TyAndLayout<'tcx>) -> bool {\n         layout.is_llvm_immediate()\n     }\n-    fn is_backend_scalar_pair(&self, layout: TyLayout<'tcx>) -> bool {\n+    fn is_backend_scalar_pair(&self, layout: TyAndLayout<'tcx>) -> bool {\n         layout.is_llvm_scalar_pair()\n     }\n-    fn backend_field_index(&self, layout: TyLayout<'tcx>, index: usize) -> u64 {\n+    fn backend_field_index(&self, layout: TyAndLayout<'tcx>, index: usize) -> u64 {\n         layout.llvm_field_index(index)\n     }\n     fn scalar_pair_element_backend_type(\n         &self,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n         index: usize,\n         immediate: bool,\n     ) -> &'ll Type {"}, {"sha": "9d909e83d175adefd8c08067f759c17ee75aba39", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -3,18 +3,18 @@ use crate::common::*;\n use crate::type_::Type;\n use log::debug;\n use rustc::bug;\n-use rustc::ty::layout::{self, Align, FnAbiExt, LayoutOf, PointeeInfo, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, FnAbiExt, LayoutOf, PointeeInfo, Size, TyAndLayout};\n use rustc::ty::print::obsolete::DefPathBasedNames;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc_codegen_ssa::traits::*;\n-use rustc_target::abi::TyLayoutMethods;\n+use rustc_target::abi::TyAndLayoutMethods;\n \n use std::fmt::Write;\n \n fn uncached_llvm_type<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n-    layout: TyLayout<'tcx>,\n-    defer: &mut Option<(&'a Type, TyLayout<'tcx>)>,\n+    layout: TyAndLayout<'tcx>,\n+    defer: &mut Option<(&'a Type, TyAndLayout<'tcx>)>,\n ) -> &'a Type {\n     match layout.abi {\n         layout::Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n@@ -110,7 +110,7 @@ fn uncached_llvm_type<'a, 'tcx>(\n \n fn struct_llfields<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n-    layout: TyLayout<'tcx>,\n+    layout: TyAndLayout<'tcx>,\n ) -> (Vec<&'a Type>, bool) {\n     debug!(\"struct_llfields: {:#?}\", layout);\n     let field_count = layout.fields.count();\n@@ -202,7 +202,7 @@ pub trait LayoutLlvmExt<'tcx> {\n     fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size) -> Option<PointeeInfo>;\n }\n \n-impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n+impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n     fn is_llvm_immediate(&self) -> bool {\n         match self.abi {\n             layout::Abi::Scalar(_) | layout::Abi::Vector { .. } => true,\n@@ -344,7 +344,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         let (a, b) = match self.abi {\n             layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n-            _ => bug!(\"TyLayout::scalar_pair_element_llty({:?}): not applicable\", self),\n+            _ => bug!(\"TyAndLayout::scalar_pair_element_llty({:?}): not applicable\", self),\n         };\n         let scalar = [a, b][index];\n \n@@ -366,13 +366,13 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     fn llvm_field_index(&self, index: usize) -> u64 {\n         match self.abi {\n             layout::Abi::Scalar(_) | layout::Abi::ScalarPair(..) => {\n-                bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self)\n+                bug!(\"TyAndLayout::llvm_field_index({:?}): not applicable\", self)\n             }\n             _ => {}\n         }\n         match self.fields {\n             layout::FieldPlacement::Union(_) => {\n-                bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self)\n+                bug!(\"TyAndLayout::llvm_field_index({:?}): not applicable\", self)\n             }\n \n             layout::FieldPlacement::Array { .. } => index as u64,"}, {"sha": "3f5a5e4e5312a42c51fea89163d71ade1e909370", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -31,7 +31,7 @@ use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::middle::lang_items;\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, MonoItem};\n-use rustc::ty::layout::{self, Align, HasTyCtxt, LayoutOf, TyLayout, VariantIdx};\n+use rustc::ty::layout::{self, Align, HasTyCtxt, LayoutOf, TyAndLayout, VariantIdx};\n use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n use rustc::ty::query::Providers;\n use rustc::ty::{self, Instance, Ty, TyCtxt};\n@@ -341,7 +341,7 @@ pub fn from_immediate<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n pub fn to_immediate<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     val: Bx::Value,\n-    layout: layout::TyLayout<'_>,\n+    layout: layout::TyAndLayout<'_>,\n ) -> Bx::Value {\n     if let layout::Abi::Scalar(ref scalar) = layout.abi {\n         return to_immediate_scalar(bx, val, scalar);\n@@ -366,7 +366,7 @@ pub fn memcpy_ty<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     dst_align: Align,\n     src: Bx::Value,\n     src_align: Align,\n-    layout: TyLayout<'tcx>,\n+    layout: TyAndLayout<'tcx>,\n     flags: MemFlags,\n ) {\n     let size = layout.size.bytes();"}, {"sha": "b94a87a8e43e23d206d61af528401b2e63a5f206", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,7 +1,7 @@\n use crate::base;\n use crate::traits::*;\n use rustc::mir;\n-use rustc::ty::layout::{FnAbiExt, HasTyCtxt, TyLayout};\n+use rustc::ty::layout::{FnAbiExt, HasTyCtxt, TyAndLayout};\n use rustc::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_target::abi::call::{FnAbi, PassMode};\n \n@@ -114,7 +114,7 @@ enum LocalRef<'tcx, V> {\n impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n     fn new_operand<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n     ) -> LocalRef<'tcx, V> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which"}, {"sha": "3e6bdb3b80b819613d3cdb617bf7457fd6c6f57b", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -8,7 +8,7 @@ use crate::MemFlags;\n \n use rustc::mir;\n use rustc::mir::interpret::{ConstValue, ErrorHandled, Pointer, Scalar};\n-use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, Size, TyAndLayout};\n use rustc::ty::Ty;\n \n use std::fmt;\n@@ -43,7 +43,7 @@ pub struct OperandRef<'tcx, V> {\n     pub val: OperandValue<V>,\n \n     // The layout of value, based on its Rust type.\n-    pub layout: TyLayout<'tcx>,\n+    pub layout: TyAndLayout<'tcx>,\n }\n \n impl<V: CodegenObject> fmt::Debug for OperandRef<'tcx, V> {\n@@ -55,7 +55,7 @@ impl<V: CodegenObject> fmt::Debug for OperandRef<'tcx, V> {\n impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n     pub fn new_zst<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n     ) -> OperandRef<'tcx, V> {\n         assert!(layout.is_zst());\n         OperandRef {\n@@ -159,7 +159,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n     pub fn from_immediate_or_packed_pair<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         llval: V,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n     ) -> Self {\n         let val = if let layout::Abi::ScalarPair(ref a, ref b) = layout.abi {\n             debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\", llval, layout);"}, {"sha": "5607250fe4b412617502987ce5f31c43914aa268", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -8,7 +8,7 @@ use crate::MemFlags;\n \n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n-use rustc::ty::layout::{self, Align, HasTyCtxt, LayoutOf, TyLayout, VariantIdx};\n+use rustc::ty::layout::{self, Align, HasTyCtxt, LayoutOf, TyAndLayout, VariantIdx};\n use rustc::ty::{self, Ty};\n \n #[derive(Copy, Clone, Debug)]\n@@ -20,19 +20,23 @@ pub struct PlaceRef<'tcx, V> {\n     pub llextra: Option<V>,\n \n     /// The monomorphized type of this place, including variant information.\n-    pub layout: TyLayout<'tcx>,\n+    pub layout: TyAndLayout<'tcx>,\n \n     /// The alignment we know for this place.\n     pub align: Align,\n }\n \n impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n-    pub fn new_sized(llval: V, layout: TyLayout<'tcx>) -> PlaceRef<'tcx, V> {\n+    pub fn new_sized(llval: V, layout: TyAndLayout<'tcx>) -> PlaceRef<'tcx, V> {\n         assert!(!layout.is_unsized());\n         PlaceRef { llval, llextra: None, layout, align: layout.align.abi }\n     }\n \n-    pub fn new_sized_aligned(llval: V, layout: TyLayout<'tcx>, align: Align) -> PlaceRef<'tcx, V> {\n+    pub fn new_sized_aligned(\n+        llval: V,\n+        layout: TyAndLayout<'tcx>,\n+        align: Align,\n+    ) -> PlaceRef<'tcx, V> {\n         assert!(!layout.is_unsized());\n         PlaceRef { llval, llextra: None, layout, align }\n     }\n@@ -41,7 +45,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n     pub fn alloca<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n     ) -> Self {\n         assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n         let tmp = bx.alloca(bx.cx().backend_type(layout), layout.align.abi);\n@@ -53,7 +57,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n     pub fn alloca_unsized_indirect<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n     ) -> Self {\n         assert!(layout.is_unsized(), \"tried to allocate indirect place for sized values\");\n         let ptr_ty = bx.cx().tcx().mk_mut_ptr(layout.ty);"}, {"sha": "755f988cc07174168ffd6e979f3e876905739914", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -4,7 +4,7 @@ use crate::ModuleCodegen;\n \n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n-use rustc::ty::layout::{HasTyCtxt, LayoutOf, TyLayout};\n+use rustc::ty::layout::{HasTyCtxt, LayoutOf, TyAndLayout};\n use rustc::ty::query::Providers;\n use rustc::ty::{Ty, TyCtxt};\n use rustc::util::common::ErrorReported;\n@@ -35,12 +35,12 @@ pub trait BackendTypes {\n }\n \n pub trait Backend<'tcx>:\n-    Sized + BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+    Sized + BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n {\n }\n \n impl<'tcx, T> Backend<'tcx> for T where\n-    Self: BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+    Self: BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n {\n }\n "}, {"sha": "7fbcb8874de784c370f7e829b01493c64a40cd4a", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -34,7 +34,7 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     ) -> Self::Value;\n     fn from_const_alloc(\n         &self,\n-        layout: layout::TyLayout<'tcx>,\n+        layout: layout::TyAndLayout<'tcx>,\n         alloc: &Allocation,\n         offset: layout::Size,\n     ) -> PlaceRef<'tcx, Self::Value>;"}, {"sha": "39274921ed2d9bc2a56520aeb48fdfe53c8ee907", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -3,7 +3,7 @@ use super::Backend;\n use super::HasCodegen;\n use crate::common::TypeKind;\n use crate::mir::place::PlaceRef;\n-use rustc::ty::layout::{self, TyLayout};\n+use rustc::ty::layout::{self, TyAndLayout};\n use rustc::ty::{self, Ty};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::call::{ArgAbi, CastTarget, FnAbi, Reg};\n@@ -94,17 +94,17 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n impl<T> DerivedTypeMethods<'tcx> for T where Self: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {}\n \n pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n-    fn backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n+    fn backend_type(&self, layout: TyAndLayout<'tcx>) -> Self::Type;\n     fn cast_backend_type(&self, ty: &CastTarget) -> Self::Type;\n     fn fn_ptr_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn reg_backend_type(&self, ty: &Reg) -> Self::Type;\n-    fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n-    fn is_backend_immediate(&self, layout: TyLayout<'tcx>) -> bool;\n-    fn is_backend_scalar_pair(&self, layout: TyLayout<'tcx>) -> bool;\n-    fn backend_field_index(&self, layout: TyLayout<'tcx>, index: usize) -> u64;\n+    fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> Self::Type;\n+    fn is_backend_immediate(&self, layout: TyAndLayout<'tcx>) -> bool;\n+    fn is_backend_scalar_pair(&self, layout: TyAndLayout<'tcx>) -> bool;\n+    fn backend_field_index(&self, layout: TyAndLayout<'tcx>, index: usize) -> u64;\n     fn scalar_pair_element_backend_type(\n         &self,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n         index: usize,\n         immediate: bool,\n     ) -> Self::Type;"}, {"sha": "f519c41c71a8cbdff55199c7ea35cff7b68262d9", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -21,7 +21,7 @@ use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n use rustc::lint::LintDiagnosticBuilder;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n-use rustc::ty::layout::{LayoutError, LayoutOf, TyLayout};\n+use rustc::ty::layout::{LayoutError, LayoutOf, TyAndLayout};\n use rustc::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n use rustc_ast::ast;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n@@ -811,9 +811,9 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n \n impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+    type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n     }\n }"}, {"sha": "9bf8a4f0ec15bd0c7fc176e79a56ace602f4da18", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,7 +1,7 @@\n use std::convert::TryFrom;\n \n use rustc::ty::adjustment::PointerCast;\n-use rustc::ty::layout::{self, Size, TyLayout};\n+use rustc::ty::layout::{self, Size, TyAndLayout};\n use rustc::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc_ast::ast::FloatTy;\n use rustc_span::symbol::sym;\n@@ -102,7 +102,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn cast_immediate(\n         &self,\n         src: ImmTy<'tcx, M::PointerTag>,\n-        dest_layout: TyLayout<'tcx>,\n+        dest_layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n         use rustc::ty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, dest_layout.ty);\n@@ -183,8 +183,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn cast_from_int_like(\n         &self,\n         v: u128, // raw bits\n-        src_layout: TyLayout<'tcx>,\n-        dest_layout: TyLayout<'tcx>,\n+        src_layout: TyAndLayout<'tcx>,\n+        dest_layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n         // Let's make sure v is sign-extended *if* it has a signed type.\n         let signed = src_layout.abi.is_signed();"}, {"sha": "57431b18ef2935f77ffb187548a59e6734ce85fa", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -7,7 +7,7 @@ use rustc::mir;\n use rustc::mir::interpret::{\n     sign_extend, truncate, AllocId, FrameInfo, GlobalId, InterpResult, Pointer, Scalar,\n };\n-use rustc::ty::layout::{self, Align, HasDataLayout, LayoutOf, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, HasDataLayout, LayoutOf, Size, TyAndLayout};\n use rustc::ty::query::TyCtxtAt;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -114,7 +114,7 @@ pub struct LocalState<'tcx, Tag = (), Id = AllocId> {\n     pub value: LocalValue<Tag, Id>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n     #[stable_hasher(ignore)]\n-    pub layout: Cell<Option<TyLayout<'tcx>>>,\n+    pub layout: Cell<Option<TyAndLayout<'tcx>>>,\n }\n \n /// Current value of a local variable\n@@ -202,10 +202,10 @@ where\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = InterpResult<'tcx, TyLayout<'tcx>>;\n+    type TyAndLayout = InterpResult<'tcx, TyAndLayout<'tcx>>;\n \n     #[inline]\n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.tcx\n             .layout_of(self.param_env.and(ty))\n             .map_err(|layout| err_inval!(Layout(layout)).into())\n@@ -284,13 +284,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     #[inline(always)]\n-    pub fn sign_extend(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n+    pub fn sign_extend(&self, value: u128, ty: TyAndLayout<'_>) -> u128 {\n         assert!(ty.abi.is_signed());\n         sign_extend(value, ty.size)\n     }\n \n     #[inline(always)]\n-    pub fn truncate(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n+    pub fn truncate(&self, value: u128, ty: TyAndLayout<'_>) -> u128 {\n         truncate(value, ty.size)\n     }\n \n@@ -373,8 +373,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local,\n-        layout: Option<TyLayout<'tcx>>,\n-    ) -> InterpResult<'tcx, TyLayout<'tcx>> {\n+        layout: Option<TyAndLayout<'tcx>>,\n+    ) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n         // `const_prop` runs into this with an invalid (empty) frame, so we\n         // have to support that case (mostly by skipping all caching).\n         match frame.locals.get(local).and_then(|state| state.layout.get()) {\n@@ -401,7 +401,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub(super) fn size_and_align_of(\n         &self,\n         metadata: MemPlaceMeta<M::PointerTag>,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n         if !layout.is_unsized() {\n             return Ok(Some((layout.size, layout.align.abi)));"}, {"sha": "358fd9739c641bb2647dca484e012cd3bb08e9bd", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -9,7 +9,7 @@ use rustc::mir::interpret::{\n     sign_extend, truncate, AllocId, ConstValue, GlobalId, InterpResult, Pointer, Scalar,\n };\n use rustc::ty::layout::{\n-    self, HasDataLayout, IntegerExt, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n+    self, HasDataLayout, IntegerExt, LayoutOf, PrimitiveExt, Size, TyAndLayout, VariantIdx,\n };\n use rustc::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n use rustc::ty::Ty;\n@@ -88,7 +88,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag = ()> {\n     pub(crate) imm: Immediate<Tag>,\n-    pub layout: TyLayout<'tcx>,\n+    pub layout: TyAndLayout<'tcx>,\n }\n \n impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n@@ -152,7 +152,7 @@ pub enum Operand<Tag = (), Id = AllocId> {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct OpTy<'tcx, Tag = ()> {\n     op: Operand<Tag>, // Keep this private; it helps enforce invariants.\n-    pub layout: TyLayout<'tcx>,\n+    pub layout: TyAndLayout<'tcx>,\n }\n \n impl<'tcx, Tag> ::std::ops::Deref for OpTy<'tcx, Tag> {\n@@ -179,26 +179,26 @@ impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n \n impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n     #[inline]\n-    pub fn from_scalar(val: Scalar<Tag>, layout: TyLayout<'tcx>) -> Self {\n+    pub fn from_scalar(val: Scalar<Tag>, layout: TyAndLayout<'tcx>) -> Self {\n         ImmTy { imm: val.into(), layout }\n     }\n \n     #[inline]\n-    pub fn try_from_uint(i: impl Into<u128>, layout: TyLayout<'tcx>) -> Option<Self> {\n+    pub fn try_from_uint(i: impl Into<u128>, layout: TyAndLayout<'tcx>) -> Option<Self> {\n         Some(Self::from_scalar(Scalar::try_from_uint(i, layout.size)?, layout))\n     }\n     #[inline]\n-    pub fn from_uint(i: impl Into<u128>, layout: TyLayout<'tcx>) -> Self {\n+    pub fn from_uint(i: impl Into<u128>, layout: TyAndLayout<'tcx>) -> Self {\n         Self::from_scalar(Scalar::from_uint(i, layout.size), layout)\n     }\n \n     #[inline]\n-    pub fn try_from_int(i: impl Into<i128>, layout: TyLayout<'tcx>) -> Option<Self> {\n+    pub fn try_from_int(i: impl Into<i128>, layout: TyAndLayout<'tcx>) -> Option<Self> {\n         Some(Self::from_scalar(Scalar::try_from_int(i, layout.size)?, layout))\n     }\n \n     #[inline]\n-    pub fn from_int(i: impl Into<i128>, layout: TyLayout<'tcx>) -> Self {\n+    pub fn from_int(i: impl Into<i128>, layout: TyAndLayout<'tcx>) -> Self {\n         Self::from_scalar(Scalar::from_int(i, layout.size), layout)\n     }\n }\n@@ -207,9 +207,9 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n // or compute the layout.\n #[inline(always)]\n pub(super) fn from_known_layout<'tcx>(\n-    layout: Option<TyLayout<'tcx>>,\n-    compute: impl FnOnce() -> InterpResult<'tcx, TyLayout<'tcx>>,\n-) -> InterpResult<'tcx, TyLayout<'tcx>> {\n+    layout: Option<TyAndLayout<'tcx>>,\n+    compute: impl FnOnce() -> InterpResult<'tcx, TyAndLayout<'tcx>>,\n+) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n     match layout {\n         None => compute(),\n         Some(layout) => {\n@@ -434,7 +434,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         frame: &super::Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local,\n-        layout: Option<TyLayout<'tcx>>,\n+        layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         assert_ne!(local, mir::RETURN_PLACE);\n         let layout = self.layout_of_local(frame, local, layout)?;\n@@ -465,7 +465,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn eval_place_to_op(\n         &self,\n         place: &mir::Place<'tcx>,\n-        layout: Option<TyLayout<'tcx>>,\n+        layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base_op = match place.local {\n             mir::RETURN_PLACE => throw_ub!(ReadFromReturnPlace),\n@@ -493,7 +493,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn eval_operand(\n         &self,\n         mir_op: &mir::Operand<'tcx>,\n-        layout: Option<TyLayout<'tcx>>,\n+        layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Operand::*;\n         let op = match *mir_op {\n@@ -525,7 +525,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     crate fn eval_const_to_op(\n         &self,\n         val: &ty::Const<'tcx>,\n-        layout: Option<TyLayout<'tcx>>,\n+        layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let tag_scalar = |scalar| match scalar {\n             Scalar::Ptr(ptr) => Scalar::Ptr(self.tag_global_base_pointer(ptr)),"}, {"sha": "10fa66c49d7bf8e5464bc8db8380c26347bb89b9", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -4,7 +4,7 @@ use rustc::mir;\n use rustc::mir::interpret::{InterpResult, Scalar};\n use rustc::ty::{\n     self,\n-    layout::{LayoutOf, TyLayout},\n+    layout::{LayoutOf, TyAndLayout},\n     Ty,\n };\n use rustc_apfloat::Float;\n@@ -123,9 +123,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         bin_op: mir::BinOp,\n         // passing in raw bits\n         l: u128,\n-        left_layout: TyLayout<'tcx>,\n+        left_layout: TyAndLayout<'tcx>,\n         r: u128,\n-        right_layout: TyLayout<'tcx>,\n+        right_layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         use rustc::mir::BinOp::*;\n "}, {"sha": "7ae8634cb2ab08b4fccb1b0e035d9112c26108e5", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -8,7 +8,7 @@ use std::hash::Hash;\n use rustc::mir;\n use rustc::mir::interpret::truncate;\n use rustc::ty::layout::{\n-    self, Align, HasDataLayout, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n+    self, Align, HasDataLayout, LayoutOf, PrimitiveExt, Size, TyAndLayout, VariantIdx,\n };\n use rustc::ty::{self, Ty};\n use rustc_macros::HashStable;\n@@ -86,7 +86,7 @@ pub enum Place<Tag = (), Id = AllocId> {\n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx, Tag = ()> {\n     place: Place<Tag>, // Keep this private; it helps enforce invariants.\n-    pub layout: TyLayout<'tcx>,\n+    pub layout: TyAndLayout<'tcx>,\n }\n \n impl<'tcx, Tag> ::std::ops::Deref for PlaceTy<'tcx, Tag> {\n@@ -101,7 +101,7 @@ impl<'tcx, Tag> ::std::ops::Deref for PlaceTy<'tcx, Tag> {\n #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n pub struct MPlaceTy<'tcx, Tag = ()> {\n     mplace: MemPlace<Tag>,\n-    pub layout: TyLayout<'tcx>,\n+    pub layout: TyAndLayout<'tcx>,\n }\n \n impl<'tcx, Tag> ::std::ops::Deref for MPlaceTy<'tcx, Tag> {\n@@ -178,7 +178,7 @@ impl<Tag> MemPlace<Tag> {\n impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     /// Produces a MemPlace that works for ZST but nothing else\n     #[inline]\n-    pub fn dangling(layout: TyLayout<'tcx>, cx: &impl HasDataLayout) -> Self {\n+    pub fn dangling(layout: TyAndLayout<'tcx>, cx: &impl HasDataLayout) -> Self {\n         let align = layout.align.abi;\n         let ptr = Scalar::from_machine_usize(align.bytes(), cx);\n         // `Poison` this to make sure that the pointer value `ptr` is never observable by the program.\n@@ -196,14 +196,14 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         self,\n         offset: Size,\n         meta: MemPlaceMeta<Tag>,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n         Ok(MPlaceTy { mplace: self.mplace.offset(offset, meta, cx)?, layout })\n     }\n \n     #[inline]\n-    fn from_aligned_ptr(ptr: Pointer<Tag>, layout: TyLayout<'tcx>) -> Self {\n+    fn from_aligned_ptr(ptr: Pointer<Tag>, layout: TyAndLayout<'tcx>) -> Self {\n         MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align.abi), layout }\n     }\n \n@@ -1030,7 +1030,7 @@ where\n \n     pub fn allocate(\n         &mut self,\n-        layout: TyLayout<'tcx>,\n+        layout: TyAndLayout<'tcx>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate(layout.size, layout.align.abi, kind);\n@@ -1077,7 +1077,7 @@ where\n                 ..\n             } => {\n                 // No need to validate that the discriminant here because the\n-                // `TyLayout::for_variant()` call earlier already checks the variant is valid.\n+                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n \n                 let discr_val =\n                     dest.layout.ty.discriminant_for_variant(*self.tcx, variant_index).unwrap().val;\n@@ -1099,7 +1099,7 @@ where\n                 ..\n             } => {\n                 // No need to validate that the discriminant here because the\n-                // `TyLayout::for_variant()` call earlier already checks the variant is valid.\n+                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n \n                 if variant_index != dataful_variant {\n                     let variants_start = niche_variants.start().as_u32();"}, {"sha": "edae6ef066d3e74dbe65e3c29a407011bb33fe30", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,7 +1,7 @@\n use std::borrow::Cow;\n use std::convert::TryFrom;\n \n-use rustc::ty::layout::{self, LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, LayoutOf, TyAndLayout};\n use rustc::ty::Instance;\n use rustc::{mir, ty};\n use rustc_span::source_map::Span;\n@@ -134,8 +134,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn check_argument_compat(\n         rust_abi: bool,\n-        caller: TyLayout<'tcx>,\n-        callee: TyLayout<'tcx>,\n+        caller: TyAndLayout<'tcx>,\n+        callee: TyAndLayout<'tcx>,\n     ) -> bool {\n         if caller.ty == callee.ty {\n             // No question"}, {"sha": "7b580fa12ebaaa5c12204dd371adacbfa7a11716", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -9,7 +9,7 @@ use std::fmt::Write;\n use std::ops::RangeInclusive;\n \n use rustc::ty;\n-use rustc::ty::layout::{self, LayoutOf, TyLayout, VariantIdx};\n+use rustc::ty::layout::{self, LayoutOf, TyAndLayout, VariantIdx};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_span::symbol::{sym, Symbol};\n@@ -177,7 +177,7 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n }\n \n impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M> {\n-    fn aggregate_field_path_elem(&mut self, layout: TyLayout<'tcx>, field: usize) -> PathElem {\n+    fn aggregate_field_path_elem(&mut self, layout: TyAndLayout<'tcx>, field: usize) -> PathElem {\n         // First, check if we are projecting to a variant.\n         match layout.variants {\n             layout::Variants::Multiple { discr_index, .. } => {\n@@ -266,7 +266,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n     fn check_wide_ptr_meta(\n         &mut self,\n         meta: MemPlaceMeta<M::PointerTag>,\n-        pointee: TyLayout<'tcx>,\n+        pointee: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind {"}, {"sha": "54dec393e71b6ed95efb619e85f78e8e79bed26d", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -3,7 +3,7 @@\n \n use rustc::mir::interpret::InterpResult;\n use rustc::ty;\n-use rustc::ty::layout::{self, TyLayout, VariantIdx};\n+use rustc::ty::layout::{self, TyAndLayout, VariantIdx};\n \n use super::{InterpCx, MPlaceTy, Machine, OpTy};\n \n@@ -12,7 +12,7 @@ use super::{InterpCx, MPlaceTy, Machine, OpTy};\n // that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     /// Gets this value's layout.\n-    fn layout(&self) -> TyLayout<'tcx>;\n+    fn layout(&self) -> TyAndLayout<'tcx>;\n \n     /// Makes this into an `OpTy`.\n     fn to_op(self, ecx: &InterpCx<'mir, 'tcx, M>) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n@@ -36,7 +36,7 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n // Places in general are not due to `place_field` having to do `force_allocation`.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n-    fn layout(&self) -> TyLayout<'tcx> {\n+    fn layout(&self) -> TyAndLayout<'tcx> {\n         self.layout\n     }\n \n@@ -74,7 +74,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n-    fn layout(&self) -> TyLayout<'tcx> {\n+    fn layout(&self) -> TyAndLayout<'tcx> {\n         self.layout\n     }\n "}, {"sha": "927deebb175781f91597ee2e9ba499449beb7781", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -15,7 +15,7 @@ use rustc::mir::{\n     UnOp, RETURN_PLACE,\n };\n use rustc::ty::layout::{\n-    HasDataLayout, HasTyCtxt, LayoutError, LayoutOf, Size, TargetDataLayout, TyLayout,\n+    HasDataLayout, HasTyCtxt, LayoutError, LayoutOf, Size, TargetDataLayout, TyAndLayout,\n };\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{self, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeFoldable};\n@@ -316,9 +316,9 @@ struct ConstPropagator<'mir, 'tcx> {\n \n impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+    type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n     }\n }\n@@ -573,7 +573,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn const_prop(\n         &mut self,\n         rvalue: &Rvalue<'tcx>,\n-        place_layout: TyLayout<'tcx>,\n+        place_layout: TyAndLayout<'tcx>,\n         source_info: SourceInfo,\n         place: &Place<'tcx>,\n     ) -> Option<()> {"}, {"sha": "d33f9b6a28627fa7701445c0187c74861a98a29f", "filename": "src/librustc_mir/transform/uninhabited_enum_branching.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -5,7 +5,7 @@ use rustc::mir::{\n     BasicBlock, BasicBlockData, Body, BodyAndCache, Local, Operand, Rvalue, StatementKind,\n     TerminatorKind,\n };\n-use rustc::ty::layout::{Abi, TyLayout, Variants};\n+use rustc::ty::layout::{Abi, TyAndLayout, Variants};\n use rustc::ty::{Ty, TyCtxt};\n \n pub struct UninhabitedEnumBranching;\n@@ -49,7 +49,7 @@ fn get_switched_on_type<'tcx>(\n }\n \n fn variant_discriminants<'tcx>(\n-    layout: &TyLayout<'tcx>,\n+    layout: &TyAndLayout<'tcx>,\n     ty: Ty<'tcx>,\n     tcx: TyCtxt<'tcx>,\n ) -> Vec<u128> {"}, {"sha": "a3bbfd8b4c0ae3e60790d5098ce0743dc3c1db3b", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::layout::HasParamEnv;\n use rustc::ty::layout::HasTyCtxt;\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::layout::TargetDataLayout;\n-use rustc::ty::layout::TyLayout;\n+use rustc::ty::layout::TyAndLayout;\n use rustc::ty::ParamEnv;\n use rustc::ty::Ty;\n use rustc::ty::TyCtxt;\n@@ -118,9 +118,9 @@ struct UnwrapLayoutCx<'tcx> {\n \n impl LayoutOf for UnwrapLayoutCx<'tcx> {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = TyLayout<'tcx>;\n+    type TyAndLayout = TyAndLayout<'tcx>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.tcx.layout_of(self.param_env.and(ty)).unwrap()\n     }\n }"}, {"sha": "1ab7722edab98a167d69285d2dc5c0ac965190d9", "filename": "src/librustc_target/abi/call/aarch64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,10 +1,10 @@\n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n@@ -26,8 +26,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n@@ -58,8 +58,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n@@ -90,8 +90,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "0b4f279fece403908221547dfa88f4cdffa5b89f", "filename": "src/librustc_target/abi/call/amdgpu.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,26 +1,26 @@\n use crate::abi::call::{ArgAbi, FnAbi};\n-use crate::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n \n fn classify_ret<'a, Ty, C>(_cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     ret.extend_integer_width_to(32);\n }\n \n fn classify_arg<'a, Ty, C>(_cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.extend_integer_width_to(32);\n }\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "26fed3bae4e484cab2ea0cc17b9f7de55e0477f3", "filename": "src/librustc_target/abi/call/arm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,11 +1,11 @@\n use crate::abi::call::{ArgAbi, Conv, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n use crate::spec::HasTargetSpec;\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n@@ -27,8 +27,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>, vfp: bool)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n@@ -60,8 +60,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, vfp: bool)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n@@ -82,8 +82,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n {\n     // If this is a target with a hard-float ABI, and the function is not explicitly\n     // `extern \"aapcs\"`, then we must use the VFP registers for homogeneous aggregates."}, {"sha": "733a7328bd3a005648d99cf26006cfaa23c335c4", "filename": "src/librustc_target/abi/call/mips.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,9 +1,9 @@\n use crate::abi::call::{ArgAbi, FnAbi, Reg, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, Size, TyAndLayoutMethods};\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n where\n-    Ty: TyLayoutMethods<'a, C>,\n+    Ty: TyAndLayoutMethods<'a, C>,\n     C: LayoutOf<Ty = Ty> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n@@ -16,7 +16,7 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n where\n-    Ty: TyLayoutMethods<'a, C>,\n+    Ty: TyAndLayoutMethods<'a, C>,\n     C: LayoutOf<Ty = Ty> + HasDataLayout,\n {\n     let dl = cx.data_layout();\n@@ -37,7 +37,7 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C>,\n+    Ty: TyAndLayoutMethods<'a, C>,\n     C: LayoutOf<Ty = Ty> + HasDataLayout,\n {\n     let mut offset = Size::ZERO;"}, {"sha": "285cb5ff6433fe7bacf464352f4297cac27d16e7", "filename": "src/librustc_target/abi/call/mips64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::call::{ArgAbi, ArgAttribute, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n-use crate::abi::{self, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n+use crate::abi::{self, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods};\n \n fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n     // Always sign extend u32 values on 64-bit mips\n@@ -19,8 +19,8 @@ fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n \n fn float_reg<'a, Ty, C>(cx: &C, ret: &ArgAbi<'a, Ty>, i: usize) -> Option<Reg>\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     match ret.layout.field(cx, i).abi {\n         abi::Abi::Scalar(ref scalar) => match scalar.value {\n@@ -34,8 +34,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         extend_integer_width_mips(ret, 64);\n@@ -74,8 +74,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         extend_integer_width_mips(arg, 64);\n@@ -143,8 +143,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "ffc85c153c9cd1d75dfe8471daf0cb9b6c4785fa", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::{self, Abi, Align, FieldPlacement, Size};\n-use crate::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n use crate::spec::{self, HasTargetSpec};\n \n mod aarch64;\n@@ -264,7 +264,7 @@ impl HomogeneousAggregate {\n     }\n }\n \n-impl<'a, Ty> TyLayout<'a, Ty> {\n+impl<'a, Ty> TyAndLayout<'a, Ty> {\n     fn is_aggregate(&self) -> bool {\n         match self.abi {\n             Abi::Uninhabited | Abi::Scalar(_) | Abi::Vector { .. } => false,\n@@ -284,8 +284,8 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n     /// specific targets.\n     pub fn homogeneous_aggregate<C>(&self, cx: &C) -> Result<HomogeneousAggregate, Heterogeneous>\n     where\n-        Ty: TyLayoutMethods<'a, C> + Copy,\n-        C: LayoutOf<Ty = Ty, TyLayout = Self>,\n+        Ty: TyAndLayoutMethods<'a, C> + Copy,\n+        C: LayoutOf<Ty = Ty, TyAndLayout = Self>,\n     {\n         match self.abi {\n             Abi::Uninhabited => Err(Heterogeneous),\n@@ -404,7 +404,7 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n /// or return a value from, a function, under some ABI.\n #[derive(Debug)]\n pub struct ArgAbi<'a, Ty> {\n-    pub layout: TyLayout<'a, Ty>,\n+    pub layout: TyAndLayout<'a, Ty>,\n \n     /// Dummy argument, which is emitted before the real argument.\n     pub pad: Option<Reg>,\n@@ -413,7 +413,7 @@ pub struct ArgAbi<'a, Ty> {\n }\n \n impl<'a, Ty> ArgAbi<'a, Ty> {\n-    pub fn new(layout: TyLayout<'a, Ty>) -> Self {\n+    pub fn new(layout: TyAndLayout<'a, Ty>) -> Self {\n         ArgAbi { layout, pad: None, mode: PassMode::Direct(ArgAttributes::new()) }\n     }\n \n@@ -551,8 +551,8 @@ pub struct FnAbi<'a, Ty> {\n impl<'a, Ty> FnAbi<'a, Ty> {\n     pub fn adjust_for_cabi<C>(&mut self, cx: &C, abi: spec::abi::Abi) -> Result<(), String>\n     where\n-        Ty: TyLayoutMethods<'a, C> + Copy,\n-        C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+        Ty: TyAndLayoutMethods<'a, C> + Copy,\n+        C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n     {\n         match &cx.target_spec().arch[..] {\n             \"x86\" => {"}, {"sha": "b740707320f6074074e89059215ba000e416c130", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -3,7 +3,7 @@\n // need to be fixed when PowerPC vector support is added.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{Endian, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use crate::abi::{Endian, HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n use crate::spec::HasTargetSpec;\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n@@ -19,8 +19,8 @@ fn is_homogeneous_aggregate<'a, Ty, C>(\n     abi: ABI,\n ) -> Option<Uniform>\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // ELFv1 only passes one-member aggregates transparently.\n@@ -43,8 +43,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>, abi: ABI)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n@@ -86,8 +86,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, abi: ABI)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n@@ -116,8 +116,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n {\n     let abi = if cx.target_spec().target_env == \"musl\" {\n         ELFv2"}, {"sha": "7cd3a0900941d7f1106abb62f6de5310ac4c289e", "filename": "src/librustc_target/abi/call/riscv.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -6,7 +6,7 @@\n \n use crate::abi::call::{ArgAbi, ArgAttribute, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n use crate::abi::{\n-    self, Abi, FieldPlacement, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods,\n+    self, Abi, FieldPlacement, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods,\n };\n use crate::spec::HasTargetSpec;\n \n@@ -36,15 +36,15 @@ fn is_riscv_aggregate<'a, Ty>(arg: &ArgAbi<'a, Ty>) -> bool {\n \n fn should_use_fp_conv_helper<'a, Ty, C>(\n     cx: &C,\n-    arg_layout: &TyLayout<'a, Ty>,\n+    arg_layout: &TyAndLayout<'a, Ty>,\n     xlen: u64,\n     flen: u64,\n     field1_kind: &mut RegPassKind,\n     field2_kind: &mut RegPassKind,\n ) -> Result<(), CannotUseFpConv>\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     match arg_layout.abi {\n         Abi::Scalar(ref scalar) => match scalar.value {\n@@ -122,13 +122,13 @@ where\n \n fn should_use_fp_conv<'a, Ty, C>(\n     cx: &C,\n-    arg: &TyLayout<'a, Ty>,\n+    arg: &TyAndLayout<'a, Ty>,\n     xlen: u64,\n     flen: u64,\n ) -> Option<FloatConv>\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     let mut field1_kind = RegPassKind::Unknown;\n     let mut field2_kind = RegPassKind::Unknown;\n@@ -146,8 +146,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, xlen: u64, flen: u64) -> bool\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     if let Some(conv) = should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n         match conv {\n@@ -209,8 +209,8 @@ fn classify_arg<'a, Ty, C>(\n     avail_gprs: &mut u64,\n     avail_fprs: &mut u64,\n ) where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     if !is_vararg {\n         match should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n@@ -322,8 +322,8 @@ fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n {\n     let flen = match &cx.target_spec().options.llvm_abiname[..] {\n         \"ilp32f\" | \"lp64f\" => 32,"}, {"sha": "005dcc62dfdc193cedeff6f5a633494e222234ec", "filename": "src/librustc_target/abi/call/s390x.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -2,11 +2,11 @@\n // for a pre-z13 machine or using -mno-vx.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg};\n-use crate::abi::{self, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use crate::abi::{self, HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n \n fn classify_ret<'a, Ty, C>(ret: &mut ArgAbi<'_, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C>,\n+    Ty: TyAndLayoutMethods<'a, C>,\n     C: LayoutOf<Ty = Ty> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() && ret.layout.size.bits() <= 64 {\n@@ -16,10 +16,10 @@ where\n     }\n }\n \n-fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyLayout<'a, Ty>) -> bool\n+fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyAndLayout<'a, Ty>) -> bool\n where\n-    Ty: TyLayoutMethods<'a, C>,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C>,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     match layout.abi {\n         abi::Abi::Scalar(ref scalar) => scalar.value.is_float(),\n@@ -36,8 +36,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() && arg.layout.size.bits() <= 64 {\n         arg.extend_integer_width_to(64);\n@@ -63,8 +63,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(&mut fn_abi.ret);"}, {"sha": "733a7328bd3a005648d99cf26006cfaa23c335c4", "filename": "src/librustc_target/abi/call/sparc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,9 +1,9 @@\n use crate::abi::call::{ArgAbi, FnAbi, Reg, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, Size, TyAndLayoutMethods};\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n where\n-    Ty: TyLayoutMethods<'a, C>,\n+    Ty: TyAndLayoutMethods<'a, C>,\n     C: LayoutOf<Ty = Ty> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n@@ -16,7 +16,7 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n where\n-    Ty: TyLayoutMethods<'a, C>,\n+    Ty: TyAndLayoutMethods<'a, C>,\n     C: LayoutOf<Ty = Ty> + HasDataLayout,\n {\n     let dl = cx.data_layout();\n@@ -37,7 +37,7 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C>,\n+    Ty: TyAndLayoutMethods<'a, C>,\n     C: LayoutOf<Ty = Ty> + HasDataLayout,\n {\n     let mut offset = Size::ZERO;"}, {"sha": "a647675e0735b8a0464034dec4cf4564461c7a39", "filename": "src/librustc_target/abi/call/sparc64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,12 +1,12 @@\n // FIXME: This needs an audit for correctness and completeness.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n@@ -26,8 +26,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n@@ -52,8 +52,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n@@ -76,8 +76,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "510f671a501e1760f2522ca3461bb2b2a8a7439a", "filename": "src/librustc_target/abi/call/wasm32.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,10 +1,10 @@\n use crate::abi::call::{ArgAbi, FnAbi, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n \n fn unwrap_trivial_aggregate<'a, Ty, C>(cx: &C, val: &mut ArgAbi<'a, Ty>) -> bool\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if val.layout.is_aggregate() {\n         if let Some(unit) = val.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()) {\n@@ -20,8 +20,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     ret.extend_integer_width_to(32);\n     if ret.layout.is_aggregate() {\n@@ -33,8 +33,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.extend_integer_width_to(32);\n     if arg.layout.is_aggregate() {\n@@ -46,8 +46,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "df3dd5d9208d37b47a15c1386a9c9218ede7f867", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::call::{ArgAttribute, FnAbi, PassMode, Reg, RegKind};\n-use crate::abi::{self, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use crate::abi::{self, HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n use crate::spec::HasTargetSpec;\n \n #[derive(PartialEq)]\n@@ -8,10 +8,10 @@ pub enum Flavor {\n     Fastcall,\n }\n \n-fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyLayout<'a, Ty>) -> bool\n+fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyAndLayout<'a, Ty>) -> bool\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     match layout.abi {\n         abi::Abi::Scalar(ref scalar) => scalar.value.is_float(),\n@@ -28,8 +28,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>, flavor: Flavor)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n {\n     if !fn_abi.ret.is_ignore() {\n         if fn_abi.ret.layout.is_aggregate() {"}, {"sha": "5f154dc1bc9f83ee78f4809cc3692363c21c5043", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -2,7 +2,7 @@\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n use crate::abi::call::{ArgAbi, CastTarget, FnAbi, Reg, RegKind};\n-use crate::abi::{self, Abi, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n+use crate::abi::{self, Abi, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods};\n \n /// Classification of \"eightbyte\" components.\n // N.B., the order of the variants is from general to specific,\n@@ -26,18 +26,18 @@ fn classify_arg<'a, Ty, C>(\n     arg: &ArgAbi<'a, Ty>,\n ) -> Result<[Option<Class>; MAX_EIGHTBYTES], Memory>\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     fn classify<'a, Ty, C>(\n         cx: &C,\n-        layout: TyLayout<'a, Ty>,\n+        layout: TyAndLayout<'a, Ty>,\n         cls: &mut [Option<Class>],\n         off: Size,\n     ) -> Result<(), Memory>\n     where\n-        Ty: TyLayoutMethods<'a, C> + Copy,\n-        C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+        Ty: TyAndLayoutMethods<'a, C> + Copy,\n+        C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n     {\n         if !off.is_aligned(layout.align.abi) {\n             if !layout.is_zst() {\n@@ -172,8 +172,8 @@ const MAX_SSE_REGS: usize = 8; // XMM0-7\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     let mut int_regs = MAX_INT_REGS;\n     let mut sse_regs = MAX_SSE_REGS;"}, {"sha": "3cc7292bbdfd547b408a092c843b55040f5051b3", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d009ce441f59f6a65111d94bb822a1c28872006a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=d009ce441f59f6a65111d94bb822a1c28872006a", "patch": "@@ -939,14 +939,13 @@ impl Layout {\n /// to that obtained from `layout_of(ty)`, as we need to produce\n /// layouts for which Rust types do not exist, such as enum variants\n /// or synthetic fields of enums (i.e., discriminants) and fat pointers.\n-// FIXME: rename to TyAndLayout.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct TyLayout<'a, Ty> {\n+pub struct TyAndLayout<'a, Ty> {\n     pub ty: Ty,\n     pub layout: &'a Layout,\n }\n \n-impl<'a, Ty> Deref for TyLayout<'a, Ty> {\n+impl<'a, Ty> Deref for TyAndLayout<'a, Ty> {\n     type Target = &'a Layout;\n     fn deref(&self) -> &&'a Layout {\n         &self.layout\n@@ -956,15 +955,15 @@ impl<'a, Ty> Deref for TyLayout<'a, Ty> {\n /// Trait for context types that can compute layouts of things.\n pub trait LayoutOf {\n     type Ty;\n-    type TyLayout;\n+    type TyAndLayout;\n \n-    fn layout_of(&self, ty: Self::Ty) -> Self::TyLayout;\n-    fn spanned_layout_of(&self, ty: Self::Ty, _span: Span) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Self::Ty) -> Self::TyAndLayout;\n+    fn spanned_layout_of(&self, ty: Self::Ty, _span: Span) -> Self::TyAndLayout {\n         self.layout_of(ty)\n     }\n }\n \n-/// The `TyLayout` above will always be a `MaybeResult<TyLayout<'_, Self>>`.\n+/// The `TyAndLayout` above will always be a `MaybeResult<TyAndLayout<'_, Self>>`.\n /// We can't add the bound due to the lifetime, but this trait is still useful when\n /// writing code that's generic over the `LayoutOf` impl.\n pub trait MaybeResult<T> {\n@@ -1018,45 +1017,45 @@ pub struct PointeeInfo {\n     pub safe: Option<PointerKind>,\n }\n \n-pub trait TyLayoutMethods<'a, C: LayoutOf<Ty = Self>>: Sized {\n+pub trait TyAndLayoutMethods<'a, C: LayoutOf<Ty = Self>>: Sized {\n     fn for_variant(\n-        this: TyLayout<'a, Self>,\n+        this: TyAndLayout<'a, Self>,\n         cx: &C,\n         variant_index: VariantIdx,\n-    ) -> TyLayout<'a, Self>;\n-    fn field(this: TyLayout<'a, Self>, cx: &C, i: usize) -> C::TyLayout;\n-    fn pointee_info_at(this: TyLayout<'a, Self>, cx: &C, offset: Size) -> Option<PointeeInfo>;\n+    ) -> TyAndLayout<'a, Self>;\n+    fn field(this: TyAndLayout<'a, Self>, cx: &C, i: usize) -> C::TyAndLayout;\n+    fn pointee_info_at(this: TyAndLayout<'a, Self>, cx: &C, offset: Size) -> Option<PointeeInfo>;\n }\n \n-impl<'a, Ty> TyLayout<'a, Ty> {\n+impl<'a, Ty> TyAndLayout<'a, Ty> {\n     pub fn for_variant<C>(self, cx: &C, variant_index: VariantIdx) -> Self\n     where\n-        Ty: TyLayoutMethods<'a, C>,\n+        Ty: TyAndLayoutMethods<'a, C>,\n         C: LayoutOf<Ty = Ty>,\n     {\n         Ty::for_variant(self, cx, variant_index)\n     }\n \n-    /// Callers might want to use `C: LayoutOf<Ty=Ty, TyLayout: MaybeResult<Self>>`\n+    /// Callers might want to use `C: LayoutOf<Ty=Ty, TyAndLayout: MaybeResult<Self>>`\n     /// to allow recursion (see `might_permit_zero_init` below for an example).\n-    pub fn field<C>(self, cx: &C, i: usize) -> C::TyLayout\n+    pub fn field<C>(self, cx: &C, i: usize) -> C::TyAndLayout\n     where\n-        Ty: TyLayoutMethods<'a, C>,\n+        Ty: TyAndLayoutMethods<'a, C>,\n         C: LayoutOf<Ty = Ty>,\n     {\n         Ty::field(self, cx, i)\n     }\n \n     pub fn pointee_info_at<C>(self, cx: &C, offset: Size) -> Option<PointeeInfo>\n     where\n-        Ty: TyLayoutMethods<'a, C>,\n+        Ty: TyAndLayoutMethods<'a, C>,\n         C: LayoutOf<Ty = Ty>,\n     {\n         Ty::pointee_info_at(self, cx, offset)\n     }\n }\n \n-impl<'a, Ty> TyLayout<'a, Ty> {\n+impl<'a, Ty> TyAndLayout<'a, Ty> {\n     /// Returns `true` if the layout corresponds to an unsized type.\n     pub fn is_unsized(&self) -> bool {\n         self.abi.is_unsized()\n@@ -1083,8 +1082,8 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n     pub fn might_permit_raw_init<C, E>(self, cx: &C, zero: bool) -> Result<bool, E>\n     where\n         Self: Copy,\n-        Ty: TyLayoutMethods<'a, C>,\n-        C: LayoutOf<Ty = Ty, TyLayout: MaybeResult<Self, Error = E>> + HasDataLayout,\n+        Ty: TyAndLayoutMethods<'a, C>,\n+        C: LayoutOf<Ty = Ty, TyAndLayout: MaybeResult<Self, Error = E>> + HasDataLayout,\n     {\n         let scalar_allows_raw_init = move |s: &Scalar| -> bool {\n             if zero {"}]}