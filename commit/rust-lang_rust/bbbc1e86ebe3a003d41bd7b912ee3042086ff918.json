{"sha": "bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYmMxZTg2ZWJlM2EwMDNkNDFiZDdiOTEyZWUzMDQyMDg2ZmY5MTg=", "commit": {"author": {"name": "rchaser53", "email": "tayoshizawa29@gmail.com", "date": "2019-03-18T12:41:31Z"}, "committer": {"name": "rchaser53", "email": "tayoshizawa29@gmail.com", "date": "2019-03-21T12:45:39Z"}, "message": "refrect topecongiro reviews\n\n    - &Vec<syntax::ast::PathSegment> => &[ast::PathSegment]\n    - remove unnecessary implements\n    - transfer skip logic to inside rewrite_macro\n    - fix test\n    - use util methods in libsyntax\n    - use meta_item_list directly\n    - avoid no_entry.rs for test using module system\n    - add logic to skip rustfmt::skip::macros only\n    - remove base_skip_macro_names\n    - remove Rc\n    - use clone to append skip_macro_names", "tree": {"sha": "7843faf558b99c18526cd4c54ebb8f49cf601e24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7843faf558b99c18526cd4c54ebb8f49cf601e24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "html_url": "https://github.com/rust-lang/rust/commit/bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/comments", "author": {"login": "rchaser53", "id": 9676954, "node_id": "MDQ6VXNlcjk2NzY5NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/9676954?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rchaser53", "html_url": "https://github.com/rchaser53", "followers_url": "https://api.github.com/users/rchaser53/followers", "following_url": "https://api.github.com/users/rchaser53/following{/other_user}", "gists_url": "https://api.github.com/users/rchaser53/gists{/gist_id}", "starred_url": "https://api.github.com/users/rchaser53/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rchaser53/subscriptions", "organizations_url": "https://api.github.com/users/rchaser53/orgs", "repos_url": "https://api.github.com/users/rchaser53/repos", "events_url": "https://api.github.com/users/rchaser53/events{/privacy}", "received_events_url": "https://api.github.com/users/rchaser53/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rchaser53", "id": 9676954, "node_id": "MDQ6VXNlcjk2NzY5NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/9676954?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rchaser53", "html_url": "https://github.com/rchaser53", "followers_url": "https://api.github.com/users/rchaser53/followers", "following_url": "https://api.github.com/users/rchaser53/following{/other_user}", "gists_url": "https://api.github.com/users/rchaser53/gists{/gist_id}", "starred_url": "https://api.github.com/users/rchaser53/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rchaser53/subscriptions", "organizations_url": "https://api.github.com/users/rchaser53/orgs", "repos_url": "https://api.github.com/users/rchaser53/repos", "events_url": "https://api.github.com/users/rchaser53/events{/privacy}", "received_events_url": "https://api.github.com/users/rchaser53/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "558a2c351266dc78e73963d2303221a60a0d5c85", "url": "https://api.github.com/repos/rust-lang/rust/commits/558a2c351266dc78e73963d2303221a60a0d5c85", "html_url": "https://github.com/rust-lang/rust/commit/558a2c351266dc78e73963d2303221a60a0d5c85"}], "stats": {"total": 526, "additions": 311, "deletions": 215}, "files": [{"sha": "068b8f7fed6bc556e56068cff9d399cd936f07ae", "filename": "src/expr.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -190,21 +190,13 @@ pub fn format_expr(\n             rewrite_chain(expr, context, shape)\n         }\n         ast::ExprKind::Mac(ref mac) => {\n-            let should_skip = context\n-                .skip_macro_names\n-                .borrow()\n-                .contains(&context.snippet(mac.node.path.span).to_owned());\n-            if should_skip {\n-                None\n-            } else {\n-                rewrite_macro(mac, None, context, shape, MacroPosition::Expression).or_else(|| {\n-                    wrap_str(\n-                        context.snippet(expr.span).to_owned(),\n-                        context.config.max_width(),\n-                        shape,\n-                    )\n-                })\n-            }\n+            rewrite_macro(mac, None, context, shape, MacroPosition::Expression).or_else(|| {\n+                wrap_str(\n+                    context.snippet(expr.span).to_owned(),\n+                    context.config.max_width(),\n+                    shape,\n+                )\n+            })\n         }\n         ast::ExprKind::Ret(None) => Some(\"return\".to_owned()),\n         ast::ExprKind::Ret(Some(ref expr)) => {\n@@ -1928,7 +1920,6 @@ pub fn rewrite_assign_rhs_with<S: Into<String>, R: Rewrite>(\n         offset: shape.offset + last_line_width + 1,\n         ..shape\n     });\n-    // dbg!(\n     let rhs = choose_rhs(\n         context,\n         ex,"}, {"sha": "545d2fe279f766f0069e7df4e42b04c59b61f4b0", "filename": "src/formatting.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -15,6 +15,7 @@ use syntax::source_map::{FilePathMapping, SourceMap, Span, DUMMY_SP};\n use crate::comment::{CharClasses, FullCodeCharKind};\n use crate::config::{Config, FileName, Verbosity};\n use crate::issues::BadIssueSeeker;\n+use crate::utils::{count_newlines, get_skip_macro_names};\n use crate::visitor::{FmtVisitor, SnippetProvider};\n use crate::{modules, source_file, ErrorKind, FormatReport, Input, Session};\n \n@@ -153,6 +154,10 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             &snippet_provider,\n             self.report.clone(),\n         );\n+        visitor\n+            .skip_macro_names\n+            .borrow_mut()\n+            .append(&mut get_skip_macro_names(&self.krate.attrs));\n \n         // Format inner attributes if available.\n         if !self.krate.attrs.is_empty() && is_root {\n@@ -168,10 +173,7 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             visitor.format_separate_mod(module, &*source_file);\n         };\n \n-        debug_assert_eq!(\n-            visitor.line_number,\n-            crate::utils::count_newlines(&visitor.buffer)\n-        );\n+        debug_assert_eq!(visitor.line_number, count_newlines(&visitor.buffer));\n \n         // For some reason, the source_map does not include terminating\n         // newlines so we must add one on for each file. This is sad."}, {"sha": "40a3b7edcd69ccd21e6e93fe7d19aa2decb8f1df", "filename": "src/macros.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -208,12 +208,21 @@ pub fn rewrite_macro(\n     shape: Shape,\n     position: MacroPosition,\n ) -> Option<String> {\n-    let guard = InsideMacroGuard::inside_macro_context(context);\n-    let result = rewrite_macro_inner(mac, extra_ident, context, shape, position, guard.is_nested);\n-    if result.is_none() {\n-        context.macro_rewrite_failure.replace(true);\n+    let should_skip = context\n+        .skip_macro_names\n+        .borrow()\n+        .contains(&context.snippet(mac.node.path.span).to_owned());\n+    if should_skip {\n+        None\n+    } else {\n+        let guard = InsideMacroGuard::inside_macro_context(context);\n+        let result =\n+            rewrite_macro_inner(mac, extra_ident, context, shape, position, guard.is_nested);\n+        if result.is_none() {\n+            context.macro_rewrite_failure.replace(true);\n+        }\n+        result\n     }\n-    result\n }\n \n fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {"}, {"sha": "c736c2535a616701e1719adf60fd0f2a10d1638c", "filename": "src/rewrite.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -1,7 +1,6 @@\n // A generic trait to abstract the rewriting of an element (of the AST).\n \n use std::cell::RefCell;\n-use std::rc::Rc;\n \n use syntax::parse::ParseSess;\n use syntax::ptr;\n@@ -40,7 +39,7 @@ pub struct RewriteContext<'a> {\n     // Used for `format_snippet`\n     pub(crate) macro_rewrite_failure: RefCell<bool>,\n     pub(crate) report: FormatReport,\n-    pub skip_macro_names: Rc<RefCell<Vec<String>>>,\n+    pub skip_macro_names: RefCell<Vec<String>>,\n }\n \n impl<'a> RewriteContext<'a> {"}, {"sha": "0628094fdeffe2ea41a4668fb3f783f469122aec", "filename": "src/test/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -22,6 +22,7 @@ const SKIP_FILE_WHITE_LIST: &[&str] = &[\n     // We want to make sure that the `skip_children` is correctly working,\n     // so we do not want to test this file directly.\n     \"configs/skip_children/foo/mod.rs\",\n+    \"issue-3434/no_entry.rs\",\n ];\n \n fn is_file_skip(path: &Path) -> bool {"}, {"sha": "743a86276129369270338da5e54e3d75bb58c22f", "filename": "src/utils.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -603,6 +603,26 @@ pub(crate) fn unicode_str_width(s: &str) -> usize {\n     s.width()\n }\n \n+pub fn get_skip_macro_names(attrs: &[ast::Attribute]) -> Vec<String> {\n+    let mut skip_macro_names = vec![];\n+    for attr in attrs {\n+        // syntax::ast::Path is implemented partialEq\n+        // but it is designed for segments.len() == 1\n+        if format!(\"{}\", attr.path) != \"rustfmt::skip::macros\" {\n+            continue;\n+        }\n+\n+        if let Some(list) = attr.meta_item_list() {\n+            for spanned in list {\n+                if let Some(name) = spanned.name() {\n+                    skip_macro_names.push(name.to_string());\n+                }\n+            }\n+        }\n+    }\n+    skip_macro_names\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "441f7b4e75fc7724641dd49541a8e5e4c7c4adb3", "filename": "src/visitor.rs", "status": "modified", "additions": 137, "deletions": 142, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -1,9 +1,7 @@\n use std::cell::RefCell;\n-use std::rc::Rc;\n \n-use syntax::parse::{token, ParseSess};\n+use syntax::parse::ParseSess;\n use syntax::source_map::{self, BytePos, Pos, SourceMap, Span};\n-use syntax::tokenstream::TokenTree;\n use syntax::{ast, visit};\n \n use crate::attr::*;\n@@ -22,8 +20,8 @@ use crate::shape::{Indent, Shape};\n use crate::source_map::{LineRangeUtils, SpanUtils};\n use crate::spanned::Spanned;\n use crate::utils::{\n-    self, contains_skip, count_newlines, inner_attributes, mk_sp, ptr_vec_to_ref_vec,\n-    rewrite_ident, stmt_expr, DEPR_SKIP_ANNOTATION,\n+    self, contains_skip, count_newlines, get_skip_macro_names, inner_attributes, mk_sp,\n+    ptr_vec_to_ref_vec, rewrite_ident, stmt_expr, DEPR_SKIP_ANNOTATION,\n };\n use crate::{ErrorKind, FormatReport, FormattingError};\n \n@@ -68,7 +66,7 @@ pub struct FmtVisitor<'a> {\n     pub skipped_range: Vec<(usize, usize)>,\n     pub macro_rewrite_failure: bool,\n     pub(crate) report: FormatReport,\n-    pub skip_macro_names: Rc<RefCell<Vec<String>>>,\n+    pub skip_macro_names: RefCell<Vec<String>>,\n }\n \n impl<'a> Drop for FmtVisitor<'a> {\n@@ -299,25 +297,32 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         // the AST lumps them all together.\n         let filtered_attrs;\n         let mut attrs = &item.attrs;\n-        match item.node {\n+        let temp_skip_macro_names = self.skip_macro_names.clone();\n+        self.skip_macro_names\n+            .borrow_mut()\n+            .append(&mut get_skip_macro_names(&attrs));\n+\n+        let should_visit_node_again = match item.node {\n             // For use items, skip rewriting attributes. Just check for a skip attribute.\n             ast::ItemKind::Use(..) => {\n                 if contains_skip(attrs) {\n                     self.push_skipped_with_span(attrs.as_slice(), item.span(), item.span());\n-                    return;\n+                    false\n+                } else {\n+                    true\n                 }\n             }\n             // Module is inline, in this case we treat it like any other item.\n             _ if !is_mod_decl(item) => {\n                 if self.visit_attrs(&item.attrs, ast::AttrStyle::Outer) {\n                     self.push_skipped_with_span(item.attrs.as_slice(), item.span(), item.span());\n-                    return;\n+                    false\n+                } else {\n+                    true\n                 }\n             }\n             // Module is not inline, but should be skipped.\n-            ast::ItemKind::Mod(..) if contains_skip(&item.attrs) => {\n-                return;\n-            }\n+            ast::ItemKind::Mod(..) if contains_skip(&item.attrs) => false,\n             // Module is not inline and should not be skipped. We want\n             // to process only the attributes in the current file.\n             ast::ItemKind::Mod(..) => {\n@@ -326,123 +331,127 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 // the above case.\n                 assert!(!self.visit_attrs(&filtered_attrs, ast::AttrStyle::Outer));\n                 attrs = &filtered_attrs;\n+                true\n             }\n             _ => {\n                 if self.visit_attrs(&item.attrs, ast::AttrStyle::Outer) {\n                     self.push_skipped_with_span(item.attrs.as_slice(), item.span(), item.span());\n-                    return;\n+                    false\n+                } else {\n+                    true\n                 }\n             }\n-        }\n-        self.get_skip_macros(&attrs);\n-\n-        match item.node {\n-            ast::ItemKind::Use(ref tree) => self.format_import(item, tree),\n-            ast::ItemKind::Impl(..) => {\n-                let snippet = self.snippet(item.span);\n-                let where_span_end = snippet\n-                    .find_uncommented(\"{\")\n-                    .map(|x| BytePos(x as u32) + source!(self, item.span).lo());\n-                let block_indent = self.block_indent;\n-                let rw =\n-                    self.with_context(|ctx| format_impl(&ctx, item, block_indent, where_span_end));\n-                self.push_rewrite(item.span, rw);\n-            }\n-            ast::ItemKind::Trait(..) => {\n-                let block_indent = self.block_indent;\n-                let rw = self.with_context(|ctx| format_trait(&ctx, item, block_indent));\n-                self.push_rewrite(item.span, rw);\n-            }\n-            ast::ItemKind::TraitAlias(ref generics, ref generic_bounds) => {\n-                let shape = Shape::indented(self.block_indent, self.config);\n-                let rw = format_trait_alias(\n-                    &self.get_context(),\n-                    item.ident,\n-                    &item.vis,\n-                    generics,\n-                    generic_bounds,\n-                    shape,\n-                );\n-                self.push_rewrite(item.span, rw);\n-            }\n-            ast::ItemKind::ExternCrate(_) => {\n-                let rw = rewrite_extern_crate(&self.get_context(), item);\n-                self.push_rewrite(item.span, rw);\n-            }\n-            ast::ItemKind::Struct(..) | ast::ItemKind::Union(..) => {\n-                self.visit_struct(&StructParts::from_item(item));\n-            }\n-            ast::ItemKind::Enum(ref def, ref generics) => {\n-                self.format_missing_with_indent(source!(self, item.span).lo());\n-                self.visit_enum(item.ident, &item.vis, def, generics, item.span);\n-                self.last_pos = source!(self, item.span).hi();\n-            }\n-            ast::ItemKind::Mod(ref module) => {\n-                let is_inline = !is_mod_decl(item);\n-                self.format_missing_with_indent(source!(self, item.span).lo());\n-                self.format_mod(module, &item.vis, item.span, item.ident, attrs, is_inline);\n-            }\n-            ast::ItemKind::Mac(ref mac) => {\n-                self.visit_mac(mac, Some(item.ident), MacroPosition::Item);\n-            }\n-            ast::ItemKind::ForeignMod(ref foreign_mod) => {\n-                self.format_missing_with_indent(source!(self, item.span).lo());\n-                self.format_foreign_mod(foreign_mod, item.span);\n-            }\n-            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n-                self.visit_static(&StaticParts::from_item(item));\n-            }\n-            ast::ItemKind::Fn(ref decl, ref fn_header, ref generics, ref body) => {\n-                let inner_attrs = inner_attributes(&item.attrs);\n-                self.visit_fn(\n-                    visit::FnKind::ItemFn(item.ident, fn_header, &item.vis, body),\n-                    generics,\n-                    decl,\n-                    item.span,\n-                    ast::Defaultness::Final,\n-                    Some(&inner_attrs),\n-                )\n-            }\n-            ast::ItemKind::Ty(ref ty, ref generics) => {\n-                let rewrite = rewrite_type_alias(\n-                    &self.get_context(),\n-                    self.block_indent,\n-                    item.ident,\n-                    ty,\n-                    generics,\n-                    &item.vis,\n-                );\n-                self.push_rewrite(item.span, rewrite);\n-            }\n-            ast::ItemKind::Existential(ref generic_bounds, ref generics) => {\n-                let rewrite = rewrite_existential_type(\n-                    &self.get_context(),\n-                    self.block_indent,\n-                    item.ident,\n-                    generic_bounds,\n-                    generics,\n-                    &item.vis,\n-                );\n-                self.push_rewrite(item.span, rewrite);\n-            }\n-            ast::ItemKind::GlobalAsm(..) => {\n-                let snippet = Some(self.snippet(item.span).to_owned());\n-                self.push_rewrite(item.span, snippet);\n-            }\n-            ast::ItemKind::MacroDef(ref def) => {\n-                let rewrite = rewrite_macro_def(\n-                    &self.get_context(),\n-                    self.shape(),\n-                    self.block_indent,\n-                    def,\n-                    item.ident,\n-                    &item.vis,\n-                    item.span,\n-                );\n-                self.push_rewrite(item.span, rewrite);\n-            }\n         };\n-        self.skip_macro_names.borrow_mut().clear();\n+\n+        if should_visit_node_again {\n+            match item.node {\n+                ast::ItemKind::Use(ref tree) => self.format_import(item, tree),\n+                ast::ItemKind::Impl(..) => {\n+                    let snippet = self.snippet(item.span);\n+                    let where_span_end = snippet\n+                        .find_uncommented(\"{\")\n+                        .map(|x| BytePos(x as u32) + source!(self, item.span).lo());\n+                    let block_indent = self.block_indent;\n+                    let rw = self\n+                        .with_context(|ctx| format_impl(&ctx, item, block_indent, where_span_end));\n+                    self.push_rewrite(item.span, rw);\n+                }\n+                ast::ItemKind::Trait(..) => {\n+                    let block_indent = self.block_indent;\n+                    let rw = self.with_context(|ctx| format_trait(&ctx, item, block_indent));\n+                    self.push_rewrite(item.span, rw);\n+                }\n+                ast::ItemKind::TraitAlias(ref generics, ref generic_bounds) => {\n+                    let shape = Shape::indented(self.block_indent, self.config);\n+                    let rw = format_trait_alias(\n+                        &self.get_context(),\n+                        item.ident,\n+                        &item.vis,\n+                        generics,\n+                        generic_bounds,\n+                        shape,\n+                    );\n+                    self.push_rewrite(item.span, rw);\n+                }\n+                ast::ItemKind::ExternCrate(_) => {\n+                    let rw = rewrite_extern_crate(&self.get_context(), item);\n+                    self.push_rewrite(item.span, rw);\n+                }\n+                ast::ItemKind::Struct(..) | ast::ItemKind::Union(..) => {\n+                    self.visit_struct(&StructParts::from_item(item));\n+                }\n+                ast::ItemKind::Enum(ref def, ref generics) => {\n+                    self.format_missing_with_indent(source!(self, item.span).lo());\n+                    self.visit_enum(item.ident, &item.vis, def, generics, item.span);\n+                    self.last_pos = source!(self, item.span).hi();\n+                }\n+                ast::ItemKind::Mod(ref module) => {\n+                    let is_inline = !is_mod_decl(item);\n+                    self.format_missing_with_indent(source!(self, item.span).lo());\n+                    self.format_mod(module, &item.vis, item.span, item.ident, attrs, is_inline);\n+                }\n+                ast::ItemKind::Mac(ref mac) => {\n+                    self.visit_mac(mac, Some(item.ident), MacroPosition::Item);\n+                }\n+                ast::ItemKind::ForeignMod(ref foreign_mod) => {\n+                    self.format_missing_with_indent(source!(self, item.span).lo());\n+                    self.format_foreign_mod(foreign_mod, item.span);\n+                }\n+                ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n+                    self.visit_static(&StaticParts::from_item(item));\n+                }\n+                ast::ItemKind::Fn(ref decl, ref fn_header, ref generics, ref body) => {\n+                    let inner_attrs = inner_attributes(&item.attrs);\n+                    self.visit_fn(\n+                        visit::FnKind::ItemFn(item.ident, fn_header, &item.vis, body),\n+                        generics,\n+                        decl,\n+                        item.span,\n+                        ast::Defaultness::Final,\n+                        Some(&inner_attrs),\n+                    )\n+                }\n+                ast::ItemKind::Ty(ref ty, ref generics) => {\n+                    let rewrite = rewrite_type_alias(\n+                        &self.get_context(),\n+                        self.block_indent,\n+                        item.ident,\n+                        ty,\n+                        generics,\n+                        &item.vis,\n+                    );\n+                    self.push_rewrite(item.span, rewrite);\n+                }\n+                ast::ItemKind::Existential(ref generic_bounds, ref generics) => {\n+                    let rewrite = rewrite_existential_type(\n+                        &self.get_context(),\n+                        self.block_indent,\n+                        item.ident,\n+                        generic_bounds,\n+                        generics,\n+                        &item.vis,\n+                    );\n+                    self.push_rewrite(item.span, rewrite);\n+                }\n+                ast::ItemKind::GlobalAsm(..) => {\n+                    let snippet = Some(self.snippet(item.span).to_owned());\n+                    self.push_rewrite(item.span, snippet);\n+                }\n+                ast::ItemKind::MacroDef(ref def) => {\n+                    let rewrite = rewrite_macro_def(\n+                        &self.get_context(),\n+                        self.shape(),\n+                        self.block_indent,\n+                        def,\n+                        item.ident,\n+                        &item.vis,\n+                        item.span,\n+                    );\n+                    self.push_rewrite(item.span, rewrite);\n+                }\n+            };\n+        }\n+        self.skip_macro_names = temp_skip_macro_names;\n     }\n \n     pub fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n@@ -597,6 +606,10 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             ctx.snippet_provider,\n             ctx.report.clone(),\n         );\n+        visitor\n+            .skip_macro_names\n+            .borrow_mut()\n+            .append(&mut ctx.skip_macro_names.borrow().clone());\n         visitor.set_parent_context(ctx);\n         visitor\n     }\n@@ -621,7 +634,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             skipped_range: vec![],\n             macro_rewrite_failure: false,\n             report,\n-            skip_macro_names: Rc::new(RefCell::new(vec![])),\n+            skip_macro_names: RefCell::new(vec![]),\n         }\n     }\n \n@@ -674,7 +687,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         false\n     }\n \n-    fn is_rustfmt_macro_error(&self, segments: &Vec<syntax::ast::PathSegment>) -> bool {\n+    fn is_rustfmt_macro_error(&self, segments: &[ast::PathSegment]) -> bool {\n         if segments[0].ident.to_string() != \"rustfmt\" {\n             return false;\n         }\n@@ -837,22 +850,4 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             skip_macro_names: self.skip_macro_names.clone(),\n         }\n     }\n-\n-    pub fn get_skip_macros(&mut self, attrs: &[ast::Attribute]) {\n-        for attr in attrs {\n-            for token in attr.tokens.trees() {\n-                if let TokenTree::Delimited(_, _, stream) = token {\n-                    for inner_token in stream.trees() {\n-                        if let TokenTree::Token(span, token) = inner_token {\n-                            if let token::Token::Ident(_, _) = token {\n-                                // FIXME ident.span.lo() and ident.span.hi() are 0\n-                                let macro_name = self.get_context().snippet(span).to_owned();\n-                                self.skip_macro_names.borrow_mut().push(macro_name);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n }"}, {"sha": "5d753ef0c4d3b609ccd12a68933f7363296d94a5", "filename": "tests/source/issue-3434.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/558a2c351266dc78e73963d2303221a60a0d5c85/tests%2Fsource%2Fissue-3434.rs", "raw_url": "https://github.com/rust-lang/rust/raw/558a2c351266dc78e73963d2303221a60a0d5c85/tests%2Fsource%2Fissue-3434.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3434.rs?ref=558a2c351266dc78e73963d2303221a60a0d5c85", "patch": "@@ -1,22 +0,0 @@\n-#[rustfmt::skip::macros(html, skip_macro)]\n-fn main() {\n-    let macro_result1 = html! { <div>\n-Hello</div>\n-    }.to_string();\n-\n-    let macro_result2 = not_skip_macro! { <div>\n-Hello</div>\n-    }.to_string();\n-\n-    skip_macro! {\n-this is a skip_macro here\n-};\n-\n-  foo();\n-}\n-\n-fn foo() {\n-    let macro_result1 = html! { <div>\n-Hello</div>\n-    }.to_string();\n-}"}, {"sha": "d3f4056bd8ae7928f2dde1c16fed190715acdc11", "filename": "tests/source/issue-3434/lib.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Fsource%2Fissue-3434%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Fsource%2Fissue-3434%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3434%2Flib.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -0,0 +1,36 @@\n+#![rustfmt::skip::macros(skip_macro_mod)]\n+\n+mod no_entry;\n+\n+#[rustfmt::skip::macros(html, skip_macro)]\n+fn main() {\n+    let macro_result1 = html! { <div>\n+this should be skipped</div>\n+    }\n+    .to_string();\n+\n+    let macro_result2 = not_skip_macro! { <div>\n+this should be mangled</div>\n+        }\n+    .to_string();\n+\n+    skip_macro! {\n+this should be skipped\n+};\n+\n+    foo();\n+}\n+\n+fn foo() {\n+    let macro_result1 = html! { <div>\n+this should be mangled</div>\n+            }\n+    .to_string();\n+}\n+\n+fn bar() {\n+    let macro_result1 = skip_macro_mod! { <div>\n+this should be skipped</div>\n+        }\n+    .to_string();\n+}"}, {"sha": "0838829fed34893edf0574c7aeaf70a483e3d0ca", "filename": "tests/source/issue-3434/no_entry.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Fsource%2Fissue-3434%2Fno_entry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Fsource%2Fissue-3434%2Fno_entry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3434%2Fno_entry.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -0,0 +1,18 @@\n+#[rustfmt::skip::macros(another_macro)]\n+fn foo() {\n+    another_macro!(\n+This should be skipped.\n+        );\n+}\n+\n+fn bar() {\n+    skip_macro_mod!(\n+This should be skipped.\n+        );\n+}\n+\n+fn baz() {\n+    let macro_result1 = no_skip_macro! { <div>\n+this should be mangled</div>\n+    }.to_string();\n+}"}, {"sha": "1d7d73c523d6228285795d51d58a676e63070ce8", "filename": "tests/source/issue-3434/not_skip_macro.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Fsource%2Fissue-3434%2Fnot_skip_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Fsource%2Fissue-3434%2Fnot_skip_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3434%2Fnot_skip_macro.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -0,0 +1,8 @@\n+#[this::is::not::skip::macros(ouch)]\n+\n+fn main() {\n+    let macro_result1 = ouch! { <div>\n+this should be mangled</div>\n+    }\n+    .to_string();\n+}"}, {"sha": "44171bb83fb33364fc465e19711004e75c20551b", "filename": "tests/target/issue-3434.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/558a2c351266dc78e73963d2303221a60a0d5c85/tests%2Ftarget%2Fissue-3434.rs", "raw_url": "https://github.com/rust-lang/rust/raw/558a2c351266dc78e73963d2303221a60a0d5c85/tests%2Ftarget%2Fissue-3434.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3434.rs?ref=558a2c351266dc78e73963d2303221a60a0d5c85", "patch": "@@ -1,24 +0,0 @@\n-#[rustfmt::skip::macros(html, skip_macro)]\n-fn main() {\n-    let macro_result1 = html! { <div>\n-Hello</div>\n-    }.to_string();\n-\n-    let macro_result2 = not_skip_macro! { <div>\n-    Hello</div>\n-        }\n-    .to_string();\n-\n-    skip_macro! {\n-this is a skip_macro here\n-};\n-\n-    foo();\n-}\n-\n-fn foo() {\n-    let macro_result1 = html! { <div>\n-    Hello</div>\n-        }\n-    .to_string();\n-}"}, {"sha": "95bc75642f06307751d8c808213845c30bdb291e", "filename": "tests/target/issue-3434/lib.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Ftarget%2Fissue-3434%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Ftarget%2Fissue-3434%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3434%2Flib.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -0,0 +1,36 @@\n+#![rustfmt::skip::macros(skip_macro_mod)]\n+\n+mod no_entry;\n+\n+#[rustfmt::skip::macros(html, skip_macro)]\n+fn main() {\n+    let macro_result1 = html! { <div>\n+this should be skipped</div>\n+    }\n+    .to_string();\n+\n+    let macro_result2 = not_skip_macro! { <div>\n+    this should be mangled</div>\n+            }\n+    .to_string();\n+\n+    skip_macro! {\n+this should be skipped\n+};\n+\n+    foo();\n+}\n+\n+fn foo() {\n+    let macro_result1 = html! { <div>\n+    this should be mangled</div>\n+                }\n+    .to_string();\n+}\n+\n+fn bar() {\n+    let macro_result1 = skip_macro_mod! { <div>\n+this should be skipped</div>\n+        }\n+    .to_string();\n+}"}, {"sha": "a2ecf2c2f99bdfa56f78f764a1d0b208e7e3f5b4", "filename": "tests/target/issue-3434/no_entry.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Ftarget%2Fissue-3434%2Fno_entry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Ftarget%2Fissue-3434%2Fno_entry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3434%2Fno_entry.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -0,0 +1,19 @@\n+#[rustfmt::skip::macros(another_macro)]\n+fn foo() {\n+    another_macro!(\n+This should be skipped.\n+        );\n+}\n+\n+fn bar() {\n+    skip_macro_mod!(\n+This should be skipped.\n+        );\n+}\n+\n+fn baz() {\n+    let macro_result1 = no_skip_macro! { <div>\n+    this should be mangled</div>\n+        }\n+    .to_string();\n+}"}, {"sha": "c90d09744b281e3a9917e2f38a14084e9b263827", "filename": "tests/target/issue-3434/not_skip_macro.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Ftarget%2Fissue-3434%2Fnot_skip_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbc1e86ebe3a003d41bd7b912ee3042086ff918/tests%2Ftarget%2Fissue-3434%2Fnot_skip_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3434%2Fnot_skip_macro.rs?ref=bbbc1e86ebe3a003d41bd7b912ee3042086ff918", "patch": "@@ -0,0 +1,8 @@\n+#[this::is::not::skip::macros(ouch)]\n+\n+fn main() {\n+    let macro_result1 = ouch! { <div>\n+    this should be mangled</div>\n+        }\n+    .to_string();\n+}"}]}