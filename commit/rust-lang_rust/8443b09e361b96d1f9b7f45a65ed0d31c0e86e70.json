{"sha": "8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NDNiMDllMzYxYjk2ZDFmOWI3ZjQ1YTY1ZWQwZDMxYzBlODZlNzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-20T05:52:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-20T05:52:18Z"}, "message": "auto merge of #19995 : eddyb/rust/split-resolve, r=nikomatsakis\n\nr? @nikomatsakis", "tree": {"sha": "384f1c2987b838be0a788d10d0958e898044cdbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/384f1c2987b838be0a788d10d0958e898044cdbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "html_url": "https://github.com/rust-lang/rust/commit/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c2df5cc3cfc0c9e80adf9fa6504d55056741c5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2df5cc3cfc0c9e80adf9fa6504d55056741c5a", "html_url": "https://github.com/rust-lang/rust/commit/1c2df5cc3cfc0c9e80adf9fa6504d55056741c5a"}, {"sha": "948cc666de56d6d1deba55b870e385ffef06a9f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/948cc666de56d6d1deba55b870e385ffef06a9f3", "html_url": "https://github.com/rust-lang/rust/commit/948cc666de56d6d1deba55b870e385ffef06a9f3"}], "stats": {"total": 1040, "additions": 565, "deletions": 475}, "files": [{"sha": "e20cb06e3a8ca43a21aadb134bbfa52e6c2648a8", "filename": "mk/crates.mk", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -53,7 +53,8 @@ TARGET_CRATES := libc std flate arena term \\\n                  serialize getopts collections test time rand \\\n                  log regex graphviz core rbml alloc \\\n                  unicode\n-RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_driver rustc_trans rustc_back rustc_llvm \n+RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n+                rustc_trans rustc_back rustc_llvm\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc regex_macros fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n@@ -67,11 +68,12 @@ DEPS_std := core libc rand alloc collections unicode \\\n DEPS_graphviz := std\n DEPS_syntax := std term serialize log fmt_macros arena libc\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n-                     rustc_typeck log syntax serialize rustc_llvm rustc_trans\n+                     rustc_typeck rustc_resolve log syntax serialize rustc_llvm rustc_trans\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n \t                log syntax serialize rustc_llvm\n DEPS_rustc_typeck := rustc syntax\n DEPS_rustc_borrowck := rustc log graphviz syntax\n+DEPS_rustc_resolve := rustc log syntax\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n               time log graphviz rustc_llvm rustc_back\n DEPS_rustc_llvm := native:rustllvm libc std\n@@ -118,9 +120,11 @@ DOC_CRATES := $(filter-out rustc, \\\n               $(filter-out rustc_trans, \\\n               $(filter-out rustc_typeck, \\\n               $(filter-out rustc_borrowck, \\\n+              $(filter-out rustc_resolve, \\\n               $(filter-out rustc_driver, \\\n-              $(filter-out syntax, $(CRATES)))))))\n-COMPILER_DOC_CRATES := rustc rustc_trans rustc_borrowck rustc_typeck rustc_driver syntax\n+              $(filter-out syntax, $(CRATES))))))))\n+COMPILER_DOC_CRATES := rustc rustc_trans rustc_borrowck rustc_resolve \\\n+                       rustc_typeck rustc_driver syntax\n \n # This macro creates some simple definitions for each crate being built, just\n # some munging of all of the parameters above."}, {"sha": "a5495a44a11f79dace2ae57d8888f39ee71252b5", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -21,7 +21,8 @@ $(eval $(call RUST_CRATE,coretest))\n \n TEST_TARGET_CRATES = $(filter-out core unicode,$(TARGET_CRATES)) coretest\n TEST_DOC_CRATES = $(DOC_CRATES)\n-TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_trans,$(HOST_CRATES))\n+TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_resolve rustc_trans,\\\n+                     $(HOST_CRATES))\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n ######################################################################"}, {"sha": "669a51449709d316c71541ab5c016cbc68d74a66", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -90,7 +90,6 @@ pub mod middle {\n     pub mod reachable;\n     pub mod region;\n     pub mod recursion_limit;\n-    pub mod resolve;\n     pub mod resolve_lifetime;\n     pub mod stability;\n     pub mod subst;"}, {"sha": "b702f4925d84739983de49941b63a046b620dddb", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -19,7 +19,6 @@ use metadata::cstore;\n use metadata::decoder;\n use middle::def;\n use middle::lang_items;\n-use middle::resolve;\n use middle::ty;\n \n use rbml;\n@@ -148,7 +147,7 @@ pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n }\n \n pub fn get_trait_item_name_and_kind(cstore: &cstore::CStore, def: ast::DefId)\n-                                    -> (ast::Name, resolve::TraitItemKind) {\n+                                    -> (ast::Name, def::TraitItemKind) {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_item_name_and_kind(cstore.intr.clone(),\n                                           &*cdata,"}, {"sha": "d8168814c6cd0591324f9fadbd96049c063e7140", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -27,7 +27,6 @@ use metadata::tydecode::{parse_ty_data, parse_region_data, parse_def_id,\n                          parse_predicate_data};\n use middle::def;\n use middle::lang_items;\n-use middle::resolve::{TraitItemKind, TypeTraitItemKind};\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty::{mod, Ty};\n@@ -785,15 +784,15 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n pub fn get_trait_item_name_and_kind(intr: Rc<IdentInterner>,\n                                     cdata: Cmd,\n                                     id: ast::NodeId)\n-                                    -> (ast::Name, TraitItemKind) {\n+                                    -> (ast::Name, def::TraitItemKind) {\n     let doc = lookup_item(id, cdata.data());\n     let name = item_name(&*intr, doc);\n     match item_sort(doc) {\n         'r' | 'p' => {\n             let explicit_self = get_explicit_self(doc);\n-            (name, TraitItemKind::from_explicit_self_category(explicit_self))\n+            (name, def::TraitItemKind::from_explicit_self_category(explicit_self))\n         }\n-        't' => (name, TypeTraitItemKind),\n+        't' => (name, def::TypeTraitItemKind),\n         c => {\n             panic!(\"get_trait_item_name_and_kind(): unknown trait item kind \\\n                    in metadata: `{}`\", c)"}, {"sha": "deb86397eda2aad6e1329de79a2af3233a191bcd", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -21,10 +21,10 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n+use middle::def;\n use middle::ty::{lookup_item_type};\n use middle::ty::{mod, Ty};\n use middle::stability;\n-use middle;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use serialize::Encodable;\n@@ -66,7 +66,7 @@ pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n pub struct EncodeParams<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub reexports2: &'a middle::resolve::ExportMap2,\n+    pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n@@ -77,7 +77,7 @@ pub struct EncodeParams<'a, 'tcx: 'a> {\n pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub reexports2: &'a middle::resolve::ExportMap2,\n+    pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n@@ -379,7 +379,7 @@ fn encode_path<PI: Iterator<PathElem>>(rbml_w: &mut Encoder, path: PI) {\n }\n \n fn encode_reexported_static_method(rbml_w: &mut Encoder,\n-                                   exp: &middle::resolve::Export2,\n+                                   exp: &def::Export,\n                                    method_def_id: DefId,\n                                    method_name: ast::Name) {\n     debug!(\"(encode reexported static method) {}::{}\",\n@@ -398,7 +398,7 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n \n fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          rbml_w: &mut Encoder,\n-                                         exp: &middle::resolve::Export2)\n+                                         exp: &def::Export)\n                                          -> bool {\n     let impl_items = ecx.tcx.impl_items.borrow();\n     match ecx.tcx.inherent_impls.borrow().get(&exp.def_id) {\n@@ -428,7 +428,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n \n fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           rbml_w: &mut Encoder,\n-                                          exp: &middle::resolve::Export2)\n+                                          exp: &def::Export)\n                                           -> bool {\n     match ecx.tcx.trait_items_cache.borrow().get(&exp.def_id) {\n         Some(trait_items) => {\n@@ -449,10 +449,8 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     mod_path: PathElems,\n-                                    exp: &middle::resolve::Export2) {\n+                                    exp: &def::Export) {\n     if let Some(ast_map::NodeItem(item)) = ecx.tcx.map.find(exp.def_id.node) {\n-        let original_name = token::get_ident(item.ident);\n-\n         let path_differs = ecx.tcx.map.with_path(exp.def_id.node, |path| {\n             let (mut a, mut b) = (path, mod_path.clone());\n             loop {\n@@ -474,16 +472,16 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n         // encoded metadata for static methods relative to Bar,\n         // but not yet for Foo.\n         //\n-        if path_differs || original_name.get() != exp.name {\n+        if path_differs || item.ident.name != exp.name {\n             if !encode_reexported_static_base_methods(ecx, rbml_w, exp) {\n                 if encode_reexported_static_trait_methods(ecx, rbml_w, exp) {\n                     debug!(\"(encode reexported static methods) {} [trait]\",\n-                           original_name);\n+                           item.ident.name);\n                 }\n             }\n             else {\n                 debug!(\"(encode reexported static methods) {} [base]\",\n-                       original_name);\n+                       item.ident.name);\n             }\n         }\n     }\n@@ -519,7 +517,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                     id: NodeId,\n                     path: PathElems) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-    match ecx.reexports2.get(&id) {\n+    match ecx.reexports.get(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for {}\", id);\n             for exp in exports.iter() {\n@@ -534,7 +532,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                 rbml_w.wr_str(def_to_string(exp.def_id).as_slice());\n                 rbml_w.end_tag();\n                 rbml_w.start_tag(tag_items_data_item_reexport_name);\n-                rbml_w.wr_str(exp.name.as_slice());\n+                rbml_w.wr_str(exp.name.as_str());\n                 rbml_w.end_tag();\n                 rbml_w.end_tag();\n                 encode_reexported_static_methods(ecx, rbml_w, path.clone(), exp);\n@@ -2071,7 +2069,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         item_symbols,\n         diag,\n         tcx,\n-        reexports2,\n+        reexports,\n         cstore,\n         encode_inlined_item,\n         link_meta,\n@@ -2081,7 +2079,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n     let ecx = EncodeContext {\n         diag: diag,\n         tcx: tcx,\n-        reexports2: reexports2,\n+        reexports: reexports,\n         item_symbols: item_symbols,\n         link_meta: link_meta,\n         cstore: cstore,"}, {"sha": "90242a3252ec7119f0e80693d627b2f89748ba95", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -12,8 +12,7 @@\n // recursively.\n \n use session::Session;\n-use middle::resolve;\n-use middle::def::{DefStatic, DefConst};\n+use middle::def::{DefStatic, DefConst, DefMap};\n \n use syntax::ast;\n use syntax::{ast_util, ast_map};\n@@ -22,7 +21,7 @@ use syntax::visit;\n \n struct CheckCrateVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n-    def_map: &'a resolve::DefMap,\n+    def_map: &'a DefMap,\n     ast_map: &'a ast_map::Map<'ast>\n }\n \n@@ -34,7 +33,7 @@ impl<'v, 'a, 'ast> Visitor<'v> for CheckCrateVisitor<'a, 'ast> {\n \n pub fn check_crate<'ast>(sess: &Session,\n                          krate: &ast::Crate,\n-                         def_map: &resolve::DefMap,\n+                         def_map: &DefMap,\n                          ast_map: &ast_map::Map<'ast>) {\n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n@@ -60,15 +59,15 @@ struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n     root_it: &'a ast::Item,\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n-    def_map: &'a resolve::DefMap,\n+    def_map: &'a DefMap,\n     idstack: Vec<ast::NodeId>\n }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n pub fn check_item_recursion<'a>(sess: &'a Session,\n                                 ast_map: &'a ast_map::Map,\n-                                def_map: &'a resolve::DefMap,\n+                                def_map: &'a DefMap,\n                                 it: &'a ast::Item) {\n \n     let mut visitor = CheckItemRecursionVisitor {"}, {"sha": "a582907612fd5bf5f5b441ea7f12c963c7f49a0f", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -10,11 +10,16 @@\n \n pub use self::Def::*;\n pub use self::MethodProvenance::*;\n+pub use self::TraitItemKind::*;\n \n use middle::subst::ParamSpace;\n+use middle::ty::{ExplicitSelfCategory, StaticExplicitSelfCategory};\n+use util::nodemap::NodeMap;\n use syntax::ast;\n use syntax::ast_util::local_def;\n \n+use std::cell::RefCell;\n+\n #[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Def {\n     DefFn(ast::DefId, bool /* is_ctor */),\n@@ -56,6 +61,18 @@ pub enum Def {\n     DefMethod(ast::DefId /* method */, Option<ast::DefId> /* trait */, MethodProvenance),\n }\n \n+// Definition mapping\n+pub type DefMap = RefCell<NodeMap<Def>>;\n+// This is the replacement export map. It maps a module to all of the exports\n+// within.\n+pub type ExportMap = NodeMap<Vec<Export>>;\n+\n+#[deriving(Copy)]\n+pub struct Export {\n+    pub name: ast::Name,    // The name of the target.\n+    pub def_id: ast::DefId, // The definition of the target.\n+}\n+\n #[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum MethodProvenance {\n     FromTrait(ast::DefId),\n@@ -88,6 +105,25 @@ impl TyParamProvenance {\n     }\n }\n \n+#[deriving(Clone, Copy, Eq, PartialEq)]\n+pub enum TraitItemKind {\n+    NonstaticMethodTraitItemKind,\n+    StaticMethodTraitItemKind,\n+    TypeTraitItemKind,\n+}\n+\n+impl TraitItemKind {\n+    pub fn from_explicit_self_category(explicit_self_category:\n+                                       ExplicitSelfCategory)\n+                                       -> TraitItemKind {\n+        if explicit_self_category == StaticExplicitSelfCategory {\n+            StaticMethodTraitItemKind\n+        } else {\n+            NonstaticMethodTraitItemKind\n+        }\n+    }\n+}\n+\n impl Def {\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n@@ -122,4 +158,3 @@ impl Def {\n         }\n     }\n }\n-"}, {"sha": "0a6c29d1cb65a154e4bf4461d515e4ece52316e6", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use middle::def::*;\n-use middle::resolve;\n use middle::ty;\n use util::nodemap::FnvHashMap;\n \n@@ -21,15 +20,15 @@ pub type PatIdMap = FnvHashMap<ast::Ident, ast::NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(dm: &resolve::DefMap, pat: &ast::Pat) -> PatIdMap {\n+pub fn pat_id_map(dm: &DefMap, pat: &ast::Pat) -> PatIdMap {\n     let mut map = FnvHashMap::new();\n     pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n         map.insert(path1.node, p_id);\n     });\n     map\n }\n \n-pub fn pat_is_refutable(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_is_refutable(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n         ast::PatLit(_) | ast::PatRange(_, _) => true,\n         ast::PatEnum(_, _) |\n@@ -45,7 +44,7 @@ pub fn pat_is_refutable(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n         ast::PatEnum(_, _) |\n         ast::PatIdent(_, _, None) |\n@@ -59,7 +58,7 @@ pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_const(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_is_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n         ast::PatIdent(_, _, None) | ast::PatEnum(..) => {\n             match dm.borrow().get(&pat.id) {\n@@ -71,7 +70,7 @@ pub fn pat_is_const(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_is_binding(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n         ast::PatIdent(..) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n@@ -81,7 +80,7 @@ pub fn pat_is_binding(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n         ast::PatIdent(..) => pat_is_binding(dm, pat),\n         ast::PatWild(_) => true,\n@@ -91,7 +90,7 @@ pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n \n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings<I>(dm: &resolve::DefMap, pat: &ast::Pat, mut it: I) where\n+pub fn pat_bindings<I>(dm: &DefMap, pat: &ast::Pat, mut it: I) where\n     I: FnMut(ast::BindingMode, ast::NodeId, Span, &ast::SpannedIdent),\n {\n     walk_pat(pat, |p| {\n@@ -107,7 +106,7 @@ pub fn pat_bindings<I>(dm: &resolve::DefMap, pat: &ast::Pat, mut it: I) where\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_contains_bindings(dm: &DefMap, pat: &ast::Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {\n         if pat_is_binding(dm, p) {"}, {"sha": "8c566dd288ef87b5394a4b9f3a9cb9d670453253", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 75, "deletions": 29, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -11,34 +11,80 @@\n //! A pass that checks to make sure private fields and methods aren't used\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n+pub use self::PrivateDep::*;\n+pub use self::ImportUse::*;\n+pub use self::LastPrivate::*;\n use self::PrivacyResult::*;\n use self::FieldName::*;\n \n use std::mem::replace;\n \n use metadata::csearch;\n-use middle::{def, resolve};\n+use middle::def;\n use middle::ty::{mod, Ty};\n use middle::ty::{MethodCall, MethodMap, MethodOrigin, MethodParam, MethodTypeParam};\n use middle::ty::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n-use util::nodemap::{NodeMap, NodeSet};\n+use util::nodemap::{DefIdSet, NodeMap, NodeSet};\n \n use syntax::{ast, ast_map};\n use syntax::ast_util::{is_local, local_def, PostExpansionMethod};\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit::{mod, Visitor};\n \n-type Context<'a, 'tcx> = (&'a MethodMap<'tcx>, &'a resolve::ExportMap2);\n+type Context<'a, 'tcx> = (&'a MethodMap<'tcx>, &'a def::ExportMap);\n \n /// A set of AST nodes exported by the crate.\n pub type ExportedItems = NodeSet;\n \n+/// A set containing all exported definitions from external crates.\n+/// The set does not contain any entries from local crates.\n+pub type ExternalExports = DefIdSet;\n+\n /// A set of AST nodes that are fully public in the crate. This map is used for\n /// documentation purposes (reexporting a private struct inlines the doc,\n /// reexporting a public struct doesn't inline the doc).\n pub type PublicItems = NodeSet;\n \n+// FIXME: dox\n+pub type LastPrivateMap = NodeMap<LastPrivate>;\n+\n+#[deriving(Copy, Show)]\n+pub enum LastPrivate {\n+    LastMod(PrivateDep),\n+    // `use` directives (imports) can refer to two separate definitions in the\n+    // type and value namespaces. We record here the last private node for each\n+    // and whether the import is in fact used for each.\n+    // If the Option<PrivateDep> fields are None, it means there is no definition\n+    // in that namespace.\n+    LastImport{value_priv: Option<PrivateDep>,\n+               value_used: ImportUse,\n+               type_priv: Option<PrivateDep>,\n+               type_used: ImportUse},\n+}\n+\n+#[deriving(Copy, Show)]\n+pub enum PrivateDep {\n+    AllPublic,\n+    DependsOn(ast::DefId),\n+}\n+\n+// How an import is used.\n+#[deriving(Copy, PartialEq, Show)]\n+pub enum ImportUse {\n+    Unused,       // The import is not used.\n+    Used,         // The import is used.\n+}\n+\n+impl LastPrivate {\n+    pub fn or(self, other: LastPrivate) -> LastPrivate {\n+        match (self, other) {\n+            (me, LastMod(AllPublic)) => me,\n+            (_, other) => other,\n+        }\n+    }\n+}\n+\n /// Result of a checking operation - None => no errors were found. Some => an\n /// error and contains the span and message for reporting that error and\n /// optionally the same for a note about the error.\n@@ -136,7 +182,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n \n struct EmbargoVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    exp_map2: &'a resolve::ExportMap2,\n+    export_map: &'a def::ExportMap,\n \n     // This flag is an indicator of whether the previous item in the\n     // hierarchical chain was exported or not. This is the indicator of whether\n@@ -342,8 +388,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_exported {\n-            assert!(self.exp_map2.contains_key(&id), \"wut {}\", id);\n-            for export in self.exp_map2[id].iter() {\n+            assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n+            for export in self.export_map[id].iter() {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n                 }\n@@ -362,8 +408,8 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n     curitem: ast::NodeId,\n     in_foreign: bool,\n     parents: NodeMap<ast::NodeId>,\n-    external_exports: resolve::ExternalExports,\n-    last_private_map: resolve::LastPrivateMap,\n+    external_exports: ExternalExports,\n+    last_private_map: LastPrivateMap,\n }\n \n enum PrivacyResult {\n@@ -719,25 +765,25 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             };\n \n             match self.last_private_map[path_id] {\n-                resolve::LastMod(resolve::AllPublic) => {},\n-                resolve::LastMod(resolve::DependsOn(def)) => {\n+                LastMod(AllPublic) => {},\n+                LastMod(DependsOn(def)) => {\n                     self.report_error(ck_public(def));\n                 },\n-                resolve::LastImport{value_priv,\n-                                    value_used: check_value,\n-                                    type_priv,\n-                                    type_used: check_type} => {\n+                LastImport { value_priv,\n+                             value_used: check_value,\n+                             type_priv,\n+                             type_used: check_type } => {\n                     // This dance with found_error is because we don't want to report\n                     // a privacy error twice for the same directive.\n                     let found_error = match (type_priv, check_type) {\n-                        (Some(resolve::DependsOn(def)), resolve::Used) => {\n+                        (Some(DependsOn(def)), Used) => {\n                             !self.report_error(ck_public(def))\n                         },\n                         _ => false,\n                     };\n                     if !found_error {\n                         match (value_priv, check_value) {\n-                            (Some(resolve::DependsOn(def)), resolve::Used) => {\n+                            (Some(DependsOn(def)), Used) => {\n                                 self.report_error(ck_public(def));\n                             },\n                             _ => {},\n@@ -749,24 +795,24 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                     // be illegal. We only report one error, even if it is\n                     // illegal to import from both namespaces.\n                     match (value_priv, check_value, type_priv, check_type) {\n-                        (Some(p), resolve::Unused, None, _) |\n-                        (None, _, Some(p), resolve::Unused) => {\n+                        (Some(p), Unused, None, _) |\n+                        (None, _, Some(p), Unused) => {\n                             let p = match p {\n-                                resolve::AllPublic => None,\n-                                resolve::DependsOn(def) => ck_public(def),\n+                                AllPublic => None,\n+                                DependsOn(def) => ck_public(def),\n                             };\n                             if p.is_some() {\n                                 self.report_error(p);\n                             }\n                         },\n-                        (Some(v), resolve::Unused, Some(t), resolve::Unused) => {\n+                        (Some(v), Unused, Some(t), Unused) => {\n                             let v = match v {\n-                                resolve::AllPublic => None,\n-                                resolve::DependsOn(def) => ck_public(def),\n+                                AllPublic => None,\n+                                DependsOn(def) => ck_public(def),\n                             };\n                             let t = match t {\n-                                resolve::AllPublic => None,\n-                                resolve::DependsOn(def) => ck_public(def),\n+                                AllPublic => None,\n+                                DependsOn(def) => ck_public(def),\n                             };\n                             if let (Some(_), Some(t)) = (v, t) {\n                                 self.report_error(Some(t));\n@@ -1520,9 +1566,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   exp_map2: &resolve::ExportMap2,\n-                   external_exports: resolve::ExternalExports,\n-                   last_private_map: resolve::LastPrivateMap)\n+                   export_map: &def::ExportMap,\n+                   external_exports: ExternalExports,\n+                   last_private_map: LastPrivateMap)\n                    -> (ExportedItems, PublicItems) {\n     let krate = tcx.map.krate();\n \n@@ -1561,7 +1607,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         exported_items: NodeSet::new(),\n         public_items: NodeSet::new(),\n         reexports: NodeSet::new(),\n-        exp_map2: exp_map2,\n+        export_map: export_map,\n         prev_exported: true,\n         prev_public: true,\n     };"}, {"sha": "c8f53df6727e5fdc8bbae86f2067c0666587f01e", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -19,9 +19,8 @@ pub use self::DefRegion::*;\n use self::ScopeChain::*;\n \n use session::Session;\n-use middle::def;\n+use middle::def::{mod, DefMap};\n use middle::region;\n-use middle::resolve::DefMap;\n use middle::subst;\n use middle::ty;\n use std::fmt;"}, {"sha": "d5c97bd6aa6c6756226f5e835a6a7355a7c81692", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -46,13 +46,12 @@ use lint;\n use metadata::csearch;\n use middle;\n use middle::const_eval;\n-use middle::def;\n+use middle::def::{mod, DefMap, ExportMap};\n use middle::dependency_format;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n use middle::lang_items::{FnOnceTraitLangItem, TyDescStructLangItem};\n use middle::mem_categorization as mc;\n use middle::region;\n-use middle::resolve;\n use middle::resolve_lifetime;\n use middle::infer;\n use middle::stability;\n@@ -99,7 +98,7 @@ pub const INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n /// The complete set of all analyses described in this module. This is\n /// produced by the driver and fed to trans and later passes.\n pub struct CrateAnalysis<'tcx> {\n-    pub exp_map2: middle::resolve::ExportMap2,\n+    pub export_map: ExportMap,\n     pub exported_items: middle::privacy::ExportedItems,\n     pub public_items: middle::privacy::PublicItems,\n     pub ty_cx: ty::ctxt<'tcx>,\n@@ -615,7 +614,7 @@ pub struct ctxt<'tcx> {\n     // queried from a HashSet.\n     interner: RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n     pub sess: Session,\n-    pub def_map: resolve::DefMap,\n+    pub def_map: DefMap,\n \n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n@@ -1967,7 +1966,7 @@ impl UnboxedClosureKind {\n \n pub fn mk_ctxt<'tcx>(s: Session,\n                      type_arena: &'tcx TypedArena<TyS<'tcx>>,\n-                     dm: resolve::DefMap,\n+                     dm: DefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n                      freevars: RefCell<FreevarMap>,\n@@ -6263,6 +6262,9 @@ pub type FreevarMap = NodeMap<Vec<Freevar>>;\n \n pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n \n+// Trait method resolution\n+pub type TraitMap = NodeMap<Vec<DefId>>;\n+\n pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n     F: FnOnce(&[Freevar]) -> T,\n {"}, {"sha": "60b890b037095c0f0845a76777d20a9858c81efe", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -20,6 +20,7 @@ use rustc::plugin::registry::Registry;\n use rustc::plugin;\n use rustc::util::common::time;\n use rustc_borrowck as borrowck;\n+use rustc_resolve as resolve;\n use rustc_trans::back::link;\n use rustc_trans::back::write;\n use rustc_trans::save;\n@@ -341,17 +342,17 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let lang_items = time(time_passes, \"language item collection\", (), |_|\n                           middle::lang_items::collect_language_items(krate, &sess));\n \n-    let middle::resolve::CrateMap {\n+    let resolve::CrateMap {\n         def_map,\n         freevars,\n         capture_mode_map,\n-        exp_map2,\n+        export_map,\n         trait_map,\n         external_exports,\n         last_private_map\n     } =\n-        time(time_passes, \"resolution\", (), |_|\n-             middle::resolve::resolve_crate(&sess, &lang_items, krate));\n+        time(time_passes, \"resolution\", (),\n+             |_| resolve::resolve_crate(&sess, &lang_items, krate));\n \n     // Discard MTWT tables that aren't required past resolution.\n     syntax::ext::mtwt::clear_tables();\n@@ -406,7 +407,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let maps = (external_exports, last_private_map);\n     let (exported_items, public_items) =\n             time(time_passes, \"privacy checking\", maps, |(a, b)|\n-                 middle::privacy::check_crate(&ty_cx, &exp_map2, a, b));\n+                 middle::privacy::check_crate(&ty_cx, &export_map, a, b));\n \n     time(time_passes, \"intrinsic checking\", (), |_|\n          middle::intrinsicck::check_crate(&ty_cx));\n@@ -447,7 +448,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n          lint::check_crate(&ty_cx, &exported_items));\n \n     ty::CrateAnalysis {\n-        exp_map2: exp_map2,\n+        export_map: export_map,\n         ty_cx: ty_cx,\n         exported_items: exported_items,\n         public_items: public_items,"}, {"sha": "34d9fd6bcad74cb94d500512fc4f85801e02eb95", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -35,6 +35,7 @@ extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_borrowck;\n+extern crate rustc_resolve;\n extern crate rustc_trans;\n extern crate rustc_typeck;\n #[phase(plugin, link)] extern crate log;"}, {"sha": "090d6a7a3caef2d81fb855110bf35e11d12f9e25", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -13,9 +13,9 @@\n use diagnostic;\n use diagnostic::Emitter;\n use driver;\n+use rustc_resolve as resolve;\n use rustc_typeck::middle::lang_items;\n use rustc_typeck::middle::region::{mod, CodeExtent};\n-use rustc_typeck::middle::resolve;\n use rustc_typeck::middle::resolve_lifetime;\n use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;"}, {"sha": "39cdf6fc8f31828596e52a6ef1c31d5741f1e5b1", "filename": "src/librustc_resolve/check_unused.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -0,0 +1,161 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+//\n+// Unused import checking\n+//\n+// Although this is mostly a lint pass, it lives in here because it depends on\n+// resolve data structures and because it finalises the privacy information for\n+// `use` directives.\n+//\n+\n+use Resolver;\n+use Namespace::{TypeNS, ValueNS};\n+\n+use rustc::lint;\n+use rustc::middle::privacy::{DependsOn, LastImport, Used, Unused};\n+use syntax::ast;\n+use syntax::ast::{ViewItem, ViewItemExternCrate, ViewItemUse};\n+use syntax::ast::{ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::visit::{mod, Visitor};\n+\n+struct UnusedImportCheckVisitor<'a, 'b:'a> {\n+    resolver: &'a mut Resolver<'b>\n+}\n+\n+// Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n+impl<'a, 'b> Deref<Resolver<'b>> for UnusedImportCheckVisitor<'a, 'b> {\n+    fn deref<'c>(&'c self) -> &'c Resolver<'b> {\n+        &*self.resolver\n+    }\n+}\n+\n+impl<'a, 'b> DerefMut<Resolver<'b>> for UnusedImportCheckVisitor<'a, 'b> {\n+    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> {\n+        &mut *self.resolver\n+    }\n+}\n+\n+impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n+    // We have information about whether `use` (import) directives are actually used now.\n+    // If an import is not used at all, we signal a lint error. If an import is only used\n+    // for a single namespace, we remove the other namespace from the recorded privacy\n+    // information. That means in privacy.rs, we will only check imports and namespaces\n+    // which are used. In particular, this means that if an import could name either a\n+    // public or private item, we will check the correct thing, dependent on how the import\n+    // is used.\n+    fn finalize_import(&mut self, id: ast::NodeId, span: Span) {\n+        debug!(\"finalizing import uses for {}\",\n+                self.session.codemap().span_to_snippet(span));\n+\n+        if !self.used_imports.contains(&(id, TypeNS)) &&\n+           !self.used_imports.contains(&(id, ValueNS)) {\n+            self.session.add_lint(lint::builtin::UNUSED_IMPORTS,\n+                                  id,\n+                                  span,\n+                                  \"unused import\".to_string());\n+        }\n+\n+        let (v_priv, t_priv) = match self.last_private.get(&id) {\n+            Some(&LastImport {\n+                value_priv: v,\n+                value_used: _,\n+                type_priv: t,\n+                type_used: _\n+            }) => (v, t),\n+            Some(_) => {\n+                panic!(\"we should only have LastImport for `use` directives\")\n+            }\n+            _ => return,\n+        };\n+\n+        let mut v_used = if self.used_imports.contains(&(id, ValueNS)) {\n+            Used\n+        } else {\n+            Unused\n+        };\n+        let t_used = if self.used_imports.contains(&(id, TypeNS)) {\n+            Used\n+        } else {\n+            Unused\n+        };\n+\n+        match (v_priv, t_priv) {\n+            // Since some items may be both in the value _and_ type namespaces (e.g., structs)\n+            // we might have two LastPrivates pointing at the same thing. There is no point\n+            // checking both, so lets not check the value one.\n+            (Some(DependsOn(def_v)), Some(DependsOn(def_t))) if def_v == def_t => v_used = Unused,\n+            _ => {},\n+        }\n+\n+        self.last_private.insert(id, LastImport{value_priv: v_priv,\n+                                                value_used: v_used,\n+                                                type_priv: t_priv,\n+                                                type_used: t_used});\n+    }\n+}\n+\n+impl<'a, 'b, 'v> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b> {\n+    fn visit_view_item(&mut self, vi: &ViewItem) {\n+        // Ignore is_public import statements because there's no way to be sure\n+        // whether they're used or not. Also ignore imports with a dummy span\n+        // because this means that they were generated in some fashion by the\n+        // compiler and we don't need to consider them.\n+        if vi.vis == ast::Public || vi.span == DUMMY_SP {\n+            visit::walk_view_item(self, vi);\n+            return;\n+        }\n+\n+        match vi.node {\n+            ViewItemExternCrate(_, _, id) => {\n+                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(id) {\n+                    if !self.used_crates.contains(&crate_num) {\n+                        self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n+                                              id,\n+                                              vi.span,\n+                                              \"unused extern crate\".to_string());\n+                    }\n+                }\n+            },\n+            ViewItemUse(ref p) => {\n+                match p.node {\n+                    ViewPathSimple(_, _, id) => {\n+                        self.finalize_import(id, p.span)\n+                    }\n+\n+                    ViewPathList(_, ref list, _) => {\n+                        for i in list.iter() {\n+                            self.finalize_import(i.node.id(), i.span);\n+                        }\n+                    }\n+                    ViewPathGlob(_, id) => {\n+                        if !self.used_imports.contains(&(id, TypeNS)) &&\n+                           !self.used_imports.contains(&(id, ValueNS)) {\n+                            self.session\n+                                .add_lint(lint::builtin::UNUSED_IMPORTS,\n+                                          id,\n+                                          p.span,\n+                                          \"unused import\".to_string());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        visit::walk_view_item(self, vi);\n+    }\n+}\n+\n+pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n+    let mut visitor = UnusedImportCheckVisitor { resolver: resolver };\n+    visit::walk_crate(&mut visitor, krate);\n+}"}, {"sha": "e1708be30d972c02ad1845f5dd6a01d78cc64841", "filename": "src/librustc_resolve/lib.rs", "status": "renamed", "additions": 56, "deletions": 364, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -8,12 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n+#![crate_name = \"rustc_resolve\"]\n+#![experimental]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n+\n+#![feature(globs, phase, slicing_syntax)]\n+#![feature(rustc_diagnostic_macros)]\n+\n+#[phase(plugin, link)] extern crate log;\n+#[phase(plugin, link)] extern crate syntax;\n+\n+extern crate rustc;\n \n-pub use self::PrivateDep::*;\n-pub use self::ImportUse::*;\n-pub use self::TraitItemKind::*;\n-pub use self::LastPrivate::*;\n use self::PatternBindingMode::*;\n use self::Namespace::*;\n use self::NamespaceError::*;\n@@ -36,26 +46,26 @@ use self::ModuleKind::*;\n use self::TraitReferenceType::*;\n use self::FallbackChecks::*;\n \n-use session::Session;\n-use lint;\n-use metadata::csearch;\n-use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n-use middle::def::*;\n-use middle::lang_items::LanguageItems;\n-use middle::pat_util::pat_bindings;\n-use middle::subst::{ParamSpace, FnSpace, TypeSpace};\n-use middle::ty::{ExplicitSelfCategory, StaticExplicitSelfCategory};\n-use middle::ty::{CaptureModeMap, Freevar, FreevarMap};\n-use util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n+use rustc::session::Session;\n+use rustc::lint;\n+use rustc::metadata::csearch;\n+use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n+use rustc::middle::def::*;\n+use rustc::middle::lang_items::LanguageItems;\n+use rustc::middle::pat_util::pat_bindings;\n+use rustc::middle::privacy::*;\n+use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n+use rustc::middle::ty::{CaptureModeMap, Freevar, FreevarMap, TraitMap};\n+use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DeclItem, DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic, Generics};\n-use syntax::ast::{Ident, ImplItem, Item, ItemEnum, ItemFn, ItemForeignMod};\n-use syntax::ast::{ItemImpl, ItemMac, ItemMod, ItemStatic, ItemStruct};\n-use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local, ItemConst};\n+use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemFn};\n+use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy, Local};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n@@ -86,72 +96,17 @@ use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::uint;\n \n-// Definition mapping\n-pub type DefMap = RefCell<NodeMap<Def>>;\n+mod check_unused;\n+mod record_exports;\n \n #[deriving(Copy)]\n-struct binding_info {\n+struct BindingInfo {\n     span: Span,\n     binding_mode: BindingMode,\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = HashMap<Name,binding_info>;\n-\n-// Trait method resolution\n-pub type TraitMap = NodeMap<Vec<DefId> >;\n-\n-// This is the replacement export map. It maps a module to all of the exports\n-// within.\n-pub type ExportMap2 = NodeMap<Vec<Export2>>;\n-\n-pub struct Export2 {\n-    pub name: String,        // The name of the target.\n-    pub def_id: DefId,       // The definition of the target.\n-}\n-\n-// This set contains all exported definitions from external crates. The set does\n-// not contain any entries from local crates.\n-pub type ExternalExports = DefIdSet;\n-\n-// FIXME: dox\n-pub type LastPrivateMap = NodeMap<LastPrivate>;\n-\n-#[deriving(Copy, Show)]\n-pub enum LastPrivate {\n-    LastMod(PrivateDep),\n-    // `use` directives (imports) can refer to two separate definitions in the\n-    // type and value namespaces. We record here the last private node for each\n-    // and whether the import is in fact used for each.\n-    // If the Option<PrivateDep> fields are None, it means there is no definition\n-    // in that namespace.\n-    LastImport{value_priv: Option<PrivateDep>,\n-               value_used: ImportUse,\n-               type_priv: Option<PrivateDep>,\n-               type_used: ImportUse},\n-}\n-\n-#[deriving(Copy, Show)]\n-pub enum PrivateDep {\n-    AllPublic,\n-    DependsOn(DefId),\n-}\n-\n-// How an import is used.\n-#[deriving(Copy, PartialEq, Show)]\n-pub enum ImportUse {\n-    Unused,       // The import is not used.\n-    Used,         // The import is used.\n-}\n-\n-impl LastPrivate {\n-    fn or(self, other: LastPrivate) -> LastPrivate {\n-        match (self, other) {\n-            (me, LastMod(AllPublic)) => me,\n-            (_, other) => other,\n-        }\n-    }\n-}\n+type BindingMap = HashMap<Name, BindingInfo>;\n \n #[deriving(Copy, PartialEq)]\n enum PatternBindingMode {\n@@ -340,25 +295,6 @@ enum ModulePrefixResult {\n     PrefixFound(Rc<Module>, uint)\n }\n \n-#[deriving(Clone, Copy, Eq, PartialEq)]\n-pub enum TraitItemKind {\n-    NonstaticMethodTraitItemKind,\n-    StaticMethodTraitItemKind,\n-    TypeTraitItemKind,\n-}\n-\n-impl TraitItemKind {\n-    pub fn from_explicit_self_category(explicit_self_category:\n-                                       ExplicitSelfCategory)\n-                                       -> TraitItemKind {\n-        if explicit_self_category == StaticExplicitSelfCategory {\n-            StaticMethodTraitItemKind\n-        } else {\n-            NonstaticMethodTraitItemKind\n-        }\n-    }\n-}\n-\n #[deriving(Copy, PartialEq)]\n enum NameSearchType {\n     /// We're doing a name search in order to resolve a `use` directive.\n@@ -948,7 +884,7 @@ struct Resolver<'a> {\n     freevars: RefCell<FreevarMap>,\n     freevars_seen: RefCell<NodeMap<NodeSet>>,\n     capture_mode_map: CaptureModeMap,\n-    export_map2: ExportMap2,\n+    export_map: ExportMap,\n     trait_map: TraitMap,\n     external_exports: ExternalExports,\n     last_private: LastPrivateMap,\n@@ -1002,17 +938,6 @@ impl<'a, 'b, 'v> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b> {\n \n }\n \n-struct UnusedImportCheckVisitor<'a, 'b:'a> {\n-    resolver: &'a mut Resolver<'b>\n-}\n-\n-impl<'a, 'b, 'v> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b> {\n-    fn visit_view_item(&mut self, vi: &ViewItem) {\n-        self.resolver.check_for_item_unused_imports(vi);\n-        visit::walk_view_item(self, vi);\n-    }\n-}\n-\n #[deriving(PartialEq)]\n enum FallbackChecks {\n     Everything,\n@@ -1063,7 +988,7 @@ impl<'a> Resolver<'a> {\n             freevars: RefCell::new(NodeMap::new()),\n             freevars_seen: RefCell::new(NodeMap::new()),\n             capture_mode_map: NodeMap::new(),\n-            export_map2: NodeMap::new(),\n+            export_map: NodeMap::new(),\n             trait_map: NodeMap::new(),\n             used_imports: HashSet::new(),\n             used_crates: HashSet::new(),\n@@ -1073,22 +998,6 @@ impl<'a> Resolver<'a> {\n             emit_errors: true,\n         }\n     }\n-    /// The main name resolution procedure.\n-    fn resolve(&mut self, krate: &ast::Crate) {\n-        self.build_reduced_graph(krate);\n-        self.session.abort_if_errors();\n-\n-        self.resolve_imports();\n-        self.session.abort_if_errors();\n-\n-        self.record_exports();\n-        self.session.abort_if_errors();\n-\n-        self.resolve_crate(krate);\n-        self.session.abort_if_errors();\n-\n-        self.check_for_unused_imports(krate);\n-    }\n \n     //\n     // Reduced graph building\n@@ -3800,125 +3709,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    // Export recording\n-    //\n-    // This pass simply determines what all \"export\" keywords refer to and\n-    // writes the results into the export map.\n-    //\n-    // FIXME #4953 This pass will be removed once exports change to per-item.\n-    // Then this operation can simply be performed as part of item (or import)\n-    // processing.\n-\n-    fn record_exports(&mut self) {\n-        let root_module = self.graph_root.get_module();\n-        self.record_exports_for_module_subtree(root_module);\n-    }\n-\n-    fn record_exports_for_module_subtree(&mut self,\n-                                             module_: Rc<Module>) {\n-        // If this isn't a local krate, then bail out. We don't need to record\n-        // exports for nonlocal crates.\n-\n-        match module_.def_id.get() {\n-            Some(def_id) if def_id.krate == LOCAL_CRATE => {\n-                // OK. Continue.\n-                debug!(\"(recording exports for module subtree) recording \\\n-                        exports for local module `{}`\",\n-                       self.module_to_string(&*module_));\n-            }\n-            None => {\n-                // Record exports for the root module.\n-                debug!(\"(recording exports for module subtree) recording \\\n-                        exports for root module `{}`\",\n-                       self.module_to_string(&*module_));\n-            }\n-            Some(_) => {\n-                // Bail out.\n-                debug!(\"(recording exports for module subtree) not recording \\\n-                        exports for `{}`\",\n-                       self.module_to_string(&*module_));\n-                return;\n-            }\n-        }\n-\n-        self.record_exports_for_module(&*module_);\n-        self.populate_module_if_necessary(&module_);\n-\n-        for (_, child_name_bindings) in module_.children.borrow().iter() {\n-            match child_name_bindings.get_module_if_available() {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(child_module) => {\n-                    self.record_exports_for_module_subtree(child_module);\n-                }\n-            }\n-        }\n-\n-        for (_, child_module) in module_.anonymous_children.borrow().iter() {\n-            self.record_exports_for_module_subtree(child_module.clone());\n-        }\n-    }\n-\n-    fn record_exports_for_module(&mut self, module_: &Module) {\n-        let mut exports2 = Vec::new();\n-\n-        self.add_exports_for_module(&mut exports2, module_);\n-        match module_.def_id.get() {\n-            Some(def_id) => {\n-                self.export_map2.insert(def_id.node, exports2);\n-                debug!(\"(computing exports) writing exports for {} (some)\",\n-                       def_id.node);\n-            }\n-            None => {}\n-        }\n-    }\n-\n-    fn add_exports_of_namebindings(&mut self,\n-                                   exports2: &mut Vec<Export2> ,\n-                                   name: Name,\n-                                   namebindings: &NameBindings,\n-                                   ns: Namespace) {\n-        match namebindings.def_for_namespace(ns) {\n-            Some(d) => {\n-                let name = token::get_name(name);\n-                debug!(\"(computing exports) YES: export '{}' => {}\",\n-                       name, d.def_id());\n-                exports2.push(Export2 {\n-                    name: name.get().to_string(),\n-                    def_id: d.def_id()\n-                });\n-            }\n-            d_opt => {\n-                debug!(\"(computing exports) NO: {}\", d_opt);\n-            }\n-        }\n-    }\n-\n-    fn add_exports_for_module(&mut self,\n-                              exports2: &mut Vec<Export2> ,\n-                              module_: &Module) {\n-        for (name, importresolution) in module_.import_resolutions.borrow().iter() {\n-            if !importresolution.is_public {\n-                continue\n-            }\n-            let xs = [TypeNS, ValueNS];\n-            for &ns in xs.iter() {\n-                match importresolution.target_for_namespace(ns) {\n-                    Some(target) => {\n-                        debug!(\"(computing exports) maybe export '{}'\",\n-                               token::get_name(*name));\n-                        self.add_exports_of_namebindings(exports2,\n-                                                         *name,\n-                                                         &*target.bindings,\n-                                                         ns)\n-                    }\n-                    _ => ()\n-                }\n-            }\n-        }\n-    }\n-\n     // AST resolution\n     //\n     // We maintain a list of value ribs and type ribs.\n@@ -4809,9 +4599,10 @@ impl<'a> Resolver<'a> {\n         let mut result = HashMap::new();\n         pat_bindings(&self.def_map, pat, |binding_mode, _id, sp, path1| {\n             let name = mtwt::resolve(path1.node);\n-            result.insert(name,\n-                          binding_info {span: sp,\n-                                        binding_mode: binding_mode});\n+            result.insert(name, BindingInfo {\n+                span: sp,\n+                binding_mode: binding_mode\n+            });\n         });\n         return result;\n     }\n@@ -6135,119 +5926,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    //\n-    // Unused import checking\n-    //\n-    // Although this is mostly a lint pass, it lives in here because it depends on\n-    // resolve data structures and because it finalises the privacy information for\n-    // `use` directives.\n-    //\n-\n-    fn check_for_unused_imports(&mut self, krate: &ast::Crate) {\n-        let mut visitor = UnusedImportCheckVisitor{ resolver: self };\n-        visit::walk_crate(&mut visitor, krate);\n-    }\n-\n-    fn check_for_item_unused_imports(&mut self, vi: &ViewItem) {\n-        // Ignore is_public import statements because there's no way to be sure\n-        // whether they're used or not. Also ignore imports with a dummy span\n-        // because this means that they were generated in some fashion by the\n-        // compiler and we don't need to consider them.\n-        if vi.vis == Public { return }\n-        if vi.span == DUMMY_SP { return }\n-\n-        match vi.node {\n-            ViewItemExternCrate(_, _, id) => {\n-                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(id) {\n-                    if !self.used_crates.contains(&crate_num) {\n-                        self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n-                                              id,\n-                                              vi.span,\n-                                              \"unused extern crate\".to_string());\n-                    }\n-                }\n-            },\n-            ViewItemUse(ref p) => {\n-                match p.node {\n-                    ViewPathSimple(_, _, id) => self.finalize_import(id, p.span),\n-\n-                    ViewPathList(_, ref list, _) => {\n-                        for i in list.iter() {\n-                            self.finalize_import(i.node.id(), i.span);\n-                        }\n-                    },\n-                    ViewPathGlob(_, id) => {\n-                        if !self.used_imports.contains(&(id, TypeNS)) &&\n-                           !self.used_imports.contains(&(id, ValueNS)) {\n-                            self.session\n-                                .add_lint(lint::builtin::UNUSED_IMPORTS,\n-                                          id,\n-                                          p.span,\n-                                          \"unused import\".to_string());\n-                        }\n-                    },\n-                }\n-            }\n-        }\n-    }\n-\n-    // We have information about whether `use` (import) directives are actually used now.\n-    // If an import is not used at all, we signal a lint error. If an import is only used\n-    // for a single namespace, we remove the other namespace from the recorded privacy\n-    // information. That means in privacy.rs, we will only check imports and namespaces\n-    // which are used. In particular, this means that if an import could name either a\n-    // public or private item, we will check the correct thing, dependent on how the import\n-    // is used.\n-    fn finalize_import(&mut self, id: NodeId, span: Span) {\n-        debug!(\"finalizing import uses for {}\",\n-               self.session.codemap().span_to_snippet(span));\n-\n-        if !self.used_imports.contains(&(id, TypeNS)) &&\n-           !self.used_imports.contains(&(id, ValueNS)) {\n-            self.session.add_lint(lint::builtin::UNUSED_IMPORTS,\n-                                  id,\n-                                  span,\n-                                  \"unused import\".to_string());\n-        }\n-\n-        let (v_priv, t_priv) = match self.last_private.get(&id) {\n-            Some(&LastImport {\n-                value_priv: v,\n-                value_used: _,\n-                type_priv: t,\n-                type_used: _\n-            }) => (v, t),\n-            Some(_) => {\n-                panic!(\"we should only have LastImport for `use` directives\")\n-            }\n-            _ => return,\n-        };\n-\n-        let mut v_used = if self.used_imports.contains(&(id, ValueNS)) {\n-            Used\n-        } else {\n-            Unused\n-        };\n-        let t_used = if self.used_imports.contains(&(id, TypeNS)) {\n-            Used\n-        } else {\n-            Unused\n-        };\n-\n-        match (v_priv, t_priv) {\n-            // Since some items may be both in the value _and_ type namespaces (e.g., structs)\n-            // we might have two LastPrivates pointing at the same thing. There is no point\n-            // checking both, so lets not check the value one.\n-            (Some(DependsOn(def_v)), Some(DependsOn(def_t))) if def_v == def_t => v_used = Unused,\n-            _ => {},\n-        }\n-\n-        self.last_private.insert(id, LastImport{value_priv: v_priv,\n-                                                value_used: v_used,\n-                                                type_priv: t_priv,\n-                                                type_used: t_used});\n-    }\n-\n     //\n     // Diagnostics\n     //\n@@ -6323,7 +6001,7 @@ pub struct CrateMap {\n     pub def_map: DefMap,\n     pub freevars: RefCell<FreevarMap>,\n     pub capture_mode_map: RefCell<CaptureModeMap>,\n-    pub exp_map2: ExportMap2,\n+    pub export_map: ExportMap,\n     pub trait_map: TraitMap,\n     pub external_exports: ExternalExports,\n     pub last_private_map: LastPrivateMap,\n@@ -6335,12 +6013,26 @@ pub fn resolve_crate(session: &Session,\n                      krate: &Crate)\n                   -> CrateMap {\n     let mut resolver = Resolver::new(session, krate.span);\n-    resolver.resolve(krate);\n+\n+    resolver.build_reduced_graph(krate);\n+    session.abort_if_errors();\n+\n+    resolver.resolve_imports();\n+    session.abort_if_errors();\n+\n+    record_exports::record(&mut resolver);\n+    session.abort_if_errors();\n+\n+    resolver.resolve_crate(krate);\n+    session.abort_if_errors();\n+\n+    check_unused::check_crate(&mut resolver, krate);\n+\n     CrateMap {\n         def_map: resolver.def_map,\n         freevars: resolver.freevars,\n         capture_mode_map: RefCell::new(resolver.capture_mode_map),\n-        exp_map2: resolver.export_map2,\n+        export_map: resolver.export_map,\n         trait_map: resolver.trait_map,\n         external_exports: resolver.external_exports,\n         last_private_map: resolver.last_private,", "previous_filename": "src/librustc/middle/resolve.rs"}, {"sha": "41882a94b34fd5dcb46b479523262e16029e81d0", "filename": "src/librustc_resolve/record_exports.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// Export recording\n+//\n+// This pass simply determines what all \"export\" keywords refer to and\n+// writes the results into the export map.\n+//\n+// FIXME #4953 This pass will be removed once exports change to per-item.\n+// Then this operation can simply be performed as part of item (or import)\n+// processing.\n+\n+use {Module, NameBindings, Resolver};\n+use Namespace::{mod, TypeNS, ValueNS};\n+\n+use rustc::middle::def::Export;\n+use syntax::ast;\n+use syntax::parse::token;\n+\n+use std::rc::Rc;\n+\n+struct ExportRecorder<'a, 'b:'a> {\n+    resolver: &'a mut Resolver<'b>\n+}\n+\n+// Deref and DerefMut impls allow treating ExportRecorder as Resolver.\n+impl<'a, 'b> Deref<Resolver<'b>> for ExportRecorder<'a, 'b> {\n+    fn deref<'c>(&'c self) -> &'c Resolver<'b> {\n+        &*self.resolver\n+    }\n+}\n+\n+impl<'a, 'b> DerefMut<Resolver<'b>> for ExportRecorder<'a, 'b> {\n+    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> {\n+        &mut *self.resolver\n+    }\n+}\n+\n+impl<'a, 'b> ExportRecorder<'a, 'b> {\n+    fn record_exports_for_module_subtree(&mut self,\n+                                         module_: Rc<Module>) {\n+        // If this isn't a local krate, then bail out. We don't need to record\n+        // exports for nonlocal crates.\n+\n+        match module_.def_id.get() {\n+            Some(def_id) if def_id.krate == ast::LOCAL_CRATE => {\n+                // OK. Continue.\n+                debug!(\"(recording exports for module subtree) recording \\\n+                        exports for local module `{}`\",\n+                       self.module_to_string(&*module_));\n+            }\n+            None => {\n+                // Record exports for the root module.\n+                debug!(\"(recording exports for module subtree) recording \\\n+                        exports for root module `{}`\",\n+                       self.module_to_string(&*module_));\n+            }\n+            Some(_) => {\n+                // Bail out.\n+                debug!(\"(recording exports for module subtree) not recording \\\n+                        exports for `{}`\",\n+                       self.module_to_string(&*module_));\n+                return;\n+            }\n+        }\n+\n+        self.record_exports_for_module(&*module_);\n+        self.populate_module_if_necessary(&module_);\n+\n+        for (_, child_name_bindings) in module_.children.borrow().iter() {\n+            match child_name_bindings.get_module_if_available() {\n+                None => {\n+                    // Nothing to do.\n+                }\n+                Some(child_module) => {\n+                    self.record_exports_for_module_subtree(child_module);\n+                }\n+            }\n+        }\n+\n+        for (_, child_module) in module_.anonymous_children.borrow().iter() {\n+            self.record_exports_for_module_subtree(child_module.clone());\n+        }\n+    }\n+\n+    fn record_exports_for_module(&mut self, module_: &Module) {\n+        let mut exports = Vec::new();\n+\n+        self.add_exports_for_module(&mut exports, module_);\n+        match module_.def_id.get() {\n+            Some(def_id) => {\n+                self.export_map.insert(def_id.node, exports);\n+                debug!(\"(computing exports) writing exports for {} (some)\",\n+                       def_id.node);\n+            }\n+            None => {}\n+        }\n+    }\n+\n+    fn add_exports_of_namebindings(&mut self,\n+                                   exports: &mut Vec<Export>,\n+                                   name: ast::Name,\n+                                   namebindings: &NameBindings,\n+                                   ns: Namespace) {\n+        match namebindings.def_for_namespace(ns) {\n+            Some(d) => {\n+                debug!(\"(computing exports) YES: export '{}' => {}\",\n+                       name, d.def_id());\n+                exports.push(Export {\n+                    name: name,\n+                    def_id: d.def_id()\n+                });\n+            }\n+            d_opt => {\n+                debug!(\"(computing exports) NO: {}\", d_opt);\n+            }\n+        }\n+    }\n+\n+    fn add_exports_for_module(&mut self,\n+                              exports: &mut Vec<Export>,\n+                              module_: &Module) {\n+        for (name, importresolution) in module_.import_resolutions.borrow().iter() {\n+            if !importresolution.is_public {\n+                continue\n+            }\n+            let xs = [TypeNS, ValueNS];\n+            for &ns in xs.iter() {\n+                match importresolution.target_for_namespace(ns) {\n+                    Some(target) => {\n+                        debug!(\"(computing exports) maybe export '{}'\",\n+                               token::get_name(*name));\n+                        self.add_exports_of_namebindings(exports,\n+                                                         *name,\n+                                                         &*target.bindings,\n+                                                         ns)\n+                    }\n+                    _ => ()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn record(resolver: &mut Resolver) {\n+    let mut recorder = ExportRecorder { resolver: resolver };\n+    let root_module = recorder.graph_root.get_module();\n+    recorder.record_exports_for_module_subtree(root_module);\n+}"}, {"sha": "2bcd723fc83a422f698574b5523d512f69576700", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -193,12 +193,11 @@ use llvm::{ValueRef, BasicBlockRef};\n use middle::check_match::StaticInliner;\n use middle::check_match;\n use middle::const_eval;\n-use middle::def;\n+use middle::def::{mod, DefMap};\n use middle::expr_use_visitor as euv;\n use middle::lang_items::StrEqFnLangItem;\n use middle::mem_categorization as mc;\n use middle::pat_util::*;\n-use middle::resolve::DefMap;\n use trans::adt;\n use trans::base::*;\n use trans::build::{AddCase, And, BitCast, Br, CondBr, GEPi, InBoundsGEP, Load};"}, {"sha": "b0ef2257a0a15739f3e88820d923230bb69d1867", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -2938,7 +2938,7 @@ pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'tcx>,\n     encoder::EncodeParams {\n         diag: cx.sess().diagnostic(),\n         tcx: cx.tcx(),\n-        reexports2: cx.exp_map2(),\n+        reexports: cx.export_map(),\n         item_symbols: cx.item_symbols(),\n         link_meta: cx.link_meta(),\n         cstore: &cx.sess().cstore,\n@@ -3071,7 +3071,7 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n \n pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n                          -> (ty::ctxt<'tcx>, CrateTranslation) {\n-    let ty::CrateAnalysis { ty_cx: tcx, exp_map2, reachable, name, .. } = analysis;\n+    let ty::CrateAnalysis { ty_cx: tcx, export_map, reachable, name, .. } = analysis;\n     let krate = tcx.map.krate();\n \n     // Before we touch LLVM, make sure that multithreading is enabled.\n@@ -3098,7 +3098,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let shared_ccx = SharedCrateContext::new(link_meta.crate_name.as_slice(),\n                                              codegen_units,\n                                              tcx,\n-                                             exp_map2,\n+                                             export_map,\n                                              Sha256::new(),\n                                              link_meta.clone(),\n                                              reachable);"}, {"sha": "7b962a939906fa5a7882caaec69de29975a00224", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -13,7 +13,7 @@ use llvm::{ContextRef, ModuleRef, ValueRef, BuilderRef};\n use llvm::{TargetData};\n use llvm::mk_target_data;\n use metadata::common::LinkMeta;\n-use middle::resolve;\n+use middle::def::ExportMap;\n use middle::traits;\n use trans::adt;\n use trans::base;\n@@ -61,7 +61,7 @@ pub struct SharedCrateContext<'tcx> {\n     metadata_llmod: ModuleRef,\n     metadata_llcx: ContextRef,\n \n-    exp_map2: resolve::ExportMap2,\n+    export_map: ExportMap,\n     reachable: NodeSet,\n     item_symbols: RefCell<NodeMap<String>>,\n     link_meta: LinkMeta,\n@@ -238,7 +238,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n     pub fn new(crate_name: &str,\n                local_count: uint,\n                tcx: ty::ctxt<'tcx>,\n-               emap2: resolve::ExportMap2,\n+               export_map: ExportMap,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet)\n@@ -251,7 +251,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             local_ccxs: Vec::with_capacity(local_count),\n             metadata_llmod: metadata_llmod,\n             metadata_llcx: metadata_llcx,\n-            exp_map2: emap2,\n+            export_map: export_map,\n             reachable: reachable,\n             item_symbols: RefCell::new(NodeMap::new()),\n             link_meta: link_meta,\n@@ -329,8 +329,8 @@ impl<'tcx> SharedCrateContext<'tcx> {\n         self.metadata_llcx\n     }\n \n-    pub fn exp_map2<'a>(&'a self) -> &'a resolve::ExportMap2 {\n-        &self.exp_map2\n+    pub fn export_map<'a>(&'a self) -> &'a ExportMap {\n+        &self.export_map\n     }\n \n     pub fn reachable<'a>(&'a self) -> &'a NodeSet {\n@@ -553,8 +553,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.item_vals\n     }\n \n-    pub fn exp_map2<'a>(&'a self) -> &'a resolve::ExportMap2 {\n-        &self.shared.exp_map2\n+    pub fn export_map<'a>(&'a self) -> &'a ExportMap {\n+        &self.shared.export_map\n     }\n \n     pub fn reachable<'a>(&'a self) -> &'a NodeSet {"}, {"sha": "ec0313d4d8fd0fe7d651e4154ffa1ecdfc5b36e4", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -90,7 +90,6 @@ pub use rustc::session;\n pub use rustc::util;\n \n use middle::def;\n-use middle::resolve;\n use middle::infer;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n@@ -121,7 +120,7 @@ struct TypeAndSubsts<'tcx> {\n \n struct CrateCtxt<'a, 'tcx: 'a> {\n     // A mapping from method call sites to traits that have that method.\n-    trait_map: resolve::TraitMap,\n+    trait_map: ty::TraitMap,\n     tcx: &'a ty::ctxt<'tcx>\n }\n \n@@ -316,7 +315,7 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt, trait_map: resolve::TraitMap) {\n+pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n         trait_map: trait_map,"}, {"sha": "ad4ed03e6e2c82386f09c1add758975a89ce71d5", "filename": "src/test/run-pass/issue-14254.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Ftest%2Frun-pass%2Fissue-14254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8443b09e361b96d1f9b7f45a65ed0d31c0e86e70/src%2Ftest%2Frun-pass%2Fissue-14254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14254.rs?ref=8443b09e361b96d1f9b7f45a65ed0d31c0e86e70", "patch": "@@ -24,7 +24,7 @@ impl BarTy {\n     fn b(&self) {}\n }\n \n-// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+// If these fail, it's necessary to update rustc_resolve and the cfail tests.\n impl Foo for *const BarTy {\n     fn bar(&self) {\n         self.baz();\n@@ -33,7 +33,7 @@ impl Foo for *const BarTy {\n     }\n }\n \n-// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+// If these fail, it's necessary to update rustc_resolve and the cfail tests.\n impl<'a> Foo for &'a BarTy {\n     fn bar(&self) {\n         self.baz();\n@@ -45,7 +45,7 @@ impl<'a> Foo for &'a BarTy {\n     }\n }\n \n-// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+// If these fail, it's necessary to update rustc_resolve and the cfail tests.\n impl<'a> Foo for &'a mut BarTy {\n     fn bar(&self) {\n         self.baz();\n@@ -57,39 +57,39 @@ impl<'a> Foo for &'a mut BarTy {\n     }\n }\n \n-// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+// If these fail, it's necessary to update rustc_resolve and the cfail tests.\n impl Foo for Box<BarTy> {\n     fn bar(&self) {\n         self.baz();\n         Foo::bah(None::<Box<BarTy>>);\n     }\n }\n \n-// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+// If these fail, it's necessary to update rustc_resolve and the cfail tests.\n impl Foo for *const int {\n     fn bar(&self) {\n         self.baz();\n         Foo::bah(None::<*const int>);\n     }\n }\n \n-// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+// If these fail, it's necessary to update rustc_resolve and the cfail tests.\n impl<'a> Foo for &'a int {\n     fn bar(&self) {\n         self.baz();\n         Foo::bah(None::<&int>);\n     }\n }\n \n-// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+// If these fail, it's necessary to update rustc_resolve and the cfail tests.\n impl<'a> Foo for &'a mut int {\n     fn bar(&self) {\n         self.baz();\n         Foo::bah(None::<&mut int>);\n     }\n }\n \n-// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+// If these fail, it's necessary to update rustc_resolve and the cfail tests.\n impl Foo for Box<int> {\n     fn bar(&self) {\n         self.baz();"}]}