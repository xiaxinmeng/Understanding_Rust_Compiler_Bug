{"sha": "a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZGQzZmUyZjIyNjZjMTBlZDBlM2JjMDdhMTY1YzJmMDk0ZTFjMWI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-21T18:08:10Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T14:44:48Z"}, "message": "librustc: Fix merge fallout.", "tree": {"sha": "c40e3c42b3798279c5dc1a38cba62f4a980e70a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c40e3c42b3798279c5dc1a38cba62f4a980e70a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "html_url": "https://github.com/rust-lang/rust/commit/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c9e9d35ac0f6469e0eeffc5c497f4b3ed6f1f8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c9e9d35ac0f6469e0eeffc5c497f4b3ed6f1f8a", "html_url": "https://github.com/rust-lang/rust/commit/3c9e9d35ac0f6469e0eeffc5c497f4b3ed6f1f8a"}], "stats": {"total": 229, "additions": 130, "deletions": 99}, "files": [{"sha": "c6550ec7c6e86a3d46a413a5313c8fab962a13be", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -122,7 +122,7 @@ impl Visitor<()> for Context {\n             }\n             ast::ViewItemExternMod(..) => {\n                 for attr in i.attrs.iter() {\n-                    if \"phase\" == attr.name() {\n+                    if attr.name().get() == \"phase\"{\n                         self.gate_feature(\"phase\", attr.span,\n                                           \"compile time crate loading is \\\n                                            experimental and possibly buggy\");"}, {"sha": "4eb36b0f3fbd128b0978303f8fe38a17d9bb1395", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -19,6 +19,8 @@ use syntax::codemap;\n use syntax::fold::Folder;\n use syntax::fold;\n use syntax::opt_vec;\n+use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::util::small_vector::SmallVector;\n \n pub static VERSION: &'static str = \"0.10-pre\";\n@@ -56,11 +58,13 @@ struct StandardLibraryInjector {\n     sess: Session,\n }\n \n-pub fn with_version(crate: &str) -> Option<(@str, ast::StrStyle)> {\n+pub fn with_version(crate: &str) -> Option<(InternedString, ast::StrStyle)> {\n     match option_env!(\"CFG_DISABLE_INJECT_STD_VERSION\") {\n         Some(\"1\") => None,\n         _ => {\n-            Some((format!(\"{}\\\\#{}\", crate, VERSION).to_managed(),\n+            Some((token::intern_and_get_ident(format!(\"{}\\\\#{}\",\n+                                                      crate,\n+                                                      VERSION)),\n                   ast::CookedStr))\n         }\n     }\n@@ -73,9 +77,12 @@ impl fold::Folder for StandardLibraryInjector {\n                                          with_version(\"std\"),\n                                          ast::DUMMY_NODE_ID),\n             attrs: ~[\n-                attr::mk_attr(attr::mk_list_item(@\"phase\",\n-                                                 ~[attr::mk_word_item(@\"syntax\"),\n-                                                   attr::mk_word_item(@\"link\")]))\n+                attr::mk_attr(attr::mk_list_item(\n+                        InternedString::new(\"phase\"),\n+                        ~[\n+                            attr::mk_word_item(InternedString::new(\"syntax\")),\n+                            attr::mk_word_item(InternedString::new(\"link\")\n+                        )]))\n             ],\n             vis: ast::Inherited,\n             span: DUMMY_SP"}, {"sha": "7ba96516bf91b14cc3b42b816ac63ee60da6326c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -235,7 +235,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n       0u => d::early_error(demitter, \"no input filename given\"),\n       1u => {\n         let ifile = matches.free[0].as_slice();\n-        if \"-\" == ifile {\n+        if ifile == \"-\" {\n             let src =\n                 str::from_utf8_owned(io::stdin().read_to_end()).unwrap();\n             (d::StrInput(src), None)"}, {"sha": "2a30ca51584e6d9345627f7f1837ecb6e3dc7cce", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -134,7 +134,7 @@ fn visit_crate(e: &Env, c: &ast::Crate) {\n \n fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n     let should_load = i.attrs.iter().all(|attr| {\n-        \"phase\" != attr.name() ||\n+        attr.name().get() != \"phase\" ||\n             attr.meta_item_list().map_or(false, |phases| {\n                 attr::contains_name(phases, \"link\")\n             })\n@@ -163,11 +163,11 @@ struct CrateInfo {\n \n fn extract_crate_info(i: &ast::ViewItem) -> Option<CrateInfo> {\n     match i.node {\n-        ast::ViewItemExternMod(ident, path_opt, id) => {\n-            let ident = token::ident_to_str(&ident);\n+        ast::ViewItemExternMod(ref ident, ref path_opt, id) => {\n+            let ident = token::ident_to_str(ident);\n             debug!(\"resolving extern mod stmt. ident: {:?} path_opt: {:?}\",\n                    ident, path_opt);\n-            let (name, version) = match path_opt {\n+            let (name, version) = match *path_opt {\n                 Some((ref path_str, _)) => {\n                     let crateid: Option<CrateId> = from_str(path_str.get());\n                     match crateid {"}, {"sha": "99577efb14d6e805269fed8bb682911eaf3793bf", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -76,21 +76,17 @@ use std::hashmap::HashMap;\n use std::libc::c_uint;\n use std::vec;\n use std::local_data;\n+use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n use syntax::ast_map::{PathName, PathPrettyName, path_elem_to_str};\n use syntax::ast_util::{local_def, is_local};\n-use syntax::attr;\n-use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n use syntax::attr::AttrMetaMethods;\n+use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::parse::token::{InternedString, special_idents};\n+use syntax::parse::token::InternedString;\n use syntax::parse::token;\n-use syntax::{ast, ast_util, ast_map};\n-use syntax::attr::AttrMetaMethods;\n-use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n-use syntax::visit;\n use syntax::visit::Visitor;\n use syntax::visit;\n-use syntax::{ast, ast_util, codemap, ast_map};\n+use syntax::{ast, ast_util, ast_map};\n \n pub use middle::trans::context::task_llcx;\n "}, {"sha": "a601b16e9b25b34a3b46dfebf4bd24bbac78ced3", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -25,7 +25,6 @@ use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n-use middle::trans::datum::immediate_rvalue;\n use middle::trans::expr;\n use middle::trans::machine::*;\n use middle::trans::reflect;"}, {"sha": "ea1e0f78f449f46ef8bd222a24824462f59b2b72", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -232,10 +232,10 @@ pub fn trans_slice_vstore<'a>(\n     match content_expr.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(s, _) => {\n+                ast::LitStr(ref s, _) => {\n                     return trans_lit_str(bcx,\n                                          content_expr,\n-                                         (*s).clone(),\n+                                         s.clone(),\n                                          dest)\n                 }\n                 _ => {}\n@@ -340,12 +340,12 @@ pub fn trans_uniq_or_managed_vstore<'a>(bcx: &'a Block<'a>,\n             match content_expr.node {\n                 ast::ExprLit(lit) => {\n                     match lit.node {\n-                        ast::LitStr(s, _) => {\n+                        ast::LitStr(ref s, _) => {\n                             let llptrval = C_cstr(bcx.ccx(), (*s).clone());\n                             let llptrval = PointerCast(bcx,\n                                                        llptrval,\n                                                        Type::i8p());\n-                            let llsizeval = C_uint(bcx.ccx(), s.len());\n+                            let llsizeval = C_uint(bcx.ccx(), s.get().len());\n                             let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n                             let lldestval = rvalue_scratch_datum(bcx,\n                                                                  typ,"}, {"sha": "6abafd5995c2facfe4983a3dd10b4be401e51aa5", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -1039,8 +1039,13 @@ pub enum ViewItemInner {\n impl Clean<ViewItemInner> for ast::ViewItem_ {\n     fn clean(&self) -> ViewItemInner {\n         match self {\n-            &ast::ViewItemExternMod(ref i, ref p, ref id) =>\n-                ExternMod(i.clean(), p.map(|(ref x, _)| x.to_owned()), *id),\n+            &ast::ViewItemExternMod(ref i, ref p, ref id) => {\n+                let string = match *p {\n+                    None => None,\n+                    Some((ref x, _)) => Some(x.get().to_owned()),\n+                };\n+                ExternMod(i.clean(), string, *id)\n+            }\n             &ast::ViewItemUse(ref vp) => Import(vp.clean())\n         }\n     }"}, {"sha": "ba31699a7d04e54450f894edc3d02e965b630e78", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -472,13 +472,14 @@ impl<'a> CrateInstaller<'a> {\n \n         match vi.node {\n             // ignore metadata, I guess\n-            ast::ViewItemExternMod(lib_ident, path_opt, _) => {\n-                let lib_name = match path_opt {\n-                    Some((p, _)) => p,\n-                    None => self.sess.str_of(lib_ident)\n+            ast::ViewItemExternMod(ref lib_ident, ref path_opt, _) => {\n+                let lib_name = match *path_opt {\n+                    Some((ref p, _)) => (*p).clone(),\n+                    None => token::get_ident(lib_ident.name),\n                 };\n                 debug!(\"Finding and installing... {}\", lib_name);\n-                let crate_id: CrateId = from_str(lib_name).expect(\"valid crate id\");\n+                let crate_id: CrateId =\n+                    from_str(lib_name.get()).expect(\"valid crate id\");\n                 // Check standard Rust library path first\n                 let whatever = system_library(&self.context.sysroot_to_use(), &crate_id);\n                 debug!(\"system library returned {:?}\", whatever);"}, {"sha": "5df2a9010b1aa7d9e5f8c2ca2df62d1d2df7b8b4", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -16,7 +16,7 @@ use ext;\n use ext::expand;\n use parse;\n use parse::token;\n-use parse::token::{InternedString, ident_to_str, intern, str_to_ident};\n+use parse::token::{InternedString, intern, str_to_ident};\n use util::small_vector::SmallVector;\n \n use std::hashmap::HashMap;\n@@ -396,9 +396,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn set_trace_macros(&mut self, x: bool) {\n         self.trace_mac = x\n     }\n-    pub fn str_of(&self, id: ast::Ident) -> @str {\n-        ident_to_str(&id)\n-    }\n     pub fn ident_of(&self, st: &str) -> ast::Ident {\n         str_to_ident(st)\n     }\n@@ -411,7 +408,7 @@ pub fn expr_to_str(cx: &ExtCtxt, expr: @ast::Expr, err_msg: &str)\n                    -> Option<(InternedString, ast::StrStyle)> {\n     match expr.node {\n         ast::ExprLit(l) => match l.node {\n-            ast::LitStr(s, style) => return Some(((*s).clone(), style)),\n+            ast::LitStr(ref s, style) => return Some(((*s).clone(), style)),\n             _ => cx.span_err(l.span, err_msg)\n         },\n         _ => cx.span_err(expr.span, err_msg)\n@@ -446,7 +443,8 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n         match tts[0] {\n             ast::TTTok(_, token::LIT_STR(ident))\n             | ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => {\n-                return Some(cx.str_of(ident).to_str())\n+                let interned_str = token::get_ident(ident.name);\n+                return Some(interned_str.get().to_str())\n             }\n             _ => cx.span_err(sp, format!(\"{} requires a string.\", name)),\n         }"}, {"sha": "e0d53add6489fec9e6ced7165996504061b46723", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -30,7 +30,10 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             }\n         } else {\n             match *e {\n-                ast::TTTok(_, token::IDENT(ident,_)) => res_str.push_str(cx.str_of(ident)),\n+                ast::TTTok(_, token::IDENT(ident,_)) => {\n+                    let interned_str = token::get_ident(ident.name);\n+                    res_str.push_str(interned_str.get())\n+                }\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");\n                     return MacResult::dummy_expr();"}, {"sha": "c50c9f18389c2ff897b979f861b0b0c16687ebd6", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -133,7 +133,7 @@ fn encodable_substructure(cx: &ExtCtxt, trait_span: Span,\n                     ..\n                 }) in fields.iter().enumerate() {\n                 let name = match name {\n-                    Some(id) => token::get_ident(id),\n+                    Some(id) => token::get_ident(id.name),\n                     None => {\n                         token::intern_and_get_ident(format!(\"_field{}\", i))\n                     }\n@@ -181,7 +181,7 @@ fn encodable_substructure(cx: &ExtCtxt, trait_span: Span,\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n             let name = cx.expr_str(trait_span,\n-                                   token::get_ident(variant.node.name));\n+                                   token::get_ident(variant.node.name.name));\n             let call = cx.expr_method_call(trait_span, blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n                                            ~[name,"}, {"sha": "6101d647ca5dd9beed219375ecb0a3623760b211", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -61,7 +61,9 @@ fn to_str_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure)\n             cx.expr_str_uniq(span, token::get_ident(name.name))\n         } else {\n             let buf = cx.ident_of(\"buf\");\n-            let start = token::intern_and_get_ident(cx.str_of(name) + start);\n+            let interned_str = token::get_ident(name.name);\n+            let start =\n+                token::intern_and_get_ident(interned_str.get() + start);\n             let init = cx.expr_str_uniq(span, start);\n             let mut stmts = ~[cx.stmt_let(span, true, buf, init)];\n             let push_str = cx.ident_of(\"push_str\");\n@@ -79,7 +81,8 @@ fn to_str_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure)\n                 match name {\n                     None => {}\n                     Some(id) => {\n-                        let name = cx.str_of(id) + \": \";\n+                        let interned_id = token::get_ident(id.name);\n+                        let name = interned_id.get() + \": \";\n                         push(cx.expr_str(span,\n                                          token::intern_and_get_ident(name)));\n                     }"}, {"sha": "c166240e2043d9aac93a72a3079e38607ea9c1a7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -385,7 +385,7 @@ pub fn expand_view_item(vi: &ast::ViewItem,\n                         fld: &mut MacroExpander)\n                         -> ast::ViewItem {\n     let should_load = vi.attrs.iter().any(|attr| {\n-        \"phase\" == attr.name() &&\n+        attr.name().get() == \"phase\" &&\n             attr.meta_item_list().map_or(false, |phases| {\n                 attr::contains_name(phases, \"syntax\")\n             })\n@@ -405,12 +405,12 @@ fn load_extern_macros(crate: &ast::ViewItem, fld: &mut MacroExpander) {\n         ast::ViewItemExternMod(ref name, _, _) => token::ident_to_str(name),\n         _ => unreachable!(),\n     };\n-    let name = format!(\"<{} macros>\", crate_name).to_managed();\n+    let name = format!(\"<{} macros>\", crate_name);\n \n     let exported_macros = fld.cx.loader.get_exported_macros(cnum);\n     for source in exported_macros.iter() {\n-        let item = parse::parse_item_from_source_str(name,\n-                                                     source.to_managed(),\n+        let item = parse::parse_item_from_source_str(name.clone(),\n+                                                     (*source).clone(),\n                                                      fld.cx.cfg(),\n                                                      fld.cx.parse_sess())\n                 .expect(\"expected a serialized item\");"}, {"sha": "ba1d5efdd49cd5a8ca787859217eb28fbb975460", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 58, "deletions": 44, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -24,14 +24,14 @@ use std::vec;\n \n #[deriving(Eq)]\n enum ArgumentType {\n-    Known(@str),\n+    Known(~str),\n     Unsigned,\n     String,\n }\n \n enum Position {\n     Exact(uint),\n-    Named(@str),\n+    Named(~str),\n }\n \n struct Context<'a> {\n@@ -43,12 +43,12 @@ struct Context<'a> {\n     args: ~[@ast::Expr],\n     arg_types: ~[Option<ArgumentType>],\n     // Parsed named expressions and the types that we've found for them so far\n-    names: HashMap<@str, @ast::Expr>,\n-    name_types: HashMap<@str, ArgumentType>,\n+    names: HashMap<~str, @ast::Expr>,\n+    name_types: HashMap<~str, ArgumentType>,\n \n     // Collection of the compiled `rt::Piece` structures\n     pieces: ~[@ast::Expr],\n-    name_positions: HashMap<@str, uint>,\n+    name_positions: HashMap<~str, uint>,\n     method_statics: ~[@ast::Item],\n \n     // Updated as arguments are consumed or methods are entered\n@@ -105,10 +105,11 @@ impl<'a> Context<'a> {\n                         return (extra, None);\n                     }\n                 };\n-                let name = self.ecx.str_of(ident);\n+                let interned_name = token::get_ident(ident.name);\n+                let name = interned_name.get();\n                 p.expect(&token::EQ);\n                 let e = p.parse_expr();\n-                match self.names.find(&name) {\n+                match self.names.find_equiv(&name) {\n                     None => {}\n                     Some(prev) => {\n                         self.ecx.span_err(e.span, format!(\"duplicate argument \\\n@@ -118,7 +119,7 @@ impl<'a> Context<'a> {\n                         continue\n                     }\n                 }\n-                self.names.insert(name, e);\n+                self.names.insert(name.to_str(), e);\n             } else {\n                 self.args.push(p.parse_expr());\n                 self.arg_types.push(None);\n@@ -157,13 +158,13 @@ impl<'a> Context<'a> {\n                         Exact(i)\n                     }\n                     parse::ArgumentIs(i) => Exact(i),\n-                    parse::ArgumentNamed(s) => Named(s.to_managed()),\n+                    parse::ArgumentNamed(s) => Named(s.to_str()),\n                 };\n \n                 // and finally the method being applied\n                 match arg.method {\n                     None => {\n-                        let ty = Known(arg.format.ty.to_managed());\n+                        let ty = Known(arg.format.ty.to_str());\n                         self.verify_arg_type(pos, ty);\n                     }\n                     Some(ref method) => { self.verify_method(pos, *method); }\n@@ -185,7 +186,7 @@ impl<'a> Context<'a> {\n                 self.verify_arg_type(Exact(i), Unsigned);\n             }\n             parse::CountIsName(s) => {\n-                self.verify_arg_type(Named(s.to_managed()), Unsigned);\n+                self.verify_arg_type(Named(s.to_str()), Unsigned);\n             }\n             parse::CountIsNextParam => {\n                 if self.check_positional_ok() {\n@@ -260,7 +261,13 @@ impl<'a> Context<'a> {\n                     self.ecx.span_err(self.fmtsp, msg);\n                     return;\n                 }\n-                self.verify_same(self.args[arg].span, ty, self.arg_types[arg]);\n+                {\n+                    let arg_type = match self.arg_types[arg] {\n+                        None => None,\n+                        Some(ref x) => Some(x)\n+                    };\n+                    self.verify_same(self.args[arg].span, &ty, arg_type);\n+                }\n                 if self.arg_types[arg].is_none() {\n                     self.arg_types[arg] = Some(ty);\n                 }\n@@ -275,10 +282,9 @@ impl<'a> Context<'a> {\n                         return;\n                     }\n                 };\n-                self.verify_same(span, ty,\n-                                 self.name_types.find(&name).map(|&x| x));\n+                self.verify_same(span, &ty, self.name_types.find(&name));\n                 if !self.name_types.contains_key(&name) {\n-                    self.name_types.insert(name, ty);\n+                    self.name_types.insert(name.clone(), ty);\n                 }\n                 // Assign this named argument a slot in the arguments array if\n                 // it hasn't already been assigned a slot.\n@@ -298,30 +304,36 @@ impl<'a> Context<'a> {\n     ///\n     /// Obviously `Some(Some(x)) != Some(Some(y))`, but we consider it true\n     /// that: `Some(None) == Some(Some(x))`\n-    fn verify_same(&self, sp: Span, ty: ArgumentType,\n-                   before: Option<ArgumentType>) {\n+    fn verify_same(&self,\n+                   sp: Span,\n+                   ty: &ArgumentType,\n+                   before: Option<&ArgumentType>) {\n         let cur = match before {\n             None => return,\n             Some(t) => t,\n         };\n-        if ty == cur { return }\n+        if *ty == *cur {\n+            return\n+        }\n         match (cur, ty) {\n-            (Known(cur), Known(ty)) => {\n+            (&Known(ref cur), &Known(ref ty)) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument redeclared with type `{}` when \\\n-                                           it was previously `{}`\", ty, cur));\n+                                           it was previously `{}`\",\n+                                          *ty,\n+                                          *cur));\n             }\n-            (Known(cur), _) => {\n+            (&Known(ref cur), _) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument used to format with `{}` was \\\n                                            attempted to not be used for formatting\",\n-                                           cur));\n+                                           *cur));\n             }\n-            (_, Known(ty)) => {\n+            (_, &Known(ref ty)) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument previously used as a format \\\n                                            argument attempted to be used as `{}`\",\n-                                           ty));\n+                                           *ty));\n             }\n             (_, _) => {\n                 self.ecx.span_err(sp, \"argument declared with multiple formats\");\n@@ -397,9 +409,8 @@ impl<'a> Context<'a> {\n                     self.ecx.expr_path(path)\n                 }\n                 parse::CountIsName(n) => {\n-                    let n = n.to_managed();\n-                    let i = match self.name_positions.find_copy(&n) {\n-                        Some(i) => i,\n+                    let i = match self.name_positions.find_equiv(&n) {\n+                        Some(&i) => i,\n                         None => 0, // error already emitted elsewhere\n                     };\n                     let i = i + self.args.len();\n@@ -519,9 +530,8 @@ impl<'a> Context<'a> {\n                     // Named arguments are converted to positional arguments at\n                     // the end of the list of arguments\n                     parse::ArgumentNamed(n) => {\n-                        let n = n.to_managed();\n-                        let i = match self.name_positions.find_copy(&n) {\n-                            Some(i) => i,\n+                        let i = match self.name_positions.find_equiv(&n) {\n+                            Some(&i) => i,\n                             None => 0, // error already emitted elsewhere\n                         };\n                         let i = i + self.args.len();\n@@ -633,14 +643,17 @@ impl<'a> Context<'a> {\n             locals.push(self.format_arg(e.span, Exact(i),\n                                         self.ecx.expr_ident(e.span, name)));\n         }\n-        for (&name, &e) in self.names.iter() {\n-            if !self.name_types.contains_key(&name) { continue }\n+        for (name, &e) in self.names.iter() {\n+            if !self.name_types.contains_key(name) {\n+                continue\n+            }\n \n-            let lname = self.ecx.ident_of(format!(\"__arg{}\", name));\n+            let lname = self.ecx.ident_of(format!(\"__arg{}\", *name));\n             let e = self.ecx.expr_addr_of(e.span, e);\n             lets.push(self.ecx.stmt_let(e.span, false, lname, e));\n-            names[*self.name_positions.get(&name)] =\n-                Some(self.format_arg(e.span, Named(name),\n+            names[*self.name_positions.get(name)] =\n+                Some(self.format_arg(e.span,\n+                                     Named((*name).clone()),\n                                      self.ecx.expr_ident(e.span, lname)));\n         }\n \n@@ -682,16 +695,16 @@ impl<'a> Context<'a> {\n                                            Some(result)))\n     }\n \n-    fn format_arg(&self, sp: Span, argno: Position,\n-                  arg: @ast::Expr) -> @ast::Expr {\n+    fn format_arg(&self, sp: Span, argno: Position, arg: @ast::Expr)\n+                  -> @ast::Expr {\n         let ty = match argno {\n-            Exact(i) => self.arg_types[i].unwrap(),\n-            Named(s) => *self.name_types.get(&s)\n+            Exact(ref i) => self.arg_types[*i].get_ref(),\n+            Named(ref s) => self.name_types.get(s)\n         };\n \n-        let fmt_trait = match ty {\n-            Known(tyname) => {\n-                match tyname.as_slice() {\n+        let fmt_trait = match *ty {\n+            Known(ref tyname) => {\n+                match (*tyname).as_slice() {\n                     \"\"  => \"Default\",\n                     \"?\" => \"Poly\",\n                     \"b\" => \"Bool\",\n@@ -708,8 +721,9 @@ impl<'a> Context<'a> {\n                     \"x\" => \"LowerHex\",\n                     \"X\" => \"UpperHex\",\n                     _ => {\n-                        self.ecx.span_err(sp, format!(\"unknown format trait \\\n-                                                       `{}`\", tyname));\n+                        self.ecx.span_err(sp,\n+                                          format!(\"unknown format trait `{}`\",\n+                                                  *tyname));\n                         \"Dummy\"\n                     }\n                 }"}, {"sha": "44f3bb379f63e68267bfd751226d40cc2757a81a", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -71,7 +71,12 @@ pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n-    let string = cx.mod_path().map(|x| cx.str_of(*x)).connect(\"::\");\n+    let string = cx.mod_path()\n+                   .map(|x| {\n+                        let interned_str = token::get_ident(x.name);\n+                        interned_str.get().to_str()\n+                    })\n+                   .connect(\"::\");\n     base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(string)))\n }\n "}, {"sha": "97981f87393c52e3a7eb2ec807b0eec454aa187f", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -23,6 +23,7 @@ use parse::parser::Parser;\n use parse::attr::ParserAttr;\n use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_str};\n use parse::token::{FAT_ARROW, SEMI, NtMatchers, NtTT, EOF};\n+use parse::token;\n use print;\n use std::cell::RefCell;\n use util::small_vector::SmallVector;\n@@ -112,10 +113,11 @@ fn generic_extension(cx: &ExtCtxt,\n                      rhses: &[@NamedMatch])\n                      -> MacResult {\n     if cx.trace_macros() {\n+        let interned_name = token::get_ident(name.name);\n         println!(\"{}! \\\\{ {} \\\\}\",\n-                  cx.str_of(name),\n-                  print::pprust::tt_to_str(&TTDelim(@arg.to_owned()),\n-                                           get_ident_interner()));\n+                 interned_name.get(),\n+                 print::pprust::tt_to_str(&TTDelim(@arg.to_owned()),\n+                                          get_ident_interner()));\n     }\n \n     // Which arm's failure should we report? (the one furthest along)"}, {"sha": "6e1b2044657e64decc16ec7fbed5ade478b94264", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a4dd3fe2f2266c10ed0e3bc07a165c2f094e1c1b", "patch": "@@ -497,12 +497,10 @@ fn fold_variant_arg_<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {\n pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n                                        -> ViewItem{\n     let inner_view_item = match vi.node {\n-        ViewItemExternMod(ref ident,\n-                             string,\n-                             node_id) => {\n+        ViewItemExternMod(ref ident, ref string, node_id) => {\n             ViewItemExternMod(ident.clone(),\n-                                 string,\n-                                 folder.new_id(node_id))\n+                              (*string).clone(),\n+                              folder.new_id(node_id))\n         }\n         ViewItemUse(ref view_paths) => {\n             ViewItemUse(folder.fold_view_paths(*view_paths))"}]}