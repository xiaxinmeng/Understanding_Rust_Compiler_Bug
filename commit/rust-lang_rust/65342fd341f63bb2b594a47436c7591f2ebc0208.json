{"sha": "65342fd341f63bb2b594a47436c7591f2ebc0208", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MzQyZmQzNDFmNjNiYjJiNTk0YTQ3NDM2Yzc1OTFmMmViYzAyMDg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-02T22:55:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-02T22:55:52Z"}, "message": "Rollup merge of #73724 - CryZe:wasm-saturating-casts, r=alexcrichton\n\nUse WASM's saturating casts if they are available\n\nWebAssembly supports saturating floating point to integer casts behind a target feature. The feature is already available on many browsers. Beginning with 1.45 Rust will start defining the behavior of floating point to integer casts to be saturating as well. For this Rust constructs additional checks on top of the `fptoui` / `fptosi` instructions it emits. Here we introduce the possibility for the codegen backend to construct saturating casts itself and only fall back to constructing the checks ourselves if that is not possible.\n\nResolves part of #73591", "tree": {"sha": "4d2dc15d466ea51888fa4c43c6b1b096e7379486", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d2dc15d466ea51888fa4c43c6b1b096e7379486"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65342fd341f63bb2b594a47436c7591f2ebc0208", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/mX4CRBK7hj4Ov3rIwAAdHIIAHN+l/7R55mqbsLzeupttfLK\nCD3vfj/BSV6+6MjCyvUEm58KGnmJIaVbT7l+sALm2mDNgZHiPLKdlXAAX3Hvi/67\npbCZRsnH7BP4M/CO1wbaEXzIEQonaTftTNsMdemv9s1CMln8L+ihowuyYUfKF8fp\ndGh5r/hu+B40rQPcMiHY6U5zCKOvjuzGGn0WsUs/I04w74VDAIfneffWgANtoS9y\n5267UpNGWgfuFKZEQCrbTeN/xQButvF/sOtifETmurSRBDw5UPOvoGaGiYrDOqw3\n1v0C73fKbKOzByJ0n4e1/rqtDLPdAdy/SEGNIROdd/cHKZlaIwg5YkgEONgac2E=\n=njuO\n-----END PGP SIGNATURE-----\n", "payload": "tree 4d2dc15d466ea51888fa4c43c6b1b096e7379486\nparent dc6a19c2f0a527826e6704e0ee7bfe7f2d7d7864\nparent 838c497a4578bb4c939e9834240198e22815ad1b\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593730552 -0700\ncommitter GitHub <noreply@github.com> 1593730552 -0700\n\nRollup merge of #73724 - CryZe:wasm-saturating-casts, r=alexcrichton\n\nUse WASM's saturating casts if they are available\n\nWebAssembly supports saturating floating point to integer casts behind a target feature. The feature is already available on many browsers. Beginning with 1.45 Rust will start defining the behavior of floating point to integer casts to be saturating as well. For this Rust constructs additional checks on top of the `fptoui` / `fptosi` instructions it emits. Here we introduce the possibility for the codegen backend to construct saturating casts itself and only fall back to constructing the checks ourselves if that is not possible.\n\nResolves part of #73591\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65342fd341f63bb2b594a47436c7591f2ebc0208", "html_url": "https://github.com/rust-lang/rust/commit/65342fd341f63bb2b594a47436c7591f2ebc0208", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65342fd341f63bb2b594a47436c7591f2ebc0208/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc6a19c2f0a527826e6704e0ee7bfe7f2d7d7864", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc6a19c2f0a527826e6704e0ee7bfe7f2d7d7864", "html_url": "https://github.com/rust-lang/rust/commit/dc6a19c2f0a527826e6704e0ee7bfe7f2d7d7864"}, {"sha": "838c497a4578bb4c939e9834240198e22815ad1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/838c497a4578bb4c939e9834240198e22815ad1b", "html_url": "https://github.com/rust-lang/rust/commit/838c497a4578bb4c939e9834240198e22815ad1b"}], "stats": {"total": 1439, "additions": 932, "deletions": 507}, "files": [{"sha": "6775baa8c3273e7ef7a7b2a3a35c62a8d05c4eb3", "filename": "src/ci/docker/test-various/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -17,7 +17,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   wget \\\n   patch\n \n-RUN curl -sL https://nodejs.org/dist/v9.2.0/node-v9.2.0-linux-x64.tar.xz | \\\n+RUN curl -sL https://nodejs.org/dist/v14.4.0/node-v14.4.0-linux-x64.tar.xz | \\\n   tar -xJ\n \n WORKDIR /build/\n@@ -30,7 +30,7 @@ RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n   --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n-  --set build.nodejs=/node-v9.2.0-linux-x64/bin/node \\\n+  --set build.nodejs=/node-v14.4.0-linux-x64/bin/node \\\n   --set rust.lld\n \n # Some run-make tests have assertions about code size, and enabling debug"}, {"sha": "89b70dce52c661c8c571f0929d306f846378c3bd", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -18,6 +18,7 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::sym;\n use rustc_target::abi::{self, Align, Size};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n@@ -652,6 +653,56 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, UNNAMED) }\n     }\n \n+    fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n+        // WebAssembly has saturating floating point to integer casts if the\n+        // `nontrapping-fptoint` target feature is activated. We'll use those if\n+        // they are available.\n+        if self.sess().target.target.arch == \"wasm32\"\n+            && self.sess().target_features.contains(&sym::nontrapping_fptoint)\n+        {\n+            let src_ty = self.cx.val_ty(val);\n+            let float_width = self.cx.float_width(src_ty);\n+            let int_width = self.cx.int_width(dest_ty);\n+            let name = match (int_width, float_width) {\n+                (32, 32) => Some(\"llvm.wasm.trunc.saturate.unsigned.i32.f32\"),\n+                (32, 64) => Some(\"llvm.wasm.trunc.saturate.unsigned.i32.f64\"),\n+                (64, 32) => Some(\"llvm.wasm.trunc.saturate.unsigned.i64.f32\"),\n+                (64, 64) => Some(\"llvm.wasm.trunc.saturate.unsigned.i64.f64\"),\n+                _ => None,\n+            };\n+            if let Some(name) = name {\n+                let intrinsic = self.get_intrinsic(name);\n+                return Some(self.call(intrinsic, &[val], None));\n+            }\n+        }\n+        None\n+    }\n+\n+    fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n+        // WebAssembly has saturating floating point to integer casts if the\n+        // `nontrapping-fptoint` target feature is activated. We'll use those if\n+        // they are available.\n+        if self.sess().target.target.arch == \"wasm32\"\n+            && self.sess().target_features.contains(&sym::nontrapping_fptoint)\n+        {\n+            let src_ty = self.cx.val_ty(val);\n+            let float_width = self.cx.float_width(src_ty);\n+            let int_width = self.cx.int_width(dest_ty);\n+            let name = match (int_width, float_width) {\n+                (32, 32) => Some(\"llvm.wasm.trunc.saturate.signed.i32.f32\"),\n+                (32, 64) => Some(\"llvm.wasm.trunc.saturate.signed.i32.f64\"),\n+                (64, 32) => Some(\"llvm.wasm.trunc.saturate.signed.i64.f32\"),\n+                (64, 64) => Some(\"llvm.wasm.trunc.saturate.signed.i64.f64\"),\n+                _ => None,\n+            };\n+            if let Some(name) = name {\n+                let intrinsic = self.get_intrinsic(name);\n+                return Some(self.call(intrinsic, &[val], None));\n+            }\n+        }\n+        None\n+    }\n+\n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe { llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, UNNAMED) }\n     }"}, {"sha": "d484e15eb2f6e0944ec119192322be79626f8c2b", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -497,6 +497,15 @@ impl CodegenCx<'b, 'tcx> {\n             t_v8f64: t_f64, 8;\n         }\n \n+        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i64.f64\", fn(t_f64) -> t_i64);\n+        ifn!(\"llvm.wasm.trunc.saturate.signed.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.saturate.signed.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f64\", fn(t_f64) -> t_i64);\n+\n         ifn!(\"llvm.trap\", fn() -> void);\n         ifn!(\"llvm.debugtrap\", fn() -> void);\n         ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);"}, {"sha": "2e2ce1544109aa1dead3eae7f6f44a78a042ac54", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -250,8 +250,11 @@ const RISCV_WHITELIST: &[(&str, Option<Symbol>)] = &[\n     (\"e\", Some(sym::riscv_target_feature)),\n ];\n \n-const WASM_WHITELIST: &[(&str, Option<Symbol>)] =\n-    &[(\"simd128\", Some(sym::wasm_target_feature)), (\"atomics\", Some(sym::wasm_target_feature))];\n+const WASM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"simd128\", Some(sym::wasm_target_feature)),\n+    (\"atomics\", Some(sym::wasm_target_feature)),\n+    (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n+];\n \n /// When rustdoc is running, provide a list of all known features so that all their respective\n /// primitives may be documented."}, {"sha": "4b2be7b5321ff8aec4cc808b133461cd6c3f88c9", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -774,12 +774,17 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     float_ty: Bx::Type,\n     int_ty: Bx::Type,\n ) -> Bx::Value {\n-    let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n-\n     if let Some(false) = bx.cx().sess().opts.debugging_opts.saturating_float_casts {\n-        return fptosui_result;\n+        return if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n+    }\n+\n+    let try_sat_result = if signed { bx.fptosi_sat(x, int_ty) } else { bx.fptoui_sat(x, int_ty) };\n+    if let Some(try_sat_result) = try_sat_result {\n+        return try_sat_result;\n     }\n \n+    let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n+\n     let int_width = bx.cx().int_width(int_ty);\n     let float_width = bx.cx().float_width(float_ty);\n     // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the"}, {"sha": "65eb70e173e2cb0ccac0647fcc5b149462630473", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -158,6 +158,8 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn trunc(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn sext(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn fptoui_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n+    fn fptosi_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n     fn fptoui(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptosi(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn uitofp(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;"}, {"sha": "12ac2ed1c0b1914b6be74c21dc1bd26c58fda732", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -517,6 +517,7 @@ symbols! {\n         None,\n         non_exhaustive,\n         non_modrs_mods,\n+        nontrapping_fptoint: \"nontrapping-fptoint\",\n         noreturn,\n         no_niche,\n         no_sanitize,"}, {"sha": "bd6073d8c204a7eb0b099a8ae792f5478f0eb746", "filename": "src/test/codegen/wasm_casts_nontrapping.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Ftest%2Fcodegen%2Fwasm_casts_nontrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Ftest%2Fcodegen%2Fwasm_casts_nontrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fwasm_casts_nontrapping.rs?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -0,0 +1,162 @@\n+// only-wasm32\n+// compile-flags: -C target-feature=+nontrapping-fptoint\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @cast_f64_i64\n+#[no_mangle]\n+pub fn cast_f64_i64(a: f64) -> i64 {\n+    // CHECK: tail call i64 @llvm.wasm.trunc.saturate.signed.i64.f64(double {{.*}})\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f64_i32\n+#[no_mangle]\n+pub fn cast_f64_i32(a: f64) -> i32 {\n+    // CHECK: tail call i32 @llvm.wasm.trunc.saturate.signed.i32.f64(double {{.*}})\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f32_i64\n+#[no_mangle]\n+pub fn cast_f32_i64(a: f32) -> i64 {\n+    // CHECK: tail call i64 @llvm.wasm.trunc.saturate.signed.i64.f32(float {{.*}})\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f32_i32\n+#[no_mangle]\n+pub fn cast_f32_i32(a: f32) -> i32 {\n+    // CHECK: tail call i32 @llvm.wasm.trunc.saturate.signed.i32.f32(float {{.*}})\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a as _\n+}\n+\n+\n+// CHECK-LABEL: @cast_f64_u64\n+#[no_mangle]\n+pub fn cast_f64_u64(a: f64) -> u64 {\n+    // CHECK: tail call i64 @llvm.wasm.trunc.saturate.unsigned.i64.f64(double {{.*}})\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f64_u32\n+#[no_mangle]\n+pub fn cast_f64_u32(a: f64) -> u32 {\n+    // CHECK: tail call i32 @llvm.wasm.trunc.saturate.unsigned.i32.f64(double {{.*}})\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f32_u64\n+#[no_mangle]\n+pub fn cast_f32_u64(a: f32) -> u64 {\n+    // CHECK: tail call i64 @llvm.wasm.trunc.saturate.unsigned.i64.f32(float {{.*}})\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f32_u32\n+#[no_mangle]\n+pub fn cast_f32_u32(a: f32) -> u32 {\n+    // CHECK: tail call i32 @llvm.wasm.trunc.saturate.unsigned.i32.f32(float {{.*}})\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f32_u8\n+#[no_mangle]\n+pub fn cast_f32_u8(a: f32) -> u8 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui float {{.*}} to i8\n+    // CHECK-NEXT: select i1 {{.*}}, i8 {{.*}}, i8 {{.*}}\n+    // CHECK-NEXT: ret i8 {{.*}}\n+    a as _\n+}\n+\n+\n+\n+// CHECK-LABEL: @cast_unchecked_f64_i64\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f64_i64(a: f64) -> i64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi double {{.*}} to i64\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f64_i32\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f64_i32(a: f64) -> i32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi double {{.*}} to i32\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f32_i64\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f32_i64(a: f32) -> i64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi float {{.*}} to i64\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f32_i32\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f32_i32(a: f32) -> i32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi float {{.*}} to i32\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+\n+// CHECK-LABEL: @cast_unchecked_f64_u64\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f64_u64(a: f64) -> u64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui double {{.*}} to i64\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f64_u32\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f64_u32(a: f64) -> u32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui double {{.*}} to i32\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f32_u64\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f32_u64(a: f32) -> u64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui float {{.*}} to i64\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f32_u32\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f32_u32(a: f32) -> u32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui float {{.*}} to i32\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f32_u8\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f32_u8(a: f32) -> u8 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui float {{.*}} to i8\n+    // CHECK-NEXT: ret i8 {{.*}}\n+    a.to_int_unchecked()\n+}"}, {"sha": "45b905190493a12151704411e8b8955842f16d1b", "filename": "src/test/codegen/wasm_casts_trapping.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -0,0 +1,169 @@\n+// only-wasm32\n+// compile-flags: -C target-feature=-nontrapping-fptoint\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @cast_f64_i64\n+#[no_mangle]\n+pub fn cast_f64_i64(a: f64) -> i64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi double {{.*}} to i64\n+    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f64_i32\n+#[no_mangle]\n+pub fn cast_f64_i32(a: f64) -> i32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi double {{.*}} to i32\n+    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f32_i64\n+#[no_mangle]\n+pub fn cast_f32_i64(a: f32) -> i64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi float {{.*}} to i64\n+    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f32_i32\n+#[no_mangle]\n+pub fn cast_f32_i32(a: f32) -> i32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi float {{.*}} to i32\n+    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    a as _\n+}\n+\n+\n+// CHECK-LABEL: @cast_f64_u64\n+#[no_mangle]\n+pub fn cast_f64_u64(a: f64) -> u64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui double {{.*}} to i64\n+    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f64_u32\n+#[no_mangle]\n+pub fn cast_f64_u32(a: f64) -> u32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui double {{.*}} to i32\n+    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f32_u64\n+#[no_mangle]\n+pub fn cast_f32_u64(a: f32) -> u64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui float {{.*}} to i64\n+    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f32_u32\n+#[no_mangle]\n+pub fn cast_f32_u32(a: f32) -> u32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui float {{.*}} to i32\n+    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    a as _\n+}\n+\n+// CHECK-LABEL: @cast_f32_u8\n+#[no_mangle]\n+pub fn cast_f32_u8(a: f32) -> u8 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui float {{.*}} to i8\n+    // CHECK-NEXT: select i1 {{.*}}, i8 {{.*}}, i8 {{.*}}\n+    a as _\n+}\n+\n+\n+\n+// CHECK-LABEL: @cast_unchecked_f64_i64\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f64_i64(a: f64) -> i64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi double {{.*}} to i64\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f64_i32\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f64_i32(a: f64) -> i32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi double {{.*}} to i32\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f32_i64\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f32_i64(a: f32) -> i64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi float {{.*}} to i64\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f32_i32\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f32_i32(a: f32) -> i32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptosi float {{.*}} to i32\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+\n+// CHECK-LABEL: @cast_unchecked_f64_u64\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f64_u64(a: f64) -> u64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui double {{.*}} to i64\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f64_u32\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f64_u32(a: f64) -> u32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui double {{.*}} to i32\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f32_u64\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f32_u64(a: f32) -> u64 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui float {{.*}} to i64\n+    // CHECK-NEXT: ret i64 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f32_u32\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f32_u32(a: f32) -> u32 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui float {{.*}} to i32\n+    // CHECK-NEXT: ret i32 {{.*}}\n+    a.to_int_unchecked()\n+}\n+\n+// CHECK-LABEL: @cast_unchecked_f32_u8\n+#[no_mangle]\n+pub unsafe fn cast_unchecked_f32_u8(a: f32) -> u8 {\n+    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n+    // CHECK: fptoui float {{.*}} to i8\n+    // CHECK-NEXT: ret i8 {{.*}}\n+    a.to_int_unchecked()\n+}"}, {"sha": "6c3e503693c3ceef3b999403776f48b36dc83834", "filename": "src/test/ui/numbers-arithmetic/saturating-float-casts-impl.rs", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-impl.rs?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -0,0 +1,507 @@\n+// ignore-test\n+\n+// Tests saturating float->int casts. See u128-as-f32.rs for the opposite direction.\n+//\n+// Some of these tests come from a similar file in miri,\n+// tests/run-pass/float.rs. Individual test cases are potentially duplicated\n+// with the previously existing tests, but since this runs so quickly anyway,\n+// we're not spending the time to figure out exactly which ones should be\n+// merged.\n+\n+extern crate test;\n+\n+use self::test::black_box;\n+use std::{f32, f64};\n+#[cfg(not(target_os = \"emscripten\"))]\n+use std::{i128, u128};\n+use std::{i16, i32, i64, i8, u16, u32, u64, u8};\n+\n+macro_rules! test {\n+    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => (\n+        // black_box disables constant evaluation to test run-time conversions:\n+        assert_eq!(black_box::<$src_ty>($val) as $dest_ty, $expected,\n+                    \"run-time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+\n+        {\n+            const X: $src_ty = $val;\n+            const Y: $dest_ty = X as $dest_ty;\n+            assert_eq!(Y, $expected,\n+                        \"const eval {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+        }\n+    );\n+\n+    ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n+        test!($fval, f32 -> $ity, $ival);\n+        test!($fval, f64 -> $ity, $ival);\n+    )\n+}\n+\n+macro_rules! common_fptoi_tests {\n+    ($fty:ident -> $($ity:ident)+) => ({ $(\n+        test!($fty::NAN, $fty -> $ity, 0);\n+        test!($fty::INFINITY, $fty -> $ity, $ity::MAX);\n+        test!($fty::NEG_INFINITY, $fty -> $ity, $ity::MIN);\n+        // These two tests are not solely float->int tests, in particular the latter relies on\n+        // `u128::MAX as f32` not being UB. But that's okay, since this file tests int->float\n+        // as well, the test is just slightly misplaced.\n+        test!($ity::MIN as $fty, $fty -> $ity, $ity::MIN);\n+        test!($ity::MAX as $fty, $fty -> $ity, $ity::MAX);\n+        test!(0., $fty -> $ity, 0);\n+        test!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(-0.9, $fty -> $ity, 0);\n+        test!(1., $fty -> $ity, 1);\n+        test!(42., $fty -> $ity, 42);\n+    )+ });\n+\n+    (f* -> $($ity:ident)+) => ({\n+        common_fptoi_tests!(f32 -> $($ity)+);\n+        common_fptoi_tests!(f64 -> $($ity)+);\n+    })\n+}\n+\n+macro_rules! fptoui_tests {\n+    ($fty: ident -> $($ity: ident)+) => ({ $(\n+        test!(-0., $fty -> $ity, 0);\n+        test!(-$fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(-0.99999994, $fty -> $ity, 0);\n+        test!(-1., $fty -> $ity, 0);\n+        test!(-100., $fty -> $ity, 0);\n+        test!(#[allow(overflowing_literals)] -1e50, $fty -> $ity, 0);\n+        test!(#[allow(overflowing_literals)] -1e130, $fty -> $ity, 0);\n+    )+ });\n+\n+    (f* -> $($ity:ident)+) => ({\n+        fptoui_tests!(f32 -> $($ity)+);\n+        fptoui_tests!(f64 -> $($ity)+);\n+    })\n+}\n+\n+use std::fmt::Debug;\n+\n+// Helper function to avoid promotion so that this tests \"run-time\" casts, not CTFE.\n+#[track_caller]\n+#[inline(never)]\n+fn assert_eq<T: PartialEq + Debug>(x: T, y: T) {\n+    assert_eq!(x, y);\n+}\n+\n+trait FloatToInt<Int>: Copy {\n+    fn cast(self) -> Int;\n+    unsafe fn cast_unchecked(self) -> Int;\n+}\n+\n+impl FloatToInt<i8> for f32 {\n+    fn cast(self) -> i8 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i8 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i32> for f32 {\n+    fn cast(self) -> i32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u32> for f32 {\n+    fn cast(self) -> u32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i64> for f32 {\n+    fn cast(self) -> i64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u64> for f32 {\n+    fn cast(self) -> u64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+\n+impl FloatToInt<i8> for f64 {\n+    fn cast(self) -> i8 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i8 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i32> for f64 {\n+    fn cast(self) -> i32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u32> for f64 {\n+    fn cast(self) -> u32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i64> for f64 {\n+    fn cast(self) -> i64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u64> for f64 {\n+    fn cast(self) -> u64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+// FIXME emscripten does not support i128\n+#[cfg(not(target_os = \"emscripten\"))]\n+impl FloatToInt<i128> for f64 {\n+    fn cast(self) -> i128 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i128 {\n+        self.to_int_unchecked()\n+    }\n+}\n+// FIXME emscripten does not support i128\n+#[cfg(not(target_os = \"emscripten\"))]\n+impl FloatToInt<u128> for f64 {\n+    fn cast(self) -> u128 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u128 {\n+        self.to_int_unchecked()\n+    }\n+}\n+\n+/// Test this cast both via `as` and via `to_int_unchecked` (i.e., it must not saturate).\n+#[track_caller]\n+#[inline(never)]\n+fn test_both_cast<F, I>(x: F, y: I)\n+where\n+    F: FloatToInt<I>,\n+    I: PartialEq + Debug,\n+{\n+    assert_eq!(x.cast(), y);\n+    assert_eq!(unsafe { x.cast_unchecked() }, y);\n+}\n+\n+fn casts() {\n+    // f32 -> i8\n+    test_both_cast::<f32, i8>(127.99, 127);\n+    test_both_cast::<f32, i8>(-128.99, -128);\n+\n+    // f32 -> i32\n+    test_both_cast::<f32, i32>(0.0, 0);\n+    test_both_cast::<f32, i32>(-0.0, 0);\n+    test_both_cast::<f32, i32>(/*0x1p-149*/ f32::from_bits(0x00000001), 0);\n+    test_both_cast::<f32, i32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n+    test_both_cast::<f32, i32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n+    test_both_cast::<f32, i32>(/*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd), -1);\n+    test_both_cast::<f32, i32>(1.9, 1);\n+    test_both_cast::<f32, i32>(-1.9, -1);\n+    test_both_cast::<f32, i32>(5.0, 5);\n+    test_both_cast::<f32, i32>(-5.0, -5);\n+    test_both_cast::<f32, i32>(2147483520.0, 2147483520);\n+    test_both_cast::<f32, i32>(-2147483648.0, -2147483648);\n+    // unrepresentable casts\n+    assert_eq::<i32>(2147483648.0f32 as i32, i32::MAX);\n+    assert_eq::<i32>(-2147483904.0f32 as i32, i32::MIN);\n+    assert_eq::<i32>(f32::MAX as i32, i32::MAX);\n+    assert_eq::<i32>(f32::MIN as i32, i32::MIN);\n+    assert_eq::<i32>(f32::INFINITY as i32, i32::MAX);\n+    assert_eq::<i32>(f32::NEG_INFINITY as i32, i32::MIN);\n+    assert_eq::<i32>(f32::NAN as i32, 0);\n+    assert_eq::<i32>((-f32::NAN) as i32, 0);\n+\n+    // f32 -> u32\n+    test_both_cast::<f32, u32>(0.0, 0);\n+    test_both_cast::<f32, u32>(-0.0, 0);\n+    test_both_cast::<f32, u32>(-0.9999999, 0);\n+    test_both_cast::<f32, u32>(/*0x1p-149*/ f32::from_bits(0x1), 0);\n+    test_both_cast::<f32, u32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n+    test_both_cast::<f32, u32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n+    test_both_cast::<f32, u32>(1.9, 1);\n+    test_both_cast::<f32, u32>(5.0, 5);\n+    test_both_cast::<f32, u32>(2147483648.0, 0x8000_0000);\n+    test_both_cast::<f32, u32>(4294967040.0, 0u32.wrapping_sub(256));\n+    test_both_cast::<f32, u32>(/*-0x1.ccccccp-1*/ f32::from_bits(0xbf666666), 0);\n+    test_both_cast::<f32, u32>(/*-0x1.fffffep-1*/ f32::from_bits(0xbf7fffff), 0);\n+    test_both_cast::<f32, u32>((u32::MAX - 128) as f32, u32::MAX - 255); // rounding loss\n+\n+    // unrepresentable casts:\n+\n+    // rounds up and then becomes unrepresentable\n+    assert_eq::<u32>((u32::MAX - 127) as f32 as u32, u32::MAX);\n+\n+    assert_eq::<u32>(4294967296.0f32 as u32, u32::MAX);\n+    assert_eq::<u32>(-5.0f32 as u32, 0);\n+    assert_eq::<u32>(f32::MAX as u32, u32::MAX);\n+    assert_eq::<u32>(f32::MIN as u32, 0);\n+    assert_eq::<u32>(f32::INFINITY as u32, u32::MAX);\n+    assert_eq::<u32>(f32::NEG_INFINITY as u32, 0);\n+    assert_eq::<u32>(f32::NAN as u32, 0);\n+    assert_eq::<u32>((-f32::NAN) as u32, 0);\n+\n+    // f32 -> i64\n+    test_both_cast::<f32, i64>(4294967296.0, 4294967296);\n+    test_both_cast::<f32, i64>(-4294967296.0, -4294967296);\n+    test_both_cast::<f32, i64>(9223371487098961920.0, 9223371487098961920);\n+    test_both_cast::<f32, i64>(-9223372036854775808.0, -9223372036854775808);\n+\n+    // f64 -> i8\n+    test_both_cast::<f64, i8>(127.99, 127);\n+    test_both_cast::<f64, i8>(-128.99, -128);\n+\n+    // f64 -> i32\n+    test_both_cast::<f64, i32>(0.0, 0);\n+    test_both_cast::<f64, i32>(-0.0, 0);\n+    test_both_cast::<f64, i32>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n+    test_both_cast::<f64, i32>(\n+        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n+        -1,\n+    );\n+    test_both_cast::<f64, i32>(1.9, 1);\n+    test_both_cast::<f64, i32>(-1.9, -1);\n+    test_both_cast::<f64, i32>(1e8, 100_000_000);\n+    test_both_cast::<f64, i32>(2147483647.0, 2147483647);\n+    test_both_cast::<f64, i32>(-2147483648.0, -2147483648);\n+    // unrepresentable casts\n+    assert_eq::<i32>(2147483648.0f64 as i32, i32::MAX);\n+    assert_eq::<i32>(-2147483649.0f64 as i32, i32::MIN);\n+\n+    // f64 -> i64\n+    test_both_cast::<f64, i64>(0.0, 0);\n+    test_both_cast::<f64, i64>(-0.0, 0);\n+    test_both_cast::<f64, i64>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1), 0);\n+    test_both_cast::<f64, i64>(\n+        /*-0x0.0000000000001p-1022*/ f64::from_bits(0x8000000000000001),\n+        0,\n+    );\n+    test_both_cast::<f64, i64>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n+    test_both_cast::<f64, i64>(\n+        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n+        -1,\n+    );\n+    test_both_cast::<f64, i64>(5.0, 5);\n+    test_both_cast::<f64, i64>(5.9, 5);\n+    test_both_cast::<f64, i64>(-5.0, -5);\n+    test_both_cast::<f64, i64>(-5.9, -5);\n+    test_both_cast::<f64, i64>(4294967296.0, 4294967296);\n+    test_both_cast::<f64, i64>(-4294967296.0, -4294967296);\n+    test_both_cast::<f64, i64>(9223372036854774784.0, 9223372036854774784);\n+    test_both_cast::<f64, i64>(-9223372036854775808.0, -9223372036854775808);\n+    // unrepresentable casts\n+    assert_eq::<i64>(9223372036854775808.0f64 as i64, i64::MAX);\n+    assert_eq::<i64>(-9223372036854777856.0f64 as i64, i64::MIN);\n+    assert_eq::<i64>(f64::MAX as i64, i64::MAX);\n+    assert_eq::<i64>(f64::MIN as i64, i64::MIN);\n+    assert_eq::<i64>(f64::INFINITY as i64, i64::MAX);\n+    assert_eq::<i64>(f64::NEG_INFINITY as i64, i64::MIN);\n+    assert_eq::<i64>(f64::NAN as i64, 0);\n+    assert_eq::<i64>((-f64::NAN) as i64, 0);\n+\n+    // f64 -> u64\n+    test_both_cast::<f64, u64>(0.0, 0);\n+    test_both_cast::<f64, u64>(-0.0, 0);\n+    test_both_cast::<f64, u64>(-0.99999999999, 0);\n+    test_both_cast::<f64, u64>(5.0, 5);\n+    test_both_cast::<f64, u64>(1e16, 10000000000000000);\n+    test_both_cast::<f64, u64>((u64::MAX - 1024) as f64, u64::MAX - 2047); // rounding loss\n+    test_both_cast::<f64, u64>(9223372036854775808.0, 9223372036854775808);\n+    // unrepresentable casts\n+    assert_eq::<u64>(-5.0f64 as u64, 0);\n+    // rounds up and then becomes unrepresentable\n+    assert_eq::<u64>((u64::MAX - 1023) as f64 as u64, u64::MAX);\n+    assert_eq::<u64>(18446744073709551616.0f64 as u64, u64::MAX);\n+    assert_eq::<u64>(f64::MAX as u64, u64::MAX);\n+    assert_eq::<u64>(f64::MIN as u64, 0);\n+    assert_eq::<u64>(f64::INFINITY as u64, u64::MAX);\n+    assert_eq::<u64>(f64::NEG_INFINITY as u64, 0);\n+    assert_eq::<u64>(f64::NAN as u64, 0);\n+    assert_eq::<u64>((-f64::NAN) as u64, 0);\n+\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        // f64 -> i128\n+        assert_eq::<i128>(f64::MAX as i128, i128::MAX);\n+        assert_eq::<i128>(f64::MIN as i128, i128::MIN);\n+\n+        // f64 -> u128\n+        assert_eq::<u128>(f64::MAX as u128, u128::MAX);\n+        assert_eq::<u128>(f64::MIN as u128, 0);\n+    }\n+\n+    // int -> f32\n+    assert_eq::<f32>(127i8 as f32, 127.0);\n+    assert_eq::<f32>(2147483647i32 as f32, 2147483648.0);\n+    assert_eq::<f32>((-2147483648i32) as f32, -2147483648.0);\n+    assert_eq::<f32>(1234567890i32 as f32, /*0x1.26580cp+30*/ f32::from_bits(0x4e932c06));\n+    assert_eq::<f32>(16777217i32 as f32, 16777216.0);\n+    assert_eq::<f32>((-16777217i32) as f32, -16777216.0);\n+    assert_eq::<f32>(16777219i32 as f32, 16777220.0);\n+    assert_eq::<f32>((-16777219i32) as f32, -16777220.0);\n+    assert_eq::<f32>(\n+        0x7fffff4000000001i64 as f32,\n+        /*0x1.fffffep+62*/ f32::from_bits(0x5effffff),\n+    );\n+    assert_eq::<f32>(\n+        0x8000004000000001u64 as i64 as f32,\n+        /*-0x1.fffffep+62*/ f32::from_bits(0xdeffffff),\n+    );\n+    assert_eq::<f32>(\n+        0x0020000020000001i64 as f32,\n+        /*0x1.000002p+53*/ f32::from_bits(0x5a000001),\n+    );\n+    assert_eq::<f32>(\n+        0xffdfffffdfffffffu64 as i64 as f32,\n+        /*-0x1.000002p+53*/ f32::from_bits(0xda000001),\n+    );\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        assert_eq::<f32>(i128::MIN as f32, -170141183460469231731687303715884105728.0f32);\n+        assert_eq::<f32>(u128::MAX as f32, f32::INFINITY); // saturation\n+    }\n+\n+    // int -> f64\n+    assert_eq::<f64>(127i8 as f64, 127.0);\n+    assert_eq::<f64>(i16::MIN as f64, -32768.0f64);\n+    assert_eq::<f64>(2147483647i32 as f64, 2147483647.0);\n+    assert_eq::<f64>(-2147483648i32 as f64, -2147483648.0);\n+    assert_eq::<f64>(987654321i32 as f64, 987654321.0);\n+    assert_eq::<f64>(9223372036854775807i64 as f64, 9223372036854775807.0);\n+    assert_eq::<f64>(-9223372036854775808i64 as f64, -9223372036854775808.0);\n+    assert_eq::<f64>(4669201609102990i64 as f64, 4669201609102990.0); // Feigenbaum (?)\n+    assert_eq::<f64>(9007199254740993i64 as f64, 9007199254740992.0);\n+    assert_eq::<f64>(-9007199254740993i64 as f64, -9007199254740992.0);\n+    assert_eq::<f64>(9007199254740995i64 as f64, 9007199254740996.0);\n+    assert_eq::<f64>(-9007199254740995i64 as f64, -9007199254740996.0);\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        // even that fits...\n+        assert_eq::<f64>(u128::MAX as f64, 340282366920938463463374607431768211455.0f64);\n+    }\n+\n+    // f32 -> f64\n+    assert_eq::<u64>((0.0f32 as f64).to_bits(), 0.0f64.to_bits());\n+    assert_eq::<u64>(((-0.0f32) as f64).to_bits(), (-0.0f64).to_bits());\n+    assert_eq::<f64>(5.0f32 as f64, 5.0f64);\n+    assert_eq::<f64>(\n+        /*0x1p-149*/ f32::from_bits(0x1) as f64,\n+        /*0x1p-149*/ f64::from_bits(0x36a0000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*-0x1p-149*/ f32::from_bits(0x80000001) as f64,\n+        /*-0x1p-149*/ f64::from_bits(0xb6a0000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1.fffffep+127*/ f32::from_bits(0x7f7fffff) as f64,\n+        /*0x1.fffffep+127*/ f64::from_bits(0x47efffffe0000000),\n+    );\n+    assert_eq::<f64>(\n+        /*-0x1.fffffep+127*/ (-f32::from_bits(0x7f7fffff)) as f64,\n+        /*-0x1.fffffep+127*/ -f64::from_bits(0x47efffffe0000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1p-119*/ f32::from_bits(0x4000000) as f64,\n+        /*0x1p-119*/ f64::from_bits(0x3880000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1.8f867ep+125*/ f32::from_bits(0x7e47c33f) as f64,\n+        6.6382536710104395e+37,\n+    );\n+    assert_eq::<f64>(f32::INFINITY as f64, f64::INFINITY);\n+    assert_eq::<f64>(f32::NEG_INFINITY as f64, f64::NEG_INFINITY);\n+\n+    // f64 -> f32\n+    assert_eq::<u32>((0.0f64 as f32).to_bits(), 0.0f32.to_bits());\n+    assert_eq::<u32>(((-0.0f64) as f32).to_bits(), (-0.0f32).to_bits());\n+    assert_eq::<f32>(5.0f64 as f32, 5.0f32);\n+    assert_eq::<f32>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1) as f32, 0.0);\n+    assert_eq::<f32>(/*-0x0.0000000000001p-1022*/ (-f64::from_bits(0x1)) as f32, -0.0);\n+    assert_eq::<f32>(\n+        /*0x1.fffffe0000000p-127*/ f64::from_bits(0x380fffffe0000000) as f32,\n+        /*0x1p-149*/ f32::from_bits(0x800000),\n+    );\n+    assert_eq::<f32>(\n+        /*0x1.4eae4f7024c7p+108*/ f64::from_bits(0x46b4eae4f7024c70) as f32,\n+        /*0x1.4eae5p+108*/ f32::from_bits(0x75a75728),\n+    );\n+    assert_eq::<f32>(f64::MAX as f32, f32::INFINITY);\n+    assert_eq::<f32>(f64::MIN as f32, f32::NEG_INFINITY);\n+    assert_eq::<f32>(f64::INFINITY as f32, f32::INFINITY);\n+    assert_eq::<f32>(f64::NEG_INFINITY as f32, f32::NEG_INFINITY);\n+}\n+\n+pub fn run() {\n+    casts(); // from miri's tests\n+\n+    common_fptoi_tests!(f* -> i8 i16 i32 i64 u8 u16 u32 u64);\n+    fptoui_tests!(f* -> u8 u16 u32 u64);\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        common_fptoi_tests!(f* -> i128 u128);\n+        fptoui_tests!(f* -> u128);\n+    }\n+\n+    // The following tests cover edge cases for some integer types.\n+\n+    // # u8\n+    test!(254., f* -> u8, 254);\n+    test!(256., f* -> u8, 255);\n+\n+    // # i8\n+    test!(-127., f* -> i8, -127);\n+    test!(-129., f* -> i8, -128);\n+    test!(126., f* -> i8, 126);\n+    test!(128., f* -> i8, 127);\n+\n+    // # i32\n+    // -2147483648. is i32::MIN (exactly)\n+    test!(-2147483648., f* -> i32, i32::MIN);\n+    // 2147483648. is i32::MAX rounded up\n+    test!(2147483648., f32 -> i32, 2147483647);\n+    // With 24 significand bits, floats with magnitude in [2^30 + 1, 2^31] are rounded to\n+    // multiples of 2^7. Therefore, nextDown(round(i32::MAX)) is 2^31 - 128:\n+    test!(2147483520., f32 -> i32, 2147483520);\n+    // Similarly, nextUp(i32::MIN) is i32::MIN + 2^8 and nextDown(i32::MIN) is i32::MIN - 2^7\n+    test!(-2147483904., f* -> i32, i32::MIN);\n+    test!(-2147483520., f* -> i32, -2147483520);\n+\n+    // # u32\n+    // round(MAX) and nextUp(round(MAX))\n+    test!(4294967040., f* -> u32, 4294967040);\n+    test!(4294967296., f* -> u32, 4294967295);\n+\n+    // # u128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        // float->int:\n+        test!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n+        // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n+        const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n+        test!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n+    }\n+}"}, {"sha": "cad05917391be97623a7c921866f21665dc2df5c", "filename": "src/test/ui/numbers-arithmetic/saturating-float-casts-wasm.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-wasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-wasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-wasm.rs?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -0,0 +1,13 @@\n+// run-pass\n+// only-wasm32\n+// compile-flags: -Zmir-opt-level=0 -C target-feature=+nontrapping-fptoint\n+\n+#![feature(test, stmt_expr_attributes)]\n+#![deny(overflowing_literals)]\n+\n+#[path = \"saturating-float-casts-impl.rs\"]\n+mod implementation;\n+\n+pub fn main() {\n+    implementation::run();\n+}"}, {"sha": "cc248a9bea0879c325295f13a785511f3dd5909c", "filename": "src/test/ui/numbers-arithmetic/saturating-float-casts.rs", "status": "modified", "additions": 3, "deletions": 500, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65342fd341f63bb2b594a47436c7591f2ebc0208/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs?ref=65342fd341f63bb2b594a47436c7591f2ebc0208", "patch": "@@ -1,509 +1,12 @@\n // run-pass\n // compile-flags:-Zmir-opt-level=0\n-// Tests saturating float->int casts. See u128-as-f32.rs for the opposite direction.\n-//\n-// Some of these tests come from a similar file in miri,\n-// tests/run-pass/float.rs. Individual test cases are potentially duplicated\n-// with the previously existing tests, but since this runs so quickly anyway,\n-// we're not spending the time to figure out exactly which ones should be\n-// merged.\n \n #![feature(test, stmt_expr_attributes)]\n #![deny(overflowing_literals)]\n-extern crate test;\n \n-use std::{f32, f64};\n-#[cfg(not(target_os = \"emscripten\"))]\n-use std::{i128, u128};\n-use std::{i16, i32, i64, i8, u16, u32, u64, u8};\n-use test::black_box;\n-\n-macro_rules! test {\n-    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => (\n-        // black_box disables constant evaluation to test run-time conversions:\n-        assert_eq!(black_box::<$src_ty>($val) as $dest_ty, $expected,\n-                    \"run-time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n-\n-        {\n-            const X: $src_ty = $val;\n-            const Y: $dest_ty = X as $dest_ty;\n-            assert_eq!(Y, $expected,\n-                        \"const eval {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n-        }\n-    );\n-\n-    ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n-        test!($fval, f32 -> $ity, $ival);\n-        test!($fval, f64 -> $ity, $ival);\n-    )\n-}\n-\n-macro_rules! common_fptoi_tests {\n-    ($fty:ident -> $($ity:ident)+) => ({ $(\n-        test!($fty::NAN, $fty -> $ity, 0);\n-        test!($fty::INFINITY, $fty -> $ity, $ity::MAX);\n-        test!($fty::NEG_INFINITY, $fty -> $ity, $ity::MIN);\n-        // These two tests are not solely float->int tests, in particular the latter relies on\n-        // `u128::MAX as f32` not being UB. But that's okay, since this file tests int->float\n-        // as well, the test is just slightly misplaced.\n-        test!($ity::MIN as $fty, $fty -> $ity, $ity::MIN);\n-        test!($ity::MAX as $fty, $fty -> $ity, $ity::MAX);\n-        test!(0., $fty -> $ity, 0);\n-        test!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n-        test!(-0.9, $fty -> $ity, 0);\n-        test!(1., $fty -> $ity, 1);\n-        test!(42., $fty -> $ity, 42);\n-    )+ });\n-\n-    (f* -> $($ity:ident)+) => ({\n-        common_fptoi_tests!(f32 -> $($ity)+);\n-        common_fptoi_tests!(f64 -> $($ity)+);\n-    })\n-}\n-\n-macro_rules! fptoui_tests {\n-    ($fty: ident -> $($ity: ident)+) => ({ $(\n-        test!(-0., $fty -> $ity, 0);\n-        test!(-$fty::MIN_POSITIVE, $fty -> $ity, 0);\n-        test!(-0.99999994, $fty -> $ity, 0);\n-        test!(-1., $fty -> $ity, 0);\n-        test!(-100., $fty -> $ity, 0);\n-        test!(#[allow(overflowing_literals)] -1e50, $fty -> $ity, 0);\n-        test!(#[allow(overflowing_literals)] -1e130, $fty -> $ity, 0);\n-    )+ });\n-\n-    (f* -> $($ity:ident)+) => ({\n-        fptoui_tests!(f32 -> $($ity)+);\n-        fptoui_tests!(f64 -> $($ity)+);\n-    })\n-}\n-\n-use std::fmt::Debug;\n-\n-// Helper function to avoid promotion so that this tests \"run-time\" casts, not CTFE.\n-#[track_caller]\n-#[inline(never)]\n-fn assert_eq<T: PartialEq + Debug>(x: T, y: T) {\n-    assert_eq!(x, y);\n-}\n-\n-trait FloatToInt<Int>: Copy {\n-    fn cast(self) -> Int;\n-    unsafe fn cast_unchecked(self) -> Int;\n-}\n-\n-impl FloatToInt<i8> for f32 {\n-    fn cast(self) -> i8 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i8 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<i32> for f32 {\n-    fn cast(self) -> i32 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i32 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<u32> for f32 {\n-    fn cast(self) -> u32 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> u32 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<i64> for f32 {\n-    fn cast(self) -> i64 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i64 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<u64> for f32 {\n-    fn cast(self) -> u64 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> u64 {\n-        self.to_int_unchecked()\n-    }\n-}\n-\n-impl FloatToInt<i8> for f64 {\n-    fn cast(self) -> i8 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i8 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<i32> for f64 {\n-    fn cast(self) -> i32 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i32 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<u32> for f64 {\n-    fn cast(self) -> u32 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> u32 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<i64> for f64 {\n-    fn cast(self) -> i64 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i64 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<u64> for f64 {\n-    fn cast(self) -> u64 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> u64 {\n-        self.to_int_unchecked()\n-    }\n-}\n-// FIXME emscripten does not support i128\n-#[cfg(not(target_os = \"emscripten\"))]\n-impl FloatToInt<i128> for f64 {\n-    fn cast(self) -> i128 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i128 {\n-        self.to_int_unchecked()\n-    }\n-}\n-// FIXME emscripten does not support i128\n-#[cfg(not(target_os = \"emscripten\"))]\n-impl FloatToInt<u128> for f64 {\n-    fn cast(self) -> u128 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> u128 {\n-        self.to_int_unchecked()\n-    }\n-}\n-\n-/// Test this cast both via `as` and via `to_int_unchecked` (i.e., it must not saturate).\n-#[track_caller]\n-#[inline(never)]\n-fn test_both_cast<F, I>(x: F, y: I)\n-where\n-    F: FloatToInt<I>,\n-    I: PartialEq + Debug,\n-{\n-    assert_eq!(x.cast(), y);\n-    assert_eq!(unsafe { x.cast_unchecked() }, y);\n-}\n-\n-fn casts() {\n-    // f32 -> i8\n-    test_both_cast::<f32, i8>(127.99, 127);\n-    test_both_cast::<f32, i8>(-128.99, -128);\n-\n-    // f32 -> i32\n-    test_both_cast::<f32, i32>(0.0, 0);\n-    test_both_cast::<f32, i32>(-0.0, 0);\n-    test_both_cast::<f32, i32>(/*0x1p-149*/ f32::from_bits(0x00000001), 0);\n-    test_both_cast::<f32, i32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n-    test_both_cast::<f32, i32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n-    test_both_cast::<f32, i32>(/*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd), -1);\n-    test_both_cast::<f32, i32>(1.9, 1);\n-    test_both_cast::<f32, i32>(-1.9, -1);\n-    test_both_cast::<f32, i32>(5.0, 5);\n-    test_both_cast::<f32, i32>(-5.0, -5);\n-    test_both_cast::<f32, i32>(2147483520.0, 2147483520);\n-    test_both_cast::<f32, i32>(-2147483648.0, -2147483648);\n-    // unrepresentable casts\n-    assert_eq::<i32>(2147483648.0f32 as i32, i32::MAX);\n-    assert_eq::<i32>(-2147483904.0f32 as i32, i32::MIN);\n-    assert_eq::<i32>(f32::MAX as i32, i32::MAX);\n-    assert_eq::<i32>(f32::MIN as i32, i32::MIN);\n-    assert_eq::<i32>(f32::INFINITY as i32, i32::MAX);\n-    assert_eq::<i32>(f32::NEG_INFINITY as i32, i32::MIN);\n-    assert_eq::<i32>(f32::NAN as i32, 0);\n-    assert_eq::<i32>((-f32::NAN) as i32, 0);\n-\n-    // f32 -> u32\n-    test_both_cast::<f32, u32>(0.0, 0);\n-    test_both_cast::<f32, u32>(-0.0, 0);\n-    test_both_cast::<f32, u32>(-0.9999999, 0);\n-    test_both_cast::<f32, u32>(/*0x1p-149*/ f32::from_bits(0x1), 0);\n-    test_both_cast::<f32, u32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n-    test_both_cast::<f32, u32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n-    test_both_cast::<f32, u32>(1.9, 1);\n-    test_both_cast::<f32, u32>(5.0, 5);\n-    test_both_cast::<f32, u32>(2147483648.0, 0x8000_0000);\n-    test_both_cast::<f32, u32>(4294967040.0, 0u32.wrapping_sub(256));\n-    test_both_cast::<f32, u32>(/*-0x1.ccccccp-1*/ f32::from_bits(0xbf666666), 0);\n-    test_both_cast::<f32, u32>(/*-0x1.fffffep-1*/ f32::from_bits(0xbf7fffff), 0);\n-    test_both_cast::<f32, u32>((u32::MAX - 128) as f32, u32::MAX - 255); // rounding loss\n-\n-    // unrepresentable casts:\n-\n-    // rounds up and then becomes unrepresentable\n-    assert_eq::<u32>((u32::MAX - 127) as f32 as u32, u32::MAX);\n-\n-    assert_eq::<u32>(4294967296.0f32 as u32, u32::MAX);\n-    assert_eq::<u32>(-5.0f32 as u32, 0);\n-    assert_eq::<u32>(f32::MAX as u32, u32::MAX);\n-    assert_eq::<u32>(f32::MIN as u32, 0);\n-    assert_eq::<u32>(f32::INFINITY as u32, u32::MAX);\n-    assert_eq::<u32>(f32::NEG_INFINITY as u32, 0);\n-    assert_eq::<u32>(f32::NAN as u32, 0);\n-    assert_eq::<u32>((-f32::NAN) as u32, 0);\n-\n-    // f32 -> i64\n-    test_both_cast::<f32, i64>(4294967296.0, 4294967296);\n-    test_both_cast::<f32, i64>(-4294967296.0, -4294967296);\n-    test_both_cast::<f32, i64>(9223371487098961920.0, 9223371487098961920);\n-    test_both_cast::<f32, i64>(-9223372036854775808.0, -9223372036854775808);\n-\n-    // f64 -> i8\n-    test_both_cast::<f64, i8>(127.99, 127);\n-    test_both_cast::<f64, i8>(-128.99, -128);\n-\n-    // f64 -> i32\n-    test_both_cast::<f64, i32>(0.0, 0);\n-    test_both_cast::<f64, i32>(-0.0, 0);\n-    test_both_cast::<f64, i32>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n-    test_both_cast::<f64, i32>(\n-        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n-        -1,\n-    );\n-    test_both_cast::<f64, i32>(1.9, 1);\n-    test_both_cast::<f64, i32>(-1.9, -1);\n-    test_both_cast::<f64, i32>(1e8, 100_000_000);\n-    test_both_cast::<f64, i32>(2147483647.0, 2147483647);\n-    test_both_cast::<f64, i32>(-2147483648.0, -2147483648);\n-    // unrepresentable casts\n-    assert_eq::<i32>(2147483648.0f64 as i32, i32::MAX);\n-    assert_eq::<i32>(-2147483649.0f64 as i32, i32::MIN);\n-\n-    // f64 -> i64\n-    test_both_cast::<f64, i64>(0.0, 0);\n-    test_both_cast::<f64, i64>(-0.0, 0);\n-    test_both_cast::<f64, i64>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1), 0);\n-    test_both_cast::<f64, i64>(\n-        /*-0x0.0000000000001p-1022*/ f64::from_bits(0x8000000000000001),\n-        0,\n-    );\n-    test_both_cast::<f64, i64>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n-    test_both_cast::<f64, i64>(\n-        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n-        -1,\n-    );\n-    test_both_cast::<f64, i64>(5.0, 5);\n-    test_both_cast::<f64, i64>(5.9, 5);\n-    test_both_cast::<f64, i64>(-5.0, -5);\n-    test_both_cast::<f64, i64>(-5.9, -5);\n-    test_both_cast::<f64, i64>(4294967296.0, 4294967296);\n-    test_both_cast::<f64, i64>(-4294967296.0, -4294967296);\n-    test_both_cast::<f64, i64>(9223372036854774784.0, 9223372036854774784);\n-    test_both_cast::<f64, i64>(-9223372036854775808.0, -9223372036854775808);\n-    // unrepresentable casts\n-    assert_eq::<i64>(9223372036854775808.0f64 as i64, i64::MAX);\n-    assert_eq::<i64>(-9223372036854777856.0f64 as i64, i64::MIN);\n-    assert_eq::<i64>(f64::MAX as i64, i64::MAX);\n-    assert_eq::<i64>(f64::MIN as i64, i64::MIN);\n-    assert_eq::<i64>(f64::INFINITY as i64, i64::MAX);\n-    assert_eq::<i64>(f64::NEG_INFINITY as i64, i64::MIN);\n-    assert_eq::<i64>(f64::NAN as i64, 0);\n-    assert_eq::<i64>((-f64::NAN) as i64, 0);\n-\n-    // f64 -> u64\n-    test_both_cast::<f64, u64>(0.0, 0);\n-    test_both_cast::<f64, u64>(-0.0, 0);\n-    test_both_cast::<f64, u64>(-0.99999999999, 0);\n-    test_both_cast::<f64, u64>(5.0, 5);\n-    test_both_cast::<f64, u64>(1e16, 10000000000000000);\n-    test_both_cast::<f64, u64>((u64::MAX - 1024) as f64, u64::MAX - 2047); // rounding loss\n-    test_both_cast::<f64, u64>(9223372036854775808.0, 9223372036854775808);\n-    // unrepresentable casts\n-    assert_eq::<u64>(-5.0f64 as u64, 0);\n-    // rounds up and then becomes unrepresentable\n-    assert_eq::<u64>((u64::MAX - 1023) as f64 as u64, u64::MAX);\n-    assert_eq::<u64>(18446744073709551616.0f64 as u64, u64::MAX);\n-    assert_eq::<u64>(f64::MAX as u64, u64::MAX);\n-    assert_eq::<u64>(f64::MIN as u64, 0);\n-    assert_eq::<u64>(f64::INFINITY as u64, u64::MAX);\n-    assert_eq::<u64>(f64::NEG_INFINITY as u64, 0);\n-    assert_eq::<u64>(f64::NAN as u64, 0);\n-    assert_eq::<u64>((-f64::NAN) as u64, 0);\n-\n-    // FIXME emscripten does not support i128\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    {\n-        // f64 -> i128\n-        assert_eq::<i128>(f64::MAX as i128, i128::MAX);\n-        assert_eq::<i128>(f64::MIN as i128, i128::MIN);\n-\n-        // f64 -> u128\n-        assert_eq::<u128>(f64::MAX as u128, u128::MAX);\n-        assert_eq::<u128>(f64::MIN as u128, 0);\n-    }\n-\n-    // int -> f32\n-    assert_eq::<f32>(127i8 as f32, 127.0);\n-    assert_eq::<f32>(2147483647i32 as f32, 2147483648.0);\n-    assert_eq::<f32>((-2147483648i32) as f32, -2147483648.0);\n-    assert_eq::<f32>(1234567890i32 as f32, /*0x1.26580cp+30*/ f32::from_bits(0x4e932c06));\n-    assert_eq::<f32>(16777217i32 as f32, 16777216.0);\n-    assert_eq::<f32>((-16777217i32) as f32, -16777216.0);\n-    assert_eq::<f32>(16777219i32 as f32, 16777220.0);\n-    assert_eq::<f32>((-16777219i32) as f32, -16777220.0);\n-    assert_eq::<f32>(\n-        0x7fffff4000000001i64 as f32,\n-        /*0x1.fffffep+62*/ f32::from_bits(0x5effffff),\n-    );\n-    assert_eq::<f32>(\n-        0x8000004000000001u64 as i64 as f32,\n-        /*-0x1.fffffep+62*/ f32::from_bits(0xdeffffff),\n-    );\n-    assert_eq::<f32>(\n-        0x0020000020000001i64 as f32,\n-        /*0x1.000002p+53*/ f32::from_bits(0x5a000001),\n-    );\n-    assert_eq::<f32>(\n-        0xffdfffffdfffffffu64 as i64 as f32,\n-        /*-0x1.000002p+53*/ f32::from_bits(0xda000001),\n-    );\n-    // FIXME emscripten does not support i128\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    {\n-        assert_eq::<f32>(i128::MIN as f32, -170141183460469231731687303715884105728.0f32);\n-        assert_eq::<f32>(u128::MAX as f32, f32::INFINITY); // saturation\n-    }\n-\n-    // int -> f64\n-    assert_eq::<f64>(127i8 as f64, 127.0);\n-    assert_eq::<f64>(i16::MIN as f64, -32768.0f64);\n-    assert_eq::<f64>(2147483647i32 as f64, 2147483647.0);\n-    assert_eq::<f64>(-2147483648i32 as f64, -2147483648.0);\n-    assert_eq::<f64>(987654321i32 as f64, 987654321.0);\n-    assert_eq::<f64>(9223372036854775807i64 as f64, 9223372036854775807.0);\n-    assert_eq::<f64>(-9223372036854775808i64 as f64, -9223372036854775808.0);\n-    assert_eq::<f64>(4669201609102990i64 as f64, 4669201609102990.0); // Feigenbaum (?)\n-    assert_eq::<f64>(9007199254740993i64 as f64, 9007199254740992.0);\n-    assert_eq::<f64>(-9007199254740993i64 as f64, -9007199254740992.0);\n-    assert_eq::<f64>(9007199254740995i64 as f64, 9007199254740996.0);\n-    assert_eq::<f64>(-9007199254740995i64 as f64, -9007199254740996.0);\n-    // FIXME emscripten does not support i128\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    {\n-        // even that fits...\n-        assert_eq::<f64>(u128::MAX as f64, 340282366920938463463374607431768211455.0f64);\n-    }\n-\n-    // f32 -> f64\n-    assert_eq::<u64>((0.0f32 as f64).to_bits(), 0.0f64.to_bits());\n-    assert_eq::<u64>(((-0.0f32) as f64).to_bits(), (-0.0f64).to_bits());\n-    assert_eq::<f64>(5.0f32 as f64, 5.0f64);\n-    assert_eq::<f64>(\n-        /*0x1p-149*/ f32::from_bits(0x1) as f64,\n-        /*0x1p-149*/ f64::from_bits(0x36a0000000000000),\n-    );\n-    assert_eq::<f64>(\n-        /*-0x1p-149*/ f32::from_bits(0x80000001) as f64,\n-        /*-0x1p-149*/ f64::from_bits(0xb6a0000000000000),\n-    );\n-    assert_eq::<f64>(\n-        /*0x1.fffffep+127*/ f32::from_bits(0x7f7fffff) as f64,\n-        /*0x1.fffffep+127*/ f64::from_bits(0x47efffffe0000000),\n-    );\n-    assert_eq::<f64>(\n-        /*-0x1.fffffep+127*/ (-f32::from_bits(0x7f7fffff)) as f64,\n-        /*-0x1.fffffep+127*/ -f64::from_bits(0x47efffffe0000000),\n-    );\n-    assert_eq::<f64>(\n-        /*0x1p-119*/ f32::from_bits(0x4000000) as f64,\n-        /*0x1p-119*/ f64::from_bits(0x3880000000000000),\n-    );\n-    assert_eq::<f64>(\n-        /*0x1.8f867ep+125*/ f32::from_bits(0x7e47c33f) as f64,\n-        6.6382536710104395e+37,\n-    );\n-    assert_eq::<f64>(f32::INFINITY as f64, f64::INFINITY);\n-    assert_eq::<f64>(f32::NEG_INFINITY as f64, f64::NEG_INFINITY);\n-\n-    // f64 -> f32\n-    assert_eq::<u32>((0.0f64 as f32).to_bits(), 0.0f32.to_bits());\n-    assert_eq::<u32>(((-0.0f64) as f32).to_bits(), (-0.0f32).to_bits());\n-    assert_eq::<f32>(5.0f64 as f32, 5.0f32);\n-    assert_eq::<f32>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1) as f32, 0.0);\n-    assert_eq::<f32>(/*-0x0.0000000000001p-1022*/ (-f64::from_bits(0x1)) as f32, -0.0);\n-    assert_eq::<f32>(\n-        /*0x1.fffffe0000000p-127*/ f64::from_bits(0x380fffffe0000000) as f32,\n-        /*0x1p-149*/ f32::from_bits(0x800000),\n-    );\n-    assert_eq::<f32>(\n-        /*0x1.4eae4f7024c7p+108*/ f64::from_bits(0x46b4eae4f7024c70) as f32,\n-        /*0x1.4eae5p+108*/ f32::from_bits(0x75a75728),\n-    );\n-    assert_eq::<f32>(f64::MAX as f32, f32::INFINITY);\n-    assert_eq::<f32>(f64::MIN as f32, f32::NEG_INFINITY);\n-    assert_eq::<f32>(f64::INFINITY as f32, f32::INFINITY);\n-    assert_eq::<f32>(f64::NEG_INFINITY as f32, f32::NEG_INFINITY);\n-}\n+#[path = \"saturating-float-casts-impl.rs\"]\n+mod implementation;\n \n pub fn main() {\n-    casts(); // from miri's tests\n-\n-    common_fptoi_tests!(f* -> i8 i16 i32 i64 u8 u16 u32 u64);\n-    fptoui_tests!(f* -> u8 u16 u32 u64);\n-    // FIXME emscripten does not support i128\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    {\n-        common_fptoi_tests!(f* -> i128 u128);\n-        fptoui_tests!(f* -> u128);\n-    }\n-\n-    // The following tests cover edge cases for some integer types.\n-\n-    // # u8\n-    test!(254., f* -> u8, 254);\n-    test!(256., f* -> u8, 255);\n-\n-    // # i8\n-    test!(-127., f* -> i8, -127);\n-    test!(-129., f* -> i8, -128);\n-    test!(126., f* -> i8, 126);\n-    test!(128., f* -> i8, 127);\n-\n-    // # i32\n-    // -2147483648. is i32::MIN (exactly)\n-    test!(-2147483648., f* -> i32, i32::MIN);\n-    // 2147483648. is i32::MAX rounded up\n-    test!(2147483648., f32 -> i32, 2147483647);\n-    // With 24 significand bits, floats with magnitude in [2^30 + 1, 2^31] are rounded to\n-    // multiples of 2^7. Therefore, nextDown(round(i32::MAX)) is 2^31 - 128:\n-    test!(2147483520., f32 -> i32, 2147483520);\n-    // Similarly, nextUp(i32::MIN) is i32::MIN + 2^8 and nextDown(i32::MIN) is i32::MIN - 2^7\n-    test!(-2147483904., f* -> i32, i32::MIN);\n-    test!(-2147483520., f* -> i32, -2147483520);\n-\n-    // # u32\n-    // round(MAX) and nextUp(round(MAX))\n-    test!(4294967040., f* -> u32, 4294967040);\n-    test!(4294967296., f* -> u32, 4294967295);\n-\n-    // # u128\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    {\n-        // float->int:\n-        test!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n-        // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n-        const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n-        test!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n-    }\n+    implementation::run();\n }"}]}