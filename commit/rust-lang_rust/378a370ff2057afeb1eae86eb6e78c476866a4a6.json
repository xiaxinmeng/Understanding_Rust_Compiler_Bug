{"sha": "378a370ff2057afeb1eae86eb6e78c476866a4a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3OGEzNzBmZjIwNTdhZmViMWVhZTg2ZWI2ZTc4YzQ3Njg2NmE0YTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-26T02:58:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-26T02:58:31Z"}, "message": "Auto merge of #25646 - huonw:align, r=alexcrichton\n\nThis removes a footgun, since it is a reasonable assumption to make that\r\npointers to `T` will be aligned to `align_of::<T>()`. This also matches\r\nthe behaviour of C/C++. `min_align_of` is now deprecated.\r\n\r\nCloses #21611.", "tree": {"sha": "0c97a350fa399bce435bbe8d36f2e92d61de38d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c97a350fa399bce435bbe8d36f2e92d61de38d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/378a370ff2057afeb1eae86eb6e78c476866a4a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/378a370ff2057afeb1eae86eb6e78c476866a4a6", "html_url": "https://github.com/rust-lang/rust/commit/378a370ff2057afeb1eae86eb6e78c476866a4a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/378a370ff2057afeb1eae86eb6e78c476866a4a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b70d1c601d2dbbe1901eba2a745c9cbe49bb3ad1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b70d1c601d2dbbe1901eba2a745c9cbe49bb3ad1", "html_url": "https://github.com/rust-lang/rust/commit/b70d1c601d2dbbe1901eba2a745c9cbe49bb3ad1"}, {"sha": "225b116829ef76b72f01c2ebf718259c20aa7e14", "url": "https://api.github.com/repos/rust-lang/rust/commits/225b116829ef76b72f01c2ebf718259c20aa7e14", "html_url": "https://github.com/rust-lang/rust/commit/225b116829ef76b72f01c2ebf718259c20aa7e14"}], "stats": {"total": 100, "additions": 47, "deletions": 53}, "files": [{"sha": "dd9c1d1fd188556cc89a78808411b9c89ef8dfd6", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=378a370ff2057afeb1eae86eb6e78c476866a4a6", "patch": "@@ -77,7 +77,7 @@ use core::atomic;\n use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n use core::fmt;\n use core::cmp::Ordering;\n-use core::mem::{min_align_of_val, size_of_val};\n+use core::mem::{align_of_val, size_of_val};\n use core::intrinsics::drop_in_place;\n use core::mem;\n use core::nonzero::NonZero;\n@@ -241,7 +241,7 @@ impl<T: ?Sized> Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            deallocate(ptr as *mut u8, size_of_val(&*ptr), min_align_of_val(&*ptr))\n+            deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n         }\n     }\n }\n@@ -565,7 +565,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n             atomic::fence(Acquire);\n             unsafe { deallocate(ptr as *mut u8,\n                                 size_of_val(&*ptr),\n-                                min_align_of_val(&*ptr)) }\n+                                align_of_val(&*ptr)) }\n         }\n     }\n }"}, {"sha": "3dfafd0a378b90bef31771c17dbb43d28f069b78", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=378a370ff2057afeb1eae86eb6e78c476866a4a6", "patch": "@@ -162,7 +162,7 @@ use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::intrinsics::{assume, drop_in_place};\n use core::marker::{self, Unsize};\n-use core::mem::{self, min_align_of, size_of, min_align_of_val, size_of_val, forget};\n+use core::mem::{self, align_of, size_of, align_of_val, size_of_val, forget};\n use core::nonzero::NonZero;\n use core::ops::{CoerceUnsized, Deref};\n use core::ptr;\n@@ -246,7 +246,7 @@ impl<T> Rc<T> {\n                 // destruct the box and skip our Drop\n                 // we can ignore the refcounts because we know we're unique\n                 deallocate(*rc._ptr as *mut u8, size_of::<RcBox<T>>(),\n-                            min_align_of::<RcBox<T>>());\n+                            align_of::<RcBox<T>>());\n                 forget(rc);\n                 Ok(val)\n             }\n@@ -496,7 +496,7 @@ impl<T: ?Sized> Drop for Rc<T> {\n                     if self.weak() == 0 {\n                         deallocate(ptr as *mut u8,\n                                    size_of_val(&*ptr),\n-                                   min_align_of_val(&*ptr))\n+                                   align_of_val(&*ptr))\n                     }\n                 }\n             }\n@@ -805,7 +805,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n                 // the strong pointers have disappeared.\n                 if self.weak() == 0 {\n                     deallocate(ptr as *mut u8, size_of_val(&*ptr),\n-                               min_align_of_val(&*ptr))\n+                               align_of_val(&*ptr))\n                 }\n             }\n         }"}, {"sha": "4d064b16ad027ea210d39b2fe0c1028d1d2782c8", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=378a370ff2057afeb1eae86eb6e78c476866a4a6", "patch": "@@ -244,7 +244,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n     fn alloc_copy<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             let ptr = self.alloc_copy_inner(mem::size_of::<T>(),\n-                                            mem::min_align_of::<T>());\n+                                            mem::align_of::<T>());\n             let ptr = ptr as *mut T;\n             ptr::write(&mut (*ptr), op());\n             return &mut *ptr;\n@@ -300,7 +300,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n                 self.alloc_noncopy_inner(mem::size_of::<T>(),\n-                                         mem::min_align_of::<T>());\n+                                         mem::align_of::<T>());\n             let ty_ptr = ty_ptr as *mut usize;\n             let ptr = ptr as *mut T;\n             // Write in our tydesc along with a bit indicating that it\n@@ -393,7 +393,7 @@ struct TypedArenaChunk<T> {\n \n fn calculate_size<T>(capacity: usize) -> usize {\n     let mut size = mem::size_of::<TypedArenaChunk<T>>();\n-    size = round_up(size, mem::min_align_of::<T>());\n+    size = round_up(size, mem::align_of::<T>());\n     let elem_size = mem::size_of::<T>();\n     let elems_size = elem_size.checked_mul(capacity).unwrap();\n     size = size.checked_add(elems_size).unwrap();\n@@ -405,7 +405,7 @@ impl<T> TypedArenaChunk<T> {\n     unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: usize)\n            -> *mut TypedArenaChunk<T> {\n         let size = calculate_size::<T>(capacity);\n-        let chunk = allocate(size, mem::min_align_of::<TypedArenaChunk<T>>())\n+        let chunk = allocate(size, mem::align_of::<TypedArenaChunk<T>>())\n                     as *mut TypedArenaChunk<T>;\n         if chunk.is_null() { alloc::oom() }\n         (*chunk).next = next;\n@@ -431,7 +431,7 @@ impl<T> TypedArenaChunk<T> {\n         let size = calculate_size::<T>(self.capacity);\n         let self_ptr: *mut TypedArenaChunk<T> = self;\n         deallocate(self_ptr as *mut u8, size,\n-                   mem::min_align_of::<TypedArenaChunk<T>>());\n+                   mem::align_of::<TypedArenaChunk<T>>());\n         if !next.is_null() {\n             let capacity = (*next).capacity;\n             (*next).destroy(capacity);\n@@ -444,7 +444,7 @@ impl<T> TypedArenaChunk<T> {\n         let this: *const TypedArenaChunk<T> = self;\n         unsafe {\n             mem::transmute(round_up(this.offset(1) as usize,\n-                                    mem::min_align_of::<T>()))\n+                                    mem::align_of::<T>()))\n         }\n     }\n "}, {"sha": "4d76a986700a25ed316f879c3b43eb261ad83c81", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=378a370ff2057afeb1eae86eb6e78c476866a4a6", "patch": "@@ -163,12 +163,12 @@ fn test_offset_calculation() {\n }\n \n fn calculate_allocation_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n-    let (keys_size, keys_align) = (capacity * mem::size_of::<K>(), mem::min_align_of::<K>());\n-    let (vals_size, vals_align) = (capacity * mem::size_of::<V>(), mem::min_align_of::<V>());\n+    let (keys_size, keys_align) = (capacity * mem::size_of::<K>(), mem::align_of::<K>());\n+    let (vals_size, vals_align) = (capacity * mem::size_of::<V>(), mem::align_of::<V>());\n     let (edges_size, edges_align) = if is_leaf {\n         (0, 1)\n     } else {\n-        ((capacity + 1) * mem::size_of::<Node<K, V>>(), mem::min_align_of::<Node<K, V>>())\n+        ((capacity + 1) * mem::size_of::<Node<K, V>>(), mem::align_of::<Node<K, V>>())\n     };\n \n     calculate_allocation(\n@@ -181,11 +181,11 @@ fn calculate_allocation_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize,\n fn calculate_offsets_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n     let keys_size = capacity * mem::size_of::<K>();\n     let vals_size = capacity * mem::size_of::<V>();\n-    let vals_align = mem::min_align_of::<V>();\n+    let vals_align = mem::align_of::<V>();\n     let edges_align = if is_leaf {\n         1\n     } else {\n-        mem::min_align_of::<Node<K, V>>()\n+        mem::align_of::<Node<K, V>>()\n     };\n \n     calculate_offsets("}, {"sha": "4ea26509fd9e8afdff6f24a466e3fce441b6ebe1", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=378a370ff2057afeb1eae86eb6e78c476866a4a6", "patch": "@@ -219,7 +219,7 @@ impl<T> Vec<T> {\n         } else {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n-            let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n+            let ptr = unsafe { allocate(size, mem::align_of::<T>()) };\n             if ptr.is_null() { ::alloc::oom() }\n             unsafe { Vec::from_raw_parts(ptr as *mut T, 0, capacity) }\n         }\n@@ -393,7 +393,7 @@ impl<T> Vec<T> {\n                 let ptr = reallocate(*self.ptr as *mut u8,\n                                      self.cap * mem::size_of::<T>(),\n                                      self.len * mem::size_of::<T>(),\n-                                     mem::min_align_of::<T>()) as *mut T;\n+                                     mem::align_of::<T>()) as *mut T;\n                 if ptr.is_null() { ::alloc::oom() }\n                 self.ptr = Unique::new(ptr);\n             }\n@@ -866,9 +866,9 @@ impl<T> Vec<T> {\n             // FIXME: Assert statically that the types `T` and `U` have the\n             // same minimal alignment in case they are not zero-sized.\n \n-            // These asserts are necessary because the `min_align_of` of the\n+            // These asserts are necessary because the `align_of` of the\n             // types are passed to the allocator by `Vec`.\n-            assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n+            assert!(mem::align_of::<T>() == mem::align_of::<U>());\n \n             // This `as isize` cast is safe, because the size of the elements of the\n             // vector is not 0, and:\n@@ -1269,9 +1269,9 @@ impl<T> Vec<T> {\n #[inline(never)]\n unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: usize, size: usize) -> *mut T {\n     if old_size == 0 {\n-        allocate(size, mem::min_align_of::<T>()) as *mut T\n+        allocate(size, mem::align_of::<T>()) as *mut T\n     } else {\n-        reallocate(ptr as *mut u8, old_size, size, mem::min_align_of::<T>()) as *mut T\n+        reallocate(ptr as *mut u8, old_size, size, mem::align_of::<T>()) as *mut T\n     }\n }\n \n@@ -1280,7 +1280,7 @@ unsafe fn dealloc<T>(ptr: *mut T, len: usize) {\n     if mem::size_of::<T>() != 0 {\n         deallocate(ptr as *mut u8,\n                    len * mem::size_of::<T>(),\n-                   mem::min_align_of::<T>())\n+                   mem::align_of::<T>())\n     }\n }\n "}, {"sha": "ed47c06e7cd0847374cc30ac743f8cd6224e2d7b", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=378a370ff2057afeb1eae86eb6e78c476866a4a6", "patch": "@@ -67,7 +67,7 @@ impl<T> Drop for VecDeque<T> {\n             if mem::size_of::<T>() != 0 {\n                 heap::deallocate(*self.ptr as *mut u8,\n                                  self.cap * mem::size_of::<T>(),\n-                                 mem::min_align_of::<T>())\n+                                 mem::align_of::<T>())\n             }\n         }\n     }\n@@ -172,7 +172,7 @@ impl<T> VecDeque<T> {\n \n         let ptr = unsafe {\n             if mem::size_of::<T>() != 0 {\n-                let ptr = heap::allocate(size, mem::min_align_of::<T>())  as *mut T;;\n+                let ptr = heap::allocate(size, mem::align_of::<T>())  as *mut T;;\n                 if ptr.is_null() { ::alloc::oom() }\n                 Unique::new(ptr)\n             } else {\n@@ -340,7 +340,7 @@ impl<T> VecDeque<T> {\n                     let ptr = heap::reallocate(*self.ptr as *mut u8,\n                                                old,\n                                                new,\n-                                               mem::min_align_of::<T>()) as *mut T;\n+                                               mem::align_of::<T>()) as *mut T;\n                     if ptr.is_null() { ::alloc::oom() }\n                     self.ptr = Unique::new(ptr);\n                 }\n@@ -460,7 +460,7 @@ impl<T> VecDeque<T> {\n                     let ptr = heap::reallocate(*self.ptr as *mut u8,\n                                                old,\n                                                new_size,\n-                                               mem::min_align_of::<T>()) as *mut T;\n+                                               mem::align_of::<T>()) as *mut T;\n                     if ptr.is_null() { ::alloc::oom() }\n                     self.ptr = Unique::new(ptr);\n                 }"}, {"sha": "4177e0666e3a5c1fbb91d5d32c81119385a4041e", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=378a370ff2057afeb1eae86eb6e78c476866a4a6", "patch": "@@ -155,6 +155,7 @@ pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(reason = \"use `align_of` instead\", since = \"1.1.0\")]\n pub fn min_align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n@@ -170,14 +171,14 @@ pub fn min_align_of<T>() -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(reason = \"use `align_of_val` instead\", since = \"1.1.0\")]\n pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n /// Returns the alignment in memory for a type.\n ///\n-/// This function will return the alignment, in bytes, of a type in memory. If the alignment\n-/// returned is adhered to, then the type is guaranteed to function properly.\n+/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n ///\n /// # Examples\n ///\n@@ -189,17 +190,10 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn align_of<T>() -> usize {\n-    // We use the preferred alignment as the default alignment for a type. This\n-    // appears to be what clang migrated towards as well:\n-    //\n-    // http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20110725/044411.html\n-    unsafe { intrinsics::pref_align_of::<T>() }\n+    unsafe { intrinsics::min_align_of::<T>() }\n }\n \n-/// Returns the alignment of the type of the value that `_val` points to.\n-///\n-/// This is similar to `align_of`, but function will properly handle types such as trait objects\n-/// (in the future), returning the alignment for an arbitrary value at runtime.\n+/// Returns the ABI-required minimum alignment of the type of the value that `val` points to\n ///\n /// # Examples\n ///\n@@ -210,8 +204,8 @@ pub fn align_of<T>() -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn align_of_val<T>(_val: &T) -> usize {\n-    align_of::<T>()\n+pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::min_align_of_val(val) }\n }\n \n /// Creates a value initialized to zero."}, {"sha": "349462aebe31b47f72b6cd6dd835ac1f068af8c8", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/378a370ff2057afeb1eae86eb6e78c476866a4a6/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=378a370ff2057afeb1eae86eb6e78c476866a4a6", "patch": "@@ -15,7 +15,7 @@ use cmp;\n use hash::{Hash, Hasher};\n use iter::{Iterator, ExactSizeIterator};\n use marker::{Copy, Send, Sync, Sized, self};\n-use mem::{min_align_of, size_of};\n+use mem::{align_of, size_of};\n use mem;\n use num::wrapping::OverflowingOps;\n use ops::{Deref, DerefMut, Drop};\n@@ -553,9 +553,9 @@ fn calculate_allocation(hash_size: usize, hash_align: usize,\n                                                               vals_align);\n     let (end_of_vals, oflo2) = vals_offset.overflowing_add(vals_size);\n \n-    let min_align = cmp::max(hash_align, cmp::max(keys_align, vals_align));\n+    let align = cmp::max(hash_align, cmp::max(keys_align, vals_align));\n \n-    (min_align, hash_offset, end_of_vals, oflo || oflo2)\n+    (align, hash_offset, end_of_vals, oflo || oflo2)\n }\n \n #[test]\n@@ -597,9 +597,9 @@ impl<K, V> RawTable<K, V> {\n         // factored out into a different function.\n         let (malloc_alignment, hash_offset, size, oflo) =\n             calculate_allocation(\n-                hashes_size, min_align_of::<u64>(),\n-                keys_size,   min_align_of::< K >(),\n-                vals_size,   min_align_of::< V >());\n+                hashes_size, align_of::<u64>(),\n+                keys_size,   align_of::< K >(),\n+                vals_size,   align_of::< V >());\n \n         assert!(!oflo, \"capacity overflow\");\n \n@@ -630,8 +630,8 @@ impl<K, V> RawTable<K, V> {\n         let buffer = *self.hashes as *mut u8;\n         let (keys_offset, vals_offset, oflo) =\n             calculate_offsets(hashes_size,\n-                              keys_size, min_align_of::<K>(),\n-                              min_align_of::<V>());\n+                              keys_size, align_of::<K>(),\n+                              align_of::<V>());\n         debug_assert!(!oflo, \"capacity overflow\");\n         unsafe {\n             RawBucket {\n@@ -1005,9 +1005,9 @@ impl<K, V> Drop for RawTable<K, V> {\n         let keys_size = self.capacity * size_of::<K>();\n         let vals_size = self.capacity * size_of::<V>();\n         let (align, _, size, oflo) =\n-            calculate_allocation(hashes_size, min_align_of::<u64>(),\n-                                 keys_size, min_align_of::<K>(),\n-                                 vals_size, min_align_of::<V>());\n+            calculate_allocation(hashes_size, align_of::<u64>(),\n+                                 keys_size, align_of::<K>(),\n+                                 vals_size, align_of::<V>());\n \n         debug_assert!(!oflo, \"should be impossible\");\n "}]}