{"sha": "af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "node_id": "C_kwDOAAsO6NoAKGFmOTBlYzgwOTY1ZTExZGZkYWY0YzRlODRlOWEwNzRhZmZiMjRmN2M", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-04T20:08:04Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-06T17:39:09Z"}, "message": "Partially support \"overloaded deref\" MIR lowering", "tree": {"sha": "eb8480ebdfc06b869159487865c4741db38b719e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb8480ebdfc06b869159487865c4741db38b719e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "html_url": "https://github.com/rust-lang/rust/commit/af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf0f99f15ddc00ddc49eb357764a58aaf7a93b02", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf0f99f15ddc00ddc49eb357764a58aaf7a93b02", "html_url": "https://github.com/rust-lang/rust/commit/bf0f99f15ddc00ddc49eb357764a58aaf7a93b02"}], "stats": {"total": 843, "additions": 546, "deletions": 297}, "files": [{"sha": "545d2bebf5f0d6349bf92d0ced03b36350ccd625", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -422,13 +422,6 @@ impl Body {\n         }\n     }\n \n-    pub fn walk_child_bindings(&self, pat: PatId, f: &mut impl FnMut(BindingId)) {\n-        if let Pat::Bind { id, .. } = self[pat] {\n-            f(id)\n-        }\n-        self[pat].walk_child_pats(|p| self.walk_child_bindings(p, f));\n-    }\n-\n     pub fn pretty_print(&self, db: &dyn DefDatabase, owner: DefWithBodyId) -> String {\n         pretty::print_body_hir(db, self, owner)\n     }"}, {"sha": "f2e42d6e5035b3fd85d6a338db2feaaab14c61a5", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -148,6 +148,60 @@ fn reference_autoderef() {\n     );\n }\n \n+#[test]\n+fn overloaded_deref() {\n+    // FIXME: We should support this.\n+    check_fail(\n+        r#\"\n+    //- minicore: deref_mut\n+    struct Foo;\n+\n+    impl core::ops::Deref for Foo {\n+        type Target = i32;\n+        fn deref(&self) -> &i32 {\n+            &5\n+        }\n+    }\n+\n+    const GOAL: i32 = {\n+        let x = Foo;\n+        let y = &*x;\n+        *y + *x\n+    };\n+    \"#,\n+        ConstEvalError::MirLowerError(MirLowerError::NotSupported(\n+            \"explicit overloaded deref\".into(),\n+        )),\n+    );\n+}\n+\n+#[test]\n+fn overloaded_deref_autoref() {\n+    check_number(\n+        r#\"\n+    //- minicore: deref_mut\n+    struct Foo;\n+    struct Bar;\n+\n+    impl core::ops::Deref for Foo {\n+        type Target = Bar;\n+        fn deref(&self) -> &Bar {\n+            &Bar\n+        }\n+    }\n+\n+    impl Bar {\n+        fn method(&self) -> i32 {\n+            5\n+        }\n+    }\n+\n+    const GOAL: i32 = Foo.method();\n+    \"#,\n+        5,\n+    );\n+}\n+\n #[test]\n fn function_call() {\n     check_number("}, {"sha": "3a75f8712112e62dd4d82d21f9e358338bf69c40", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -291,8 +291,10 @@ pub enum Adjust {\n /// call, with the signature `&'a T -> &'a U` or `&'a mut T -> &'a mut U`.\n /// The target type is `U` in both cases, with the region and mutability\n /// being those shared by both the receiver and the returned reference.\n+///\n+/// Mutability is `None` when we are not sure.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct OverloadedDeref(pub Mutability);\n+pub struct OverloadedDeref(pub Option<Mutability>);\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum AutoBorrow {\n@@ -355,7 +357,7 @@ pub struct InferenceResult {\n     pub type_of_binding: ArenaMap<BindingId, Ty>,\n     pub type_of_rpit: ArenaMap<RpitId, Ty>,\n     /// Type of the result of `.into_iter()` on the for. `ExprId` is the one of the whole for loop.\n-    pub type_of_for_iterator: ArenaMap<ExprId, Ty>,\n+    pub type_of_for_iterator: FxHashMap<ExprId, Ty>,\n     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch>,\n     /// Interned common types to return references to.\n     standard_types: InternedStandardTypes,"}, {"sha": "48c91530266dfbcaa5c13e94848cdc4ebef54249", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -693,7 +693,7 @@ pub(super) fn auto_deref_adjust_steps(autoderef: &Autoderef<'_, '_>) -> Vec<Adju\n         .iter()\n         .map(|(kind, _source)| match kind {\n             // We do not know what kind of deref we require at this point yet\n-            AutoderefKind::Overloaded => Some(OverloadedDeref(Mutability::Not)),\n+            AutoderefKind::Overloaded => Some(OverloadedDeref(None)),\n             AutoderefKind::Builtin => None,\n         })\n         .zip(targets)"}, {"sha": "0f49e837881834fd71668a863df35d9bbfbc9d89", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -5,7 +5,10 @@ use std::iter::repeat_with;\n use chalk_ir::Mutability;\n use hir_def::{\n     body::Body,\n-    expr::{Binding, BindingAnnotation, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId, RecordFieldPat, BindingId},\n+    expr::{\n+        Binding, BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId,\n+        RecordFieldPat,\n+    },\n     path::Path,\n };\n use hir_expand::name::Name;"}, {"sha": "92a17fc3a99728020c4b20047610d129b435bc79", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -579,8 +579,8 @@ impl ReceiverAdjustments {\n                     ty = new_ty.clone();\n                     adjust.push(Adjustment {\n                         kind: Adjust::Deref(match kind {\n-                            // FIXME should we know the mutability here?\n-                            AutoderefKind::Overloaded => Some(OverloadedDeref(Mutability::Not)),\n+                            // FIXME should we know the mutability here, when autoref is `None`?\n+                            AutoderefKind::Overloaded => Some(OverloadedDeref(self.autoref)),\n                             AutoderefKind::Builtin => None,\n                         }),\n                         target: new_ty,"}, {"sha": "4cb5dece76d7d0f55d5230b9b33ab1787f97da6e", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 194, "deletions": 273, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -11,19 +11,23 @@ use hir_def::{\n     },\n     lang_item::{LangItem, LangItemTarget},\n     layout::LayoutError,\n+    path::Path,\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n     DefWithBodyId, EnumVariantId, HasModule,\n };\n+use hir_expand::name;\n use la_arena::ArenaMap;\n \n use crate::{\n     consteval::ConstEvalError, db::HirDatabase, display::HirDisplay, infer::TypeMismatch,\n     inhabitedness::is_ty_uninhabited_from, layout::layout_of_ty, mapping::ToChalk, static_lifetime,\n-    utils::generics, Adjust, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n+    utils::generics, Adjust, Adjustment, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n };\n \n use super::*;\n \n+mod as_place;\n+\n #[derive(Debug, Clone, Copy)]\n struct LoopBlocks {\n     begin: BasicBlockId,\n@@ -61,6 +65,7 @@ pub enum MirLowerError {\n     /// Something that should never happen and is definitely a bug, but we don't want to panic if it happened\n     ImplementationError(&'static str),\n     LangItemNotFound(LangItem),\n+    MutatingRvalue,\n }\n \n macro_rules! not_supported {\n@@ -69,6 +74,13 @@ macro_rules! not_supported {\n     };\n }\n \n+macro_rules! implementation_error {\n+    ($x: expr) => {{\n+        ::stdx::never!(\"MIR lower implementation bug: {}\", $x);\n+        return Err(MirLowerError::ImplementationError($x));\n+    }};\n+}\n+\n impl From<ConstEvalError> for MirLowerError {\n     fn from(value: ConstEvalError) -> Self {\n         match value {\n@@ -84,117 +96,89 @@ impl From<LayoutError> for MirLowerError {\n     }\n }\n \n+impl MirLowerError {\n+    fn unresolved_path(db: &dyn HirDatabase, p: &Path) -> Self {\n+        Self::UnresolvedName(p.display(db).to_string())\n+    }\n+}\n+\n type Result<T> = std::result::Result<T, MirLowerError>;\n \n impl MirLowerCtx<'_> {\n     fn temp(&mut self, ty: Ty) -> Result<LocalId> {\n         if matches!(ty.kind(Interner), TyKind::Slice(_) | TyKind::Dyn(_)) {\n-            not_supported!(\"unsized temporaries\");\n+            implementation_error!(\"unsized temporaries\");\n         }\n         Ok(self.result.locals.alloc(Local { ty }))\n     }\n \n-    fn lower_expr_as_place(&self, expr_id: ExprId) -> Option<Place> {\n-        let adjustments = self.infer.expr_adjustments.get(&expr_id);\n-        let mut r = self.lower_expr_as_place_without_adjust(expr_id)?;\n-        for adjustment in adjustments.iter().flat_map(|x| x.iter()) {\n-            match adjustment.kind {\n-                Adjust::NeverToAny => return Some(r),\n-                Adjust::Deref(None) => {\n-                    r.projection.push(ProjectionElem::Deref);\n-                }\n-                Adjust::Deref(Some(_)) => return None,\n-                Adjust::Borrow(_) => return None,\n-                Adjust::Pointer(_) => return None,\n-            }\n-        }\n-        Some(r)\n-    }\n-\n-    fn lower_expr_as_place_without_adjust(&self, expr_id: ExprId) -> Option<Place> {\n-        match &self.body.exprs[expr_id] {\n-            Expr::Path(p) => {\n-                let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n-                let pr = resolver.resolve_path_in_value_ns(self.db.upcast(), p.mod_path())?;\n-                let pr = match pr {\n-                    ResolveValueResult::ValueNs(v) => v,\n-                    ResolveValueResult::Partial(..) => return None,\n-                };\n-                match pr {\n-                    ValueNs::LocalBinding(pat_id) => {\n-                        Some(self.result.binding_locals[pat_id].into())\n-                    }\n-                    _ => None,\n-                }\n-            }\n-            Expr::UnaryOp { expr, op } => match op {\n-                hir_def::expr::UnaryOp::Deref => {\n-                    if !matches!(\n-                        self.expr_ty(*expr).kind(Interner),\n-                        TyKind::Ref(..) | TyKind::Raw(..)\n-                    ) {\n-                        return None;\n-                    }\n-                    let mut r = self.lower_expr_as_place(*expr)?;\n-                    r.projection.push(ProjectionElem::Deref);\n-                    Some(r)\n-                }\n-                _ => None,\n-            },\n-            Expr::Field { expr, .. } => {\n-                let mut r = self.lower_expr_as_place(*expr)?;\n-                self.push_field_projection(&mut r, expr_id).ok()?;\n-                Some(r)\n-            }\n-            _ => None,\n-        }\n-    }\n-\n     fn lower_expr_to_some_operand(\n         &mut self,\n         expr_id: ExprId,\n         current: BasicBlockId,\n-    ) -> Result<(Operand, Option<BasicBlockId>)> {\n+    ) -> Result<Option<(Operand, BasicBlockId)>> {\n         if !self.has_adjustments(expr_id) {\n             match &self.body.exprs[expr_id] {\n                 Expr::Literal(l) => {\n                     let ty = self.expr_ty(expr_id);\n-                    return Ok((self.lower_literal_to_operand(ty, l)?, Some(current)));\n+                    return Ok(Some((self.lower_literal_to_operand(ty, l)?, current)));\n                 }\n                 _ => (),\n             }\n         }\n-        let (p, current) = self.lower_expr_to_some_place(expr_id, current)?;\n-        Ok((Operand::Copy(p), current))\n-    }\n-\n-    fn lower_expr_to_some_place(\n-        &mut self,\n-        expr_id: ExprId,\n-        prev_block: BasicBlockId,\n-    ) -> Result<(Place, Option<BasicBlockId>)> {\n-        if let Some(p) = self.lower_expr_as_place(expr_id) {\n-            return Ok((p, Some(prev_block)));\n-        }\n-        let ty = self.expr_ty_after_adjustments(expr_id);\n-        let place = self.temp(ty)?;\n-        Ok((place.into(), self.lower_expr_to_place(expr_id, place.into(), prev_block)?))\n+        let Some((p, current)) = self.lower_expr_as_place(current, expr_id, true)? else {\n+            return Ok(None);\n+        };\n+        Ok(Some((Operand::Copy(p), current)))\n     }\n \n-    fn lower_expr_to_some_place_without_adjust(\n+    fn lower_expr_to_place_with_adjust(\n         &mut self,\n         expr_id: ExprId,\n-        prev_block: BasicBlockId,\n-    ) -> Result<(Place, Option<BasicBlockId>)> {\n-        if let Some(p) = self.lower_expr_as_place_without_adjust(expr_id) {\n-            return Ok((p, Some(prev_block)));\n+        place: Place,\n+        current: BasicBlockId,\n+        adjustments: &[Adjustment],\n+    ) -> Result<Option<BasicBlockId>> {\n+        match adjustments.split_last() {\n+            Some((last, rest)) => match &last.kind {\n+                Adjust::NeverToAny => {\n+                    let temp = self.temp(TyKind::Never.intern(Interner))?;\n+                    self.lower_expr_to_place_with_adjust(expr_id, temp.into(), current, rest)\n+                }\n+                Adjust::Deref(_) => {\n+                    let Some((p, current)) = self.lower_expr_as_place_with_adjust(current, expr_id, true, adjustments)? else {\n+                            return Ok(None);\n+                        };\n+                    self.push_assignment(current, place, Operand::Copy(p).into(), expr_id.into());\n+                    Ok(Some(current))\n+                }\n+                Adjust::Borrow(AutoBorrow::Ref(m) | AutoBorrow::RawPtr(m)) => {\n+                    let Some((p, current)) = self.lower_expr_as_place_with_adjust(current, expr_id, true, rest)? else {\n+                            return Ok(None);\n+                        };\n+                    let bk = BorrowKind::from_chalk(*m);\n+                    self.push_assignment(current, place, Rvalue::Ref(bk, p), expr_id.into());\n+                    Ok(Some(current))\n+                }\n+                Adjust::Pointer(cast) => {\n+                    let Some((p, current)) = self.lower_expr_as_place_with_adjust(current, expr_id, true, rest)? else {\n+                            return Ok(None);\n+                        };\n+                    self.push_assignment(\n+                        current,\n+                        place,\n+                        Rvalue::Cast(\n+                            CastKind::Pointer(cast.clone()),\n+                            Operand::Copy(p).into(),\n+                            last.target.clone(),\n+                        ),\n+                        expr_id.into(),\n+                    );\n+                    Ok(Some(current))\n+                }\n+            },\n+            None => self.lower_expr_to_place_without_adjust(expr_id, place, current),\n         }\n-        let ty = self.expr_ty(expr_id);\n-        let place = self.temp(ty)?;\n-        Ok((\n-            place.into(),\n-            self.lower_expr_to_place_without_adjust(expr_id, place.into(), prev_block)?,\n-        ))\n     }\n \n     fn lower_expr_to_place(\n@@ -203,50 +187,8 @@ impl MirLowerCtx<'_> {\n         place: Place,\n         prev_block: BasicBlockId,\n     ) -> Result<Option<BasicBlockId>> {\n-        if let Some(x) = self.infer.expr_adjustments.get(&expr_id) {\n-            if x.len() > 0 {\n-                let (mut r, Some(current)) =\n-                    self.lower_expr_to_some_place_without_adjust(expr_id, prev_block)?\n-                else {\n-                    return Ok(None);\n-                };\n-                for adjustment in x {\n-                    match &adjustment.kind {\n-                        Adjust::NeverToAny => (),\n-                        Adjust::Deref(None) => {\n-                            r.projection.push(ProjectionElem::Deref);\n-                        }\n-                        Adjust::Deref(Some(_)) => not_supported!(\"implicit overloaded dereference\"),\n-                        Adjust::Borrow(AutoBorrow::Ref(m) | AutoBorrow::RawPtr(m)) => {\n-                            let tmp = self.temp(adjustment.target.clone())?;\n-                            self.push_assignment(\n-                                current,\n-                                tmp.into(),\n-                                Rvalue::Ref(BorrowKind::from_chalk(*m), r),\n-                                expr_id.into(),\n-                            );\n-                            r = tmp.into();\n-                        }\n-                        Adjust::Pointer(cast) => {\n-                            let target = &adjustment.target;\n-                            let tmp = self.temp(target.clone())?;\n-                            self.push_assignment(\n-                                current,\n-                                tmp.into(),\n-                                Rvalue::Cast(\n-                                    CastKind::Pointer(cast.clone()),\n-                                    Operand::Copy(r).into(),\n-                                    target.clone(),\n-                                ),\n-                                expr_id.into(),\n-                            );\n-                            r = tmp.into();\n-                        }\n-                    }\n-                }\n-                self.push_assignment(current, place, Operand::Copy(r).into(), expr_id.into());\n-                return Ok(Some(current));\n-            }\n+        if let Some(adjustments) = self.infer.expr_adjustments.get(&expr_id) {\n+            return self.lower_expr_to_place_with_adjust(expr_id, place, prev_block, adjustments);\n         }\n         self.lower_expr_to_place_without_adjust(expr_id, place, prev_block)\n     }\n@@ -260,7 +202,7 @@ impl MirLowerCtx<'_> {\n         match &self.body.exprs[expr_id] {\n             Expr::Missing => Err(MirLowerError::IncompleteExpr),\n             Expr::Path(p) => {\n-                let unresolved_name = || MirLowerError::UnresolvedName(p.display(self.db).to_string());\n+                let unresolved_name = || MirLowerError::unresolved_path(self.db, p);\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n                 let pr = resolver\n                     .resolve_path_in_value_ns(self.db.upcast(), p.mod_path())\n@@ -286,7 +228,7 @@ impl MirLowerCtx<'_> {\n                             match variant {\n                                 VariantId::EnumVariantId(e) => ValueNs::EnumVariantId(e),\n                                 VariantId::StructId(s) => ValueNs::StructId(s),\n-                                VariantId::UnionId(_) => return Err(MirLowerError::ImplementationError(\"Union variant as path\")),\n+                                VariantId::UnionId(_) => implementation_error!(\"Union variant as path\"),\n                             }\n                         } else {\n                             return Err(unresolved_name());\n@@ -355,7 +297,7 @@ impl MirLowerCtx<'_> {\n                 }\n             }\n             Expr::If { condition, then_branch, else_branch } => {\n-                let (discr, Some(current)) = self.lower_expr_to_some_operand(*condition, current)? else {\n+                let Some((discr, current)) = self.lower_expr_to_some_operand(*condition, current)? else {\n                     return Ok(None);\n                 };\n                 let start_of_then = self.new_basic_block();\n@@ -377,8 +319,7 @@ impl MirLowerCtx<'_> {\n                 Ok(self.merge_blocks(end_of_then, end_of_else))\n             }\n             Expr::Let { pat, expr } => {\n-                self.push_storage_live(*pat, current)?;\n-                let (cond_place, Some(current)) = self.lower_expr_to_some_place(*expr, current)? else {\n+                let Some((cond_place, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n                     return Ok(None);\n                 };\n                 let (then_target, else_target) = self.pattern_match(\n@@ -411,70 +352,17 @@ impl MirLowerCtx<'_> {\n                 self.lower_block_to_place(None, statements, current, *tail, place)\n             }\n             Expr::Block { id: _, statements, tail, label } => {\n-                if label.is_some() {\n-                    not_supported!(\"block with label\");\n-                }\n-                for statement in statements.iter() {\n-                    match statement {\n-                        hir_def::expr::Statement::Let {\n-                            pat,\n-                            initializer,\n-                            else_branch,\n-                            type_ref: _,\n-                        } => {\n-                            self.push_storage_live(*pat, current)?;\n-                            if let Some(expr_id) = initializer {\n-                            let else_block;\n-                            let (init_place, Some(c)) =\n-                                self.lower_expr_to_some_place(*expr_id, current)?\n-                            else {\n-                                return Ok(None);\n-                            };\n-                            current = c;\n-                            (current, else_block) = self.pattern_match(\n-                                current,\n-                                None,\n-                                init_place,\n-                                self.expr_ty_after_adjustments(*expr_id),\n-                                *pat,\n-                                BindingAnnotation::Unannotated,\n-                            )?;\n-                            match (else_block, else_branch) {\n-                                (None, _) => (),\n-                                (Some(else_block), None) => {\n-                                    self.set_terminator(else_block, Terminator::Unreachable);\n-                                }\n-                                (Some(else_block), Some(else_branch)) => {\n-                                    let (_, b) = self\n-                                        .lower_expr_to_some_place(*else_branch, else_block)?;\n-                                    if let Some(b) = b {\n-                                        self.set_terminator(b, Terminator::Unreachable);\n-                                    }\n-                                }\n-                            }\n-                        } },\n-                        hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n-                            let (_, Some(c)) = self.lower_expr_to_some_place(*expr, current)? else {\n-                                return Ok(None);\n-                            };\n-                            current = c;\n-                        }\n-                    }\n-                }\n-                match tail {\n-                    Some(tail) => self.lower_expr_to_place(*tail, place, current),\n-                    None => Ok(Some(current)),\n-                }\n+                self.lower_block_to_place(*label, statements, current, *tail, place)\n             }\n             Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin| {\n-                if let (_, Some(block)) = this.lower_expr_to_some_place(*body, begin)? {\n+                if let Some((_, block)) = this.lower_expr_as_place(begin, *body, true)? {\n                     this.set_goto(block, begin);\n                 }\n                 Ok(())\n             }),\n             Expr::While { condition, body, label } => {\n                 self.lower_loop(current, *label, |this, begin| {\n-                    let (discr, Some(to_switch)) = this.lower_expr_to_some_operand(*condition, begin)? else {\n+                    let Some((discr, to_switch)) = this.lower_expr_to_some_operand(*condition, begin)? else {\n                         return Ok(());\n                     };\n                     let end = this.current_loop_end()?;\n@@ -486,7 +374,7 @@ impl MirLowerCtx<'_> {\n                             targets: SwitchTargets::static_if(1, after_cond, end),\n                         },\n                     );\n-                    if let (_, Some(block)) = this.lower_expr_to_some_place(*body, after_cond)? {\n+                    if let Some((_, block)) = this.lower_expr_as_place(after_cond, *body, true)? {\n                         this.set_goto(block, begin);\n                     }\n                     Ok(())\n@@ -510,7 +398,9 @@ impl MirLowerCtx<'_> {\n                         self.db.intern_callable_def(CallableDefId::FunctionId(iter_next_fn)).into(),\n                         Substitution::from1(Interner, self.expr_ty(iterable))\n                     ).intern(Interner));\n-                let iterator_ty = &self.infer.type_of_for_iterator[expr_id];\n+                let &Some(iterator_ty) = &self.infer.type_of_for_iterator.get(&expr_id) else {\n+                    return Err(MirLowerError::TypeError(\"unknown for loop iterator type\"));\n+                };\n                 let ref_mut_iterator_ty = TyKind::Ref(Mutability::Mut, static_lifetime(), iterator_ty.clone()).intern(Interner);\n                 let item_ty = &self.infer.type_of_pat[pat];\n                 let option_item_ty = TyKind::Adt(chalk_ir::AdtId(option.into()), Substitution::from1(Interner, item_ty.clone())).intern(Interner);\n@@ -523,7 +413,6 @@ impl MirLowerCtx<'_> {\n                 };\n                 self.push_assignment(current, ref_mut_iterator_place.clone(), Rvalue::Ref(BorrowKind::Mut { allow_two_phase_borrow: false }, iterator_place), expr_id.into());\n                 self.lower_loop(current, label, |this, begin| {\n-                    this.push_storage_live(pat, begin)?;\n                     let Some(current) = this.lower_call(iter_next_fn_op, vec![Operand::Copy(ref_mut_iterator_place)], option_item_place.clone(), begin, false)?\n                     else {\n                         return Ok(());\n@@ -538,7 +427,7 @@ impl MirLowerCtx<'_> {\n                         pat.into(),\n                         Some(end),\n                         &[pat], &None)?;\n-                    if let (_, Some(block)) = this.lower_expr_to_some_place(body, current)? {\n+                    if let Some((_, block)) = this.lower_expr_as_place(current, body, true)? {\n                         this.set_goto(block, begin);\n                     }\n                     Ok(())\n@@ -595,7 +484,7 @@ impl MirLowerCtx<'_> {\n                 )\n             }\n             Expr::Match { expr, arms } => {\n-                let (cond_place, Some(mut current)) = self.lower_expr_to_some_place(*expr, current)?\n+                let Some((cond_place, mut current)) = self.lower_expr_as_place(current, *expr, true)?\n                 else {\n                     return Ok(None);\n                 };\n@@ -605,7 +494,6 @@ impl MirLowerCtx<'_> {\n                     if guard.is_some() {\n                         not_supported!(\"pattern matching with guard\");\n                     }\n-                    self.push_storage_live(*pat, current)?;\n                     let (then, otherwise) = self.pattern_match(\n                         current,\n                         None,\n@@ -686,7 +574,7 @@ impl MirLowerCtx<'_> {\n                         for RecordLitField { name, expr } in fields.iter() {\n                             let field_id =\n                                 variant_data.field(name).ok_or(MirLowerError::UnresolvedField)?;\n-                            let (op, Some(c)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                            let Some((op, c)) = self.lower_expr_to_some_operand(*expr, current)? else {\n                                 return Ok(None);\n                             };\n                             current = c;\n@@ -719,27 +607,14 @@ impl MirLowerCtx<'_> {\n                     }\n                 }\n             }\n-            Expr::Field { expr, .. } => {\n-                let (mut current_place, Some(current)) = self.lower_expr_to_some_place(*expr, current)? else {\n-                    return Ok(None);\n-                };\n-                self.push_field_projection(&mut current_place, expr_id)?;\n-                self.push_assignment(\n-                    current,\n-                    place,\n-                    Operand::Copy(current_place).into(),\n-                    expr_id.into(),\n-                );\n-                Ok(Some(current))\n-            }\n             Expr::Await { .. } => not_supported!(\"await\"),\n             Expr::Try { .. } => not_supported!(\"? operator\"),\n             Expr::Yeet { .. } => not_supported!(\"yeet\"),\n             Expr::TryBlock { .. } => not_supported!(\"try block\"),\n             Expr::Async { .. } => not_supported!(\"async block\"),\n             Expr::Const { .. } => not_supported!(\"anonymous const block\"),\n             Expr::Cast { expr, type_ref: _ } => {\n-                let (x, Some(current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                let Some((x, current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n                     return Ok(None);\n                 };\n                 let source_ty = self.infer[*expr].clone();\n@@ -753,63 +628,59 @@ impl MirLowerCtx<'_> {\n                 Ok(Some(current))\n             }\n             Expr::Ref { expr, rawness: _, mutability } => {\n-                let (p, Some(current)) = self.lower_expr_to_some_place(*expr, current)? else {\n+                let Some((p, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n                     return Ok(None);\n                 };\n                 let bk = BorrowKind::from_hir(*mutability);\n                 self.push_assignment(current, place, Rvalue::Ref(bk, p), expr_id.into());\n                 Ok(Some(current))\n             }\n             Expr::Box { .. } => not_supported!(\"box expression\"),\n-            Expr::UnaryOp { expr, op } => match op {\n-                hir_def::expr::UnaryOp::Deref => {\n-                    if !matches!(self.expr_ty(*expr).kind(Interner), TyKind::Ref(..) | TyKind::Raw(..)) {\n-                        not_supported!(\"explicit overloaded deref\");\n-                    }\n-                    let (mut tmp, Some(current)) = self.lower_expr_to_some_place(*expr, current)? else {\n-                        return Ok(None);\n-                    };\n-                    tmp.projection.push(ProjectionElem::Deref);\n-                    self.push_assignment(current, place, Operand::Copy(tmp).into(), expr_id.into());\n-                    Ok(Some(current))\n-                }\n-                hir_def::expr::UnaryOp::Not | hir_def::expr::UnaryOp::Neg => {\n-                    let (operand, Some(current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n-                        return Ok(None);\n-                    };\n-                    let operation = match op {\n-                        hir_def::expr::UnaryOp::Not => UnOp::Not,\n-                        hir_def::expr::UnaryOp::Neg => UnOp::Neg,\n-                        _ => unreachable!(),\n-                    };\n-                    self.push_assignment(\n-                        current,\n-                        place,\n-                        Rvalue::UnaryOp(operation, operand),\n-                        expr_id.into(),\n-                    );\n-                    Ok(Some(current))\n-                }\n+            Expr::Field { .. } | Expr::Index { .. } | Expr::UnaryOp { op: hir_def::expr::UnaryOp::Deref, .. } => {\n+                let Some((p, current)) = self.lower_expr_as_place(current, expr_id, true)? else {\n+                    return Ok(None);\n+                };\n+                self.push_assignment(current, place, Operand::Copy(p).into(), expr_id.into());\n+                Ok(Some(current))\n+            }\n+            Expr::UnaryOp { expr, op: op @ (hir_def::expr::UnaryOp::Not | hir_def::expr::UnaryOp::Neg) } => {\n+                let Some((operand, current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                    return Ok(None);\n+                };\n+                let operation = match op {\n+                    hir_def::expr::UnaryOp::Not => UnOp::Not,\n+                    hir_def::expr::UnaryOp::Neg => UnOp::Neg,\n+                    _ => unreachable!(),\n+                };\n+                self.push_assignment(\n+                    current,\n+                    place,\n+                    Rvalue::UnaryOp(operation, operand),\n+                    expr_id.into(),\n+                );\n+                Ok(Some(current))\n             },\n             Expr::BinaryOp { lhs, rhs, op } => {\n                 let op = op.ok_or(MirLowerError::IncompleteExpr)?;\n                 if let hir_def::expr::BinaryOp::Assignment { op } = op {\n                     if op.is_some() {\n                         not_supported!(\"assignment with arith op (like +=)\");\n                     }\n-                    let Some(lhs_place) = self.lower_expr_as_place(*lhs) else {\n-                        not_supported!(\"assignment to complex place\");\n+                    let Some((lhs_place, current)) =\n+                        self.lower_expr_as_place(current, *lhs, false)?\n+                    else {\n+                        return Ok(None);\n                     };\n-                    let (rhs_op, Some(current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n+                    let Some((rhs_op, current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n                         return Ok(None);\n                     };\n                     self.push_assignment(current, lhs_place, rhs_op.into(), expr_id.into());\n                     return Ok(Some(current));\n                 }\n-                let (lhs_op, Some(current)) = self.lower_expr_to_some_operand(*lhs, current)? else {\n+                let Some((lhs_op, current)) = self.lower_expr_to_some_operand(*lhs, current)? else {\n                     return Ok(None);\n                 };\n-                let (rhs_op, Some(current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n+                let Some((rhs_op, current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n                     return Ok(None);\n                 };\n                 self.push_assignment(\n@@ -833,24 +704,12 @@ impl MirLowerCtx<'_> {\n                 Ok(Some(current))\n             }\n             Expr::Range { .. } => not_supported!(\"range\"),\n-            Expr::Index { base, index } => {\n-                let (mut p_base, Some(current)) = self.lower_expr_to_some_place(*base, current)?  else {\n-                    return Ok(None);\n-                };\n-                let l_index = self.temp(self.expr_ty_after_adjustments(*index))?;\n-                let Some(current) = self.lower_expr_to_place(*index, l_index.into(), current)? else {\n-                    return Ok(None);\n-                };\n-                p_base.projection.push(ProjectionElem::Index(l_index));\n-                self.push_assignment(current, place, Operand::Copy(p_base).into(), expr_id.into());\n-                Ok(Some(current))\n-            }\n             Expr::Closure { .. } => not_supported!(\"closure\"),\n             Expr::Tuple { exprs, is_assignee_expr: _ } => {\n                 let Some(values) = exprs\n                         .iter()\n                         .map(|x| {\n-                            let (o, Some(c)) = self.lower_expr_to_some_operand(*x, current)? else {\n+                            let Some((o, c)) = self.lower_expr_to_some_operand(*x, current)? else {\n                                 return Ok(None);\n                             };\n                             current = c;\n@@ -880,7 +739,7 @@ impl MirLowerCtx<'_> {\n                     let Some(values) = elements\n                             .iter()\n                             .map(|x| {\n-                                let (o, Some(c)) = self.lower_expr_to_some_operand(*x, current)? else {\n+                                let Some((o, c)) = self.lower_expr_to_some_operand(*x, current)? else {\n                                     return Ok(None);\n                                 };\n                                 current = c;\n@@ -1034,7 +893,7 @@ impl MirLowerCtx<'_> {\n     ) -> Result<Option<BasicBlockId>> {\n         let Some(args) = args\n             .map(|arg| {\n-                if let (temp, Some(c)) = self.lower_expr_to_some_operand(arg, current)? {\n+                if let Some((temp, c)) = self.lower_expr_to_some_operand(arg, current)? {\n                     current = c;\n                     Ok(Some(temp))\n                 } else {\n@@ -1250,6 +1109,7 @@ impl MirLowerCtx<'_> {\n                 if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n                     binding_mode = mode;\n                 }\n+                self.push_storage_live(*id, current)?;\n                 self.push_assignment(\n                     current,\n                     target_place.into(),\n@@ -1464,7 +1324,7 @@ impl MirLowerCtx<'_> {\n     }\n \n     /// This function push `StorageLive` statements for each binding in the pattern.\n-    fn push_storage_live(&mut self, pat: PatId, current: BasicBlockId) -> Result<()> {\n+    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) -> Result<()> {\n         // Current implementation is wrong. It adds no `StorageDead` at the end of scope, and before each break\n         // and continue. It just add a `StorageDead` before the `StorageLive`, which is not wrong, but unneeeded in\n         // the proper implementation. Due this limitation, implementing a borrow checker on top of this mir will falsely\n@@ -1483,19 +1343,81 @@ impl MirLowerCtx<'_> {\n         // ```\n         // But I think this approach work for mutability analysis, as user can't write code which mutates a binding\n         // after StorageDead, except loops, which are handled by this hack.\n-        let span = pat.into();\n-        self.body.walk_child_bindings(pat, &mut |b| {\n-            let l = self.result.binding_locals[b];\n-            self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n-            self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n-        });\n+        let span = self.body.bindings[b]\n+            .definitions\n+            .first()\n+            .copied()\n+            .map(MirSpan::PatId)\n+            .unwrap_or(MirSpan::Unknown);\n+        let l = self.result.binding_locals[b];\n+        self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n+        self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n         Ok(())\n     }\n \n     fn resolve_lang_item(&self, item: LangItem) -> Result<LangItemTarget> {\n         let crate_id = self.owner.module(self.db.upcast()).krate();\n         self.db.lang_item(crate_id, item).ok_or(MirLowerError::LangItemNotFound(item))\n     }\n+\n+    fn lower_block_to_place(\n+        &mut self,\n+        label: Option<LabelId>,\n+        statements: &[hir_def::expr::Statement],\n+        mut current: BasicBlockId,\n+        tail: Option<ExprId>,\n+        place: Place,\n+    ) -> Result<Option<Idx<BasicBlock>>> {\n+        if label.is_some() {\n+            not_supported!(\"block with label\");\n+        }\n+        for statement in statements.iter() {\n+            match statement {\n+                hir_def::expr::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n+                    if let Some(expr_id) = initializer {\n+                        let else_block;\n+                        let Some((init_place, c)) =\n+                        self.lower_expr_as_place(current, *expr_id, true)?\n+                    else {\n+                        return Ok(None);\n+                    };\n+                        current = c;\n+                        (current, else_block) = self.pattern_match(\n+                            current,\n+                            None,\n+                            init_place,\n+                            self.expr_ty_after_adjustments(*expr_id),\n+                            *pat,\n+                            BindingAnnotation::Unannotated,\n+                        )?;\n+                        match (else_block, else_branch) {\n+                            (None, _) => (),\n+                            (Some(else_block), None) => {\n+                                self.set_terminator(else_block, Terminator::Unreachable);\n+                            }\n+                            (Some(else_block), Some(else_branch)) => {\n+                                if let Some((_, b)) =\n+                                    self.lower_expr_as_place(else_block, *else_branch, true)?\n+                                {\n+                                    self.set_terminator(b, Terminator::Unreachable);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n+                    let Some((_, c)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                        return Ok(None);\n+                    };\n+                    current = c;\n+                }\n+            }\n+        }\n+        match tail {\n+            Some(tail) => self.lower_expr_to_place(tail, place, current),\n+            None => Ok(Some(current)),\n+        }\n+    }\n }\n \n fn pattern_matching_dereference(\n@@ -1533,7 +1455,8 @@ fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n pub fn mir_body_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Result<Arc<MirBody>> {\n     let body = db.body(def);\n     let infer = db.infer(def);\n-    Ok(Arc::new(lower_to_mir(db, def, &body, &infer, body.body_expr)?))\n+    let result = lower_to_mir(db, def, &body, &infer, body.body_expr)?;\n+    Ok(Arc::new(result))\n }\n \n pub fn mir_body_recover(\n@@ -1553,9 +1476,7 @@ pub fn lower_to_mir(\n     // need to take this input explicitly.\n     root_expr: ExprId,\n ) -> Result<MirBody> {\n-    if let (Some((_, x)), _) | (_, Some((_, x))) =\n-        (infer.expr_type_mismatches().next(), infer.pat_type_mismatches().next())\n-    {\n+    if let Some((_, x)) = infer.type_mismatches().next() {\n         return Err(MirLowerError::TypeMismatch(x.clone()));\n     }\n     let mut basic_blocks = Arena::new();"}, {"sha": "ada52c61ece77ee7e6a9860de622c43e40930b0d", "filename": "crates/hir-ty/src/mir/lower/as_place.rs", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -0,0 +1,236 @@\n+//! MIR lowering for places\n+\n+use super::*;\n+\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirLowerError::NotSupported(format!($x)))\n+    };\n+}\n+\n+impl MirLowerCtx<'_> {\n+    fn lower_expr_to_some_place_without_adjust(\n+        &mut self,\n+        expr_id: ExprId,\n+        prev_block: BasicBlockId,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let ty = self.expr_ty(expr_id);\n+        let place = self.temp(ty)?;\n+        let Some(current) = self.lower_expr_to_place_without_adjust(expr_id, place.into(), prev_block)? else {\n+            return Ok(None);\n+        };\n+        Ok(Some((place.into(), current)))\n+    }\n+\n+    fn lower_expr_to_some_place_with_adjust(\n+        &mut self,\n+        expr_id: ExprId,\n+        prev_block: BasicBlockId,\n+        adjustments: &[Adjustment],\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let ty =\n+            adjustments.last().map(|x| x.target.clone()).unwrap_or_else(|| self.expr_ty(expr_id));\n+        let place = self.temp(ty)?;\n+        let Some(current) = self.lower_expr_to_place_with_adjust(expr_id, place.into(), prev_block, adjustments)? else {\n+            return Ok(None);\n+        };\n+        Ok(Some((place.into(), current)))\n+    }\n+\n+    pub(super) fn lower_expr_as_place_with_adjust(\n+        &mut self,\n+        current: BasicBlockId,\n+        expr_id: ExprId,\n+        upgrade_rvalue: bool,\n+        adjustments: &[Adjustment],\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let try_rvalue = |this: &mut MirLowerCtx<'_>| {\n+            if !upgrade_rvalue {\n+                return Err(MirLowerError::MutatingRvalue);\n+            }\n+            this.lower_expr_to_some_place_with_adjust(expr_id, current, adjustments)\n+        };\n+        if let Some((last, rest)) = adjustments.split_last() {\n+            match last.kind {\n+                Adjust::Deref(None) => {\n+                    let Some(mut x) = self.lower_expr_as_place_with_adjust(\n+                        current,\n+                        expr_id,\n+                        upgrade_rvalue,\n+                        rest,\n+                    )? else {\n+                        return Ok(None);\n+                    };\n+                    x.0.projection.push(ProjectionElem::Deref);\n+                    Ok(Some(x))\n+                }\n+                Adjust::Deref(Some(od)) => {\n+                    let Some((r, current)) = self.lower_expr_as_place_with_adjust(\n+                        current,\n+                        expr_id,\n+                        upgrade_rvalue,\n+                        rest,\n+                    )? else {\n+                        return Ok(None);\n+                    };\n+                    self.lower_overloaded_deref(\n+                        current,\n+                        r,\n+                        rest.last()\n+                            .map(|x| x.target.clone())\n+                            .unwrap_or_else(|| self.expr_ty(expr_id)),\n+                        last.target.clone(),\n+                        expr_id.into(),\n+                        match od.0 {\n+                            Some(Mutability::Mut) => true,\n+                            Some(Mutability::Not) => false,\n+                            None => {\n+                                not_supported!(\"implicit overloaded deref with unknown mutability\")\n+                            }\n+                        },\n+                    )\n+                }\n+                Adjust::NeverToAny | Adjust::Borrow(_) | Adjust::Pointer(_) => try_rvalue(self),\n+            }\n+        } else {\n+            self.lower_expr_as_place_without_adjust(current, expr_id, upgrade_rvalue)\n+        }\n+    }\n+\n+    pub(super) fn lower_expr_as_place(\n+        &mut self,\n+        current: BasicBlockId,\n+        expr_id: ExprId,\n+        upgrade_rvalue: bool,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        match self.infer.expr_adjustments.get(&expr_id) {\n+            Some(a) => self.lower_expr_as_place_with_adjust(current, expr_id, upgrade_rvalue, a),\n+            None => self.lower_expr_as_place_without_adjust(current, expr_id, upgrade_rvalue),\n+        }\n+    }\n+\n+    fn lower_expr_as_place_without_adjust(\n+        &mut self,\n+        current: BasicBlockId,\n+        expr_id: ExprId,\n+        upgrade_rvalue: bool,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let try_rvalue = |this: &mut MirLowerCtx<'_>| {\n+            if !upgrade_rvalue {\n+                return Err(MirLowerError::MutatingRvalue);\n+            }\n+            this.lower_expr_to_some_place_without_adjust(expr_id, current)\n+        };\n+        match &self.body.exprs[expr_id] {\n+            Expr::Path(p) => {\n+                let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n+                let Some(pr) = resolver.resolve_path_in_value_ns(self.db.upcast(), p.mod_path()) else {\n+                    return Err(MirLowerError::unresolved_path(self.db, p));\n+                };\n+                let pr = match pr {\n+                    ResolveValueResult::ValueNs(v) => v,\n+                    ResolveValueResult::Partial(..) => return try_rvalue(self),\n+                };\n+                match pr {\n+                    ValueNs::LocalBinding(pat_id) => {\n+                        Ok(Some((self.result.binding_locals[pat_id].into(), current)))\n+                    }\n+                    _ => try_rvalue(self),\n+                }\n+            }\n+            Expr::UnaryOp { expr, op } => match op {\n+                hir_def::expr::UnaryOp::Deref => {\n+                    if !matches!(\n+                        self.expr_ty(*expr).kind(Interner),\n+                        TyKind::Ref(..) | TyKind::Raw(..)\n+                    ) {\n+                        let Some(_) = self.lower_expr_as_place(current, *expr, true)? else {\n+                            return Ok(None);\n+                        };\n+                        not_supported!(\"explicit overloaded deref\");\n+                    }\n+                    let Some((mut r, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                        return Ok(None);\n+                    };\n+                    r.projection.push(ProjectionElem::Deref);\n+                    Ok(Some((r, current)))\n+                }\n+                _ => try_rvalue(self),\n+            },\n+            Expr::Field { expr, .. } => {\n+                let Some((mut r, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                    return Ok(None);\n+                };\n+                self.push_field_projection(&mut r, expr_id)?;\n+                Ok(Some((r, current)))\n+            }\n+            Expr::Index { base, index } => {\n+                let base_ty = self.expr_ty_after_adjustments(*base);\n+                let index_ty = self.expr_ty_after_adjustments(*index);\n+                if index_ty != TyBuilder::usize()\n+                    || !matches!(base_ty.kind(Interner), TyKind::Array(..) | TyKind::Slice(..))\n+                {\n+                    not_supported!(\"overloaded index\");\n+                }\n+                let Some((mut p_base, current)) =\n+                    self.lower_expr_as_place(current, *base, true)? else {\n+                    return Ok(None);\n+                };\n+                let l_index = self.temp(self.expr_ty_after_adjustments(*index))?;\n+                let Some(current) = self.lower_expr_to_place(*index, l_index.into(), current)? else {\n+                    return Ok(None);\n+                };\n+                p_base.projection.push(ProjectionElem::Index(l_index));\n+                Ok(Some((p_base, current)))\n+            }\n+            _ => try_rvalue(self),\n+        }\n+    }\n+\n+    fn lower_overloaded_deref(\n+        &mut self,\n+        current: BasicBlockId,\n+        place: Place,\n+        source_ty: Ty,\n+        target_ty: Ty,\n+        span: MirSpan,\n+        mutability: bool,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let (chalk_mut, trait_lang_item, trait_method_name, borrow_kind) = if !mutability {\n+            (Mutability::Not, LangItem::Deref, name![deref], BorrowKind::Shared)\n+        } else {\n+            (\n+                Mutability::Mut,\n+                LangItem::DerefMut,\n+                name![deref_mut],\n+                BorrowKind::Mut { allow_two_phase_borrow: false },\n+            )\n+        };\n+        let ty_ref = TyKind::Ref(chalk_mut, static_lifetime(), source_ty.clone()).intern(Interner);\n+        let target_ty_ref = TyKind::Ref(chalk_mut, static_lifetime(), target_ty).intern(Interner);\n+        let ref_place: Place = self.temp(ty_ref)?.into();\n+        self.push_assignment(current, ref_place.clone(), Rvalue::Ref(borrow_kind, place), span);\n+        let deref_trait = self\n+            .resolve_lang_item(trait_lang_item)?\n+            .as_trait()\n+            .ok_or(MirLowerError::LangItemNotFound(trait_lang_item))?;\n+        let deref_fn = self\n+            .db\n+            .trait_data(deref_trait)\n+            .method_by_name(&trait_method_name)\n+            .ok_or(MirLowerError::LangItemNotFound(trait_lang_item))?;\n+        let deref_fn_op = Operand::const_zst(\n+            TyKind::FnDef(\n+                self.db.intern_callable_def(CallableDefId::FunctionId(deref_fn)).into(),\n+                Substitution::from1(Interner, source_ty),\n+            )\n+            .intern(Interner),\n+        );\n+        let mut result: Place = self.temp(target_ty_ref)?.into();\n+        let Some(current) = self.lower_call(deref_fn_op, vec![Operand::Copy(ref_place)], result.clone(), current, false)? else {\n+            return Ok(None);\n+        };\n+        result.projection.push(ProjectionElem::Deref);\n+        Ok(Some((result, current)))\n+    }\n+}"}, {"sha": "b524922b6cf40a61947dd6043a44a382780945f7", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -258,6 +258,7 @@ fn test() {\n \n #[test]\n fn coerce_autoderef_block() {\n+    // FIXME: We should know mutability in overloaded deref\n     check_no_mismatches(\n         r#\"\n //- minicore: deref\n@@ -267,7 +268,7 @@ fn takes_ref_str(x: &str) {}\n fn returns_string() -> String { loop {} }\n fn test() {\n     takes_ref_str(&{ returns_string() });\n-               // ^^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(None), Deref(Some(OverloadedDeref(Not))), Borrow(Ref(Not))\n+               // ^^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(None), Deref(Some(OverloadedDeref(None))), Borrow(Ref(Not))\n }\n \"#,\n     );"}, {"sha": "e568e7013fac0eefd670ecee7e1dd0c8892a1611", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -1252,6 +1252,7 @@ fn foo<T: Trait>(a: &T) {\n \n #[test]\n fn autoderef_visibility_field() {\n+    // FIXME: We should know mutability in overloaded deref\n     check(\n         r#\"\n //- minicore: deref\n@@ -1273,7 +1274,7 @@ mod a {\n mod b {\n     fn foo() {\n         let x = super::a::Bar::new().0;\n-             // ^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(Some(OverloadedDeref(Not)))\n+             // ^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(Some(OverloadedDeref(None)))\n              // ^^^^^^^^^^^^^^^^^^^^^^ type: char\n     }\n }"}, {"sha": "9f6b5c0a9fcc9edf3f1cde479bdbe2058aff3f71", "filename": "crates/hir/src/has_source.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fhas_source.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -11,7 +11,8 @@ use syntax::ast;\n \n use crate::{\n     db::HirDatabase, Adt, Const, Enum, Field, FieldSource, Function, Impl, LifetimeParam,\n-    LocalSource, Macro, Module, Static, Struct, Trait, TypeAlias, TraitAlias, TypeOrConstParam, Union, Variant,\n+    LocalSource, Macro, Module, Static, Struct, Trait, TraitAlias, TypeAlias, TypeOrConstParam,\n+    Union, Variant,\n };\n \n pub trait HasSource {"}, {"sha": "501adde2e725fdcd978ff6d8a204026a3c473cab", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -85,12 +85,12 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n-        MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n-        MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n+        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncorrectCase,\n+        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n+        MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n         ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n-        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n-        UnresolvedProcMacro, UnusedMut,\n+        UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n+        UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},"}, {"sha": "2a0077cf50516f0085db394465b38a6d9732091e", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -1103,7 +1103,10 @@ impl<'db> SemanticsImpl<'db> {\n                     let kind = match adjust.kind {\n                         hir_ty::Adjust::NeverToAny => Adjust::NeverToAny,\n                         hir_ty::Adjust::Deref(Some(hir_ty::OverloadedDeref(m))) => {\n-                            Adjust::Deref(Some(OverloadedDeref(mutability(m))))\n+                            // FIXME: Should we handle unknown mutability better?\n+                            Adjust::Deref(Some(OverloadedDeref(\n+                                m.map(mutability).unwrap_or(Mutability::Shared),\n+                            )))\n                         }\n                         hir_ty::Adjust::Deref(None) => Adjust::Deref(None),\n                         hir_ty::Adjust::Borrow(hir_ty::AutoBorrow::RawPtr(m)) => {"}, {"sha": "b52c36378cf084aa9e08f4371a4b2fa53347e942", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af90ec80965e11dfdaf4c4e84e9a074affb24f7c/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=af90ec80965e11dfdaf4c4e84e9a074affb24f7c", "patch": "@@ -529,6 +529,7 @@ fn f(x: [(i32, u8); 10]) {\n \n     #[test]\n     fn overloaded_deref() {\n+        // FIXME: check for false negative\n         check_diagnostics(\n             r#\"\n //- minicore: deref_mut\n@@ -547,9 +548,42 @@ impl DerefMut for Foo {\n     }\n }\n fn f() {\n-    // FIXME: remove this mut and detect error\n+    let x = Foo;\n+    let y = &*x;\n+    let x = Foo;\n     let mut x = Foo;\n-    let y = &mut *x;\n+    let y: &mut i32 = &mut x;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn or_pattern() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: option\n+fn f(_: i32) {}\n+fn main() {\n+    let ((Some(mut x), None) | (_, Some(mut x))) = (None, Some(7));\n+             //^^^^^ \ud83d\udca1 weak: remove this `mut`\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn respect_allow_unused_mut() {\n+        // FIXME: respect\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    #[allow(unused_mut)]\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: remove this `mut`\n+    f(x);\n }\n \"#,\n         );"}]}