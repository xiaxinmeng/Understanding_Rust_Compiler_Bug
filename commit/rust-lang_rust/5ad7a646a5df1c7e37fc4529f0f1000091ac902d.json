{"sha": "5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "node_id": "C_kwDOAAsO6NoAKDVhZDdhNjQ2YTVkZjFjN2UzN2ZjNDUyOWYwZjEwMDAwOTFhYzkwMmQ", "commit": {"author": {"name": "Ramon de C Valle", "email": "rcvalle@users.noreply.github.com", "date": "2022-04-01T05:50:41Z"}, "committer": {"name": "Ramon de C Valle", "email": "rcvalle@users.noreply.github.com", "date": "2022-07-23T17:51:34Z"}, "message": "Add fine-grained LLVM CFI support to the Rust compiler\n\nThis commit improves the LLVM Control Flow Integrity (CFI) support in\nthe Rust compiler by providing forward-edge control flow protection for\nRust-compiled code only by aggregating function pointers in groups\nidentified by their return and parameter types.\n\nForward-edge control flow protection for C or C++ and Rust -compiled\ncode \"mixed binaries\" (i.e., for when C or C++ and Rust -compiled code\nshare the same virtual address space) will be provided in later work as\npart of this project by identifying C char and integer type uses at the\ntime types are encoded (see Type metadata in the design document in the\ntracking issue #89653).\n\nLLVM CFI can be enabled with -Zsanitizer=cfi and requires LTO (i.e.,\n-Clto).", "tree": {"sha": "8652f20115c37ac54bee675c3f5d027a5e88852f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8652f20115c37ac54bee675c3f5d027a5e88852f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "html_url": "https://github.com/rust-lang/rust/commit/5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/comments", "author": {"login": "rcvalle", "id": 3988004, "node_id": "MDQ6VXNlcjM5ODgwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3988004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rcvalle", "html_url": "https://github.com/rcvalle", "followers_url": "https://api.github.com/users/rcvalle/followers", "following_url": "https://api.github.com/users/rcvalle/following{/other_user}", "gists_url": "https://api.github.com/users/rcvalle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rcvalle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rcvalle/subscriptions", "organizations_url": "https://api.github.com/users/rcvalle/orgs", "repos_url": "https://api.github.com/users/rcvalle/repos", "events_url": "https://api.github.com/users/rcvalle/events{/privacy}", "received_events_url": "https://api.github.com/users/rcvalle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rcvalle", "id": 3988004, "node_id": "MDQ6VXNlcjM5ODgwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3988004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rcvalle", "html_url": "https://github.com/rcvalle", "followers_url": "https://api.github.com/users/rcvalle/followers", "following_url": "https://api.github.com/users/rcvalle/following{/other_user}", "gists_url": "https://api.github.com/users/rcvalle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rcvalle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rcvalle/subscriptions", "organizations_url": "https://api.github.com/users/rcvalle/orgs", "repos_url": "https://api.github.com/users/rcvalle/repos", "events_url": "https://api.github.com/users/rcvalle/events{/privacy}", "received_events_url": "https://api.github.com/users/rcvalle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7", "html_url": "https://github.com/rust-lang/rust/commit/5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7"}], "stats": {"total": 1783, "additions": 1647, "deletions": 136}, "files": [{"sha": "24d5c5d6efc2b333ab1464df05bcf3056c19c970", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -4441,6 +4441,7 @@ dependencies = [\n name = \"rustc_symbol_mangling\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags\",\n  \"punycode\",\n  \"rustc-demangle\",\n  \"rustc_data_structures\","}, {"sha": "5df59438c90eb5b1422370788f33053cfda6e125", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -784,16 +784,6 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn type_metadata(&mut self, _function: RValue<'gcc>, _typeid: String) {\n-        // Unsupported.\n-    }\n-\n-    fn typeid_metadata(&mut self, _typeid: String) -> RValue<'gcc> {\n-        // Unsupported.\n-        self.context.new_rvalue_from_int(self.int_type, 0)\n-    }\n-\n-\n     fn store(&mut self, val: RValue<'gcc>, ptr: RValue<'gcc>, align: Align) -> RValue<'gcc> {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }"}, {"sha": "68bdb8d4e55f4b1183bb479e406b48f7a065e656", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -1,7 +1,7 @@\n use std::convert::TryInto;\n \n use gccjit::{RValue, Struct, Type};\n-use rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods};\n+use rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods, TypeMembershipMethods};\n use rustc_codegen_ssa::common::TypeKind;\n use rustc_middle::{bug, ty};\n use rustc_middle::ty::layout::TyAndLayout;\n@@ -290,3 +290,14 @@ pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout\n \n     (result, packed)\n }\n+\n+impl<'gcc, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn set_type_metadata(&self, _function: RValue<'gcc>, _typeid: String) {\n+        // Unsupported.\n+    }\n+\n+    fn typeid_metadata(&self, _typeid: String) -> RValue<'gcc> {\n+        // Unsupported.\n+        self.context.new_rvalue_from_int(self.int_type, 0)\n+    }\n+}"}, {"sha": "f9a5463efcd8a97c5453f1e0cb4a7fa98bb334f5", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -18,7 +18,6 @@ rustc_middle = { path = \"../rustc_middle\" }\n rustc-demangle = \"0.1.21\"\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n-rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_fs_util = { path = \"../rustc_fs_util\" }\n@@ -30,6 +29,7 @@ rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }"}, {"sha": "d3096c73a8a9ddc603565fb36c8878be8fff0d5e", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -626,32 +626,6 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn type_metadata(&mut self, function: &'ll Value, typeid: String) {\n-        let typeid_metadata = self.typeid_metadata(typeid);\n-        let v = [self.const_usize(0), typeid_metadata];\n-        unsafe {\n-            llvm::LLVMGlobalSetMetadata(\n-                function,\n-                llvm::MD_type as c_uint,\n-                llvm::LLVMValueAsMetadata(llvm::LLVMMDNodeInContext(\n-                    self.cx.llcx,\n-                    v.as_ptr(),\n-                    v.len() as c_uint,\n-                )),\n-            )\n-        }\n-    }\n-\n-    fn typeid_metadata(&mut self, typeid: String) -> Self::Value {\n-        unsafe {\n-            llvm::LLVMMDStringInContext(\n-                self.cx.llcx,\n-                typeid.as_ptr() as *const c_char,\n-                typeid.as_bytes().len() as c_uint,\n-            )\n-        }\n-    }\n-\n     fn store(&mut self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }"}, {"sha": "fa0ecd18fc895bcd7908250d6b970a0834677243", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -18,7 +18,9 @@ use crate::llvm;\n use crate::llvm::AttributePlace::Function;\n use crate::type_::Type;\n use crate::value::Value;\n+use rustc_codegen_ssa::traits::TypeMembershipMethods;\n use rustc_middle::ty::Ty;\n+use rustc_symbol_mangling::typeid::typeid_for_fnabi;\n use smallvec::SmallVec;\n use tracing::debug;\n \n@@ -97,6 +99,12 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             fn_abi.llvm_type(self),\n         );\n         fn_abi.apply_attrs_llfn(self, llfn);\n+\n+        if self.tcx.sess.is_sanitizer_cfi_enabled() {\n+            let typeid = typeid_for_fnabi(self.tcx, fn_abi);\n+            self.set_type_metadata(llfn, typeid);\n+        }\n+\n         llfn\n     }\n "}, {"sha": "eeb38d4ecf591db659db4b03fcde8f1569ac5d3e", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -19,7 +19,7 @@ use rustc_target::abi::{AddressSpace, Align, Integer, Size};\n use std::fmt;\n use std::ptr;\n \n-use libc::c_uint;\n+use libc::{c_char, c_uint};\n \n impl PartialEq for Type {\n     fn eq(&self, other: &Self) -> bool {\n@@ -289,3 +289,31 @@ impl<'ll, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         ty.llvm_type(self)\n     }\n }\n+\n+impl<'ll, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn set_type_metadata(&self, function: &'ll Value, typeid: String) {\n+        let typeid_metadata = self.typeid_metadata(typeid);\n+        let v = [self.const_usize(0), typeid_metadata];\n+        unsafe {\n+            llvm::LLVMGlobalSetMetadata(\n+                function,\n+                llvm::MD_type as c_uint,\n+                llvm::LLVMValueAsMetadata(llvm::LLVMMDNodeInContext(\n+                    self.llcx,\n+                    v.as_ptr(),\n+                    v.len() as c_uint,\n+                )),\n+            )\n+        }\n+    }\n+\n+    fn typeid_metadata(&self, typeid: String) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMMDStringInContext(\n+                self.llcx,\n+                typeid.as_ptr() as *const c_char,\n+                typeid.len() as c_uint,\n+            )\n+        }\n+    }\n+}"}, {"sha": "aefa4086971c4ca3fed7da674cef62798676f765", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Instance, Ty, TypeVisitable};\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n-use rustc_symbol_mangling::typeid_for_fnabi;\n+use rustc_symbol_mangling::typeid::typeid_for_fnabi;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::abi::{self, HasDataLayout, InitKind, WrappingRange};\n use rustc_target::spec::abi::Abi;\n@@ -920,7 +920,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             // FIXME(rcvalle): Add support for generalized identifiers.\n             // FIXME(rcvalle): Create distinct unnamed MDNodes for internal identifiers.\n             let typeid = typeid_for_fnabi(bx.tcx(), fn_abi);\n-            let typeid_metadata = bx.typeid_metadata(typeid);\n+            let typeid_metadata = self.cx.typeid_metadata(typeid);\n \n             // Test whether the function pointer is associated with the type identifier.\n             let cond = bx.type_test(fn_ptr, typeid_metadata);"}, {"sha": "8ee375fa9e3e9811395f746b91af6665e57afed4", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -3,7 +3,6 @@ use rustc_middle::mir;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable, TypeVisitable};\n-use rustc_symbol_mangling::typeid_for_fnabi;\n use rustc_target::abi::call::{FnAbi, PassMode};\n \n use std::iter;\n@@ -247,13 +246,6 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     for (bb, _) in traversal::reverse_postorder(&mir) {\n         fx.codegen_block(bb);\n     }\n-\n-    // For backends that support CFI using type membership (i.e., testing whether a given  pointer\n-    // is associated with a type identifier).\n-    if cx.tcx().sess.is_sanitizer_cfi_enabled() {\n-        let typeid = typeid_for_fnabi(cx.tcx(), fn_abi);\n-        bx.type_metadata(llfn, typeid);\n-    }\n }\n \n /// Produces, for each argument, a `Value` pointing at the"}, {"sha": "3ea01a4ccc398523b135984b0bf271d47b06260c", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -160,8 +160,6 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn range_metadata(&mut self, load: Self::Value, range: WrappingRange);\n     fn nonnull_metadata(&mut self, load: Self::Value);\n-    fn type_metadata(&mut self, function: Self::Function, typeid: String);\n-    fn typeid_metadata(&mut self, typeid: String) -> Self::Value;\n \n     fn store(&mut self, val: Self::Value, ptr: Self::Value, align: Align) -> Self::Value;\n     fn store_with_flags("}, {"sha": "782fdadbfb87ca189861ab7561c4e9fb06b6bd0e", "filename": "compiler/rustc_codegen_ssa/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -40,7 +40,8 @@ pub use self::intrinsic::IntrinsicCallMethods;\n pub use self::misc::MiscMethods;\n pub use self::statics::{StaticBuilderMethods, StaticMethods};\n pub use self::type_::{\n-    ArgAbiMethods, BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods,\n+    ArgAbiMethods, BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMembershipMethods,\n+    TypeMethods,\n };\n pub use self::write::{ModuleBufferMethods, ThinBufferMethods, WriteBackendMethods};\n "}, {"sha": "8158e8dd011234328a1aec50c7bc7bde9d136714", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -117,6 +117,13 @@ pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     ) -> Self::Type;\n }\n \n+// For backends that support CFI using type membership (i.e., testing whether a given  pointer is\n+// associated with a type identifier).\n+pub trait TypeMembershipMethods<'tcx>: Backend<'tcx> {\n+    fn set_type_metadata(&self, function: Self::Function, typeid: String);\n+    fn typeid_metadata(&self, typeid: String) -> Self::Value;\n+}\n+\n pub trait ArgAbiMethods<'tcx>: HasCodegen<'tcx> {\n     fn store_fn_arg(\n         &mut self,\n@@ -133,6 +140,12 @@ pub trait ArgAbiMethods<'tcx>: HasCodegen<'tcx> {\n     fn arg_memory_ty(&self, arg_abi: &ArgAbi<'tcx, Ty<'tcx>>) -> Self::Type;\n }\n \n-pub trait TypeMethods<'tcx>: DerivedTypeMethods<'tcx> + LayoutTypeMethods<'tcx> {}\n+pub trait TypeMethods<'tcx>:\n+    DerivedTypeMethods<'tcx> + LayoutTypeMethods<'tcx> + TypeMembershipMethods<'tcx>\n+{\n+}\n \n-impl<'tcx, T> TypeMethods<'tcx> for T where Self: DerivedTypeMethods<'tcx> + LayoutTypeMethods<'tcx> {}\n+impl<'tcx, T> TypeMethods<'tcx> for T where\n+    Self: DerivedTypeMethods<'tcx> + LayoutTypeMethods<'tcx> + TypeMembershipMethods<'tcx>\n+{\n+}"}, {"sha": "b104a40c231150fb3802ac03c127ace56da0f27b", "filename": "compiler/rustc_symbol_mangling/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_symbol_mangling%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_symbol_mangling%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2FCargo.toml?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -7,6 +7,7 @@ edition = \"2021\"\n doctest = false\n \n [dependencies]\n+bitflags = \"1.2.1\"\n tracing = \"0.1\"\n punycode = \"0.4.0\"\n rustc-demangle = \"0.1.21\""}, {"sha": "5fc992023caa04121a440bf26b5414bb9e25288e", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -102,16 +102,16 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Instance, TyCtxt};\n use rustc_session::config::SymbolManglingVersion;\n-use rustc_target::abi::call::FnAbi;\n \n use tracing::debug;\n \n mod legacy;\n mod v0;\n \n pub mod test;\n+pub mod typeid;\n \n /// This function computes the symbol name for the given `instance` and the\n /// given instantiating crate. That is, if you know that instance X is\n@@ -150,11 +150,6 @@ fn symbol_name_provider<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty\n     ty::SymbolName::new(tcx, &symbol_name)\n }\n \n-/// This function computes the typeid for the given function ABI.\n-pub fn typeid_for_fnabi<'tcx>(tcx: TyCtxt<'tcx>, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> String {\n-    v0::mangle_typeid_for_fnabi(tcx, fn_abi)\n-}\n-\n pub fn typeid_for_trait_ref<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyExistentialTraitRef<'tcx>,"}, {"sha": "9228bea43f9327319d92c5c32b1360d815c92365", "filename": "compiler/rustc_symbol_mangling/src/typeid.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -0,0 +1,18 @@\n+// For more information about type metadata and type metadata identifiers for cross-language LLVM\n+// CFI support, see Type metadata in the design document in the tracking issue #89653.\n+\n+use rustc_middle::ty::{FnSig, Ty, TyCtxt};\n+use rustc_target::abi::call::FnAbi;\n+\n+mod typeid_itanium_cxx_abi;\n+use typeid_itanium_cxx_abi::TypeIdOptions;\n+\n+/// Returns a type metadata identifier for the specified FnAbi.\n+pub fn typeid_for_fnabi<'tcx>(tcx: TyCtxt<'tcx>, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> String {\n+    typeid_itanium_cxx_abi::typeid_for_fnabi(tcx, fn_abi, TypeIdOptions::NO_OPTIONS)\n+}\n+\n+/// Returns a type metadata identifier for the specified FnSig.\n+pub fn typeid_for_fnsig<'tcx>(tcx: TyCtxt<'tcx>, fn_sig: &FnSig<'tcx>) -> String {\n+    typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, TypeIdOptions::NO_OPTIONS)\n+}"}, {"sha": "a09b52fbfdf971d532e5e8c041323a942d05cca7", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "added", "additions": 929, "deletions": 0, "changes": 929, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -0,0 +1,929 @@\n+// For more information about type metadata and type metadata identifiers for cross-language LLVM\n+// CFI support, see Type metadata in the design document in the tracking issue #89653.\n+\n+// FIXME(rcvalle): Identify C char and integer type uses and encode them with their respective\n+// builtin type encodings as specified by the Itanium C++ ABI for extern function types with the \"C\"\n+// calling convention to use this encoding for cross-language LLVM CFI.\n+\n+use bitflags::bitflags;\n+use core::fmt::Display;\n+use rustc_data_structures::base_n;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n+use rustc_middle::ty::{\n+    self, Binder, Const, ExistentialPredicate, FloatTy, FnSig, IntTy, List, Region, RegionKind,\n+    Term, Ty, TyCtxt, UintTy,\n+};\n+use rustc_span::def_id::DefId;\n+use rustc_span::symbol::sym;\n+use rustc_target::abi::call::{Conv, FnAbi};\n+use rustc_target::spec::abi::Abi;\n+use std::fmt::Write as _;\n+\n+/// Type and extended type qualifiers.\n+#[derive(Eq, Hash, PartialEq)]\n+enum TyQ {\n+    None,\n+    Const,\n+    Mut,\n+}\n+\n+/// Substitution dictionary key.\n+#[derive(Eq, Hash, PartialEq)]\n+enum DictKey<'tcx> {\n+    Ty(Ty<'tcx>, TyQ),\n+    Region(Region<'tcx>),\n+    Const(Const<'tcx>),\n+    Predicate(ExistentialPredicate<'tcx>),\n+}\n+\n+bitflags! {\n+    /// Options for typeid_for_fnabi and typeid_for_fnsig.\n+    pub struct TypeIdOptions: u32 {\n+        const NO_OPTIONS = 0;\n+        const GENERALIZE_POINTERS = 1;\n+        const GENERALIZE_REPR_C = 2;\n+    }\n+}\n+\n+/// Options for encode_ty.\n+type EncodeTyOptions = TypeIdOptions;\n+\n+/// Options for transform_ty.\n+type TransformTyOptions = TypeIdOptions;\n+\n+/// Converts a number to a disambiguator (see\n+/// <https://rust-lang.github.io/rfcs/2603-rust-symbol-name-mangling-v0.html>).\n+fn to_disambiguator(num: u64) -> String {\n+    if let Some(num) = num.checked_sub(1) {\n+        format!(\"s{}_\", base_n::encode(num as u128, 62))\n+    } else {\n+        \"s_\".to_string()\n+    }\n+}\n+\n+/// Converts a number to a sequence number (see\n+/// <https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangle.seq-id>).\n+fn to_seq_id(num: usize) -> String {\n+    if let Some(num) = num.checked_sub(1) {\n+        base_n::encode(num as u128, 36).to_uppercase()\n+    } else {\n+        \"\".to_string()\n+    }\n+}\n+\n+/// Substitutes a component if found in the substitution dictionary (see\n+/// <https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling-compression>).\n+fn compress<'tcx>(\n+    dict: &mut FxHashMap<DictKey<'tcx>, usize>,\n+    key: DictKey<'tcx>,\n+    comp: &mut String,\n+) {\n+    match dict.get(&key) {\n+        Some(num) => {\n+            comp.clear();\n+            let _ = write!(comp, \"S{}_\", to_seq_id(*num));\n+        }\n+        None => {\n+            dict.insert(key, dict.len());\n+        }\n+    }\n+}\n+\n+// FIXME(rcvalle): Move to compiler/rustc_middle/src/ty/sty.rs after C types work is done, possibly\n+// along with other is_c_type methods.\n+/// Returns whether a `ty::Ty` is `c_void`.\n+fn is_c_void_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.kind() {\n+        ty::Adt(adt_def, ..) => {\n+            let def_id = adt_def.0.did;\n+            let crate_name = tcx.crate_name(def_id.krate);\n+            if tcx.item_name(def_id).as_str() == \"c_void\"\n+                && (crate_name == sym::core || crate_name == sym::std || crate_name == sym::libc)\n+            {\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+        _ => false,\n+    }\n+}\n+\n+/// Encodes a const using the Itanium C++ ABI as a literal argument (see\n+/// <https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling.literal>).\n+fn encode_const<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    c: Const<'tcx>,\n+    dict: &mut FxHashMap<DictKey<'tcx>, usize>,\n+    options: EncodeTyOptions,\n+) -> String {\n+    // L<element-type>[n]<element-value>E as literal argument\n+    let mut s = String::from('L');\n+\n+    // Element type\n+    s.push_str(&encode_ty(tcx, c.ty(), dict, options));\n+\n+    // The only allowed types of const parameters are bool, u8, u16, u32, u64, u128, usize i8, i16,\n+    // i32, i64, i128, isize, and char. The bool value false is encoded as 0 and true as 1.\n+    fn push_signed_value<T: Display + PartialOrd>(s: &mut String, value: T, zero: T) {\n+        if value < zero {\n+            s.push('n')\n+        };\n+        let _ = write!(s, \"{}\", value);\n+    }\n+\n+    fn push_unsigned_value<T: Display>(s: &mut String, value: T) {\n+        let _ = write!(s, \"{}\", value);\n+    }\n+\n+    if let Some(scalar_int) = c.kind().try_to_scalar_int() {\n+        let signed = c.ty().is_signed();\n+        match scalar_int.size().bits() {\n+            8 if signed => push_signed_value(&mut s, scalar_int.try_to_i8().unwrap(), 0),\n+            16 if signed => push_signed_value(&mut s, scalar_int.try_to_i16().unwrap(), 0),\n+            32 if signed => push_signed_value(&mut s, scalar_int.try_to_i32().unwrap(), 0),\n+            64 if signed => push_signed_value(&mut s, scalar_int.try_to_i64().unwrap(), 0),\n+            128 if signed => push_signed_value(&mut s, scalar_int.try_to_i128().unwrap(), 0),\n+            8 => push_unsigned_value(&mut s, scalar_int.try_to_u8().unwrap()),\n+            16 => push_unsigned_value(&mut s, scalar_int.try_to_u16().unwrap()),\n+            32 => push_unsigned_value(&mut s, scalar_int.try_to_u32().unwrap()),\n+            64 => push_unsigned_value(&mut s, scalar_int.try_to_u64().unwrap()),\n+            128 => push_unsigned_value(&mut s, scalar_int.try_to_u128().unwrap()),\n+            _ => {\n+                bug!(\"encode_const: unexpected size `{:?}`\", scalar_int.size().bits());\n+            }\n+        };\n+    } else {\n+        bug!(\"encode_const: unexpected type `{:?}`\", c.ty());\n+    }\n+\n+    // Close the \"L..E\" pair\n+    s.push('E');\n+\n+    compress(dict, DictKey::Const(c), &mut s);\n+\n+    s\n+}\n+\n+/// Encodes a FnSig using the Itanium C++ ABI with vendor extended type qualifiers and types for\n+/// Rust types that are not used at the FFI boundary.\n+fn encode_fnsig<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    fn_sig: &FnSig<'tcx>,\n+    dict: &mut FxHashMap<DictKey<'tcx>, usize>,\n+    options: TypeIdOptions,\n+) -> String {\n+    // Function types are delimited by an \"F..E\" pair\n+    let mut s = String::from(\"F\");\n+\n+    let mut encode_ty_options = EncodeTyOptions::from_bits(options.bits())\n+        .unwrap_or_else(|| bug!(\"encode_fnsig: invalid option(s) `{:?}`\", options.bits()));\n+    match fn_sig.abi {\n+        Abi::C { .. } => {\n+            encode_ty_options.insert(EncodeTyOptions::GENERALIZE_REPR_C);\n+        }\n+        _ => {\n+            encode_ty_options.remove(EncodeTyOptions::GENERALIZE_REPR_C);\n+        }\n+    }\n+\n+    // Encode the return type\n+    let transform_ty_options = TransformTyOptions::from_bits(options.bits())\n+        .unwrap_or_else(|| bug!(\"encode_fnsig: invalid option(s) `{:?}`\", options.bits()));\n+    let ty = transform_ty(tcx, fn_sig.output(), transform_ty_options);\n+    s.push_str(&encode_ty(tcx, ty, dict, encode_ty_options));\n+\n+    // Encode the parameter types\n+    let tys = fn_sig.inputs();\n+    if !tys.is_empty() {\n+        for ty in tys {\n+            let ty = transform_ty(tcx, *ty, transform_ty_options);\n+            s.push_str(&encode_ty(tcx, ty, dict, encode_ty_options));\n+        }\n+\n+        if fn_sig.c_variadic {\n+            s.push('z');\n+        }\n+    } else {\n+        if fn_sig.c_variadic {\n+            s.push('z');\n+        } else {\n+            // Empty parameter lists, whether declared as () or conventionally as (void), are\n+            // encoded with a void parameter specifier \"v\".\n+            s.push('v')\n+        }\n+    }\n+\n+    // Close the \"F..E\" pair\n+    s.push('E');\n+\n+    s\n+}\n+\n+/// Encodes a predicate using the Itanium C++ ABI with vendor extended type qualifiers and types for\n+/// Rust types that are not used at the FFI boundary.\n+fn encode_predicate<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicate: Binder<'tcx, ExistentialPredicate<'tcx>>,\n+    dict: &mut FxHashMap<DictKey<'tcx>, usize>,\n+    options: EncodeTyOptions,\n+) -> String {\n+    // u<length><name>[I<element-type1..element-typeN>E], where <element-type> is <subst>, as vendor\n+    // extended type.\n+    let mut s = String::new();\n+    match predicate.as_ref().skip_binder() {\n+        ty::ExistentialPredicate::Trait(trait_ref) => {\n+            let name = encode_ty_name(tcx, trait_ref.def_id);\n+            let _ = write!(s, \"u{}{}\", name.len(), &name);\n+            s.push_str(&encode_substs(tcx, trait_ref.substs, dict, options));\n+        }\n+        ty::ExistentialPredicate::Projection(projection) => {\n+            let name = encode_ty_name(tcx, projection.item_def_id);\n+            let _ = write!(s, \"u{}{}\", name.len(), &name);\n+            s.push_str(&encode_substs(tcx, projection.substs, dict, options));\n+            match projection.term {\n+                Term::Ty(ty) => {\n+                    s.push_str(&encode_ty(tcx, ty, dict, options));\n+                }\n+                Term::Const(c) => {\n+                    s.push_str(&encode_const(tcx, c, dict, options));\n+                }\n+            }\n+        }\n+        ty::ExistentialPredicate::AutoTrait(def_id) => {\n+            let name = encode_ty_name(tcx, *def_id);\n+            let _ = write!(s, \"u{}{}\", name.len(), &name);\n+        }\n+    };\n+    compress(dict, DictKey::Predicate(*predicate.as_ref().skip_binder()), &mut s);\n+    s\n+}\n+\n+/// Encodes predicates using the Itanium C++ ABI with vendor extended type qualifiers and types for\n+/// Rust types that are not used at the FFI boundary.\n+fn encode_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicates: &List<Binder<'tcx, ExistentialPredicate<'tcx>>>,\n+    dict: &mut FxHashMap<DictKey<'tcx>, usize>,\n+    options: EncodeTyOptions,\n+) -> String {\n+    // <predicate1[..predicateN]>E as part of vendor extended type\n+    let mut s = String::new();\n+    let predicates: Vec<Binder<'tcx, ExistentialPredicate<'tcx>>> =\n+        predicates.iter().map(|predicate| predicate).collect();\n+    for predicate in predicates {\n+        s.push_str(&encode_predicate(tcx, predicate, dict, options));\n+    }\n+    s\n+}\n+\n+/// Encodes a region using the Itanium C++ ABI as a vendor extended type.\n+fn encode_region<'tcx>(\n+    _tcx: TyCtxt<'tcx>,\n+    region: Region<'tcx>,\n+    dict: &mut FxHashMap<DictKey<'tcx>, usize>,\n+    _options: EncodeTyOptions,\n+) -> String {\n+    // u6region[I[<region-disambiguator>][<region-index>]E] as vendor extended type\n+    let mut s = String::new();\n+    match region.kind() {\n+        RegionKind::ReLateBound(debruijn, r) => {\n+            s.push_str(\"u6regionI\");\n+            // Debruijn index, which identifies the binder, as region disambiguator\n+            let num = debruijn.index() as u64;\n+            if num > 0 {\n+                s.push_str(&to_disambiguator(num));\n+            }\n+            // Index within the binder\n+            let _ = write!(s, \"{}\", r.var.index() as u64);\n+            s.push('E');\n+            compress(dict, DictKey::Region(region), &mut s);\n+        }\n+        RegionKind::ReErased => {\n+            s.push_str(\"u6region\");\n+            compress(dict, DictKey::Region(region), &mut s);\n+        }\n+        RegionKind::ReEarlyBound(..)\n+        | RegionKind::ReFree(..)\n+        | RegionKind::ReStatic\n+        | RegionKind::ReVar(..)\n+        | RegionKind::RePlaceholder(..)\n+        | RegionKind::ReEmpty(..) => {\n+            bug!(\"encode_region: unexpected `{:?}`\", region.kind());\n+        }\n+    }\n+    s\n+}\n+\n+/// Encodes substs using the Itanium C++ ABI with vendor extended type qualifiers and types for Rust\n+/// types that are not used at the FFI boundary.\n+fn encode_substs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    substs: SubstsRef<'tcx>,\n+    dict: &mut FxHashMap<DictKey<'tcx>, usize>,\n+    options: EncodeTyOptions,\n+) -> String {\n+    // [I<subst1..substN>E] as part of vendor extended type\n+    let mut s = String::new();\n+    let substs: Vec<GenericArg<'_>> = substs.iter().map(|subst| subst).collect();\n+    if !substs.is_empty() {\n+        s.push('I');\n+        for subst in substs {\n+            match subst.unpack() {\n+                GenericArgKind::Lifetime(region) => {\n+                    s.push_str(&encode_region(tcx, region, dict, options));\n+                }\n+                GenericArgKind::Type(ty) => {\n+                    s.push_str(&encode_ty(tcx, ty, dict, options));\n+                }\n+                GenericArgKind::Const(c) => {\n+                    s.push_str(&encode_const(tcx, c, dict, options));\n+                }\n+            }\n+        }\n+        s.push('E');\n+    }\n+    s\n+}\n+\n+/// Encodes a ty:Ty name, including its crate and path disambiguators and names.\n+fn encode_ty_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> String {\n+    // Encode <name> for use in u<length><name>[I<element-type1..element-typeN>E], where\n+    // <element-type> is <subst>, using v0's <path> without v0's extended form of paths:\n+    //\n+    // N<namespace-tagN>..N<namespace-tag1>\n+    // C<crate-disambiguator><crate-name>\n+    // <path-disambiguator1><path-name1>..<path-disambiguatorN><path-nameN>\n+    //\n+    // With additional tags for DefPathData::Impl and DefPathData::ForeignMod. For instance:\n+    //\n+    //     pub type Type1 = impl Send;\n+    //     let _: Type1 = <Struct1<i32>>::foo;\n+    //     fn foo1(_: Type1) { }\n+    //\n+    //     pub type Type2 = impl Send;\n+    //     let _: Type2 = <Trait1<i32>>::foo;\n+    //     fn foo2(_: Type2) { }\n+    //\n+    //     pub type Type3 = impl Send;\n+    //     let _: Type3 = <i32 as Trait1<i32>>::foo;\n+    //     fn foo3(_: Type3) { }\n+    //\n+    //     pub type Type4 = impl Send;\n+    //     let _: Type4 = <Struct1<i32> as Trait1<i32>>::foo;\n+    //     fn foo3(_: Type4) { }\n+    //\n+    // Are encoded as:\n+    //\n+    //     _ZTSFvu29NvNIC1234_5crate8{{impl}}3fooIu3i32EE\n+    //     _ZTSFvu27NvNtC1234_5crate6Trait13fooIu3dynIu21NtC1234_5crate6Trait1Iu3i32Eu6regionES_EE\n+    //     _ZTSFvu27NvNtC1234_5crate6Trait13fooIu3i32S_EE\n+    //     _ZTSFvu27NvNtC1234_5crate6Trait13fooIu22NtC1234_5crate7Struct1Iu3i32ES_EE\n+    //\n+    // The reason for not using v0's extended form of paths is to use a consistent and simpler\n+    // encoding, as the reasoning for using it isn't relevand for type metadata identifiers (i.e.,\n+    // keep symbol names close to how methods are represented in error messages). See\n+    // https://rust-lang.github.io/rfcs/2603-rust-symbol-name-mangling-v0.html#methods.\n+    let mut s = String::new();\n+\n+    // Start and namespace tags\n+    let mut def_path = tcx.def_path(def_id);\n+    def_path.data.reverse();\n+    for disambiguated_data in &def_path.data {\n+        s.push('N');\n+        s.push_str(match disambiguated_data.data {\n+            hir::definitions::DefPathData::Impl => \"I\", // Not specified in v0's <namespace>\n+            hir::definitions::DefPathData::ForeignMod => \"F\", // Not specified in v0's <namespace>\n+            hir::definitions::DefPathData::TypeNs(..) => \"t\",\n+            hir::definitions::DefPathData::ValueNs(..) => \"v\",\n+            hir::definitions::DefPathData::ClosureExpr => \"C\",\n+            hir::definitions::DefPathData::Ctor => \"c\",\n+            hir::definitions::DefPathData::AnonConst => \"k\",\n+            hir::definitions::DefPathData::ImplTrait => \"i\",\n+            hir::definitions::DefPathData::CrateRoot\n+            | hir::definitions::DefPathData::Use\n+            | hir::definitions::DefPathData::GlobalAsm\n+            | hir::definitions::DefPathData::MacroNs(..)\n+            | hir::definitions::DefPathData::LifetimeNs(..) => {\n+                bug!(\"encode_ty_name: unexpected `{:?}`\", disambiguated_data.data);\n+            }\n+        });\n+    }\n+\n+    // Crate disambiguator and name\n+    s.push('C');\n+    s.push_str(&to_disambiguator(tcx.stable_crate_id(def_path.krate).to_u64()));\n+    let crate_name = tcx.crate_name(def_path.krate).to_string();\n+    let _ = write!(s, \"{}{}\", crate_name.len(), &crate_name);\n+\n+    // Disambiguators and names\n+    def_path.data.reverse();\n+    for disambiguated_data in &def_path.data {\n+        let num = disambiguated_data.disambiguator as u64;\n+        if num > 0 {\n+            s.push_str(&to_disambiguator(num));\n+        }\n+\n+        let name = disambiguated_data.data.to_string();\n+        let _ = write!(s, \"{}\", name.len());\n+\n+        // Prepend a '_' if name starts with a digit or '_'\n+        if let Some(first) = name.as_bytes().get(0) {\n+            if first.is_ascii_digit() || *first == b'_' {\n+                s.push('_');\n+            }\n+        } else {\n+            bug!(\"encode_ty_name: invalid name `{:?}`\", name);\n+        }\n+\n+        s.push_str(&name);\n+    }\n+\n+    s\n+}\n+\n+/// Encodes a ty:Ty using the Itanium C++ ABI with vendor extended type qualifiers and types for\n+/// Rust types that are not used at the FFI boundary.\n+fn encode_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    dict: &mut FxHashMap<DictKey<'tcx>, usize>,\n+    options: EncodeTyOptions,\n+) -> String {\n+    let mut typeid = String::new();\n+\n+    match ty.kind() {\n+        // Primitive types\n+        ty::Bool => {\n+            typeid.push('b');\n+        }\n+\n+        ty::Int(..) | ty::Uint(..) | ty::Float(..) => {\n+            // u<length><type-name> as vendor extended type\n+            let mut s = String::from(match ty.kind() {\n+                ty::Int(IntTy::I8) => \"u2i8\",\n+                ty::Int(IntTy::I16) => \"u3i16\",\n+                ty::Int(IntTy::I32) => \"u3i32\",\n+                ty::Int(IntTy::I64) => \"u3i64\",\n+                ty::Int(IntTy::I128) => \"u4i128\",\n+                ty::Int(IntTy::Isize) => \"u5isize\",\n+                ty::Uint(UintTy::U8) => \"u2u8\",\n+                ty::Uint(UintTy::U16) => \"u3u16\",\n+                ty::Uint(UintTy::U32) => \"u3u32\",\n+                ty::Uint(UintTy::U64) => \"u3u64\",\n+                ty::Uint(UintTy::U128) => \"u4u128\",\n+                ty::Uint(UintTy::Usize) => \"u5usize\",\n+                ty::Float(FloatTy::F32) => \"u3f32\",\n+                ty::Float(FloatTy::F64) => \"u3f64\",\n+                _ => \"\",\n+            });\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        ty::Char => {\n+            // u4char as vendor extended type\n+            let mut s = String::from(\"u4char\");\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        ty::Str => {\n+            // u3str as vendor extended type\n+            let mut s = String::from(\"u3str\");\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        ty::Never => {\n+            // u5never as vendor extended type\n+            let mut s = String::from(\"u5never\");\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        // Compound types\n+        // () in Rust is equivalent to void return type in C\n+        _ if ty.is_unit() => {\n+            typeid.push('v');\n+        }\n+\n+        // Sequence types\n+        ty::Tuple(tys) => {\n+            // u5tupleI<element-type1..element-typeN>E as vendor extended type\n+            let mut s = String::from(\"u5tupleI\");\n+            for ty in tys.iter() {\n+                s.push_str(&encode_ty(tcx, ty, dict, options));\n+            }\n+            s.push('E');\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        ty::Array(ty0, len) => {\n+            // A<array-length><element-type>\n+            let mut s = String::from(\"A\");\n+            let _ = write!(s, \"{}\", &len.kind().try_to_scalar().unwrap().to_u64().unwrap());\n+            s.push_str(&encode_ty(tcx, *ty0, dict, options));\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        ty::Slice(ty0) => {\n+            // u5sliceI<element-type>E as vendor extended type\n+            let mut s = String::from(\"u5sliceI\");\n+            s.push_str(&encode_ty(tcx, *ty0, dict, options));\n+            s.push('E');\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        // User-defined types\n+        ty::Adt(adt_def, substs) => {\n+            let mut s = String::new();\n+            let def_id = adt_def.0.did;\n+            if options.contains(EncodeTyOptions::GENERALIZE_REPR_C) && adt_def.repr().c() {\n+                // For for cross-language CFI support, the encoding must be compatible at the FFI\n+                // boundary. For instance:\n+                //\n+                //     struct type1 {};\n+                //     void foo(struct type1* bar) {}\n+                //\n+                // Is encoded as:\n+                //\n+                //     _ZTSFvP5type1E\n+                //\n+                // So, encode any repr(C) user-defined type for extern function types with the \"C\"\n+                // calling convention (or extern types [i.e., ty::Foreign]) as <length><name>, where\n+                // <name> is <unscoped-name>.\n+                let name = tcx.item_name(def_id).to_string();\n+                let _ = write!(s, \"{}{}\", name.len(), &name);\n+                compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            } else {\n+                // u<length><name>[I<element-type1..element-typeN>E], where <element-type> is\n+                // <subst>, as vendor extended type.\n+                let name = encode_ty_name(tcx, def_id);\n+                let _ = write!(s, \"u{}{}\", name.len(), &name);\n+                s.push_str(&encode_substs(tcx, substs, dict, options));\n+                compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            }\n+            typeid.push_str(&s);\n+        }\n+\n+        ty::Foreign(def_id) => {\n+            // <length><name>, where <name> is <unscoped-name>\n+            let mut s = String::new();\n+            let name = tcx.item_name(*def_id).to_string();\n+            let _ = write!(s, \"{}{}\", name.len(), &name);\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        // Function types\n+        ty::FnDef(def_id, substs)\n+        | ty::Closure(def_id, substs)\n+        | ty::Generator(def_id, substs, ..) => {\n+            // u<length><name>[I<element-type1..element-typeN>E], where <element-type> is <subst>,\n+            // as vendor extended type.\n+            let mut s = String::new();\n+            let name = encode_ty_name(tcx, *def_id);\n+            let _ = write!(s, \"u{}{}\", name.len(), &name);\n+            s.push_str(&encode_substs(tcx, substs, dict, options));\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        // Pointer types\n+        ty::Ref(region, ty0, ..) => {\n+            // [U3mut]u3refI<element-type>E as vendor extended type qualifier and type\n+            let mut s = String::new();\n+            s.push_str(\"u3refI\");\n+            s.push_str(&encode_ty(tcx, *ty0, dict, options));\n+            s.push('E');\n+            compress(dict, DictKey::Ty(tcx.mk_imm_ref(*region, *ty0), TyQ::None), &mut s);\n+            if ty.is_mutable_ptr() {\n+                s = format!(\"{}{}\", \"U3mut\", &s);\n+                compress(dict, DictKey::Ty(ty, TyQ::Mut), &mut s);\n+            }\n+            typeid.push_str(&s);\n+        }\n+\n+        ty::RawPtr(tm) => {\n+            // P[K]<element-type>\n+            let mut s = String::new();\n+            s.push_str(&encode_ty(tcx, tm.ty, dict, options));\n+            if !ty.is_mutable_ptr() {\n+                s = format!(\"{}{}\", \"K\", &s);\n+                compress(dict, DictKey::Ty(tm.ty, TyQ::Const), &mut s);\n+            };\n+            s = format!(\"{}{}\", \"P\", &s);\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        ty::FnPtr(fn_sig) => {\n+            // PF<return-type><parameter-type1..parameter-typeN>E\n+            let mut s = String::from(\"P\");\n+            s.push_str(&encode_fnsig(tcx, &fn_sig.skip_binder(), dict, TypeIdOptions::NO_OPTIONS));\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        // Trait types\n+        ty::Dynamic(predicates, region) => {\n+            // u3dynI<element-type1[..element-typeN]>E, where <element-type> is <predicate>, as\n+            // vendor extended type.\n+            let mut s = String::from(\"u3dynI\");\n+            s.push_str(&encode_predicates(tcx, predicates, dict, options));\n+            s.push_str(&encode_region(tcx, *region, dict, options));\n+            s.push('E');\n+            compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            typeid.push_str(&s);\n+        }\n+\n+        // Unexpected types\n+        ty::Bound(..)\n+        | ty::Error(..)\n+        | ty::GeneratorWitness(..)\n+        | ty::Infer(..)\n+        | ty::Opaque(..)\n+        | ty::Param(..)\n+        | ty::Placeholder(..)\n+        | ty::Projection(..) => {\n+            bug!(\"encode_ty: unexpected `{:?}`\", ty.kind());\n+        }\n+    };\n+\n+    typeid\n+}\n+\n+// Transforms a ty:Ty for being encoded and used in the substitution dictionary. It transforms all\n+// c_void types into unit types unconditionally, and generalizes all pointers if\n+// TransformTyOptions::GENERALIZE_POINTERS option is set.\n+fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptions) -> Ty<'tcx> {\n+    let mut ty = ty;\n+\n+    match ty.kind() {\n+        ty::Bool\n+        | ty::Int(..)\n+        | ty::Uint(..)\n+        | ty::Float(..)\n+        | ty::Char\n+        | ty::Str\n+        | ty::Never\n+        | ty::Foreign(..)\n+        | ty::Dynamic(..) => {}\n+\n+        _ if ty.is_unit() => {}\n+\n+        ty::Tuple(tys) => {\n+            ty = tcx.mk_tup(tys.iter().map(|ty| transform_ty(tcx, ty, options)));\n+        }\n+\n+        ty::Array(ty0, len) => {\n+            let len = len.kind().try_to_scalar().unwrap().to_u64().unwrap();\n+            ty = tcx.mk_array(transform_ty(tcx, *ty0, options), len);\n+        }\n+\n+        ty::Slice(ty0) => {\n+            ty = tcx.mk_slice(transform_ty(tcx, *ty0, options));\n+        }\n+\n+        ty::Adt(adt_def, substs) => {\n+            if is_c_void_ty(tcx, ty) {\n+                ty = tcx.mk_unit();\n+            } else if options.contains(TransformTyOptions::GENERALIZE_REPR_C) && adt_def.repr().c()\n+            {\n+                ty = tcx.mk_adt(*adt_def, ty::List::empty());\n+            } else if adt_def.repr().transparent() && adt_def.is_struct() {\n+                let variant = adt_def.non_enum_variant();\n+                let param_env = tcx.param_env(variant.def_id);\n+                let field = variant.fields.iter().find(|field| {\n+                    let ty = tcx.type_of(field.did);\n+                    let is_zst =\n+                        tcx.layout_of(param_env.and(ty)).map_or(false, |layout| layout.is_zst());\n+                    !is_zst\n+                });\n+                if field.is_none() {\n+                    // Transform repr(transparent) types without non-ZST field into ()\n+                    ty = tcx.mk_unit();\n+                } else {\n+                    let ty0 = tcx.type_of(field.unwrap().did);\n+                    // Generalize any repr(transparent) user-defined type that is either a pointer\n+                    // or reference, and either references itself or any other type that contains or\n+                    // references itself, to avoid a reference cycle.\n+                    if ty0.is_any_ptr() && ty0.contains(ty) {\n+                        ty = transform_ty(\n+                            tcx,\n+                            ty0,\n+                            options | TransformTyOptions::GENERALIZE_POINTERS,\n+                        );\n+                    } else {\n+                        ty = transform_ty(tcx, ty0, options);\n+                    }\n+                }\n+            } else {\n+                ty = tcx.mk_adt(*adt_def, transform_substs(tcx, substs, options));\n+            }\n+        }\n+\n+        ty::FnDef(def_id, substs) => {\n+            ty = tcx.mk_fn_def(*def_id, transform_substs(tcx, substs, options));\n+        }\n+\n+        ty::Closure(def_id, substs) => {\n+            ty = tcx.mk_closure(*def_id, transform_substs(tcx, substs, options));\n+        }\n+\n+        ty::Generator(def_id, substs, movability) => {\n+            ty = tcx.mk_generator(*def_id, transform_substs(tcx, substs, options), *movability);\n+        }\n+\n+        ty::Ref(region, ty0, ..) => {\n+            if options.contains(TransformTyOptions::GENERALIZE_POINTERS) {\n+                if ty.is_mutable_ptr() {\n+                    ty = tcx.mk_mut_ref(tcx.lifetimes.re_static, tcx.mk_unit());\n+                } else {\n+                    ty = tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_unit());\n+                }\n+            } else {\n+                if ty.is_mutable_ptr() {\n+                    ty = tcx.mk_mut_ref(*region, transform_ty(tcx, *ty0, options));\n+                } else {\n+                    ty = tcx.mk_imm_ref(*region, transform_ty(tcx, *ty0, options));\n+                }\n+            }\n+        }\n+\n+        ty::RawPtr(tm) => {\n+            if options.contains(TransformTyOptions::GENERALIZE_POINTERS) {\n+                if ty.is_mutable_ptr() {\n+                    ty = tcx.mk_mut_ptr(tcx.mk_unit());\n+                } else {\n+                    ty = tcx.mk_imm_ptr(tcx.mk_unit());\n+                }\n+            } else {\n+                if ty.is_mutable_ptr() {\n+                    ty = tcx.mk_mut_ptr(transform_ty(tcx, tm.ty, options));\n+                } else {\n+                    ty = tcx.mk_imm_ptr(transform_ty(tcx, tm.ty, options));\n+                }\n+            }\n+        }\n+\n+        ty::FnPtr(fn_sig) => {\n+            if options.contains(TransformTyOptions::GENERALIZE_POINTERS) {\n+                ty = tcx.mk_imm_ptr(tcx.mk_unit());\n+            } else {\n+                let parameters: Vec<Ty<'tcx>> = fn_sig\n+                    .skip_binder()\n+                    .inputs()\n+                    .iter()\n+                    .map(|ty| transform_ty(tcx, *ty, options))\n+                    .collect();\n+                let output = transform_ty(tcx, fn_sig.skip_binder().output(), options);\n+                ty = tcx.mk_fn_ptr(ty::Binder::bind_with_vars(\n+                    tcx.mk_fn_sig(\n+                        parameters.iter(),\n+                        &output,\n+                        fn_sig.c_variadic(),\n+                        fn_sig.unsafety(),\n+                        fn_sig.abi(),\n+                    ),\n+                    fn_sig.bound_vars(),\n+                ));\n+            }\n+        }\n+\n+        ty::Bound(..)\n+        | ty::Error(..)\n+        | ty::GeneratorWitness(..)\n+        | ty::Infer(..)\n+        | ty::Opaque(..)\n+        | ty::Param(..)\n+        | ty::Placeholder(..)\n+        | ty::Projection(..) => {\n+            bug!(\"transform_ty: unexpected `{:?}`\", ty.kind());\n+        }\n+    }\n+\n+    ty\n+}\n+\n+/// Transforms substs for being encoded and used in the substitution dictionary.\n+fn transform_substs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    substs: SubstsRef<'tcx>,\n+    options: TransformTyOptions,\n+) -> SubstsRef<'tcx> {\n+    let substs: Vec<GenericArg<'tcx>> = substs\n+        .iter()\n+        .map(|subst| {\n+            if let GenericArgKind::Type(ty) = subst.unpack() {\n+                if is_c_void_ty(tcx, ty) {\n+                    tcx.mk_unit().into()\n+                } else {\n+                    transform_ty(tcx, ty, options).into()\n+                }\n+            } else {\n+                subst\n+            }\n+        })\n+        .collect();\n+    tcx.mk_substs(substs.iter())\n+}\n+\n+/// Returns a type metadata identifier for the specified FnAbi using the Itanium C++ ABI with vendor\n+/// extended type qualifiers and types for Rust types that are not used at the FFI boundary.\n+pub fn typeid_for_fnabi<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+    options: TypeIdOptions,\n+) -> String {\n+    // A name is mangled by prefixing \"_Z\" to an encoding of its name, and in the case of functions\n+    // its type.\n+    let mut typeid = String::from(\"_Z\");\n+\n+    // Clang uses the Itanium C++ ABI's virtual tables and RTTI typeinfo structure name as type\n+    // metadata identifiers for function pointers. The typeinfo name encoding is a two-character\n+    // code (i.e., 'TS') prefixed to the type encoding for the function.\n+    typeid.push_str(\"TS\");\n+\n+    // Function types are delimited by an \"F..E\" pair\n+    typeid.push('F');\n+\n+    // A dictionary of substitution candidates used for compression (see\n+    // https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling-compression).\n+    let mut dict: FxHashMap<DictKey<'tcx>, usize> = FxHashMap::default();\n+\n+    let mut encode_ty_options = EncodeTyOptions::from_bits(options.bits())\n+        .unwrap_or_else(|| bug!(\"typeid_for_fnabi: invalid option(s) `{:?}`\", options.bits()));\n+    match fn_abi.conv {\n+        Conv::C => {\n+            encode_ty_options.insert(EncodeTyOptions::GENERALIZE_REPR_C);\n+        }\n+        _ => {\n+            encode_ty_options.remove(EncodeTyOptions::GENERALIZE_REPR_C);\n+        }\n+    }\n+\n+    // Encode the return type\n+    let transform_ty_options = TransformTyOptions::from_bits(options.bits())\n+        .unwrap_or_else(|| bug!(\"typeid_for_fnabi: invalid option(s) `{:?}`\", options.bits()));\n+    let ty = transform_ty(tcx, fn_abi.ret.layout.ty, transform_ty_options);\n+    typeid.push_str(&encode_ty(tcx, ty, &mut dict, encode_ty_options));\n+\n+    // Encode the parameter types\n+    if !fn_abi.c_variadic {\n+        if !fn_abi.args.is_empty() {\n+            for arg in fn_abi.args.iter() {\n+                let ty = transform_ty(tcx, arg.layout.ty, transform_ty_options);\n+                typeid.push_str(&encode_ty(tcx, ty, &mut dict, encode_ty_options));\n+            }\n+        } else {\n+            // Empty parameter lists, whether declared as () or conventionally as (void), are\n+            // encoded with a void parameter specifier \"v\".\n+            typeid.push('v');\n+        }\n+    } else {\n+        for n in 0..fn_abi.fixed_count {\n+            let ty = transform_ty(tcx, fn_abi.args[n].layout.ty, transform_ty_options);\n+            typeid.push_str(&encode_ty(tcx, ty, &mut dict, encode_ty_options));\n+        }\n+\n+        typeid.push('z');\n+    }\n+\n+    // Close the \"F..E\" pair\n+    typeid.push('E');\n+\n+    typeid\n+}\n+\n+/// Returns a type metadata identifier for the specified FnSig using the Itanium C++ ABI with vendor\n+/// extended type qualifiers and types for Rust types that are not used at the FFI boundary.\n+pub fn typeid_for_fnsig<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    fn_sig: &FnSig<'tcx>,\n+    options: TypeIdOptions,\n+) -> String {\n+    // A name is mangled by prefixing \"_Z\" to an encoding of its name, and in the case of functions\n+    // its type.\n+    let mut typeid = String::from(\"_Z\");\n+\n+    // Clang uses the Itanium C++ ABI's virtual tables and RTTI typeinfo structure name as type\n+    // metadata identifiers for function pointers. The typeinfo name encoding is a two-character\n+    // code (i.e., 'TS') prefixed to the type encoding for the function.\n+    typeid.push_str(\"TS\");\n+\n+    // A dictionary of substitution candidates used for compression (see\n+    // https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling-compression).\n+    let mut dict: FxHashMap<DictKey<'tcx>, usize> = FxHashMap::default();\n+\n+    // Encode the function signature\n+    typeid.push_str(&encode_fnsig(tcx, fn_sig, &mut dict, options));\n+\n+    typeid\n+}"}, {"sha": "9f74f2e276314155e6dfc3020a039bc83bbd108c", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -12,7 +12,6 @@ use rustc_middle::ty::{\n     self, EarlyBinder, FloatTy, Instance, IntTy, Ty, TyCtxt, TypeVisitable, UintTy,\n };\n use rustc_span::symbol::kw;\n-use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::Integer;\n use rustc_target::spec::abi::Abi;\n \n@@ -59,41 +58,6 @@ pub(super) fn mangle<'tcx>(\n     std::mem::take(&mut cx.out)\n }\n \n-pub(super) fn mangle_typeid_for_fnabi<'tcx>(\n-    _tcx: TyCtxt<'tcx>,\n-    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n-) -> String {\n-    // LLVM uses type metadata to allow IR modules to aggregate pointers by their types.[1] This\n-    // type metadata is used by LLVM Control Flow Integrity to test whether a given pointer is\n-    // associated with a type identifier (i.e., test type membership).\n-    //\n-    // Clang uses the Itanium C++ ABI's[2] virtual tables and RTTI typeinfo structure name[3] as\n-    // type metadata identifiers for function pointers. The typeinfo name encoding is a\n-    // two-character code (i.e., \u201cTS\u201d) prefixed to the type encoding for the function.\n-    //\n-    // For cross-language LLVM CFI support, a compatible encoding must be used by either\n-    //\n-    //  a. Using a superset of types that encompasses types used by Clang (i.e., Itanium C++ ABI's\n-    //     type encodings[4]), or at least types used at the FFI boundary.\n-    //  b. Reducing the types to the least common denominator between types used by Clang (or at\n-    //     least types used at the FFI boundary) and Rust compilers (if even possible).\n-    //  c. Creating a new ABI for cross-language CFI and using it for Clang and Rust compilers (and\n-    //     possibly other compilers).\n-    //\n-    // Option (b) may weaken the protection for Rust-compiled only code, so it should be provided\n-    // as an alternative to a Rust-specific encoding for when mixing Rust and C and C++ -compiled\n-    // code. Option (c) would require changes to Clang to use the new ABI.\n-    //\n-    // [1] https://llvm.org/docs/TypeMetadata.html\n-    // [2] https://itanium-cxx-abi.github.io/cxx-abi/abi.html\n-    // [3] https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling-special-vtables\n-    // [4] https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling-type\n-    //\n-    // FIXME(rcvalle): See comment above.\n-    let arg_count = fn_abi.args.len() + fn_abi.ret.is_indirect() as usize;\n-    format!(\"typeid{}\", arg_count)\n-}\n-\n pub(super) fn mangle_typeid_for_trait_ref<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyExistentialTraitRef<'tcx>,"}, {"sha": "c42fbba74254a3555e941cad40177521260b9979", "filename": "src/test/codegen/sanitizer-cfi-add-canonical-jump-tables-flag.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-add-canonical-jump-tables-flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-add-canonical-jump-tables-flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-add-canonical-jump-tables-flag.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -1,10 +1,7 @@\n // Verifies that \"CFI Canonical Jump Tables\" module flag is added.\n //\n-// ignore-windows\n // needs-sanitizer-cfi\n-// only-aarch64\n-// only-x86_64\n-// compile-flags: -Clto -Zsanitizer=cfi\n+// compile-flags: -Clto -Ctarget-feature=-crt-static -Zsanitizer=cfi\n \n #![crate_type=\"lib\"]\n ", "previous_filename": "src/test/codegen/sanitizer_cfi_add_canonical_jump_tables_flag.rs"}, {"sha": "082f0f121ff8b8bea9dd8669c4fd55cdd491af60", "filename": "src/test/codegen/sanitizer-cfi-emit-type-checks.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-checks.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -1,10 +1,7 @@\n // Verifies that pointer type membership tests for indirect calls are emitted.\n //\n-// ignore-windows\n // needs-sanitizer-cfi\n-// only-aarch64\n-// only-x86_64\n-// compile-flags: -Clto -Cno-prepopulate-passes -Zsanitizer=cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi\n \n #![crate_type=\"lib\"]\n ", "previous_filename": "src/test/codegen/sanitizer_cfi_emit_type_checks.rs"}, {"sha": "ece2adbdf4325e4211468d0c87d1875824bce64f", "filename": "src/test/codegen/sanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs", "status": "added", "additions": 575, "deletions": 0, "changes": 575, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -0,0 +1,575 @@\n+// Verifies that type metadata identifiers for functions are emitted correctly.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi\n+\n+#![crate_type=\"lib\"]\n+#![allow(dead_code)]\n+#![allow(incomplete_features)]\n+#![allow(unused_must_use)]\n+#![feature(adt_const_params, extern_types, inline_const, type_alias_impl_trait)]\n+\n+extern crate core;\n+use core::ffi::c_void;\n+use std::marker::PhantomData;\n+\n+// User-defined type (structure)\n+pub struct Struct1<T> {\n+    member1: T,\n+}\n+\n+// User-defined type (enum)\n+pub enum Enum1<T> {\n+    Variant1(T),\n+}\n+\n+// User-defined type (union)\n+pub union Union1<T> {\n+    member1: std::mem::ManuallyDrop<T>,\n+}\n+\n+// Extern type\n+extern {\n+    pub type type1;\n+}\n+\n+// Trait\n+pub trait Trait1<T> {\n+    fn foo(&self) { }\n+}\n+\n+// Trait implementation\n+impl<T> Trait1<T> for i32 {\n+    fn foo(&self) { }\n+}\n+\n+// Trait implementation\n+impl<T> Trait1<T> for Struct1<T> {\n+    fn foo(&self) { }\n+}\n+\n+// impl Trait type aliases for helping with defining other types (see below)\n+pub type Type1 = impl Send;\n+pub type Type2 = impl Send;\n+pub type Type3 = impl Send;\n+pub type Type4 = impl Send;\n+pub type Type5 = impl Send;\n+pub type Type6 = impl Send;\n+pub type Type7 = impl Send;\n+pub type Type8 = impl Send;\n+pub type Type9 = impl Send;\n+pub type Type10 = impl Send;\n+pub type Type11 = impl Send;\n+\n+pub fn fn1<'a>() {\n+    // Closure\n+    let closure1 = || { };\n+    let _: Type1 = closure1;\n+\n+    // Constructor\n+    pub struct Foo(i32);\n+    let _: Type2 = Foo;\n+\n+    // Type in extern path\n+    extern {\n+        fn foo();\n+    }\n+    let _: Type3 = foo;\n+\n+    // Type in closure path\n+    || {\n+        pub struct Foo;\n+        let _: Type4 = Foo;\n+    };\n+\n+    // Type in const path\n+    const {\n+        pub struct Foo;\n+        fn foo() -> Type5 { Foo }\n+    };\n+\n+    // Type in impl path\n+    impl<T> Struct1<T> {\n+        fn foo(&self) { }\n+    }\n+    let _: Type6 = <Struct1<i32>>::foo;\n+\n+    // Trait method\n+    let _: Type7 = <dyn Trait1<i32>>::foo;\n+\n+    // Trait method\n+    let _: Type8 = <i32 as Trait1<i32>>::foo;\n+\n+    // Trait method\n+    let _: Type9 = <Struct1<i32> as Trait1<i32>>::foo;\n+\n+    // Const generics\n+    pub struct Qux<T, const N: usize>([T; N]);\n+    let _: Type10 = Qux([0; 32]);\n+\n+    // Lifetimes/regions\n+    pub struct Quux<'a>(&'a i32);\n+    pub struct Quuux<'a, 'b>(&'a i32, &'b Quux<'b>);\n+    let _: Type11 = Quuux;\n+}\n+\n+// repr(transparent) user-defined type\n+struct Foo(i32);\n+\n+#[repr(transparent)]\n+pub struct Type12 {\n+    member1: (),\n+    member2: PhantomData<i32>,\n+    member3: Foo,\n+}\n+\n+// Self-referencing repr(transparent) user-defined type\n+#[repr(transparent)]\n+pub struct Type13<'a> {\n+    member1: (),\n+    member2: PhantomData<i32>,\n+    member3: &'a Type13<'a>,\n+}\n+\n+pub fn foo0(_: ()) { }\n+// CHECK: define{{.*}}foo0{{.*}}!type ![[TYPE0:[0-9]+]]\n+pub fn foo1(_: c_void, _: ()) { }\n+// CHECK: define{{.*}}foo1{{.*}}!type ![[TYPE1:[0-9]+]]\n+pub fn foo2(_: (), _: c_void, _: c_void) { }\n+// CHECK: define{{.*}}foo2{{.*}}!type ![[TYPE2:[0-9]+]]\n+pub fn foo3(_: *mut c_void) { }\n+// CHECK: define{{.*}}foo3{{.*}}!type ![[TYPE3:[0-9]+]]\n+pub fn foo4(_: *mut c_void, _: *mut ()) { }\n+// CHECK: define{{.*}}foo4{{.*}}!type ![[TYPE4:[0-9]+]]\n+pub fn foo5(_: *mut (), _: *mut c_void, _: *mut c_void) { }\n+// CHECK: define{{.*}}foo5{{.*}}!type ![[TYPE5:[0-9]+]]\n+pub fn foo6(_: *const c_void) { }\n+// CHECK: define{{.*}}foo6{{.*}}!type ![[TYPE6:[0-9]+]]\n+pub fn foo7(_: *const c_void, _: *const ()) { }\n+// CHECK: define{{.*}}foo7{{.*}}!type ![[TYPE7:[0-9]+]]\n+pub fn foo8(_: *const (), _: *const c_void, _: *const c_void) { }\n+// CHECK: define{{.*}}foo8{{.*}}!type ![[TYPE8:[0-9]+]]\n+pub fn foo9(_: bool) { }\n+// CHECK: define{{.*}}foo9{{.*}}!type ![[TYPE9:[0-9]+]]\n+pub fn foo10(_: bool, _: bool) { }\n+// CHECK: define{{.*}}foo10{{.*}}!type ![[TYPE10:[0-9]+]]\n+pub fn foo11(_: bool, _: bool, _: bool) { }\n+// CHECK: define{{.*}}foo11{{.*}}!type ![[TYPE11:[0-9]+]]\n+pub fn foo12(_: i8) { }\n+// CHECK: define{{.*}}foo12{{.*}}!type ![[TYPE12:[0-9]+]]\n+pub fn foo13(_: i8, _: i8) { }\n+// CHECK: define{{.*}}foo13{{.*}}!type ![[TYPE13:[0-9]+]]\n+pub fn foo14(_: i8, _: i8, _: i8) { }\n+// CHECK: define{{.*}}foo14{{.*}}!type ![[TYPE14:[0-9]+]]\n+pub fn foo15(_: i16) { }\n+// CHECK: define{{.*}}foo15{{.*}}!type ![[TYPE15:[0-9]+]]\n+pub fn foo16(_: i16, _: i16) { }\n+// CHECK: define{{.*}}foo16{{.*}}!type ![[TYPE16:[0-9]+]]\n+pub fn foo17(_: i16, _: i16, _: i16) { }\n+// CHECK: define{{.*}}foo17{{.*}}!type ![[TYPE17:[0-9]+]]\n+pub fn foo18(_: i32) { }\n+// CHECK: define{{.*}}foo18{{.*}}!type ![[TYPE18:[0-9]+]]\n+pub fn foo19(_: i32, _: i32) { }\n+// CHECK: define{{.*}}foo19{{.*}}!type ![[TYPE19:[0-9]+]]\n+pub fn foo20(_: i32, _: i32, _: i32) { }\n+// CHECK: define{{.*}}foo20{{.*}}!type ![[TYPE20:[0-9]+]]\n+pub fn foo21(_: i64) { }\n+// CHECK: define{{.*}}foo21{{.*}}!type ![[TYPE21:[0-9]+]]\n+pub fn foo22(_: i64, _: i64) { }\n+// CHECK: define{{.*}}foo22{{.*}}!type ![[TYPE22:[0-9]+]]\n+pub fn foo23(_: i64, _: i64, _: i64) { }\n+// CHECK: define{{.*}}foo23{{.*}}!type ![[TYPE23:[0-9]+]]\n+pub fn foo24(_: i128) { }\n+// CHECK: define{{.*}}foo24{{.*}}!type ![[TYPE24:[0-9]+]]\n+pub fn foo25(_: i128, _: i128) { }\n+// CHECK: define{{.*}}foo25{{.*}}!type ![[TYPE25:[0-9]+]]\n+pub fn foo26(_: i128, _: i128, _: i128) { }\n+// CHECK: define{{.*}}foo26{{.*}}!type ![[TYPE26:[0-9]+]]\n+pub fn foo27(_: isize) { }\n+// CHECK: define{{.*}}foo27{{.*}}!type ![[TYPE27:[0-9]+]]\n+pub fn foo28(_: isize, _: isize) { }\n+// CHECK: define{{.*}}foo28{{.*}}!type ![[TYPE28:[0-9]+]]\n+pub fn foo29(_: isize, _: isize, _: isize) { }\n+// CHECK: define{{.*}}foo29{{.*}}!type ![[TYPE29:[0-9]+]]\n+pub fn foo30(_: u8) { }\n+// CHECK: define{{.*}}foo30{{.*}}!type ![[TYPE30:[0-9]+]]\n+pub fn foo31(_: u8, _: u8) { }\n+// CHECK: define{{.*}}foo31{{.*}}!type ![[TYPE31:[0-9]+]]\n+pub fn foo32(_: u8, _: u8, _: u8) { }\n+// CHECK: define{{.*}}foo32{{.*}}!type ![[TYPE32:[0-9]+]]\n+pub fn foo33(_: u16) { }\n+// CHECK: define{{.*}}foo33{{.*}}!type ![[TYPE33:[0-9]+]]\n+pub fn foo34(_: u16, _: u16) { }\n+// CHECK: define{{.*}}foo34{{.*}}!type ![[TYPE34:[0-9]+]]\n+pub fn foo35(_: u16, _: u16, _: u16) { }\n+// CHECK: define{{.*}}foo35{{.*}}!type ![[TYPE35:[0-9]+]]\n+pub fn foo36(_: u32) { }\n+// CHECK: define{{.*}}foo36{{.*}}!type ![[TYPE36:[0-9]+]]\n+pub fn foo37(_: u32, _: u32) { }\n+// CHECK: define{{.*}}foo37{{.*}}!type ![[TYPE37:[0-9]+]]\n+pub fn foo38(_: u32, _: u32, _: u32) { }\n+// CHECK: define{{.*}}foo38{{.*}}!type ![[TYPE38:[0-9]+]]\n+pub fn foo39(_: u64) { }\n+// CHECK: define{{.*}}foo39{{.*}}!type ![[TYPE39:[0-9]+]]\n+pub fn foo40(_: u64, _: u64) { }\n+// CHECK: define{{.*}}foo40{{.*}}!type ![[TYPE40:[0-9]+]]\n+pub fn foo41(_: u64, _: u64, _: u64) { }\n+// CHECK: define{{.*}}foo41{{.*}}!type ![[TYPE41:[0-9]+]]\n+pub fn foo42(_: u128) { }\n+// CHECK: define{{.*}}foo42{{.*}}!type ![[TYPE42:[0-9]+]]\n+pub fn foo43(_: u128, _: u128) { }\n+// CHECK: define{{.*}}foo43{{.*}}!type ![[TYPE43:[0-9]+]]\n+pub fn foo44(_: u128, _: u128, _: u128) { }\n+// CHECK: define{{.*}}foo44{{.*}}!type ![[TYPE44:[0-9]+]]\n+pub fn foo45(_: usize) { }\n+// CHECK: define{{.*}}foo45{{.*}}!type ![[TYPE45:[0-9]+]]\n+pub fn foo46(_: usize, _: usize) { }\n+// CHECK: define{{.*}}foo46{{.*}}!type ![[TYPE46:[0-9]+]]\n+pub fn foo47(_: usize, _: usize, _: usize) { }\n+// CHECK: define{{.*}}foo47{{.*}}!type ![[TYPE47:[0-9]+]]\n+pub fn foo48(_: f32) { }\n+// CHECK: define{{.*}}foo48{{.*}}!type ![[TYPE48:[0-9]+]]\n+pub fn foo49(_: f32, _: f32) { }\n+// CHECK: define{{.*}}foo49{{.*}}!type ![[TYPE49:[0-9]+]]\n+pub fn foo50(_: f32, _: f32, _: f32) { }\n+// CHECK: define{{.*}}foo50{{.*}}!type ![[TYPE50:[0-9]+]]\n+pub fn foo51(_: f64) { }\n+// CHECK: define{{.*}}foo51{{.*}}!type ![[TYPE51:[0-9]+]]\n+pub fn foo52(_: f64, _: f64) { }\n+// CHECK: define{{.*}}foo52{{.*}}!type ![[TYPE52:[0-9]+]]\n+pub fn foo53(_: f64, _: f64, _: f64) { }\n+// CHECK: define{{.*}}foo53{{.*}}!type ![[TYPE53:[0-9]+]]\n+pub fn foo54(_: char) { }\n+// CHECK: define{{.*}}foo54{{.*}}!type ![[TYPE54:[0-9]+]]\n+pub fn foo55(_: char, _: char) { }\n+// CHECK: define{{.*}}foo55{{.*}}!type ![[TYPE55:[0-9]+]]\n+pub fn foo56(_: char, _: char, _: char) { }\n+// CHECK: define{{.*}}foo56{{.*}}!type ![[TYPE56:[0-9]+]]\n+pub fn foo57(_: &str) { }\n+// CHECK: define{{.*}}foo57{{.*}}!type ![[TYPE57:[0-9]+]]\n+pub fn foo58(_: &str, _: &str) { }\n+// CHECK: define{{.*}}foo58{{.*}}!type ![[TYPE58:[0-9]+]]\n+pub fn foo59(_: &str, _: &str, _: &str) { }\n+// CHECK: define{{.*}}foo59{{.*}}!type ![[TYPE59:[0-9]+]]\n+pub fn foo60(_: (i32, i32)) { }\n+// CHECK: define{{.*}}foo60{{.*}}!type ![[TYPE60:[0-9]+]]\n+pub fn foo61(_: (i32, i32), _: (i32, i32)) { }\n+// CHECK: define{{.*}}foo61{{.*}}!type ![[TYPE61:[0-9]+]]\n+pub fn foo62(_: (i32, i32), _: (i32, i32), _: (i32, i32)) { }\n+// CHECK: define{{.*}}foo62{{.*}}!type ![[TYPE62:[0-9]+]]\n+pub fn foo63(_: [i32; 32]) { }\n+// CHECK: define{{.*}}foo63{{.*}}!type ![[TYPE63:[0-9]+]]\n+pub fn foo64(_: [i32; 32], _: [i32; 32]) { }\n+// CHECK: define{{.*}}foo64{{.*}}!type ![[TYPE64:[0-9]+]]\n+pub fn foo65(_: [i32; 32], _: [i32; 32], _: [i32; 32]) { }\n+// CHECK: define{{.*}}foo65{{.*}}!type ![[TYPE65:[0-9]+]]\n+pub fn foo66(_: &[i32]) { }\n+// CHECK: define{{.*}}foo66{{.*}}!type ![[TYPE66:[0-9]+]]\n+pub fn foo67(_: &[i32], _: &[i32]) { }\n+// CHECK: define{{.*}}foo67{{.*}}!type ![[TYPE67:[0-9]+]]\n+pub fn foo68(_: &[i32], _: &[i32], _: &[i32]) { }\n+// CHECK: define{{.*}}foo68{{.*}}!type ![[TYPE68:[0-9]+]]\n+pub fn foo69(_: &Struct1::<i32>) { }\n+// CHECK: define{{.*}}foo69{{.*}}!type ![[TYPE69:[0-9]+]]\n+pub fn foo70(_: &Struct1::<i32>, _: &Struct1::<i32>) { }\n+// CHECK: define{{.*}}foo70{{.*}}!type ![[TYPE70:[0-9]+]]\n+pub fn foo71(_: &Struct1::<i32>, _: &Struct1::<i32>, _: &Struct1::<i32>) { }\n+// CHECK: define{{.*}}foo71{{.*}}!type ![[TYPE71:[0-9]+]]\n+pub fn foo72(_: &Enum1::<i32>) { }\n+// CHECK: define{{.*}}foo72{{.*}}!type ![[TYPE72:[0-9]+]]\n+pub fn foo73(_: &Enum1::<i32>, _: &Enum1::<i32>) { }\n+// CHECK: define{{.*}}foo73{{.*}}!type ![[TYPE73:[0-9]+]]\n+pub fn foo74(_: &Enum1::<i32>, _: &Enum1::<i32>, _: &Enum1::<i32>) { }\n+// CHECK: define{{.*}}foo74{{.*}}!type ![[TYPE74:[0-9]+]]\n+pub fn foo75(_: &Union1::<i32>) { }\n+// CHECK: define{{.*}}foo75{{.*}}!type ![[TYPE75:[0-9]+]]\n+pub fn foo76(_: &Union1::<i32>, _: &Union1::<i32>) { }\n+// CHECK: define{{.*}}foo76{{.*}}!type ![[TYPE76:[0-9]+]]\n+pub fn foo77(_: &Union1::<i32>, _: &Union1::<i32>, _: &Union1::<i32>) { }\n+// CHECK: define{{.*}}foo77{{.*}}!type ![[TYPE77:[0-9]+]]\n+pub fn foo78(_: *mut type1) { }\n+// CHECK: define{{.*}}foo78{{.*}}!type ![[TYPE78:[0-9]+]]\n+pub fn foo79(_: *mut type1, _: *mut type1) { }\n+// CHECK: define{{.*}}foo79{{.*}}!type ![[TYPE79:[0-9]+]]\n+pub fn foo80(_: *mut type1, _: *mut type1, _: *mut type1) { }\n+// CHECK: define{{.*}}foo80{{.*}}!type ![[TYPE80:[0-9]+]]\n+pub fn foo81(_: &mut i32) { }\n+// CHECK: define{{.*}}foo81{{.*}}!type ![[TYPE81:[0-9]+]]\n+pub fn foo82(_: &mut i32, _: &i32) { }\n+// CHECK: define{{.*}}foo82{{.*}}!type ![[TYPE82:[0-9]+]]\n+pub fn foo83(_: &mut i32, _: &i32, _: &i32) { }\n+// CHECK: define{{.*}}foo83{{.*}}!type ![[TYPE83:[0-9]+]]\n+pub fn foo84(_: &i32) { }\n+// CHECK: define{{.*}}foo84{{.*}}!type ![[TYPE84:[0-9]+]]\n+pub fn foo85(_: &i32, _: &mut i32) { }\n+// CHECK: define{{.*}}foo85{{.*}}!type ![[TYPE85:[0-9]+]]\n+pub fn foo86(_: &i32, _: &mut i32, _: &mut i32) { }\n+// CHECK: define{{.*}}foo86{{.*}}!type ![[TYPE86:[0-9]+]]\n+pub fn foo87(_: *mut i32) { }\n+// CHECK: define{{.*}}foo87{{.*}}!type ![[TYPE87:[0-9]+]]\n+pub fn foo88(_: *mut i32, _: *const i32) { }\n+// CHECK: define{{.*}}foo88{{.*}}!type ![[TYPE88:[0-9]+]]\n+pub fn foo89(_: *mut i32, _: *const i32, _: *const i32) { }\n+// CHECK: define{{.*}}foo89{{.*}}!type ![[TYPE89:[0-9]+]]\n+pub fn foo90(_: *const i32) { }\n+// CHECK: define{{.*}}foo90{{.*}}!type ![[TYPE90:[0-9]+]]\n+pub fn foo91(_: *const i32, _: *mut i32) { }\n+// CHECK: define{{.*}}foo91{{.*}}!type ![[TYPE91:[0-9]+]]\n+pub fn foo92(_: *const i32, _: *mut i32, _: *mut i32) { }\n+// CHECK: define{{.*}}foo92{{.*}}!type ![[TYPE92:[0-9]+]]\n+pub fn foo93(_: fn(i32) -> i32) { }\n+// CHECK: define{{.*}}foo93{{.*}}!type ![[TYPE93:[0-9]+]]\n+pub fn foo94(_: fn(i32) -> i32, _: fn(i32) -> i32) { }\n+// CHECK: define{{.*}}foo94{{.*}}!type ![[TYPE94:[0-9]+]]\n+pub fn foo95(_: fn(i32) -> i32, _: fn(i32) -> i32, _: fn(i32) -> i32) { }\n+// CHECK: define{{.*}}foo95{{.*}}!type ![[TYPE95:[0-9]+]]\n+pub fn foo96(_: &dyn Fn(i32) -> i32) { }\n+// CHECK: define{{.*}}foo96{{.*}}!type ![[TYPE96:[0-9]+]]\n+pub fn foo97(_: &dyn Fn(i32) -> i32, _: &dyn Fn(i32) -> i32) { }\n+// CHECK: define{{.*}}foo97{{.*}}!type ![[TYPE97:[0-9]+]]\n+pub fn foo98(_: &dyn Fn(i32) -> i32, _: &dyn Fn(i32) -> i32, _: &dyn Fn(i32) -> i32) { }\n+// CHECK: define{{.*}}foo98{{.*}}!type ![[TYPE98:[0-9]+]]\n+pub fn foo99(_: &dyn FnMut(i32) -> i32) { }\n+// CHECK: define{{.*}}foo99{{.*}}!type ![[TYPE99:[0-9]+]]\n+pub fn foo100(_: &dyn FnMut(i32) -> i32, _: &dyn FnMut(i32) -> i32) { }\n+// CHECK: define{{.*}}foo100{{.*}}!type ![[TYPE100:[0-9]+]]\n+pub fn foo101(_: &dyn FnMut(i32) -> i32, _: &dyn FnMut(i32) -> i32, _: &dyn FnMut(i32) -> i32) { }\n+// CHECK: define{{.*}}foo101{{.*}}!type ![[TYPE101:[0-9]+]]\n+pub fn foo102(_: &dyn FnOnce(i32) -> i32) { }\n+// CHECK: define{{.*}}foo102{{.*}}!type ![[TYPE102:[0-9]+]]\n+pub fn foo103(_: &dyn FnOnce(i32) -> i32, _: &dyn FnOnce(i32) -> i32) { }\n+// CHECK: define{{.*}}foo103{{.*}}!type ![[TYPE103:[0-9]+]]\n+pub fn foo104(_: &dyn FnOnce(i32) -> i32, _: &dyn FnOnce(i32) -> i32, _: &dyn FnOnce(i32) -> i32) {}\n+// CHECK: define{{.*}}foo104{{.*}}!type ![[TYPE104:[0-9]+]]\n+pub fn foo105(_: &dyn Send) { }\n+// CHECK: define{{.*}}foo105{{.*}}!type ![[TYPE105:[0-9]+]]\n+pub fn foo106(_: &dyn Send, _: &dyn Send) { }\n+// CHECK: define{{.*}}foo106{{.*}}!type ![[TYPE106:[0-9]+]]\n+pub fn foo107(_: &dyn Send, _: &dyn Send, _: &dyn Send) { }\n+// CHECK: define{{.*}}foo107{{.*}}!type ![[TYPE107:[0-9]+]]\n+pub fn foo108(_: Type1) { }\n+// CHECK: define{{.*}}foo108{{.*}}!type ![[TYPE108:[0-9]+]]\n+pub fn foo109(_: Type1, _: Type1) { }\n+// CHECK: define{{.*}}foo109{{.*}}!type ![[TYPE109:[0-9]+]]\n+pub fn foo110(_: Type1, _: Type1, _: Type1) { }\n+// CHECK: define{{.*}}foo110{{.*}}!type ![[TYPE110:[0-9]+]]\n+pub fn foo111(_: Type2) { }\n+// CHECK: define{{.*}}foo111{{.*}}!type ![[TYPE111:[0-9]+]]\n+pub fn foo112(_: Type2, _: Type2) { }\n+// CHECK: define{{.*}}foo112{{.*}}!type ![[TYPE112:[0-9]+]]\n+pub fn foo113(_: Type2, _: Type2, _: Type2) { }\n+// CHECK: define{{.*}}foo113{{.*}}!type ![[TYPE113:[0-9]+]]\n+pub fn foo114(_: Type3) { }\n+// CHECK: define{{.*}}foo114{{.*}}!type ![[TYPE114:[0-9]+]]\n+pub fn foo115(_: Type3, _: Type3) { }\n+// CHECK: define{{.*}}foo115{{.*}}!type ![[TYPE115:[0-9]+]]\n+pub fn foo116(_: Type3, _: Type3, _: Type3) { }\n+// CHECK: define{{.*}}foo116{{.*}}!type ![[TYPE116:[0-9]+]]\n+pub fn foo117(_: Type4) { }\n+// CHECK: define{{.*}}foo117{{.*}}!type ![[TYPE117:[0-9]+]]\n+pub fn foo118(_: Type4, _: Type4) { }\n+// CHECK: define{{.*}}foo118{{.*}}!type ![[TYPE118:[0-9]+]]\n+pub fn foo119(_: Type4, _: Type4, _: Type4) { }\n+// CHECK: define{{.*}}foo119{{.*}}!type ![[TYPE119:[0-9]+]]\n+pub fn foo120(_: Type5) { }\n+// CHECK: define{{.*}}foo120{{.*}}!type ![[TYPE120:[0-9]+]]\n+pub fn foo121(_: Type5, _: Type5) { }\n+// CHECK: define{{.*}}foo121{{.*}}!type ![[TYPE121:[0-9]+]]\n+pub fn foo122(_: Type5, _: Type5, _: Type5) { }\n+// CHECK: define{{.*}}foo122{{.*}}!type ![[TYPE122:[0-9]+]]\n+pub fn foo123(_: Type6) { }\n+// CHECK: define{{.*}}foo123{{.*}}!type ![[TYPE123:[0-9]+]]\n+pub fn foo124(_: Type6, _: Type6) { }\n+// CHECK: define{{.*}}foo124{{.*}}!type ![[TYPE124:[0-9]+]]\n+pub fn foo125(_: Type6, _: Type6, _: Type6) { }\n+// CHECK: define{{.*}}foo125{{.*}}!type ![[TYPE125:[0-9]+]]\n+pub fn foo126(_: Type7) { }\n+// CHECK: define{{.*}}foo126{{.*}}!type ![[TYPE126:[0-9]+]]\n+pub fn foo127(_: Type7, _: Type7) { }\n+// CHECK: define{{.*}}foo127{{.*}}!type ![[TYPE127:[0-9]+]]\n+pub fn foo128(_: Type7, _: Type7, _: Type7) { }\n+// CHECK: define{{.*}}foo128{{.*}}!type ![[TYPE128:[0-9]+]]\n+pub fn foo129(_: Type8) { }\n+// CHECK: define{{.*}}foo129{{.*}}!type ![[TYPE129:[0-9]+]]\n+pub fn foo130(_: Type8, _: Type8) { }\n+// CHECK: define{{.*}}foo130{{.*}}!type ![[TYPE130:[0-9]+]]\n+pub fn foo131(_: Type8, _: Type8, _: Type8) { }\n+// CHECK: define{{.*}}foo131{{.*}}!type ![[TYPE131:[0-9]+]]\n+pub fn foo132(_: Type9) { }\n+// CHECK: define{{.*}}foo132{{.*}}!type ![[TYPE132:[0-9]+]]\n+pub fn foo133(_: Type9, _: Type9) { }\n+// CHECK: define{{.*}}foo133{{.*}}!type ![[TYPE133:[0-9]+]]\n+pub fn foo134(_: Type9, _: Type9, _: Type9) { }\n+// CHECK: define{{.*}}foo134{{.*}}!type ![[TYPE134:[0-9]+]]\n+pub fn foo135(_: Type10) { }\n+// CHECK: define{{.*}}foo135{{.*}}!type ![[TYPE135:[0-9]+]]\n+pub fn foo136(_: Type10, _: Type10) { }\n+// CHECK: define{{.*}}foo136{{.*}}!type ![[TYPE136:[0-9]+]]\n+pub fn foo137(_: Type10, _: Type10, _: Type10) { }\n+// CHECK: define{{.*}}foo137{{.*}}!type ![[TYPE137:[0-9]+]]\n+pub fn foo138(_: Type11) { }\n+// CHECK: define{{.*}}foo138{{.*}}!type ![[TYPE138:[0-9]+]]\n+pub fn foo139(_: Type11, _: Type11) { }\n+// CHECK: define{{.*}}foo139{{.*}}!type ![[TYPE139:[0-9]+]]\n+pub fn foo140(_: Type11, _: Type11, _: Type11) { }\n+// CHECK: define{{.*}}foo140{{.*}}!type ![[TYPE140:[0-9]+]]\n+pub fn foo141(_: Type12) { }\n+// CHECK: define{{.*}}foo141{{.*}}!type ![[TYPE141:[0-9]+]]\n+pub fn foo142(_: Type12, _: Type12) { }\n+// CHECK: define{{.*}}foo142{{.*}}!type ![[TYPE142:[0-9]+]]\n+pub fn foo143(_: Type12, _: Type12, _: Type12) { }\n+// CHECK: define{{.*}}foo143{{.*}}!type ![[TYPE143:[0-9]+]]\n+pub fn foo144(_: Type13) { }\n+// CHECK: define{{.*}}foo144{{.*}}!type ![[TYPE144:[0-9]+]]\n+pub fn foo145(_: Type13, _: Type13) { }\n+// CHECK: define{{.*}}foo145{{.*}}!type ![[TYPE145:[0-9]+]]\n+pub fn foo146(_: Type13, _: Type13, _: Type13) { }\n+// CHECK: define{{.*}}foo146{{.*}}!type ![[TYPE146:[0-9]+]]\n+\n+// CHECK: ![[TYPE0]] = !{i64 0, !\"_ZTSFvvE\"}\n+// CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFvvvE\"}\n+// CHECK: ![[TYPE2]] = !{i64 0, !\"_ZTSFvvvvE\"}\n+// CHECK: ![[TYPE3]] = !{i64 0, !\"_ZTSFvPvE\"}\n+// CHECK: ![[TYPE4]] = !{i64 0, !\"_ZTSFvPvS_E\"}\n+// CHECK: ![[TYPE5]] = !{i64 0, !\"_ZTSFvPvS_S_E\"}\n+// CHECK: ![[TYPE6]] = !{i64 0, !\"_ZTSFvPKvE\"}\n+// CHECK: ![[TYPE7]] = !{i64 0, !\"_ZTSFvPKvS0_E\"}\n+// CHECK: ![[TYPE8]] = !{i64 0, !\"_ZTSFvPKvS0_S0_E\"}\n+// CHECK: ![[TYPE9]] = !{i64 0, !\"_ZTSFvbE\"}\n+// CHECK: ![[TYPE10]] = !{i64 0, !\"_ZTSFvbbE\"}\n+// CHECK: ![[TYPE11]] = !{i64 0, !\"_ZTSFvbbbE\"}\n+// CHECK: ![[TYPE12]] = !{i64 0, !\"_ZTSFvu2i8E\"}\n+// CHECK: ![[TYPE13]] = !{i64 0, !\"_ZTSFvu2i8S_E\"}\n+// CHECK: ![[TYPE14]] = !{i64 0, !\"_ZTSFvu2i8S_S_E\"}\n+// CHECK: ![[TYPE15]] = !{i64 0, !\"_ZTSFvu3i16E\"}\n+// CHECK: ![[TYPE16]] = !{i64 0, !\"_ZTSFvu3i16S_E\"}\n+// CHECK: ![[TYPE17]] = !{i64 0, !\"_ZTSFvu3i16S_S_E\"}\n+// CHECK: ![[TYPE18]] = !{i64 0, !\"_ZTSFvu3i32E\"}\n+// CHECK: ![[TYPE19]] = !{i64 0, !\"_ZTSFvu3i32S_E\"}\n+// CHECK: ![[TYPE20]] = !{i64 0, !\"_ZTSFvu3i32S_S_E\"}\n+// CHECK: ![[TYPE21]] = !{i64 0, !\"_ZTSFvu3i64E\"}\n+// CHECK: ![[TYPE22]] = !{i64 0, !\"_ZTSFvu3i64S_E\"}\n+// CHECK: ![[TYPE23]] = !{i64 0, !\"_ZTSFvu3i64S_S_E\"}\n+// CHECK: ![[TYPE24]] = !{i64 0, !\"_ZTSFvu4i128E\"}\n+// CHECK: ![[TYPE25]] = !{i64 0, !\"_ZTSFvu4i128S_E\"}\n+// CHECK: ![[TYPE26]] = !{i64 0, !\"_ZTSFvu4i128S_S_E\"}\n+// CHECK: ![[TYPE27]] = !{i64 0, !\"_ZTSFvu5isizeE\"}\n+// CHECK: ![[TYPE28]] = !{i64 0, !\"_ZTSFvu5isizeS_E\"}\n+// CHECK: ![[TYPE29]] = !{i64 0, !\"_ZTSFvu5isizeS_S_E\"}\n+// CHECK: ![[TYPE30]] = !{i64 0, !\"_ZTSFvu2u8E\"}\n+// CHECK: ![[TYPE31]] = !{i64 0, !\"_ZTSFvu2u8S_E\"}\n+// CHECK: ![[TYPE32]] = !{i64 0, !\"_ZTSFvu2u8S_S_E\"}\n+// CHECK: ![[TYPE33]] = !{i64 0, !\"_ZTSFvu3u16E\"}\n+// CHECK: ![[TYPE34]] = !{i64 0, !\"_ZTSFvu3u16S_E\"}\n+// CHECK: ![[TYPE35]] = !{i64 0, !\"_ZTSFvu3u16S_S_E\"}\n+// CHECK: ![[TYPE36]] = !{i64 0, !\"_ZTSFvu3u32E\"}\n+// CHECK: ![[TYPE37]] = !{i64 0, !\"_ZTSFvu3u32S_E\"}\n+// CHECK: ![[TYPE38]] = !{i64 0, !\"_ZTSFvu3u32S_S_E\"}\n+// CHECK: ![[TYPE39]] = !{i64 0, !\"_ZTSFvu3u64E\"}\n+// CHECK: ![[TYPE40]] = !{i64 0, !\"_ZTSFvu3u64S_E\"}\n+// CHECK: ![[TYPE41]] = !{i64 0, !\"_ZTSFvu3u64S_S_E\"}\n+// CHECK: ![[TYPE42]] = !{i64 0, !\"_ZTSFvu4u128E\"}\n+// CHECK: ![[TYPE43]] = !{i64 0, !\"_ZTSFvu4u128S_E\"}\n+// CHECK: ![[TYPE44]] = !{i64 0, !\"_ZTSFvu4u128S_S_E\"}\n+// CHECK: ![[TYPE45]] = !{i64 0, !\"_ZTSFvu5usizeE\"}\n+// CHECK: ![[TYPE46]] = !{i64 0, !\"_ZTSFvu5usizeS_E\"}\n+// CHECK: ![[TYPE47]] = !{i64 0, !\"_ZTSFvu5usizeS_S_E\"}\n+// CHECK: ![[TYPE48]] = !{i64 0, !\"_ZTSFvu3f32E\"}\n+// CHECK: ![[TYPE49]] = !{i64 0, !\"_ZTSFvu3f32S_E\"}\n+// CHECK: ![[TYPE50]] = !{i64 0, !\"_ZTSFvu3f32S_S_E\"}\n+// CHECK: ![[TYPE51]] = !{i64 0, !\"_ZTSFvu3f64E\"}\n+// CHECK: ![[TYPE52]] = !{i64 0, !\"_ZTSFvu3f64S_E\"}\n+// CHECK: ![[TYPE53]] = !{i64 0, !\"_ZTSFvu3f64S_S_E\"}\n+// CHECK: ![[TYPE54]] = !{i64 0, !\"_ZTSFvu4charE\"}\n+// CHECK: ![[TYPE55]] = !{i64 0, !\"_ZTSFvu4charS_E\"}\n+// CHECK: ![[TYPE56]] = !{i64 0, !\"_ZTSFvu4charS_S_E\"}\n+// CHECK: ![[TYPE57]] = !{i64 0, !\"_ZTSFvu3refIu3strEE\"}\n+// CHECK: ![[TYPE58]] = !{i64 0, !\"_ZTSFvu3refIu3strES0_E\"}\n+// CHECK: ![[TYPE59]] = !{i64 0, !\"_ZTSFvu3refIu3strES0_S0_E\"}\n+// CHECK: ![[TYPE60]] = !{i64 0, !\"_ZTSFvu5tupleIu3i32S_EE\"}\n+// CHECK: ![[TYPE61]] = !{i64 0, !\"_ZTSFvu5tupleIu3i32S_ES0_E\"}\n+// CHECK: ![[TYPE62]] = !{i64 0, !\"_ZTSFvu5tupleIu3i32S_ES0_S0_E\"}\n+// CHECK: ![[TYPE63]] = !{i64 0, !\"_ZTSFvA32u3i32E\"}\n+// CHECK: ![[TYPE64]] = !{i64 0, !\"_ZTSFvA32u3i32S0_E\"}\n+// CHECK: ![[TYPE65]] = !{i64 0, !\"_ZTSFvA32u3i32S0_S0_E\"}\n+// CHECK: ![[TYPE66]] = !{i64 0, !\"_ZTSFvu3refIu5sliceIu3i32EEE\"}\n+// CHECK: ![[TYPE67]] = !{i64 0, !\"_ZTSFvu3refIu5sliceIu3i32EES1_E\"}\n+// CHECK: ![[TYPE68]] = !{i64 0, !\"_ZTSFvu3refIu5sliceIu3i32EES1_S1_E\"}\n+// CHECK: ![[TYPE69]] = !{i64 0, !\"_ZTSFvu3refIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi7Struct1Iu3i32EEE\"}\n+// CHECK: ![[TYPE70]] = !{i64 0, !\"_ZTSFvu3refIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi7Struct1Iu3i32EES1_E\"}\n+// CHECK: ![[TYPE71]] = !{i64 0, !\"_ZTSFvu3refIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi7Struct1Iu3i32EES1_S1_E\"}\n+// CHECK: ![[TYPE72]] = !{i64 0, !\"_ZTSFvu3refIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi5Enum1Iu3i32EEE\"}\n+// CHECK: ![[TYPE73]] = !{i64 0, !\"_ZTSFvu3refIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi5Enum1Iu3i32EES1_E\"}\n+// CHECK: ![[TYPE74]] = !{i64 0, !\"_ZTSFvu3refIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi5Enum1Iu3i32EES1_S1_E\"}\n+// CHECK: ![[TYPE75]] = !{i64 0, !\"_ZTSFvu3refIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Union1Iu3i32EEE\"}\n+// CHECK: ![[TYPE76]] = !{i64 0, !\"_ZTSFvu3refIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Union1Iu3i32EES1_E\"}\n+// CHECK: ![[TYPE77]] = !{i64 0, !\"_ZTSFvu3refIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Union1Iu3i32EES1_S1_E\"}\n+// CHECK: ![[TYPE78]] = !{i64 0, !\"_ZTSFvP5type1E\"}\n+// CHECK: ![[TYPE79]] = !{i64 0, !\"_ZTSFvP5type1S0_E\"}\n+// CHECK: ![[TYPE80]] = !{i64 0, !\"_ZTSFvP5type1S0_S0_E\"}\n+// CHECK: ![[TYPE81]] = !{i64 0, !\"_ZTSFvU3mutu3refIu3i32EE\"}\n+// CHECK: ![[TYPE82]] = !{i64 0, !\"_ZTSFvU3mutu3refIu3i32ES0_E\"}\n+// CHECK: ![[TYPE83]] = !{i64 0, !\"_ZTSFvU3mutu3refIu3i32ES0_S0_E\"}\n+// CHECK: ![[TYPE84]] = !{i64 0, !\"_ZTSFvu3refIu3i32EE\"}\n+// CHECK: ![[TYPE85]] = !{i64 0, !\"_ZTSFvu3refIu3i32EU3mutS0_E\"}\n+// CHECK: ![[TYPE86]] = !{i64 0, !\"_ZTSFvu3refIu3i32EU3mutS0_S1_E\"}\n+// CHECK: ![[TYPE87]] = !{i64 0, !\"_ZTSFvPu3i32E\"}\n+// CHECK: ![[TYPE88]] = !{i64 0, !\"_ZTSFvPu3i32PKS_E\"}\n+// CHECK: ![[TYPE89]] = !{i64 0, !\"_ZTSFvPu3i32PKS_S2_E\"}\n+// CHECK: ![[TYPE90]] = !{i64 0, !\"_ZTSFvPKu3i32E\"}\n+// CHECK: ![[TYPE91]] = !{i64 0, !\"_ZTSFvPKu3i32PS_E\"}\n+// CHECK: ![[TYPE92]] = !{i64 0, !\"_ZTSFvPKu3i32PS_S2_E\"}\n+// CHECK: ![[TYPE93]] = !{i64 0, !\"_ZTSFvPFu3i32S_EE\"}\n+// CHECK: ![[TYPE94]] = !{i64 0, !\"_ZTSFvPFu3i32S_ES0_E\"}\n+// CHECK: ![[TYPE95]] = !{i64 0, !\"_ZTSFvPFu3i32S_ES0_S0_E\"}\n+// CHECK: ![[TYPE96]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtNtC{{[[:print:]]+}}_4core3ops8function2FnIu5tupleIu3i32EEu{{[0-9]+}}NtNtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnce6OutputIS0_ES_u6regionEEE\"}\n+// CHECK: ![[TYPE97]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtNtC{{[[:print:]]+}}_4core3ops8function2FnIu5tupleIu3i32EEu{{[0-9]+}}NtNtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnce6OutputIS0_ES_u6regionEES5_E\"}\n+// CHECK: ![[TYPE98]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtNtC{{[[:print:]]+}}_4core3ops8function2FnIu5tupleIu3i32EEu{{[0-9]+}}NtNtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnce6OutputIS0_ES_u6regionEES5_S5_E\"}\n+// CHECK: ![[TYPE99]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtNtC{{[[:print:]]+}}_4core3ops8function5FnMutIu5tupleIu3i32EEu{{[0-9]+}}NtNtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnce6OutputIS0_ES_u6regionEEE\"}\n+// CHECK: ![[TYPE100]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtNtC{{[[:print:]]+}}_4core3ops8function5FnMutIu5tupleIu3i32EEu{{[0-9]+}}NtNtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnce6OutputIS0_ES_u6regionEES5_E\"}\n+// CHECK: ![[TYPE101]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtNtC{{[[:print:]]+}}_4core3ops8function5FnMutIu5tupleIu3i32EEu{{[0-9]+}}NtNtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnce6OutputIS0_ES_u6regionEES5_S5_E\"}\n+// CHECK: ![[TYPE102]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnceIu5tupleIu3i32EEu{{[0-9]+}}NtNtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnce6OutputIS0_ES_u6regionEEE\"}\n+// CHECK: ![[TYPE103]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnceIu5tupleIu3i32EEu{{[0-9]+}}NtNtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnce6OutputIS0_ES_u6regionEES5_E\"}\n+// CHECK: ![[TYPE104]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnceIu5tupleIu3i32EEu{{[0-9]+}}NtNtNtNtC{{[[:print:]]+}}_4core3ops8function6FnOnce6OutputIS0_ES_u6regionEES5_S5_E\"}\n+// CHECK: ![[TYPE105]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtC{{[[:print:]]+}}_4core6marker4Sendu6regionEEE\"}\n+// CHECK: ![[TYPE106]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtC{{[[:print:]]+}}_4core6marker4Sendu6regionEES2_E\"}\n+// CHECK: ![[TYPE107]] = !{i64 0, !\"_ZTSFvu3refIu3dynIu{{[0-9]+}}NtNtC{{[[:print:]]+}}_4core6marker4Sendu6regionEES2_S2_E\"}\n+// CHECK: ![[TYPE108]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NCNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn111{{[{}][{}]}}closure{{[}][}]}}Iu2i8PFvvEvEE\"}\n+// CHECK: ![[TYPE109]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NCNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn111{{[{}][{}]}}closure{{[}][}]}}Iu2i8PFvvEvES1_E\"}\n+// CHECK: ![[TYPE110]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NCNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn111{{[{}][{}]}}closure{{[}][}]}}Iu2i8PFvvEvES1_S1_E\"}\n+// CHECK: ![[TYPE111]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NcNtNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn13Foo15{{[{}][{}]}}constructor{{[}][}]}}E\"}\n+// CHECK: ![[TYPE112]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NcNtNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn13Foo15{{[{}][{}]}}constructor{{[}][}]}}S_E\"}\n+// CHECK: ![[TYPE113]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NcNtNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn13Foo15{{[{}][{}]}}constructor{{[}][}]}}S_S_E\"}\n+// CHECK: ![[TYPE114]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNFNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn110{{[{}][{}]}}extern{{[}][}]}}3fooE\"}\n+// CHECK: ![[TYPE115]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNFNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn110{{[{}][{}]}}extern{{[}][}]}}3fooS_E\"}\n+// CHECK: ![[TYPE116]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNFNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn110{{[{}][{}]}}extern{{[}][}]}}3fooS_S_E\"}\n+// CHECK: ![[TYPE117]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtNCNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn1s0_11{{[{}][{}]}}closure{{[}][}]}}3FooE\"}\n+// CHECK: ![[TYPE118]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtNCNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn1s0_11{{[{}][{}]}}closure{{[}][}]}}3FooS_E\"}\n+// CHECK: ![[TYPE119]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtNCNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn1s0_11{{[{}][{}]}}closure{{[}][}]}}3FooS_S_E\"}\n+// CHECK: ![[TYPE120]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtNkNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn112{{[{}][{}]}}constant{{[}][}]}}3FooE\"}\n+// CHECK: ![[TYPE121]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtNkNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn112{{[{}][{}]}}constant{{[}][}]}}3FooS_E\"}\n+// CHECK: ![[TYPE122]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtNkNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn112{{[{}][{}]}}constant{{[}][}]}}3FooS_S_E\"}\n+// CHECK: ![[TYPE123]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNINvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn18{{[{}][{}]}}impl{{[}][}]}}3fooIu3i32EE\"}\n+// CHECK: ![[TYPE124]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNINvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn18{{[{}][{}]}}impl{{[}][}]}}3fooIu3i32ES0_E\"}\n+// CHECK: ![[TYPE125]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNINvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn18{{[{}][{}]}}impl{{[}][}]}}3fooIu3i32ES0_S0_E\"}\n+// CHECK: ![[TYPE126]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait13fooIu3dynIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait1Iu3i32Eu6regionES_EE\"}\n+// CHECK: ![[TYPE127]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait13fooIu3dynIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait1Iu3i32Eu6regionES_ES3_E\"}\n+// CHECK: ![[TYPE128]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait13fooIu3dynIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait1Iu3i32Eu6regionES_ES3_S3_E\"}\n+// CHECK: ![[TYPE129]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait13fooIu3i32S_EE\"}\n+// CHECK: ![[TYPE130]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait13fooIu3i32S_ES0_E\"}\n+// CHECK: ![[TYPE131]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait13fooIu3i32S_ES0_S0_E\"}\n+// CHECK: ![[TYPE132]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait13fooIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi7Struct1Iu3i32ES_EE\"}\n+// CHECK: ![[TYPE133]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait13fooIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi7Struct1Iu3i32ES_ES1_E\"}\n+// CHECK: ![[TYPE134]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NvNtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi6Trait13fooIu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi7Struct1Iu3i32ES_ES1_S1_E\"}\n+// CHECK: ![[TYPE135]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn13QuxIu3i32Lu5usize32EEE\"}\n+// CHECK: ![[TYPE136]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn13QuxIu3i32Lu5usize32EES2_E\"}\n+// CHECK: ![[TYPE137]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn13QuxIu3i32Lu5usize32EES2_S2_E\"}\n+// CHECK: ![[TYPE138]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NcNtNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn15Quuux15{{[{}][{}]}}constructor{{[}][}]}}Iu6regionS_EE\"}\n+// CHECK: ![[TYPE139]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NcNtNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn15Quuux15{{[{}][{}]}}constructor{{[}][}]}}Iu6regionS_ES0_E\"}\n+// CHECK: ![[TYPE140]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NcNtNvC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3fn15Quuux15{{[{}][{}]}}constructor{{[}][}]}}Iu6regionS_ES0_S0_E\"}\n+// CHECK: ![[TYPE141]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3FooE\"}\n+// CHECK: ![[TYPE142]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3FooS_E\"}\n+// CHECK: ![[TYPE143]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3FooS_S_E\"}\n+// CHECK: ![[TYPE144]] = !{i64 0, !\"_ZTSFvu3refIu3refIvEEE\"}\n+// CHECK: ![[TYPE145]] = !{i64 0, !\"_ZTSFvu3refIu3refIvEES0_E\"}\n+// CHECK: ![[TYPE146]] = !{i64 0, !\"_ZTSFvu3refIu3refIvEES0_S0_E\"}"}, {"sha": "09310ba9f60a6d3b5a76b9c02ebe1e92e4dd26d2", "filename": "src/test/codegen/sanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -0,0 +1,31 @@\n+// Verifies that type metadata for functions are emitted.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo\n+    // CHECK-SAME: {{.*}}!type ![[TYPE1:[0-9]+]]\n+    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"_ZTSFu3i32S_E\")\n+    f(arg)\n+}\n+\n+pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}bar\n+    // CHECK-SAME: {{.*}}!type ![[TYPE2:[0-9]+]]\n+    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"_ZTSFu3i32S_S_E\")\n+    f(arg1, arg2)\n+}\n+\n+pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}baz\n+    // CHECK-SAME: {{.*}}!type ![[TYPE3:[0-9]+]]\n+    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"_ZTSFu3i32S_S_S_E\")\n+    f(arg1, arg2, arg3)\n+}\n+\n+// CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFu3i32PFS_S_ES_E\"}\n+// CHECK: ![[TYPE2]] = !{i64 0, !\"_ZTSFu3i32PFS_S_S_ES_S_E\"}\n+// CHECK: ![[TYPE3]] = !{i64 0, !\"_ZTSFu3i32PFS_S_S_S_ES_S_S_E\"}"}, {"sha": "96fced47e786d977f63bfe170e3886b0cfecef9d", "filename": "src/test/codegen/sanitizer_cfi_emit_type_metadata.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_emit_type_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_emit_type_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_emit_type_metadata.rs?ref=5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7", "patch": "@@ -1,31 +0,0 @@\n-// Verifies that type metadata for functions are emitted.\n-//\n-// ignore-windows\n-// needs-sanitizer-cfi\n-// only-aarch64\n-// only-x86_64\n-// compile-flags: -Clto -Cno-prepopulate-passes -Zsanitizer=cfi\n-\n-#![crate_type=\"lib\"]\n-\n-pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n-    // CHECK-LABEL: define{{.*}}foo{{.*}}!type !{{[0-9]+}}\n-    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"typeid1\")\n-    f(arg)\n-}\n-\n-pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n-    // CHECK-LABEL: define{{.*}}bar{{.*}}!type !{{[0-9]+}}\n-    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"typeid2\")\n-    f(arg1, arg2)\n-}\n-\n-pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n-    // CHECK-LABEL: define{{.*}}baz{{.*}}!type !{{[0-9]+}}\n-    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"typeid3\")\n-    f(arg1, arg2, arg3)\n-}\n-\n-// CHECK: !{{[0-9]+}} = !{i64 0, !\"typeid2\"}\n-// CHECK: !{{[0-9]+}} = !{i64 0, !\"typeid3\"}\n-// CHECK: !{{[0-9]+}} = !{i64 0, !\"typeid4\"}"}, {"sha": "a7da3dad15987ae474b5a97531fbc976645eb52e", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -847,6 +847,7 @@ pub fn make_test_description<R: Read>(\n     let rustc_has_sanitizer_support = env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some();\n     let has_asm_support = util::has_asm_support(&config.target);\n     let has_asan = util::ASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+    let has_cfi = util::CFI_SUPPORTED_TARGETS.contains(&&*config.target);\n     let has_lsan = util::LSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n     let has_msan = util::MSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n     let has_tsan = util::TSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n@@ -884,6 +885,7 @@ pub fn make_test_description<R: Read>(\n         ignore |= !rustc_has_sanitizer_support\n             && config.parse_name_directive(ln, \"needs-sanitizer-support\");\n         ignore |= !has_asan && config.parse_name_directive(ln, \"needs-sanitizer-address\");\n+        ignore |= !has_cfi && config.parse_name_directive(ln, \"needs-sanitizer-cfi\");\n         ignore |= !has_lsan && config.parse_name_directive(ln, \"needs-sanitizer-leak\");\n         ignore |= !has_msan && config.parse_name_directive(ln, \"needs-sanitizer-memory\");\n         ignore |= !has_tsan && config.parse_name_directive(ln, \"needs-sanitizer-thread\");"}, {"sha": "1a85a21a2a7ca015239c511328a6060f5fc3bb89", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad7a646a5df1c7e37fc4529f0f1000091ac902d/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=5ad7a646a5df1c7e37fc4529f0f1000091ac902d", "patch": "@@ -96,6 +96,23 @@ pub const ASAN_SUPPORTED_TARGETS: &[&str] = &[\n     \"x86_64-unknown-linux-gnu\",\n ];\n \n+// FIXME(rcvalle): More targets are likely supported.\n+pub const CFI_SUPPORTED_TARGETS: &[&str] = &[\n+    \"aarch64-apple-darwin\",\n+    \"aarch64-fuchsia\",\n+    \"aarch64-linux-android\",\n+    \"aarch64-unknown-freebsd\",\n+    \"aarch64-unknown-linux-gnu\",\n+    \"x86_64-apple-darwin\",\n+    \"x86_64-fuchsia\",\n+    \"x86_64-pc-solaris\",\n+    \"x86_64-unknown-freebsd\",\n+    \"x86_64-unknown-illumos\",\n+    \"x86_64-unknown-linux-gnu\",\n+    \"x86_64-unknown-linux-musl\",\n+    \"x86_64-unknown-netbsd\",\n+];\n+\n pub const LSAN_SUPPORTED_TARGETS: &[&str] = &[\n     // FIXME: currently broken, see #88132\n     // \"aarch64-apple-darwin\","}]}