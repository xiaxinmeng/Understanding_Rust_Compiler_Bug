{"sha": "35385770ae1ea86a911cc44ac43f856831e44b26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1Mzg1NzcwYWUxZWE4NmE5MTFjYzQ0YWM0M2Y4NTY4MzFlNDRiMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-22T01:16:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-22T01:16:29Z"}, "message": "Auto merge of #79846 - the8472:inplace-tra, r=m-ou-se\n\nUse TrustedRandomAccess for in-place iterators where possible\n\nThis can speed up in-place iterators containing simple casts and transmutes from `Copy` types to any type of same size. `!Copy` types can't be optimized since `TrustedRandomAccess`  isn't implemented for those iterators.\n\n```\n name                  on.b ns/iter     o1.b ns/iter     diff ns/iter   diff %  speedup\n vec::bench_transmute  20 (40000 MB/s)  12 (66666 MB/s)            -8  -40.00%   x 1.67\n```", "tree": {"sha": "509eb08317fe567c9294f2162699bb310266f52c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/509eb08317fe567c9294f2162699bb310266f52c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35385770ae1ea86a911cc44ac43f856831e44b26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35385770ae1ea86a911cc44ac43f856831e44b26", "html_url": "https://github.com/rust-lang/rust/commit/35385770ae1ea86a911cc44ac43f856831e44b26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35385770ae1ea86a911cc44ac43f856831e44b26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97663b6690689379aa0493deb494dfe14627c46b", "url": "https://api.github.com/repos/rust-lang/rust/commits/97663b6690689379aa0493deb494dfe14627c46b", "html_url": "https://github.com/rust-lang/rust/commit/97663b6690689379aa0493deb494dfe14627c46b"}, {"sha": "2d8be457434103bfeeea59f1882a15760f2a5c70", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8be457434103bfeeea59f1882a15760f2a5c70", "html_url": "https://github.com/rust-lang/rust/commit/2d8be457434103bfeeea59f1882a15760f2a5c70"}], "stats": {"total": 99, "additions": 83, "deletions": 16}, "files": [{"sha": "7a098219ce4a75759f4a3436f3dfc93a6b605be8", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35385770ae1ea86a911cc44ac43f856831e44b26/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35385770ae1ea86a911cc44ac43f856831e44b26/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=35385770ae1ea86a911cc44ac43f856831e44b26", "patch": "@@ -548,6 +548,22 @@ fn bench_in_place_zip_iter_mut(b: &mut Bencher) {\n     black_box(data);\n }\n \n+pub fn vec_cast<T, U>(input: Vec<T>) -> Vec<U> {\n+    input.into_iter().map(|e| unsafe { std::mem::transmute_copy(&e) }).collect()\n+}\n+\n+#[bench]\n+fn bench_transmute(b: &mut Bencher) {\n+    let mut vec = vec![10u32; 100];\n+    b.bytes = 800; // 2 casts x 4 bytes x 100\n+    b.iter(|| {\n+        let v = std::mem::take(&mut vec);\n+        let v = black_box(vec_cast::<u32, i32>(v));\n+        let v = black_box(vec_cast::<i32, u32>(v));\n+        vec = v;\n+    });\n+}\n+\n #[derive(Clone)]\n struct Droppable(usize);\n "}, {"sha": "50882fc17673e76f40be6e4b8f22359fed8e862d", "filename": "library/alloc/src/vec/source_iter_marker.rs", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/35385770ae1ea86a911cc44ac43f856831e44b26/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35385770ae1ea86a911cc44ac43f856831e44b26/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs?ref=35385770ae1ea86a911cc44ac43f856831e44b26", "patch": "@@ -1,4 +1,4 @@\n-use core::iter::{InPlaceIterable, SourceIter};\n+use core::iter::{InPlaceIterable, SourceIter, TrustedRandomAccess};\n use core::mem::{self, ManuallyDrop};\n use core::ptr::{self};\n \n@@ -52,16 +52,7 @@ where\n             )\n         };\n \n-        // use try-fold since\n-        // - it vectorizes better for some iterator adapters\n-        // - unlike most internal iteration methods, it only takes a &mut self\n-        // - it lets us thread the write pointer through its innards and get it back in the end\n-        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n-        let sink = iterator\n-            .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(dst_end))\n-            .unwrap();\n-        // iteration succeeded, don't drop head\n-        let dst = ManuallyDrop::new(sink).dst;\n+        let len = SpecInPlaceCollect::collect_in_place(&mut iterator, dst_buf, dst_end);\n \n         let src = unsafe { iterator.as_inner().as_into_iter() };\n         // check if SourceIter contract was upheld\n@@ -72,7 +63,7 @@ where\n         // then the source pointer will stay in its initial position and we can't use it as reference\n         if src.ptr != src_ptr {\n             debug_assert!(\n-                dst as *const _ <= src.ptr,\n+                unsafe { dst_buf.add(len) as *const _ } <= src.ptr,\n                 \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n             );\n         }\n@@ -82,10 +73,7 @@ where\n         // but prevent drop of the allocation itself once IntoIter goes out of scope\n         src.forget_allocation();\n \n-        let vec = unsafe {\n-            let len = dst.offset_from(dst_buf) as usize;\n-            Vec::from_raw_parts(dst_buf, len, cap)\n-        };\n+        let vec = unsafe { Vec::from_raw_parts(dst_buf, len, cap) };\n \n         vec\n     }\n@@ -106,3 +94,52 @@ fn write_in_place_with_drop<T>(\n         Ok(sink)\n     }\n }\n+\n+/// Helper trait to hold specialized implementations of the in-place iterate-collect loop\n+trait SpecInPlaceCollect<T, I>: Iterator<Item = T> {\n+    /// Collects an iterator (`self`) into the destination buffer (`dst`) and returns the number of items\n+    /// collected. `end` is the last writable element of the allocation and used for bounds checks.\n+    fn collect_in_place(&mut self, dst: *mut T, end: *const T) -> usize;\n+}\n+\n+impl<T, I> SpecInPlaceCollect<T, I> for I\n+where\n+    I: Iterator<Item = T>,\n+{\n+    #[inline]\n+    default fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n+        // use try-fold since\n+        // - it vectorizes better for some iterator adapters\n+        // - unlike most internal iteration methods, it only takes a &mut self\n+        // - it lets us thread the write pointer through its innards and get it back in the end\n+        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n+        let sink =\n+            self.try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(end)).unwrap();\n+        // iteration succeeded, don't drop head\n+        unsafe { ManuallyDrop::new(sink).dst.offset_from(dst_buf) as usize }\n+    }\n+}\n+\n+impl<T, I> SpecInPlaceCollect<T, I> for I\n+where\n+    I: Iterator<Item = T> + TrustedRandomAccess,\n+{\n+    #[inline]\n+    fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n+        let len = self.size();\n+        let mut drop_guard = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n+        for i in 0..len {\n+            // Safety: InplaceIterable contract guarantees that for every element we read\n+            // one slot in the underlying storage will have been freed up and we can immediately\n+            // write back the result.\n+            unsafe {\n+                let dst = dst_buf.offset(i as isize);\n+                debug_assert!(dst as *const _ <= end, \"InPlaceIterable contract violation\");\n+                ptr::write(dst, self.__iterator_get_unchecked(i));\n+                drop_guard.dst = dst.add(1);\n+            }\n+        }\n+        mem::forget(drop_guard);\n+        len\n+    }\n+}"}, {"sha": "72ed7492be93cb38fb2de2be2210feef86703598", "filename": "src/test/codegen/vec-in-place.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35385770ae1ea86a911cc44ac43f856831e44b26/src%2Ftest%2Fcodegen%2Fvec-in-place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35385770ae1ea86a911cc44ac43f856831e44b26/src%2Ftest%2Fcodegen%2Fvec-in-place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-in-place.rs?ref=35385770ae1ea86a911cc44ac43f856831e44b26", "patch": "@@ -0,0 +1,14 @@\n+// ignore-debug: the debug assertions get in the way\n+// compile-flags: -O\n+// min-llvm-version: 11.0\n+#![crate_type = \"lib\"]\n+\n+// Ensure that trivial casts of vec elements are O(1)\n+\n+// CHECK-LABEL: @vec_iterator_cast\n+#[no_mangle]\n+pub fn vec_iterator_cast(vec: Vec<isize>) -> Vec<usize> {\n+    // CHECK-NOT: loop\n+    // CHECK-NOT: call\n+    vec.into_iter().map(|e| e as usize).collect()\n+}"}]}