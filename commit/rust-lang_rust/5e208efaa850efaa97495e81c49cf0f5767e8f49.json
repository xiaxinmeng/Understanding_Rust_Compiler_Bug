{"sha": "5e208efaa850efaa97495e81c49cf0f5767e8f49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMjA4ZWZhYTg1MGVmYWE5NzQ5NWU4MWM0OWNmMGY1NzY3ZThmNDk=", "commit": {"author": {"name": "DPC", "email": "dylan.dpc@gmail.com", "date": "2020-08-29T00:13:02Z"}, "committer": {"name": "DPC", "email": "dylan.dpc@gmail.com", "date": "2020-08-29T00:13:02Z"}, "message": "rename get_{ref, mut} to assume_init_{ref,mut} in Maybeuninit", "tree": {"sha": "cbe063954292f51ba594a070a482200e6e4c0e67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbe063954292f51ba594a070a482200e6e4c0e67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e208efaa850efaa97495e81c49cf0f5767e8f49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e208efaa850efaa97495e81c49cf0f5767e8f49", "html_url": "https://github.com/rust-lang/rust/commit/5e208efaa850efaa97495e81c49cf0f5767e8f49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e208efaa850efaa97495e81c49cf0f5767e8f49/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf4342114e357f2934d59e12e31e94532ddb2adf", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf4342114e357f2934d59e12e31e94532ddb2adf", "html_url": "https://github.com/rust-lang/rust/commit/bf4342114e357f2934d59e12e31e94532ddb2adf"}], "stats": {"total": 57, "additions": 29, "deletions": 28}, "files": [{"sha": "29b39f197be736c5235b45c49f106008519d58e4", "filename": "library/core/src/fmt/float.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e208efaa850efaa97495e81c49cf0f5767e8f49/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e208efaa850efaa97495e81c49cf0f5767e8f49/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs?ref=5e208efaa850efaa97495e81c49cf0f5767e8f49", "patch": "@@ -28,8 +28,8 @@ where\n             *num,\n             sign,\n             precision,\n-            buf.get_mut(),\n-            parts.get_mut(),\n+            buf.assume_init_mut(),\n+            parts.assume_init_mut(),\n         );\n         fmt.pad_formatted_parts(&formatted)\n     }\n@@ -58,8 +58,8 @@ where\n             *num,\n             sign,\n             precision,\n-            buf.get_mut(),\n-            parts.get_mut(),\n+            buf.assume_init_mut(),\n+            parts.assume_init_mut(),\n         );\n         fmt.pad_formatted_parts(&formatted)\n     }\n@@ -114,8 +114,8 @@ where\n             sign,\n             precision,\n             upper,\n-            buf.get_mut(),\n-            parts.get_mut(),\n+            buf.assume_init_mut(),\n+            parts.assume_init_mut(),\n         );\n         fmt.pad_formatted_parts(&formatted)\n     }\n@@ -145,8 +145,8 @@ where\n             sign,\n             (0, 0),\n             upper,\n-            buf.get_mut(),\n-            parts.get_mut(),\n+            buf.assume_init_mut(),\n+            parts.assume_init_mut(),\n         );\n         fmt.pad_formatted_parts(&formatted)\n     }"}, {"sha": "0166b3f22865aafabae5aa541705d760883545d6", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5e208efaa850efaa97495e81c49cf0f5767e8f49/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e208efaa850efaa97495e81c49cf0f5767e8f49/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=5e208efaa850efaa97495e81c49cf0f5767e8f49", "patch": "@@ -167,7 +167,8 @@ use crate::mem::ManuallyDrop;\n ///\n /// // For each item in the array, drop if we allocated it.\n /// for elem in &mut data[0..data_len] {\n-///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n+///     unsafe { ptr::drop_in_place(elem.\n+/// ptr()); }\n /// }\n /// ```\n ///\n@@ -369,7 +370,7 @@ impl<T> MaybeUninit<T> {\n     pub fn write(&mut self, val: T) -> &mut T {\n         unsafe {\n             self.value = ManuallyDrop::new(val);\n-            self.get_mut()\n+            self.assume_init_mut()\n         }\n     }\n \n@@ -601,7 +602,7 @@ impl<T> MaybeUninit<T> {\n     /// // create a shared reference to it:\n     /// let x: &Vec<u32> = unsafe {\n     ///     // Safety: `x` has been initialized.\n-    ///     x.get_ref()\n+    ///     x.assume_init_ref()\n     /// };\n     /// assert_eq!(x, &vec![1, 2, 3]);\n     /// ```\n@@ -613,7 +614,7 @@ impl<T> MaybeUninit<T> {\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// let x_vec: &Vec<u32> = unsafe { x.get_ref() };\n+    /// let x_vec: &Vec<u32> = unsafe { x.assume_init_ref() };\n     /// // We have created a reference to an uninitialized vector! This is undefined behavior. \u26a0\ufe0f\n     /// ```\n     ///\n@@ -624,14 +625,14 @@ impl<T> MaybeUninit<T> {\n     /// let b = MaybeUninit::<Cell<bool>>::uninit();\n     /// // Initialize the `MaybeUninit` using `Cell::set`:\n     /// unsafe {\n-    ///     b.get_ref().set(true);\n+    ///     b.assume_init_ref().set(true);\n     ///  // ^^^^^^^^^^^\n     ///  // Reference to an uninitialized `Cell<bool>`: UB!\n     /// }\n     /// ```\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n-    pub unsafe fn get_ref(&self) -> &T {\n+    pub unsafe fn assume_init_ref(&self) -> &T {\n         // SAFETY: the caller must guarantee that `self` is initialized.\n         // This also means that `self` must be a `value` variant.\n         unsafe {\n@@ -650,7 +651,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// Calling this when the content is not yet fully initialized causes undefined\n     /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n-    /// is in an initialized state. For instance, `.get_mut()` cannot be used to\n+    /// is in an initialized state. For instance, `.assume_init_mut()` cannot be used to\n     /// initialize a `MaybeUninit`.\n     ///\n     /// # Examples\n@@ -678,7 +679,7 @@ impl<T> MaybeUninit<T> {\n     /// // the `&mut MaybeUninit<[u8; 2048]>` to a `&mut [u8; 2048]`:\n     /// let buf: &mut [u8; 2048] = unsafe {\n     ///     // Safety: `buf` has been initialized.\n-    ///     buf.get_mut()\n+    ///     buf.assume_init_ref()\n     /// };\n     ///\n     /// // Now we can use `buf` as a normal slice:\n@@ -691,15 +692,15 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// ### *Incorrect* usages of this method:\n     ///\n-    /// You cannot use `.get_mut()` to initialize a value:\n+    /// You cannot use `.assume_init_mut()` to initialize a value:\n     ///\n     /// ```rust,no_run\n     /// #![feature(maybe_uninit_ref)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut b = MaybeUninit::<bool>::uninit();\n     /// unsafe {\n-    ///     *b.get_mut() = true;\n+    ///     *b.assume_init_mut() = true;\n     ///     // We have created a (mutable) reference to an uninitialized `bool`!\n     ///     // This is undefined behavior. \u26a0\ufe0f\n     /// }\n@@ -716,7 +717,7 @@ impl<T> MaybeUninit<T> {\n     /// fn read_chunk (reader: &'_ mut dyn io::Read) -> io::Result<[u8; 64]>\n     /// {\n     ///     let mut buffer = MaybeUninit::<[u8; 64]>::uninit();\n-    ///     reader.read_exact(unsafe { buffer.get_mut() })?;\n+    ///     reader.read_exact(unsafe { buffer.assume_init_mut() })?;\n     ///                             // ^^^^^^^^^^^^^^^^\n     ///                             // (mutable) reference to uninitialized memory!\n     ///                             // This is undefined behavior.\n@@ -737,23 +738,23 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let foo: Foo = unsafe {\n     ///     let mut foo = MaybeUninit::<Foo>::uninit();\n-    ///     ptr::write(&mut foo.get_mut().a as *mut u32, 1337);\n+    ///     ptr::write(&mut foo.assume_init_mut().a as *mut u32, 1337);\n     ///                  // ^^^^^^^^^^^^^\n     ///                  // (mutable) reference to uninitialized memory!\n     ///                  // This is undefined behavior.\n-    ///     ptr::write(&mut foo.get_mut().b as *mut u8, 42);\n+    ///     ptr::write(&mut foo.assume_init_mut().b as *mut u8, 42);\n     ///                  // ^^^^^^^^^^^^^\n     ///                  // (mutable) reference to uninitialized memory!\n     ///                  // This is undefined behavior.\n-    ///     foo.assume_init()\n+    ///     foo.assume_init_mut()\n     /// };\n     /// ```\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n-    pub unsafe fn get_mut(&mut self) -> &mut T {\n+    pub unsafe fn assume_init_mut(&mut self) -> &mut T {\n         // SAFETY: the caller must guarantee that `self` is initialized.\n         // This also means that `self` must be a `value` variant.\n         unsafe {"}, {"sha": "47498ff7e9f0c51e84ff8660de4a0c519d288719", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e208efaa850efaa97495e81c49cf0f5767e8f49/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e208efaa850efaa97495e81c49cf0f5767e8f49/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=5e208efaa850efaa97495e81c49cf0f5767e8f49", "patch": "@@ -55,18 +55,18 @@ where\n     // to uninitialized data, but within libstd we can rely on more guarantees\n     // than if this code were in an external lib.\n     unsafe {\n-        reader.initializer().initialize(buf.get_mut());\n+        reader.initializer().initialize(buf.assume_init_mut());\n     }\n \n     let mut written = 0;\n     loop {\n-        let len = match reader.read(unsafe { buf.get_mut() }) {\n+        let len = match reader.read(unsafe { buf.assume_init_mut() }) {\n             Ok(0) => return Ok(written),\n             Ok(len) => len,\n             Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),\n         };\n-        writer.write_all(unsafe { &buf.get_ref()[..len] })?;\n+        writer.write_all(unsafe { &buf.assume_init_ref()[..len] })?;\n         written += len as u64;\n     }\n }"}, {"sha": "d44539051408591f08f7e4049bc5e0d047e839df", "filename": "library/std/src/lazy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e208efaa850efaa97495e81c49cf0f5767e8f49/library%2Fstd%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e208efaa850efaa97495e81c49cf0f5767e8f49/library%2Fstd%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy.rs?ref=5e208efaa850efaa97495e81c49cf0f5767e8f49", "patch": "@@ -376,13 +376,13 @@ impl<T> SyncOnceCell<T> {\n     /// Safety: The value must be initialized\n     unsafe fn get_unchecked(&self) -> &T {\n         debug_assert!(self.is_initialized());\n-        (&*self.value.get()).get_ref()\n+        (&*self.value.get()).assume_init_ref()\n     }\n \n     /// Safety: The value must be initialized\n     unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n         debug_assert!(self.is_initialized());\n-        (&mut *self.value.get()).get_mut()\n+        (&mut *self.value.get()).assume_init_mut()\n     }\n }\n "}]}