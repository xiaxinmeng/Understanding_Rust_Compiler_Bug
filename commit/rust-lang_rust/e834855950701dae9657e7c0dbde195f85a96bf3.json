{"sha": "e834855950701dae9657e7c0dbde195f85a96bf3", "node_id": "C_kwDOAAsO6NoAKGU4MzQ4NTU5NTA3MDFkYWU5NjU3ZTdjMGRiZGUxOTVmODVhOTZiZjM", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-06T01:07:29Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-19T14:54:55Z"}, "message": "Move `StableSortPrimitive` to `Methods` lint pass", "tree": {"sha": "b5fd861959d495586692afef6d2ab33691163ff6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5fd861959d495586692afef6d2ab33691163ff6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e834855950701dae9657e7c0dbde195f85a96bf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e834855950701dae9657e7c0dbde195f85a96bf3", "html_url": "https://github.com/rust-lang/rust/commit/e834855950701dae9657e7c0dbde195f85a96bf3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e834855950701dae9657e7c0dbde195f85a96bf3/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06d752e28dcc4b343f9d437e59d7ebbedff3fde8", "url": "https://api.github.com/repos/rust-lang/rust/commits/06d752e28dcc4b343f9d437e59d7ebbedff3fde8", "html_url": "https://github.com/rust-lang/rust/commit/06d752e28dcc4b343f9d437e59d7ebbedff3fde8"}], "stats": {"total": 224, "additions": 76, "deletions": 148}, "files": [{"sha": "e8c796b4e9b607c391524741ab953d867f9f0cd1", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e834855950701dae9657e7c0dbde195f85a96bf3/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e834855950701dae9657e7c0dbde195f85a96bf3/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=e834855950701dae9657e7c0dbde195f85a96bf3", "patch": "@@ -353,6 +353,7 @@ store.register_lints(&[\n     methods::SINGLE_CHAR_ADD_STR,\n     methods::SINGLE_CHAR_PATTERN,\n     methods::SKIP_WHILE_NEXT,\n+    methods::STABLE_SORT_PRIMITIVE,\n     methods::STRING_EXTEND_CHARS,\n     methods::SUSPICIOUS_MAP,\n     methods::SUSPICIOUS_SPLITN,\n@@ -504,7 +505,6 @@ store.register_lints(&[\n     single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS,\n     size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT,\n     slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n-    stable_sort_primitive::STABLE_SORT_PRIMITIVE,\n     std_instead_of_core::ALLOC_INSTEAD_OF_CORE,\n     std_instead_of_core::STD_INSTEAD_OF_ALLOC,\n     std_instead_of_core::STD_INSTEAD_OF_CORE,"}, {"sha": "13474127e8d75c9681bc61f530593f0c527916cb", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e834855950701dae9657e7c0dbde195f85a96bf3/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e834855950701dae9657e7c0dbde195f85a96bf3/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=e834855950701dae9657e7c0dbde195f85a96bf3", "patch": "@@ -64,6 +64,7 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(methods::MANUAL_OK_OR),\n     LintId::of(methods::MAP_UNWRAP_OR),\n     LintId::of(methods::NAIVE_BYTECOUNT),\n+    LintId::of(methods::STABLE_SORT_PRIMITIVE),\n     LintId::of(methods::UNNECESSARY_JOIN),\n     LintId::of(misc::USED_UNDERSCORE_BINDING),\n     LintId::of(mismatching_type_param_order::MISMATCHING_TYPE_PARAM_ORDER),\n@@ -85,7 +86,6 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(ref_option_ref::REF_OPTION_REF),\n     LintId::of(return_self_not_must_use::RETURN_SELF_NOT_MUST_USE),\n     LintId::of(semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED),\n-    LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n     LintId::of(strings::STRING_ADD_ASSIGN),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n     LintId::of(types::LINKEDLIST),"}, {"sha": "c424c373d3229db2c7f8741b28697b02ae9904dd", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e834855950701dae9657e7c0dbde195f85a96bf3/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e834855950701dae9657e7c0dbde195f85a96bf3/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e834855950701dae9657e7c0dbde195f85a96bf3", "patch": "@@ -354,7 +354,6 @@ mod single_char_lifetime_names;\n mod single_component_path_imports;\n mod size_of_in_element_count;\n mod slow_vector_initialization;\n-mod stable_sort_primitive;\n mod std_instead_of_core;\n mod strings;\n mod strlen_on_c_strings;\n@@ -822,7 +821,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || Box::new(nonstandard_macro_braces::MacroBraces::new(&macro_matcher)));\n     store.register_late_pass(|| Box::new(macro_use::MacroUseImports::default()));\n     store.register_late_pass(|| Box::new(pattern_type_mismatch::PatternTypeMismatch));\n-    store.register_late_pass(|| Box::new(stable_sort_primitive::StableSortPrimitive));\n     store.register_late_pass(|| Box::new(unwrap_in_result::UnwrapInResult));\n     store.register_late_pass(|| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n     store.register_late_pass(|| Box::new(async_yields_async::AsyncYieldsAsync));"}, {"sha": "a47081d8752c522eb3343c735acfc7c3555354c6", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e834855950701dae9657e7c0dbde195f85a96bf3/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e834855950701dae9657e7c0dbde195f85a96bf3/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=e834855950701dae9657e7c0dbde195f85a96bf3", "patch": "@@ -72,6 +72,7 @@ mod single_char_insert_string;\n mod single_char_pattern;\n mod single_char_push_string;\n mod skip_while_next;\n+mod stable_sort_primitive;\n mod str_splitn;\n mod string_extend_chars;\n mod suspicious_map;\n@@ -2793,6 +2794,44 @@ declare_clippy_lint! {\n     \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// When sorting primitive values (integers, bools, chars, as well\n+    /// as arrays, slices, and tuples of such items), it is typically better to\n+    /// use an unstable sort than a stable sort.\n+    ///\n+    /// ### Why is this bad?\n+    /// Typically, using a stable sort consumes more memory and cpu cycles.\n+    /// Because values which compare equal are identical, preserving their\n+    /// relative order (the guarantee that a stable sort provides) means\n+    /// nothing, while the extra costs still apply.\n+    ///\n+    /// ### Known problems\n+    ///\n+    /// As pointed out in\n+    /// [issue #8241](https://github.com/rust-lang/rust-clippy/issues/8241),\n+    /// a stable sort can instead be significantly faster for certain scenarios\n+    /// (eg. when a sorted vector is extended with new data and resorted).\n+    ///\n+    /// For more information and benchmarking results, please refer to the\n+    /// issue linked above.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut vec = vec![2, 1, 3];\n+    /// vec.sort();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut vec = vec![2, 1, 3];\n+    /// vec.sort_unstable();\n+    /// ```\n+    #[clippy::version = \"1.47.0\"]\n+    pub STABLE_SORT_PRIMITIVE,\n+    pedantic,\n+    \"use of sort() when sort_unstable() is equivalent\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -2909,6 +2948,7 @@ impl_lint_pass!(Methods => [\n     PATH_BUF_PUSH_OVERWRITE,\n     RANGE_ZIP_WITH_LEN,\n     REPEAT_ONCE,\n+    STABLE_SORT_PRIMITIVE,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -3300,6 +3340,9 @@ impl Methods {\n                 (\"repeat\", [arg]) => {\n                     repeat_once::check(cx, expr, recv, arg);\n                 },\n+                (\"sort\", []) => {\n+                    stable_sort_primitive::check(cx, expr, recv);\n+                },\n                 (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n                     if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n                         suspicious_splitn::check(cx, name, expr, recv, count);"}, {"sha": "91951c65bb3095aebbeefb7fb105b35f53c05047", "filename": "clippy_lints/src/methods/stable_sort_primitive.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e834855950701dae9657e7c0dbde195f85a96bf3/clippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e834855950701dae9657e7c0dbde195f85a96bf3/clippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs?ref=e834855950701dae9657e7c0dbde195f85a96bf3", "patch": "@@ -0,0 +1,31 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_slice_of_primitives;\n+use clippy_utils::source::snippet_with_context;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+\n+use super::STABLE_SORT_PRIMITIVE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, recv: &'tcx Expr<'_>) {\n+    if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id)\n+        && let Some(impl_id) = cx.tcx.impl_of_method(method_id)\n+        && cx.tcx.type_of(impl_id).is_slice()\n+        && let Some(slice_type) = is_slice_of_primitives(cx, recv)\n+    {\n+        span_lint_and_then(\n+            cx,\n+            STABLE_SORT_PRIMITIVE,\n+            e.span,\n+            &format!(\"used `sort` on primitive type `{}`\", slice_type),\n+            |diag| {\n+                let mut app = Applicability::MachineApplicable;\n+                let recv_snip = snippet_with_context(cx, recv.span, e.span.ctxt(), \"..\", &mut app).0;\n+                diag.span_suggestion(e.span, \"try\", format!(\"{}.sort_unstable()\", recv_snip), app);\n+                diag.note(\n+                    \"an unstable sort typically performs faster without any observable difference for this data type\",\n+                );\n+            },\n+        );\n+    }\n+}"}, {"sha": "6d54935f81ab26e29d03b3eac6e1fc33e2c88ea9", "filename": "clippy_lints/src/stable_sort_primitive.rs", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/06d752e28dcc4b343f9d437e59d7ebbedff3fde8/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06d752e28dcc4b343f9d437e59d7ebbedff3fde8/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs?ref=06d752e28dcc4b343f9d437e59d7ebbedff3fde8", "patch": "@@ -1,144 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::{is_slice_of_primitives, sugg::Sugg};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// When sorting primitive values (integers, bools, chars, as well\n-    /// as arrays, slices, and tuples of such items), it is typically better to\n-    /// use an unstable sort than a stable sort.\n-    ///\n-    /// ### Why is this bad?\n-    /// Typically, using a stable sort consumes more memory and cpu cycles.\n-    /// Because values which compare equal are identical, preserving their\n-    /// relative order (the guarantee that a stable sort provides) means\n-    /// nothing, while the extra costs still apply.\n-    ///\n-    /// ### Known problems\n-    ///\n-    /// As pointed out in\n-    /// [issue #8241](https://github.com/rust-lang/rust-clippy/issues/8241),\n-    /// a stable sort can instead be significantly faster for certain scenarios\n-    /// (eg. when a sorted vector is extended with new data and resorted).\n-    ///\n-    /// For more information and benchmarking results, please refer to the\n-    /// issue linked above.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let mut vec = vec![2, 1, 3];\n-    /// vec.sort();\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let mut vec = vec![2, 1, 3];\n-    /// vec.sort_unstable();\n-    /// ```\n-    #[clippy::version = \"1.47.0\"]\n-    pub STABLE_SORT_PRIMITIVE,\n-    pedantic,\n-    \"use of sort() when sort_unstable() is equivalent\"\n-}\n-\n-declare_lint_pass!(StableSortPrimitive => [STABLE_SORT_PRIMITIVE]);\n-\n-/// The three \"kinds\" of sorts\n-enum SortingKind {\n-    Vanilla,\n-    /* The other kinds of lint are currently commented out because they\n-     * can map distinct values to equal ones. If the key function is\n-     * provably one-to-one, or if the Cmp function conserves equality,\n-     * then they could be linted on, but I don't know if we can check\n-     * for that. */\n-\n-    /* ByKey,\n-     * ByCmp, */\n-}\n-impl SortingKind {\n-    /// The name of the stable version of this kind of sort\n-    fn stable_name(&self) -> &str {\n-        match self {\n-            SortingKind::Vanilla => \"sort\",\n-            /* SortingKind::ByKey => \"sort_by_key\",\n-             * SortingKind::ByCmp => \"sort_by\", */\n-        }\n-    }\n-    /// The name of the unstable version of this kind of sort\n-    fn unstable_name(&self) -> &str {\n-        match self {\n-            SortingKind::Vanilla => \"sort_unstable\",\n-            /* SortingKind::ByKey => \"sort_unstable_by_key\",\n-             * SortingKind::ByCmp => \"sort_unstable_by\", */\n-        }\n-    }\n-    /// Takes the name of a function call and returns the kind of sort\n-    /// that corresponds to that function name (or None if it isn't)\n-    fn from_stable_name(name: &str) -> Option<SortingKind> {\n-        match name {\n-            \"sort\" => Some(SortingKind::Vanilla),\n-            // \"sort_by\" => Some(SortingKind::ByCmp),\n-            // \"sort_by_key\" => Some(SortingKind::ByKey),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-/// A detected instance of this lint\n-struct LintDetection {\n-    slice_name: String,\n-    method: SortingKind,\n-    method_args: String,\n-    slice_type: String,\n-}\n-\n-fn detect_stable_sort_primitive(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintDetection> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_name, [slice, args @ ..], _) = &expr.kind;\n-        if let Some(method) = SortingKind::from_stable_name(method_name.ident.name.as_str());\n-        if let Some(slice_type) = is_slice_of_primitives(cx, slice);\n-        then {\n-            let args_str = args.iter().map(|arg| Sugg::hir(cx, arg, \"..\").to_string()).collect::<Vec<String>>().join(\", \");\n-            Some(LintDetection { slice_name: Sugg::hir(cx, slice, \"..\").to_string(), method, method_args: args_str, slice_type })\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl LateLintPass<'_> for StableSortPrimitive {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if let Some(detection) = detect_stable_sort_primitive(cx, expr) {\n-            span_lint_and_then(\n-                cx,\n-                STABLE_SORT_PRIMITIVE,\n-                expr.span,\n-                format!(\n-                    \"used `{}` on primitive type `{}`\",\n-                    detection.method.stable_name(),\n-                    detection.slice_type,\n-                )\n-                .as_str(),\n-                |diag| {\n-                    diag.span_suggestion(\n-                        expr.span,\n-                        \"try\",\n-                        format!(\n-                            \"{}.{}({})\",\n-                            detection.slice_name,\n-                            detection.method.unstable_name(),\n-                            detection.method_args,\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    diag.note(\n-                        \"an unstable sort typically performs faster without any observable difference for this data type\",\n-                    );\n-                },\n-            );\n-        }\n-    }\n-}"}]}