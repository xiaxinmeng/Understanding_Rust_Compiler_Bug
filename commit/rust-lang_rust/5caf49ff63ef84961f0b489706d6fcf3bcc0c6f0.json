{"sha": "5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYWY0OWZmNjNlZjg0OTYxZjBiNDg5NzA2ZDZmY2YzYmNjMGM2ZjA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-26T02:16:37Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-26T02:20:30Z"}, "message": "Commit changes code using map of adjustments", "tree": {"sha": "7b7e17e8d6c5d3f5b7cda17215402f1fdb84f783", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b7e17e8d6c5d3f5b7cda17215402f1fdb84f783"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0", "html_url": "https://github.com/rust-lang/rust/commit/5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [], "stats": {"total": 954, "additions": 954, "deletions": 0}, "files": [{"sha": "ba2b90d185d783f7a4b83f6db7059726c695854f", "filename": "src/changes.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0", "patch": "@@ -0,0 +1,251 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// TODO\n+// composable changes\n+// print to files (maybe that shouldn't be here, but in mod)\n+// tests\n+// docs\n+\n+use rope::{Rope, RopeSlice};\n+use std::collections::{HashMap, BTreeMap};\n+use std::collections::Bound::{Included, Unbounded};\n+use syntax::codemap::{CodeMap, Span, Pos};\n+use std::fmt;\n+\n+pub struct ChangeSet<'a> {\n+    file_map: HashMap<String, Rope>,\n+    // FIXME, we only keep a codemap around so we can have convenience methods\n+    // taking Spans, it would be more resuable to factor this (and the methods)\n+    // out into an adaptor.\n+    codemap: &'a CodeMap,\n+    pub count: u64,\n+    // TODO we need to map the start and end of spans differently\n+    // TODO needs to be per file\n+    adjusts: BTreeMap<usize, Adjustment>,\n+}\n+\n+// An extent over which we must adjust the position values.\n+#[derive(Show, Clone, Eq, PartialEq)]\n+struct Adjustment {\n+    // Start is implicit, given by its position in the map.\n+    end: usize,\n+    delta: isize,\n+}\n+\n+impl Adjustment {\n+    fn chop_left(&self, new_end: usize) -> Adjustment {\n+        Adjustment {\n+            end: new_end,\n+            delta: self.delta,\n+        }\n+    }\n+\n+    fn move_left(&self, mov: usize) -> Adjustment {\n+        assert!(self.delta > mov);\n+        Adjustment {\n+            end: self.end,\n+            delta: self.delta - mov,\n+        }\n+    }\n+}\n+\n+pub struct FileIterator<'c, 'a: 'c> {\n+    change_set: &'c ChangeSet<'a>,\n+    keys: Vec<&'c String>,\n+    cur_key: usize,\n+}\n+\n+impl<'a> ChangeSet<'a> {\n+    pub fn from_codemap(codemap: &'a CodeMap) -> ChangeSet<'a> {\n+        let mut result = ChangeSet {\n+            file_map: HashMap::new(),\n+            codemap: codemap,\n+            count: 0,\n+            adjusts: BTreeMap::new(),\n+        };\n+\n+        for f in codemap.files.borrow().iter() {\n+            let contents = Rope::from_string(f.src.clone());\n+            result.file_map.insert(f.name.clone(), contents);\n+        }\n+\n+        result\n+    }\n+\n+    // start and end are unadjusted.\n+    pub fn change(&mut self, file_name: &str, start: usize, end: usize, text: String) {\n+        println!(\"change: {}:{}-{} \\\"{}\\\"\", file_name, start, end, text);\n+\n+        let new_len = text.len();\n+        self.count += 1;\n+\n+        let (key_start, adj_start, abs_start): (Option<usize>, Option<Adjustment>, usize) = {\n+            let before_start = self.adjusts.range(Unbounded, Included(&start)).next_back();\n+            match before_start {\n+                Some((k, a)) if a.end > start => (Some(*k), Some(a.clone()), (start as isize + a.delta) as usize),\n+                _ => (None, None, start)\n+            }\n+        };\n+        let (key_end, adj_end, abs_end) = {\n+            let before_end = self.adjusts.range(Unbounded, Included(&end)).next_back();\n+            match before_end {\n+                Some((k, a)) if a.end > end => (Some(*k), Some(a.clone()), (end as isize + a.delta) as usize),\n+                _ => (None, None, end)\n+            }\n+        };\n+\n+        {\n+            let file = &mut self.file_map[*file_name];\n+\n+            println!(\"change: absolute values {}-{}, replaces \\\"{}\\\"\",\n+                   abs_start, abs_end, file.slice(abs_start..abs_end));\n+\n+            file.remove(abs_start, abs_end);\n+            file.insert(abs_start, text);\n+\n+            // Record the changed locations.\n+            // TODO what if there is a change to the right of end? - need to iterate over all changes to the right :-(\n+            match (key_start, key_end) {\n+                (None, None) => {\n+                    // Factor this out?\n+                    let old_len = end as isize - start as isize;\n+                    let delta = new_len as isize - old_len;\n+                    self.adjusts.insert(end, Adjustment { end: file.len(), delta: delta });\n+                }\n+                (Some(k), None) => {\n+                    // Adjust the old change.\n+                    self.adjusts[k] = adj_start.unwrap().chop_left(end);\n+\n+                    // Add the new one.\n+                    let old_len = end as isize - start as isize;\n+                    let delta = new_len as isize - old_len;\n+                    self.adjusts.insert(end, Adjustment { end: file.len(), delta: delta });\n+                }\n+                (None, Some(k)) => {\n+                    let old_len = end as isize - start as isize;\n+                    let delta = new_len as isize - old_len;\n+\n+                    // Adjust the old change.\n+                    // TODO only if we move left, but what if moving right?\n+                    self.adjusts[abs_end] = adj_end.unwrap().move_left(TODO);\n+                    self.adjusts.remove(&k);\n+\n+                    // Add the new one.\n+                    self.adjusts.insert(end, Adjustment { end: file.len(), delta: delta });\n+                }\n+                _ => {\n+                    println!(\"{}\", file);\n+                    panic!();\n+                }\n+            }\n+        }\n+\n+        debug_assert!(self.verify_adjustments(), \"Bad change, created an overlapping adjustment\");\n+    }\n+\n+    // Intended for debugging.\n+    fn verify_adjustments(&self) -> bool {\n+        let mut prev_end = 0;\n+        let mut prev_delta = 0;\n+        for (&k, a) in self.adjusts.iter() {\n+            if k < prev_end {\n+                debug!(\"Found bad adjustment at start {}, overlaps with previous adjustment\", k);\n+                return false;\n+            }\n+            if k as isize + a.delta < 0 {\n+                debug!(\"Found bad adjustment at start {}, absolute start < 0\", k);\n+                return false;\n+            }\n+            if k as isize + a.delta < prev_end as isize + prev_delta {\n+                debug!(\"Found bad adjustment at start {}, \\\n+                        projection overlaps with previous projection\", k);\n+                return false;\n+            }\n+            // TODO Check end + delta <= file.len - needs per file\n+\n+            prev_end = a.end;\n+            prev_delta = a.delta;\n+        }\n+        true\n+    }\n+\n+    // span is unadjusted.\n+    pub fn change_span(&mut self, span: Span, text: String) {\n+        let l_loc = self.codemap.lookup_char_pos(span.lo);\n+        let file_offset = l_loc.file.start_pos.0;\n+        self.change(&l_loc.file.name[],\n+                    (span.lo.0 - file_offset) as usize,\n+                    (span.hi.0 - file_offset) as usize,\n+                    text)\n+    }\n+\n+    // start and end are unadjusted.\n+    pub fn slice(&self, file_name: &str, start: usize, end: usize) -> RopeSlice {\n+        // TODO refactor with change?\n+        let abs_start = {\n+            let before_start = self.adjusts.range(Unbounded, Included(&start)).next_back();\n+            match before_start {\n+                Some((k, ref a)) if a.end > start => (start as isize + a.delta) as usize,\n+                _ => start\n+            }\n+        };\n+        let abs_end = {\n+            let before_end = self.adjusts.range(Unbounded, Included(&end)).next_back();\n+            match before_end {\n+                Some((k, ref a)) if a.end > end => (end as isize + a.delta) as usize,\n+                _ => end\n+            }\n+        };\n+\n+        let file = &self.file_map[*file_name];\n+        file.slice(abs_start..abs_end)\n+    }\n+\n+    // span is unadjusted.\n+    pub fn slice_span(&self, span:Span) -> RopeSlice {\n+        let l_loc = self.codemap.lookup_char_pos(span.lo);\n+        let file_offset = l_loc.file.start_pos.0;\n+        self.slice(&l_loc.file.name[],\n+                   (span.lo.0 - file_offset) as usize,\n+                   (span.hi.0 - file_offset) as usize)\n+    }\n+\n+    pub fn text<'c>(&'c self) -> FileIterator<'c, 'a> {\n+        FileIterator {\n+            change_set: self,\n+            keys: self.file_map.keys().collect(),\n+            cur_key: 0,\n+        }\n+    }\n+}\n+\n+impl<'c, 'a> Iterator for FileIterator<'c, 'a> {\n+    type Item = (&'c str, &'c Rope);\n+    fn next(&mut self) -> Option<(&'c str, &'c Rope)> {\n+        if self.cur_key >= self.keys.len() {\n+            return None;\n+        }\n+\n+        let key = self.keys[self.cur_key];\n+        self.cur_key += 1;\n+        return Some((&key[], &self.change_set.file_map[*key]))\n+    }\n+}\n+\n+impl<'a> fmt::Display for ChangeSet<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        for (f, r) in self.text() {\n+            try!(write!(fmt, \"{}:\\n\", f));\n+            try!(write!(fmt, \"{}\", r));\n+        }\n+        Ok(())\n+    }    \n+}"}, {"sha": "263a7923c3b5ed28108adadcf431359fd64fd4e1", "filename": "src/rope.rs", "status": "added", "additions": 703, "deletions": 0, "changes": 703, "blob_url": "https://github.com/rust-lang/rust/blob/5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0/src%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0/src%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frope.rs?ref=5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0", "patch": "@@ -0,0 +1,703 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// TODO\n+// ----\n+// docs - mod docs, item docs\n+// tests\n+// pull out into its own crate\n+// impl Default, Extend\n+// impl DOubleEndedIter and ExactSizeIter for RopeChars\n+// better allocation\n+// balancing\n+// thread safety/parallisation\n+\n+extern crate unicode;\n+use std::fmt;\n+use std::ops::Range;\n+\n+// A Rope, based on an unbalanced binary tree.\n+\n+pub struct Rope {\n+    root: Node,\n+    len: usize,\n+    // FIXME: Allocation is very dumb at the moment, we always add another buffer for every inserted string and we never resuse or collect old memory\n+    storage: Vec<Vec<u8>>\n+}\n+\n+pub struct RopeSlice<'rope> {\n+    // All nodes which make up the slice, in order.\n+    nodes: Vec<&'rope Lnode>,\n+    // The offset of the start point in the first node.\n+    start: usize,\n+    // The length of text in the last node.\n+    len: usize,\n+}\n+\n+pub struct RopeChars<'rope> {\n+    data: RopeSlice<'rope>,\n+    cur_node: usize,\n+    cur_byte: usize,\n+    abs_byte: usize,\n+}\n+\n+\n+impl Rope {\n+    pub fn new() -> Rope {\n+        Rope {\n+            root: Node::empty_inner(),\n+            len: 0,\n+            storage: vec![],\n+        }\n+    }\n+\n+    // Uses text as initial storage.\n+    pub fn from_string(text: String) -> Rope {\n+        // TODO should split large texts into segments as we insert\n+\n+        let mut result = Rope::new();\n+        result.insert(0, text);\n+        result\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n+\n+    pub fn insert(&mut self, start: usize, text: String) {\n+        if text.len() == 0 {\n+            return;\n+        }\n+\n+        debug_assert!(start <= self.len(), \"insertion out of bounds of rope\");\n+\n+        let len = text.len();\n+        let storage = text.into_bytes();\n+        let new_node = box Node::new_leaf(&storage[][0] as *const u8, len);\n+        self.storage.push(storage);\n+\n+        match self.root.insert(new_node, start) {\n+            NodeAction::Change(n, adj) => {\n+                assert!(adj as usize == len);\n+                self.root = *n;\n+            }\n+            NodeAction::Adjust(adj) => {\n+                assert!(adj as usize == len);\n+            }\n+            _ => panic!(\"Unexpected action\")\n+        }\n+        self.len += len;\n+    }\n+\n+    pub fn insert_copy(&mut self, start: usize, text: &str) {\n+        // If we did clever things with allocation, we could do better here\n+        self.insert(start, text.to_string());\n+    }\n+\n+    pub fn push(&mut self, text: String) {\n+        let len = self.len();\n+        self.insert(len, text);\n+    }\n+\n+    pub fn push_copy(&mut self, text: &str) {\n+        // If we did clever things with allocation, we could do better here\n+        let len = self.len();\n+        self.insert(len, text.to_string());\n+    }\n+\n+    pub fn remove(&mut self, start: usize, end: usize) {\n+        assert!(end >= start);\n+        if start == end {\n+            return;\n+        }\n+\n+        let action = self.root.remove(start, end, 0);\n+        match action {\n+            NodeAction::None => {}\n+            NodeAction::Remove => {\n+                self.root = Node::empty_inner();\n+                self.len = 0;\n+            }\n+            NodeAction::Adjust(adj) => self.len = (self.len as isize + adj) as usize,\n+            NodeAction::Change(node, adj) => {\n+                self.root = *node;\n+                self.len = (self.len as isize + adj) as usize;\n+            }\n+        }\n+    }\n+\n+    // This can go horribly wrong if you overwrite a grapheme of different size.\n+    // It is the callers responsibility to ensure that the grapheme at point start\n+    // has the same size as new_char.\n+    pub fn replace(&mut self, start: usize, new_char: char) {\n+        assert!(start + new_char.len_utf8() <= self.len);\n+        // This is pretty wasteful in that we're allocating for no point, but\n+        // I think that is better than duplicating a bunch of code.\n+        // It should be possible to view a &char as a &[u8] somehow, and then\n+        // we can optimise this (FIXME).\n+        self.replace_str(start, &new_char.to_string()[]);\n+    }\n+\n+    pub fn replace_str(&mut self, start: usize, new_str: &str) {\n+        assert!(start + new_str.len() <= self.len);\n+        self.root.replace(start, new_str);\n+    }\n+\n+    pub fn slice(&self, Range { start, end }: Range<usize>) -> RopeSlice {\n+        debug_assert!(end > start && start <= self.len && end <= self.len);\n+        if start == end {\n+            return RopeSlice::empty();\n+        }\n+\n+        let mut result = RopeSlice::empty();\n+        self.root.find_slice(start, end, &mut result);\n+        result\n+    }\n+\n+    pub fn full_slice(&self) -> RopeSlice {\n+        self.slice(0..self.len)\n+    }\n+\n+    pub fn chars(&self) -> RopeChars {\n+        RopeChars {\n+            data: self.full_slice(),\n+            cur_node: 0,\n+            cur_byte: 0,\n+            abs_byte: 0,\n+        }\n+    }\n+}\n+\n+impl<'rope> RopeSlice<'rope> {\n+    fn empty<'r>() -> RopeSlice<'r> {\n+        RopeSlice {\n+            nodes: vec![],\n+            start: 0,\n+            len: 0,\n+        }\n+    }\n+}\n+\n+impl<'rope> Iterator for RopeChars<'rope> {\n+    type Item = (char, usize);\n+    fn next(&mut self) -> Option<(char, usize)> {\n+        if self.cur_node >= self.data.nodes.len() {\n+            return None;\n+        }\n+\n+        let byte = self.abs_byte;\n+        let node = self.data.nodes[self.cur_node];\n+        if self.cur_byte >= node.len {\n+            self.cur_byte = 0;\n+            self.cur_node += 1;\n+            return self.next();\n+        }\n+\n+        let result = self.read_char();\n+        return Some((result, byte));\n+    }\n+}\n+\n+impl<'rope> RopeChars<'rope> {\n+    fn read_char(&mut self) -> char {\n+        let first_byte = self.read_byte();\n+        let width = unicode::str::utf8_char_width(first_byte);\n+        if width == 1 {\n+            return first_byte as char\n+        }\n+        if width == 0 {\n+            panic!(\"non-utf8 char in rope\");\n+        }\n+        let mut buf = [first_byte, 0, 0, 0];\n+        {\n+            let mut start = 1;\n+            while start < width {\n+                buf[start] = self.read_byte();\n+                start += 1;\n+            }\n+        }\n+        match ::std::str::from_utf8(&buf[..width]).ok() {\n+            Some(s) => s.char_at(0),\n+            None => panic!(\"bad chars in rope\")\n+        }\n+    }\n+\n+    fn read_byte(&mut self) -> u8 {\n+        let node = self.data.nodes[self.cur_node];\n+        let addr = node.text as usize + self.cur_byte;\n+        self.cur_byte += 1;\n+        self.abs_byte += 1;\n+        let addr = addr as *const u8;\n+        unsafe {\n+            *addr\n+        }        \n+    }\n+}\n+\n+impl ::std::str::FromStr for Rope {\n+    fn from_str(text: &str) -> Option<Rope> {\n+        // TODO should split large texts into segments as we insert\n+\n+        let mut result = Rope::new();\n+        result.insert_copy(0, text);\n+        Some(result)\n+    }\n+}\n+\n+impl<'a> fmt::Display for RopeSlice<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        let last_idx = self.nodes.len() - 1;\n+        for (i, n) in self.nodes.iter().enumerate() {\n+            let mut ptr = n.text;\n+            let mut len = n.len;\n+            if i == 0 {\n+                ptr = (ptr as usize + self.start) as *const u8;\n+                len -= self.start;\n+            }\n+            if i == last_idx {\n+                len = self.len;\n+            }\n+            unsafe {\n+                try!(write!(fmt,\n+                            \"{}\",\n+                            ::std::str::from_utf8(::std::slice::from_raw_buf(&ptr, len)).unwrap()));\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'a> fmt::Debug for RopeSlice<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        let last_idx = self.nodes.len() - 1;\n+        for (i, n) in self.nodes.iter().enumerate() {\n+            let mut ptr = n.text;\n+            let mut len = n.len;\n+            if i == 0 {\n+                ptr = (ptr as usize + self.start) as *const u8;\n+                len -= self.start;\n+            } else {\n+                try!(write!(fmt, \"|\"));\n+            }\n+            if i == last_idx {\n+                len = self.len;\n+            }\n+            unsafe {\n+                try!(write!(fmt,\n+                            \"\\\"{}\\\"\",\n+                            ::std::str::from_utf8(::std::slice::from_raw_buf(&ptr, len)).unwrap()));\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl fmt::Display for Rope {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(fmt, \"{}\", self.root)\n+    }\n+}\n+\n+impl fmt::Debug for Rope {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(fmt, \"{:?}\", self.root)\n+    }\n+}\n+\n+impl fmt::Display for Node {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        match *self {\n+            Node::InnerNode(Inode { ref left, ref right, .. }) => {\n+                if let Some(ref left) = *left {\n+                    write!(fmt, \"{}\", left)\n+                } else {\n+                    Ok(())\n+                }.and_then(|_| if let Some(ref right) = *right {\n+                    write!(fmt, \"{}\", right)\n+                } else {\n+                    Ok(())\n+                })\n+            }\n+            Node::LeafNode(Lnode{ ref text, len }) => {\n+                unsafe {\n+                    write!(fmt,\n+                           \"{}\",\n+                           ::std::str::from_utf8(::std::slice::from_raw_buf(text, len)).unwrap())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Node {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        match *self {\n+            Node::InnerNode(Inode { ref left, ref right, weight }) => {\n+                try!(write!(fmt, \"(\"));\n+                if let Some(ref left) = *left {\n+                    try!(write!(fmt, \"left: {:?}\", &**left));\n+                } else {\n+                    try!(write!(fmt, \"left: ()\"));\n+                }\n+                try!(write!(fmt, \", \"));\n+                if let Some(ref right) = *right {\n+                    try!(write!(fmt, \"right: {:?}\", &**right));\n+                } else {\n+                    try!(write!(fmt, \"right: ()\"));\n+                }\n+                write!(fmt, \"; {})\", weight)\n+            }\n+            Node::LeafNode(Lnode{ ref text, len }) => {\n+                unsafe {\n+                    write!(fmt,\n+                           \"\\\"{}\\\"; {}\",\n+                           ::std::str::from_utf8(::std::slice::from_raw_buf(text, len)).unwrap(),\n+                           len)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Eq, PartialEq)]\n+enum Node {\n+    InnerNode(Inode),\n+    LeafNode(Lnode),\n+}\n+\n+#[derive(Clone, Eq, PartialEq)]\n+struct Inode {\n+    weight: usize,\n+    left: Option<Box<Node>>,\n+    right: Option<Box<Node>>,\n+}\n+\n+#[derive(Clone, Eq, PartialEq)]\n+struct Lnode {\n+    text: *const u8,\n+    len: usize,\n+}\n+\n+impl Node {\n+    fn empty_inner() -> Node {\n+        Node::InnerNode(Inode {\n+            left: None,\n+            right: None,\n+            weight: 0\n+        })\n+    }\n+\n+    fn new_inner(left: Option<Box<Node>>,\n+                 right: Option<Box<Node>>,\n+                 weight: usize)\n+    -> Node {\n+        Node::InnerNode(Inode {\n+            left: left,\n+            right: right,\n+            weight: weight\n+        })\n+    }\n+\n+    fn new_leaf(text: *const u8, len: usize) -> Node {\n+        Node::LeafNode(Lnode {\n+            text: text,\n+            len: len\n+        })\n+    }\n+\n+    fn len(&self) -> usize {\n+        match *self {\n+            Node::InnerNode(Inode { weight, ref right, .. }) => {\n+                match *right {\n+                    Some(ref r) => weight + r.len(),\n+                    None => weight\n+                }\n+            }\n+            Node::LeafNode(Lnode { len, .. }) => len,\n+        }\n+    }\n+\n+    // precond: start < end\n+    fn remove(&mut self, start: usize, end: usize, offset: usize) -> NodeAction {\n+        if end < offset {\n+            // The span to remove is to the left of this node.\n+            return NodeAction::None;\n+        }\n+\n+        match *self {\n+            Node::InnerNode(ref mut i) => i.remove(start, end, offset),\n+            Node::LeafNode(ref mut l) => l.remove(start, end, offset),\n+        }\n+    }\n+\n+    fn insert(&mut self, node: Box<Node>, start: usize) -> NodeAction {\n+        match *self {\n+            Node::InnerNode(ref mut i) => i.insert(node, start),\n+            Node::LeafNode(ref mut l) => l.insert(node, start),\n+        }\n+    }\n+\n+    fn find_slice<'a>(&'a self, start: usize, end: usize, slice: &mut RopeSlice<'a>) {\n+        match *self {\n+            Node::InnerNode(ref i) => i.find_slice(start, end, slice),\n+            Node::LeafNode(ref l) => l.find_slice(start, end, slice),\n+        }\n+    }\n+\n+    fn replace(&mut self, start: usize, new_str: &str) {\n+        match *self {\n+            Node::InnerNode(ref mut i) => i.replace(start, new_str),\n+            Node::LeafNode(ref mut l) => l.replace(start, new_str),\n+        }        \n+    }\n+}\n+\n+#[derive(Show, Clone, Eq, PartialEq)]\n+enum NodeAction {\n+    None,\n+    Remove,\n+    Adjust(isize), // Arg is the length of the old node - the length of the newly adjusted node.\n+    Change(Box<Node>, isize) // Args are the new node and the change in length.\n+}\n+\n+impl Inode {\n+    // precond: start < end && end >= offset\n+    fn remove(&mut self, start: usize, end: usize, offset: usize) -> NodeAction {\n+        debug!(\"Inode::remove: {}, {}, {}, {}\", start, end, offset, self.weight);\n+        if start >= offset + self.weight {\n+            // The removal cannot affect our left side.\n+            match self.right {\n+                Some(_) => {}\n+                None => {}\n+            }\n+        }\n+\n+        let left_action = if let Some(ref mut left) = self.left {\n+            left.remove(start, end, offset)\n+        } else {\n+            NodeAction::None\n+        };\n+        let right_action = if let Some(ref mut right) = self.right {\n+            right.remove(start, end, offset + self.weight)\n+        } else {\n+            NodeAction::None\n+        };\n+\n+        if left_action == NodeAction::Remove && right_action == NodeAction::Remove ||\n+           left_action == NodeAction::Remove && self.right.is_none() ||\n+           right_action == NodeAction::Remove && self.left.is_none() {\n+            return NodeAction::Remove;\n+        }\n+\n+        if left_action == NodeAction::Remove {\n+            return NodeAction::Change(self.right.clone().unwrap(),\n+                                      -(self.weight as isize));\n+        }\n+        if right_action == NodeAction::Remove {\n+            return NodeAction::Change(self.left.clone().unwrap(),\n+                                      -(self.right.as_ref().map(|n| n.len()).unwrap() as isize));\n+        }\n+\n+        let mut total_adj = 0;\n+        if let NodeAction::Change(ref n, adj) = left_action {\n+            self.left = Some(n.clone());\n+            self.weight = (self.weight as isize + adj) as usize;\n+            total_adj += adj;\n+        }\n+        if let NodeAction::Change(ref n, adj) = right_action {\n+            self.right = Some(n.clone());\n+            total_adj += adj;\n+        }\n+\n+        if let NodeAction::Adjust(adj) = left_action {\n+            self.weight = (self.weight as isize + adj) as usize;\n+            total_adj += adj;\n+        }\n+        if let NodeAction::Adjust(adj) = right_action {\n+            total_adj += adj;\n+        }\n+\n+        return NodeAction::Adjust(total_adj);\n+    }\n+\n+    fn insert(&mut self, node: Box<Node>, start: usize) -> NodeAction {\n+        let mut total_adj = 0;\n+        if start < self.weight {\n+            let action = if let Some(ref mut left) = self.left {\n+                left.insert(node, start)\n+            } else {\n+                assert!(self.weight == 0);\n+                let len = node.len() as isize;\n+                NodeAction::Change(node, len)\n+            };\n+\n+            match action {\n+                NodeAction::Change(n, adj) => {\n+                    self.left = Some(n);\n+                    self.weight += adj as usize;\n+                    total_adj += adj;\n+                }\n+                NodeAction::Adjust(adj) => {\n+                    self.weight += adj as usize;\n+                    total_adj += adj;\n+                }\n+                _ => panic!(\"Unexpected action\"),\n+            }\n+        } else {\n+            let action = if let Some(ref mut right) = self.right {\n+                assert!(start >= self.weight);\n+                right.insert(node, start - self.weight)\n+            } else {\n+                let len = node.len() as isize;\n+                NodeAction::Change(node, len)\n+            };\n+\n+            match action {\n+                NodeAction::Change(n, adj) => {\n+                    self.right = Some(n);\n+                    total_adj += adj;\n+                }\n+                NodeAction::Adjust(adj) => total_adj += adj,\n+                _ => panic!(\"Unexpected action\"),\n+            }\n+        }\n+\n+        NodeAction::Adjust(total_adj)\n+    }\n+\n+    fn find_slice<'a>(&'a self, start: usize, end: usize, slice: &mut RopeSlice<'a>) {\n+        debug!(\"Inode::find_slice: {}, {}, {}\", start, end, self.weight);\n+        if start < self.weight {\n+            self.left.as_ref().unwrap().find_slice(start, end, slice);\n+        }\n+        if end > self.weight {\n+            let start = if start < self.weight {\n+                0\n+            } else {\n+                start - self.weight\n+            };\n+            self.right.as_ref().unwrap().find_slice(start, end - self.weight, slice)\n+        }\n+    }\n+\n+    fn replace(&mut self, start: usize, new_str: &str) {\n+        debug!(\"Inode::replace: {}, {}, {}\", start, new_str, self.weight);\n+        let end = start + new_str.len();\n+        if start < self.weight {\n+            if let Some(ref mut left) = self.left {\n+                left.replace(start, &new_str[..::std::cmp::min(self.weight-start, new_str.len())]);\n+            } else {\n+                panic!();\n+            }\n+        }\n+        if end > self.weight {\n+            let (start, offset) = if start < self.weight {\n+                (0, self.weight - start)\n+            } else {\n+                (start - self.weight, 0)\n+            };\n+            if let Some(ref mut right) = self.right {\n+                right.replace(start, &new_str[offset..]);\n+            } else {\n+                panic!();\n+            }\n+        }\n+    }\n+}\n+\n+impl Lnode {\n+    // precond: start < end && end >= offset\n+    fn remove(&mut self, start: usize, end: usize, offset: usize) -> NodeAction {\n+        debug!(\"Lnode::remove: {}, {}, {}, {}\", start, end, offset, self.len);\n+        if start > offset + self.len {\n+            // The span to remove is to the right of this node.\n+            return NodeAction::None;\n+        }\n+\n+        if start <= offset && end >= offset + self.len {\n+            // The removal span includes us, remove ourselves.\n+            return NodeAction::Remove;\n+        }\n+\n+        let old_len = self.len;\n+        if start <= offset {\n+            // Truncate the left of the node.\n+            self.text = (self.text as usize + (end - offset)) as *const u8;\n+            self.len = old_len - (end - offset);\n+            return NodeAction::Adjust(self.len as isize - old_len as isize);\n+        }\n+\n+        if end >= offset + self.len {\n+            // Truncate the right of the node.\n+            self.len = start - offset;\n+            return NodeAction::Adjust(self.len as isize - old_len as isize);\n+        }\n+\n+        // Split the node (span to remove is in the middle of the node).\n+        let new_node = Node::new_inner(\n+            Some(box Node::new_leaf(self.text, start - offset)),\n+            Some(box Node::new_leaf((self.text as usize + (end - offset)) as *const u8,\n+                                    old_len - (end - offset))),\n+            start - offset);\n+        return NodeAction::Change(box new_node, -((end - start) as isize));\n+    }\n+\n+    fn insert(&mut self, node: Box<Node>, start: usize) -> NodeAction {\n+        let len = node.len();\n+        if start == 0 {\n+            // Insert at the start of the node\n+            let new_node = box Node::new_inner(Some(node),\n+                                               Some(box Node::LeafNode(self.clone())),\n+                                               len);\n+            return NodeAction::Change(new_node, len as isize)\n+        }\n+\n+        if start == self.len {\n+            // Insert at the end of the node\n+            let new_node = box Node::new_inner(Some(box Node::LeafNode(self.clone())),\n+                                               Some(node),\n+                                               self.len);\n+            return NodeAction::Change(new_node, len as isize)\n+        }\n+\n+        // Insert into the middle of the node\n+        let left = Some(box Node::new_leaf(self.text, start));\n+        let new_left = box Node::new_inner(left, Some(node), start);\n+        let right = Some(box Node::new_leaf((self.text as usize + (start)) as *const u8,\n+                                            self.len - (start)));\n+        let new_node = box Node::new_inner(Some(new_left), right, start + len);\n+\n+        return NodeAction::Change(new_node, len as isize)        \n+    }\n+\n+    fn find_slice<'a>(&'a self, start: usize, end: usize, slice: &mut RopeSlice<'a>) {\n+        debug!(\"Lnode::find_slice: {}, {}, {}\", start, end, self.len);\n+        debug_assert!(start < self.len, \"Shouldn't have called this fn, we're out of bounds\");\n+\n+        slice.nodes.push(self);\n+        let mut len = end;\n+        if start > 0 {\n+            slice.start = start;\n+            len -= start;\n+        }\n+        if end <= self.len {\n+            slice.len = len;\n+        }\n+    }\n+\n+    fn replace(&mut self, start: usize, new_str: &str) {\n+        debug!(\"Lnode::replace: {}, {}, {}\", start, new_str, self.len);\n+        debug_assert!(start + new_str.len() <= self.len);\n+        let addr = (self.text as usize + start) as *mut u8;\n+        unsafe {\n+            ::std::intrinsics::copy_nonoverlapping_memory(addr, &new_str.as_bytes()[0], new_str.len());\n+        }\n+    }\n+}"}]}