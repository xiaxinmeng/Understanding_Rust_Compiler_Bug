{"sha": "0cabd6fa1a87f5a6c522cddcbaeb2a189000dfe7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYWJkNmZhMWE4N2Y1YTZjNTIyY2RkY2JhZWIyYTE4OTAwMGRmZTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-23T01:59:34Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-23T04:23:00Z"}, "message": "tutorial: More intro simplification", "tree": {"sha": "230b005a125e9bf0da2ed2388522019829c33a9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/230b005a125e9bf0da2ed2388522019829c33a9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cabd6fa1a87f5a6c522cddcbaeb2a189000dfe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cabd6fa1a87f5a6c522cddcbaeb2a189000dfe7", "html_url": "https://github.com/rust-lang/rust/commit/0cabd6fa1a87f5a6c522cddcbaeb2a189000dfe7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cabd6fa1a87f5a6c522cddcbaeb2a189000dfe7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2bc5122cd2122edcc0a4fd23288b19378ad2d3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2bc5122cd2122edcc0a4fd23288b19378ad2d3a", "html_url": "https://github.com/rust-lang/rust/commit/c2bc5122cd2122edcc0a4fd23288b19378ad2d3a"}], "stats": {"total": 287, "additions": 166, "deletions": 121}, "files": [{"sha": "a9a5ab2dcf9ba4af0e5f26aa03ed294cf845370d", "filename": "doc/tutorial.md", "status": "modified", "additions": 166, "deletions": 121, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/0cabd6fa1a87f5a6c522cddcbaeb2a189000dfe7/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/0cabd6fa1a87f5a6c522cddcbaeb2a189000dfe7/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=0cabd6fa1a87f5a6c522cddcbaeb2a189000dfe7", "patch": "@@ -61,41 +61,41 @@ they don't contain references to things that aren't actually defined.\n \n # Getting started\n \n-## Installation\n+The Rust compiler currently must be built from a [tarball], unless you\n+are on Windows, in which case using the [installer][win-exe] is\n+recommended.\n \n-The Rust compiler currently must be built from a [tarball][]. We hope\n-to be distributing binary packages for various operating systems in\n-the future.\n+Since the Rust compiler is written in Rust, it must be built by\n+a precompiled \"snapshot\" version of itself (made in an earlier state\n+of development). As such, source builds require a connection to\n+the Internet, to fetch snapshots, and an OS that can execute the\n+available snapshot binaries.\n \n-The Rust compiler is slightly unusual in that it is written in Rust\n-and therefore must be built by a precompiled \"snapshot\" version of\n-itself (made in an earlier state of development). As such, source\n-builds require that:\n+Snapshot binaries are currently built and tested on several platforms:\n \n-  * You are connected to the internet, to fetch snapshots.\n-  * You can at least execute snapshot binaries of one of the forms we\n-    offer them in. Currently we build and test snapshots on:\n-    * Windows (7, server 2008 r2) x86 only\n-    * Linux (various distributions) x86 and x86-64\n-    * OSX 10.6 (\"Snow Leopard\") or 10.7 (\"Lion\") x86 and x86-64\n+* Windows (7, Server 2008 R2), x86 only\n+* Linux (various distributions), x86 and x86-64\n+* OSX 10.6 (\"Snow Leopard\") or 10.7 (\"Lion\"), x86 and x86-64\n \n-You may find other platforms work, but these are our \"tier 1\" supported\n-build environments that are most likely to work. Further platforms will\n-be added to the list in the future via cross-compilation.\n+You may find that other platforms work, but these are our \"tier 1\"\n+supported build environments that are most likely to work.\n+\n+> ***Note:*** Windows users should read the detailed\n+> [getting started][wiki-start] notes on the wiki. Even when using\n+> the binary installer the windows build requires a MinGW installation,\n+> the precise details of which are not discussed in this tutorial.\n \n To build from source you will also need the following prerequisite\n packages:\n \n-  * g++ 4.4 or clang++ 3.x\n-  * python 2.6 or later\n-  * perl 5.0 or later\n-  * gnu make 3.81 or later\n-  * curl\n+* g++ 4.4 or clang++ 3.x\n+* python 2.6 or later (but not 3.x)\n+* perl 5.0 or later\n+* gnu make 3.81 or later\n+* curl\n \n Assuming you're on a relatively modern *nix system and have met the\n-prerequisites, something along these lines should work. Building from\n-source on Windows requires some extra steps: please see the [getting\n-started][wiki-get-started] page on the Rust wiki.\n+prerequisites, something along these lines should work.\n \n ~~~~ {.notrust}\n $ wget http://dl.rust-lang.org/dist/rust-0.4.tar.gz\n@@ -118,8 +118,9 @@ When complete, `make install` will place the following programs into\n   * `rustdoc`, the API-documentation tool\n   * `cargo`, the Rust package manager\n \n-[wiki-get-started]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n+[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n [tarball]: http://dl.rust-lang.org/dist/rust-0.4.tar.gz\n+[win-exe]: http://dl.rust-lang.org/dist/rust-0.4-install.exe\n \n ## Compiling your first program\n \n@@ -128,91 +129,137 @@ we have a file `hello.rs` containing this program:\n \n ~~~~\n fn main() {\n-    io::println(\"hello world!\");\n+    io::println(\"hello? yes, this is rust\");\n }\n ~~~~\n \n If the Rust compiler was installed successfully, running `rustc\n-hello.rs` will produce a binary called `hello` (or `hello.exe`).\n+hello.rs` will produce an executable called `hello` (or `hello.exe` on\n+Windows) which, upon running, will likely do exactly what you expect\n+(unless you are on Windows, in which case what it does is subject\n+to local weather conditions).\n+\n+> ***Note:*** That may or may not be hyperbole, but there are some\n+> 'gotchas' to be aware of on Windows. First, the MinGW environment\n+> must be set up perfectly. Please read [the\n+> wiki][wiki-started]. Second, `rustc` may need to be [referred to as\n+> `rustc.exe`][bug-3319]. It's a bummer, I know, and I am so very\n+> sorry.\n \n-If you modify the program to make it invalid (for example, by changing\n- `io::println` to some nonexistent function), and then compile it,\n- you'll see an error message like this:\n+[bug-3319]: https://github.com/mozilla/rust/issues/3319\n+[wiki-started]:\thttps://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n+\n+The Rust compiler tries to provide useful information when it runs\n+into an error. If you modify the program to make it invalid (for\n+example, by changing `io::println` to some nonexistent function), and\n+then compile it, you'll see an error message like this:\n \n ~~~~ {.notrust}\n hello.rs:2:4: 2:16 error: unresolved name: io::print_it\n-hello.rs:2     io::print_it(\"hello world!\");\n+hello.rs:2     io::print_it(\"hello? yes, this is rust\");\n                ^~~~~~~~~~~~\n ~~~~\n \n-The Rust compiler tries to provide useful information when it runs\n-into an error.\n-\n-## Anatomy of a Rust program\n-\n-In its simplest form, a Rust program is a `.rs` file with some\n-types and functions defined in it. If it has a `main` function, it can\n-be compiled to an executable. Rust does not allow code that's not a\n+In its simplest form, a Rust program is a `.rs` file with some types\n+and functions defined in it. If it has a `main` function, it can be\n+compiled to an executable. Rust does not allow code that's not a\n declaration to appear at the top level of the file\u2014all statements must\n-live inside a function.\n-\n-Rust programs can also be compiled as libraries, and included in other\n-programs. The `extern mod std` directive that appears at the top of a lot of\n-examples imports the [standard library][std]. This is described in more\n-detail [later on](#modules-and-crates).\n+live inside a function.  Rust programs can also be compiled as\n+libraries, and included in other programs. The `extern mod std`\n+directive that appears at the top of many examples imports the\n+[standard library][std], described in more detail [later\n+on](#modules-and-crates).\n \n [std]: http://doc.rust-lang.org/doc/std\n \n ## Editing Rust code\n \n-There are Vim highlighting and indentation scripts in the Rust source\n-distribution under `src/etc/vim/`, and an emacs mode under\n-`src/etc/emacs/`. There is a package for Sublime Text 2 at\n-[github.com/dbp/sublime-rust](http://github.com/dbp/sublime-rust), also\n-available through [package control](http://wbond.net/sublime_packages/package_control).\n+There are vim highlighting and indentation scripts in the Rust source\n+distribution under `src/etc/vim/`. There is an emacs mode under\n+`src/etc/emacs/` called `rust-mode`, but do read the instructions\n+included in that directory. In particular, if you are running emacs\n+24, then using emacs's internal package manager to install `rust-mode`\n+is the easiest way to keep it up to date. There is also a package for\n+Sublime Text 2, available both [standalone][sublime] and through\n+[Sublime Package Control][sublime-pkg].\n \n Other editors are not provided for yet. If you end up writing a Rust\n mode for your favorite editor, let us know so that we can link to it.\n \n-# Syntax Basics\n+[sublime]: http://github.com/dbp/sublime-rust\n+[sublime-pkg]: http://wbond.net/sublime_packages/package_control\n \n-## Braces\n+# Syntax Basics\n \n Assuming you've programmed in any C-family language (C++, Java,\n-JavaScript, C#, or PHP), Rust will feel familiar. The main surface\n-difference to be aware of is that the bodies of `if` statements and of\n-`while` loops *have* to be wrapped in brackets. Single-statement,\n-bracket-less bodies are not allowed.\n+JavaScript, C#, or PHP), Rust will feel familiar. Code is arranged\n+in blocks delineated by curly braces; there are control structures\n+for branching and looping, like the familiar `if` and `when`; function\n+calls are written `myfunc(arg1, arg2)`; operators are written the same\n+and mostly have the same precedence as in C; comments are again like C.\n \n-Accounting for these differences, the surface syntax of Rust\n-statements and expressions is C-like. Function calls are written\n-`myfunc(arg1, arg2)`, operators have mostly the same name and\n-precedence that they have in C, comments look the same, and constructs\n-like `if` and `while` are available:\n+The main surface difference to be aware of is that the condition at\n+the head of control structures like `if` and `while` do not require\n+paretheses, while their bodies *must* be wrapped in\n+brackets. Single-statement, bracket-less bodies are not allowed.\n \n ~~~~\n-# fn it_works() {}\n-# fn abort() {}\n+# fn calibrate_universe() -> bool { true }\n+# fn party_on() {}\n+# fn panic() {}\n fn main() {\n-    while true {\n-        /* Ensure that basic math works. */\n+    while calibrate_universe() {\n+        /* Ensure that basic math still operates is expected */\n         if 2*20 > 30 {\n-            // Everything is OK.\n-            it_works();\n+            party_on(); // That's a relief\n         } else {\n-            abort();\n+            panic();\n         }\n-        break;\n     }\n }\n ~~~~\n \n+The `let` keyword, introduces a local variable. By default, variables\n+are immutable. `let mut` can be used to introduce a local variable\n+that can be reassigned.\n+\n+~~~~\n+let hi = \"hi\";\n+let mut count = 0;\n+\n+while count < 10 {\n+    io::println(hi);\n+    count += 1;\n+}\n+~~~~\n+\n+Although Rust can almost always infer the types of local variables, it\n+can help readability to specify a variable's type by following it with\n+a colon, then the type name. Local variables may shadow earlier\n+declarations, making the earlier variables inaccessible.\n+\n+~~~~\n+let my_favorite_value: float = 57.8;\n+let my_favorite_value: int = my_favorite_value as int;\n+~~~~\n+\n+Rust identifiers follow the same rules as C; they start with an alphabetic\n+character or an underscore, and after that may contain any sequence of\n+alphabetic characters, numbers, or underscores. The preferred style is to\n+begin function, variable, and module names with a lowercase letter, using\n+underscores where they help readability, while writing types in camel case.\n+\n+~~~\n+let my_variable = 100;\n+type MyType = int; // built-in types though are _not_ camel case\n+~~~\n+\n ## Expression syntax\n \n Though it isn't apparent in all code, there is a fundamental\n difference between Rust's syntax and its predecessors in this family\n of languages. Many constructs that are statements in C are expressions\n-in Rust. This allows Rust to be more expressive. For example, you might\n+in Rust, allowing code to be more concise. For example, you might\n write a piece of code like this:\n \n ~~~~\n@@ -231,81 +278,79 @@ But, in Rust, you don't have to repeat the name `price`:\n \n ~~~~\n # let item = \"salad\";\n-let price = if item == \"salad\" { 3.50 }\n-            else if item == \"muffin\" { 2.25 }\n-            else { 2.00 };\n+let price = if item == \"salad\" {\n+    3.50\n+} else if item == \"muffin\" {\n+    2.25\n+} else {\n+    2.00\n+};\n ~~~~\n \n-Both pieces of code are exactly equivalent\u2014they assign a value to `price`\n-depending on the condition that holds. Note that the semicolons are omitted\n-from the second snippet. This is important; the lack of a semicolon after the\n-last statement in a braced block gives the whole block the value of that last\n-expression.\n+Both pieces of code are exactly equivalent\u2014they assign a value to\n+`price` depending on the condition that holds. Note that the\n+semicolons are omitted from the blocks in the second snippet. This is\n+important; the lack of a semicolon after the last statement in a\n+braced block gives the whole block the value of that last expression.\n \n Put another way, the semicolon in Rust *ignores the value of an expression*.\n Thus, if the branches of the `if` had looked like `{ 4; }`, the above example\n would simply assign nil (void) to `price`. But without the semicolon, each\n branch has a different value, and `price` gets the value of the branch that\n was taken.\n \n-This feature also works for function bodies. This function returns a boolean:\n+In short, everything that's not a declaration (`let` for variables,\n+`fn` for functions, et cetera) is an expression, including function bodies.\n \n ~~~~\n-fn is_four(x: int) -> bool { x == 4 }\n+fn is_four(x: int) -> bool {\n+   // No need for a return statement. The result of the expression\n+   // is used as the return value.\n+   x == 4\n+}\n ~~~~\n \n-In short, everything that's not a declaration (`let` for variables,\n-`fn` for functions, et cetera) is an expression.\n-\n If all those things are expressions, you might conclude that you have\n to add a terminating semicolon after *every* statement, even ones that\n are not traditionally terminated with a semicolon in C (like `while`).\n That is not the case, though. Expressions that end in a block only\n need a semicolon if that block contains a trailing expression. `while`\n loops do not allow trailing expressions, and `if` statements tend to\n only have a trailing expression when you want to use their value for\n-something\u2014in which case you'll have embedded it in a bigger statement,\n-like the `let x = ...` example above.\n-\n-## Identifiers\n-\n-Rust identifiers follow the same rules as C; they start with an alphabetic\n-character or an underscore, and after that may contain any sequence of\n-alphabetic characters, numbers, or underscores. The preferred style is to\n-begin function, variable, and module names with a lowercase letter, using\n-underscores where they help readability, while beginning types with a capital\n-letter.\n+something\u2014in which case you'll have embedded it in a bigger statement.\n \n-The double-colon (`::`) is used as a module separator, so\n-`io::println` means 'the thing named `println` in the module\n-named `io`.\n-\n-## Variable declaration\n+~~~\n+# fn foo() -> bool { true }\n+# fn bar() -> bool { true }\n+# fn baz() -> bool { true }\n \n-The `let` keyword, as we've seen, introduces a local variable. Local\n-variables are immutable by default: `let mut` can be used to introduce\n-a local variable that can be reassigned.  Global constants can be\n-defined with `const`:\n+// `let` is not an expression, so it is semi-colon terminated;\n+let x = foo();\n \n-~~~~\n-const REPEAT: int = 5;\n-fn main() {\n-    let hi = \"Hi!\";\n-    let mut count = 0;\n-    while count < REPEAT {\n-        io::println(hi);\n-        count += 1;\n-    }\n-}\n-~~~~\n+// When used in statement position, bracy expressions do not\n+// usually need to be semicolon terminated\n+if x {\n+    bar();\n+} else {\n+    baz();\n+} // No semi-colon\n+\n+// Although, if `bar` and `baz` have non-nil return types, and\n+// we try to use them as the tail expressions, rustc will\n+// make us terminate the expression.\n+if x {\n+    bar()\n+} else {\n+    baz()\n+}; // Semi-colon to ignore non-nil block type\n \n-Local variables may shadow earlier declarations, making the earlier variables\n-inaccessible.\n+// An `if` embedded in `let` again requires a semicolon to terminate\n+// the `let` statement\n+let y = if x { foo() } else { bar() };\n+~~~\n \n-~~~~\n-let my_favorite_value: float = 57.8;\n-let my_favorite_value: int = my_favorite_value as int;\n-~~~~\n+This may sound a bit intricate, but it is super-useful, and it will\n+grow on you (hopefully).\n \n ## Types\n "}]}