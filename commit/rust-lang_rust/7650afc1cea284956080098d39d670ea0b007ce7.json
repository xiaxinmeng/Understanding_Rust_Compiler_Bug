{"sha": "7650afc1cea284956080098d39d670ea0b007ce7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NTBhZmMxY2VhMjg0OTU2MDgwMDk4ZDM5ZDY3MGVhMGIwMDdjZTc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-10T10:00:21Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-28T21:47:55Z"}, "message": "Make transmuting from fn item types to pointer-sized types a hard error.", "tree": {"sha": "d8611263ba31a649a64a1bab7c960f3e152ce6d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8611263ba31a649a64a1bab7c960f3e152ce6d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7650afc1cea284956080098d39d670ea0b007ce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7650afc1cea284956080098d39d670ea0b007ce7", "html_url": "https://github.com/rust-lang/rust/commit/7650afc1cea284956080098d39d670ea0b007ce7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7650afc1cea284956080098d39d670ea0b007ce7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1cb9ba221e5cb0070ac82c6a234af11e4240680", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1cb9ba221e5cb0070ac82c6a234af11e4240680", "html_url": "https://github.com/rust-lang/rust/commit/e1cb9ba221e5cb0070ac82c6a234af11e4240680"}], "stats": {"total": 269, "additions": 153, "deletions": 116}, "files": [{"sha": "85b4ddcdd719099a90bd1cd25abc93827b32b7a2", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7650afc1cea284956080098d39d670ea0b007ce7/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7650afc1cea284956080098d39d670ea0b007ce7/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=7650afc1cea284956080098d39d670ea0b007ce7", "patch": "@@ -1725,6 +1725,68 @@ If you want to get command-line arguments, use `std::env::args`. To exit with a\n specified exit code, use `std::process::exit`.\n \"##,\n \n+E0591: r##\"\n+Per [RFC 401][rfc401], if you have a function declaration `foo`:\n+\n+```rust,ignore\n+// For the purposes of this explanation, all of these\n+// different kinds of `fn` declarations are equivalent:\n+fn foo(x: i32) { ... }\n+extern \"C\" fn foo(x: i32);\n+impl i32 { fn foo(x: self) { ... } }\n+```\n+\n+the type of `foo` is **not** `fn(i32)`, as one might expect.\n+Rather, it is a unique, zero-sized marker type written here as `typeof(foo)`.\n+However, `typeof(foo)` can be _coerced_ to a function pointer `fn(i32)`,\n+so you rarely notice this:\n+\n+```rust,ignore\n+let x: fn(i32) = foo; // OK, coerces\n+```\n+\n+The reason that this matter is that the type `fn(i32)` is not specific to\n+any particular function: it's a function _pointer_. So calling `x()` results\n+in a virtual call, whereas `foo()` is statically dispatched, because the type\n+of `foo` tells us precisely what function is being called.\n+\n+As noted above, coercions mean that most code doesn't have to be\n+concerned with this distinction. However, you can tell the difference\n+when using **transmute** to convert a fn item into a fn pointer.\n+\n+This is sometimes done as part of an FFI:\n+\n+```rust,ignore\n+extern \"C\" fn foo(userdata: Box<i32>) {\n+   ...\n+}\n+\n+let f: extern \"C\" fn(*mut i32) = transmute(foo);\n+callback(f);\n+\n+```\n+\n+Here, transmute is being used to convert the types of the fn arguments.\n+This pattern is incorrect because, because the type of `foo` is a function\n+**item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n+is a function pointer, which is not zero-sized.\n+This pattern should be rewritten. There are a few possible ways to do this:\n+- change the original fn declaration to match the expected signature,\n+  and do the cast in the fn body (the prefered option)\n+- cast the fn item fo a fn pointer before calling transmute, as shown here:\n+  - `let f: extern \"C\" fn(*mut i32) = transmute(foo as extern \"C\" fn(_))`\n+  - `let f: extern \"C\" fn(*mut i32) = transmute(foo as usize) /* works too */`\n+\n+The same applies to transmutes to `*mut fn()`, which were observedin practice.\n+Note though that use of this type is generally incorrect.\n+The intention is typically to describe a function pointer, but just `fn()`\n+alone suffices for that. `*mut fn()` is a pointer to a fn pointer.\n+(Since these values are typically just passed to C code, however, this rarely\n+makes a difference in practice.)\n+\n+[rfc401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+\"##,\n+\n }\n \n "}, {"sha": "6c2730f2d1a5fa5408740528cb87945577d8b525", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7650afc1cea284956080098d39d670ea0b007ce7/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7650afc1cea284956080098d39d670ea0b007ce7/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=7650afc1cea284956080098d39d670ea0b007ce7", "patch": "@@ -155,12 +155,6 @@ declare_lint! {\n     \"uses of #[derive] with raw pointers are rarely correct\"\n }\n \n-declare_lint! {\n-    pub TRANSMUTE_FROM_FN_ITEM_TYPES,\n-    Deny,\n-    \"transmute from function item type to pointer-sized type erroneously allowed\"\n-}\n-\n declare_lint! {\n     pub HR_LIFETIME_IN_ASSOC_TYPE,\n     Deny,\n@@ -273,7 +267,6 @@ impl LintPass for HardwiredLints {\n             ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n             CONST_ERR,\n             RAW_POINTER_DERIVE,\n-            TRANSMUTE_FROM_FN_ITEM_TYPES,\n             OVERLAPPING_INHERENT_IMPLS,\n             RENAMED_AND_REMOVED_LINTS,\n             SUPER_OR_SELF_IN_GLOBAL_PATH,"}, {"sha": "c9722adc9510cc6f7eaa8f6a37e9295c4d983931", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7650afc1cea284956080098d39d670ea0b007ce7/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7650afc1cea284956080098d39d670ea0b007ce7/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=7650afc1cea284956080098d39d670ea0b007ce7", "patch": "@@ -17,7 +17,6 @@ use ty::{self, Ty, TyCtxt};\n use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n \n use syntax::abi::Abi::RustIntrinsic;\n-use syntax::ast;\n use syntax_pos::Span;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir;\n@@ -37,6 +36,35 @@ struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>\n }\n \n+/// If the type is `Option<T>`, it will return `T`, otherwise\n+/// the type itself. Works on most `Option`-like types.\n+fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                ty: Ty<'tcx>)\n+                                -> Ty<'tcx> {\n+    let (def, substs) = match ty.sty {\n+        ty::TyAdt(def, substs) => (def, substs),\n+        _ => return ty\n+    };\n+\n+    if def.variants.len() == 2 && !def.repr.c && def.repr.int.is_none() {\n+        let data_idx;\n+\n+        if def.variants[0].fields.is_empty() {\n+            data_idx = 1;\n+        } else if def.variants[1].fields.is_empty() {\n+            data_idx = 0;\n+        } else {\n+            return ty;\n+        }\n+\n+        if def.variants[data_idx].fields.len() == 1 {\n+            return def.variants[data_idx].fields[0].ty(tcx, substs);\n+        }\n+    }\n+\n+    ty\n+}\n+\n impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match self.infcx.tcx.item_type(def_id).sty {\n@@ -46,7 +74,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n         intrinsic && self.infcx.tcx.item_name(def_id) == \"transmute\"\n     }\n \n-    fn check_transmute(&self, span: Span, from: Ty<'gcx>, to: Ty<'gcx>, id: ast::NodeId) {\n+    fn check_transmute(&self, span: Span, from: Ty<'gcx>, to: Ty<'gcx>) {\n         let sk_from = SizeSkeleton::compute(from, self.infcx);\n         let sk_to = SizeSkeleton::compute(to, self.infcx);\n \n@@ -56,15 +84,17 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n                 return;\n             }\n \n+            // Special-case transmutting from `typeof(function)` and\n+            // `Option<typeof(function)>` to present a clearer error.\n+            let from = unpack_option_like(self.infcx.tcx.global_tcx(), from);\n             match (&from.sty, sk_to) {\n                 (&ty::TyFnDef(..), SizeSkeleton::Known(size_to))\n                         if size_to == Pointer.size(&self.infcx.tcx.data_layout) => {\n-                    // FIXME #19925 Remove this warning after a release cycle.\n-                    let msg = format!(\"`{}` is now zero-sized and has to be cast \\\n-                                       to a pointer before transmuting to `{}`\",\n-                                      from, to);\n-                    self.infcx.tcx.sess.add_lint(\n-                        ::lint::builtin::TRANSMUTE_FROM_FN_ITEM_TYPES, id, span, msg);\n+                    struct_span_err!(self.infcx.tcx.sess, span, E0591,\n+                                     \"`{}` is zero-sized and can't be transmuted to `{}`\",\n+                                     from, to)\n+                        .span_note(span, &format!(\"cast with `as` to a pointer instead\"))\n+                        .emit();\n                     return;\n                 }\n                 _ => {}\n@@ -140,7 +170,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for ExprVisitor<'a, 'gcx, 'tcx> {\n                     ty::TyFnDef(.., sig) if sig.abi() == RustIntrinsic => {\n                         let from = sig.inputs().skip_binder()[0];\n                         let to = *sig.output().skip_binder();\n-                        self.check_transmute(expr.span, from, to, expr.id);\n+                        self.check_transmute(expr.span, from, to);\n                     }\n                     _ => {\n                         span_bug!(expr.span, \"transmute wasn't a bare fn?!\");"}, {"sha": "091bc9cfdfaecc88bd6abe4b16eafd11513e4e70", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7650afc1cea284956080098d39d670ea0b007ce7/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7650afc1cea284956080098d39d670ea0b007ce7/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=7650afc1cea284956080098d39d670ea0b007ce7", "patch": "@@ -195,10 +195,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(SUPER_OR_SELF_IN_GLOBAL_PATH),\n             reference: \"issue #36888 <https://github.com/rust-lang/rust/issues/36888>\",\n         },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(TRANSMUTE_FROM_FN_ITEM_TYPES),\n-            reference: \"issue #19925 <https://github.com/rust-lang/rust/issues/19925>\",\n-        },\n         FutureIncompatibleInfo {\n             id: LintId::of(OVERLAPPING_INHERENT_IMPLS),\n             reference: \"issue #36889 <https://github.com/rust-lang/rust/issues/36889>\",\n@@ -260,4 +256,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     store.register_removed(\"raw_pointer_deriving\",\n                            \"using derive with raw pointers is ok\");\n     store.register_removed(\"drop_with_repr_extern\", \"drop flags have been removed\");\n+    store.register_removed(\"transmute_from_fn_item_types\",\n+        \"always cast functions before transmuting them\");\n }"}, {"sha": "34d8c6500b9263d325bb3251cff8202a9904caf4", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7650afc1cea284956080098d39d670ea0b007ce7/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7650afc1cea284956080098d39d670ea0b007ce7/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=7650afc1cea284956080098d39d670ea0b007ce7", "patch": "@@ -21,7 +21,7 @@ use builder::Builder;\n use common::{self, Funclet};\n use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n-use machine::{llalign_of_min, llbitsize_of_real};\n+use machine::llalign_of_min;\n use meth;\n use type_of::{self, align_of};\n use glue;\n@@ -869,24 +869,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     fn trans_transmute_into(&mut self, bcx: &Builder<'a, 'tcx>,\n                             src: &mir::Operand<'tcx>,\n                             dst: &LvalueRef<'tcx>) {\n-        let mut val = self.trans_operand(bcx, src);\n-        if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n-            let llouttype = type_of::type_of(bcx.ccx, dst.ty.to_ty(bcx.tcx()));\n-            let out_type_size = llbitsize_of_real(bcx.ccx, llouttype);\n-            if out_type_size != 0 {\n-                // FIXME #19925 Remove this hack after a release cycle.\n-                let f = Callee::def(bcx.ccx, def_id, substs);\n-                let ty = match f.ty.sty {\n-                    ty::TyFnDef(.., f) => bcx.tcx().mk_fn_ptr(f),\n-                    _ => f.ty\n-                };\n-                val = OperandRef {\n-                    val: Immediate(f.reify(bcx.ccx)),\n-                    ty: ty\n-                };\n-            }\n-        }\n-\n+        let val = self.trans_operand(bcx, src);\n         let llty = type_of::type_of(bcx.ccx, val.ty);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         let in_type = val.ty;"}, {"sha": "c3fe1de895df9dcf6ef9e3dfa4bccc596662eecd", "filename": "src/test/compile-fail/transmute-from-fn-item-types-error.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7650afc1cea284956080098d39d670ea0b007ce7/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7650afc1cea284956080098d39d670ea0b007ce7/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-error.rs?ref=7650afc1cea284956080098d39d670ea0b007ce7", "patch": "@@ -10,14 +10,61 @@\n \n use std::mem;\n \n+unsafe fn foo() -> (isize, *const (), Option<fn()>) {\n+    let i = mem::transmute(bar);\n+    //~^ ERROR is zero-sized and can't be transmuted\n+    //~^^ NOTE cast with `as` to a pointer instead\n+\n+    let p = mem::transmute(foo);\n+    //~^ ERROR is zero-sized and can't be transmuted\n+    //~^^ NOTE cast with `as` to a pointer instead\n+\n+    let of = mem::transmute(main);\n+    //~^ ERROR is zero-sized and can't be transmuted\n+    //~^^ NOTE cast with `as` to a pointer instead\n+\n+    (i, p, of)\n+}\n+\n unsafe fn bar() {\n-    // Error, still, if the resulting type is not pointer-sized.\n+    // Error as usual if the resulting type is not pointer-sized.\n     mem::transmute::<_, u8>(main);\n     //~^ ERROR transmute called with differently sized types\n+    //~^^ NOTE transmuting between 0 bits and 8 bits\n+\n+    mem::transmute::<_, *mut ()>(foo);\n+    //~^ ERROR is zero-sized and can't be transmuted\n+    //~^^ NOTE cast with `as` to a pointer instead\n+\n+    mem::transmute::<_, fn()>(bar);\n+    //~^ ERROR is zero-sized and can't be transmuted\n+    //~^^ NOTE cast with `as` to a pointer instead\n+\n+    // No error if a coercion would otherwise occur.\n+    mem::transmute::<fn(), usize>(main);\n+}\n+\n+unsafe fn baz() {\n+    mem::transmute::<_, *mut ()>(Some(foo));\n+    //~^ ERROR is zero-sized and can't be transmuted\n+    //~^^ NOTE cast with `as` to a pointer instead\n+\n+    mem::transmute::<_, fn()>(Some(bar));\n+    //~^ ERROR is zero-sized and can't be transmuted\n+    //~^^ NOTE cast with `as` to a pointer instead\n+\n+    mem::transmute::<_, Option<fn()>>(Some(baz));\n+    //~^ ERROR is zero-sized and can't be transmuted\n+    //~^^ NOTE cast with `as` to a pointer instead\n+\n+    // No error if a coercion would otherwise occur.\n+    mem::transmute::<Option<fn()>, usize>(Some(main));\n }\n \n fn main() {\n     unsafe {\n+        foo();\n         bar();\n+        baz();\n     }\n }"}, {"sha": "08e660e878c2978ea54261cb28077ebff49454f5", "filename": "src/test/compile-fail/transmute-from-fn-item-types-lint.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![deny(transmute_from_fn_item_types)]\n-\n-use std::mem;\n-\n-unsafe fn foo() -> (isize, *const (), Option<fn()>) {\n-    let i = mem::transmute(bar);\n-    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARNING was previously accepted\n-\n-    let p = mem::transmute(foo);\n-    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARNING was previously accepted\n-\n-    let of = mem::transmute(main);\n-    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARNING was previously accepted\n-\n-    (i, p, of)\n-}\n-\n-unsafe fn bar() {\n-    mem::transmute::<_, *mut ()>(foo);\n-    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARNING was previously accepted\n-\n-    mem::transmute::<_, fn()>(bar);\n-    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARNING was previously accepted\n-\n-    // No error if a coercion would otherwise occur.\n-    mem::transmute::<fn(), usize>(main);\n-}\n-\n-fn main() {\n-    unsafe {\n-        foo();\n-        bar();\n-    }\n-}"}, {"sha": "574a90e2ad6972fd11de8f85c0d6d8c7c50ef0c4", "filename": "src/test/run-pass/transmute-from-fn-item-types.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Ftransmute-from-fn-item-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Ftransmute-from-fn-item-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftransmute-from-fn-item-types.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(transmute_from_fn_item_types)]\n-\n-use std::mem;\n-\n-fn main() {\n-    unsafe {\n-        let u = mem::transmute(main);\n-        let p = mem::transmute(main);\n-        let f = mem::transmute(main);\n-        let tuple: (usize, *mut (), fn()) = (u, p, f);\n-        assert_eq!(mem::transmute::<_, [usize; 3]>(tuple), [main as usize; 3]);\n-\n-        mem::transmute::<_, usize>(main);\n-        mem::transmute::<_, *mut ()>(main);\n-        mem::transmute::<_, fn()>(main);\n-    }\n-}"}]}