{"sha": "489f470886ed95d005c6687aa29d12f514e626c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4OWY0NzA4ODZlZDk1ZDAwNWM2Njg3YWEyOWQxMmY1MTRlNjI2YzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-25T10:01:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-25T10:01:20Z"}, "message": "auto merge of #14370 : cmr/rust/design-faq, r=brson\n\nThis indends to help quell frequently answered questions about the language\ndesign in a single, authoritative place.", "tree": {"sha": "77a6996f614f09a022f9f20c552d2ca6de6e446c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77a6996f614f09a022f9f20c552d2ca6de6e446c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/489f470886ed95d005c6687aa29d12f514e626c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/489f470886ed95d005c6687aa29d12f514e626c2", "html_url": "https://github.com/rust-lang/rust/commit/489f470886ed95d005c6687aa29d12f514e626c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/489f470886ed95d005c6687aa29d12f514e626c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b1426b87c203c64dd4200eef0dd67ea5af29268", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b1426b87c203c64dd4200eef0dd67ea5af29268", "html_url": "https://github.com/rust-lang/rust/commit/6b1426b87c203c64dd4200eef0dd67ea5af29268"}, {"sha": "11c0f771074111ed067a8a828c0ad01594043d98", "url": "https://api.github.com/repos/rust-lang/rust/commits/11c0f771074111ed067a8a828c0ad01594043d98", "html_url": "https://github.com/rust-lang/rust/commit/11c0f771074111ed067a8a828c0ad01594043d98"}], "stats": {"total": 195, "additions": 186, "deletions": 9}, "files": [{"sha": "91ff72ed2b53ee3cf3bc206b7e23f64e1da0bd66", "filename": "mk/docs.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/489f470886ed95d005c6687aa29d12f514e626c2/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/489f470886ed95d005c6687aa29d12f514e626c2/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=489f470886ed95d005c6687aa29d12f514e626c2", "patch": "@@ -29,8 +29,8 @@\n DOCS := index intro tutorial guide-ffi guide-macros guide-lifetimes \\\n \tguide-tasks guide-container guide-pointers guide-testing \\\n \tguide-runtime complement-bugreport complement-cheatsheet \\\n-\tcomplement-lang-faq complement-project-faq rust rustdoc \\\n-\tguide-unsafe\n+\tcomplement-lang-faq complement-design-faq complement-project-faq rust \\\n+    rustdoc guide-unsafe\n \n PDF_DOCS := tutorial rust\n "}, {"sha": "8a8f6e02b6d222cf00fa2d0f21a6f0ad5bb48943", "filename": "src/doc/complement-design-faq.md", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/489f470886ed95d005c6687aa29d12f514e626c2/src%2Fdoc%2Fcomplement-design-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/489f470886ed95d005c6687aa29d12f514e626c2/src%2Fdoc%2Fcomplement-design-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-design-faq.md?ref=489f470886ed95d005c6687aa29d12f514e626c2", "patch": "@@ -0,0 +1,176 @@\n+% Rust Design FAQ\n+\n+This document describes decisions were arrived at after lengthy discussion and\n+experimenting with alternatives. Please do not propose reversing them unless\n+you have a new, extremely compelling argument. Note that this document\n+specifically talks about the *language* and not any library or implementation.\n+\n+A few general guidelines define the philosophy:\n+\n+- [Memory safety][mem] must never be compromised\n+- [Abstraction][abs] should be zero-cost, while still maintaining safety\n+- Practicality is key\n+\n+[mem]: http://en.wikipedia.org/wiki/Memory_safety\n+[abs]: http://en.wikipedia.org/wiki/Abstraction_%28computer_science%29\n+\n+# Semantics\n+\n+## Data layout is unspecified\n+\n+In the general case, `enum` and `struct` layout is undefined. This allows the\n+compiler to potentially do optimizations like re-using padding for the\n+discriminant, compacting variants of nested enums, reordering fields to remove\n+padding, etc. `enum`s which carry no data (\"C-like\") are eligible to have a\n+defined representation. Such `enum`s are easily distinguished in that they are\n+simply a list of names that carry no data:\n+\n+```\n+enum CLike {\n+    A,\n+    B = 32,\n+    C = 34,\n+    D\n+}\n+```\n+\n+The [repr attribute][repr] can be applied to such `enum`s to give them the same\n+representation as a primitive. This allows using Rust `enum`s in FFI where C\n+`enum`s are also used, for most use cases. The attribute can also be applied\n+to `struct`s to get the same layout as a C struct would.\n+\n+[repr]: http://doc.rust-lang.org/rust.html#miscellaneous-attributes\n+\n+## There is no GC\n+\n+A language that requires a GC is a language that opts into a larger, more\n+complex runtime than Rust cares for. Rust is usable on bare metal with no\n+extra runtime. Additionally, garbage collection is frequently a source of\n+non-deterministic behavior. Rust provides the tools to make using a GC\n+possible and even pleasant, but it should not be a requirement for\n+implementing the language.\n+\n+## Non-`Share` `static mut` is unsafe\n+\n+Types which are [`Share`][share] are thread-safe when multiple shared\n+references to them are used concurrently. Types which are not `Share` are not\n+thread-safe, and thus when used in a global require unsafe code to use.\n+\n+[share]: http://doc.rust-lang.org/core/kinds/trait.Share.html\n+\n+### If mutable static items that implement `Share` are safe, why is taking &mut SHARABLE unsafe?\n+\n+Having multiple aliasing `&mut T`s is never allowed. Due to the nature of\n+globals, the borrow checker cannot possibly ensure that a static obeys the\n+borrowing rules, so taking a mutable reference to a static is always unsafe.\n+\n+## There is no life before or after main (no static ctors/dtors)\n+\n+Globals can not have a non-constant-expression constructor and cannot have a\n+destructor at all. This is an opinion of the language. Static constructors are\n+undesirable because they can slow down program startup. Life before main is\n+often considered a misfeature, never to be used. Rust helps this along by just\n+not having the feature.\n+\n+See [the C++ FQA][fqa]  about the \"static initialization order fiasco\", and\n+[Eric Lippert's blog][elp] for the challenges in C#, which also has this\n+feature.\n+\n+A nice replacement is the [lazy constructor macro][lcm] by [Marvin\n+L\u00f6bel][kim].\n+\n+[fqa]: https://mail.mozilla.org/pipermail/rust-dev/2013-April/003815.html\n+[elp]: http://ericlippert.com/2013/02/06/static-constructors-part-one/\n+[lcm]: https://gist.github.com/Kimundi/8782487\n+[kim]: https://github.com/Kimundi\n+\n+## The language does not require a runtime\n+\n+See the above entry on GC. Requiring a runtime limits the utility of the\n+language, and makes it undeserving of the title \"systems language\". All Rust\n+code should need to run is a stack.\n+\n+## `match` must be exhaustive\n+\n+`match` being exhaustive has some useful properties. First, if every\n+possibility is covered by the `match`, adding further variants to the `enum`\n+in the future will prompt a compilation failure, rather than runtime failure.\n+Second, it makes cost explicit. In general, only safe way to have a\n+non-exhaustive match would be to fail the task if nothing is matched, though\n+it could fall through if the type of the `match` expression is `()`. This sort\n+of hidden cost and special casing is against the language's philosophy. It's\n+easy to ignore certain cases by using the `_` wildcard:\n+\n+```rust,ignore\n+match val.do_something() {\n+    Cat(a) => { /* ... */ }\n+    _      => { /* ... */ }\n+}\n+```\n+\n+[#3101][iss] is the issue that proposed making this the only behavior, with\n+rationale and discussion.\n+\n+[iss]: https://github.com/mozilla/rust/issues/3101\n+\n+## No guaranteed tail-call optimization\n+\n+In general, tail-call optimization is not guaranteed: see for a detailed\n+explanation with references. There is a [proposed extension][tce] that would\n+allow tail-call elimination in certain contexts. The compiler is still free to\n+optimize tail-calls [when it pleases][sco], however.\n+\n+[tml]: https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html\n+[sco]: http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization\n+[tce]: https://github.com/rust-lang/rfcs/pull/81\n+\n+## No constructors\n+\n+Functions can serve the same purpose as constructors without adding any\n+language complexity.\n+\n+## No copy constructors\n+\n+Types which implement [`Copy`][copy], will do a standard C-like \"shallow copy\"\n+with no extra work (similar to \"plain old data\" in C++). It is impossible to\n+implement `Copy` types that require custom copy behavior. Instead, in Rust\n+\"copy constructors\" are created by implementing the [`Clone`][clone] trait,\n+and explicitly calling the `clone` method. Making user-defined copy operators\n+explicit surfaces the underlying complexity, forcing the developer to opt-in\n+to potentially expensive operations.\n+\n+[copy]: http://doc.rust-lang.org/core/kinds/trait.Copy.html\n+[clone]: http://doc.rust-lang.org/core/clone/trait.Clone.html\n+\n+## No move constructors\n+\n+Values of all types are moved via `memcpy`. This makes writing generic unsafe\n+code much simpler since assignment, passing and returning are known to never\n+have a side effect like unwinding.\n+\n+# Syntax\n+\n+## Macros require balanced delimiters\n+\n+This is to make the language easier to parse for machines. Since the body of a\n+macro can contain arbitrary tokens, some restriction is needed to allow simple\n+non-macro-expanding lexers and parsers. This comes in the form of requiring\n+that all delimiters be balanced.\n+\n+## `->` for function return type\n+\n+This is to make the language easier to parse for humans, especially in the face\n+of higher-order functions. `fn foo<T>(f: fn(int): int, fn(T): U): U` is not\n+particularly easy to read.\n+\n+## `let` is used to introduce variables\n+\n+`let` not only defines variables, but can do pattern matching. One can also\n+redeclare immutable variables with `let`. This is useful to avoid unnecessary\n+`mut` annotations. An interesting historical note is that Rust comes,\n+syntactically, most closely from ML, which also uses `let` to introduce\n+bindings.\n+\n+See also [a long thread][alt] on renaming `let mut` to `var`.\n+\n+[alt]: https://mail.mozilla.org/pipermail/rust-dev/2014-January/008319.html"}, {"sha": "37d03d0867d13cab1639c519251257ed0d2b9efa", "filename": "src/doc/index.md", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/489f470886ed95d005c6687aa29d12f514e626c2/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/489f470886ed95d005c6687aa29d12f514e626c2/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=489f470886ed95d005c6687aa29d12f514e626c2", "patch": "@@ -23,6 +23,14 @@ li {list-style-type: none; }\n * [Testing](guide-testing.html)\n * [Rust's Runtime](guide-runtime.html)\n \n+# FAQs\n+\n+* [Language Design FAQ](complement-design-faq.html)\n+* [Language FAQ](complement-lang-faq.html)\n+* [Project FAQ](complement-project-faq.html)\n+* [Code cheatsheet](complement-cheatsheet.html) - \"How do I do X?\"\n+* [How to submit a bug report](complement-bugreport.html)\n+\n # Libraries\n \n * [The standard library, `std`](std/index.html)\n@@ -60,13 +68,6 @@ li {list-style-type: none; }\n \n * [The `rustdoc` manual](rustdoc.html)\n \n-# FAQs\n-\n-* [Language FAQ](complement-lang-faq.html)\n-* [Project FAQ](complement-project-faq.html)\n-* [Code cheatsheet](complement-cheatsheet.html) - \"How do I do X?\"\n-* [How to submit a bug report](complement-bugreport.html)\n-\n # External resources\n \n * The Rust IRC channels on [irc.mozilla.org](http://irc.mozilla.org/)"}]}