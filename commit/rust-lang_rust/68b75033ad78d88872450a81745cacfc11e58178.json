{"sha": "68b75033ad78d88872450a81745cacfc11e58178", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4Yjc1MDMzYWQ3OGQ4ODg3MjQ1MGE4MTc0NWNhY2ZjMTFlNTgxNzg=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-05-11T03:17:28Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-05-12T02:38:14Z"}, "message": "Split `RawVec::grow` up.\n\nThe amortized case is much more common than the exact case, and it is\ntypically instantiated many times.\n\nAlso, we can put a chunk of the code into a function that isn't generic\nover T, which reduces the amount of LLVM IR generated quite a lot,\nimproving compile times.", "tree": {"sha": "1500e771f8d43bbf17a25a18d2fd9d9d606faf11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1500e771f8d43bbf17a25a18d2fd9d9d606faf11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68b75033ad78d88872450a81745cacfc11e58178", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68b75033ad78d88872450a81745cacfc11e58178", "html_url": "https://github.com/rust-lang/rust/commit/68b75033ad78d88872450a81745cacfc11e58178", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68b75033ad78d88872450a81745cacfc11e58178/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f420726566587862ef4da9153fbc2800ed444033", "url": "https://api.github.com/repos/rust-lang/rust/commits/f420726566587862ef4da9153fbc2800ed444033", "html_url": "https://github.com/rust-lang/rust/commit/f420726566587862ef4da9153fbc2800ed444033"}], "stats": {"total": 129, "additions": 79, "deletions": 50}, "files": [{"sha": "d46bf81f996f73433649a331789e2203475695a3", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 79, "deletions": 50, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/68b75033ad78d88872450a81745cacfc11e58178/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b75033ad78d88872450a81745cacfc11e58178/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=68b75033ad78d88872450a81745cacfc11e58178", "patch": "@@ -1,7 +1,7 @@\n #![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n #![doc(hidden)]\n \n-use core::alloc::MemoryBlock;\n+use core::alloc::{LayoutErr, MemoryBlock};\n use core::cmp;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::Drop;\n@@ -278,7 +278,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         needed_extra_capacity: usize,\n     ) -> Result<(), TryReserveError> {\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Amortized, used_capacity, needed_extra_capacity, MayMove, Uninitialized)\n+            self.grow_amortized(used_capacity, needed_extra_capacity, MayMove)\n         } else {\n             Ok(())\n         }\n@@ -305,8 +305,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         // This is more readable than putting this in one line:\n         // `!self.needs_to_grow(...) || self.grow(...).is_ok()`\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Amortized, used_capacity, needed_extra_capacity, InPlace, Uninitialized)\n-                .is_ok()\n+            self.grow_amortized(used_capacity, needed_extra_capacity, InPlace).is_ok()\n         } else {\n             true\n         }\n@@ -347,7 +346,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         needed_extra_capacity: usize,\n     ) -> Result<(), TryReserveError> {\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Exact, used_capacity, needed_extra_capacity, MayMove, Uninitialized)\n+            self.grow_exact(used_capacity, needed_extra_capacity)\n         } else {\n             Ok(())\n         }\n@@ -372,13 +371,6 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-enum Strategy {\n-    Amortized,\n-    Exact,\n-}\n-use Strategy::*;\n-\n impl<T, A: AllocRef> RawVec<T, A> {\n     /// Returns if the buffer needs to grow to fulfill the needed extra capacity.\n     /// Mainly used to make inlining reserve-calls possible without inlining `grow`.\n@@ -396,54 +388,59 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         self.cap = Self::capacity_from_bytes(memory.size);\n     }\n \n-    /// Single method to handle all possibilities of growing the buffer.\n-    fn grow(\n+    // This method is usually instantiated many times. So we want it to be as\n+    // small as possible, to improve compile times. But we also want as much of\n+    // its contents to be statically computable as possible, to make the\n+    // generated code run faster. Therefore, this method is carefully written\n+    // so that all of the code that depends on `T` is within it, while as much\n+    // of the code that doesn't depend on `T` as possible is in functions that\n+    // are non-generic over `T`.\n+    fn grow_amortized(\n         &mut self,\n-        strategy: Strategy,\n         used_capacity: usize,\n         needed_extra_capacity: usize,\n         placement: ReallocPlacement,\n-        init: AllocInit,\n     ) -> Result<(), TryReserveError> {\n-        let elem_size = mem::size_of::<T>();\n-        if elem_size == 0 {\n+        if mem::size_of::<T>() == 0 {\n             // Since we return a capacity of `usize::MAX` when `elem_size` is\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             return Err(CapacityOverflow);\n         }\n-        let new_layout = match strategy {\n-            Amortized => {\n-                // Nothing we can really do about these checks, sadly.\n-                let required_cap =\n-                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n-                // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n-                let double_cap = self.cap * 2;\n-                // `double_cap` guarantees exponential growth.\n-                let cap = cmp::max(double_cap, required_cap);\n-                Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?\n-            }\n-            Exact => {\n-                let cap =\n-                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n-                Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?\n-            }\n-        };\n-        alloc_guard(new_layout.size())?;\n \n-        let memory = if let Some((ptr, old_layout)) = self.current_memory() {\n-            debug_assert_eq!(old_layout.align(), new_layout.align());\n-            unsafe {\n-                self.alloc\n-                    .grow(ptr, old_layout, new_layout.size(), placement, init)\n-                    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n-            }\n-        } else {\n-            match placement {\n-                MayMove => self.alloc.alloc(new_layout, init),\n-                InPlace => Err(AllocErr),\n-            }\n-            .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n-        };\n+        // Nothing we can really do about these checks, sadly.\n+        let required_cap =\n+            used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n+        // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n+        let double_cap = self.cap * 2;\n+        // `double_cap` guarantees exponential growth.\n+        let cap = cmp::max(double_cap, required_cap);\n+        let new_layout = Layout::array::<T>(cap);\n+\n+        // `finish_grow` is non-generic over `T`.\n+        let memory = finish_grow(new_layout, placement, self.current_memory(), &mut self.alloc)?;\n+        self.set_memory(memory);\n+        Ok(())\n+    }\n+\n+    // The constraints on this method are much the same as those on\n+    // `grow_amortized`, but this method is usually instantiated less often so\n+    // it's less critical.\n+    fn grow_exact(\n+        &mut self,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n+    ) -> Result<(), TryReserveError> {\n+        if mem::size_of::<T>() == 0 {\n+            // Since we return a capacity of `usize::MAX` when the type size is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n+            return Err(CapacityOverflow);\n+        }\n+\n+        let cap = used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n+        let new_layout = Layout::array::<T>(cap);\n+\n+        // `finish_grow` is non-generic over `T`.\n+        let memory = finish_grow(new_layout, MayMove, self.current_memory(), &mut self.alloc)?;\n         self.set_memory(memory);\n         Ok(())\n     }\n@@ -471,6 +468,38 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n }\n \n+// This function is outside `RawVec` to minimize compile times. See the comment\n+// above `RawVec::grow_amortized` for details. (The `A` parameter isn't\n+// significant, because the number of different `A` types seen in practice is\n+// much smaller than the number of `T` types.)\n+fn finish_grow<A>(\n+    new_layout: Result<Layout, LayoutErr>,\n+    placement: ReallocPlacement,\n+    current_memory: Option<(NonNull<u8>, Layout)>,\n+    alloc: &mut A,\n+) -> Result<MemoryBlock, TryReserveError>\n+where\n+    A: AllocRef,\n+{\n+    // Check for the error here to minimize the size of `RawVec::grow_*`.\n+    let new_layout = new_layout.map_err(|_| CapacityOverflow)?;\n+\n+    alloc_guard(new_layout.size())?;\n+\n+    let memory = if let Some((ptr, old_layout)) = current_memory {\n+        debug_assert_eq!(old_layout.align(), new_layout.align());\n+        unsafe { alloc.grow(ptr, old_layout, new_layout.size(), placement, Uninitialized) }\n+    } else {\n+        match placement {\n+            MayMove => alloc.alloc(new_layout, Uninitialized),\n+            InPlace => Err(AllocErr),\n+        }\n+    }\n+    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?;\n+\n+    Ok(memory)\n+}\n+\n impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n     ///"}]}