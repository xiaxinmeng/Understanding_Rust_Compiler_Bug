{"sha": "8d0de3a8da50c2a0eca8e8ece13b77d712d8652d", "node_id": "C_kwDOAAsO6NoAKDhkMGRlM2E4ZGE1MGMyYTBlY2E4ZThlY2UxM2I3N2Q3MTJkODY1MmQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-04T21:42:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-04T21:42:03Z"}, "message": "Rollup merge of #97735 - jsha:no-foreign-std, r=GuillaumeGomez\n\nDon't generate \"Impls on Foreign Types\" for std\n\nHack: many traits and types in std are re-exported from core or alloc. In general, rustdoc is capable of recognizing these implementations as being on local types. However, in at least one case, rustdoc gets confused and labels an implementation as being on a foreign type. To make sure that confusion doesn't pass on to the reader, consider all implementations in std, core, and alloc to be on local types.\n\nDemo: https://rustdoc.crud.net/jsha/no-foreign-std/std/clone/trait.Clone.html", "tree": {"sha": "72dd2a34c8ed80ae1c3d4577b2436ce227e37b08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72dd2a34c8ed80ae1c3d4577b2436ce227e37b08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d0de3a8da50c2a0eca8e8ece13b77d712d8652d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJim9GsCRBK7hj4Ov3rIwAAm0kIAAOGedCnqqmTHgXnCIBBp+8N\nWgcmsl8WYS1nEDP7uu4Ow0+bnqKCOSqs+bFEZ8IvW0Kx4nVMjcQzjkhvcY06SilA\nI57iMStXUknY6SclVhjlWhCwv716I0rdUMIuhawGK0Ga/kKK8lmxT9JPpjISxc0x\nv8w8x5RlpmfQJiqmqytad3QY7oJiFdFpFT+8q456jqwZKP9x31gNUhGa5lZCj6V8\nfx+vt4d82s6FGSPqwizmoxcTMIph3ondtHPoCjddXqRrlinKKFkdFdBl5Kfsp9wC\neMwhuKjYV84NGJE+t9FP3Ir+6Gqt7WClpCvZq7lDaTUzAckaawLndBUSooqDlAU=\n=Kxkb\n-----END PGP SIGNATURE-----\n", "payload": "tree 72dd2a34c8ed80ae1c3d4577b2436ce227e37b08\nparent c857265b51a14625a36d4b57b3978e3e008e8983\nparent 784eebcc604a10c697f6dce2f82155268333c57c\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1654378923 +0200\ncommitter GitHub <noreply@github.com> 1654378923 +0200\n\nRollup merge of #97735 - jsha:no-foreign-std, r=GuillaumeGomez\n\nDon't generate \"Impls on Foreign Types\" for std\n\nHack: many traits and types in std are re-exported from core or alloc. In general, rustdoc is capable of recognizing these implementations as being on local types. However, in at least one case, rustdoc gets confused and labels an implementation as being on a foreign type. To make sure that confusion doesn't pass on to the reader, consider all implementations in std, core, and alloc to be on local types.\n\nDemo: https://rustdoc.crud.net/jsha/no-foreign-std/std/clone/trait.Clone.html\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0de3a8da50c2a0eca8e8ece13b77d712d8652d", "html_url": "https://github.com/rust-lang/rust/commit/8d0de3a8da50c2a0eca8e8ece13b77d712d8652d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d0de3a8da50c2a0eca8e8ece13b77d712d8652d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c857265b51a14625a36d4b57b3978e3e008e8983", "url": "https://api.github.com/repos/rust-lang/rust/commits/c857265b51a14625a36d4b57b3978e3e008e8983", "html_url": "https://github.com/rust-lang/rust/commit/c857265b51a14625a36d4b57b3978e3e008e8983"}, {"sha": "784eebcc604a10c697f6dce2f82155268333c57c", "url": "https://api.github.com/repos/rust-lang/rust/commits/784eebcc604a10c697f6dce2f82155268333c57c", "html_url": "https://github.com/rust-lang/rust/commit/784eebcc604a10c697f6dce2f82155268333c57c"}], "stats": {"total": 24, "additions": 18, "deletions": 6}, "files": [{"sha": "b236bd7be4f0c0eb9db8ccde0bf628071d3ca83a", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8d0de3a8da50c2a0eca8e8ece13b77d712d8652d/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0de3a8da50c2a0eca8e8ece13b77d712d8652d/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=8d0de3a8da50c2a0eca8e8ece13b77d712d8652d", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::def_id::DefId;\n pub(crate) use renderer::{run_format, FormatRenderer};\n \n use crate::clean::{self, ItemId};\n-use cache::Cache;\n+use crate::html::render::Context;\n \n /// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n /// impl.\n@@ -65,7 +65,8 @@ impl Impl {\n     // Returns true if this is an implementation on a \"local\" type, meaning:\n     // the type is in the current crate, or the type and the trait are both\n     // re-exported by the current crate.\n-    pub(crate) fn is_on_local_type(&self, cache: &Cache) -> bool {\n+    pub(crate) fn is_on_local_type(&self, cx: &Context<'_>) -> bool {\n+        let cache = cx.cache();\n         let for_type = &self.inner_impl().for_;\n         if let Some(for_type_did) = for_type.def_id(cache) {\n             // The \"for\" type is local if it's in the paths for the current crate.\n@@ -80,6 +81,18 @@ impl Impl {\n                 if for_type_did.krate == trait_did.krate {\n                     return true;\n                 }\n+                // Hack: many traits and types in std are re-exported from\n+                // core or alloc. In general, rustdoc is capable of recognizing\n+                // these implementations as being on local types. However, in at\n+                // least one case (https://github.com/rust-lang/rust/issues/97610),\n+                // rustdoc gets confused and labels an implementation as being on\n+                // a foreign type. To make sure that confusion doesn't pass on to\n+                // the reader, consider all implementations in std, core, and alloc\n+                // to be on local types.\n+                let crate_name = cx.tcx().crate_name(trait_did.krate);\n+                if matches!(crate_name.as_str(), \"std\" | \"core\" | \"alloc\") {\n+                    return true;\n+                }\n             }\n             return false;\n         };"}, {"sha": "23ce634cf286ba839680ef3291abbba78ae2e74e", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d0de3a8da50c2a0eca8e8ece13b77d712d8652d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0de3a8da50c2a0eca8e8ece13b77d712d8652d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8d0de3a8da50c2a0eca8e8ece13b77d712d8652d", "patch": "@@ -2281,11 +2281,10 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::Method),\n     );\n \n-    let cache = cx.cache();\n-    if let Some(implementors) = cache.implementors.get(&it.item_id.expect_def_id()) {\n+    if let Some(implementors) = cx.cache().implementors.get(&it.item_id.expect_def_id()) {\n         let mut res = implementors\n             .iter()\n-            .filter(|i| !i.is_on_local_type(cache))\n+            .filter(|i| !i.is_on_local_type(cx))\n             .filter_map(|i| extract_for_impl_name(&i.impl_item, cx))\n             .collect::<Vec<_>>();\n "}, {"sha": "d115185562ce44344ad2cb87265f4b82618480a8", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d0de3a8da50c2a0eca8e8ece13b77d712d8652d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0de3a8da50c2a0eca8e8ece13b77d712d8652d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=8d0de3a8da50c2a0eca8e8ece13b77d712d8652d", "patch": "@@ -823,7 +823,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         }\n \n         let (local, foreign) =\n-            implementors.iter().partition::<Vec<_>, _>(|i| i.is_on_local_type(cache));\n+            implementors.iter().partition::<Vec<_>, _>(|i| i.is_on_local_type(cx));\n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             local.iter().partition(|i| i.inner_impl().kind.is_auto());"}]}