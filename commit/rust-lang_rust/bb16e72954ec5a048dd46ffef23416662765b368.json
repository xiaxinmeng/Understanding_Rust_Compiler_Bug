{"sha": "bb16e72954ec5a048dd46ffef23416662765b368", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMTZlNzI5NTRlYzVhMDQ4ZGQ0NmZmZWYyMzQxNjY2Mjc2NWIzNjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-15T18:24:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-15T18:24:18Z"}, "message": "Auto merge of #61868 - Centril:rollup-gglsecp, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #61785 (note some safety concerns of raw-ptr-to-ref casts)\n - #61805 (typeck: Fix ICE for blocks in repeat expr count.)\n - #61813 (Remove some unnecessary symbol interner ops)\n - #61824 (in which we decline to lint single-use lifetimes in `derive`d impls)\n - #61844 (Change `...` to `..=` where applicable)\n - #61854 (Minor cosmetic improvements to accompany PR 61825)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3a2d9840c569f96fa1db0200b4709992cd2a8367", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a2d9840c569f96fa1db0200b4709992cd2a8367"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb16e72954ec5a048dd46ffef23416662765b368", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb16e72954ec5a048dd46ffef23416662765b368", "html_url": "https://github.com/rust-lang/rust/commit/bb16e72954ec5a048dd46ffef23416662765b368", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb16e72954ec5a048dd46ffef23416662765b368/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f06855064ed06a50c496577b21ca50f92a2e67d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f06855064ed06a50c496577b21ca50f92a2e67d", "html_url": "https://github.com/rust-lang/rust/commit/9f06855064ed06a50c496577b21ca50f92a2e67d"}, {"sha": "ab2d2f90c49437fb99f1bc469e13d62c1b2addeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab2d2f90c49437fb99f1bc469e13d62c1b2addeb", "html_url": "https://github.com/rust-lang/rust/commit/ab2d2f90c49437fb99f1bc469e13d62c1b2addeb"}], "stats": {"total": 328, "additions": 198, "deletions": 130}, "files": [{"sha": "a337c467131335cdbafe1f60951f31743f317ff4", "filename": "src/libcore/benches/ascii.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -191,7 +191,7 @@ benches! {\n     fn case11_mask_mult_bool_match_range(bytes: &mut [u8]) {\n         fn is_ascii_lowercase(b: u8) -> bool {\n             match b {\n-                b'a'...b'z' => true,\n+                b'a'..=b'z' => true,\n                 _ => false\n             }\n         }\n@@ -203,7 +203,7 @@ benches! {\n     fn case12_mask_shifted_bool_match_range(bytes: &mut [u8]) {\n         fn is_ascii_lowercase(b: u8) -> bool {\n             match b {\n-                b'a'...b'z' => true,\n+                b'a'..=b'z' => true,\n                 _ => false\n             }\n         }\n@@ -215,7 +215,7 @@ benches! {\n     fn case13_subtract_shifted_bool_match_range(bytes: &mut [u8]) {\n         fn is_ascii_lowercase(b: u8) -> bool {\n             match b {\n-                b'a'...b'z' => true,\n+                b'a'..=b'z' => true,\n                 _ => false\n             }\n         }\n@@ -227,7 +227,7 @@ benches! {\n     fn case14_subtract_multiplied_bool_match_range(bytes: &mut [u8]) {\n         fn is_ascii_lowercase(b: u8) -> bool {\n             match b {\n-                b'a'...b'z' => true,\n+                b'a'..=b'z' => true,\n                 _ => false\n             }\n         }"}, {"sha": "0a870c67518c73a8fd4361971b1c35fc099db0f7", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -123,7 +123,7 @@ impl From<char> for u32 {\n     }\n }\n \n-/// Maps a byte in 0x00...0xFF to a `char` whose code point has the same value, in U+0000 to U+00FF.\n+/// Maps a byte in 0x00..=0xFF to a `char` whose code point has the same value, in U+0000..=U+00FF.\n ///\n /// Unicode is designed such that this effectively decodes bytes\n /// with the character encoding that IANA calls ISO-8859-1."}, {"sha": "722c4c805168ffbb7682da6ab09da72c3a351714", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -1042,8 +1042,8 @@ impl char {\n \n     /// Checks if the value is an ASCII alphabetic character:\n     ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z'.\n+    /// - U+0041 'A' ..= U+005A 'Z', or\n+    /// - U+0061 'a' ..= U+007A 'z'.\n     ///\n     /// # Examples\n     ///\n@@ -1075,7 +1075,7 @@ impl char {\n     }\n \n     /// Checks if the value is an ASCII uppercase character:\n-    /// U+0041 'A' ... U+005A 'Z'.\n+    /// U+0041 'A' ..= U+005A 'Z'.\n     ///\n     /// # Examples\n     ///\n@@ -1107,7 +1107,7 @@ impl char {\n     }\n \n     /// Checks if the value is an ASCII lowercase character:\n-    /// U+0061 'a' ... U+007A 'z'.\n+    /// U+0061 'a' ..= U+007A 'z'.\n     ///\n     /// # Examples\n     ///\n@@ -1140,9 +1140,9 @@ impl char {\n \n     /// Checks if the value is an ASCII alphanumeric character:\n     ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z', or\n-    /// - U+0030 '0' ... U+0039 '9'.\n+    /// - U+0041 'A' ..= U+005A 'Z', or\n+    /// - U+0061 'a' ..= U+007A 'z', or\n+    /// - U+0030 '0' ..= U+0039 '9'.\n     ///\n     /// # Examples\n     ///\n@@ -1174,7 +1174,7 @@ impl char {\n     }\n \n     /// Checks if the value is an ASCII decimal digit:\n-    /// U+0030 '0' ... U+0039 '9'.\n+    /// U+0030 '0' ..= U+0039 '9'.\n     ///\n     /// # Examples\n     ///\n@@ -1207,9 +1207,9 @@ impl char {\n \n     /// Checks if the value is an ASCII hexadecimal digit:\n     ///\n-    /// - U+0030 '0' ... U+0039 '9', or\n-    /// - U+0041 'A' ... U+0046 'F', or\n-    /// - U+0061 'a' ... U+0066 'f'.\n+    /// - U+0030 '0' ..= U+0039 '9', or\n+    /// - U+0041 'A' ..= U+0046 'F', or\n+    /// - U+0061 'a' ..= U+0066 'f'.\n     ///\n     /// # Examples\n     ///\n@@ -1242,10 +1242,10 @@ impl char {\n \n     /// Checks if the value is an ASCII punctuation character:\n     ///\n-    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n-    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n-    /// - U+005B ... U+0060 ``[ \\ ] ^ _ ` ``, or\n-    /// - U+007B ... U+007E `{ | } ~`\n+    /// - U+0021 ..= U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n+    /// - U+003A ..= U+0040 `: ; < = > ? @`, or\n+    /// - U+005B ..= U+0060 ``[ \\ ] ^ _ ` ``, or\n+    /// - U+007B ..= U+007E `{ | } ~`\n     ///\n     /// # Examples\n     ///\n@@ -1277,7 +1277,7 @@ impl char {\n     }\n \n     /// Checks if the value is an ASCII graphic character:\n-    /// U+0021 '!' ... U+007E '~'.\n+    /// U+0021 '!' ..= U+007E '~'.\n     ///\n     /// # Examples\n     ///\n@@ -1358,7 +1358,7 @@ impl char {\n     }\n \n     /// Checks if the value is an ASCII control character:\n-    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n+    /// U+0000 NUL ..= U+001F UNIT SEPARATOR, or U+007F DELETE.\n     /// Note that most ASCII whitespace characters are control\n     /// characters, but SPACE is not.\n     ///"}, {"sha": "d70f55670116c9c0c662830d749b6e9763acecc4", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -4166,8 +4166,8 @@ impl u8 {\n \n     /// Checks if the value is an ASCII alphabetic character:\n     ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z'.\n+    /// - U+0041 'A' ..= U+005A 'Z', or\n+    /// - U+0061 'a' ..= U+007A 'z'.\n     ///\n     /// # Examples\n     ///\n@@ -4202,7 +4202,7 @@ impl u8 {\n     }\n \n     /// Checks if the value is an ASCII uppercase character:\n-    /// U+0041 'A' ... U+005A 'Z'.\n+    /// U+0041 'A' ..= U+005A 'Z'.\n     ///\n     /// # Examples\n     ///\n@@ -4237,7 +4237,7 @@ impl u8 {\n     }\n \n     /// Checks if the value is an ASCII lowercase character:\n-    /// U+0061 'a' ... U+007A 'z'.\n+    /// U+0061 'a' ..= U+007A 'z'.\n     ///\n     /// # Examples\n     ///\n@@ -4273,9 +4273,9 @@ impl u8 {\n \n     /// Checks if the value is an ASCII alphanumeric character:\n     ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z', or\n-    /// - U+0030 '0' ... U+0039 '9'.\n+    /// - U+0041 'A' ..= U+005A 'Z', or\n+    /// - U+0061 'a' ..= U+007A 'z', or\n+    /// - U+0030 '0' ..= U+0039 '9'.\n     ///\n     /// # Examples\n     ///\n@@ -4310,7 +4310,7 @@ impl u8 {\n     }\n \n     /// Checks if the value is an ASCII decimal digit:\n-    /// U+0030 '0' ... U+0039 '9'.\n+    /// U+0030 '0' ..= U+0039 '9'.\n     ///\n     /// # Examples\n     ///\n@@ -4346,9 +4346,9 @@ impl u8 {\n \n     /// Checks if the value is an ASCII hexadecimal digit:\n     ///\n-    /// - U+0030 '0' ... U+0039 '9', or\n-    /// - U+0041 'A' ... U+0046 'F', or\n-    /// - U+0061 'a' ... U+0066 'f'.\n+    /// - U+0030 '0' ..= U+0039 '9', or\n+    /// - U+0041 'A' ..= U+0046 'F', or\n+    /// - U+0061 'a' ..= U+0066 'f'.\n     ///\n     /// # Examples\n     ///\n@@ -4384,10 +4384,10 @@ impl u8 {\n \n     /// Checks if the value is an ASCII punctuation character:\n     ///\n-    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n-    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n-    /// - U+005B ... U+0060 ``[ \\ ] ^ _ ` ``, or\n-    /// - U+007B ... U+007E `{ | } ~`\n+    /// - U+0021 ..= U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n+    /// - U+003A ..= U+0040 `: ; < = > ? @`, or\n+    /// - U+005B ..= U+0060 ``[ \\ ] ^ _ ` ``, or\n+    /// - U+007B ..= U+007E `{ | } ~`\n     ///\n     /// # Examples\n     ///\n@@ -4422,7 +4422,7 @@ impl u8 {\n     }\n \n     /// Checks if the value is an ASCII graphic character:\n-    /// U+0021 '!' ... U+007E '~'.\n+    /// U+0021 '!' ..= U+007E '~'.\n     ///\n     /// # Examples\n     ///\n@@ -4509,7 +4509,7 @@ impl u8 {\n     }\n \n     /// Checks if the value is an ASCII control character:\n-    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n+    /// U+0000 NUL ..= U+001F UNIT SEPARATOR, or U+007F DELETE.\n     /// Note that most ASCII whitespace characters are control\n     /// characters, but SPACE is not.\n     ///"}, {"sha": "8f026a5b7d8dd0906ea19285c101e91a33333c0f", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -984,8 +984,17 @@ impl<T: ?Sized> *const T {\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n     ///\n+    /// When calling this method, you have to ensure that if the pointer is\n+    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n+    /// size of `T`) and points to an initialized instance of `T`. This applies\n+    /// even if the result of this method is unused!\n+    /// (The part about being initialized is not yet fully decided, but until\n+    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n+    ///\n     /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data.\n+    /// not necessarily reflect the actual lifetime of the data. It is up to the\n+    /// caller to ensure that for the duration of this lifetime, the memory this\n+    /// pointer points to does not get written to outside of `UnsafeCell<U>`.\n     ///\n     /// # Examples\n     ///\n@@ -1610,8 +1619,17 @@ impl<T: ?Sized> *mut T {\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n     ///\n+    /// When calling this method, you have to ensure that if the pointer is\n+    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n+    /// size of `T`) and points to an initialized instance of `T`. This applies\n+    /// even if the result of this method is unused!\n+    /// (The part about being initialized is not yet fully decided, but until\n+    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n+    ///\n     /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data.\n+    /// not necessarily reflect the actual lifetime of the data. It is up to the\n+    /// caller to ensure that for the duration of this lifetime, the memory this\n+    /// pointer points to does not get written to outside of `UnsafeCell<U>`.\n     ///\n     /// # Examples\n     ///\n@@ -1755,10 +1773,24 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// # Safety\n     ///\n-    /// As with `as_ref`, this is unsafe because it cannot verify the validity\n+    /// As with [`as_ref`], this is unsafe because it cannot verify the validity\n     /// of the returned pointer, nor can it ensure that the lifetime `'a`\n     /// returned is indeed a valid lifetime for the contained data.\n     ///\n+    /// When calling this method, you have to ensure that if the pointer is\n+    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n+    /// size of `T`) and points to an initialized instance of `T`. This applies\n+    /// even if the result of this method is unused!\n+    /// (The part about being initialized is not yet fully decided, but until\n+    /// it is the only safe approach is to ensure that they are indeed initialized.)\n+    ///\n+    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n+    /// not necessarily reflect the actual lifetime of the data. It is up to the\n+    /// caller to ensure that for the duration of this lifetime, the memory this\n+    /// pointer points to does not get accessed through any other pointer.\n+    ///\n+    /// [`as_ref`]: #method.as_ref\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:"}, {"sha": "6ace4c4174b56b39821d29864c700851acd48fd9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -994,7 +994,7 @@ pub enum PatKind {\n     /// A literal.\n     Lit(P<Expr>),\n \n-    /// A range pattern (e.g., `1...2` or `1..2`).\n+    /// A range pattern (e.g., `1..=2` or `1..2`).\n     Range(P<Expr>, P<Expr>, RangeEnd),\n \n     /// `[a, b, ..i, y, z]` is represented as:"}, {"sha": "48d2a477a9af45aba5b6a68984410d5a9941616f", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -1586,6 +1586,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             continue;\n                         }\n \n+                        if let Some(parent_def_id) = self.tcx.parent(def_id) {\n+                            if let Some(parent_hir_id) = self.tcx.hir()\n+                                .as_local_hir_id(parent_def_id) {\n+                                    // lifetimes in `derive` expansions don't count (Issue #53738)\n+                                    if self.tcx.hir().attrs_by_hir_id(parent_hir_id).iter()\n+                                        .any(|attr| attr.check_name(sym::automatically_derived)) {\n+                                            continue;\n+                                        }\n+                                }\n+                        }\n+\n                         let mut err = self.tcx.struct_span_lint_hir(\n                             lint::builtin::SINGLE_USE_LIFETIMES,\n                             id,"}, {"sha": "bb1a67bcdaeffcdd0efc14ddedc379d1795d4c40", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -428,7 +428,7 @@ enum Constructor<'tcx> {\n     Variant(DefId),\n     /// Literal values.\n     ConstantValue(&'tcx ty::Const<'tcx>),\n-    /// Ranges of literal values (`2...5` and `2..5`).\n+    /// Ranges of literal values (`2..=5` and `2..5`).\n     ConstantRange(u128, u128, Ty<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n     Slice(u64),\n@@ -816,7 +816,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n /// `IntRange`s always store a contiguous range. This means that values are\n /// encoded such that `0` encodes the minimum value for the integer,\n /// regardless of the signedness.\n-/// For example, the pattern `-128...127i8` is encoded as `0..=255`.\n+/// For example, the pattern `-128..=127i8` is encoded as `0..=255`.\n /// This makes comparisons and arithmetic on interval endpoints much more\n /// straightforward. See `signed_bias` for details.\n ///"}, {"sha": "e3cd2948d7af5c12b82bafa1bae47c7fa0180d86", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -305,7 +305,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 // Empty groups `a::b::{}` are turned into synthetic `self` imports\n-                // `a::b::c::{self as __dummy}`, so that their prefixes are correctly\n+                // `a::b::c::{self as _}`, so that their prefixes are correctly\n                 // resolved and checked for privacy/stability/etc.\n                 if items.is_empty() && !empty_for_self(&prefix) {\n                     let new_span = prefix[prefix.len() - 1].ident.span;\n@@ -314,7 +314,7 @@ impl<'a> Resolver<'a> {\n                             Ident::new(kw::SelfLower, new_span)\n                         ),\n                         kind: ast::UseTreeKind::Simple(\n-                            Some(Ident::from_str_and_span(\"__dummy\", new_span).gensym()),\n+                            Some(Ident::new(kw::Underscore, new_span)),\n                             ast::DUMMY_NODE_ID,\n                             ast::DUMMY_NODE_ID,\n                         ),"}, {"sha": "7f05e0f477c2d41a19a159b9bae27d5eac71d266", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -1519,37 +1519,32 @@ impl<'a> NameBinding<'a> {\n ///\n /// All other types are defined somewhere and possibly imported, but the primitive ones need\n /// special handling, since they have no place of origin.\n-#[derive(Default)]\n struct PrimitiveTypeTable {\n     primitive_types: FxHashMap<Name, PrimTy>,\n }\n \n impl PrimitiveTypeTable {\n     fn new() -> PrimitiveTypeTable {\n-        let mut table = PrimitiveTypeTable::default();\n-\n-        table.intern(\"bool\", Bool);\n-        table.intern(\"char\", Char);\n-        table.intern(\"f32\", Float(FloatTy::F32));\n-        table.intern(\"f64\", Float(FloatTy::F64));\n-        table.intern(\"isize\", Int(IntTy::Isize));\n-        table.intern(\"i8\", Int(IntTy::I8));\n-        table.intern(\"i16\", Int(IntTy::I16));\n-        table.intern(\"i32\", Int(IntTy::I32));\n-        table.intern(\"i64\", Int(IntTy::I64));\n-        table.intern(\"i128\", Int(IntTy::I128));\n-        table.intern(\"str\", Str);\n-        table.intern(\"usize\", Uint(UintTy::Usize));\n-        table.intern(\"u8\", Uint(UintTy::U8));\n-        table.intern(\"u16\", Uint(UintTy::U16));\n-        table.intern(\"u32\", Uint(UintTy::U32));\n-        table.intern(\"u64\", Uint(UintTy::U64));\n-        table.intern(\"u128\", Uint(UintTy::U128));\n-        table\n-    }\n-\n-    fn intern(&mut self, string: &str, primitive_type: PrimTy) {\n-        self.primitive_types.insert(Symbol::intern(string), primitive_type);\n+        let mut table = FxHashMap::default();\n+\n+        table.insert(sym::bool, Bool);\n+        table.insert(sym::char, Char);\n+        table.insert(sym::f32, Float(FloatTy::F32));\n+        table.insert(sym::f64, Float(FloatTy::F64));\n+        table.insert(sym::isize, Int(IntTy::Isize));\n+        table.insert(sym::i8, Int(IntTy::I8));\n+        table.insert(sym::i16, Int(IntTy::I16));\n+        table.insert(sym::i32, Int(IntTy::I32));\n+        table.insert(sym::i64, Int(IntTy::I64));\n+        table.insert(sym::i128, Int(IntTy::I128));\n+        table.insert(sym::str, Str);\n+        table.insert(sym::usize, Uint(UintTy::Usize));\n+        table.insert(sym::u8, Uint(UintTy::U8));\n+        table.insert(sym::u16, Uint(UintTy::U16));\n+        table.insert(sym::u32, Uint(UintTy::U32));\n+        table.insert(sym::u64, Uint(UintTy::U64));\n+        table.insert(sym::u128, Uint(UintTy::U128));\n+        Self { primitive_types: table }\n     }\n }\n "}, {"sha": "b7ad5d8ffabedda248e2b779e35775ed8a2a74d9", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -136,7 +136,7 @@ impl TargetDataLayout {\n                     }\n                     if bits >= i128_align_src && bits <= 128 {\n                         // Default alignment for i128 is decided by taking the alignment of\n-                        // largest-sized i{64...128}.\n+                        // largest-sized i{64..=128}.\n                         i128_align_src = bits;\n                         dl.i128_align = a;\n                     }"}, {"sha": "892a7b1f73015e794fb7179cbe9cd1ed69722b39", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -2157,6 +2157,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     /// Returns the `DefId` of the constant parameter that the provided expression is a path to.\n     pub fn const_param_def_id(&self, expr: &hir::Expr) -> Option<DefId> {\n+        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n+        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n+        let expr = match &expr.node {\n+            ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() =>\n+                block.expr.as_ref().unwrap(),\n+            _ => expr,\n+        };\n+\n         match &expr.node {\n             ExprKind::Path(hir::QPath::Resolved(_, path)) => match path.res {\n                 Res::Def(DefKind::ConstParam, did) => Some(did),\n@@ -2184,18 +2192,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty,\n         };\n \n-        let mut expr = &tcx.hir().body(ast_const.body).value;\n-\n-        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n-        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n-        if let ExprKind::Block(block, _) = &expr.node {\n-            if block.stmts.is_empty() {\n-                if let Some(trailing) = &block.expr {\n-                    expr = &trailing;\n-                }\n-            }\n-        }\n-\n+        let expr = &tcx.hir().body(ast_const.body).value;\n         if let Some(def_id) = self.const_param_def_id(expr) {\n             // Find the name and index of the const parameter by indexing the generics of the\n             // parent item and construct a `ParamConst`."}, {"sha": "65a36d9230641e2f410c4e0595726d205f2e32e7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // }\n             // ```\n             //\n-            // cc #46688\n+            // See issue #46688.\n             def_bm = ty::BindByValue(hir::MutImmutable);\n         }\n \n@@ -152,7 +152,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let ty = self.node_ty(lt.hir_id);\n \n                 // Byte string patterns behave the same way as array patterns\n-                // They can denote both statically and dynamically sized byte arrays\n+                // They can denote both statically and dynamically-sized byte arrays.\n                 let mut pat_ty = ty;\n                 if let hir::ExprKind::Lit(ref lt) = lt.node {\n                     if let ast::LitKind::ByteStr(_) = lt.node {\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                // somewhat surprising: in this case, the subtyping\n+                // Somewhat surprising: in this case, the subtyping\n                 // relation goes the opposite way as the other\n                 // cases. Actually what we really want is not a subtyping\n                 // relation at all but rather that there exists a LUB (so\n@@ -177,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 //\n                 //     &'static str <: expected\n                 //\n-                // that's equivalent to there existing a LUB.\n+                // then that's equivalent to there existing a LUB.\n                 if let Some(mut err) = self.demand_suptype_diag(pat.span, expected, pat_ty) {\n                     err.emit_unless(discrim_span\n                         .filter(|&s| s.is_compiler_desugaring(CompilerDesugaringKind::IfTemporary))\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // it to type the entire expression.\n                 let common_type = self.resolve_vars_if_possible(&lhs_ty);\n \n-                // subtyping doesn't matter here, as the value is some kind of scalar\n+                // Subtyping doesn't matter here, as the value is some kind of scalar.\n                 self.demand_eqtype_pat(pat.span, expected, lhs_ty, discrim_span);\n                 self.demand_eqtype_pat(pat.span, expected, rhs_ty, discrim_span);\n                 common_type\n@@ -250,8 +250,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n                 match bm {\n                     ty::BindByReference(mutbl) => {\n-                        // if the binding is like\n-                        //    ref x | ref const x | ref mut x\n+                        // If the binding is like\n+                        //     ref x | ref const x | ref mut x\n                         // then `x` is assigned a value of type `&M T` where M is the mutability\n                         // and T is the expected type.\n                         let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n@@ -263,16 +263,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // an explanation.\n                         self.demand_eqtype_pat(pat.span, region_ty, local_ty, discrim_span);\n                     }\n-                    // otherwise the type of x is the expected type T\n+                    // Otherwise, the type of x is the expected type `T`.\n                     ty::BindByValue(_) => {\n-                        // As above, `T <: typeof(x)` is required but we\n+                        // As above, `T <: typeof(x)` is required, but we\n                         // use equality, see (*) below.\n                         self.demand_eqtype_pat(pat.span, expected, local_ty, discrim_span);\n                     }\n                 }\n \n-                // if there are multiple arms, make sure they all agree on\n-                // what the type of the binding `x` ought to be\n+                // If there are multiple arms, make sure they all agree on\n+                // what the type of the binding `x` ought to be.\n                 if var_id != pat.hir_id {\n                     let vt = self.local_ty(pat.span, var_id).decl_ty;\n                     self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n@@ -880,7 +880,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 // possibly incorrect trailing `;` in the else arm\n                 remove_semicolon = self.could_remove_semicolon(block, then_ty);\n                 stmt.span\n-            } else {  // empty block, point at its entirety\n+            } else { // empty block; point at its entirety\n                 // Avoid overlapping spans that aren't as readable:\n                 // ```\n                 // 2 |        let x = if true {\n@@ -917,19 +917,19 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             else_expr.span\n         };\n \n-        // Compute `Span` of `then` part of `if`-expression:\n+        // Compute `Span` of `then` part of `if`-expression.\n         let then_sp = if let ExprKind::Block(block, _) = &then_expr.node {\n             if let Some(expr) = &block.expr {\n                 expr.span\n             } else if let Some(stmt) = block.stmts.last() {\n                 // possibly incorrect trailing `;` in the else arm\n                 remove_semicolon = remove_semicolon.or(self.could_remove_semicolon(block, else_ty));\n                 stmt.span\n-            } else {  // empty block, point at its entirety\n-                outer_sp = None;  // same as in `error_sp`, cleanup output\n+            } else { // empty block; point at its entirety\n+                outer_sp = None;  // same as in `error_sp`; cleanup output\n                 then_expr.span\n             }\n-        } else {  // shouldn't happen unless the parser has done something weird\n+        } else { // shouldn't happen unless the parser has done something weird\n             then_expr.span\n         };\n "}, {"sha": "22f17097fcbe330d38386de37f317e5488e33398", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -4741,7 +4741,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Resolves associated value path into a base type and associated constant or method\n+    /// Resolves an associated value path into a base type and associated constant, or method\n     /// resolution. The newly resolved definition is written into `type_dependent_defs`.\n     pub fn resolve_ty_and_res_ufcs<'b>(&self,\n                                        qpath: &'b QPath,"}, {"sha": "54cd4035a7ba41d19fb59f1102d2b8e43625e6e1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -1181,7 +1181,7 @@ pub enum ExprKind {\n     Field(P<Expr>, Ident),\n     /// An indexing operation (e.g., `foo[2]`).\n     Index(P<Expr>, P<Expr>),\n-    /// A range (e.g., `1..2`, `1..`, `..2`, `1...2`, `1...`, `...2`).\n+    /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`).\n     Range(Option<P<Expr>>, Option<P<Expr>>, RangeLimits),\n \n     /// Variable reference, possibly containing `::` and/or type"}, {"sha": "ee640a1603a6ca688c54a648102efa6b7bee3d7a", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -120,19 +120,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n         }\n     });\n \n-    let span = span.apply_mark(ecx.current_expansion.mark);\n-\n-    let name = Ident::from_str_and_span(&format!(\"__register_diagnostic_{}\", code), span).gensym();\n-\n-    MacEager::items(smallvec![\n-        ecx.item_mod(\n-            span,\n-            span,\n-            name,\n-            vec![],\n-            vec![],\n-        )\n-    ])\n+    MacEager::items(smallvec![])\n }\n \n #[allow(deprecated)]"}, {"sha": "6b699464ba9a893f94ced6cc9436ba714015327e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -249,8 +249,9 @@ pub fn compile(\n     def: &ast::Item,\n     edition: Edition\n ) -> SyntaxExtension {\n-    let lhs_nm = ast::Ident::from_str(\"lhs\").gensym();\n-    let rhs_nm = ast::Ident::from_str(\"rhs\").gensym();\n+    let lhs_nm = ast::Ident::new(sym::lhs, def.span);\n+    let rhs_nm = ast::Ident::new(sym::rhs, def.span);\n+    let tt_spec = ast::Ident::new(sym::tt, def.span);\n \n     // Parse the macro_rules! invocation\n     let body = match def.node {\n@@ -266,9 +267,9 @@ pub fn compile(\n     let argument_gram = vec![\n         quoted::TokenTree::Sequence(DelimSpan::dummy(), Lrc::new(quoted::SequenceRepetition {\n             tts: vec![\n-                quoted::TokenTree::MetaVarDecl(def.span, lhs_nm, ast::Ident::from_str(\"tt\")),\n+                quoted::TokenTree::MetaVarDecl(def.span, lhs_nm, tt_spec),\n                 quoted::TokenTree::token(token::FatArrow, def.span),\n-                quoted::TokenTree::MetaVarDecl(def.span, rhs_nm, ast::Ident::from_str(\"tt\")),\n+                quoted::TokenTree::MetaVarDecl(def.span, rhs_nm, tt_spec),\n             ],\n             separator: Some(Token::new(\n                 if body.legacy { token::Semi } else { token::Comma }, def.span\n@@ -1115,10 +1116,9 @@ fn has_legal_fragment_specifier(sess: &ParseSess,\n                                 tok: &quoted::TokenTree) -> Result<(), String> {\n     debug!(\"has_legal_fragment_specifier({:?})\", tok);\n     if let quoted::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n-        let frag_name = frag_spec.as_str();\n         let frag_span = tok.span();\n-        if !is_legal_fragment_specifier(sess, features, attrs, &frag_name, frag_span) {\n-            return Err(frag_name.to_string());\n+        if !is_legal_fragment_specifier(sess, features, attrs, frag_spec.name, frag_span) {\n+            return Err(frag_spec.to_string());\n         }\n     }\n     Ok(())\n@@ -1127,7 +1127,7 @@ fn has_legal_fragment_specifier(sess: &ParseSess,\n fn is_legal_fragment_specifier(_sess: &ParseSess,\n                                _features: &Features,\n                                _attrs: &[ast::Attribute],\n-                               frag_name: &str,\n+                               frag_name: Symbol,\n                                _frag_span: Span) -> bool {\n     /*\n      * If new fragment specifiers are invented in nightly, `_sess`,\n@@ -1136,9 +1136,9 @@ fn is_legal_fragment_specifier(_sess: &ParseSess,\n      * this function.\n      */\n     match frag_name {\n-        \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" | \"lifetime\" |\n-        \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"vis\" | \"literal\" |\n-        \"\" => true,\n+        sym::item | sym::block | sym::stmt | sym::expr | sym::pat |\n+        sym::lifetime | sym::path | sym::ty | sym::ident | sym::meta | sym::tt |\n+        sym::vis | sym::literal | kw::Invalid => true,\n         _ => false,\n     }\n }"}, {"sha": "cbaf12529c101c3d4d9a4561dd9f87e15b3aedc6", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -327,7 +327,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     //        }\n     let sp = ignored_span(cx, DUMMY_SP);\n     let ecx = &cx.ext_cx;\n-    let test_id = ecx.ident_of(\"test\").gensym();\n+    let test_id = Ident::with_empty_ctxt(sym::test);\n \n     // test::test_main_static(...)\n     let mut test_runner = cx.test_runner.clone().unwrap_or(\n@@ -350,7 +350,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let test_extern_stmt = ecx.stmt_item(sp, ecx.item(sp,\n         test_id,\n         vec![],\n-        ast::ItemKind::ExternCrate(Some(sym::test))\n+        ast::ItemKind::ExternCrate(None)\n     ));\n \n     // pub fn main() { ... }"}, {"sha": "fcecee8c57fc92b855fb675457466eb25d412bb7", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -234,7 +234,7 @@ pub const PREC_RESET: i8 = -100;\n pub const PREC_CLOSURE: i8 = -40;\n pub const PREC_JUMP: i8 = -30;\n pub const PREC_RANGE: i8 = -10;\n-// The range 2 ... 14 is reserved for AssocOp binary operator precedences.\n+// The range 2..=14 is reserved for AssocOp binary operator precedences.\n pub const PREC_PREFIX: i8 = 50;\n pub const PREC_POSTFIX: i8 = 60;\n pub const PREC_PAREN: i8 = 99;"}, {"sha": "f121fe17a720f996da32e8fe0289c425dbf68d21", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -157,6 +157,7 @@ symbols! {\n         bin,\n         bind_by_move_pattern_guards,\n         block,\n+        bool,\n         borrowck_graphviz_postflow,\n         borrowck_graphviz_preflow,\n         box_patterns,\n@@ -171,6 +172,7 @@ symbols! {\n         cfg_target_has_atomic,\n         cfg_target_thread_local,\n         cfg_target_vendor,\n+        char,\n         clone,\n         Clone,\n         clone_closures,\n@@ -351,6 +353,7 @@ symbols! {\n         label_break_value,\n         lang,\n         lang_items,\n+        lhs,\n         lib,\n         lifetime,\n         link,\n@@ -511,6 +514,7 @@ symbols! {\n         result,\n         Result,\n         Return,\n+        rhs,\n         rlib,\n         rt,\n         rtm_target_feature,"}, {"sha": "604c14ee120a8eb7dd008b1a86eed9f7aed81fc7", "filename": "src/test/ui/const-generics/issue-61336-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -0,0 +1,16 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n+    [x; {N}]\n+}\n+\n+fn g<T, const N: usize>(x: T) -> [T; N] {\n+    [x; {N}]\n+    //~^ ERROR the trait bound `T: std::marker::Copy` is not satisfied [E0277]\n+}\n+\n+fn main() {\n+    let x: [u32; 5] = f::<u32, 5>(3);\n+    assert_eq!(x, [3u32; 5]);\n+}"}, {"sha": "a7135b62f8cffbdcae4cf1a313c813dddb77676d", "filename": "src/test/ui/const-generics/issue-61336-2.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-2.stderr?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -0,0 +1,18 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-61336-2.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-61336-2.rs:9:5\n+   |\n+LL |     [x; {N}]\n+   |     ^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |\n+   = help: consider adding a `where T: std::marker::Copy` bound\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "6c4d2a4a7ad41b9eba57a22236fa720dec3257c9", "filename": "src/test/ui/single-use-lifetime/one-use-in-struct.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb16e72954ec5a048dd46ffef23416662765b368/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb16e72954ec5a048dd46ffef23416662765b368/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fone-use-in-struct.rs?ref=bb16e72954ec5a048dd46ffef23416662765b368", "patch": "@@ -18,4 +18,11 @@ enum Bar<'f> {\n \n trait Baz<'f> { }\n \n+// `Derive`d impls shouldn't trigger a warning, either (Issue #53738).\n+\n+#[derive(Debug)]\n+struct Quux<'a> {\n+    priors: &'a u32,\n+}\n+\n fn main() { }"}]}