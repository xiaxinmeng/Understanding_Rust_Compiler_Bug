{"sha": "cce055daef93bfa50b11b1d3368811fe586d8a42", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZTA1NWRhZWY5M2JmYTUwYjExYjFkMzM2ODgxMWZlNTg2ZDhhNDI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-01-04T18:22:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-04T18:22:44Z"}, "message": "Rollup merge of #67137 - anp:tracked-panic-internals, r=eddyb\n\nlibstd uses `core::panic::Location` where possible.\n\ncc @eddyb", "tree": {"sha": "2adeeb04e178dd04953384d33a60f80ab58b6ef9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2adeeb04e178dd04953384d33a60f80ab58b6ef9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cce055daef93bfa50b11b1d3368811fe586d8a42", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeENf0CRBK7hj4Ov3rIwAAdHIIAGeWSXMN344w3q5aos8iqG4U\nlByEhEo2PwvyQYmUMuXGdl1qiQ7MUSQrB81kSVlyb9hayu91dXfxhwg7+vmleUmo\nuiNcRwP4zxlwhPCy04zW/qwzmAkoF+RC4WdC33gMx+sHxq5P/xz3OUOqS+6wG2DA\nj67FBarWlcYf7LFYosMjci9ip0k6UZZ5POqm2h4/y9BJuEGuM8y4bXHzSgy63Piq\nwBnVp6N0wdPg6y/jn692CC8KzgEOccodu8o4CZXRuoyuXLFkTkexJFudliJ91TKm\nQ3wiCDPFobTz50KLBh2Wf/1Pc06AxPz/XWWrusGvs3J4+bM+XamWS2BDmXTXYWA=\n=62ha\n-----END PGP SIGNATURE-----\n", "payload": "tree 2adeeb04e178dd04953384d33a60f80ab58b6ef9\nparent cd8377d37e9bc47f9a5a982c41705a7800cbb51d\nparent 27b25eb822d32911b73991c7fd6921fea609f825\nauthor Dylan DPC <dylan.dpc@gmail.com> 1578162164 +0530\ncommitter GitHub <noreply@github.com> 1578162164 +0530\n\nRollup merge of #67137 - anp:tracked-panic-internals, r=eddyb\n\nlibstd uses `core::panic::Location` where possible.\n\ncc @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cce055daef93bfa50b11b1d3368811fe586d8a42", "html_url": "https://github.com/rust-lang/rust/commit/cce055daef93bfa50b11b1d3368811fe586d8a42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cce055daef93bfa50b11b1d3368811fe586d8a42/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd8377d37e9bc47f9a5a982c41705a7800cbb51d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd8377d37e9bc47f9a5a982c41705a7800cbb51d", "html_url": "https://github.com/rust-lang/rust/commit/cd8377d37e9bc47f9a5a982c41705a7800cbb51d"}, {"sha": "27b25eb822d32911b73991c7fd6921fea609f825", "url": "https://api.github.com/repos/rust-lang/rust/commits/27b25eb822d32911b73991c7fd6921fea609f825", "html_url": "https://github.com/rust-lang/rust/commit/27b25eb822d32911b73991c7fd6921fea609f825"}], "stats": {"total": 184, "additions": 90, "deletions": 94}, "files": [{"sha": "0eb9e19423617b789ff2d27f914a6bb1b391431d", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -1,27 +1,21 @@\n #[doc(include = \"panic.md\")]\n #[macro_export]\n-#[allow_internal_unstable(core_panic,\n-    // FIXME(anp, eddyb) `core_intrinsics` is used here to allow calling\n-    // the `caller_location` intrinsic, but once  `#[track_caller]` is implemented,\n-    // `panicking::{panic, panic_fmt}` can use that instead of a `Location` argument.\n-    core_intrinsics,\n-    const_caller_location,\n-)]\n+#[allow_internal_unstable(core_panic, track_caller)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n         $crate::panic!(\"explicit panic\")\n     );\n     ($msg:expr) => (\n-        $crate::panicking::panic($msg, $crate::intrinsics::caller_location())\n+        $crate::panicking::panic($msg)\n     );\n     ($msg:expr,) => (\n         $crate::panic!($msg)\n     );\n     ($fmt:expr, $($arg:tt)+) => (\n         $crate::panicking::panic_fmt(\n             $crate::format_args!($fmt, $($arg)+),\n-            $crate::intrinsics::caller_location(),\n+            $crate::panic::Location::caller(),\n         )\n     );\n }"}, {"sha": "61b764f2d6206ad7773ede553601ea130ce968d1", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -36,8 +36,9 @@ use crate::panic::{Location, PanicInfo};\n // never inline unless panic_immediate_abort to avoid code\n // bloat at the call sites as much as possible\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[track_caller]\n #[lang = \"panic\"] // needed by codegen for panic on overflow and other `Assert` MIR terminators\n-pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n+pub fn panic(expr: &str) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { super::intrinsics::abort() }\n     }\n@@ -48,7 +49,7 @@ pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n     // truncation and padding (even though none is used here). Using\n     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n     // output binary, saving up to a few kilobytes.\n-    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), location)\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), Location::caller())\n }\n \n #[cold]"}, {"sha": "11f94ab2e627980b0445e92a50967bc442e46b68", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::{self, AttrVec, BlockCheckMode, Expr, Ident, PatKind, UnOp};\n use syntax::attr;\n use syntax::ptr::P;\n \n-use rustc_span::{Pos, Span};\n+use rustc_span::Span;\n \n impl<'a> ExtCtxt<'a> {\n     pub fn path(&self, span: Span, strs: Vec<ast::Ident>) -> ast::Path {\n@@ -350,16 +350,10 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n-        let loc = self.source_map().lookup_char_pos(span.lo());\n-        let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name.to_string()));\n-        let expr_line = self.expr_u32(span, loc.line as u32);\n-        let expr_col = self.expr_u32(span, loc.col.to_usize() as u32 + 1);\n-        let expr_loc_tuple = self.expr_tuple(span, vec![expr_file, expr_line, expr_col]);\n-        let expr_loc_ptr = self.expr_addr_of(span, expr_loc_tuple);\n         self.expr_call_global(\n             span,\n             [sym::std, sym::rt, sym::begin_panic].iter().map(|s| Ident::new(*s, span)).collect(),\n-            vec![self.expr_str(span, msg), expr_loc_ptr],\n+            vec![self.expr_str(span, msg)],\n         )\n     }\n "}, {"sha": "b39a61c5e0dd115c0df9b6ba4e4a63e0e6709e7c", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -177,6 +177,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n@@ -199,7 +200,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 // Some functions we support even if they are non-const -- but avoid testing\n                 // that for const fn!  We certainly do *not* want to actually call the fn\n                 // though, so be sure we return here.\n-                return if ecx.hook_panic_fn(instance, args, ret)? {\n+                return if ecx.hook_panic_fn(span, instance, args)? {\n                     Ok(None)\n                 } else {\n                     throw_unsup_format!(\"calling non-const function `{}`\", instance)"}, {"sha": "b075e8ea383e1511889d1dba3c85d22f89b70901", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -366,47 +366,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `true` if an intercept happened.\n     pub fn hook_panic_fn(\n         &mut self,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        _ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx, bool> {\n         let def_id = instance.def_id();\n-        if Some(def_id) == self.tcx.lang_items().panic_fn() {\n-            // &'static str, &core::panic::Location { &'static str, u32, u32 }\n-            assert!(args.len() == 2);\n+        if Some(def_id) == self.tcx.lang_items().panic_fn()\n+            || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+        {\n+            // &'static str\n+            assert!(args.len() == 1);\n \n             let msg_place = self.deref_operand(args[0])?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n-\n-            let location = self.deref_operand(args[1])?;\n-            let (file, line, col) = (\n-                self.mplace_field(location, 0)?,\n-                self.mplace_field(location, 1)?,\n-                self.mplace_field(location, 2)?,\n-            );\n-\n-            let file_place = self.deref_operand(file.into())?;\n-            let file = Symbol::intern(self.read_str(file_place)?);\n-            let line = self.read_scalar(line.into())?.to_u32()?;\n-            let col = self.read_scalar(col.into())?.to_u32()?;\n-            throw_panic!(Panic { msg, file, line, col })\n-        } else if Some(def_id) == self.tcx.lang_items().begin_panic_fn() {\n-            assert!(args.len() == 2);\n-            // &'static str, &(&'static str, u32, u32)\n-            let msg = args[0];\n-            let place = self.deref_operand(args[1])?;\n-            let (file, line, col) = (\n-                self.mplace_field(place, 0)?,\n-                self.mplace_field(place, 1)?,\n-                self.mplace_field(place, 2)?,\n-            );\n-\n-            let msg_place = self.deref_operand(msg.into())?;\n-            let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let file_place = self.deref_operand(file.into())?;\n-            let file = Symbol::intern(self.read_str(file_place)?);\n-            let line = self.read_scalar(line.into())?.to_u32()?;\n-            let col = self.read_scalar(col.into())?.to_u32()?;\n+            let span = self.find_closest_untracked_caller_location().unwrap_or(span);\n+            let (file, line, col) = self.location_triple_for_span(span);\n             throw_panic!(Panic { msg, file, line, col })\n         } else {\n             return Ok(false);"}, {"sha": "0525108d2d129a928dee79aa1bdd7ef06c49ba9e", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -9,8 +9,9 @@ use crate::interpret::{\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    /// Walks up the callstack from the intrinsic's callsite, searching for the first frame which is\n-    /// not `#[track_caller]`.\n+    /// Walks up the callstack from the intrinsic's callsite, searching for the first callsite in a\n+    /// frame which is not `#[track_caller]`. If the first frame found lacks `#[track_caller]`, then\n+    /// `None` is returned and the callsite of the function invocation itself should be used.\n     crate fn find_closest_untracked_caller_location(&self) -> Option<Span> {\n         let mut caller_span = None;\n         for next_caller in self.stack.iter().rev() {\n@@ -54,9 +55,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     pub fn alloc_caller_location_for_span(&mut self, span: Span) -> MPlaceTy<'tcx, M::PointerTag> {\n+        let (file, line, column) = self.location_triple_for_span(span);\n+        self.alloc_caller_location(file, line, column)\n+    }\n+\n+    pub(super) fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n-        self.alloc_caller_location(\n+        (\n             Symbol::intern(&caller.file.name.to_string()),\n             caller.line as u32,\n             caller.col_display as u32 + 1,"}, {"sha": "3dc572d256d8ed661b2de81c08274e566914528d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -139,6 +139,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// was used.\n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,"}, {"sha": "032062d636040f9aa4c41b7221d915cd7a79f96d", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -238,7 +238,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | ty::InstanceDef::CloneShim(..)\n             | ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n-                let body = match M::find_mir_or_eval_fn(self, instance, args, ret, unwind)? {\n+                let body = match M::find_mir_or_eval_fn(self, span, instance, args, ret, unwind)? {\n                     Some(body) => body,\n                     None => return Ok(()),\n                 };"}, {"sha": "31c3a2c7ebceb63099246c6b0b9d67addd1fcc73", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -125,6 +125,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n \n     fn find_mir_or_eval_fn(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _span: Span,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n         _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,"}, {"sha": "f90647472c6787ee401474fa63ef7de2ebe98251", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -305,6 +305,7 @@\n #![feature(thread_local)]\n #![feature(toowned_clone_into)]\n #![feature(trace_macros)]\n+#![feature(track_caller)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(untagged_unions)]"}, {"sha": "18fb0f87688dea28d9e3ee577a5f5413b739306d", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -4,6 +4,7 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n+#[cfg(bootstrap)]\n #[doc(include = \"../libcore/macros/panic.md\")]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -19,8 +20,21 @@ macro_rules! panic {\n         $crate::panic!($msg)\n     });\n     ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+),\n-                                    &($crate::file!(), $crate::line!(), $crate::column!()))\n+        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+))\n+    });\n+}\n+\n+#[cfg(not(bootstrap))]\n+#[doc(include = \"../libcore/macros/panic.md\")]\n+#[macro_export]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow_internal_unstable(libstd_sys_internals)]\n+macro_rules! panic {\n+    () => ({ $crate::panic!(\"explicit panic\") });\n+    ($msg:expr) => ({ $crate::rt::begin_panic($msg) });\n+    ($msg:expr,) => ({ $crate::panic!($msg) });\n+    ($fmt:expr, $($arg:tt)+) => ({\n+        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+))\n     });\n }\n "}, {"sha": "599ccc809be1fc494379e5a059b7c555c2dac416", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -313,17 +313,15 @@ pub fn panicking() -> bool {\n #[cold]\n // If panic_immediate_abort, inline the abort call,\n // otherwise avoid inlining because of it is cold path.\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), track_caller)]\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-pub fn begin_panic_fmt(msg: &fmt::Arguments<'_>, file_line_col: &(&'static str, u32, u32)) -> ! {\n+pub fn begin_panic_fmt(msg: &fmt::Arguments<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { intrinsics::abort() }\n     }\n \n-    // Just package everything into a `PanicInfo` and continue like libcore panics.\n-    let (file, line, col) = *file_line_col;\n-    let location = Location::internal_constructor(file, line, col);\n-    let info = PanicInfo::internal_constructor(Some(msg), &location);\n+    let info = PanicInfo::internal_constructor(Some(msg), Location::caller());\n     begin_panic_handler(&info)\n }\n \n@@ -356,6 +354,9 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n \n     unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n         fn take_box(&mut self) -> *mut (dyn Any + Send) {\n+            // We do two allocations here, unfortunately. But (a) they're required with the current\n+            // scheme, and (b) we don't handle panic + OOM properly anyway (see comment in\n+            // begin_panic below).\n             let contents = mem::take(self.fill());\n             Box::into_raw(Box::new(contents))\n         }\n@@ -365,15 +366,9 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n         }\n     }\n \n-    // We do two allocations here, unfortunately. But (a) they're\n-    // required with the current scheme, and (b) we don't handle\n-    // panic + OOM properly anyway (see comment in begin_panic\n-    // below).\n-\n     let loc = info.location().unwrap(); // The current implementation always returns Some\n     let msg = info.message().unwrap(); // The current implementation always returns Some\n-    let file_line_col = (loc.file(), loc.line(), loc.column());\n-    rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), &file_line_col);\n+    rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), loc);\n }\n \n /// This is the entry point of panicking for the non-format-string variants of\n@@ -386,19 +381,13 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n // bloat at the call sites as much as possible\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[cold]\n-pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u32)) -> ! {\n+#[track_caller]\n+pub fn begin_panic<M: Any + Send>(msg: M, #[cfg(bootstrap)] _: &(&str, u32, u32)) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { intrinsics::abort() }\n     }\n \n-    // Note that this should be the only allocation performed in this code path.\n-    // Currently this means that panic!() on OOM will invoke this code path,\n-    // but then again we're not really ready for panic on OOM anyway. If\n-    // we do start doing this, then we should propagate this allocation to\n-    // be performed in the parent of this thread instead of the thread that's\n-    // panicking.\n-\n-    rust_panic_with_hook(&mut PanicPayload::new(msg), None, file_line_col);\n+    rust_panic_with_hook(&mut PanicPayload::new(msg), None, Location::caller());\n \n     struct PanicPayload<A> {\n         inner: Option<A>,\n@@ -412,6 +401,11 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u3\n \n     unsafe impl<A: Send + 'static> BoxMeUp for PanicPayload<A> {\n         fn take_box(&mut self) -> *mut (dyn Any + Send) {\n+            // Note that this should be the only allocation performed in this code path. Currently\n+            // this means that panic!() on OOM will invoke this code path, but then again we're not\n+            // really ready for panic on OOM anyway. If we do start doing this, then we should\n+            // propagate this allocation to be performed in the parent of this thread instead of the\n+            // thread that's panicking.\n             let data = match self.inner.take() {\n                 Some(a) => Box::new(a) as Box<dyn Any + Send>,\n                 None => process::abort(),\n@@ -436,10 +430,8 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u3\n fn rust_panic_with_hook(\n     payload: &mut dyn BoxMeUp,\n     message: Option<&fmt::Arguments<'_>>,\n-    file_line_col: &(&str, u32, u32),\n+    location: &Location<'_>,\n ) -> ! {\n-    let (file, line, col) = *file_line_col;\n-\n     let panics = update_panic_count(1);\n \n     // If this is the third nested call (e.g., panics == 2, this is 0-indexed),\n@@ -456,8 +448,7 @@ fn rust_panic_with_hook(\n     }\n \n     unsafe {\n-        let location = Location::internal_constructor(file, line, col);\n-        let mut info = PanicInfo::internal_constructor(message, &location);\n+        let mut info = PanicInfo::internal_constructor(message, location);\n         HOOK_LOCK.read();\n         match HOOK {\n             // Some platforms (like wasm) know that printing to stderr won't ever actually"}, {"sha": "8e9bae8569f196e04cabf92d7c361352e0302193", "filename": "src/test/mir-opt/retain-never-const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Ftest%2Fmir-opt%2Fretain-never-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Ftest%2Fmir-opt%2Fretain-never-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretain-never-const.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -6,6 +6,7 @@\n \n #![feature(const_panic)]\n #![feature(never_type)]\n+#![warn(const_err)]\n \n struct PrintName<T>(T);\n "}, {"sha": "74c6e501c9136289665bdecc706e88ddec372bf0", "filename": "src/test/ui/extern/issue-64655-allow-unwind-when-calling-panic-directly.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -22,7 +22,7 @@\n //[thin]compile-flags: -C lto=thin\n //[fat]compile-flags: -C lto=fat\n \n-#![feature(core_panic, panic_internals)]\n+#![feature(core_panic)]\n \n // (For some reason, reproducing the LTO issue requires pulling in std\n // explicitly this way.)\n@@ -50,9 +50,7 @@ fn main() {\n         }\n \n         let _guard = Droppable;\n-        let s = \"issue-64655-allow-unwind-when-calling-panic-directly.rs\";\n-        let location = core::panic::Location::internal_constructor(s, 17, 4);\n-        core::panicking::panic(\"???\", &location);\n+        core::panicking::panic(\"???\");\n     });\n \n     let wait = handle.join();"}, {"sha": "090e912c1d0ba9fa2ba5342dd163cf7c02e7a87c", "filename": "src/test/ui/rfc-2091-track-caller/caller-location-intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -4,16 +4,16 @@\n \n #[inline(never)]\n #[track_caller]\n-fn defeat_const_prop() -> &'static core::panic::Location<'static> {\n+fn codegen_caller_loc() -> &'static core::panic::Location<'static> {\n     core::panic::Location::caller()\n }\n \n macro_rules! caller_location_from_macro {\n-    () => (defeat_const_prop());\n+    () => (codegen_caller_loc());\n }\n \n fn main() {\n-    let loc = defeat_const_prop();\n+    let loc = codegen_caller_loc();\n     assert_eq!(loc.file(), file!());\n     assert_eq!(loc.line(), 16);\n     assert_eq!(loc.column(), 15);"}, {"sha": "1fb75ef35ffc1b6208e2b7577c8eb6577ab56240", "filename": "src/test/ui/rfc-2091-track-caller/diverging-caller-location.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fdiverging-caller-location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fdiverging-caller-location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fdiverging-caller-location.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -0,0 +1,19 @@\n+// run-fail\n+\n+//! This test ensures that `#[track_caller]` can be applied directly to diverging functions, as\n+//! the tracking issue says: https://github.com/rust-lang/rust/issues/47809#issue-292138490.\n+//! Because the annotated function must diverge and a panic keeps that faster than an infinite loop,\n+//! we don't inspect the location returned -- it would be difficult to distinguish between the\n+//! explicit panic and a failed assertion. That it compiles and runs is enough for this one.\n+\n+#![feature(track_caller)]\n+\n+#[track_caller]\n+fn doesnt_return() -> ! {\n+    let _location = core::panic::Location::caller();\n+    panic!(\"huzzah\");\n+}\n+\n+fn main() {\n+    doesnt_return();\n+}"}, {"sha": "76a380ed3e30d21399fd7cf4eb05e23eb7f4a9e3", "filename": "src/test/ui/rfc-2091-track-caller/track-caller-attribute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce055daef93bfa50b11b1d3368811fe586d8a42/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs?ref=cce055daef93bfa50b11b1d3368811fe586d8a42", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n \n-#![feature(const_fn, track_caller)]\n+#![feature(track_caller)]\n \n use std::panic::Location;\n "}]}