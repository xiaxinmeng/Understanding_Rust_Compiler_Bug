{"sha": "9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe", "node_id": "C_kwDOAAsO6NoAKDlmYmJlNzVmZDczZWQzYzIwMmNlYzNiMGJhNTFlYWRmNTA2ZjAzZmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-14T03:12:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-14T03:12:53Z"}, "message": "Auto merge of #95602 - scottmcm:faster-array-intoiter-fold, r=the8472\n\nFix `array::IntoIter::fold` to use the optimized `Range::fold`\n\nIt was using `Iterator::by_ref` in the implementation, which ended up pessimizing it enough that, for example, it didn't vectorize when we tried it in the <https://rust-lang.zulipchat.com/#narrow/stream/257879-project-portable-simd/topic/Reducing.20sum.20into.20wider.20types> conversation.\n\nDemonstration that the codegen test doesn't pass on the current nightly: <https://rust.godbolt.org/z/Taxev5eMn>", "tree": {"sha": "370bb66caa2dcab24871a888d08ecfe70fdfe8d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/370bb66caa2dcab24871a888d08ecfe70fdfe8d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe", "html_url": "https://github.com/rust-lang/rust/commit/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f721e64014863f41c1a386b04af04c2de25321", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f721e64014863f41c1a386b04af04c2de25321", "html_url": "https://github.com/rust-lang/rust/commit/f1f721e64014863f41c1a386b04af04c2de25321"}, {"sha": "e8fc7ba6a756628b3226e002e3f3e54ddf14fa04", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8fc7ba6a756628b3226e002e3f3e54ddf14fa04", "html_url": "https://github.com/rust-lang/rust/commit/e8fc7ba6a756628b3226e002e3f3e54ddf14fa04"}], "stats": {"total": 142, "additions": 141, "deletions": 1}, "files": [{"sha": "f4885ed9ffbb67c676e8550574702483666664cd", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe", "patch": "@@ -266,7 +266,7 @@ impl<T, const N: usize> Iterator for IntoIter<T, N> {\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let data = &mut self.data;\n-        self.alive.by_ref().fold(init, |acc, idx| {\n+        iter::ByRefSized(&mut self.alive).fold(init, |acc, idx| {\n             // SAFETY: idx is obtained by folding over the `alive` range, which implies the\n             // value is currently considered alive but as the range is being consumed each value\n             // we read here will only be read once and then considered dead.\n@@ -323,6 +323,20 @@ impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N> {\n         })\n     }\n \n+    #[inline]\n+    fn rfold<Acc, Fold>(mut self, init: Acc, mut rfold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let data = &mut self.data;\n+        iter::ByRefSized(&mut self.alive).rfold(init, |acc, idx| {\n+            // SAFETY: idx is obtained by folding over the `alive` range, which implies the\n+            // value is currently considered alive but as the range is being consumed each value\n+            // we read here will only be read once and then considered dead.\n+            rfold(acc, unsafe { data.get_unchecked(idx).assume_init_read() })\n+        })\n+    }\n+\n     fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n         let len = self.len();\n "}, {"sha": "bf2e3e182e2a3234c3417cadb477be7d862e92a8", "filename": "library/core/src/iter/adapters/by_ref_sized.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs?ref=9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe", "patch": "@@ -9,29 +9,35 @@ pub(crate) struct ByRefSized<'a, I>(pub &'a mut I);\n impl<I: Iterator> Iterator for ByRefSized<'_, I> {\n     type Item = I::Item;\n \n+    #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n         self.0.next()\n     }\n \n+    #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.0.size_hint()\n     }\n \n+    #[inline]\n     fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n         self.0.advance_by(n)\n     }\n \n+    #[inline]\n     fn nth(&mut self, n: usize) -> Option<Self::Item> {\n         self.0.nth(n)\n     }\n \n+    #[inline]\n     fn fold<B, F>(self, init: B, f: F) -> B\n     where\n         F: FnMut(B, Self::Item) -> B,\n     {\n         self.0.fold(init, f)\n     }\n \n+    #[inline]\n     fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n     where\n         F: FnMut(B, Self::Item) -> R,\n@@ -40,3 +46,37 @@ impl<I: Iterator> Iterator for ByRefSized<'_, I> {\n         self.0.try_fold(init, f)\n     }\n }\n+\n+impl<I: DoubleEndedIterator> DoubleEndedIterator for ByRefSized<'_, I> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.0.next_back()\n+    }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.0.advance_back_by(n)\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.0.nth_back(n)\n+    }\n+\n+    #[inline]\n+    fn rfold<B, F>(self, init: B, f: F) -> B\n+    where\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        self.0.rfold(init, f)\n+    }\n+\n+    #[inline]\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        self.0.try_rfold(init, f)\n+    }\n+}"}, {"sha": "ee7ff012ec1c12e4ab64aeb3f76f3a34f72dc470", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe", "patch": "@@ -668,3 +668,35 @@ fn array_mixed_equality_nans() {\n     assert!(!(mut3 == array3));\n     assert!(mut3 != array3);\n }\n+\n+#[test]\n+fn array_into_iter_fold() {\n+    // Strings to help MIRI catch if we double-free or something\n+    let a = [\"Aa\".to_string(), \"Bb\".to_string(), \"Cc\".to_string()];\n+    let mut s = \"s\".to_string();\n+    a.into_iter().for_each(|b| s += &b);\n+    assert_eq!(s, \"sAaBbCc\");\n+\n+    let a = [1, 2, 3, 4, 5, 6];\n+    let mut it = a.into_iter();\n+    it.advance_by(1).unwrap();\n+    it.advance_back_by(2).unwrap();\n+    let s = it.fold(10, |a, b| 10 * a + b);\n+    assert_eq!(s, 10234);\n+}\n+\n+#[test]\n+fn array_into_iter_rfold() {\n+    // Strings to help MIRI catch if we double-free or something\n+    let a = [\"Aa\".to_string(), \"Bb\".to_string(), \"Cc\".to_string()];\n+    let mut s = \"s\".to_string();\n+    a.into_iter().rev().for_each(|b| s += &b);\n+    assert_eq!(s, \"sCcBbAa\");\n+\n+    let a = [1, 2, 3, 4, 5, 6];\n+    let mut it = a.into_iter();\n+    it.advance_by(1).unwrap();\n+    it.advance_back_by(2).unwrap();\n+    let s = it.rfold(10, |a, b| 10 * a + b);\n+    assert_eq!(s, 10432);\n+}"}, {"sha": "fde9b0fcd8ac16d355568a8e48741e5979caa14c", "filename": "src/test/codegen/simd-wide-sum.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe/src%2Ftest%2Fcodegen%2Fsimd-wide-sum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe/src%2Ftest%2Fcodegen%2Fsimd-wide-sum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-wide-sum.rs?ref=9fbbe75fd73ed3c202cec3b0ba51eadf506f03fe", "patch": "@@ -0,0 +1,54 @@\n+// compile-flags: -C opt-level=3 --edition=2021\n+// only-x86_64\n+// ignore-debug: the debug assertions get in the way\n+\n+#![crate_type = \"lib\"]\n+#![feature(portable_simd)]\n+\n+use std::simd::Simd;\n+const N: usize = 8;\n+\n+#[no_mangle]\n+// CHECK-LABEL: @wider_reduce_simd\n+pub fn wider_reduce_simd(x: Simd<u8, N>) -> u16 {\n+    // CHECK: zext <8 x i8>\n+    // CHECK-SAME: to <8 x i16>\n+    // CHECK: call i16 @llvm.vector.reduce.add.v8i16(<8 x i16>\n+    let x: Simd<u16, N> = x.cast();\n+    x.reduce_sum()\n+}\n+\n+#[no_mangle]\n+// CHECK-LABEL: @wider_reduce_loop\n+pub fn wider_reduce_loop(x: Simd<u8, N>) -> u16 {\n+    // CHECK: zext <8 x i8>\n+    // CHECK-SAME: to <8 x i16>\n+    // CHECK: call i16 @llvm.vector.reduce.add.v8i16(<8 x i16>\n+    let mut sum = 0_u16;\n+    for i in 0..N {\n+        sum += u16::from(x[i]);\n+    }\n+    sum\n+}\n+\n+#[no_mangle]\n+// CHECK-LABEL: @wider_reduce_iter\n+pub fn wider_reduce_iter(x: Simd<u8, N>) -> u16 {\n+    // CHECK: zext <8 x i8>\n+    // CHECK-SAME: to <8 x i16>\n+    // CHECK: call i16 @llvm.vector.reduce.add.v8i16(<8 x i16>\n+    x.as_array().iter().copied().map(u16::from).sum()\n+}\n+\n+// This iterator one is the most interesting, as it's the one\n+// which used to not auto-vectorize due to a suboptimality in the\n+// `<array::IntoIter as Iterator>::fold` implementation.\n+\n+#[no_mangle]\n+// CHECK-LABEL: @wider_reduce_into_iter\n+pub fn wider_reduce_into_iter(x: Simd<u8, N>) -> u16 {\n+    // CHECK: zext <8 x i8>\n+    // CHECK-SAME: to <8 x i16>\n+    // CHECK: call i16 @llvm.vector.reduce.add.v8i16(<8 x i16>\n+    x.to_array().into_iter().map(u16::from).sum()\n+}"}]}