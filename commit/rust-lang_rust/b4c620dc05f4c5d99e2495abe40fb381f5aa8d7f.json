{"sha": "b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YzYyMGRjMDVmNGM1ZDk5ZTI0OTVhYmU0MGZiMzgxZjVhYThkN2Y=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-04T07:21:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-04T07:21:23Z"}, "message": "Rollup merge of #60449 - matthewjasper:impl-trait-outlives, r=pnkfelix\n\nConstrain all regions in the concrete type for an opaque type\n\n`push_outlives_components` skips some regions in a type, notably the signature\nof a closure is ignored. Most of the time this is OK, but for opaque types the\nconcrete type is used when checking auto-trait bounds in other functions.\n\ncc @nikomatsakis @pnkfelix\n\nCloses #57464\nCloses #60127", "tree": {"sha": "fec00f35c423557faf445951069f88b1526fc463", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fec00f35c423557faf445951069f88b1526fc463"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJczT1zCRBK7hj4Ov3rIwAAdHIIAFr7ykY7A7jq8Sl83V4F9tCk\nEhV+dCQ9TbvtAh7RkmGxxOAexf6TS99OOTdHgUjuivbSq/ys4CY12XBo3ayYOI6M\nedMxVC1d3HdbSVNM5Oi3ojg5txtHTkxMTvkYgdhZFy2fuQaamxS8Dg4onLWI2TgJ\nt+fAcXfKct57Vhcuzewf5KZnUyq0D6dUe/qaKhyQBU3EJrgjyUmiUhd/vztdBMrW\nKPvkFm/Y2v/I+DZsRXMJNp5Z50R5OLWTCmh741ttEl+hXueF43m7lru2IEDBt5Ye\nIcJSgo59ySHNTIyb6cozHuF8auwJM1ZoazgdkvStMv6qNmfxBj/JxJ6ceKRUis0=\n=zBO6\n-----END PGP SIGNATURE-----\n", "payload": "tree fec00f35c423557faf445951069f88b1526fc463\nparent 6a86be9fca0b46ad098717fad7f75319e9708c5c\nparent d72f4de659341c281021ddd42c15705a63370bda\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556954483 +0200\ncommitter GitHub <noreply@github.com> 1556954483 +0200\n\nRollup merge of #60449 - matthewjasper:impl-trait-outlives, r=pnkfelix\n\nConstrain all regions in the concrete type for an opaque type\n\n`push_outlives_components` skips some regions in a type, notably the signature\nof a closure is ignored. Most of the time this is OK, but for opaque types the\nconcrete type is used when checking auto-trait bounds in other functions.\n\ncc @nikomatsakis @pnkfelix\n\nCloses #57464\nCloses #60127\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f", "html_url": "https://github.com/rust-lang/rust/commit/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a86be9fca0b46ad098717fad7f75319e9708c5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a86be9fca0b46ad098717fad7f75319e9708c5c", "html_url": "https://github.com/rust-lang/rust/commit/6a86be9fca0b46ad098717fad7f75319e9708c5c"}, {"sha": "d72f4de659341c281021ddd42c15705a63370bda", "url": "https://api.github.com/repos/rust-lang/rust/commits/d72f4de659341c281021ddd42c15705a63370bda", "html_url": "https://github.com/rust-lang/rust/commit/d72f4de659341c281021ddd42c15705a63370bda"}], "stats": {"total": 201, "additions": 129, "deletions": 72}, "files": [{"sha": "f85fd524a5d9bd7f35eafaaccb4d42d0fd62b717", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 84, "deletions": 57, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f", "patch": "@@ -1,13 +1,14 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use syntax_pos::Span;\n+\n use crate::hir::def_id::DefId;\n use crate::hir;\n use crate::hir::Node;\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n-use rustc_data_structures::fx::FxHashMap;\n use crate::traits::{self, PredicateObligation};\n use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n-use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n-use crate::ty::outlives::Component;\n+use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, UnpackedKind};\n use crate::util::nodemap::DefIdMap;\n \n@@ -373,58 +374,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let least_region = least_region.unwrap_or(self.tcx.lifetimes.re_static);\n         debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n \n-        // Require that the type `concrete_ty` outlives\n-        // `least_region`, modulo any type parameters that appear\n-        // in the type, which we ignore. This is because impl\n-        // trait values are assumed to capture all the in-scope\n-        // type parameters. This little loop here just invokes\n-        // `outlives` repeatedly, draining all the nested\n-        // obligations that result.\n-        let mut types = vec![concrete_ty];\n-        let bound_region = |r| self.sub_regions(infer::CallReturn(span), least_region, r);\n-        while let Some(ty) = types.pop() {\n-            let mut components = smallvec![];\n-            self.tcx.push_outlives_components(ty, &mut components);\n-            while let Some(component) = components.pop() {\n-                match component {\n-                    Component::Region(r) => {\n-                        bound_region(r);\n-                    }\n-\n-                    Component::Param(_) => {\n-                        // ignore type parameters like `T`, they are captured\n-                        // implicitly by the `impl Trait`\n-                    }\n-\n-                    Component::UnresolvedInferenceVariable(_) => {\n-                        // we should get an error that more type\n-                        // annotations are needed in this case\n-                        self.tcx\n-                            .sess\n-                            .delay_span_bug(span, \"unresolved inf var in opaque\");\n-                    }\n-\n-                    Component::Projection(ty::ProjectionTy {\n-                        substs,\n-                        item_def_id: _,\n-                    }) => {\n-                        for k in substs {\n-                            match k.unpack() {\n-                                UnpackedKind::Lifetime(lt) => bound_region(lt),\n-                                UnpackedKind::Type(ty) => types.push(ty),\n-                                UnpackedKind::Const(_) => {\n-                                    // Const parameters don't impose constraints.\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    Component::EscapingProjection(more_components) => {\n-                        components.extend(more_components);\n-                    }\n-                }\n-            }\n-        }\n+        concrete_ty.visit_with(&mut OpaqueTypeOutlivesVisitor {\n+            infcx: self,\n+            least_region,\n+            span,\n+        });\n     }\n \n     /// Given the fully resolved, instantiated type for an opaque\n@@ -502,6 +456,80 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+// Visitor that requires that (almost) all regions in the type visited outlive\n+// `least_region`. We cannot use `push_outlives_components` because regions in\n+// closure signatures are not included in their outlives components. We need to\n+// ensure all regions outlive the given bound so that we don't end up with,\n+// say, `ReScope` appearing in a return type and causing ICEs when other\n+// functions end up with region constraints involving regions from other\n+// functions.\n+//\n+// We also cannot use `for_each_free_region` because for closures it includes\n+// the regions parameters from the enclosing item.\n+//\n+// We ignore any type parameters because impl trait values are assumed to\n+// capture all the in-scope type parameters.\n+struct OpaqueTypeOutlivesVisitor<'a, 'gcx, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    least_region: ty::Region<'tcx>,\n+    span: Span,\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, '_, 'tcx>\n+{\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+        t.skip_binder().visit_with(self);\n+        false // keep visiting\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        match *r {\n+            // ignore bound regions, keep visiting\n+            ty::ReLateBound(_, _) => false,\n+            _ => {\n+                self.infcx.sub_regions(infer::CallReturn(self.span), self.least_region, r);\n+                false\n+            }\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        // We're only interested in types involving regions\n+        if !ty.flags.intersects(ty::TypeFlags::HAS_FREE_REGIONS) {\n+            return false; // keep visiting\n+        }\n+\n+        match ty.sty {\n+            ty::Closure(def_id, ref substs) => {\n+                // Skip lifetime parameters of the enclosing item(s)\n+\n+                for upvar_ty in substs.upvar_tys(def_id, self.infcx.tcx) {\n+                    upvar_ty.visit_with(self);\n+                }\n+\n+                substs.closure_sig_ty(def_id, self.infcx.tcx).visit_with(self);\n+            }\n+\n+            ty::Generator(def_id, ref substs, _) => {\n+                // Skip lifetime parameters of the enclosing item(s)\n+                // Also skip the witness type, because that has no free regions.\n+\n+                for upvar_ty in substs.upvar_tys(def_id, self.infcx.tcx) {\n+                    upvar_ty.visit_with(self);\n+                }\n+\n+                substs.return_ty(def_id, self.infcx.tcx).visit_with(self);\n+                substs.yield_ty(def_id, self.infcx.tcx).visit_with(self);\n+            }\n+            _ => {\n+                ty.super_visit_with(self);\n+            }\n+        }\n+\n+        false\n+    }\n+}\n+\n struct ReverseMapper<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n \n@@ -563,8 +591,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n             // ignore `'static`, as that can appear anywhere\n             ty::ReStatic |\n \n-            // ignore `ReScope`, as that can appear anywhere\n-            // See `src/test/run-pass/issue-49556.rs` for example.\n+            // ignore `ReScope`, which may appear in impl Trait in bindings.\n             ty::ReScope(..) => return r,\n \n             _ => { }"}, {"sha": "a982b176ecda1c280353c5246c7b4005b1b0bffb", "filename": "src/test/ui/impl-trait/can-return-unconstrained-closure.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f/src%2Ftest%2Fui%2Fimpl-trait%2Fcan-return-unconstrained-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f/src%2Ftest%2Fui%2Fimpl-trait%2Fcan-return-unconstrained-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fcan-return-unconstrained-closure.rs?ref=b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f", "patch": "@@ -0,0 +1,19 @@\n+// Test that we are special casing \"outlives\" for opaque types.\n+//\n+// The return type of a closure is not required to outlive the closure. As such\n+// the following code would not compile if we used a standard outlives check\n+// when checking the return type, because the return type of the closure would\n+// be `&ReEmpty i32`, and we don't allow `ReEmpty` to occur in the concrete\n+// type used for an opaque type.\n+//\n+// However, opaque types are special cased to include check all regions in the\n+// concrete type against the bound, which forces the return type to be\n+// `&'static i32` here.\n+\n+// compile-pass\n+\n+fn make_identity() -> impl Sized {\n+    |x: &'static i32| x\n+}\n+\n+fn main() {}"}, {"sha": "50646edd61a8585f6de31b7dd87dc062839e21e1", "filename": "src/test/ui/impl-trait/issue-55608-captures-empty-region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.rs?ref=b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f", "patch": "@@ -1,9 +1,9 @@\n // This used to ICE because it creates an `impl Trait` that captures a\n // hidden empty region.\n \n-#![feature(conservative_impl_trait)]\n+// compile-pass\n \n-fn server() -> impl FilterBase2 { //~ ERROR [E0700]\n+fn server() -> impl FilterBase2 {\n     segment2(|| { loop { } }).map2(|| \"\")\n }\n "}, {"sha": "6311a7f00674f86c4383f7d551ac9bc03df0f376", "filename": "src/test/ui/impl-trait/issue-55608-captures-empty-region.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a86be9fca0b46ad098717fad7f75319e9708c5c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a86be9fca0b46ad098717fad7f75319e9708c5c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.stderr?ref=6a86be9fca0b46ad098717fad7f75319e9708c5c", "patch": "@@ -1,11 +0,0 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-55608-captures-empty-region.rs:6:16\n-   |\n-LL | fn server() -> impl FilterBase2 {\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = note: hidden type `Map2<[closure@$DIR/issue-55608-captures-empty-region.rs:7:36: 7:41]>` captures an empty lifetime\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "29e271c68ec9068562d430508509870a3728d8c6", "filename": "src/test/ui/impl-trait/issue-57464-unexpected-regions.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57464-unexpected-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57464-unexpected-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57464-unexpected-regions.rs?ref=b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f", "patch": "@@ -0,0 +1,22 @@\n+// Regression test for issue 57464.\n+//\n+// Closure are (surprisingly) allowed to outlive their signature. As such it\n+// was possible to end up with `ReScope`s appearing in the concrete type of an\n+// opaque type. As all regions are now required to outlive the bound in an\n+// opaque type we avoid the issue here.\n+\n+// compile-pass\n+\n+struct A<F>(F);\n+\n+unsafe impl <'a, 'b, F: Fn(&'a i32) -> &'b i32> Send for A<F> {}\n+\n+fn wrapped_closure() -> impl Sized {\n+    let f = |x| x;\n+    f(&0);\n+    A(f)\n+}\n+\n+fn main() {\n+    let x: Box<dyn Send> = Box::new(wrapped_closure());\n+}"}, {"sha": "46d9e749aae2398b2f681942265d457b34fcc508", "filename": "src/test/ui/issues/issue-49556.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f/src%2Ftest%2Fui%2Fissues%2Fissue-49556.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f/src%2Ftest%2Fui%2Fissues%2Fissue-49556.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49556.rs?ref=b4c620dc05f4c5d99e2495abe40fb381f5aa8d7f", "patch": "@@ -2,10 +2,10 @@\n fn iter<'a>(data: &'a [usize]) -> impl Iterator<Item = usize> + 'a {\n     data.iter()\n         .map(\n-            |x| x // fn(&'a usize) -> &'(ReScope) usize\n+            |x| x // fn(&'a usize) -> &'a usize\n         )\n         .map(\n-            |x| *x // fn(&'(ReScope) usize) -> usize\n+            |x| *x // fn(&'a usize) -> usize\n         )\n }\n "}]}