{"sha": "928435305ad1d778d7c4d2c2ff989c6a87be0223", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyODQzNTMwNWFkMWQ3NzhkN2M0ZDJjMmZmOTg5YzZhODdiZTAyMjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-23T02:21:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-23T02:21:06Z"}, "message": "Auto merge of #48052 - eddyb:deggregate, r=nikomatsakis\n\n rustc_mir: handle all aggregate kinds in, and always run, the deaggregator.\n\nThis helps with removing`Rvalue::Aggregate` from the MIR, and with enabling more optimizations.\nr? @nikomatsakis", "tree": {"sha": "dab0486605b6f0615fa49456d76edf9629f92497", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dab0486605b6f0615fa49456d76edf9629f92497"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/928435305ad1d778d7c4d2c2ff989c6a87be0223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/928435305ad1d778d7c4d2c2ff989c6a87be0223", "html_url": "https://github.com/rust-lang/rust/commit/928435305ad1d778d7c4d2c2ff989c6a87be0223", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/928435305ad1d778d7c4d2c2ff989c6a87be0223/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5de90898de7bea94b897f3cffd66aac9141d803f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5de90898de7bea94b897f3cffd66aac9141d803f", "html_url": "https://github.com/rust-lang/rust/commit/5de90898de7bea94b897f3cffd66aac9141d803f"}, {"sha": "c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a", "html_url": "https://github.com/rust-lang/rust/commit/c9fcedeb4c30ef9362453c93ee2dc6655c7ed31a"}], "stats": {"total": 311, "additions": 181, "deletions": 130}, "files": [{"sha": "8c76e0182dfbd7102fd05287beb211d34196d57b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -69,6 +69,7 @@\n #![feature(underscore_lifetimes)]\n #![feature(universal_impl_trait)]\n #![feature(trace_macros)]\n+#![feature(trusted_len)]\n #![feature(catch_expr)]\n #![feature(test)]\n "}, {"sha": "475946468fa35f6f9945ee9373ed16fd305d4109", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -34,13 +34,13 @@ use std::ascii;\n use std::borrow::{Cow};\n use std::cell::Ref;\n use std::fmt::{self, Debug, Formatter, Write};\n-use std::{iter, u32};\n+use std::{iter, mem, u32};\n use std::ops::{Index, IndexMut};\n use std::rc::Rc;\n use std::vec::IntoIter;\n use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n mod cache;\n pub mod tcx;\n@@ -984,11 +984,62 @@ impl<'tcx> BasicBlockData<'tcx> {\n     pub fn retain_statements<F>(&mut self, mut f: F) where F: FnMut(&mut Statement) -> bool {\n         for s in &mut self.statements {\n             if !f(s) {\n-                s.kind = StatementKind::Nop;\n+                s.make_nop();\n             }\n         }\n     }\n \n+    pub fn expand_statements<F, I>(&mut self, mut f: F)\n+        where F: FnMut(&mut Statement<'tcx>) -> Option<I>,\n+              I: iter::TrustedLen<Item = Statement<'tcx>>\n+    {\n+        // Gather all the iterators we'll need to splice in, and their positions.\n+        let mut splices: Vec<(usize, I)> = vec![];\n+        let mut extra_stmts = 0;\n+        for (i, s) in self.statements.iter_mut().enumerate() {\n+            if let Some(mut new_stmts) = f(s) {\n+                if let Some(first) = new_stmts.next() {\n+                    // We can already store the first new statement.\n+                    *s = first;\n+\n+                    // Save the other statements for optimized splicing.\n+                    let remaining = new_stmts.size_hint().0;\n+                    if remaining > 0 {\n+                        splices.push((i + 1 + extra_stmts, new_stmts));\n+                        extra_stmts += remaining;\n+                    }\n+                } else {\n+                    s.make_nop();\n+                }\n+            }\n+        }\n+\n+        // Splice in the new statements, from the end of the block.\n+        // FIXME(eddyb) This could be more efficient with a \"gap buffer\"\n+        // where a range of elements (\"gap\") is left uninitialized, with\n+        // splicing adding new elements to the end of that gap and moving\n+        // existing elements from before the gap to the end of the gap.\n+        // For now, this is safe code, emulating a gap but initializing it.\n+        let mut gap = self.statements.len()..self.statements.len()+extra_stmts;\n+        self.statements.resize(gap.end, Statement {\n+            source_info: SourceInfo {\n+                span: DUMMY_SP,\n+                scope: ARGUMENT_VISIBILITY_SCOPE\n+            },\n+            kind: StatementKind::Nop\n+        });\n+        for (splice_start, new_stmts) in splices.into_iter().rev() {\n+            let splice_end = splice_start + new_stmts.size_hint().0;\n+            while gap.end > splice_end {\n+                gap.start -= 1;\n+                gap.end -= 1;\n+                self.statements.swap(gap.start, gap.end);\n+            }\n+            self.statements.splice(splice_start..splice_end, new_stmts);\n+            gap.end = splice_start;\n+        }\n+    }\n+\n     pub fn visitable(&self, index: usize) -> &dyn MirVisitable<'tcx> {\n         if index < self.statements.len() {\n             &self.statements[index]\n@@ -1157,6 +1208,14 @@ impl<'tcx> Statement<'tcx> {\n     pub fn make_nop(&mut self) {\n         self.kind = StatementKind::Nop\n     }\n+\n+    /// Changes a statement to a nop and returns the original statement.\n+    pub fn replace_nop(&mut self) -> Self {\n+        Statement {\n+            source_info: self.source_info,\n+            kind: mem::replace(&mut self.kind, StatementKind::Nop)\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "503354ebc4ffd0e064c5f6926086cb8ffc880a7c", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 72, "deletions": 98, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -21,116 +21,90 @@ impl MirPass for Deaggregator {\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        let node_path = tcx.item_path_str(source.def_id);\n-        debug!(\"running on: {:?}\", node_path);\n-        // we only run when mir_opt_level > 2\n-        if tcx.sess.opts.debugging_opts.mir_opt_level <= 2 {\n-            return;\n-        }\n-\n         // Don't run on constant MIR, because trans might not be able to\n         // evaluate the modified MIR.\n         // FIXME(eddyb) Remove check after miri is merged.\n         let id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n         match (tcx.hir.body_owner_kind(id), source.promoted) {\n-            (hir::BodyOwnerKind::Fn, None) => {},\n-            _ => return\n-        }\n-        // In fact, we might not want to trigger in other cases.\n-        // Ex: when we could use SROA.  See issue #35259\n+            (_, Some(_)) |\n+            (hir::BodyOwnerKind::Const, _) |\n+            (hir::BodyOwnerKind::Static(_), _) => return,\n \n-        for bb in mir.basic_blocks_mut() {\n-            let mut curr: usize = 0;\n-            while let Some(idx) = get_aggregate_statement_index(curr, &bb.statements) {\n-                // do the replacement\n-                debug!(\"removing statement {:?}\", idx);\n-                let src_info = bb.statements[idx].source_info;\n-                let suffix_stmts = bb.statements.split_off(idx+1);\n-                let orig_stmt = bb.statements.pop().unwrap();\n-                let (lhs, rhs) = match orig_stmt.kind {\n-                    StatementKind::Assign(ref lhs, ref rhs) => (lhs, rhs),\n-                    _ => span_bug!(src_info.span, \"expected assign, not {:?}\", orig_stmt),\n-                };\n-                let (agg_kind, operands) = match rhs {\n-                    &Rvalue::Aggregate(ref agg_kind, ref operands) => (agg_kind, operands),\n-                    _ => span_bug!(src_info.span, \"expected aggregate, not {:?}\", rhs),\n-                };\n-                let (adt_def, variant, substs) = match **agg_kind {\n-                    AggregateKind::Adt(adt_def, variant, substs, None)\n-                        => (adt_def, variant, substs),\n-                    _ => span_bug!(src_info.span, \"expected struct, not {:?}\", rhs),\n-                };\n-                let n = bb.statements.len();\n-                bb.statements.reserve(n + operands.len() + suffix_stmts.len());\n-                for (i, op) in operands.iter().enumerate() {\n-                    let ref variant_def = adt_def.variants[variant];\n-                    let ty = variant_def.fields[i].ty(tcx, substs);\n-                    let rhs = Rvalue::Use(op.clone());\n+            (hir::BodyOwnerKind::Fn, _) => {\n+                if tcx.is_const_fn(source.def_id) {\n+                    // Don't run on const functions, as, again, trans might not be able to evaluate\n+                    // the optimized IR.\n+                    return\n+                }\n+            }\n+        }\n \n-                    let lhs_cast = if adt_def.is_enum() {\n-                        Place::Projection(Box::new(PlaceProjection {\n-                            base: lhs.clone(),\n-                            elem: ProjectionElem::Downcast(adt_def, variant),\n-                        }))\n+        let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n+        let local_decls = &*local_decls;\n+        for bb in basic_blocks {\n+            bb.expand_statements(|stmt| {\n+                // FIXME(eddyb) don't match twice on `stmt.kind` (post-NLL).\n+                if let StatementKind::Assign(_, ref rhs) = stmt.kind {\n+                    if let Rvalue::Aggregate(ref kind, _) = *rhs {\n+                        // FIXME(#48193) Deaggregate arrays when it's cheaper to do so.\n+                        if let AggregateKind::Array(_) = **kind {\n+                            return None;\n+                        }\n                     } else {\n-                        lhs.clone()\n-                    };\n-\n-                    let lhs_proj = Place::Projection(Box::new(PlaceProjection {\n-                        base: lhs_cast,\n-                        elem: ProjectionElem::Field(Field::new(i), ty),\n-                    }));\n-                    let new_statement = Statement {\n-                        source_info: src_info,\n-                        kind: StatementKind::Assign(lhs_proj, rhs),\n-                    };\n-                    debug!(\"inserting: {:?} @ {:?}\", new_statement, idx + i);\n-                    bb.statements.push(new_statement);\n+                        return None;\n+                    }\n+                } else {\n+                    return None;\n                 }\n \n-                // if the aggregate was an enum, we need to set the discriminant\n-                if adt_def.is_enum() {\n-                    let set_discriminant = Statement {\n-                        kind: StatementKind::SetDiscriminant {\n-                            place: lhs.clone(),\n-                            variant_index: variant,\n-                        },\n-                        source_info: src_info,\n-                    };\n-                    bb.statements.push(set_discriminant);\n+                let stmt = stmt.replace_nop();\n+                let source_info = stmt.source_info;\n+                let (mut lhs, kind, operands) = match stmt.kind {\n+                    StatementKind::Assign(lhs, Rvalue::Aggregate(kind, operands))\n+                        => (lhs, kind, operands),\n+                    _ => bug!()\n                 };\n \n-                curr = bb.statements.len();\n-                bb.statements.extend(suffix_stmts);\n-            }\n-        }\n-    }\n-}\n+                let mut set_discriminant = None;\n+                let active_field_index = match *kind {\n+                    AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n+                        if adt_def.is_enum() {\n+                            set_discriminant = Some(Statement {\n+                                kind: StatementKind::SetDiscriminant {\n+                                    place: lhs.clone(),\n+                                    variant_index,\n+                                },\n+                                source_info,\n+                            });\n+                            lhs = lhs.downcast(adt_def, variant_index);\n+                        }\n+                        active_field_index\n+                    }\n+                    _ => None\n+                };\n \n-fn get_aggregate_statement_index<'a, 'tcx, 'b>(start: usize,\n-                                         statements: &Vec<Statement<'tcx>>)\n-                                         -> Option<usize> {\n-    for i in start..statements.len() {\n-        let ref statement = statements[i];\n-        let rhs = match statement.kind {\n-            StatementKind::Assign(_, ref rhs) => rhs,\n-            _ => continue,\n-        };\n-        let (kind, operands) = match rhs {\n-            &Rvalue::Aggregate(ref kind, ref operands) => (kind, operands),\n-            _ => continue,\n-        };\n-        let (adt_def, variant) = match **kind {\n-            AggregateKind::Adt(adt_def, variant, _, None) => (adt_def, variant),\n-            _ => continue,\n-        };\n-        if operands.len() == 0 {\n-            // don't deaggregate ()\n-            continue;\n+                Some(operands.into_iter().enumerate().map(move |(i, op)| {\n+                    let lhs_field = if let AggregateKind::Array(_) = *kind {\n+                        // FIXME(eddyb) `offset` should be u64.\n+                        let offset = i as u32;\n+                        assert_eq!(offset as usize, i);\n+                        lhs.clone().elem(ProjectionElem::ConstantIndex {\n+                            offset,\n+                            // FIXME(eddyb) `min_length` doesn't appear to be used.\n+                            min_length: offset + 1,\n+                            from_end: false\n+                        })\n+                    } else {\n+                        let ty = op.ty(local_decls, tcx);\n+                        let field = Field::new(active_field_index.unwrap_or(i));\n+                        lhs.clone().field(field, ty)\n+                    };\n+                    Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(lhs_field, Rvalue::Use(op)),\n+                    }\n+                }).chain(set_discriminant))\n+            });\n         }\n-        debug!(\"getting variant {:?}\", variant);\n-        debug!(\"for adt_def {:?}\", adt_def);\n-        return Some(i);\n-    };\n-    None\n+    }\n }"}, {"sha": "b16c1436a1cbee682cb7e2cc131656318e239b8f", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -258,14 +258,18 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n \n         // Optimizations begin.\n         inline::Inline,\n+\n+        // Lowering generator control-flow and variables\n+        // has to happen before we do anything else to them.\n+        generator::StateTransform,\n+\n         instcombine::InstCombine,\n         deaggregator::Deaggregator,\n         copy_prop::CopyPropagation,\n         remove_noop_landing_pads::RemoveNoopLandingPads,\n         simplify::SimplifyCfg::new(\"final\"),\n         simplify::SimplifyLocals,\n \n-        generator::StateTransform,\n         add_call_guards::CriticalCallEdges,\n         dump_mir::Marker(\"PreTrans\"),\n     ];"}, {"sha": "2c6ed1f19b7fded5e96e3d3538d10bb0961598fb", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -42,6 +42,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, Visitor, PlaceContext};\n+use rustc::session::config::FullDebugInfo;\n use std::borrow::Cow;\n use transform::{MirPass, MirSource};\n \n@@ -281,16 +282,24 @@ pub struct SimplifyLocals;\n \n impl MirPass for SimplifyLocals {\n     fn run_pass<'a, 'tcx>(&self,\n-                          _: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource,\n                           mir: &mut Mir<'tcx>) {\n         let mut marker = DeclMarker { locals: BitVector::new(mir.local_decls.len()) };\n         marker.visit_mir(mir);\n         // Return pointer and arguments are always live\n-        marker.locals.insert(0);\n-        for idx in mir.args_iter() {\n-            marker.locals.insert(idx.index());\n+        marker.locals.insert(RETURN_PLACE.index());\n+        for arg in mir.args_iter() {\n+            marker.locals.insert(arg.index());\n         }\n+\n+        // We may need to keep dead user variables live for debuginfo.\n+        if tcx.sess.opts.debuginfo == FullDebugInfo {\n+            for local in mir.vars_iter() {\n+                marker.locals.insert(local.index());\n+            }\n+        }\n+\n         let map = make_local_map(&mut mir.local_decls, marker.locals);\n         // Update references to all vars and tmps now\n         LocalUpdater { map: map }.visit_mir(mir);"}, {"sha": "62aa93398ac42c4da050dcb68a3c3204525f4b75", "filename": "src/test/codegen/lifetime_start_end.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -28,14 +28,14 @@ pub fn test() {\n // CHECK: [[S_b:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"** %b to i8*\n // CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, i8* [[S_b]])\n \n-// CHECK: [[S__5:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"* %_5 to i8*\n-// CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, i8* [[S__5]])\n+// CHECK: [[S__4:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"* %_4 to i8*\n+// CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, i8* [[S__4]])\n \n // CHECK: [[E_b:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"** %b to i8*\n // CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, i8* [[E_b]])\n \n-// CHECK: [[E__5:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"* %_5 to i8*\n-// CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, i8* [[E__5]])\n+// CHECK: [[E__4:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"* %_4 to i8*\n+// CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, i8* [[E__4]])\n     }\n \n     let c = 1;"}, {"sha": "c9d0427dd0ad43b76243d0d61f77c2f89111d307", "filename": "src/test/codegen/match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fcodegen%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fcodegen%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch.rs?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -19,7 +19,7 @@ pub enum E {\n \n // CHECK-LABEL: @exhaustive_match\n #[no_mangle]\n-pub fn exhaustive_match(e: E) {\n+pub fn exhaustive_match(e: E, unit: ()) {\n // CHECK: switch{{.*}}, label %[[OTHERWISE:[a-zA-Z0-9_]+]] [\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[A:[a-zA-Z0-9_]+]]\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[B:[a-zA-Z0-9_]+]]\n@@ -31,7 +31,7 @@ pub fn exhaustive_match(e: E) {\n // CHECK: [[OTHERWISE]]:\n // CHECK-NEXT: unreachable\n     match e {\n-        E::A => (),\n-        E::B => (),\n+        E::A => unit,\n+        E::B => unit,\n     }\n }"}, {"sha": "73418f48860708e06c2113c82ae5266e4f60116b", "filename": "src/test/incremental/hashes/closure_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -64,7 +64,7 @@ pub fn change_parameter_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_parameter_pattern() {\n     let _ = |&x: &u32| x;"}, {"sha": "f890672aa8f587ad9932154851eb915350a1fef2", "filename": "src/test/incremental/issue-38222.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fincremental%2Fissue-38222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fincremental%2Fissue-38222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-38222.rs?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -18,7 +18,7 @@\n #![feature(rustc_attrs)]\n \n \n-#![rustc_partition_translated(module=\"issue_38222-mod1\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"issue_38222-mod1\", cfg=\"rpass2\")]\n \n // If trans had added a dependency edge to the Krate dep-node, nothing would\n // be re-used, so checking that this module was re-used is sufficient."}, {"sha": "feadec6bbf76e2667c1ed13be581cbddf3337e95", "filename": "src/test/mir-opt/copy_propagation_arg.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -78,7 +78,7 @@ fn main() {\n // bb1: {\n //     StorageDead(_3);\n //     _1 = const 5u8;\n-//     _0 = ();\n+//     ...\n //     return;\n // }\n // END rustc.bar.CopyPropagation.before.mir\n@@ -92,6 +92,7 @@ fn main() {\n //     ...\n //     _1 = const 5u8;\n //     ...\n+//     return;\n // }\n // END rustc.bar.CopyPropagation.after.mir\n // START rustc.baz.CopyPropagation.before.mir\n@@ -100,7 +101,7 @@ fn main() {\n //     _2 = _1;\n //     _1 = move _2;\n //     StorageDead(_2);\n-//     _0 = ();\n+//     ...\n //     return;\n // }\n // END rustc.baz.CopyPropagation.before.mir\n@@ -110,21 +111,22 @@ fn main() {\n //     _2 = _1;\n //     _1 = move _2;\n //     ...\n+//     return;\n // }\n // END rustc.baz.CopyPropagation.after.mir\n // START rustc.arg_src.CopyPropagation.before.mir\n // bb0: {\n-//       ...\n-//       _3 = _1;\n-//       _2 = move _3;\n-//       ...\n-//       _1 = const 123i32;\n-//       ...\n-//       _4 = _2;\n-//       _0 = move _4;\n-//       ...\n-//       return;\n-//   }\n+//      ...\n+//      _3 = _1;\n+//      _2 = move _3;\n+//      ...\n+//      _1 = const 123i32;\n+//      ...\n+//      _4 = _2;\n+//      _0 = move _4;\n+//      ...\n+//      return;\n+//  }\n // END rustc.arg_src.CopyPropagation.before.mir\n // START rustc.arg_src.CopyPropagation.after.mir\n // bb0: {"}, {"sha": "36f913ff3faac7851820c64609fb9c326fd2c74e", "filename": "src/test/run-make/sepcomp-cci-copies/Makefile", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -2,9 +2,11 @@\n \n # Check that cross-crate inlined items are inlined in all compilation units\n # that refer to them, and not in any other compilation units.\n+# Note that we have to pass `-C codegen-units=6` because up to two CGUs may be\n+# created for each source module (see `rustc_mir::monomorphize::partitioning`).\n \n all:\n \t$(RUSTC) cci_lib.rs\n-\t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=3 \\\n+\t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=6 \\\n \t\t-Z inline-in-all-cgus\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.*.ll | grep -c define\\ .*cci_fn)\" -eq \"2\" ]"}, {"sha": "21fdbb3f5a1ccb17fcf33adc2a07f52dec95d8df", "filename": "src/test/ui/print_type_sizes/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928435305ad1d778d7c4d2c2ff989c6a87be0223/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerics.rs?ref=928435305ad1d778d7c4d2c2ff989c6a87be0223", "patch": "@@ -72,7 +72,7 @@ pub fn f1<T:Copy>(x: T) {\n fn start(_: isize, _: *const *const u8) -> isize {\n     let _b: Pair<u8> = Pair::new(0, 0);\n     let _s: Pair<SevenBytes> = Pair::new(SevenBytes::new(), SevenBytes::new());\n-    let _z: ZeroSized = ZeroSized;\n+    let ref _z: ZeroSized = ZeroSized;\n     f1::<SevenBytes>(SevenBytes::new());\n     0\n }"}]}