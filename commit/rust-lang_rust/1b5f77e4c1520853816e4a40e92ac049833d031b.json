{"sha": "1b5f77e4c1520853816e4a40e92ac049833d031b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNWY3N2U0YzE1MjA4NTM4MTZlNGE0MGU5MmFjMDQ5ODMzZDAzMWI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-05T00:26:19Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-05T21:19:10Z"}, "message": "Implement Offset like the other binary operators, share code with the intrinsic\n\nAlso improve drop glue tests", "tree": {"sha": "9a985bf39cee4f7bdfe001f7ff173318858d962a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a985bf39cee4f7bdfe001f7ff173318858d962a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b5f77e4c1520853816e4a40e92ac049833d031b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b5f77e4c1520853816e4a40e92ac049833d031b", "html_url": "https://github.com/rust-lang/rust/commit/1b5f77e4c1520853816e4a40e92ac049833d031b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b5f77e4c1520853816e4a40e92ac049833d031b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31cf66d0e82800d4239bfba6d2e1c9d4431c8d2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/31cf66d0e82800d4239bfba6d2e1c9d4431c8d2c", "html_url": "https://github.com/rust-lang/rust/commit/31cf66d0e82800d4239bfba6d2e1c9d4431c8d2c"}], "stats": {"total": 264, "additions": 136, "deletions": 128}, "files": [{"sha": "142d90f8dc4d39dddbc36e7ddc72191294a2326e", "filename": "src/eval_context.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b5f77e4c1520853816e4a40e92ac049833d031b/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5f77e4c1520853816e4a40e92ac049833d031b/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=1b5f77e4c1520853816e4a40e92ac049833d031b", "patch": "@@ -451,18 +451,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_value(value, dest, dest_ty)?;\n             }\n \n-            BinaryOp(mir::BinOp::Offset, ref left, ref right) => {\n-                let pointer_ty = self.operand_ty(left);\n-                let pointee_ty = pointer_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n-                // FIXME: assuming here that type size is < i64::max_value()\n-                let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n-                let offset = self.eval_operand_to_primval(right)?.to_i128()? as i64;\n-\n-                let ptr = self.eval_operand_to_primval(left)?.to_ptr()?;\n-                let result_ptr = ptr.signed_offset(offset * pointee_size);\n-                self.write_primval(dest, PrimVal::Ptr(result_ptr), dest_ty)?;\n-            }\n-\n             BinaryOp(bin_op, ref left, ref right) => {\n                 // ignore overflow bit, rustc inserts check branches for us\n                 self.intrinsic_overflowing(bin_op, left, right, dest, dest_ty)?;\n@@ -853,6 +841,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n+    pub(super) fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n+        // FIXME: assuming here that type size is < i64::max_value()\n+        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        // FIXME: Check overflow, out-of-bounds\n+        Ok(ptr.signed_offset(offset * pointee_size))\n+    }\n+\n     pub(super) fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         let value = self.eval_operand(op)?;\n         let ty = self.operand_ty(op);"}, {"sha": "0109cddb5736e5e17a7d14db93ba0428d5114b22", "filename": "src/operator.rs", "status": "modified", "additions": 122, "deletions": 102, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/1b5f77e4c1520853816e4a40e92ac049833d031b/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5f77e4c1520853816e4a40e92ac049833d031b/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=1b5f77e4c1520853816e4a40e92ac049833d031b", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir;\n-use rustc::ty::Ty;\n+use rustc::ty::{self, Ty};\n \n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n@@ -25,11 +25,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n         let left_ty    = self.operand_ty(left);\n         let right_ty   = self.operand_ty(right);\n-        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n-        let right_kind = self.ty_to_primval_kind(right_ty)?;\n         let left_val   = self.eval_operand_to_primval(left)?;\n         let right_val  = self.eval_operand_to_primval(right)?;\n-        binary_op(op, left_val, left_kind, right_val, right_kind)\n+        self.binary_op(op, left_val, left_ty, right_val, right_ty)\n     }\n \n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n@@ -132,119 +130,141 @@ macro_rules! f64_arithmetic {\n     )\n }\n \n-/// Returns the result of the specified operation and whether it overflowed.\n-pub fn binary_op<'tcx>(\n-    bin_op: mir::BinOp,\n-    left: PrimVal,\n-    left_kind: PrimValKind,\n-    right: PrimVal,\n-    right_kind: PrimValKind,\n-) -> EvalResult<'tcx, (PrimVal, bool)> {\n-    use rustc::mir::BinOp::*;\n-    use value::PrimValKind::*;\n-\n-    // FIXME(solson): Temporary hack. It will go away when we get rid of Pointer's ability to store\n-    // plain bytes, and leave that to PrimVal::Bytes.\n-    fn normalize(val: PrimVal) -> PrimVal {\n-        if let PrimVal::Ptr(ptr) = val {\n-            if let Ok(bytes) = ptr.to_int() {\n-                return PrimVal::Bytes(bytes as u128);\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    /// Returns the result of the specified operation and whether it overflowed.\n+    pub fn binary_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: PrimVal,\n+        left_ty: Ty<'tcx>,\n+        right: PrimVal,\n+        right_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+        use rustc::mir::BinOp::*;\n+        use value::PrimValKind::*;\n+\n+        // FIXME(solson): Temporary hack. It will go away when we get rid of Pointer's ability to store\n+        // plain bytes, and leave that to PrimVal::Bytes.\n+        fn normalize(val: PrimVal) -> PrimVal {\n+            if let PrimVal::Ptr(ptr) = val {\n+                if let Ok(bytes) = ptr.to_int() {\n+                    return PrimVal::Bytes(bytes as u128);\n+                }\n             }\n+            val\n         }\n-        val\n-    }\n-    let (left, right) = (normalize(left), normalize(right));\n+        let (left, right) = (normalize(left), normalize(right));\n \n-    let (l, r) = match (left, right) {\n-        (PrimVal::Bytes(left_bytes), PrimVal::Bytes(right_bytes)) => (left_bytes, right_bytes),\n-\n-        (PrimVal::Ptr(left_ptr), PrimVal::Ptr(right_ptr)) => {\n-            if left_ptr.alloc_id == right_ptr.alloc_id {\n-                // If the pointers are into the same allocation, fall through to the more general\n-                // match later, which will do comparisons on the pointer offsets.\n-                (left_ptr.offset as u128, right_ptr.offset as u128)\n-            } else {\n-                return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n-            }\n+        // Offset is handled early, before we dispatch to unrelated_ptr_ops.  We have to also catch the case where both arguments *are* convertible to integers.\n+        if bin_op == Offset {\n+            let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n+            let ptr = self.pointer_offset(left.to_ptr()?, pointee_ty, right.to_bytes()? as i64)?;\n+            return Ok((PrimVal::Ptr(ptr), false));\n         }\n \n-        (PrimVal::Ptr(ptr), PrimVal::Bytes(bytes)) |\n-        (PrimVal::Bytes(bytes), PrimVal::Ptr(ptr)) => {\n-            return Ok((unrelated_ptr_ops(bin_op, ptr, Pointer::from_int(bytes as u64))?, false));\n-        }\n+        let (l, r) = match (left, right) {\n+            (PrimVal::Bytes(left_bytes), PrimVal::Bytes(right_bytes)) => (left_bytes, right_bytes),\n+\n+            (PrimVal::Ptr(left_ptr), PrimVal::Ptr(right_ptr)) => {\n+                if left_ptr.alloc_id == right_ptr.alloc_id {\n+                    // If the pointers are into the same allocation, fall through to the more general\n+                    // match later, which will do comparisons on the pointer offsets.\n+                    (left_ptr.offset as u128, right_ptr.offset as u128)\n+                } else {\n+                    return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n+                }\n+            }\n \n-        (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n-    };\n+            (PrimVal::Ptr(ptr), PrimVal::Bytes(bytes)) |\n+            (PrimVal::Bytes(bytes), PrimVal::Ptr(ptr)) => {\n+                return Ok((unrelated_ptr_ops(bin_op, ptr, Pointer::from_int(bytes as u64))?, false));\n+            }\n \n-    // These ops can have an RHS with a different numeric type.\n-    if bin_op == Shl || bin_op == Shr {\n-        return match bin_op {\n-            Shl => int_shift!(left_kind, overflowing_shl, l, r as u32),\n-            Shr => int_shift!(left_kind, overflowing_shr, l, r as u32),\n-            _ => bug!(\"it has already been checked that this is a shift op\"),\n+            (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n         };\n-    }\n \n-    if left_kind != right_kind {\n-        let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n-        return Err(EvalError::Unimplemented(msg));\n-    }\n+        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n+        let right_kind = self.ty_to_primval_kind(right_ty)?;\n \n-    let val = match (bin_op, left_kind) {\n-        (Eq, F32) => PrimVal::from_bool(bytes_to_f32(l) == bytes_to_f32(r)),\n-        (Ne, F32) => PrimVal::from_bool(bytes_to_f32(l) != bytes_to_f32(r)),\n-        (Lt, F32) => PrimVal::from_bool(bytes_to_f32(l) <  bytes_to_f32(r)),\n-        (Le, F32) => PrimVal::from_bool(bytes_to_f32(l) <= bytes_to_f32(r)),\n-        (Gt, F32) => PrimVal::from_bool(bytes_to_f32(l) >  bytes_to_f32(r)),\n-        (Ge, F32) => PrimVal::from_bool(bytes_to_f32(l) >= bytes_to_f32(r)),\n-\n-        (Eq, F64) => PrimVal::from_bool(bytes_to_f64(l) == bytes_to_f64(r)),\n-        (Ne, F64) => PrimVal::from_bool(bytes_to_f64(l) != bytes_to_f64(r)),\n-        (Lt, F64) => PrimVal::from_bool(bytes_to_f64(l) <  bytes_to_f64(r)),\n-        (Le, F64) => PrimVal::from_bool(bytes_to_f64(l) <= bytes_to_f64(r)),\n-        (Gt, F64) => PrimVal::from_bool(bytes_to_f64(l) >  bytes_to_f64(r)),\n-        (Ge, F64) => PrimVal::from_bool(bytes_to_f64(l) >= bytes_to_f64(r)),\n-\n-        (Add, F32) => f32_arithmetic!(+, l, r),\n-        (Sub, F32) => f32_arithmetic!(-, l, r),\n-        (Mul, F32) => f32_arithmetic!(*, l, r),\n-        (Div, F32) => f32_arithmetic!(/, l, r),\n-        (Rem, F32) => f32_arithmetic!(%, l, r),\n-\n-        (Add, F64) => f64_arithmetic!(+, l, r),\n-        (Sub, F64) => f64_arithmetic!(-, l, r),\n-        (Mul, F64) => f64_arithmetic!(*, l, r),\n-        (Div, F64) => f64_arithmetic!(/, l, r),\n-        (Rem, F64) => f64_arithmetic!(%, l, r),\n-\n-        (Eq, _) => PrimVal::from_bool(l == r),\n-        (Ne, _) => PrimVal::from_bool(l != r),\n-        (Lt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) < (r as i128)),\n-        (Lt, _) => PrimVal::from_bool(l <  r),\n-        (Le, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) <= (r as i128)),\n-        (Le, _) => PrimVal::from_bool(l <= r),\n-        (Gt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) > (r as i128)),\n-        (Gt, _) => PrimVal::from_bool(l >  r),\n-        (Ge, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) >= (r as i128)),\n-        (Ge, _) => PrimVal::from_bool(l >= r),\n-\n-        (BitOr,  _) => PrimVal::Bytes(l | r),\n-        (BitAnd, _) => PrimVal::Bytes(l & r),\n-        (BitXor, _) => PrimVal::Bytes(l ^ r),\n-\n-        (Add, k) if k.is_int() => return int_arithmetic!(k, overflowing_add, l, r),\n-        (Sub, k) if k.is_int() => return int_arithmetic!(k, overflowing_sub, l, r),\n-        (Mul, k) if k.is_int() => return int_arithmetic!(k, overflowing_mul, l, r),\n-        (Div, k) if k.is_int() => return int_arithmetic!(k, overflowing_div, l, r),\n-        (Rem, k) if k.is_int() => return int_arithmetic!(k, overflowing_rem, l, r),\n+        // These ops can have an RHS with a different numeric type.\n+        if bin_op == Shl || bin_op == Shr {\n+            return match bin_op {\n+                Shl => int_shift!(left_kind, overflowing_shl, l, r as u32),\n+                Shr => int_shift!(left_kind, overflowing_shr, l, r as u32),\n+                _ => bug!(\"it has already been checked that this is a shift op\"),\n+            };\n+        }\n+        if bin_op == Offset {\n+            // We permit offset-by-0 in any case.  Drop glue actually does this, and it's probably (TM) fine for LLVM.\n+            if left_kind == PrimValKind::Ptr && right_kind.is_int() && r == 0 {\n+                return Ok((PrimVal::Bytes(l), false));\n+            } else {\n+                let msg = format!(\"unimplemented Offset: {:?}, {:?}\", left, right);\n+                return Err(EvalError::Unimplemented(msg));\n+            }\n+        }\n \n-        _ => {\n+        if left_kind != right_kind {\n             let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n             return Err(EvalError::Unimplemented(msg));\n         }\n-    };\n \n-    Ok((val, false))\n+        let val = match (bin_op, left_kind) {\n+            (Eq, F32) => PrimVal::from_bool(bytes_to_f32(l) == bytes_to_f32(r)),\n+            (Ne, F32) => PrimVal::from_bool(bytes_to_f32(l) != bytes_to_f32(r)),\n+            (Lt, F32) => PrimVal::from_bool(bytes_to_f32(l) <  bytes_to_f32(r)),\n+            (Le, F32) => PrimVal::from_bool(bytes_to_f32(l) <= bytes_to_f32(r)),\n+            (Gt, F32) => PrimVal::from_bool(bytes_to_f32(l) >  bytes_to_f32(r)),\n+            (Ge, F32) => PrimVal::from_bool(bytes_to_f32(l) >= bytes_to_f32(r)),\n+\n+            (Eq, F64) => PrimVal::from_bool(bytes_to_f64(l) == bytes_to_f64(r)),\n+            (Ne, F64) => PrimVal::from_bool(bytes_to_f64(l) != bytes_to_f64(r)),\n+            (Lt, F64) => PrimVal::from_bool(bytes_to_f64(l) <  bytes_to_f64(r)),\n+            (Le, F64) => PrimVal::from_bool(bytes_to_f64(l) <= bytes_to_f64(r)),\n+            (Gt, F64) => PrimVal::from_bool(bytes_to_f64(l) >  bytes_to_f64(r)),\n+            (Ge, F64) => PrimVal::from_bool(bytes_to_f64(l) >= bytes_to_f64(r)),\n+\n+            (Add, F32) => f32_arithmetic!(+, l, r),\n+            (Sub, F32) => f32_arithmetic!(-, l, r),\n+            (Mul, F32) => f32_arithmetic!(*, l, r),\n+            (Div, F32) => f32_arithmetic!(/, l, r),\n+            (Rem, F32) => f32_arithmetic!(%, l, r),\n+\n+            (Add, F64) => f64_arithmetic!(+, l, r),\n+            (Sub, F64) => f64_arithmetic!(-, l, r),\n+            (Mul, F64) => f64_arithmetic!(*, l, r),\n+            (Div, F64) => f64_arithmetic!(/, l, r),\n+            (Rem, F64) => f64_arithmetic!(%, l, r),\n+\n+            (Eq, _) => PrimVal::from_bool(l == r),\n+            (Ne, _) => PrimVal::from_bool(l != r),\n+            (Lt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) < (r as i128)),\n+            (Lt, _) => PrimVal::from_bool(l <  r),\n+            (Le, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) <= (r as i128)),\n+            (Le, _) => PrimVal::from_bool(l <= r),\n+            (Gt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) > (r as i128)),\n+            (Gt, _) => PrimVal::from_bool(l >  r),\n+            (Ge, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) >= (r as i128)),\n+            (Ge, _) => PrimVal::from_bool(l >= r),\n+\n+            (BitOr,  _) => PrimVal::Bytes(l | r),\n+            (BitAnd, _) => PrimVal::Bytes(l & r),\n+            (BitXor, _) => PrimVal::Bytes(l ^ r),\n+\n+            (Add, k) if k.is_int() => return int_arithmetic!(k, overflowing_add, l, r),\n+            (Sub, k) if k.is_int() => return int_arithmetic!(k, overflowing_sub, l, r),\n+            (Mul, k) if k.is_int() => return int_arithmetic!(k, overflowing_mul, l, r),\n+            (Div, k) if k.is_int() => return int_arithmetic!(k, overflowing_div, l, r),\n+            (Rem, k) if k.is_int() => return int_arithmetic!(k, overflowing_rem, l, r),\n+\n+            _ => {\n+                let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n+                return Err(EvalError::Unimplemented(msg));\n+            }\n+        };\n+\n+        Ok((val, false))\n+    }\n }\n \n fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp, left: Pointer, right: Pointer) -> EvalResult<'tcx, PrimVal> {"}, {"sha": "843a5b06b6a0420be6c6754c3f07fd0aa9c16300", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b5f77e4c1520853816e4a40e92ac049833d031b/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5f77e4c1520853816e4a40e92ac049833d031b/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=1b5f77e4c1520853816e4a40e92ac049833d031b", "patch": "@@ -7,7 +7,6 @@ use rustc::ty::{self, Ty};\n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n use lvalue::{Lvalue, LvalueExtra};\n-use operator;\n use value::{PrimVal, PrimValKind, Value};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n@@ -103,8 +102,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n                 };\n-                let kind = self.ty_to_primval_kind(ty)?;\n-                let (val, _) = operator::binary_op(mir::BinOp::Eq, old, kind, expect_old, kind)?;\n+                let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n                 let dest = self.force_allocation(dest)?.to_ptr();\n                 self.write_pair_to_ptr(old, val, dest, dest_ty)?;\n                 self.write_primval(Lvalue::from_ptr(ptr), change, ty)?;\n@@ -125,7 +123,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByValPair(..) => bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\"),\n                 };\n                 self.write_primval(dest, old, ty)?;\n-                let kind = self.ty_to_primval_kind(ty)?;\n                 let op = match intrinsic_name.split('_').nth(1).unwrap() {\n                     \"or\" => mir::BinOp::BitOr,\n                     \"xor\" => mir::BinOp::BitXor,\n@@ -135,7 +132,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => bug!(),\n                 };\n                 // FIXME: what do atomics do on overflow?\n-                let (val, _) = operator::binary_op(op, old, kind, change, kind)?;\n+                let (val, _) = self.binary_op(op, old, ty, change, ty)?;\n                 self.write_primval(Lvalue::from_ptr(ptr), val, ty)?;\n             },\n \n@@ -219,7 +216,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n                 let ty = substs.type_at(0);\n-                let kind = self.ty_to_primval_kind(ty)?;\n                 let a = self.value_to_primval(arg_vals[0], ty)?;\n                 let b = self.value_to_primval(arg_vals[1], ty)?;\n                 let op = match intrinsic_name {\n@@ -230,7 +226,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     \"frem_fast\" => mir::BinOp::Rem,\n                     _ => bug!(),\n                 };\n-                let result = operator::binary_op(op, a, kind, b, kind)?;\n+                let result = self.binary_op(op, a, ty, b, ty)?;\n                 self.write_primval(dest, result.0, dest_ty)?;\n             }\n \n@@ -298,13 +294,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"offset\" => {\n-                let pointee_ty = substs.type_at(0);\n-                // FIXME: assuming here that type size is < i64::max_value()\n-                let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n-                let result_ptr = ptr.signed_offset(offset * pointee_size);\n+                let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_primval(dest, PrimVal::Ptr(result_ptr), dest_ty)?;\n             }\n "}, {"sha": "c9b59f635e14506815a4d8f410b6d5fb47f5326e", "filename": "tests/run-pass/call_drop_on_array_elements.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b5f77e4c1520853816e4a40e92ac049833d031b/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5f77e4c1520853816e4a40e92ac049833d031b/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs?ref=1b5f77e4c1520853816e4a40e92ac049833d031b", "patch": "@@ -1,15 +1,16 @@\n-struct Bar(i32); // ZSTs are tested separately\n+struct Bar(u16); // ZSTs are tested separately\n \n static mut DROP_COUNT: usize = 0;\n \n impl Drop for Bar {\n     fn drop(&mut self) {\n+        assert_eq!(self.0 as usize, unsafe { DROP_COUNT }); // tests whether we are called at a valid address\n         unsafe { DROP_COUNT += 1; }\n     }\n }\n \n fn main() {\n-    let b = [Bar(0), Bar(0), Bar(0), Bar(0)];\n+    let b = [Bar(0), Bar(1), Bar(2), Bar(3)];\n     assert_eq!(unsafe { DROP_COUNT }, 0);\n     drop(b);\n     assert_eq!(unsafe { DROP_COUNT }, 4);"}]}