{"sha": "1f09bc77c1b72ccd0a037cb0d5729749d3acb304", "node_id": "C_kwDOAAsO6NoAKDFmMDliYzc3YzFiNzJjY2QwYTAzN2NiMGQ1NzI5NzQ5ZDNhY2IzMDQ", "commit": {"author": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-03-04T10:35:30Z"}, "committer": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-04-04T15:50:02Z"}, "message": "Migrate (most of) report_and_explain_type_error", "tree": {"sha": "cdcc9fa9257132ba5583d5662254a1e2aa48e0d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdcc9fa9257132ba5583d5662254a1e2aa48e0d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f09bc77c1b72ccd0a037cb0d5729749d3acb304", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f09bc77c1b72ccd0a037cb0d5729749d3acb304", "html_url": "https://github.com/rust-lang/rust/commit/1f09bc77c1b72ccd0a037cb0d5729749d3acb304", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f09bc77c1b72ccd0a037cb0d5729749d3acb304/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab11b4389e9236bec5f8fa679900ca7156567a7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab11b4389e9236bec5f8fa679900ca7156567a7f", "html_url": "https://github.com/rust-lang/rust/commit/ab11b4389e9236bec5f8fa679900ca7156567a7f"}], "stats": {"total": 626, "additions": 397, "deletions": 229}, "files": [{"sha": "9bdce1ee071a77f48bbf3e7edb8099a251c58792", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f09bc77c1b72ccd0a037cb0d5729749d3acb304/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f09bc77c1b72ccd0a037cb0d5729749d3acb304/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=1f09bc77c1b72ccd0a037cb0d5729749d3acb304", "patch": "@@ -768,7 +768,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let (provided_ty, provided_span) = provided_arg_tys[*provided_idx];\n             let trace =\n                 mk_trace(provided_span, formal_and_expected_inputs[*expected_idx], provided_ty);\n-            if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308(_)) {\n+            if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308) {\n                 self.err_ctxt().report_and_explain_type_error(trace, *e).emit();\n                 return true;\n             }"}, {"sha": "163992658e1bd8cee453f53a7b52ce1b49277a0e", "filename": "compiler/rustc_infer/messages.ftl", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1f09bc77c1b72ccd0a037cb0d5729749d3acb304/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1f09bc77c1b72ccd0a037cb0d5729749d3acb304/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=1f09bc77c1b72ccd0a037cb0d5729749d3acb304", "patch": "@@ -370,3 +370,25 @@ infer_stp_wrap_one = try wrapping the pattern in `{$variant}`\n infer_stp_wrap_many = try wrapping the pattern in a variant of `{$path}`\n \n infer_tuple_trailing_comma = use a trailing comma to create a tuple with one element\n+\n+infer_oc_method_compat = method not compatible with trait\n+infer_oc_type_compat = type not compatible with trait\n+infer_oc_const_compat = const not compatible with trait\n+infer_oc_try_compat = `?` operator has incompatible types\n+infer_oc_match_compat = `match` arms have incompatible types\n+infer_oc_if_else_different = `if` and `else` have incompatible types\n+infer_oc_no_else = `if` may be missing an `else` clause\n+infer_oc_no_diverge = `else` clause of `let...else` does not diverge\n+infer_oc_fn_main_correct_type = `main` function has wrong type\n+infer_oc_fn_start_correct_type = `#[start]` function has wrong type\n+infer_oc_intristic_correct_type = intrinsic has wrong type\n+infer_oc_method_correct_type = mismatched `self` parameter type\n+infer_oc_closure_selfref = closure/generator type that references itself\n+infer_oc_cant_coerce = cannot coerce intrinsics to function pointers\n+infer_oc_generic = mismatched types\n+\n+infer_meant_byte_literal = if you meant to write a byte literal, prefix with `b`\n+infer_meant_char_literal = if you meant to write a `char` literal, use single quotes\n+infer_meant_str_literal = if you meant to write a `str` literal, use double quotes\n+infer_consider_specifying_length = consider specifying the actual array length\n+infer_try_cannot_convert = `?` operator cannot convert from `{$found}` to `{$expected}`"}, {"sha": "f3bed305f84af730bce7b73f05c2fd049519ad19", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 158, "deletions": 15, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/1f09bc77c1b72ccd0a037cb0d5729749d3acb304/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f09bc77c1b72ccd0a037cb0d5729749d3acb304/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=1f09bc77c1b72ccd0a037cb0d5729749d3acb304", "patch": "@@ -184,18 +184,6 @@ pub enum SourceKindMultiSuggestion<'a> {\n     },\n }\n \n-#[derive(Subdiagnostic)]\n-#[suggestion(\n-    infer_suggest_add_let_for_letchains,\n-    style = \"verbose\",\n-    applicability = \"machine-applicable\",\n-    code = \"let \"\n-)]\n-pub(crate) struct SuggAddLetForLetChains {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n impl<'a> SourceKindMultiSuggestion<'a> {\n     pub fn new_fully_qualified(\n         span: Span,\n@@ -1373,17 +1361,172 @@ impl AddToDiagnostic for SuggestTuplePatternMany {\n }\n \n #[derive(Subdiagnostic)]\n-pub enum TupleTrailingCommaSuggestion {\n+pub enum Error0308Subdiags {\n+    #[suggestion(\n+        infer_meant_byte_literal,\n+        code = \"b'{code}'\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    MeantByteLiteral {\n+        #[primary_span]\n+        span: Span,\n+        code: String,\n+    },\n+    #[suggestion(\n+        infer_meant_char_literal,\n+        code = \"'{code}'\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    MeantCharLiteral {\n+        #[primary_span]\n+        span: Span,\n+        code: String,\n+    },\n+    #[suggestion(\n+        infer_meant_str_literal,\n+        code = \"\\\"{code}\\\"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    MeantStrLiteral {\n+        #[primary_span]\n+        span: Span,\n+        code: String,\n+    },\n+    #[suggestion(\n+        infer_consider_specifying_length,\n+        code = \"{length}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    ConsiderSpecifyingLength {\n+        #[primary_span]\n+        span: Span,\n+        length: u64,\n+    },\n+    #[note(infer_try_cannot_convert)]\n+    TryCannotConvert { found: String, expected: String },\n     #[suggestion(infer_tuple_trailing_comma, code = \",\", applicability = \"machine-applicable\")]\n-    OnlyComma {\n+    TupleOnlyComma {\n         #[primary_span]\n         span: Span,\n     },\n     #[multipart_suggestion(infer_tuple_trailing_comma, applicability = \"machine-applicable\")]\n-    AlsoParentheses {\n+    TupleAlsoParentheses {\n         #[suggestion_part(code = \"(\")]\n         span_low: Span,\n         #[suggestion_part(code = \",)\")]\n         span_high: Span,\n     },\n+    #[suggestion(\n+        infer_suggest_add_let_for_letchains,\n+        style = \"verbose\",\n+        applicability = \"machine-applicable\",\n+        code = \"let \"\n+    )]\n+    AddLetForLetChains {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum FailureCodeDiagnostics {\n+    #[diag(infer_oc_method_compat, code = \"E0308\")]\n+    MethodCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n+    #[diag(infer_oc_type_compat, code = \"E0308\")]\n+    TypeCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n+    #[diag(infer_oc_const_compat, code = \"E0308\")]\n+    ConstCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n+    #[diag(infer_oc_try_compat, code = \"E0308\")]\n+    TryCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n+    #[diag(infer_oc_match_compat, code = \"E0308\")]\n+    MatchCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n+    #[diag(infer_oc_if_else_different, code = \"E0308\")]\n+    IfElseDifferent {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n+    #[diag(infer_oc_no_else, code = \"E0317\")]\n+    NoElse {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[diag(infer_oc_no_diverge, code = \"E0308\")]\n+    NoDiverge {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n+    #[diag(infer_oc_fn_main_correct_type, code = \"E0580\")]\n+    FnMainCorrectType {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[diag(infer_oc_fn_start_correct_type, code = \"E0308\")]\n+    FnStartCorrectType {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n+    #[diag(infer_oc_intristic_correct_type, code = \"E0308\")]\n+    IntristicCorrectType {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n+    #[diag(infer_oc_method_correct_type, code = \"E0308\")]\n+    MethodCorrectType {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n+    #[diag(infer_oc_closure_selfref, code = \"E0644\")]\n+    ClosureSelfref {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[diag(infer_oc_cant_coerce, code = \"E0308\")]\n+    CantCoerce {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n+    #[diag(infer_oc_generic, code = \"E0308\")]\n+    Generic {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<Error0308Subdiags>,\n+    },\n }"}, {"sha": "4b7f4fe1aaa51a983c402527e74103592fa111f7", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 209, "deletions": 206, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/1f09bc77c1b72ccd0a037cb0d5729749d3acb304/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f09bc77c1b72ccd0a037cb0d5729749d3acb304/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=1f09bc77c1b72ccd0a037cb0d5729749d3acb304", "patch": "@@ -49,8 +49,7 @@ use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n-use crate::errors;\n-use crate::errors::TupleTrailingCommaSuggestion;\n+use crate::errors::{self, Error0308Subdiags, FailureCodeDiagnostics};\n use crate::infer;\n use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::ExpectedFound;\n@@ -1899,225 +1898,196 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         debug!(?diag);\n     }\n \n-    pub fn report_and_explain_type_error(\n+    pub fn type_error_additional_suggestions(\n         &self,\n-        trace: TypeTrace<'tcx>,\n+        trace: &TypeTrace<'tcx>,\n         terr: TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+    ) -> Vec<Error0308Subdiags> {\n         use crate::traits::ObligationCauseCode::MatchExpressionArm;\n-\n-        debug!(\"report_and_explain_type_error(trace={:?}, terr={:?})\", trace, terr);\n-\n+        fn escape_literal(s: &str) -> String {\n+            let mut escaped = String::with_capacity(s.len());\n+            let mut chrs = s.chars().peekable();\n+            while let Some(first) = chrs.next() {\n+                match (first, chrs.peek()) {\n+                    ('\\\\', Some(&delim @ '\"') | Some(&delim @ '\\'')) => {\n+                        escaped.push('\\\\');\n+                        escaped.push(delim);\n+                        chrs.next();\n+                    }\n+                    ('\"' | '\\'', _) => {\n+                        escaped.push('\\\\');\n+                        escaped.push(first)\n+                    }\n+                    (c, _) => escaped.push(c),\n+                };\n+            }\n+            escaped\n+        }\n+        let mut suggestions = Vec::new();\n         let span = trace.cause.span();\n-        let failure_code = trace.cause.as_failure_code(terr);\n-        let mut diag = match failure_code {\n-            FailureCode::Error0317(failure_str) => {\n-                struct_span_err!(self.tcx.sess, span, E0317, \"{}\", failure_str)\n-            }\n-            FailureCode::Error0580(failure_str) => {\n-                struct_span_err!(self.tcx.sess, span, E0580, \"{}\", failure_str)\n-            }\n-            FailureCode::Error0308(failure_str) => {\n-                fn escape_literal(s: &str) -> String {\n-                    let mut escaped = String::with_capacity(s.len());\n-                    let mut chrs = s.chars().peekable();\n-                    while let Some(first) = chrs.next() {\n-                        match (first, chrs.peek()) {\n-                            ('\\\\', Some(&delim @ '\"') | Some(&delim @ '\\'')) => {\n-                                escaped.push('\\\\');\n-                                escaped.push(delim);\n-                                chrs.next();\n-                            }\n-                            ('\"' | '\\'', _) => {\n-                                escaped.push('\\\\');\n-                                escaped.push(first)\n-                            }\n-                            (c, _) => escaped.push(c),\n-                        };\n+        if let Some((expected, found)) = trace.values.ty() {\n+            match (expected.kind(), found.kind()) {\n+                (ty::Tuple(_), ty::Tuple(_)) => {}\n+                // If a tuple of length one was expected and the found expression has\n+                // parentheses around it, perhaps the user meant to write `(expr,)` to\n+                // build a tuple (issue #86100)\n+                (ty::Tuple(fields), _) => {\n+                    suggestions.extend(self.tuple_wrap_err_subdiag( span, found, fields))\n+                }\n+                // If a byte was expected and the found expression is a char literal\n+                // containing a single ASCII character, perhaps the user meant to write `b'c'` to\n+                // specify a byte literal\n+                (ty::Uint(ty::UintTy::U8), ty::Char) => {\n+                    if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n+                        && let Some(code) = code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n+                        && !code.starts_with(\"\\\\u\") // forbid all Unicode escapes\n+                        && code.chars().next().map_or(false, |c| c.is_ascii()) // forbids literal Unicode characters beyond ASCII\n+                    {\n+                        suggestions.push(Error0308Subdiags::MeantByteLiteral { span, code: escape_literal(code) })\n                     }\n-                    escaped\n                 }\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str);\n-                let values = self.resolve_vars_if_possible(trace.values);\n-                if let Some((expected, found)) = values.ty() {\n-                    match (expected.kind(), found.kind()) {\n-                        (ty::Tuple(_), ty::Tuple(_)) => {}\n-                        // If a tuple of length one was expected and the found expression has\n-                        // parentheses around it, perhaps the user meant to write `(expr,)` to\n-                        // build a tuple (issue #86100)\n-                        (ty::Tuple(fields), _) => {\n-                            self.emit_tuple_wrap_err(&mut err, span, found, fields)\n-                        }\n-                        // If a byte was expected and the found expression is a char literal\n-                        // containing a single ASCII character, perhaps the user meant to write `b'c'` to\n-                        // specify a byte literal\n-                        (ty::Uint(ty::UintTy::U8), ty::Char) => {\n-                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n-                                && let Some(code) = code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n-                                && !code.starts_with(\"\\\\u\") // forbid all Unicode escapes\n-                                && code.chars().next().map_or(false, |c| c.is_ascii()) // forbids literal Unicode characters beyond ASCII\n-                            {\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"if you meant to write a byte literal, prefix with `b`\",\n-                                    format!(\"b'{}'\", escape_literal(code)),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                        }\n-                        // If a character was expected and the found expression is a string literal\n-                        // containing a single character, perhaps the user meant to write `'c'` to\n-                        // specify a character literal (issue #92479)\n-                        (ty::Char, ty::Ref(_, r, _)) if r.is_str() => {\n-                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n-                                && let Some(code) = code.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n-                                && code.chars().count() == 1\n-                            {\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"if you meant to write a `char` literal, use single quotes\",\n-                                    format!(\"'{}'\", escape_literal(code)),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n+                // If a character was expected and the found expression is a string literal\n+                // containing a single character, perhaps the user meant to write `'c'` to\n+                // specify a character literal (issue #92479)\n+                (ty::Char, ty::Ref(_, r, _)) if r.is_str() => {\n+                    if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n+                        && let Some(code) = code.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n+                        && code.chars().count() == 1\n+                    {\n+                        suggestions.push(Error0308Subdiags::MeantCharLiteral { span, code: escape_literal(code) })\n+                    }\n+                }\n+                // If a string was expected and the found expression is a character literal,\n+                // perhaps the user meant to write `\"s\"` to specify a string literal.\n+                (ty::Ref(_, r, _), ty::Char) if r.is_str() => {\n+                    if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n+                        if let Some(code) =\n+                            code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n+                        {\n+                            suggestions.push(Error0308Subdiags::MeantStrLiteral { span, code: escape_literal(code) })\n                         }\n-                        // If a string was expected and the found expression is a character literal,\n-                        // perhaps the user meant to write `\"s\"` to specify a string literal.\n-                        (ty::Ref(_, r, _), ty::Char) if r.is_str() => {\n-                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n-                                if let Some(code) =\n-                                    code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n-                                {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"if you meant to write a `str` literal, use double quotes\",\n-                                        format!(\"\\\"{}\\\"\", escape_literal(code)),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n+                    }\n+                }\n+                // For code `if Some(..) = expr `, the type mismatch may be expected `bool` but found `()`,\n+                // we try to suggest to add the missing `let` for `if let Some(..) = expr`\n+                (ty::Bool, ty::Tuple(list)) => if list.len() == 0 {\n+                    suggestions.extend(self.suggest_let_for_letchains(&trace.cause, span));\n+                }\n+                (ty::Array(_, _), ty::Array(_, _)) => 'block: {\n+                    let hir = self.tcx.hir();\n+                    let TypeError::FixedArraySize(sz) = terr else {\n+                        break 'block;\n+                    };\n+                    let tykind = match hir.find_by_def_id(trace.cause.body_id) {\n+                        Some(hir::Node::Item(hir::Item {\n+                            kind: hir::ItemKind::Fn(_, _, body_id),\n+                            ..\n+                        })) => {\n+                            let body = hir.body(*body_id);\n+                            struct LetVisitor<'v> {\n+                                span: Span,\n+                                result: Option<&'v hir::Ty<'v>>,\n                             }\n-                        }\n-                        // For code `if Some(..) = expr `, the type mismatch may be expected `bool` but found `()`,\n-                        // we try to suggest to add the missing `let` for `if let Some(..) = expr`\n-                        (ty::Bool, ty::Tuple(list)) => if list.len() == 0 {\n-                            self.suggest_let_for_letchains(&mut err, &trace.cause, span);\n-                        }\n-                        (ty::Array(_, _), ty::Array(_, _)) => 'block: {\n-                            let hir = self.tcx.hir();\n-                            let TypeError::FixedArraySize(sz) = terr else {\n-                                break 'block;\n-                            };\n-                            let tykind = match hir.find_by_def_id(trace.cause.body_id) {\n-                                Some(hir::Node::Item(hir::Item {\n-                                    kind: hir::ItemKind::Fn(_, _, body_id),\n-                                    ..\n-                                })) => {\n-                                    let body = hir.body(*body_id);\n-                                    struct LetVisitor<'v> {\n-                                        span: Span,\n-                                        result: Option<&'v hir::Ty<'v>>,\n+                            impl<'v> Visitor<'v> for LetVisitor<'v> {\n+                                fn visit_stmt(&mut self, s: &'v hir::Stmt<'v>) {\n+                                    if self.result.is_some() {\n+                                        return;\n                                     }\n-                                    impl<'v> Visitor<'v> for LetVisitor<'v> {\n-                                        fn visit_stmt(&mut self, s: &'v hir::Stmt<'v>) {\n-                                            if self.result.is_some() {\n-                                                return;\n-                                            }\n-                                            // Find a local statement where the initializer has\n-                                            // the same span as the error and the type is specified.\n-                                            if let hir::Stmt {\n-                                                kind: hir::StmtKind::Local(hir::Local {\n-                                                    init: Some(hir::Expr {\n-                                                        span: init_span,\n-                                                        ..\n-                                                    }),\n-                                                    ty: Some(array_ty),\n-                                                    ..\n-                                                }),\n+                                    // Find a local statement where the initializer has\n+                                    // the same span as the error and the type is specified.\n+                                    if let hir::Stmt {\n+                                        kind: hir::StmtKind::Local(hir::Local {\n+                                            init: Some(hir::Expr {\n+                                                span: init_span,\n                                                 ..\n-                                            } = s\n-                                            && init_span == &self.span {\n-                                                self.result = Some(*array_ty);\n-                                            }\n-                                        }\n+                                            }),\n+                                            ty: Some(array_ty),\n+                                            ..\n+                                        }),\n+                                        ..\n+                                    } = s\n+                                    && init_span == &self.span {\n+                                        self.result = Some(*array_ty);\n                                     }\n-                                    let mut visitor = LetVisitor {span, result: None};\n-                                    visitor.visit_body(body);\n-                                    visitor.result.map(|r| &r.peel_refs().kind)\n-                                }\n-                                Some(hir::Node::Item(hir::Item {\n-                                    kind: hir::ItemKind::Const(ty, _),\n-                                    ..\n-                                })) => {\n-                                    Some(&ty.peel_refs().kind)\n                                 }\n-                                _ => None\n-                            };\n-\n-                            if let Some(tykind) = tykind\n-                                && let hir::TyKind::Array(_, length) = tykind\n-                                && let hir::ArrayLen::Body(hir::AnonConst { hir_id, .. }) = length\n-                                && let Some(span) = self.tcx.hir().opt_span(*hir_id)\n-                            {\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"consider specifying the actual array length\",\n-                                    sz.found,\n-                                    Applicability::MaybeIncorrect,\n-                                );\n                             }\n+                            let mut visitor = LetVisitor {span, result: None};\n+                            visitor.visit_body(body);\n+                            visitor.result.map(|r| &r.peel_refs().kind)\n                         }\n-                        _ => {}\n+                        Some(hir::Node::Item(hir::Item {\n+                            kind: hir::ItemKind::Const(ty, _),\n+                            ..\n+                        })) => {\n+                            Some(&ty.peel_refs().kind)\n+                        }\n+                        _ => None\n+                    };\n+\n+                    if let Some(tykind) = tykind\n+                        && let hir::TyKind::Array(_, length) = tykind\n+                        && let hir::ArrayLen::Body(hir::AnonConst { hir_id, .. }) = length\n+                        && let Some(span) = self.tcx.hir().opt_span(*hir_id)\n+                    {\n+                        suggestions.push(Error0308Subdiags::ConsiderSpecifyingLength { span, length: sz.found });\n                     }\n                 }\n-                let code = trace.cause.code();\n-                if let &MatchExpressionArm(box MatchExpressionArmCause { source, .. }) = code\n+                _ => {}\n+            }\n+        }\n+        let code = trace.cause.code();\n+        if let &MatchExpressionArm(box MatchExpressionArmCause { source, .. }) = code\n                     && let hir::MatchSource::TryDesugar = source\n                     && let Some((expected_ty, found_ty, _, _)) = self.values_str(trace.values)\n                 {\n-                    err.note(&format!(\n-                        \"`?` operator cannot convert from `{}` to `{}`\",\n-                        found_ty.content(),\n-                        expected_ty.content(),\n-                    ));\n+                    suggestions.push(Error0308Subdiags::TryCannotConvert { found: found_ty.content(), expected: expected_ty.content() });\n                 }\n-                err\n-            }\n-            FailureCode::Error0644(failure_str) => {\n-                struct_span_err!(self.tcx.sess, span, E0644, \"{}\", failure_str)\n-            }\n-        };\n+        suggestions\n+    }\n+\n+    pub fn report_and_explain_type_error(\n+        &self,\n+        trace: TypeTrace<'tcx>,\n+        terr: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        debug!(\"report_and_explain_type_error(trace={:?}, terr={:?})\", trace, terr);\n+\n+        let span = trace.cause.span();\n+        let failure_code = trace.cause.as_failure_code_diag(\n+            terr,\n+            span,\n+            self.type_error_additional_suggestions(&trace, terr),\n+        );\n+        let mut diag = self.tcx.sess.create_err(failure_code);\n         self.note_type_err(&mut diag, &trace.cause, None, Some(trace.values), terr, false, false);\n         diag\n     }\n \n-    fn emit_tuple_wrap_err(\n+    fn tuple_wrap_err_subdiag(\n         &self,\n-        err: &mut Diagnostic,\n         span: Span,\n         found: Ty<'tcx>,\n         expected_fields: &List<Ty<'tcx>>,\n-    ) {\n-        let [expected_tup_elem] = expected_fields[..] else { return };\n+    ) -> Option<Error0308Subdiags> {\n+        let [expected_tup_elem] = expected_fields[..] else { return None};\n \n         if !self.same_type_modulo_infer(expected_tup_elem, found) {\n-            return;\n+            return None;\n         }\n \n         let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n-            else { return };\n+            else { return None };\n \n         let sugg = if code.starts_with('(') && code.ends_with(')') {\n             let before_close = span.hi() - BytePos::from_u32(1);\n-            TupleTrailingCommaSuggestion::OnlyComma {\n-                span: span.with_hi(before_close).shrink_to_hi(),\n-            }\n+            Error0308Subdiags::TupleOnlyComma { span: span.with_hi(before_close).shrink_to_hi() }\n         } else {\n-            TupleTrailingCommaSuggestion::AlsoParentheses {\n+            Error0308Subdiags::TupleAlsoParentheses {\n                 span_low: span.shrink_to_lo(),\n                 span_high: span.shrink_to_hi(),\n             }\n         };\n-        err.subdiagnostic(sugg);\n+        Some(sugg)\n     }\n \n     fn values_str(\n@@ -2820,56 +2790,89 @@ impl<'tcx> InferCtxt<'tcx> {\n }\n \n pub enum FailureCode {\n-    Error0317(&'static str),\n-    Error0580(&'static str),\n-    Error0308(&'static str),\n-    Error0644(&'static str),\n+    Error0317,\n+    Error0580,\n+    Error0308,\n+    Error0644,\n }\n \n pub trait ObligationCauseExt<'tcx> {\n     fn as_failure_code(&self, terr: TypeError<'tcx>) -> FailureCode;\n+\n+    fn as_failure_code_diag(\n+        &self,\n+        terr: TypeError<'tcx>,\n+        span: Span,\n+        subdiags: Vec<Error0308Subdiags>,\n+    ) -> FailureCodeDiagnostics;\n     fn as_requirement_str(&self) -> &'static str;\n }\n \n impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n     fn as_failure_code(&self, terr: TypeError<'tcx>) -> FailureCode {\n         use self::FailureCode::*;\n+        use crate::traits::ObligationCauseCode::*;\n+        match self.code() {\n+            IfExpressionWithNoElse => Error0317,\n+            MainFunctionType => Error0580,\n+            CompareImplItemObligation { .. }\n+            | MatchExpressionArm(_)\n+            | IfExpression { .. }\n+            | LetElse\n+            | StartFunctionType\n+            | IntrinsicType\n+            | MethodReceiver => Error0308,\n+\n+            // In the case where we have no more specific thing to\n+            // say, also take a look at the error code, maybe we can\n+            // tailor to that.\n+            _ => match terr {\n+                TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => Error0644,\n+                TypeError::IntrinsicCast => Error0308,\n+                _ => Error0308,\n+            },\n+        }\n+    }\n+    fn as_failure_code_diag(\n+        &self,\n+        terr: TypeError<'tcx>,\n+        span: Span,\n+        subdiags: Vec<Error0308Subdiags>,\n+    ) -> FailureCodeDiagnostics {\n         use crate::traits::ObligationCauseCode::*;\n         match self.code() {\n             CompareImplItemObligation { kind: ty::AssocKind::Fn, .. } => {\n-                Error0308(\"method not compatible with trait\")\n+                FailureCodeDiagnostics::MethodCompat { span, subdiags }\n             }\n             CompareImplItemObligation { kind: ty::AssocKind::Type, .. } => {\n-                Error0308(\"type not compatible with trait\")\n+                FailureCodeDiagnostics::TypeCompat { span, subdiags }\n             }\n             CompareImplItemObligation { kind: ty::AssocKind::Const, .. } => {\n-                Error0308(\"const not compatible with trait\")\n-            }\n-            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => {\n-                Error0308(match source {\n-                    hir::MatchSource::TryDesugar => \"`?` operator has incompatible types\",\n-                    _ => \"`match` arms have incompatible types\",\n-                })\n-            }\n-            IfExpression { .. } => Error0308(\"`if` and `else` have incompatible types\"),\n-            IfExpressionWithNoElse => Error0317(\"`if` may be missing an `else` clause\"),\n-            LetElse => Error0308(\"`else` clause of `let...else` does not diverge\"),\n-            MainFunctionType => Error0580(\"`main` function has wrong type\"),\n-            StartFunctionType => Error0308(\"`#[start]` function has wrong type\"),\n-            IntrinsicType => Error0308(\"intrinsic has wrong type\"),\n-            MethodReceiver => Error0308(\"mismatched `self` parameter type\"),\n+                FailureCodeDiagnostics::ConstCompat { span, subdiags }\n+            }\n+            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => match source {\n+                hir::MatchSource::TryDesugar => {\n+                    FailureCodeDiagnostics::TryCompat { span, subdiags }\n+                }\n+                _ => FailureCodeDiagnostics::MatchCompat { span, subdiags },\n+            },\n+            IfExpression { .. } => FailureCodeDiagnostics::IfElseDifferent { span, subdiags },\n+            IfExpressionWithNoElse => FailureCodeDiagnostics::NoElse { span },\n+            LetElse => FailureCodeDiagnostics::NoDiverge { span, subdiags },\n+            MainFunctionType => FailureCodeDiagnostics::FnMainCorrectType { span },\n+            StartFunctionType => FailureCodeDiagnostics::FnStartCorrectType { span, subdiags },\n+            IntrinsicType => FailureCodeDiagnostics::IntristicCorrectType { span, subdiags },\n+            MethodReceiver => FailureCodeDiagnostics::MethodCorrectType { span, subdiags },\n \n             // In the case where we have no more specific thing to\n             // say, also take a look at the error code, maybe we can\n             // tailor to that.\n             _ => match terr {\n                 TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => {\n-                    Error0644(\"closure/generator type that references itself\")\n-                }\n-                TypeError::IntrinsicCast => {\n-                    Error0308(\"cannot coerce intrinsics to function pointers\")\n+                    FailureCodeDiagnostics::ClosureSelfref { span }\n                 }\n-                _ => Error0308(\"mismatched types\"),\n+                TypeError::IntrinsicCast => FailureCodeDiagnostics::CantCoerce { span, subdiags },\n+                _ => FailureCodeDiagnostics::Generic { span, subdiags },\n             },\n         }\n     }"}, {"sha": "fecfc53c86a2011b078b99bf4b4a12c361055daf", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f09bc77c1b72ccd0a037cb0d5729749d3acb304/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f09bc77c1b72ccd0a037cb0d5729749d3acb304/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=1f09bc77c1b72ccd0a037cb0d5729749d3acb304", "patch": "@@ -13,10 +13,10 @@ use rustc_span::{sym, BytePos, Span};\n use rustc_target::abi::FieldIdx;\n \n use crate::errors::{\n-    ConsiderAddingAwait, DiagArg, FnConsiderCasting, FnItemsAreDistinct, FnUniqTypes,\n-    FunctionPointerSuggestion, SuggAddLetForLetChains, SuggestAccessingField,\n-    SuggestAsRefWhereAppropriate, SuggestBoxingForReturnImplTrait,\n-    SuggestRemoveSemiOrReturnBinding, SuggestTuplePatternMany, SuggestTuplePatternOne,\n+    ConsiderAddingAwait, DiagArg, Error0308Subdiags, FnConsiderCasting, FnItemsAreDistinct,\n+    FnUniqTypes, FunctionPointerSuggestion, SuggestAccessingField, SuggestAsRefWhereAppropriate,\n+    SuggestBoxingForReturnImplTrait, SuggestRemoveSemiOrReturnBinding, SuggestTuplePatternMany,\n+    SuggestTuplePatternOne,\n };\n \n use super::TypeErrCtxt;\n@@ -482,10 +482,9 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     /// and then try to find a assignment in the `cond` part, which span is equal with error span\n     pub(super) fn suggest_let_for_letchains(\n         &self,\n-        err: &mut Diagnostic,\n         cause: &ObligationCause<'_>,\n         span: Span,\n-    ) {\n+    ) -> Option<Error0308Subdiags> {\n         let hir = self.tcx.hir();\n         if let Some(node) = self.tcx.hir().find_by_def_id(cause.body_id) &&\n             let hir::Node::Item(hir::Item {\n@@ -532,9 +531,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         let mut visitor = IfVisitor { err_span: span, found_if: false, result: false };\n         visitor.visit_body(&body);\n         if visitor.result {\n-                err.subdiagnostic(SuggAddLetForLetChains{span: span.shrink_to_lo()});\n+                return Some(Error0308Subdiags::AddLetForLetChains{span: span.shrink_to_lo()});\n             }\n         }\n+        None\n     }\n }\n "}]}