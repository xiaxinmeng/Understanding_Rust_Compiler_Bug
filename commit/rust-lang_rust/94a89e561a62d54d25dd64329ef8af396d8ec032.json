{"sha": "94a89e561a62d54d25dd64329ef8af396d8ec032", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YTg5ZTU2MWE2MmQ1NGQyNWRkNjQzMjllZjhhZjM5NmQ4ZWMwMzI=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-20T04:43:17Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-20T04:43:17Z"}, "message": "some conversions cleanup", "tree": {"sha": "e1fa2b3e9aed65a646b1db3c055f107b6cb3eb74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1fa2b3e9aed65a646b1db3c055f107b6cb3eb74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94a89e561a62d54d25dd64329ef8af396d8ec032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94a89e561a62d54d25dd64329ef8af396d8ec032", "html_url": "https://github.com/rust-lang/rust/commit/94a89e561a62d54d25dd64329ef8af396d8ec032", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94a89e561a62d54d25dd64329ef8af396d8ec032/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13b2605ed985a37481dc497357dc6dcdf37ba6ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/13b2605ed985a37481dc497357dc6dcdf37ba6ff", "html_url": "https://github.com/rust-lang/rust/commit/13b2605ed985a37481dc497357dc6dcdf37ba6ff"}], "stats": {"total": 62, "additions": 39, "deletions": 23}, "files": [{"sha": "37f84ead7974b28659f3c864f759a2e8edf3682c", "filename": "src/doc/tarpl/casts.md", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/94a89e561a62d54d25dd64329ef8af396d8ec032/src%2Fdoc%2Ftarpl%2Fcasts.md", "raw_url": "https://github.com/rust-lang/rust/raw/94a89e561a62d54d25dd64329ef8af396d8ec032/src%2Fdoc%2Ftarpl%2Fcasts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fcasts.md?ref=94a89e561a62d54d25dd64329ef8af396d8ec032", "patch": "@@ -1,9 +1,21 @@\n % Casts\n \n-Casts are a superset of coercions: every coercion can be explicitly invoked via\n-a cast, but some conversions *require* a cast. These \"true casts\" are generally\n-regarded as dangerous or problematic actions. True casts revolve around raw\n-pointers and the primitive numeric types. True casts aren't checked.\n+Casts are a superset of coercions: every coercion can be explicitly\n+invoked via a cast. However some conversions *require* a cast.\n+While coercions are pervasive and largely harmless, these \"true casts\"\n+are rare and potentially dangerous. As such, casts must be explicitly invoked\n+using the `as` keyword: `expr as Type`.\n+\n+True casts generally revolve around raw pointers and the primitive numeric\n+types. Even though they're dangerous, these casts are *infallible* at runtime.\n+If a cast triggers some subtle corner case no indication will be given that\n+this occurred. The cast will simply succeed.\n+\n+That said, casts aren't `unsafe` because they generally can't violate memory\n+safety *on their own*. For instance, converting an integer to a raw pointer can\n+very easily lead to terrible things. However the act of creating the pointer\n+itself is safe, because actually using a raw pointer is already marked as\n+`unsafe`.\n \n Here's an exhaustive list of all the true casts. For brevity, we will use `*`\n to denote either a `*const` or `*mut`, and `integer` to denote any integral\n@@ -22,13 +34,8 @@ primitive:\n  * `fn as *T` where `T: Sized`\n  * `fn as integer`\n \n-where `&.T` and `*T` are references of either mutability,\n-and where unsize_kind(`T`) is the kind of the unsize info\n-in `T` - the vtable for a trait definition (e.g. `fmt::Display` or\n-`Iterator`, not `Iterator<Item=u8>`) or a length (or `()` if `T: Sized`).\n-\n Note that lengths are not adjusted when casting raw slices -\n-`T: *const [u16] as *const [u8]` creates a slice that only includes\n+`*const [u16] as *const [u8]` creates a slice that only includes\n half of the original memory.\n \n Casting is not transitive, that is, even if `e as U1 as U2` is a valid"}, {"sha": "0eb03d271c45735ce023b069ce50c68b9a2b6fe9", "filename": "src/doc/tarpl/coercions.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94a89e561a62d54d25dd64329ef8af396d8ec032/src%2Fdoc%2Ftarpl%2Fcoercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/94a89e561a62d54d25dd64329ef8af396d8ec032/src%2Fdoc%2Ftarpl%2Fcoercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fcoercions.md?ref=94a89e561a62d54d25dd64329ef8af396d8ec032", "patch": "@@ -9,8 +9,7 @@ Here's all the kinds of coercion:\n \n Coercion is allowed between the following types:\n \n-* Subtyping: `T` to `U` if `T` is a [subtype](lifetimes.html#subtyping-and-variance)\n-  of `U`\n+* Subtyping: `T` to `U` if `T` is a [subtype][] of `U`\n * Transitivity: `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`\n * Pointer Weakening:\n     * `&mut T` to `&T`\n@@ -25,7 +24,6 @@ only implemented automatically, and enables the following transformations:\n \n * `[T, ..n]` => `[T]`\n * `T` => `Trait` where `T: Trait`\n-* `SubTrait` => `Trait` where `SubTrait: Trait` (TODO: is this now implied by the previous?)\n * `Foo<..., T, ...>` => `Foo<..., U, ...>` where:\n     * `T: Unsize<U>`\n     * `Foo` is a struct\n@@ -70,3 +68,5 @@ fn main() {\n <anon>:10     foo(t);\n               ^~~\n ```\n+\n+[subtype]: subtyping.html"}, {"sha": "2309c45c6a84fee8e28e8ae12d0ba5e7a62f28b4", "filename": "src/doc/tarpl/conversions.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94a89e561a62d54d25dd64329ef8af396d8ec032/src%2Fdoc%2Ftarpl%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/94a89e561a62d54d25dd64329ef8af396d8ec032/src%2Fdoc%2Ftarpl%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconversions.md?ref=94a89e561a62d54d25dd64329ef8af396d8ec032", "patch": "@@ -1,9 +1,12 @@\n % Type Conversions\n \n At the end of the day, everything is just a pile of bits somewhere, and type\n-systems are just there to help us use those bits right. Needing to reinterpret\n-those piles of bits as different types is a common problem and Rust consequently\n-gives you several ways to do that.\n+systems are just there to help us use those bits right. There are two common\n+problems with typing bits: needing to reinterpret those exact bits as a\n+different type, and needing to change the bits to have equivalent meaning for\n+a different type. Because Rust encourages encoding important properties in the\n+type system, these problems are incredibly pervasive. As such, Rust\n+consequently gives you several ways to solve them.\n \n First we'll look at the ways that *Safe Rust* gives you to reinterpret values.\n The most trivial way to do this is to just destructure a value into its\n@@ -26,6 +29,6 @@ fn reinterpret(foo: Foo) -> Bar {\n }\n ```\n \n-But this is, at best, annoying to do. For common conversions, Rust provides\n+But this is, at best, annoying. For common conversions, Rust provides\n more ergonomic alternatives.\n "}, {"sha": "f19dda0d8b81fd948b54b36b1c5cb255192ad0e5", "filename": "src/doc/tarpl/transmutes.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94a89e561a62d54d25dd64329ef8af396d8ec032/src%2Fdoc%2Ftarpl%2Ftransmutes.md", "raw_url": "https://github.com/rust-lang/rust/raw/94a89e561a62d54d25dd64329ef8af396d8ec032/src%2Fdoc%2Ftarpl%2Ftransmutes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Ftransmutes.md?ref=94a89e561a62d54d25dd64329ef8af396d8ec032", "patch": "@@ -1,10 +1,10 @@\n % Transmutes\n \n Get out of our way type system! We're going to reinterpret these bits or die\n-trying! Even though this book is all about doing things that are unsafe, I really\n-can't emphasize that you should deeply think about finding Another Way than the\n-operations covered in this section. This is really, truly, the most horribly\n-unsafe thing you can do in Rust. The railguards here are dental floss.\n+trying! Even though this book is all about doing things that are unsafe, I\n+really can't emphasize that you should deeply think about finding Another Way\n+than the operations covered in this section. This is really, truly, the most\n+horribly unsafe thing you can do in Rust. The railguards here are dental floss.\n \n `mem::transmute<T, U>` takes a value of type `T` and reinterprets it to have\n type `U`. The only restriction is that the `T` and `U` are verified to have the\n@@ -17,13 +17,19 @@ same size. The ways to cause Undefined Behaviour with this are mind boggling.\n * Making a primitive with an invalid value is UB\n * Transmuting between non-repr(C) types is UB\n * Transmuting an & to &mut is UB\n+    * Transmuting an & to &mut is *always* UB\n+    * No you can't do it\n+    * No you're not special\n * Transmuting to a reference without an explicitly provided lifetime\n-  produces an [unbound lifetime](lifetimes.html#unbounded-lifetimes)\n+  produces an [unbounded lifetime][]\n \n `mem::transmute_copy<T, U>` somehow manages to be *even more* wildly unsafe than\n this. It copies `size_of<U>` bytes out of an `&T` and interprets them as a `U`.\n The size check that `mem::transmute` has is gone (as it may be valid to copy\n out a prefix), though it is Undefined Behaviour for `U` to be larger than `T`.\n \n Also of course you can get most of the functionality of these functions using\n-pointer casts.\n\\ No newline at end of file\n+pointer casts.\n+\n+\n+[unbounded lifetime]: unbounded-lifetimes.html"}]}