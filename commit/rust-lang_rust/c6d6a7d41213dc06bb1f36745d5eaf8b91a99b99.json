{"sha": "c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZDZhN2Q0MTIxM2RjMDZiYjFmMzY3NDVkNWVhZjhiOTFhOTliOTk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-23T19:58:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-23T19:58:03Z"}, "message": "Merge #8178\n\n8178: Show item info when hovering intra doc links r=Veykril a=Veykril\n\n![r4uIITP0IZ](https://user-images.githubusercontent.com/3757771/112197618-91e2fb00-8c0c-11eb-9edc-a7923214d2b6.gif)\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "a6fd422786b72b621fec4a3c21d7f019656f9b1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6fd422786b72b621fec4a3c21d7f019656f9b1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgWkhLCRBK7hj4Ov3rIwAAdHIIAKZ1SrB+ZARy6YmYxVPaTosQ\nm1muazNKe1gWvPPdRABSI68x+sA7GTmfTCQYAbUAgode2pRppQ2uaYAxMWmbg9Pc\n8yZIYMmAtd3RpGP6gynVMPCUsYDRqP6PidG9wXYRLatsgXN22xtntlUUDV7WqZw8\nhZefpBYL8Y1CvJfBPnsRWEOCx8cM+nEh+67Kxf15QLwfStGh3f2qXQ6ROxheeT2x\ntM/kmAQkblVASGryeThBq3kp2GSTRd2bMbc/ABFJiBv6IaUwWIASTYEYxmMaXDUR\nu2UNYu4ijwayindVrP+YvoSQyNViI0AYJvA/qhLqyv2XX+XfKotJ1+8m1BbxTyI=\n=Ff7X\n-----END PGP SIGNATURE-----\n", "payload": "tree a6fd422786b72b621fec4a3c21d7f019656f9b1d\nparent 20f8e660cafd9db3578b5ff005b84846f09d45f5\nparent caaeb92882a082bf1ac8b7d74c09ca0295c2ed10\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1616529483 +0000\ncommitter GitHub <noreply@github.com> 1616529483 +0000\n\nMerge #8178\n\n8178: Show item info when hovering intra doc links r=Veykril a=Veykril\n\n![r4uIITP0IZ](https://user-images.githubusercontent.com/3757771/112197618-91e2fb00-8c0c-11eb-9edc-a7923214d2b6.gif)\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99", "html_url": "https://github.com/rust-lang/rust/commit/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20f8e660cafd9db3578b5ff005b84846f09d45f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/20f8e660cafd9db3578b5ff005b84846f09d45f5", "html_url": "https://github.com/rust-lang/rust/commit/20f8e660cafd9db3578b5ff005b84846f09d45f5"}, {"sha": "caaeb92882a082bf1ac8b7d74c09ca0295c2ed10", "url": "https://api.github.com/repos/rust-lang/rust/commits/caaeb92882a082bf1ac8b7d74c09ca0295c2ed10", "html_url": "https://github.com/rust-lang/rust/commit/caaeb92882a082bf1ac8b7d74c09ca0295c2ed10"}], "stats": {"total": 434, "additions": 225, "deletions": 209}, "files": [{"sha": "5cd186565e3c0205bad25dcde91a9e5bf59b25f2", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99", "patch": "@@ -50,16 +50,16 @@ pub(crate) fn incoming_calls(db: &RootDatabase, position: FilePosition) -> Optio\n     for (file_id, references) in refs.references {\n         let file = sema.parse(file_id);\n         let file = file.syntax();\n-        for (r_range, _) in references {\n-            let token = file.token_at_offset(r_range.start()).next()?;\n+        for (relative_range, token) in references\n+            .into_iter()\n+            .filter_map(|(range, _)| Some(range).zip(file.token_at_offset(range.start()).next()))\n+        {\n             let token = sema.descend_into_macros(token);\n             // This target is the containing function\n             if let Some(nav) = token.ancestors().find_map(|node| {\n-                let fn_ = ast::Fn::cast(node)?;\n-                let def = sema.to_def(&fn_)?;\n+                let def = ast::Fn::cast(node).and_then(|fn_| sema.to_def(&fn_))?;\n                 def.try_to_nav(sema.db)\n             }) {\n-                let relative_range = r_range;\n                 calls.add(&nav, relative_range);\n             }\n         }\n@@ -87,7 +87,6 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n             let name_ref = call_node.name_ref()?;\n             let func_target = match call_node {\n                 FnCallNode::CallExpr(expr) => {\n-                    //FIXME: Type::as_callable is broken\n                     let callable = sema.type_of_expr(&expr.expr()?)?.as_callable(db)?;\n                     match callable.kind() {\n                         hir::CallableKind::Function(it) => it.try_to_nav(db),"}, {"sha": "0cee741acffc29b22f85cb9cefd3f2e615281080", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 154, "deletions": 106, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99", "patch": "@@ -1,4 +1,4 @@\n-//! Resolves and rewrites links in markdown documentation.\n+//! Extracts, resolves and rewrites links and intra-doc links in markdown documentation.\n \n use std::{convert::TryFrom, iter::once, ops::Range};\n \n@@ -15,7 +15,10 @@ use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n-use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n+use syntax::{\n+    ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    TokenAtOffset, T,\n+};\n \n use crate::{FilePosition, Semantics};\n \n@@ -60,29 +63,6 @@ pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Defi\n     out\n }\n \n-pub(crate) fn extract_definitions_from_markdown(\n-    markdown: &str,\n-) -> Vec<(String, Option<hir::Namespace>, Range<usize>)> {\n-    let mut res = vec![];\n-    let mut cb = |link: BrokenLink| {\n-        // These allocations are actually unnecessary but the lifetimes on BrokenLinkCallback are wrong\n-        // this is fixed in the repo but not on the crates.io release yet\n-        Some((\n-            /*url*/ link.reference.to_owned().into(),\n-            /*title*/ link.reference.to_owned().into(),\n-        ))\n-    };\n-    let doc = Parser::new_with_broken_link_callback(markdown, Options::empty(), Some(&mut cb));\n-    for (event, range) in doc.into_offset_iter() {\n-        if let Event::Start(Tag::Link(_, target, title)) = event {\n-            let link = if target.is_empty() { title } else { target };\n-            let (link, ns) = parse_link(&link);\n-            res.push((link.to_string(), ns, range));\n-        }\n-    }\n-    res\n-}\n-\n /// Remove all links in markdown documentation.\n pub(crate) fn remove_links(markdown: &str) -> String {\n     let mut drop_link = false;\n@@ -118,6 +98,105 @@ pub(crate) fn remove_links(markdown: &str) -> String {\n     out\n }\n \n+pub(crate) fn extract_definitions_from_markdown(\n+    markdown: &str,\n+) -> Vec<(Range<usize>, String, Option<hir::Namespace>)> {\n+    let mut res = vec![];\n+    let mut cb = |link: BrokenLink| {\n+        // These allocations are actually unnecessary but the lifetimes on BrokenLinkCallback are wrong\n+        // this is fixed in the repo but not on the crates.io release yet\n+        Some((\n+            /*url*/ link.reference.to_owned().into(),\n+            /*title*/ link.reference.to_owned().into(),\n+        ))\n+    };\n+    let doc = Parser::new_with_broken_link_callback(markdown, Options::empty(), Some(&mut cb));\n+    for (event, range) in doc.into_offset_iter() {\n+        if let Event::Start(Tag::Link(_, target, title)) = event {\n+            let link = if target.is_empty() { title } else { target };\n+            let (link, ns) = parse_intra_doc_link(&link);\n+            res.push((range, link.to_string(), ns));\n+        }\n+    }\n+    res\n+}\n+\n+/// Extracts a link from a comment at the given position returning the spanning range, link and\n+/// optionally it's namespace.\n+pub(crate) fn extract_positioned_link_from_comment(\n+    position: TextSize,\n+    comment: &ast::Comment,\n+) -> Option<(TextRange, String, Option<hir::Namespace>)> {\n+    let doc_comment = comment.doc_comment()?;\n+    let comment_start =\n+        comment.syntax().text_range().start() + TextSize::from(comment.prefix().len() as u32);\n+    let def_links = extract_definitions_from_markdown(doc_comment);\n+    let (range, def_link, ns) =\n+        def_links.into_iter().find_map(|(Range { start, end }, def_link, ns)| {\n+            let range = TextRange::at(\n+                comment_start + TextSize::from(start as u32),\n+                TextSize::from((end - start) as u32),\n+            );\n+            range.contains(position).then(|| (range, def_link, ns))\n+        })?;\n+    Some((range, def_link, ns))\n+}\n+\n+/// Turns a syntax node into it's [`Definition`] if it can hold docs.\n+pub(crate) fn doc_owner_to_def(\n+    sema: &Semantics<RootDatabase>,\n+    item: &SyntaxNode,\n+) -> Option<Definition> {\n+    let res: hir::ModuleDef = match_ast! {\n+        match item {\n+            ast::SourceFile(_it) => sema.scope(item).module()?.into(),\n+            ast::Fn(it) => sema.to_def(&it)?.into(),\n+            ast::Struct(it) => sema.to_def(&it)?.into(),\n+            ast::Enum(it) => sema.to_def(&it)?.into(),\n+            ast::Union(it) => sema.to_def(&it)?.into(),\n+            ast::Trait(it) => sema.to_def(&it)?.into(),\n+            ast::Const(it) => sema.to_def(&it)?.into(),\n+            ast::Static(it) => sema.to_def(&it)?.into(),\n+            ast::TypeAlias(it) => sema.to_def(&it)?.into(),\n+            ast::Variant(it) => sema.to_def(&it)?.into(),\n+            ast::Trait(it) => sema.to_def(&it)?.into(),\n+            ast::Impl(it) => return sema.to_def(&it).map(Definition::SelfType),\n+            ast::MacroRules(it) => return sema.to_def(&it).map(Definition::Macro),\n+            ast::TupleField(it) => return sema.to_def(&it).map(Definition::Field),\n+            ast::RecordField(it) => return sema.to_def(&it).map(Definition::Field),\n+            _ => return None,\n+        }\n+    };\n+    Some(Definition::ModuleDef(res))\n+}\n+\n+pub(crate) fn resolve_doc_path_for_def(\n+    db: &dyn HirDatabase,\n+    def: Definition,\n+    link: &str,\n+    ns: Option<hir::Namespace>,\n+) -> Option<hir::ModuleDef> {\n+    match def {\n+        Definition::ModuleDef(def) => match def {\n+            ModuleDef::Module(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Function(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Adt(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Variant(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Const(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Static(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Trait(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::TypeAlias(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::BuiltinType(_) => None,\n+        },\n+        Definition::Macro(it) => it.resolve_doc_path(db, &link, ns),\n+        Definition::Field(it) => it.resolve_doc_path(db, &link, ns),\n+        Definition::SelfType(_)\n+        | Definition::Local(_)\n+        | Definition::GenericParam(_)\n+        | Definition::Label(_) => None,\n+    }\n+}\n+\n // FIXME:\n // BUG: For Option::Some\n // Returns https://doc.rust-lang.org/nightly/core/prelude/v1/enum.Option.html#variant.Some\n@@ -197,26 +276,8 @@ fn rewrite_intra_doc_link(\n     title: &str,\n ) -> Option<(String, String)> {\n     let link = if target.is_empty() { title } else { target };\n-    let (link, ns) = parse_link(link);\n-    let resolved = match def {\n-        Definition::ModuleDef(def) => match def {\n-            ModuleDef::Module(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Function(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Adt(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Variant(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Const(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Static(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::Trait(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::TypeAlias(it) => it.resolve_doc_path(db, link, ns),\n-            ModuleDef::BuiltinType(_) => return None,\n-        },\n-        Definition::Macro(it) => it.resolve_doc_path(db, link, ns),\n-        Definition::Field(it) => it.resolve_doc_path(db, link, ns),\n-        Definition::SelfType(_)\n-        | Definition::Local(_)\n-        | Definition::GenericParam(_)\n-        | Definition::Label(_) => return None,\n-    }?;\n+    let (link, ns) = parse_intra_doc_link(link);\n+    let resolved = resolve_doc_path_for_def(db, def, link, ns)?;\n     let krate = resolved.module(db)?.krate();\n     let canonical_path = resolved.canonical_path(db)?;\n     let mut new_url = get_doc_url(db, &krate)?\n@@ -228,24 +289,23 @@ fn rewrite_intra_doc_link(\n         .ok()?;\n \n     if let ModuleDef::Trait(t) = resolved {\n-        let items = t.items(db);\n-        if let Some(field_or_assoc_item) = items.iter().find_map(|assoc_item| {\n+        if let Some(assoc_item) = t.items(db).into_iter().find_map(|assoc_item| {\n             if let Some(name) = assoc_item.name(db) {\n                 if *link == format!(\"{}::{}\", canonical_path, name) {\n-                    return Some(FieldOrAssocItem::AssocItem(*assoc_item));\n+                    return Some(assoc_item);\n                 }\n             }\n             None\n         }) {\n-            if let Some(fragment) = get_symbol_fragment(db, &field_or_assoc_item) {\n+            if let Some(fragment) =\n+                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(assoc_item))\n+            {\n                 new_url = new_url.join(&fragment).ok()?;\n             }\n         };\n     }\n \n-    let new_target = new_url.into_string();\n-    let new_title = strip_prefixes_suffixes(title);\n-    Some((new_target, new_title.to_string()))\n+    Some((new_url.into_string(), strip_prefixes_suffixes(title).to_string()))\n }\n \n /// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n@@ -322,73 +382,61 @@ fn map_links<'e>(\n     })\n }\n \n-fn parse_link(s: &str) -> (&str, Option<hir::Namespace>) {\n-    let path = strip_prefixes_suffixes(s);\n-    let ns = ns_from_intra_spec(s);\n-    (path, ns)\n-}\n-\n-/// Strip prefixes, suffixes, and inline code marks from the given string.\n-fn strip_prefixes_suffixes(mut s: &str) -> &str {\n-    s = s.trim_matches('`');\n-\n-    [\n-        (TYPES.0.iter(), TYPES.1.iter()),\n-        (VALUES.0.iter(), VALUES.1.iter()),\n-        (MACROS.0.iter(), MACROS.1.iter()),\n-    ]\n-    .iter()\n-    .for_each(|(prefixes, suffixes)| {\n-        prefixes.clone().for_each(|prefix| s = s.trim_start_matches(*prefix));\n-        suffixes.clone().for_each(|suffix| s = s.trim_end_matches(*suffix));\n-    });\n-    s.trim_start_matches('@').trim()\n-}\n-\n-static TYPES: ([&str; 7], [&str; 0]) =\n-    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\"], []);\n-static VALUES: ([&str; 8], [&str; 1]) =\n+const TYPES: ([&str; 9], [&str; 0]) =\n+    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\", \"prim\", \"primitive\"], []);\n+const VALUES: ([&str; 8], [&str; 1]) =\n     ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n-static MACROS: ([&str; 1], [&str; 1]) = ([\"macro\"], [\"!\"]);\n+const MACROS: ([&str; 2], [&str; 1]) = ([\"macro\", \"derive\"], [\"!\"]);\n \n /// Extract the specified namespace from an intra-doc-link if one exists.\n ///\n /// # Examples\n ///\n-/// * `struct MyStruct` -> `Namespace::Types`\n-/// * `panic!` -> `Namespace::Macros`\n-/// * `fn@from_intra_spec` -> `Namespace::Values`\n-fn ns_from_intra_spec(s: &str) -> Option<hir::Namespace> {\n+/// * `struct MyStruct` -> (\"MyStruct\", `Namespace::Types`)\n+/// * `panic!` -> (\"panic\", `Namespace::Macros`)\n+/// * `fn@from_intra_spec` -> (\"from_intra_spec\", `Namespace::Values`)\n+fn parse_intra_doc_link(s: &str) -> (&str, Option<hir::Namespace>) {\n+    let s = s.trim_matches('`');\n+\n     [\n         (hir::Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n         (hir::Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n         (hir::Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n     ]\n     .iter()\n-    .filter(|(_ns, (prefixes, suffixes))| {\n-        prefixes\n-            .clone()\n-            .map(|prefix| {\n-                s.starts_with(*prefix)\n-                    && s.chars()\n-                        .nth(prefix.len() + 1)\n-                        .map(|c| c == '@' || c == ' ')\n-                        .unwrap_or(false)\n-            })\n-            .any(|cond| cond)\n-            || suffixes\n-                .clone()\n-                .map(|suffix| {\n-                    s.starts_with(*suffix)\n-                        && s.chars()\n-                            .nth(suffix.len() + 1)\n-                            .map(|c| c == '@' || c == ' ')\n-                            .unwrap_or(false)\n-                })\n-                .any(|cond| cond)\n+    .cloned()\n+    .find_map(|(ns, (mut prefixes, mut suffixes))| {\n+        if let Some(prefix) = prefixes.find(|&&prefix| {\n+            s.starts_with(prefix)\n+                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n+        }) {\n+            Some((&s[prefix.len() + 1..], ns))\n+        } else {\n+            suffixes.find_map(|&suffix| s.strip_suffix(suffix).zip(Some(ns)))\n+        }\n+    })\n+    .map_or((s, None), |(s, ns)| (s, Some(ns)))\n+}\n+\n+fn strip_prefixes_suffixes(s: &str) -> &str {\n+    [\n+        (TYPES.0.iter(), TYPES.1.iter()),\n+        (VALUES.0.iter(), VALUES.1.iter()),\n+        (MACROS.0.iter(), MACROS.1.iter()),\n+    ]\n+    .iter()\n+    .cloned()\n+    .find_map(|(mut prefixes, mut suffixes)| {\n+        if let Some(prefix) = prefixes.find(|&&prefix| {\n+            s.starts_with(prefix)\n+                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n+        }) {\n+            Some(&s[prefix.len() + 1..])\n+        } else {\n+            suffixes.find_map(|&suffix| s.strip_suffix(suffix))\n+        }\n     })\n-    .map(|(ns, (_, _))| *ns)\n-    .next()\n+    .unwrap_or(s)\n }\n \n /// Get the root URL for the documentation of a crate."}, {"sha": "a2c97061f2f5c61320f60468ada328eee7bc3172", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 8, "deletions": 58, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99", "patch": "@@ -1,18 +1,14 @@\n-use std::ops::Range;\n-\n use either::Either;\n-use hir::{HasAttrs, ModuleDef, Semantics};\n+use hir::Semantics;\n use ide_db::{\n-    defs::{Definition, NameClass, NameRefClass},\n+    defs::{NameClass, NameRefClass},\n     RootDatabase,\n };\n-use syntax::{\n-    ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TextRange, TextSize,\n-    TokenAtOffset, T,\n-};\n+use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n \n use crate::{\n-    display::TryToNav, doc_links::extract_definitions_from_markdown, runnables::doc_owner_to_def,\n+    display::TryToNav,\n+    doc_links::{doc_owner_to_def, extract_positioned_link_from_comment, resolve_doc_path_for_def},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n \n@@ -35,7 +31,9 @@ pub(crate) fn goto_definition(\n     let token = sema.descend_into_macros(original_token.clone());\n     let parent = token.parent()?;\n     if let Some(comment) = ast::Comment::cast(token) {\n-        let nav = def_for_doc_comment(&sema, position, &comment)?.try_to_nav(db)?;\n+        let (_, link, ns) = extract_positioned_link_from_comment(position.offset, &comment)?;\n+        let def = doc_owner_to_def(&sema, &parent)?;\n+        let nav = resolve_doc_path_for_def(db, def, &link, ns)?.try_to_nav(db)?;\n         return Some(RangeInfo::new(original_token.text_range(), vec![nav]));\n     }\n \n@@ -61,54 +59,6 @@ pub(crate) fn goto_definition(\n     Some(RangeInfo::new(original_token.text_range(), nav.into_iter().collect()))\n }\n \n-fn def_for_doc_comment(\n-    sema: &Semantics<RootDatabase>,\n-    position: FilePosition,\n-    doc_comment: &ast::Comment,\n-) -> Option<hir::ModuleDef> {\n-    let parent = doc_comment.syntax().parent()?;\n-    let (link, ns) = extract_positioned_link_from_comment(position, doc_comment)?;\n-\n-    let def = doc_owner_to_def(sema, parent)?;\n-    match def {\n-        Definition::ModuleDef(def) => match def {\n-            ModuleDef::Module(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Function(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Adt(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Variant(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Const(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Static(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Trait(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::TypeAlias(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::BuiltinType(_) => return None,\n-        },\n-        Definition::Macro(it) => it.resolve_doc_path(sema.db, &link, ns),\n-        Definition::Field(it) => it.resolve_doc_path(sema.db, &link, ns),\n-        Definition::SelfType(_)\n-        | Definition::Local(_)\n-        | Definition::GenericParam(_)\n-        | Definition::Label(_) => return None,\n-    }\n-}\n-\n-fn extract_positioned_link_from_comment(\n-    position: FilePosition,\n-    comment: &ast::Comment,\n-) -> Option<(String, Option<hir::Namespace>)> {\n-    let doc_comment = comment.doc_comment()?;\n-    let comment_start =\n-        comment.syntax().text_range().start() + TextSize::from(comment.prefix().len() as u32);\n-    let def_links = extract_definitions_from_markdown(doc_comment);\n-    let (def_link, ns, _) = def_links.into_iter().find(|&(_, _, Range { start, end })| {\n-        TextRange::at(\n-            comment_start + TextSize::from(start as u32),\n-            TextSize::from((end - start) as u32),\n-        )\n-        .contains(position.offset)\n-    })?;\n-    Some((def_link, ns))\n-}\n-\n fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n     fn priority(n: &SyntaxToken) -> usize {"}, {"sha": "c4308947650ec33da14e10a642664035177f8c3e", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 54, "deletions": 9, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99", "patch": "@@ -11,11 +11,14 @@ use ide_db::{\n };\n use itertools::Itertools;\n use stdx::format_to;\n-use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n+use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n \n use crate::{\n     display::{macro_label, TryToNav},\n-    doc_links::{remove_links, rewrite_links},\n+    doc_links::{\n+        doc_owner_to_def, extract_positioned_link_from_comment, remove_links,\n+        resolve_doc_path_for_def, rewrite_links,\n+    },\n     markdown_remove::remove_markdown,\n     markup::Markup,\n     runnables::{runnable_fn, runnable_mod},\n@@ -93,20 +96,35 @@ pub(crate) fn hover(\n     let mut res = HoverResult::default();\n \n     let node = token.parent()?;\n+    let mut range = None;\n     let definition = match_ast! {\n         match node {\n             // we don't use NameClass::referenced_or_defined here as we do not want to resolve\n             // field pattern shorthands to their definition\n             ast::Name(name) => NameClass::classify(&sema, &name).and_then(|class| match class {\n                 NameClass::ConstReference(def) => Some(def),\n-                def => def.defined(sema.db),\n+                def => def.defined(db),\n             }),\n-            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|d| d.referenced(sema.db)),\n-            ast::Lifetime(lifetime) => NameClass::classify_lifetime(&sema, &lifetime)\n-                .map_or_else(|| NameRefClass::classify_lifetime(&sema, &lifetime).map(|d| d.referenced(sema.db)), |d| d.defined(sema.db)),\n-            _ => None,\n+            ast::NameRef(name_ref) => {\n+                NameRefClass::classify(&sema, &name_ref).map(|d| d.referenced(db))\n+            },\n+            ast::Lifetime(lifetime) => NameClass::classify_lifetime(&sema, &lifetime).map_or_else(\n+                || NameRefClass::classify_lifetime(&sema, &lifetime).map(|d| d.referenced(db)),\n+                |d| d.defined(db),\n+            ),\n+\n+            _ => ast::Comment::cast(token.clone())\n+                .and_then(|comment| {\n+                    let (idl_range, link, ns) =\n+                        extract_positioned_link_from_comment(position.offset, &comment)?;\n+                    range = Some(idl_range);\n+                    let def = doc_owner_to_def(&sema, &node)?;\n+                    resolve_doc_path_for_def(db, def, &link, ns)\n+                })\n+                .map(Definition::ModuleDef),\n         }\n     };\n+\n     if let Some(definition) = definition {\n         let famous_defs = match &definition {\n             Definition::ModuleDef(ModuleDef::BuiltinType(_)) => {\n@@ -128,15 +146,16 @@ pub(crate) fn hover(\n                 res.actions.push(action);\n             }\n \n-            let range = sema.original_range(&node).range;\n+            let range = range.unwrap_or_else(|| sema.original_range(&node).range);\n             return Some(RangeInfo::new(range, res));\n         }\n     }\n \n     if token.kind() == syntax::SyntaxKind::COMMENT {\n-        // don't highlight the entire parent node on comment hover\n+        cov_mark::hit!(no_highlight_on_comment_hover);\n         return None;\n     }\n+\n     if let res @ Some(_) = hover_for_keyword(&sema, links_in_hover, markdown, &token) {\n         return res;\n     }\n@@ -3483,6 +3502,7 @@ fn foo$0() {}\n \n     #[test]\n     fn hover_comments_dont_highlight_parent() {\n+        cov_mark::check!(no_highlight_on_comment_hover);\n         check_hover_no_result(\n             r#\"\n fn no_hover() {\n@@ -3755,4 +3775,29 @@ fn main() {\n             \"#]],\n         )\n     }\n+\n+    #[test]\n+    fn hover_intra_doc_links() {\n+        check(\n+            r#\"\n+/// This is the [`foo`](foo$0) function.\n+fn foo() {}\n+\"#,\n+            expect![[r#\"\n+                *[`foo`](foo)*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                fn foo()\n+                ```\n+\n+                ---\n+\n+                This is the [`foo`](https://docs.rs/test/*/test/fn.foo.html) function.\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "5b488e2c588d5374818f93e3451d1abb71cd6ea8", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99", "patch": "@@ -7,17 +7,13 @@ use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics};\n use ide_assists::utils::test_related_attribute;\n use ide_db::{\n     base_db::{FilePosition, FileRange},\n-    defs::Definition,\n     helpers::visit_file_defs,\n     search::SearchScope,\n     RootDatabase, SymbolKind,\n };\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n-use syntax::{\n-    ast::{self, AstNode, AttrsOwner},\n-    match_ast, SyntaxNode,\n-};\n+use syntax::ast::{self, AstNode, AttrsOwner};\n \n use crate::{\n     display::{ToNav, TryToNav},\n@@ -271,28 +267,6 @@ pub(crate) fn runnable_mod(sema: &Semantics<RootDatabase>, def: hir::Module) ->\n     Some(Runnable { nav, kind: RunnableKind::TestMod { path }, cfg })\n }\n \n-// FIXME: figure out a proper API here.\n-pub(crate) fn doc_owner_to_def(\n-    sema: &Semantics<RootDatabase>,\n-    item: SyntaxNode,\n-) -> Option<Definition> {\n-    let res: hir::ModuleDef = match_ast! {\n-        match item {\n-            ast::SourceFile(_it) => sema.scope(&item).module()?.into(),\n-            ast::Fn(it) => sema.to_def(&it)?.into(),\n-            ast::Struct(it) => sema.to_def(&it)?.into(),\n-            ast::Enum(it) => sema.to_def(&it)?.into(),\n-            ast::Union(it) => sema.to_def(&it)?.into(),\n-            ast::Trait(it) => sema.to_def(&it)?.into(),\n-            ast::Const(it) => sema.to_def(&it)?.into(),\n-            ast::Static(it) => sema.to_def(&it)?.into(),\n-            ast::TypeAlias(it) => sema.to_def(&it)?.into(),\n-            _ => return None,\n-        }\n-    };\n-    Some(Definition::ModuleDef(res))\n-}\n-\n fn module_def_doctest(sema: &Semantics<RootDatabase>, def: hir::ModuleDef) -> Option<Runnable> {\n     let attrs = match def {\n         hir::ModuleDef::Module(it) => it.attrs(sema.db),"}, {"sha": "38bf49348963503c79fa8ef620670088f6bebd6f", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=c6d6a7d41213dc06bb1f36745d5eaf8b91a99b99", "patch": "@@ -190,10 +190,10 @@ pub(super) fn doc_comment(\n                     intra_doc_links.extend(\n                         extract_definitions_from_markdown(line)\n                             .into_iter()\n-                            .filter_map(|(link, ns, range)| {\n-                                validate_intra_doc_link(sema.db, &def, &link, ns).zip(Some(range))\n+                            .filter_map(|(range, link, ns)| {\n+                                Some(range).zip(validate_intra_doc_link(sema.db, &def, &link, ns))\n                             })\n-                            .map(|(def, Range { start, end })| {\n+                            .map(|(Range { start, end }, def)| {\n                                 (\n                                     def,\n                                     TextRange::at("}]}