{"sha": "1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNDg3YTg5MDY5NWU3ZDZkZmJmZTVkY2Q3ZDRmYTBlOGNhODAwM2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-08-28T01:46:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-08-28T01:46:52Z"}, "message": "Implement generalized object and type parameter bounds (Fixes #16462)", "tree": {"sha": "552fabade603ab0d148a49ae3cf1abd3f399740a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/552fabade603ab0d148a49ae3cf1abd3f399740a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "comment_count": 17, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "html_url": "https://github.com/rust-lang/rust/commit/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ee047ae1ffab454270bc1859b3beef3556ef8f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee047ae1ffab454270bc1859b3beef3556ef8f9", "html_url": "https://github.com/rust-lang/rust/commit/3ee047ae1ffab454270bc1859b3beef3556ef8f9"}], "stats": {"total": 9863, "additions": 6746, "deletions": 3117}, "files": [{"sha": "13d4a0a1f0a08d4a0a70e9d9944066aa4453193e", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -105,9 +105,9 @@ pub trait BoxAny {\n }\n \n #[stable]\n-impl BoxAny for Box<Any> {\n+impl BoxAny for Box<Any+'static> {\n     #[inline]\n-    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n+    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any+'static>> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n@@ -132,7 +132,7 @@ impl<T: fmt::Show> fmt::Show for Box<T> {\n     }\n }\n \n-impl fmt::Show for Box<Any> {\n+impl fmt::Show for Box<Any+'static> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Box<Any>\")\n     }"}, {"sha": "47c56375ada180770cff843bd4a847a0964cd46e", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -49,27 +49,46 @@ struct Node<T> {\n     value: T,\n }\n \n-/// An iterator over references to the items of a `DList`.\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct Items<'a, T> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n+/// An iterator over references to the items of a `DList`.\n+#[cfg(not(stage0))]\n+pub struct Items<'a, T:'a> {\n+    head: &'a Link<T>,\n+    tail: Rawlink<Node<T>>,\n+    nelem: uint,\n+}\n+\n // FIXME #11820: the &'a Option<> of the Link stops clone working.\n impl<'a, T> Clone for Items<'a, T> {\n     fn clone(&self) -> Items<'a, T> { *self }\n }\n \n-/// An iterator over mutable references to the items of a `DList`.\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct MutItems<'a, T> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n-/// A consuming iterator over the items of a `DList`.\n+/// An iterator over mutable references to the items of a `DList`.\n+#[cfg(not(stage0))]\n+pub struct MutItems<'a, T:'a> {\n+    list: &'a mut DList<T>,\n+    head: Rawlink<Node<T>>,\n+    tail: Rawlink<Node<T>>,\n+    nelem: uint,\n+}\n+\n+/// An iterator over mutable references to the items of a `DList`.\n #[deriving(Clone)]\n pub struct MoveItems<T> {\n     list: DList<T>"}, {"sha": "905078ccc3c8c424c3a792b85fa0009725cb3d57", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -515,11 +515,18 @@ impl<T: Ord> PriorityQueue<T> {\n     }\n }\n \n-/// `PriorityQueue` iterator.\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct Items <'a, T> {\n     iter: slice::Items<'a, T>,\n }\n \n+/// `PriorityQueue` iterator.\n+#[cfg(not(stage0))]\n+pub struct Items <'a, T:'a> {\n+    iter: slice::Items<'a, T>,\n+}\n+\n impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'a T)> { self.iter.next() }"}, {"sha": "6b293c9f4d8b248f6dfbb46e932b9e0e94964fb8", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -293,14 +293,24 @@ impl<T> RingBuf<T> {\n     }\n }\n \n-/// `RingBuf` iterator.\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct Items<'a, T> {\n     lo: uint,\n     index: uint,\n     rindex: uint,\n     elts: &'a [Option<T>],\n }\n \n+/// `RingBuf` iterator.\n+#[cfg(not(stage0))]\n+pub struct Items<'a, T:'a> {\n+    lo: uint,\n+    index: uint,\n+    rindex: uint,\n+    elts: &'a [Option<T>],\n+}\n+\n impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n@@ -348,13 +358,22 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-/// `RingBuf` mutable iterator.\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct MutItems<'a, T> {\n     remaining1: &'a mut [Option<T>],\n     remaining2: &'a mut [Option<T>],\n     nelts: uint,\n }\n \n+/// `RingBuf` mutable iterator.\n+#[cfg(not(stage0))]\n+pub struct MutItems<'a, T:'a> {\n+    remaining1: &'a mut [Option<T>],\n+    remaining2: &'a mut [Option<T>],\n+    nelts: uint,\n+}\n+\n impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n     #[allow(deprecated)] // mut_shift_ref"}, {"sha": "5ef1dd2ab2277e6bf773c889a29e044a751d66b0", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -489,19 +489,37 @@ macro_rules! double_ended_iterator {\n     }\n }\n \n-/// Forward iterator over a map.\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct Entries<'a, T> {\n     front: uint,\n     back: uint,\n     iter: slice::Items<'a, Option<T>>\n }\n \n+/// Forward iterator over a map.\n+#[cfg(not(stage0))]\n+pub struct Entries<'a, T:'a> {\n+    front: uint,\n+    back: uint,\n+    iter: slice::Items<'a, Option<T>>\n+}\n+\n iterator!(impl Entries -> (uint, &'a T), get_ref)\n double_ended_iterator!(impl Entries -> (uint, &'a T), get_ref)\n \n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n+pub struct MutEntries<'a, T> {\n+    front: uint,\n+    back: uint,\n+    iter: slice::MutItems<'a, Option<T>>\n+}\n+\n /// Forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-pub struct MutEntries<'a, T> {\n+#[cfg(not(stage0))]\n+pub struct MutEntries<'a, T:'a> {\n     front: uint,\n     back: uint,\n     iter: slice::MutItems<'a, Option<T>>"}, {"sha": "6bb1e4a5ad09cd967ee3453af3324d9deff1fb9f", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 114, "deletions": 16, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -668,7 +668,8 @@ impl<K: Ord, V> TreeMap<K, V> {\n     }\n }\n \n-/// A lazy forward iterator over a map.\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct Entries<'a, K, V> {\n     stack: Vec<&'a TreeNode<K, V>>,\n     // See the comment on MutEntries; this is just to allow\n@@ -679,13 +680,32 @@ pub struct Entries<'a, K, V> {\n     remaining_max: uint\n }\n \n-/// Lazy backward iterator over a map.\n+/// Lazy forward iterator over a map\n+#[cfg(not(stage0))]\n+pub struct Entries<'a, K:'a, V:'a> {\n+    stack: Vec<&'a TreeNode<K, V>>,\n+    // See the comment on MutEntries; this is just to allow\n+    // code-sharing (for this immutable-values iterator it *could* very\n+    // well be Option<&'a TreeNode<K,V>>).\n+    node: *const TreeNode<K, V>,\n+    remaining_min: uint,\n+    remaining_max: uint\n+}\n+\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct RevEntries<'a, K, V> {\n     iter: Entries<'a, K, V>,\n }\n \n-/// A lazy forward iterator over a map that allows for the mutation of\n-/// the values.\n+/// Lazy backward iterator over a map\n+#[cfg(not(stage0))]\n+pub struct RevEntries<'a, K:'a, V:'a> {\n+    iter: Entries<'a, K, V>,\n+}\n+\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct MutEntries<'a, K, V> {\n     stack: Vec<&'a mut TreeNode<K, V>>,\n     // Unfortunately, we require some unsafe-ness to get around the\n@@ -712,11 +732,46 @@ pub struct MutEntries<'a, K, V> {\n     remaining_max: uint\n }\n \n-/// Lazy backward iterator over a map.\n+/// Lazy forward iterator over a map that allows for the mutation of\n+/// the values.\n+#[cfg(not(stage0))]\n+pub struct MutEntries<'a, K:'a, V:'a> {\n+    stack: Vec<&'a mut TreeNode<K, V>>,\n+    // Unfortunately, we require some unsafe-ness to get around the\n+    // fact that we would be storing a reference *into* one of the\n+    // nodes in the stack.\n+    //\n+    // As far as the compiler knows, this would let us invalidate the\n+    // reference by assigning a new value to this node's position in\n+    // its parent, which would cause this current one to be\n+    // deallocated so this reference would be invalid. (i.e. the\n+    // compilers complaints are 100% correct.)\n+    //\n+    // However, as far as you humans reading this code know (or are\n+    // about to know, if you haven't read far enough down yet), we are\n+    // only reading from the TreeNode.{left,right} fields. the only\n+    // thing that is ever mutated is the .value field (although any\n+    // actual mutation that happens is done externally, by the\n+    // iterator consumer). So, don't be so concerned, rustc, we've got\n+    // it under control.\n+    //\n+    // (This field can legitimately be null.)\n+    node: *mut TreeNode<K, V>,\n+    remaining_min: uint,\n+    remaining_max: uint\n+}\n+\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct RevMutEntries<'a, K, V> {\n     iter: MutEntries<'a, K, V>,\n }\n \n+/// Lazy backward iterator over a map\n+#[cfg(not(stage0))]\n+pub struct RevMutEntries<'a, K:'a, V:'a> {\n+    iter: MutEntries<'a, K, V>,\n+}\n \n /// TreeMap keys iterator.\n pub type Keys<'a, K, V> =\n@@ -885,9 +940,7 @@ fn mut_deref<K, V>(x: &mut Option<Box<TreeNode<K, V>>>)\n     }\n }\n \n-\n-\n-/// A lazy forward iterator over a map that consumes the map while iterating.\n+/// Lazy forward iterator over a map that consumes the map while iterating\n pub struct MoveEntries<K, V> {\n     stack: Vec<TreeNode<K, V>>,\n     remaining: uint\n@@ -1322,45 +1375,90 @@ impl<T: Ord> TreeSet<T> {\n     }\n }\n \n-/// A lazy forward iterator over a set.\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct SetItems<'a, T> {\n     iter: Entries<'a, T, ()>\n }\n \n-/// Lazy backward iterator over a set.\n+/// A lazy forward iterator over a set.\n+#[cfg(not(stage0))]\n+pub struct SetItems<'a, T:'a> {\n+    iter: Entries<'a, T, ()>\n+}\n+\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct RevSetItems<'a, T> {\n     iter: RevEntries<'a, T, ()>\n }\n \n+/// A lazy backward iterator over a set.\n+#[cfg(not(stage0))]\n+pub struct RevSetItems<'a, T:'a> {\n+    iter: RevEntries<'a, T, ()>\n+}\n+\n /// A lazy forward iterator over a set that consumes the set while iterating.\n pub type MoveSetItems<T> = iter::Map<'static, (T, ()), T, MoveEntries<T, ()>>;\n \n-/// A lazy iterator producing elements in the set difference (in-order).\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct DifferenceItems<'a, T> {\n     a: Peekable<&'a T, SetItems<'a, T>>,\n     b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n-/// A lazy iterator producing elements in the set symmetric difference (in-order).\n+/// A lazy iterator producing elements in the set difference (in-order).\n+#[cfg(not(stage0))]\n+pub struct DifferenceItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct SymDifferenceItems<'a, T> {\n     a: Peekable<&'a T, SetItems<'a, T>>,\n     b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n-/// A lazy iterator producing elements in the set intersection (in-order).\n+/// A lazy iterator producing elements in the set symmetric difference (in-order).\n+#[cfg(not(stage0))]\n+pub struct SymDifferenceItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct IntersectionItems<'a, T> {\n     a: Peekable<&'a T, SetItems<'a, T>>,\n     b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n-/// A lazy iterator producing elements in the set union (in-order).\n+/// A lazy iterator producing elements in the set intersection (in-order).\n+#[cfg(not(stage0))]\n+pub struct IntersectionItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct UnionItems<'a, T> {\n     a: Peekable<&'a T, SetItems<'a, T>>,\n     b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n-/// Compare `x` and `y`, but return `short` if x is None and `long` if y is\n-/// `None`.\n+/// A lazy iterator producing elements in the set union (in-order).\n+#[cfg(not(stage0))]\n+pub struct UnionItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n                         short: Ordering, long: Ordering) -> Ordering {\n     match (x, y) {"}, {"sha": "e79ec67cba0ba2ce2e3371f19c28bf450313fe5d", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -857,17 +857,37 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n     return ret;\n }\n \n-/// A forward iterator over a map.\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n pub struct Entries<'a, T> {\n     stack: [slice::Items<'a, Child<T>>, .. NUM_CHUNKS],\n     length: uint,\n     remaining_min: uint,\n     remaining_max: uint\n }\n \n+/// A forward iterator over a map.\n+#[cfg(not(stage0))]\n+pub struct Entries<'a, T:'a> {\n+    stack: [slice::Items<'a, Child<T>>, .. NUM_CHUNKS],\n+    length: uint,\n+    remaining_min: uint,\n+    remaining_max: uint\n+}\n+\n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n+pub struct MutEntries<'a, T> {\n+    stack: [slice::MutItems<'a, Child<T>>, .. NUM_CHUNKS],\n+    length: uint,\n+    remaining_min: uint,\n+    remaining_max: uint\n+}\n+\n /// A forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-pub struct MutEntries<'a, T> {\n+#[cfg(not(stage0))]\n+pub struct MutEntries<'a, T:'a> {\n     stack: [slice::MutItems<'a, Child<T>>, .. NUM_CHUNKS],\n     length: uint,\n     remaining_min: uint,"}, {"sha": "f383677ed14775f11156ab1fe56c2999dc360ba1", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -1620,9 +1620,13 @@ pub struct MoveItems<T> {\n \n impl<T> Iterator<T> for MoveItems<T> {\n     #[inline]\n-    fn next(&mut self) -> Option<T> {\n+    fn next<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n-            self.iter.next().map(|x| ptr::read(x))\n+            // Unsafely transmute from Items<'static, T> to Items<'a,\n+            // T> because otherwise the type checker requires that T\n+            // be bounded by 'static.\n+            let iter: &mut Items<'a, T> = mem::transmute(&mut self.iter);\n+            iter.next().map(|x| ptr::read(x))\n         }\n     }\n \n@@ -1634,9 +1638,13 @@ impl<T> Iterator<T> for MoveItems<T> {\n \n impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n+    fn next_back<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n-            self.iter.next_back().map(|x| ptr::read(x))\n+            // Unsafely transmute from Items<'static, T> to Items<'a,\n+            // T> because otherwise the type checker requires that T\n+            // be bounded by 'static.\n+            let iter: &mut Items<'a, T> = mem::transmute(&mut self.iter);\n+            iter.next_back().map(|x| ptr::read(x))\n         }\n     }\n }"}, {"sha": "625b89b3bae7704d68e61b0c38cdefe4ef6313da", "filename": "src/libcore/any.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -132,7 +132,7 @@ pub trait AnyRefExt<'a> {\n }\n \n #[stable]\n-impl<'a> AnyRefExt<'a> for &'a Any {\n+impl<'a> AnyRefExt<'a> for &'a Any+'a {\n     #[inline]\n     #[stable]\n     fn is<T: 'static>(self) -> bool {\n@@ -181,7 +181,7 @@ pub trait AnyMutRefExt<'a> {\n }\n \n #[stable]\n-impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n+impl<'a> AnyMutRefExt<'a> for &'a mut Any+'a {\n     #[inline]\n     #[unstable = \"naming conventions around acquiring references may change\"]\n     fn downcast_mut<T: 'static>(self) -> Option<&'a mut T> {"}, {"sha": "4cbe7d6d963fc5004730914972e9360f79bfa2a7", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -324,6 +324,16 @@ impl<T: PartialEq> PartialEq for RefCell<T> {\n \n /// Wraps a borrowed reference to a value in a `RefCell` box.\n #[unstable]\n+#[cfg(not(stage0))]\n+pub struct Ref<'b, T:'b> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _parent: &'b RefCell<T>\n+}\n+\n+/// Dox.\n+#[unstable]\n+#[cfg(stage0)]\n pub struct Ref<'b, T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -369,6 +379,16 @@ pub fn clone_ref<'b, T>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n \n /// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n #[unstable]\n+#[cfg(not(stage0))]\n+pub struct RefMut<'b, T:'b> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _parent: &'b RefCell<T>\n+}\n+\n+/// Dox.\n+#[unstable]\n+#[cfg(stage0)]\n pub struct RefMut<'b, T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref"}, {"sha": "c36150eb964e509dc1807244b29c62b4d3a1a9cd", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -102,6 +102,13 @@ pub fn try_finally<T,U,R>(mutate: &mut T,\n     try_fn(&mut *f.mutate, drop)\n }\n \n+#[cfg(not(stage0))]\n+struct Finallyalizer<'a,A:'a> {\n+    mutate: &'a mut A,\n+    dtor: |&mut A|: 'a\n+}\n+\n+#[cfg(stage0)]\n struct Finallyalizer<'a,A> {\n     mutate: &'a mut A,\n     dtor: |&mut A|: 'a"}, {"sha": "f7ff92f5ce39bc669225d9e1c02e4407666bb8b9", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -92,7 +92,7 @@ pub struct Formatter<'a> {\n     /// Optionally specified precision for numeric types\n     pub precision: Option<uint>,\n \n-    buf: &'a mut FormatWriter,\n+    buf: &'a mut FormatWriter+'a,\n     curarg: slice::Items<'a, Argument<'a>>,\n     args: &'a [Argument<'a>],\n }\n@@ -524,7 +524,7 @@ impl<'a, T: Show> Show for &'a T {\n impl<'a, T: Show> Show for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n }\n-impl<'a> Show for &'a Show {\n+impl<'a> Show for &'a Show+'a {\n     fn fmt(&self, f: &mut Formatter) -> Result { (*self).fmt(f) }\n }\n \n@@ -692,7 +692,7 @@ macro_rules! tuple (\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-impl<'a> Show for &'a any::Any {\n+impl<'a> Show for &'a any::Any+'a {\n     fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n }\n "}, {"sha": "7df8a7864d93a34bc1ddc90f1b533f8135e3dd28", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -673,7 +673,7 @@ pub trait MutableDoubleEndedIterator {\n     fn reverse_(&mut self);\n }\n \n-impl<'a, A, T: DoubleEndedIterator<&'a mut A>> MutableDoubleEndedIterator for T {\n+impl<'a, A:'a, T: DoubleEndedIterator<&'a mut A>> MutableDoubleEndedIterator for T {\n     // FIXME: #5898: should be called `reverse`\n     /// Use an iterator to reverse a container in-place\n     fn reverse_(&mut self) {\n@@ -777,18 +777,26 @@ impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterato\n \n /// A mutable reference to an iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[cfg(not(stage0))]\n+pub struct ByRef<'a, T:'a> {\n+    iter: &'a mut T\n+}\n+\n+/// Dox\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[cfg(stage0)]\n pub struct ByRef<'a, T> {\n     iter: &'a mut T\n }\n \n-impl<'a, A, T: Iterator<A>> Iterator<A> for ByRef<'a, T> {\n+impl<'a, A, T: Iterator<A>+'a> Iterator<A> for ByRef<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.iter.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for ByRef<'a, T> {\n+impl<'a, A, T: DoubleEndedIterator<A>+'a> DoubleEndedIterator<A> for ByRef<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.iter.next_back() }\n }"}, {"sha": "050e23481116317cf7a349eb3de260261b50828c", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -58,7 +58,7 @@\n \n #![no_std]\n #![feature(globs, intrinsics, lang_items, macro_rules, managed_boxes, phase)]\n-#![feature(simd, unsafe_destructor)]\n+#![feature(simd, unsafe_destructor, issue_5723_bootstrap)]\n #![deny(missing_doc)]\n \n mod macros;"}, {"sha": "947fa2ec92e5e7b77b1ad839a54edda3e300420c", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -369,15 +369,15 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n #[inline]\n #[unstable = \"this function may be removed in the future due to its \\\n               questionable utility\"]\n-pub unsafe fn copy_lifetime<'a, S, T>(_ptr: &'a S, ptr: &T) -> &'a T {\n+pub unsafe fn copy_lifetime<'a, S, T:'a>(_ptr: &'a S, ptr: &T) -> &'a T {\n     transmute(ptr)\n }\n \n /// Transforms lifetime of the second mutable pointer to match the first.\n #[inline]\n #[unstable = \"this function may be removed in the future due to its \\\n               questionable utility\"]\n-pub unsafe fn copy_mut_lifetime<'a, S, T>(_ptr: &'a mut S,\n+pub unsafe fn copy_mut_lifetime<'a, S, T:'a>(_ptr: &'a mut S,\n                                           ptr: &mut T) -> &'a mut T {\n     transmute(ptr)\n }"}, {"sha": "5a70cd8c847dacab567827e60873fd9b23d9943a", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -996,9 +996,6 @@ impl<'a, T> Default for &'a [T] {\n     fn default() -> &'a [T] { &[] }\n }\n \n-\n-\n-\n //\n // Iterators\n //\n@@ -1128,7 +1125,16 @@ impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function.\n+#[cfg(not(stage0))]\n #[experimental = \"needs review\"]\n+pub struct Splits<'a, T:'a> {\n+    v: &'a [T],\n+    pred: |t: &T|: 'a -> bool,\n+    finished: bool\n+}\n+\n+/// Dox.\n+#[cfg(stage0)]\n pub struct Splits<'a, T> {\n     v: &'a [T],\n     pred: |t: &T|: 'a -> bool,\n@@ -1186,7 +1192,16 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n+#[cfg(not(stage0))]\n #[experimental = \"needs review\"]\n+pub struct MutSplits<'a, T:'a> {\n+    v: &'a mut [T],\n+    pred: |t: &T|: 'a -> bool,\n+    finished: bool\n+}\n+\n+/// Dox\n+#[cfg(stage0)]\n pub struct MutSplits<'a, T> {\n     v: &'a mut [T],\n     pred: |t: &T|: 'a -> bool,\n@@ -1255,7 +1270,16 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function, splitting at most a fixed number of times.\n+#[cfg(not(stage0))]\n #[experimental = \"needs review\"]\n+pub struct SplitsN<'a, T:'a> {\n+    iter: Splits<'a, T>,\n+    count: uint,\n+    invert: bool\n+}\n+\n+/// Dox.\n+#[cfg(stage0)]\n pub struct SplitsN<'a, T> {\n     iter: Splits<'a, T>,\n     count: uint,\n@@ -1291,14 +1315,24 @@ impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n \n /// An iterator over the (overlapping) slices of length `size` within\n /// a vector.\n+#[cfg(stage0)]\n #[deriving(Clone)]\n #[experimental = \"needs review\"]\n pub struct Windows<'a, T> {\n     v: &'a [T],\n     size: uint\n }\n \n+/// An iterator over the (overlapping) slices of length `size` within\n+/// a vector.\n+#[cfg(not(stage0))]\n+#[deriving(Clone)]\n #[experimental = \"needs review\"]\n+pub struct Windows<'a, T:'a> {\n+    v: &'a [T],\n+    size: uint\n+}\n+\n impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n@@ -1327,13 +1361,26 @@ impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n ///\n /// When the vector len is not evenly divided by the chunk size,\n /// the last slice of the iteration will be the remainder.\n+#[cfg(stage0)]\n #[deriving(Clone)]\n #[experimental = \"needs review\"]\n pub struct Chunks<'a, T> {\n     v: &'a [T],\n     size: uint\n }\n \n+/// An iterator over a vector in (non-overlapping) chunks (`size`\n+/// elements at a time).\n+///\n+/// When the vector len is not evenly divided by the chunk size,\n+/// the last slice of the iteration will be the remainder.\n+#[cfg(not(stage0))]\n+#[deriving(Clone)]\n+pub struct Chunks<'a, T:'a> {\n+    v: &'a [T],\n+    size: uint\n+}\n+\n #[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n@@ -1400,7 +1447,15 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n /// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n /// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n /// the remainder.\n+#[cfg(not(stage0))]\n #[experimental = \"needs review\"]\n+pub struct MutChunks<'a, T:'a> {\n+    v: &'a mut [T],\n+    chunk_size: uint\n+}\n+\n+/// Dox.\n+#[cfg(stage0)]\n pub struct MutChunks<'a, T> {\n     v: &'a mut [T],\n     chunk_size: uint"}, {"sha": "cc97eeffe7ae9d11f9b7378dbd9db989f53256f3", "filename": "src/libdebug/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibdebug%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibdebug%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -25,7 +25,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\")]\n #![experimental]\n-#![feature(managed_boxes, macro_rules)]\n+#![feature(managed_boxes, macro_rules, issue_5723_bootstrap)]\n #![allow(experimental)]\n \n pub mod fmt;"}, {"sha": "dbd2c09497be8bc71a3b30e4a4f4977dd654531a", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -95,7 +95,7 @@ pub struct ReprVisitor<'a> {\n     ptr: *const u8,\n     ptr_stk: Vec<*const u8>,\n     var_stk: Vec<VariantState>,\n-    writer: &'a mut io::Writer,\n+    writer: &'a mut io::Writer+'a,\n     last_err: Option<io::IoError>,\n }\n "}, {"sha": "9e46da56a8e5d86eae92d9bae4e6baa3f3502be9", "filename": "src/libfourcc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -72,8 +72,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"fourcc\", expand_syntax_ext);\n }\n \n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult> {\n+pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                              -> Box<base::MacResult+'cx> {\n     let (expr, endian) = parse_tts(cx, tts);\n \n     let little = match endian {"}, {"sha": "10cc7e8afe92fc95e47bfd6db4e832e199739420", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -271,6 +271,7 @@ pub fn main() {\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![license = \"MIT/ASL2\"]\n+#![feature(issue_5723_bootstrap)]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\")]\n@@ -499,7 +500,7 @@ pub trait GraphWalk<'a, N, E> {\n \n /// Renders directed graph `g` into the writer `w` in DOT syntax.\n /// (Main entry point for the library.)\n-pub fn render<'a, N, E, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n+pub fn render<'a, N:'a, E:'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n               g: &'a G,\n               w: &mut W) -> io::IoResult<()>\n {"}, {"sha": "17c75b76bc1e1ef7599072129074557ba4959f54", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -34,6 +34,14 @@ use std::slice;\n /// Some clients will have a pre-allocated vector ready to hand off in\n /// a slice; others will want to create the set on the fly and hand\n /// off ownership, via `Growable`.\n+#[cfg(not(stage0))]\n+pub enum MaybeOwnedVector<'a,T:'a> {\n+    Growable(Vec<T>),\n+    Borrowed(&'a [T]),\n+}\n+\n+/// Stage0 only.\n+#[cfg(stage0)]\n pub enum MaybeOwnedVector<'a,T> {\n     Growable(Vec<T>),\n     Borrowed(&'a [T]),\n@@ -45,7 +53,7 @@ pub trait IntoMaybeOwnedVector<'a,T> {\n     fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T>;\n }\n \n-impl<'a,T> IntoMaybeOwnedVector<'a,T> for Vec<T> {\n+impl<'a,T:'a> IntoMaybeOwnedVector<'a,T> for Vec<T> {\n     #[inline]\n     fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { Growable(self) }\n }"}, {"sha": "058a00bcd4bc0960c08277811c4e0ae40bd83c98", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -82,7 +82,7 @@ impl Runtime for SimpleTask {\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> { None }\n     fn stack_bounds(&self) -> (uint, uint) { fail!() }\n     fn can_block(&self) -> bool { true }\n-    fn wrap(self: Box<SimpleTask>) -> Box<Any> { fail!() }\n+    fn wrap(self: Box<SimpleTask>) -> Box<Any+'static> { fail!() }\n }\n \n pub fn task() -> Box<Task> {"}, {"sha": "ffd94e0b86f2e992589937465c77fc25115dd3b9", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -488,7 +488,9 @@ impl Runtime for GreenTask {\n \n     fn can_block(&self) -> bool { false }\n \n-    fn wrap(self: Box<GreenTask>) -> Box<Any> { self as Box<Any> }\n+    fn wrap(self: Box<GreenTask>) -> Box<Any+'static> {\n+        self as Box<Any+'static>\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "03bd96fc260bc24282ad6eea4b84d17b43c0ff46", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -105,7 +105,7 @@ fn hex_float_lit_err(s: &str) -> Option<(uint, String)> {\n }\n \n pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult> {\n+                         -> Box<base::MacResult+'static> {\n     let (expr, ty_lit) = parse_tts(cx, tts);\n \n     let ty = match ty_lit {"}, {"sha": "5c3beeec8abd70ac4997eb16371fbae7bc4eeb1d", "filename": "src/libnative/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -145,8 +145,8 @@ impl rt::Runtime for Ops {\n         Local::put(cur_task);\n     }\n \n-    fn wrap(self: Box<Ops>) -> Box<Any> {\n-        self as Box<Any>\n+    fn wrap(self: Box<Ops>) -> Box<Any+'static> {\n+        self as Box<Any+'static>\n     }\n \n     fn stack_bounds(&self) -> (uint, uint) { self.stack_bounds }"}, {"sha": "447e3eea06147924b527f5440b141825614f841d", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -79,6 +79,13 @@ pub struct Weighted<T> {\n     pub item: T,\n }\n \n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n+pub struct WeightedChoice<'a, T> {\n+    items: &'a mut [Weighted<T>],\n+    weight_range: Range<uint>\n+}\n+\n /// A distribution that selects from a finite collection of weighted items.\n ///\n /// Each item has an associated weight that influences how likely it\n@@ -105,7 +112,8 @@ pub struct Weighted<T> {\n ///      println!(\"{}\", wc.ind_sample(&mut rng));\n /// }\n /// ```\n-pub struct WeightedChoice<'a, T> {\n+#[cfg(not(stage0))]\n+pub struct WeightedChoice<'a, T:'a> {\n     items: &'a mut [Weighted<T>],\n     weight_range: Range<uint>\n }"}, {"sha": "f1ed9ae899707b625ceb3dd6115007c723fcd553", "filename": "src/librand/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -269,10 +269,17 @@ pub trait Rng {\n     }\n }\n \n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n+pub struct Generator<'a, T, R> {\n+    rng: &'a mut R,\n+}\n+\n /// Iterator which will generate a stream of random items.\n ///\n /// This iterator is created via the `gen_iter` method on `Rng`.\n-pub struct Generator<'a, T, R> {\n+#[cfg(not(stage0))]\n+pub struct Generator<'a, T, R:'a> {\n     rng: &'a mut R,\n }\n \n@@ -282,10 +289,17 @@ impl<'a, T: Rand, R: Rng> Iterator<T> for Generator<'a, T, R> {\n     }\n }\n \n+/// Note: stage0-specific version.\n+#[cfg(stage0)]\n+pub struct AsciiGenerator<'a, R> {\n+    rng: &'a mut R,\n+}\n+\n /// Iterator which will continuously generate random ascii characters.\n ///\n /// This iterator is created via the `gen_ascii_chars` method on `Rng`.\n-pub struct AsciiGenerator<'a, R> {\n+#[cfg(not(stage0))]\n+pub struct AsciiGenerator<'a, R:'a> {\n     rng: &'a mut R,\n }\n "}, {"sha": "a05c877a6a6e10e10df2de96a239dddec6b049c7", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -24,7 +24,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(macro_rules, phase)]\n+#![feature(macro_rules, phase, issue_5723_bootstrap)]\n #![allow(missing_doc)]\n \n extern crate serialize;\n@@ -662,11 +662,19 @@ pub mod writer {\n     pub type EncodeResult = io::IoResult<()>;\n \n     // rbml writing\n+    #[cfg(stage0)]\n     pub struct Encoder<'a, W> {\n         pub writer: &'a mut W,\n         size_positions: Vec<uint>,\n     }\n \n+    // rbml writing\n+    #[cfg(not(stage0))]\n+    pub struct Encoder<'a, W:'a> {\n+        pub writer: &'a mut W,\n+        size_positions: Vec<uint>,\n+    }\n+\n     fn write_sized_vuint<W: Writer>(w: &mut W, n: uint, size: uint) -> EncodeResult {\n         match size {\n             1u => w.write(&[0x80u8 | (n as u8)]),"}, {"sha": "8aa9a2fc8fb94fc52209b439fc5bf295536f0ebb", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -77,7 +77,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n /// strategy is identical and vm.rs has comments and will be easier to follow.\n #[allow(experimental)]\n fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])\n-          -> Box<MacResult> {\n+          -> Box<MacResult+'static> {\n     let regex = match parse(cx, tts) {\n         Some(r) => r,\n         // error is logged in 'parse' with cx.span_err"}, {"sha": "14642a3708a93c50cb5f02b70fa5cdcaf0830c46", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -958,11 +958,11 @@ pub fn pretty_print_input(sess: Session,\n     let mut rdr = MemReader::new(src);\n \n     let out = match ofile {\n-        None => box io::stdout() as Box<Writer>,\n+        None => box io::stdout() as Box<Writer+'static>,\n         Some(p) => {\n             let r = io::File::create(&p);\n             match r {\n-                Ok(w) => box w as Box<Writer>,\n+                Ok(w) => box w as Box<Writer+'static>,\n                 Err(e) => fail!(\"print-print failed to open {} due to {}\",\n                                 p.display(), e),\n             }"}, {"sha": "18f4b79de6ea5d5c1baa2a7a7e422dc49638d13e", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -74,7 +74,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n \n     // A temporary feature gate used to enable parser extensions needed\n     // to bootstrap fix for #5723.\n-    (\"issue_5723_bootstrap\", Active),\n+    (\"issue_5723_bootstrap\", Accepted),\n \n     // These are used to test this portion of the compiler, they don't actually\n     // mean anything\n@@ -97,7 +97,6 @@ enum Status {\n /// A set of features to be used by later passes.\n pub struct Features {\n     pub default_type_params: Cell<bool>,\n-    pub issue_5723_bootstrap: Cell<bool>,\n     pub overloaded_calls: Cell<bool>,\n     pub rustc_diagnostic_macros: Cell<bool>,\n     pub import_shadowing: Cell<bool>,\n@@ -107,7 +106,6 @@ impl Features {\n     pub fn new() -> Features {\n         Features {\n             default_type_params: Cell::new(false),\n-            issue_5723_bootstrap: Cell::new(false),\n             overloaded_calls: Cell::new(false),\n             rustc_diagnostic_macros: Cell::new(false),\n             import_shadowing: Cell::new(false),\n@@ -310,7 +308,7 @@ impl<'a> Visitor<()> for Context<'a> {\n \n     fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n         match t.node {\n-            ast::TyClosure(closure, _) if closure.onceness == ast::Once => {\n+            ast::TyClosure(closure) if closure.onceness == ast::Once => {\n                 self.gate_feature(\"once_fns\", t.span,\n                                   \"once functions are \\\n                                    experimental and likely to be removed\");\n@@ -439,7 +437,6 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n     sess.abort_if_errors();\n \n     sess.features.default_type_params.set(cx.has_feature(\"default_type_params\"));\n-    sess.features.issue_5723_bootstrap.set(cx.has_feature(\"issue_5723_bootstrap\"));\n     sess.features.overloaded_calls.set(cx.has_feature(\"overloaded_calls\"));\n     sess.features.rustc_diagnostic_macros.set(cx.has_feature(\"rustc_diagnostic_macros\"));\n     sess.features.import_shadowing.set(cx.has_feature(\"import_shadowing\"));"}, {"sha": "9b3cc2b6a0a0002ed2ed0646d7f1cb5005076f65", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -31,6 +31,7 @@ This API is completely unstable and subject to change.\n #![allow(deprecated)]\n #![feature(macro_rules, globs, struct_variant, managed_boxes, quote)]\n #![feature(default_type_params, phase, unsafe_destructor)]\n+#![feature(issue_5723_bootstrap)]\n \n #![allow(unknown_features)] // NOTE: Remove after next snapshot\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "ca2f47328db90187c5b000e4e1a5ebd74cacfa60", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -27,8 +27,6 @@ pub static tag_items_data_item: uint = 0x04;\n \n pub static tag_items_data_item_family: uint = 0x05;\n \n-pub static tag_items_data_item_ty_param_bounds: uint = 0x06;\n-\n pub static tag_items_data_item_type: uint = 0x07;\n \n pub static tag_items_data_item_symbol: uint = 0x08;\n@@ -179,7 +177,6 @@ pub static tag_lang_items_missing: uint = 0x74;\n \n pub static tag_item_unnamed_field: uint = 0x75;\n pub static tag_items_data_item_visibility: uint = 0x76;\n-pub static tag_items_data_item_sized: uint = 0x77;\n \n pub static tag_item_method_tps: uint = 0x79;\n pub static tag_item_method_fty: uint = 0x7a;\n@@ -222,12 +219,6 @@ pub struct LinkMeta {\n     pub crate_hash: Svh,\n }\n \n-pub static tag_region_param_def: uint = 0x90;\n-pub static tag_region_param_def_ident: uint = 0x91;\n-pub static tag_region_param_def_def_id: uint = 0x92;\n-pub static tag_region_param_def_space: uint = 0x93;\n-pub static tag_region_param_def_index: uint = 0x94;\n-\n pub static tag_unboxed_closures: uint = 0x95;\n pub static tag_unboxed_closure: uint = 0x96;\n pub static tag_unboxed_closure_type: uint = 0x97;\n@@ -239,3 +230,18 @@ pub static tag_struct_field_id: uint = 0x9b;\n \n pub static tag_attribute_is_sugared_doc: uint = 0x9c;\n \n+pub static tag_trait_def_bounds: uint = 0x9d;\n+\n+pub static tag_items_data_region: uint = 0x9e;\n+\n+pub static tag_region_param_def: uint = 0xa0;\n+pub static tag_region_param_def_ident: uint = 0xa1;\n+pub static tag_region_param_def_def_id: uint = 0xa2;\n+pub static tag_region_param_def_space: uint = 0xa3;\n+pub static tag_region_param_def_index: uint = 0xa4;\n+\n+pub static tag_type_param_def: uint = 0xa5;\n+\n+pub static tag_item_generics: uint = 0xa6;\n+pub static tag_method_ty_generics: uint = 0xa7;\n+"}, {"sha": "904ca2416e0ffc8ebc563bcbdbefa3fa09c4751a", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 71, "deletions": 70, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -18,9 +18,9 @@ use metadata::common::*;\n use metadata::csearch::StaticMethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n-use metadata::tydecode::{parse_ty_data, parse_def_id};\n-use metadata::tydecode::{parse_type_param_def_data, parse_bare_fn_ty_data};\n-use metadata::tydecode::{parse_trait_ref_data};\n+use metadata::tydecode::{parse_ty_data, parse_region_data, parse_def_id,\n+                         parse_type_param_def_data, parse_bounds_data,\n+                         parse_bare_fn_ty_data, parse_trait_ref_data};\n use middle::def;\n use middle::lang_items;\n use middle::resolve::TraitItemKind;\n@@ -242,48 +242,14 @@ fn item_trait_ref(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_ty_param_defs(item: rbml::Doc,\n-                      tcx: &ty::ctxt,\n-                      cdata: Cmd,\n-                      tag: uint)\n-                      -> subst::VecPerParamSpace<ty::TypeParameterDef> {\n-    let mut bounds = subst::VecPerParamSpace::empty();\n-    reader::tagged_docs(item, tag, |p| {\n-        let bd = parse_type_param_def_data(\n-            p.data, p.start, cdata.cnum, tcx,\n-            |_, did| translate_def_id(cdata, did));\n-        bounds.push(bd.space, bd);\n-        true\n-    });\n-    bounds\n+fn doc_bounds(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::ParamBounds {\n+    parse_bounds_data(doc.data, cdata.cnum, doc.start, tcx,\n+                      |_, did| translate_def_id(cdata, did))\n }\n \n-fn item_region_param_defs(item_doc: rbml::Doc, cdata: Cmd)\n-                          -> subst::VecPerParamSpace<ty::RegionParameterDef>\n-{\n-    let mut v = subst::VecPerParamSpace::empty();\n-    reader::tagged_docs(item_doc, tag_region_param_def, |rp_doc| {\n-        let ident_str_doc = reader::get_doc(rp_doc,\n-                                            tag_region_param_def_ident);\n-        let ident = item_name(&*token::get_ident_interner(), ident_str_doc);\n-        let def_id_doc = reader::get_doc(rp_doc,\n-                                         tag_region_param_def_def_id);\n-        let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n-        let def_id = translate_def_id(cdata, def_id);\n-\n-        let doc = reader::get_doc(rp_doc, tag_region_param_def_space);\n-        let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as uint);\n-\n-        let doc = reader::get_doc(rp_doc, tag_region_param_def_index);\n-        let index = reader::doc_as_u64(doc) as uint;\n-\n-        v.push(space, ty::RegionParameterDef { name: ident.name,\n-                                               def_id: def_id,\n-                                               space: space,\n-                                               index: index });\n-        true\n-    });\n-    v\n+fn trait_def_bounds(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::ParamBounds {\n+    let d = reader::get_doc(doc, tag_trait_def_bounds);\n+    doc_bounds(d, tcx, cdata)\n }\n \n fn enum_variant_ids(item: rbml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n@@ -382,24 +348,11 @@ pub fn get_trait_def(cdata: Cmd,\n                      tcx: &ty::ctxt) -> ty::TraitDef\n {\n     let item_doc = lookup_item(item_id, cdata.data());\n-    let tp_defs = item_ty_param_defs(item_doc, tcx, cdata,\n-                                     tag_items_data_item_ty_param_bounds);\n-    let rp_defs = item_region_param_defs(item_doc, cdata);\n-    let mut bounds = ty::empty_builtin_bounds();\n-    // Collect the builtin bounds from the encoded supertraits.\n-    // FIXME(#8559): They should be encoded directly.\n-    reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n-        // NB. Bypasses real supertraits. See get_supertraits() if you wanted them.\n-        let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n-        tcx.lang_items.to_builtin_kind(trait_ref.def_id).map(|bound| {\n-            bounds.add(bound);\n-        });\n-        true\n-    });\n+    let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n+    let bounds = trait_def_bounds(item_doc, tcx, cdata);\n \n     ty::TraitDef {\n-        generics: ty::Generics {types: tp_defs,\n-                                regions: rp_defs},\n+        generics: generics,\n         bounds: bounds,\n         trait_ref: Rc::new(item_trait_ref(item_doc, tcx, cdata))\n     }\n@@ -413,12 +366,10 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n     let t = item_type(ast::DefId { krate: cdata.cnum, node: id }, item, tcx,\n                       cdata);\n \n-    let tp_defs = item_ty_param_defs(item, tcx, cdata, tag_items_data_item_ty_param_bounds);\n-    let rp_defs = item_region_param_defs(item, cdata);\n+    let generics = doc_generics(item, tcx, cdata, tag_item_generics);\n \n     ty::Polytype {\n-        generics: ty::Generics {types: tp_defs,\n-                                regions: rp_defs},\n+        generics: generics,\n         ty: t\n     }\n }\n@@ -794,6 +745,7 @@ pub fn get_impl_or_trait_item(intr: Rc<IdentInterner>,\n                               tcx: &ty::ctxt)\n                               -> ty::ImplOrTraitItem {\n     let method_doc = lookup_item(id, cdata.data());\n+\n     let def_id = item_def_id(method_doc, cdata);\n \n     let container_id = item_reqd_and_translated_parent_item(cdata.cnum,\n@@ -808,18 +760,13 @@ pub fn get_impl_or_trait_item(intr: Rc<IdentInterner>,\n \n     match item_sort(method_doc) {\n         'r' | 'p' => {\n-            let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n-                                                     tag_item_method_tps);\n-            let rp_defs = item_region_param_defs(method_doc, cdata);\n+            let generics = doc_generics(method_doc, tcx, cdata,\n+                                        tag_method_ty_generics);\n             let fty = doc_method_fty(method_doc, tcx, cdata);\n             let vis = item_visibility(method_doc);\n             let explicit_self = get_explicit_self(method_doc);\n             let provided_source = get_provided_source(method_doc, cdata);\n \n-            let generics = ty::Generics {\n-                types: type_param_defs,\n-                regions: rp_defs,\n-            };\n             ty::MethodTraitItem(Rc::new(ty::Method::new(name,\n                                                         generics,\n                                                         fty,\n@@ -1392,3 +1339,57 @@ pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n         _ => false,\n     }\n }\n+\n+fn doc_generics(base_doc: rbml::Doc,\n+                tcx: &ty::ctxt,\n+                cdata: Cmd,\n+                tag: uint)\n+                -> ty::Generics\n+{\n+    let doc = reader::get_doc(base_doc, tag);\n+\n+    let mut types = subst::VecPerParamSpace::empty();\n+    reader::tagged_docs(doc, tag_type_param_def, |p| {\n+        let bd = parse_type_param_def_data(\n+            p.data, p.start, cdata.cnum, tcx,\n+            |_, did| translate_def_id(cdata, did));\n+        types.push(bd.space, bd);\n+        true\n+    });\n+\n+    let mut regions = subst::VecPerParamSpace::empty();\n+    reader::tagged_docs(doc, tag_region_param_def, |rp_doc| {\n+        let ident_str_doc = reader::get_doc(rp_doc,\n+                                            tag_region_param_def_ident);\n+        let ident = item_name(&*token::get_ident_interner(), ident_str_doc);\n+        let def_id_doc = reader::get_doc(rp_doc,\n+                                         tag_region_param_def_def_id);\n+        let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n+        let def_id = translate_def_id(cdata, def_id);\n+\n+        let doc = reader::get_doc(rp_doc, tag_region_param_def_space);\n+        let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as uint);\n+\n+        let doc = reader::get_doc(rp_doc, tag_region_param_def_index);\n+        let index = reader::doc_as_u64(doc) as uint;\n+\n+        let mut bounds = Vec::new();\n+        reader::tagged_docs(rp_doc, tag_items_data_region, |p| {\n+            bounds.push(\n+                parse_region_data(\n+                    p.data, cdata.cnum, p.start, tcx,\n+                    |_, did| translate_def_id(cdata, did)));\n+            true\n+        });\n+\n+        regions.push(space, ty::RegionParameterDef { name: ident.name,\n+                                                     def_id: def_id,\n+                                                     space: space,\n+                                                     index: index,\n+                                                     bounds: bounds });\n+\n+        true\n+    });\n+\n+    ty::Generics { types: types, regions: regions }\n+}"}, {"sha": "1386e23b77dfc4813b061802b84729005d824d93", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 98, "deletions": 66, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -19,8 +19,7 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n-use middle::subst::VecPerParamSpace;\n-use middle::ty::{node_id_to_type, lookup_item_type};\n+use middle::ty::{lookup_item_type};\n use middle::astencode;\n use middle::ty;\n use middle::typeck;\n@@ -150,45 +149,6 @@ pub fn def_to_string(did: DefId) -> String {\n     format!(\"{}:{}\", did.krate, did.node)\n }\n \n-fn encode_ty_type_param_defs(rbml_w: &mut Encoder,\n-                             ecx: &EncodeContext,\n-                             params: &VecPerParamSpace<ty::TypeParameterDef>,\n-                             tag: uint) {\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_string,\n-        tcx: ecx.tcx,\n-        abbrevs: &ecx.type_abbrevs\n-    };\n-    for param in params.iter() {\n-        rbml_w.start_tag(tag);\n-        tyencode::enc_type_param_def(rbml_w.writer, ty_str_ctxt, param);\n-        rbml_w.end_tag();\n-    }\n-}\n-\n-fn encode_region_param_defs(rbml_w: &mut Encoder,\n-                            params: &VecPerParamSpace<ty::RegionParameterDef>) {\n-    for param in params.iter() {\n-        rbml_w.start_tag(tag_region_param_def);\n-\n-        rbml_w.start_tag(tag_region_param_def_ident);\n-        encode_name(rbml_w, param.name);\n-        rbml_w.end_tag();\n-\n-        rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             def_to_string(param.def_id).as_slice());\n-\n-        rbml_w.wr_tagged_u64(tag_region_param_def_space,\n-                             param.space.to_uint() as u64);\n-\n-        rbml_w.wr_tagged_u64(tag_region_param_def_index,\n-                             param.index as u64);\n-\n-        rbml_w.end_tag();\n-    }\n-}\n-\n fn encode_item_variances(rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          id: ast::NodeId) {\n@@ -201,9 +161,7 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n fn encode_bounds_and_type(rbml_w: &mut Encoder,\n                           ecx: &EncodeContext,\n                           pty: &ty::Polytype) {\n-    encode_ty_type_param_defs(rbml_w, ecx, &pty.generics.types,\n-                              tag_items_data_item_ty_param_bounds);\n-    encode_region_param_defs(rbml_w, &pty.generics.regions);\n+    encode_generics(rbml_w, ecx, &pty.generics, tag_item_generics);\n     encode_type(ecx, rbml_w, pty.ty);\n }\n \n@@ -238,6 +196,33 @@ pub fn write_type(ecx: &EncodeContext,\n     tyencode::enc_ty(rbml_w.writer, ty_str_ctxt, typ);\n }\n \n+pub fn write_region(ecx: &EncodeContext,\n+                    rbml_w: &mut Encoder,\n+                    r: ty::Region) {\n+    let ty_str_ctxt = &tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_string,\n+        tcx: ecx.tcx,\n+        abbrevs: &ecx.type_abbrevs\n+    };\n+    tyencode::enc_region(rbml_w.writer, ty_str_ctxt, r);\n+}\n+\n+fn encode_bounds(rbml_w: &mut Encoder,\n+                 ecx: &EncodeContext,\n+                 bounds: &ty::ParamBounds,\n+                 tag: uint) {\n+    rbml_w.start_tag(tag);\n+\n+    let ty_str_ctxt = &tyencode::ctxt { diag: ecx.diag,\n+                                        ds: def_to_string,\n+                                        tcx: ecx.tcx,\n+                                        abbrevs: &ecx.type_abbrevs };\n+    tyencode::enc_bounds(rbml_w.writer, ty_str_ctxt, bounds);\n+\n+    rbml_w.end_tag();\n+}\n+\n fn encode_type(ecx: &EncodeContext,\n                rbml_w: &mut Encoder,\n                typ: ty::t) {\n@@ -246,6 +231,14 @@ fn encode_type(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n+fn encode_region(ecx: &EncodeContext,\n+                 rbml_w: &mut Encoder,\n+                 r: ty::Region) {\n+    rbml_w.start_tag(tag_items_data_region);\n+    write_region(ecx, rbml_w, r);\n+    rbml_w.end_tag();\n+}\n+\n fn encode_method_fty(ecx: &EncodeContext,\n                      rbml_w: &mut Encoder,\n                      typ: &ty::BareFnTy) {\n@@ -728,7 +721,6 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n     let mut index = Vec::new();\n-    let tcx = ecx.tcx;\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n     for field in fields.iter() {\n@@ -745,7 +737,8 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n                token::get_name(nm), id);\n         encode_struct_field_family(rbml_w, field.vis);\n         encode_name(rbml_w, nm);\n-        encode_type(ecx, rbml_w, node_id_to_type(tcx, id));\n+        encode_bounds_and_type(rbml_w, ecx,\n+                               &lookup_item_type(ecx.tcx, local_def(id)));\n         encode_def_id(rbml_w, local_def(id));\n \n         let stab = stability::lookup(ecx.tcx, field.id);\n@@ -773,7 +766,6 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     encode_bounds_and_type(rbml_w, ecx,\n                            &lookup_item_type(ecx.tcx, local_def(ctor_id)));\n     encode_name(rbml_w, name.name);\n-    encode_type(ecx, rbml_w, node_id_to_type(ecx.tcx, ctor_id));\n     ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n     encode_parent_item(rbml_w, local_def(struct_id));\n \n@@ -793,13 +785,60 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n+fn encode_generics(rbml_w: &mut Encoder,\n+                   ecx: &EncodeContext,\n+                   generics: &ty::Generics,\n+                   tag: uint)\n+{\n+    rbml_w.start_tag(tag);\n+\n+    // Type parameters\n+    let ty_str_ctxt = &tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_string,\n+        tcx: ecx.tcx,\n+        abbrevs: &ecx.type_abbrevs\n+    };\n+    for param in generics.types.iter() {\n+        rbml_w.start_tag(tag_type_param_def);\n+        tyencode::enc_type_param_def(rbml_w.writer, ty_str_ctxt, param);\n+        rbml_w.end_tag();\n+    }\n+\n+    // Region parameters\n+    for param in generics.regions.iter() {\n+        rbml_w.start_tag(tag_region_param_def);\n+\n+        rbml_w.start_tag(tag_region_param_def_ident);\n+        encode_name(rbml_w, param.name);\n+        rbml_w.end_tag();\n+\n+        rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n+                             def_to_string(param.def_id).as_slice());\n+\n+        rbml_w.wr_tagged_u64(tag_region_param_def_space,\n+                             param.space.to_uint() as u64);\n+\n+        rbml_w.wr_tagged_u64(tag_region_param_def_index,\n+                             param.index as u64);\n+\n+        for &bound_region in param.bounds.iter() {\n+            encode_region(ecx, rbml_w, bound_region);\n+        }\n+\n+        rbml_w.end_tag();\n+    }\n+\n+    rbml_w.end_tag();\n+}\n+\n fn encode_method_ty_fields(ecx: &EncodeContext,\n                            rbml_w: &mut Encoder,\n                            method_ty: &ty::Method) {\n     encode_def_id(rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.ident.name);\n-    encode_ty_type_param_defs(rbml_w, ecx, &method_ty.generics.types,\n-                              tag_item_method_tps);\n+    encode_generics(rbml_w, ecx, &method_ty.generics,\n+                    tag_method_ty_generics);\n     encode_method_fty(ecx, rbml_w, &method_ty.fty);\n     encode_visibility(rbml_w, method_ty.vis);\n     encode_explicit_self(rbml_w, &method_ty.explicit_self);\n@@ -982,7 +1021,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         } else {\n             encode_family(rbml_w, 'c');\n         }\n-        encode_type(ecx, rbml_w, node_id_to_type(tcx, item.id));\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_symbol(ecx, rbml_w, item.id);\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n@@ -1222,17 +1261,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n         }\n       }\n-      ItemTrait(_, _, ref super_traits, ref ms) => {\n+      ItemTrait(_, _, _, ref ms) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'I');\n         encode_item_variances(rbml_w, ecx, item.id);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n-        encode_ty_type_param_defs(rbml_w, ecx,\n-                                  &trait_def.generics.types,\n-                                  tag_items_data_item_ty_param_bounds);\n-        encode_region_param_defs(rbml_w, &trait_def.generics.regions);\n+        encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, item.attrs.as_slice());\n@@ -1253,13 +1289,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n         }\n         encode_path(rbml_w, path.clone());\n-        // FIXME(#8559): This should use the tcx's supertrait cache instead of\n-        // reading the AST's list, because the former has already filtered out\n-        // the builtin-kinds-as-supertraits. See corresponding fixme in decoder.\n-        for ast_trait_ref in super_traits.iter() {\n-            let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n-            encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_super_trait_ref);\n-        }\n+\n+        encode_bounds(rbml_w, ecx, &trait_def.bounds, tag_trait_def_bounds);\n \n         // Encode the implementations of this trait.\n         encode_extension_implementations(ecx, rbml_w, def_id);\n@@ -1390,7 +1421,8 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         } else {\n             encode_family(rbml_w, 'c');\n         }\n-        encode_type(ecx, rbml_w, node_id_to_type(ecx.tcx, nitem.id));\n+        encode_bounds_and_type(rbml_w, ecx,\n+                               &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_name(rbml_w, nitem.ident.name);\n       }\n@@ -1434,7 +1466,7 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n     });\n }\n \n-struct EncodeVisitor<'a,'b> {\n+struct EncodeVisitor<'a,'b:'a> {\n     rbml_w_for_visit_item: &'a mut Encoder<'b>,\n     ecx_ptr:*const int,\n     index: &'a mut Vec<entry<i64>>,\n@@ -1738,7 +1770,7 @@ fn encode_unboxed_closures<'a>(\n }\n \n fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &Crate) {\n-    struct StructFieldVisitor<'a, 'b> {\n+    struct StructFieldVisitor<'a, 'b:'a> {\n         rbml_w: &'a mut Encoder<'b>,\n     }\n \n@@ -1760,7 +1792,7 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &Crate) {\n \n \n \n-struct ImplVisitor<'a,'b,'c> {\n+struct ImplVisitor<'a,'b:'a,'c:'a> {\n     ecx: &'a EncodeContext<'b>,\n     rbml_w: &'a mut Encoder<'c>,\n }"}, {"sha": "c18d2a7ebf404236f72e63895ea1ed3b5ca9ec77", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 69, "deletions": 17, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -147,6 +147,13 @@ pub fn parse_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty:\n     parse_ty(&mut st, conv)\n }\n \n+pub fn parse_region_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n+                         conv: conv_did) -> ty::Region {\n+    debug!(\"parse_region_data {}\", data_log_string(data, pos));\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_region(&mut st, conv)\n+}\n+\n pub fn parse_bare_fn_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                              conv: conv_did) -> ty::BareFnTy {\n     debug!(\"parse_bare_fn_ty_data {}\", data_log_string(data, pos));\n@@ -168,6 +175,27 @@ pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx:\n     parse_substs(&mut st, conv)\n }\n \n+pub fn parse_bounds_data(data: &[u8], crate_num: ast::CrateNum,\n+                         pos: uint, tcx: &ty::ctxt, conv: conv_did)\n+                         -> ty::ParamBounds {\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_bounds(&mut st, conv)\n+}\n+\n+pub fn parse_existential_bounds_data(data: &[u8], crate_num: ast::CrateNum,\n+                                     pos: uint, tcx: &ty::ctxt, conv: conv_did)\n+                                     -> ty::ExistentialBounds {\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_existential_bounds(&mut st, conv)\n+}\n+\n+pub fn parse_builtin_bounds_data(data: &[u8], crate_num: ast::CrateNum,\n+                                 pos: uint, tcx: &ty::ctxt, conv: conv_did)\n+                                 -> ty::BuiltinBounds {\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_builtin_bounds(&mut st, conv)\n+}\n+\n fn parse_size(st: &mut PState) -> Option<uint> {\n     assert_eq!(next(st), '/');\n \n@@ -355,9 +383,9 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         assert_eq!(next(st), '[');\n         let def = parse_def(st, NominalType, |x,y| conv(x,y));\n         let substs = parse_substs(st, |x,y| conv(x,y));\n-        let bounds = parse_bounds(st, |x,y| conv(x,y));\n+        let bounds = parse_existential_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(st.tcx, def, substs, bounds.builtin_bounds);\n+        return ty::mk_trait(st.tcx, def, substs, bounds);\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n@@ -515,14 +543,14 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     let fn_style = parse_fn_style(next(st));\n     let onceness = parse_onceness(next(st));\n     let store = parse_trait_store(st, |x,y| conv(x,y));\n-    let bounds = parse_bounds(st, |x,y| conv(x,y));\n+    let bounds = parse_existential_bounds(st, |x,y| conv(x,y));\n     let sig = parse_sig(st, |x,y| conv(x,y));\n     let abi = parse_abi_set(st);\n     ty::ClosureTy {\n         fn_style: fn_style,\n         onceness: onceness,\n         store: store,\n-        bounds: bounds.builtin_bounds,\n+        bounds: bounds,\n         sig: sig,\n         abi: abi,\n     }\n@@ -601,7 +629,7 @@ fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef\n     assert_eq!(next(st), '|');\n     let index = parse_uint(st);\n     assert_eq!(next(st), '|');\n-    let bounds = Rc::new(parse_bounds(st, |x,y| conv(x,y)));\n+    let bounds = parse_bounds(st, |x,y| conv(x,y));\n     let default = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)));\n \n     ty::TypeParameterDef {\n@@ -614,27 +642,51 @@ fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef\n     }\n }\n \n-fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n-    let mut param_bounds = ty::ParamBounds {\n-        builtin_bounds: ty::empty_builtin_bounds(),\n-        trait_bounds: Vec::new()\n-    };\n+fn parse_existential_bounds(st: &mut PState, conv: conv_did) -> ty::ExistentialBounds {\n+    let r = parse_region(st, |x,y| conv(x,y));\n+    let bb = parse_builtin_bounds(st, conv);\n+    return ty::ExistentialBounds { region_bound: r, builtin_bounds: bb };\n+}\n+\n+fn parse_builtin_bounds(st: &mut PState, _conv: conv_did) -> ty::BuiltinBounds {\n+    let mut builtin_bounds = ty::empty_builtin_bounds();\n+\n     loop {\n         match next(st) {\n             'S' => {\n-                param_bounds.builtin_bounds.add(ty::BoundSend);\n-            }\n-            'O' => {\n-                param_bounds.builtin_bounds.add(ty::BoundStatic);\n+                builtin_bounds.add(ty::BoundSend);\n             }\n             'Z' => {\n-                param_bounds.builtin_bounds.add(ty::BoundSized);\n+                builtin_bounds.add(ty::BoundSized);\n             }\n             'P' => {\n-                param_bounds.builtin_bounds.add(ty::BoundCopy);\n+                builtin_bounds.add(ty::BoundCopy);\n             }\n             'T' => {\n-                param_bounds.builtin_bounds.add(ty::BoundSync);\n+                builtin_bounds.add(ty::BoundSync);\n+            }\n+            '.' => {\n+                return builtin_bounds;\n+            }\n+            c => {\n+                fail!(\"parse_bounds: bad builtin bounds ('{}')\", c)\n+            }\n+        }\n+    }\n+}\n+\n+fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n+    let builtin_bounds = parse_builtin_bounds(st, |x,y| conv(x,y));\n+\n+    let mut param_bounds = ty::ParamBounds {\n+        opt_region_bound: None,\n+        builtin_bounds: builtin_bounds,\n+        trait_bounds: Vec::new()\n+    };\n+    loop {\n+        match next(st) {\n+            'R' => {\n+                param_bounds.opt_region_bound = Some(parse_region(st, |x, y| conv (x, y)));\n             }\n             'I' => {\n                 param_bounds.trait_bounds.push(Rc::new(parse_trait_ref(st, |x,y| conv(x,y))));"}, {"sha": "09be5094dc578e0b46bf0e0f3fc04cee59a7a78a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -127,7 +127,7 @@ fn enc_region_substs(w: &mut SeekableMemWriter, cx: &ctxt, substs: &subst::Regio\n     }\n }\n \n-fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n+pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {\n             mywrite!(w, \"b[{}|\", id);\n@@ -232,13 +232,11 @@ fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n         ty::ty_trait(box ty::TyTrait {\n                 def_id,\n                 ref substs,\n-                bounds\n+                ref bounds\n             }) => {\n             mywrite!(w, \"x[{}|\", (cx.ds)(def_id));\n             enc_substs(w, cx, substs);\n-            let bounds = ty::ParamBounds {builtin_bounds: bounds,\n-                                          trait_bounds: Vec::new()};\n-            enc_bounds(w, cx, &bounds);\n+            enc_existential_bounds(w, cx, bounds);\n             mywrite!(w, \"]\");\n         }\n         ty::ty_tup(ref ts) => {\n@@ -328,9 +326,7 @@ pub fn enc_closure_ty(w: &mut SeekableMemWriter, cx: &ctxt, ft: &ty::ClosureTy)\n     enc_fn_style(w, ft.fn_style);\n     enc_onceness(w, ft.onceness);\n     enc_trait_store(w, cx, ft.store);\n-    let bounds = ty::ParamBounds {builtin_bounds: ft.bounds,\n-                                  trait_bounds: Vec::new()};\n-    enc_bounds(w, cx, &bounds);\n+    enc_existential_bounds(w, cx, &ft.bounds);\n     enc_fn_sig(w, cx, &ft.sig);\n     enc_abi(w, ft.abi);\n }\n@@ -349,17 +345,32 @@ fn enc_fn_sig(w: &mut SeekableMemWriter, cx: &ctxt, fsig: &ty::FnSig) {\n     enc_ty(w, cx, fsig.output);\n }\n \n-fn enc_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n-    for bound in bs.builtin_bounds.iter() {\n+pub fn enc_builtin_bounds(w: &mut SeekableMemWriter, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n+    for bound in bs.iter() {\n         match bound {\n             ty::BoundSend => mywrite!(w, \"S\"),\n-            ty::BoundStatic => mywrite!(w, \"O\"),\n             ty::BoundSized => mywrite!(w, \"Z\"),\n             ty::BoundCopy => mywrite!(w, \"P\"),\n             ty::BoundSync => mywrite!(w, \"T\"),\n         }\n     }\n \n+    mywrite!(w, \".\");\n+}\n+\n+pub fn enc_existential_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ExistentialBounds) {\n+    enc_region(w, cx, bs.region_bound);\n+    enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n+}\n+\n+pub fn enc_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n+    enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n+\n+    for &r in bs.opt_region_bound.iter() {\n+        mywrite!(w, \"R\");\n+        enc_region(w, cx, r);\n+    }\n+\n     for tp in bs.trait_bounds.iter() {\n         mywrite!(w, \"I\");\n         enc_trait_ref(w, cx, &**tp);\n@@ -372,6 +383,6 @@ pub fn enc_type_param_def(w: &mut SeekableMemWriter, cx: &ctxt, v: &ty::TypePara\n     mywrite!(w, \"{}:{}|{}|{}|\",\n              token::get_ident(v.ident), (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index);\n-    enc_bounds(w, cx, &*v.bounds);\n+    enc_bounds(w, cx, &v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n }"}, {"sha": "6acd79f29760738360aa1d3250f141e5740a19e3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -942,6 +942,8 @@ trait rbml_writer_helpers {\n                      ecx: &e::EncodeContext,\n                      pty: ty::Polytype);\n     fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &subst::Substs);\n+    fn emit_existential_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::ExistentialBounds);\n+    fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment);\n     fn emit_autoref(&mut self, ecx: &e::EncodeContext, autoref: &ty::AutoRef);\n     fn emit_auto_deref_ref(&mut self, ecx: &e::EncodeContext, auto_deref_ref: &ty::AutoDerefRef);\n@@ -1001,6 +1003,18 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n+    fn emit_existential_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::ExistentialBounds) {\n+        self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(this.writer,\n+                                                                    &ecx.ty_str_ctxt(),\n+                                                                    bounds)));\n+    }\n+\n+    fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds) {\n+        self.emit_opaque(|this| Ok(tyencode::enc_builtin_bounds(this.writer,\n+                                                                &ecx.ty_str_ctxt(),\n+                                                                bounds)));\n+    }\n+\n     fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &subst::Substs) {\n         self.emit_opaque(|this| Ok(tyencode::enc_substs(this.writer,\n                                                            &ecx.ty_str_ctxt(),\n@@ -1100,9 +1114,10 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n                         this.emit_enum_variant_arg(1, |this| idx.encode(this))\n                     })\n                 }\n-                ty::UnsizeVtable(b, def_id, ref substs) => {\n+                ty::UnsizeVtable(ref b, def_id, ref substs) => {\n                     this.emit_enum_variant(\"UnsizeVtable\", 2, 3, |this| {\n-                        this.emit_enum_variant_arg(0, |this| b.encode(this));\n+                        this.emit_enum_variant_arg(\n+                            0, |this| Ok(this.emit_existential_bounds(ecx, b)));\n                         this.emit_enum_variant_arg(1, |this| def_id.encode(this));\n                         this.emit_enum_variant_arg(2, |this| Ok(this.emit_substs(ecx, substs)))\n                     })\n@@ -1131,7 +1146,7 @@ impl<'a> write_tag_and_id for Encoder<'a> {\n     }\n }\n \n-struct SideTableEncodingIdVisitor<'a,'b> {\n+struct SideTableEncodingIdVisitor<'a,'b:'a> {\n     ecx_ptr: *const libc::c_void,\n     new_rbml_w: &'a mut Encoder<'b>,\n }\n@@ -1380,6 +1395,7 @@ trait rbml_decoder_decoder_helpers {\n                            -> ty::TypeParameterDef;\n     fn read_polytype(&mut self, xcx: &ExtendedDecodeContext)\n                      -> ty::Polytype;\n+    fn read_existential_bounds(&mut self, xcx: &ExtendedDecodeContext) -> ty::ExistentialBounds;\n     fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> subst::Substs;\n     fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment;\n     fn read_unboxed_closure(&mut self, xcx: &ExtendedDecodeContext)\n@@ -1514,6 +1530,17 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n+    fn read_existential_bounds(&mut self, xcx: &ExtendedDecodeContext) -> ty::ExistentialBounds\n+    {\n+        self.read_opaque(|this, doc| {\n+            Ok(tydecode::parse_existential_bounds_data(doc.data,\n+                                                       xcx.dcx.cdata.cnum,\n+                                                       doc.start,\n+                                                       xcx.dcx.tcx,\n+                                                       |s, a| this.convert_def_id(xcx, s, a)))\n+        }).unwrap()\n+    }\n+\n     fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> subst::Substs {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_substs_data(doc.data,\n@@ -1638,8 +1665,9 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         ty::UnsizeStruct(box uk, idx)\n                     }\n                     2 => {\n-                        let b: ty::BuiltinBounds =\n-                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n+                        let b =\n+                            this.read_enum_variant_arg(\n+                                0, |this| Ok(this.read_existential_bounds(xcx))).unwrap();\n                         let def_id: ast::DefId =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n                         let substs = this.read_enum_variant_arg(2,"}, {"sha": "2acc92cd2275def6762c6521bc5ac53a5d7c9b1c", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -79,12 +79,14 @@ impl<'a> CFGBuilder<'a> {\n \n     fn stmt(&mut self, stmt: Gc<ast::Stmt>, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n-            ast::StmtDecl(ref decl, _) => {\n-                self.decl(&**decl, pred)\n+            ast::StmtDecl(ref decl, id) => {\n+                let exit = self.decl(&**decl, pred);\n+                self.add_node(id, [exit])\n             }\n \n-            ast::StmtExpr(ref expr, _) | ast::StmtSemi(ref expr, _) => {\n-                self.expr(expr.clone(), pred)\n+            ast::StmtExpr(ref expr, id) | ast::StmtSemi(ref expr, id) => {\n+                let exit = self.expr(expr.clone(), pred);\n+                self.add_node(id, [exit])\n             }\n \n             ast::StmtMac(..) => {"}, {"sha": "5cb7651e99a56bcc685a4f34961f8ab6f4162100", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -1018,7 +1018,7 @@ fn check_legality_of_bindings_in_at_patterns(cx: &MatchCheckCtxt, pat: &Pat) {\n     visitor.visit_pat(pat, true);\n }\n \n-struct AtBindingPatternVisitor<'a,'b> {\n+struct AtBindingPatternVisitor<'a,'b:'a> {\n     cx: &'a MatchCheckCtxt<'b>,\n }\n "}, {"sha": "91c227cd5bca9ed3092a6c950319599405a39410", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -80,11 +80,18 @@ pub trait DataFlowOperator : BitwiseOperator {\n     fn initial_value(&self) -> bool;\n }\n \n+#[cfg(stage0)]\n struct PropagationContext<'a, 'b, O> {\n     dfcx: &'a mut DataFlowContext<'b, O>,\n     changed: bool\n }\n \n+#[cfg(not(stage0))]\n+struct PropagationContext<'a, 'b:'a, O:'a> {\n+    dfcx: &'a mut DataFlowContext<'b, O>,\n+    changed: bool\n+}\n+\n fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n     let opt_cfgindex = index.find(&id).map(|&i|i);\n     opt_cfgindex.unwrap_or_else(|| {\n@@ -458,7 +465,7 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n         });\n     }\n \n-    fn pretty_print_to(&self, wr: Box<io::Writer>,\n+    fn pretty_print_to(&self, wr: Box<io::Writer+'static>,\n                        blk: &ast::Block) -> io::IoResult<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self);\n         try!(ps.cbox(pprust::indent_unit));"}, {"sha": "ae9a3fa6a67a5a0cc9b39ec4ad8f8c6cad9906fd", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -192,10 +192,18 @@ impl OverloadedCallType {\n // supplies types from the tree. After type checking is complete, you\n // can just use the tcx as the typer.\n \n+#[cfg(stage0)]\n pub struct ExprUseVisitor<'d,'t,TYPER> {\n     typer: &'t TYPER,\n     mc: mc::MemCategorizationContext<'t,TYPER>,\n-    delegate: &'d mut Delegate,\n+    delegate: &'d mut Delegate+'d,\n+}\n+\n+#[cfg(not(stage0))]\n+pub struct ExprUseVisitor<'d,'t,TYPER:'t> {\n+    typer: &'t TYPER,\n+    mc: mc::MemCategorizationContext<'t,TYPER>,\n+    delegate: &'d mut Delegate+'d,\n }\n \n // If the TYPER results in an error, it's because the type check"}, {"sha": "2c79c655a9992b806dcfc458f6f6fd5d87213dd8", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -64,6 +64,7 @@ pub struct EdgeIndex(pub uint);\n pub static InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n+#[deriving(Show)]\n pub struct Direction { repr: uint }\n pub static Outgoing: Direction = Direction { repr: 0 };\n pub static Incoming: Direction = Direction { repr: 1 };"}, {"sha": "08dde0c06079602926ab1002a4365f7ad0fabd9a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 18, "deletions": 150, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -144,14 +144,17 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n     // If this trait has builtin-kind supertraits, meet them.\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n     debug!(\"checking impl with self type {}\", ty::get(self_ty).sty);\n-    check_builtin_bounds(cx, self_ty, trait_def.bounds, |missing| {\n-        span_err!(cx.tcx.sess, self_type.span, E0142,\n-                  \"the type `{}', which does not fulfill `{}`, cannot implement this trait\",\n-                  ty_to_string(cx.tcx, self_ty), missing.user_string(cx.tcx));\n-        span_note!(cx.tcx.sess, self_type.span,\n-                   \"types implementing this trait must fulfill `{}`\",\n-                   trait_def.bounds.user_string(cx.tcx));\n-    });\n+    check_builtin_bounds(\n+        cx, self_ty, trait_def.bounds.builtin_bounds,\n+        |missing| {\n+            span_err!(cx.tcx.sess, self_type.span, E0142,\n+                      \"the type `{}', which does not fulfill `{}`, \\\n+                       cannot implement this trait\",\n+                      ty_to_string(cx.tcx, self_ty), missing.user_string(cx.tcx));\n+            span_note!(cx.tcx.sess, self_type.span,\n+                       \"types implementing this trait must fulfill `{}`\",\n+                       trait_def.bounds.user_string(cx.tcx));\n+        });\n \n     // If this is a destructor, check kinds.\n     if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) {\n@@ -297,17 +300,15 @@ fn with_appropriate_checker(cx: &Context,\n     match ty::get(fty).sty {\n         ty::ty_closure(box ty::ClosureTy {\n             store: ty::UniqTraitStore,\n-            bounds: mut bounds, ..\n+            bounds: bounds,\n+            ..\n         }) => {\n-            // Procs can't close over non-static references!\n-            bounds.add(ty::BoundStatic);\n-\n-            b(|cx, fv| check_for_uniq(cx, fv, bounds))\n+            b(|cx, fv| check_for_uniq(cx, fv, bounds.builtin_bounds))\n         }\n \n         ty::ty_closure(box ty::ClosureTy {\n             store: ty::RegionTraitStore(region, _), bounds, ..\n-        }) => b(|cx, fv| check_for_block(cx, fv, bounds, region)),\n+        }) => b(|cx, fv| check_for_block(cx, fv, bounds.builtin_bounds, region)),\n \n         ty::ty_bare_fn(_) => {\n             b(check_for_bare)\n@@ -377,13 +378,6 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n                                                          expression_type);\n \n     match e.node {\n-        ExprBox(ref loc, ref interior) => {\n-            let def = ty::resolve_expr(cx.tcx, &**loc);\n-            if Some(def.def_id()) == cx.tcx.lang_items.managed_heap() {\n-                let interior_type = ty::expr_ty(cx.tcx, &**interior);\n-                let _ = check_static(cx.tcx, interior_type, interior.span);\n-            }\n-        }\n         ExprCast(ref source, _) => {\n             let source_ty = ty::expr_ty(cx.tcx, &**source);\n             let target_ty = ty::expr_ty(cx.tcx, e);\n@@ -562,7 +556,6 @@ fn check_trait_cast(cx: &mut Context,\n                     target_ty: ty::t,\n                     span: Span,\n                     method_call: MethodCall) {\n-    check_cast_for_escaping_regions(cx, source_ty, target_ty, span);\n     match ty::get(target_ty).sty {\n         ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ ty, .. }) => {\n             match ty::get(ty).sty {\n@@ -580,7 +573,8 @@ fn check_trait_cast(cx: &mut Context,\n                                 vtable_res)\n                         }\n                     };\n-                    check_trait_cast_bounds(cx, span, source_ty, bounds);\n+                    check_trait_cast_bounds(cx, span, source_ty,\n+                                            bounds.builtin_bounds);\n                 }\n                 _ => {}\n             }\n@@ -620,7 +614,7 @@ pub fn check_builtin_bounds(cx: &Context,\n     let kind = ty::type_contents(cx.tcx, ty);\n     let mut missing = ty::empty_builtin_bounds();\n     for bound in bounds.iter() {\n-        if !kind.meets_bound(cx.tcx, bound) {\n+        if !kind.meets_builtin_bound(cx.tcx, bound) {\n             missing.add(bound);\n         }\n     }\n@@ -764,132 +758,6 @@ fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n     }\n }\n \n-pub fn check_static(tcx: &ty::ctxt, ty: ty::t, sp: Span) -> bool {\n-    if !ty::type_is_static(tcx, ty) {\n-        match ty::get(ty).sty {\n-            ty::ty_param(..) => {\n-                span_err!(tcx.sess, sp, E0149,\n-                    \"value may contain references; \\\n-                     add `'static` bound to `{}`\",\n-                     ty_to_string(tcx, ty));\n-            }\n-            _ => {\n-                span_err!(tcx.sess, sp, E0150,\n-                    \"value may contain references\");\n-            }\n-        }\n-        false\n-    } else {\n-        true\n-    }\n-}\n-\n-/// This is rather subtle.  When we are casting a value to an instantiated\n-/// trait like `a as trait<'r>`, regionck already ensures that any references\n-/// that appear in the type of `a` are bounded by `'r` (ed.: rem\n-/// FIXME(#5723)).  However, it is possible that there are *type parameters*\n-/// in the type of `a`, and those *type parameters* may have references\n-/// within them.  We have to guarantee that the regions which appear in those\n-/// type parameters are not obscured.\n-///\n-/// Therefore, we ensure that one of three conditions holds:\n-///\n-/// (1) The trait instance cannot escape the current fn.  This is\n-/// guaranteed if the region bound `&r` is some scope within the fn\n-/// itself.  This case is safe because whatever references are\n-/// found within the type parameter, they must enclose the fn body\n-/// itself.\n-///\n-/// (2) The type parameter appears in the type of the trait.  For\n-/// example, if the type parameter is `T` and the trait type is\n-/// `deque<T>`, then whatever references may appear in `T` also\n-/// appear in `deque<T>`.\n-///\n-/// (3) The type parameter is sendable (and therefore does not contain\n-/// references).\n-///\n-/// FIXME(#5723)---This code should probably move into regionck.\n-pub fn check_cast_for_escaping_regions(\n-    cx: &Context,\n-    source_ty: ty::t,\n-    target_ty: ty::t,\n-    source_span: Span)\n-{\n-    // Determine what type we are casting to; if it is not a trait, then no\n-    // worries.\n-    if !ty::type_is_trait(target_ty) {\n-        return;\n-    }\n-\n-    // Collect up the regions that appear in the target type.  We want to\n-    // ensure that these lifetimes are shorter than all lifetimes that are in\n-    // the source type.  See test `src/test/compile-fail/regions-trait-2.rs`\n-    let mut target_regions = Vec::new();\n-    ty::walk_regions_and_ty(\n-        cx.tcx,\n-        target_ty,\n-        |r| {\n-            if !r.is_bound() {\n-                target_regions.push(r);\n-            }\n-        },\n-        |_| ());\n-\n-    // Check, based on the region associated with the trait, whether it can\n-    // possibly escape the enclosing fn item (note that all type parameters\n-    // must have been declared on the enclosing fn item).\n-    if target_regions.iter().any(|r| is_ReScope(*r)) {\n-        return; /* case (1) */\n-    }\n-\n-    // Assuming the trait instance can escape, then ensure that each parameter\n-    // either appears in the trait type or is sendable.\n-    let target_params = ty::param_tys_in_type(target_ty);\n-    ty::walk_regions_and_ty(\n-        cx.tcx,\n-        source_ty,\n-\n-        |_r| {\n-            // FIXME(#5723) --- turn this check on once &Objects are usable\n-            //\n-            // if !target_regions.iter().any(|t_r| is_subregion_of(cx, *t_r, r)) {\n-            //     cx.tcx.sess.span_err(\n-            //         source_span,\n-            //         format!(\"source contains reference with lifetime \\\n-            //               not found in the target type `{}`\",\n-            //              ty_to_string(cx.tcx, target_ty)));\n-            //     note_and_explain_region(\n-            //         cx.tcx, \"source data is only valid for \", r, \"\");\n-            // }\n-        },\n-\n-        |ty| {\n-            match ty::get(ty).sty {\n-                ty::ty_param(source_param) => {\n-                    if source_param.space == subst::SelfSpace {\n-                        // FIXME (#5723) -- there is no reason that\n-                        // Self should be exempt from this check,\n-                        // except for historical accident. Bottom\n-                        // line, we need proper region bounding.\n-                    } else if target_params.iter().any(|x| x == &source_param) {\n-                        /* case (2) */\n-                    } else {\n-                        check_static(cx.tcx, ty, source_span); /* case (3) */\n-                    }\n-                }\n-                _ => {}\n-            }\n-        });\n-\n-    #[allow(non_snake_case_functions)]\n-    fn is_ReScope(r: ty::Region) -> bool {\n-        match r {\n-            ty::ReScope(..) => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n // Ensure that `ty` has a statically known size (i.e., it has the `Sized` bound).\n fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: String, sp: Span) {\n     if !ty::type_is_sized(tcx, ty) {"}, {"sha": "662b55ba3610982fd52f6c7c347a2a24bbacbd13", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -240,10 +240,16 @@ impl ast_node for ast::Pat {\n     fn span(&self) -> Span { self.span }\n }\n \n+#[cfg(stage0)]\n pub struct MemCategorizationContext<'t,TYPER> {\n     typer: &'t TYPER\n }\n \n+#[cfg(not(stage0))]\n+pub struct MemCategorizationContext<'t,TYPER:'t> {\n+    typer: &'t TYPER\n+}\n+\n pub type McResult<T> = Result<T, ()>;\n \n /**"}, {"sha": "42d6cee965476576a73f15710ebca0a50898e5e1", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -1221,8 +1221,8 @@ struct VisiblePrivateTypesVisitor<'a> {\n     public_items: &'a PublicItems,\n }\n \n-struct CheckTypeForPrivatenessVisitor<'a, 'b> {\n-    inner: &'b VisiblePrivateTypesVisitor<'a>,\n+struct CheckTypeForPrivatenessVisitor<'a, 'b:'a> {\n+    inner: &'a VisiblePrivateTypesVisitor<'b>,\n     /// whether the type refers to private types.\n     contains_private: bool,\n     /// whether we've recurred at all (i.e. if we're pointing at the"}, {"sha": "11dd3eee88e888f42d93dbd1810e5e13bd255d4c", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -25,6 +25,7 @@ use driver::session::Session;\n use middle::ty::{FreeRegion};\n use middle::ty;\n use util::nodemap::NodeMap;\n+use util::common::can_reach;\n \n use std::cell::RefCell;\n use std::collections::{HashMap, HashSet};\n@@ -78,7 +79,7 @@ The region maps encode information about region relationships.\n pub struct RegionMaps {\n     scope_map: RefCell<NodeMap<ast::NodeId>>,\n     var_map: RefCell<NodeMap<ast::NodeId>>,\n-    free_region_map: RefCell<HashMap<FreeRegion, Vec<FreeRegion> >>,\n+    free_region_map: RefCell<HashMap<FreeRegion, Vec<FreeRegion>>>,\n     rvalue_scopes: RefCell<NodeMap<ast::NodeId>>,\n     terminating_scopes: RefCell<HashSet<ast::NodeId>>,\n }\n@@ -255,34 +256,7 @@ impl RegionMaps {\n          * (that is, the user can give two different names to the same lifetime).\n          */\n \n-        if sub == sup {\n-            return true;\n-        }\n-\n-        // Do a little breadth-first-search here.  The `queue` list\n-        // doubles as a way to detect if we've seen a particular FR\n-        // before.  Note that we expect this graph to be an *extremely\n-        // shallow* tree.\n-        let mut queue = vec!(sub);\n-        let mut i = 0;\n-        while i < queue.len() {\n-            match self.free_region_map.borrow().find(queue.get(i)) {\n-                Some(parents) => {\n-                    for parent in parents.iter() {\n-                        if *parent == sup {\n-                            return true;\n-                        }\n-\n-                        if !queue.iter().any(|x| x == parent) {\n-                            queue.push(*parent);\n-                        }\n-                    }\n-                }\n-                None => {}\n-            }\n-            i += 1;\n-        }\n-        return false;\n+        can_reach(&*self.free_region_map.borrow(), sub, sup)\n     }\n \n     pub fn is_subregion_of(&self,\n@@ -300,6 +274,7 @@ impl RegionMaps {\n \n         sub_region == super_region || {\n             match (sub_region, super_region) {\n+                (ty::ReEmpty, _) |\n                 (_, ty::ReStatic) => {\n                     true\n                 }"}, {"sha": "58be2c73bd9b0ceb0dfcb1ab7d6beec7e14cb449", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -30,10 +30,10 @@ use syntax::ast::{Ident, ImplItem, Item, ItemEnum, ItemFn, ItemForeignMod};\n use syntax::ast::{ItemImpl, ItemMac, ItemMod, ItemStatic, ItemStruct};\n use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local, Method};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n-use syntax::ast::{OtherRegionTyParamBound, P, Pat, PatEnum, PatIdent, PatLit};\n+use syntax::ast::{P, Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n use syntax::ast::{PrimTy, Public, SelfExplicit, SelfStatic};\n-use syntax::ast::{StaticRegionTyParamBound, StmtDecl, StructField};\n+use syntax::ast::{RegionTyParamBound, StmtDecl, StructField};\n use syntax::ast::{StructVariantKind, TraitRef, TraitTyParamBound};\n use syntax::ast::{TupleVariantKind, Ty, TyBool, TyChar, TyClosure, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt};\n@@ -901,7 +901,7 @@ struct Resolver<'a> {\n     used_imports: HashSet<(NodeId, Namespace)>,\n }\n \n-struct BuildReducedGraphVisitor<'a, 'b> {\n+struct BuildReducedGraphVisitor<'a, 'b:'a> {\n     resolver: &'a mut Resolver<'b>,\n }\n \n@@ -933,7 +933,9 @@ impl<'a, 'b> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a, 'b> {\n \n }\n \n-struct UnusedImportCheckVisitor<'a, 'b> { resolver: &'a mut Resolver<'b> }\n+struct UnusedImportCheckVisitor<'a, 'b:'a> {\n+    resolver: &'a mut Resolver<'b>\n+}\n \n impl<'a, 'b> Visitor<()> for UnusedImportCheckVisitor<'a, 'b> {\n     fn visit_view_item(&mut self, vi: &ViewItem, _: ()) {\n@@ -3946,7 +3948,7 @@ impl<'a> Resolver<'a> {\n                                             impl_items.as_slice());\n             }\n \n-            ItemTrait(ref generics, ref unbound, ref traits, ref methods) => {\n+            ItemTrait(ref generics, ref unbound, ref bounds, ref methods) => {\n                 // Create a new rib for the self type.\n                 let self_type_rib = Rib::new(ItemRibKind);\n \n@@ -3965,10 +3967,9 @@ impl<'a> Resolver<'a> {\n                     this.resolve_type_parameters(&generics.ty_params);\n                     this.resolve_where_clause(&generics.where_clause);\n \n-                    // Resolve derived traits.\n-                    for trt in traits.iter() {\n-                        this.resolve_trait_reference(item.id, trt, TraitDerivation);\n-                    }\n+                    this.resolve_type_parameter_bounds(item.id, bounds,\n+                                                       TraitDerivation);\n+\n                     match unbound {\n                         &Some(ast::TraitTyParamBound(ref tpb)) => {\n                             this.resolve_trait_reference(item.id, tpb, TraitDerivation);\n@@ -4199,10 +4200,13 @@ impl<'a> Resolver<'a> {\n                                type_parameters: &OwnedSlice<TyParam>) {\n         for type_parameter in type_parameters.iter() {\n             for bound in type_parameter.bounds.iter() {\n-                self.resolve_type_parameter_bound(type_parameter.id, bound);\n+                self.resolve_type_parameter_bound(type_parameter.id, bound,\n+                                                  TraitBoundingTypeParameter);\n             }\n             match &type_parameter.unbound {\n-                &Some(ref unbound) => self.resolve_type_parameter_bound(type_parameter.id, unbound),\n+                &Some(ref unbound) =>\n+                    self.resolve_type_parameter_bound(\n+                        type_parameter.id, unbound, TraitBoundingTypeParameter),\n                 &None => {}\n             }\n             match type_parameter.default {\n@@ -4212,12 +4216,23 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn resolve_type_parameter_bounds(&mut self,\n+                                     id: NodeId,\n+                                     type_parameter_bounds: &OwnedSlice<TyParamBound>,\n+                                     reference_type: TraitReferenceType) {\n+        for type_parameter_bound in type_parameter_bounds.iter() {\n+            self.resolve_type_parameter_bound(id, type_parameter_bound,\n+                                              reference_type);\n+        }\n+    }\n+\n     fn resolve_type_parameter_bound(&mut self,\n                                     id: NodeId,\n-                                    type_parameter_bound: &TyParamBound) {\n+                                    type_parameter_bound: &TyParamBound,\n+                                    reference_type: TraitReferenceType) {\n         match *type_parameter_bound {\n             TraitTyParamBound(ref tref) => {\n-                self.resolve_trait_reference(id, tref, TraitBoundingTypeParameter)\n+                self.resolve_trait_reference(id, tref, reference_type)\n             }\n             UnboxedFnTyParamBound(ref unboxed_function) => {\n                 for argument in unboxed_function.decl.inputs.iter() {\n@@ -4226,7 +4241,7 @@ impl<'a> Resolver<'a> {\n \n                 self.resolve_type(&*unboxed_function.decl.output);\n             }\n-            StaticRegionTyParamBound | OtherRegionTyParamBound(_) => {}\n+            RegionTyParamBound(..) => {}\n         }\n     }\n \n@@ -4240,7 +4255,7 @@ impl<'a> Resolver<'a> {\n                 let usage_str = match reference_type {\n                     TraitBoundingTypeParameter => \"bound type parameter with\",\n                     TraitImplementation        => \"implement\",\n-                    TraitDerivation            => \"derive\"\n+                    TraitDerivation            => \"derive\",\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n@@ -4295,7 +4310,8 @@ impl<'a> Resolver<'a> {\n             }\n \n             for bound in predicate.bounds.iter() {\n-                self.resolve_type_parameter_bound(predicate.id, bound);\n+                self.resolve_type_parameter_bound(predicate.id, bound,\n+                                                  TraitBoundingTypeParameter);\n             }\n         }\n     }\n@@ -4679,18 +4695,14 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 bounds.as_ref().map(|bound_vec| {\n-                    for bound in bound_vec.iter() {\n-                        self.resolve_type_parameter_bound(ty.id, bound);\n-                    }\n+                    self.resolve_type_parameter_bounds(ty.id, bound_vec,\n+                                                       TraitBoundingTypeParameter);\n                 });\n             }\n \n-            TyClosure(c, _) | TyProc(c) => {\n-                c.bounds.as_ref().map(|bounds| {\n-                    for bound in bounds.iter() {\n-                        self.resolve_type_parameter_bound(ty.id, bound);\n-                    }\n-                });\n+            TyClosure(c) | TyProc(c) => {\n+                self.resolve_type_parameter_bounds(ty.id, &c.bounds,\n+                                                   TraitBoundingTypeParameter);\n                 visit::walk_ty(self, ty, ());\n             }\n "}, {"sha": "1bc37e2f1e445709f1cd58ea6c08aa094036a20d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 73, "deletions": 39, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -21,7 +21,6 @@ use driver::session::Session;\n use middle::subst;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::print::pprust::{lifetime_to_string};\n@@ -99,8 +98,10 @@ impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n             ast::ItemStruct(_, ref generics) |\n             ast::ItemImpl(ref generics, _, _, _) |\n             ast::ItemTrait(ref generics, _, _, _) => {\n-                self.check_lifetime_names(&generics.lifetimes);\n-                EarlyScope(subst::TypeSpace, &generics.lifetimes, &root)\n+                let scope: ScopeChain =\n+                    EarlyScope(subst::TypeSpace, &generics.lifetimes, &root);\n+                self.check_lifetime_defs(&generics.lifetimes, &scope);\n+                scope\n             }\n         };\n         debug!(\"entering scope {:?}\", scope);\n@@ -126,7 +127,7 @@ impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n \n     fn visit_ty(&mut self, ty: &ast::Ty, scope: Scope<'a>) {\n         match ty.node {\n-            ast::TyClosure(c, _) | ast::TyProc(c) => {\n+            ast::TyClosure(c) | ast::TyProc(c) => {\n                 push_fn_scope(self, ty, scope, &c.lifetimes);\n             }\n             ast::TyBareFn(c) => push_fn_scope(self, ty, scope, &c.lifetimes),\n@@ -137,8 +138,8 @@ impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n                          ty: &ast::Ty,\n                          scope: Scope,\n                          lifetimes: &Vec<ast::LifetimeDef>) {\n-            let scope1 = LateScope(ty.id, lifetimes, scope);\n-            this.check_lifetime_names(lifetimes);\n+            let scope1: ScopeChain = LateScope(ty.id, lifetimes, scope);\n+            this.check_lifetime_defs(lifetimes, &scope1);\n             debug!(\"pushing fn scope id={} due to type\", ty.id);\n             visit::walk_ty(this, ty, &scope1);\n             debug!(\"popping fn scope id={} due to type\", ty.id);\n@@ -204,24 +205,22 @@ impl<'a> LifetimeContext<'a> {\n          * the ordering is not important there.\n          */\n \n-        self.check_lifetime_names(&generics.lifetimes);\n-\n-        let referenced_idents = free_lifetimes(&generics.ty_params,\n-                                               &generics.where_clause);\n+        let referenced_idents = early_bound_lifetime_names(generics);\n         debug!(\"pushing fn scope id={} due to fn item/method\\\n                referenced_idents={:?}\",\n                n,\n                referenced_idents.iter().map(lifetime_show).collect::<Vec<token::InternedString>>());\n         if referenced_idents.is_empty() {\n-            let scope1 = LateScope(n, &generics.lifetimes, scope);\n-            walk(self, &scope1)\n+            let scope1: ScopeChain = LateScope(n, &generics.lifetimes, scope);\n+            self.check_lifetime_defs(&generics.lifetimes, &scope1);\n+            walk(self, &scope1);\n         } else {\n             let (early, late) = generics.lifetimes.clone().partition(\n                 |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n \n             let scope1 = EarlyScope(subst::FnSpace, &early, scope);\n-            let scope2 = LateScope(n, &late, &scope1);\n-\n+            let scope2: ScopeChain = LateScope(n, &late, &scope1);\n+            self.check_lifetime_defs(&generics.lifetimes, &scope2);\n             walk(self, &scope2);\n         }\n         debug!(\"popping fn scope id={} due to fn item/method\", n);\n@@ -335,7 +334,9 @@ impl<'a> LifetimeContext<'a> {\n                     token::get_name(lifetime_ref.name)).as_slice());\n     }\n \n-    fn check_lifetime_names(&self, lifetimes: &Vec<ast::LifetimeDef>) {\n+    fn check_lifetime_defs<'b>(&mut self,\n+                               lifetimes: &Vec<ast::LifetimeDef>,\n+                               scope: Scope<'b>) {\n         for i in range(0, lifetimes.len()) {\n             let lifetime_i = lifetimes.get(i);\n \n@@ -364,11 +365,7 @@ impl<'a> LifetimeContext<'a> {\n             }\n \n             for bound in lifetime_i.bounds.iter() {\n-                if !self.sess.features.issue_5723_bootstrap.get() {\n-                    self.sess.span_err(\n-                        bound.span,\n-                        \"region bounds require `issue_5723_bootstrap`\");\n-                }\n+                self.resolve_lifetime_ref(bound, scope);\n             }\n         }\n     }\n@@ -404,8 +401,7 @@ fn search_lifetimes(lifetimes: &Vec<ast::LifetimeDef>,\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn early_bound_lifetimes<'a>(generics: &'a ast::Generics) -> Vec<ast::LifetimeDef> {\n-    let referenced_idents = free_lifetimes(&generics.ty_params,\n-                                           &generics.where_clause);\n+    let referenced_idents = early_bound_lifetime_names(generics);\n     if referenced_idents.is_empty() {\n         return Vec::new();\n     }\n@@ -416,34 +412,72 @@ pub fn early_bound_lifetimes<'a>(generics: &'a ast::Generics) -> Vec<ast::Lifeti\n         .collect()\n }\n \n-pub fn free_lifetimes(ty_params: &OwnedSlice<ast::TyParam>,\n-                      where_clause: &ast::WhereClause)\n-                      -> Vec<ast::Name> {\n+fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n     /*!\n-     * Gathers up and returns the names of any lifetimes that appear\n-     * free in `ty_params`. Of course, right now, all lifetimes appear\n-     * free, since we don't currently have any binders in type parameter\n-     * declarations; just being forwards compatible with future extensions.\n+     * Given a set of generic declarations, returns a list of names\n+     * containing all early bound lifetime names for those\n+     * generics. (In fact, this list may also contain other names.)\n      */\n \n-    let mut collector = FreeLifetimeCollector { names: vec!() };\n-    for ty_param in ty_params.iter() {\n-        visit::walk_ty_param_bounds(&mut collector, &ty_param.bounds, ());\n+    // Create two lists, dividing the lifetimes into early/late bound.\n+    // Initially, all of them are considered late, but we will move\n+    // things from late into early as we go if we find references to\n+    // them.\n+    let mut early_bound = Vec::new();\n+    let mut late_bound = generics.lifetimes.iter()\n+                                           .map(|l| l.lifetime.name)\n+                                           .collect();\n+\n+    // Any lifetime that appears in a type bound is early.\n+    {\n+        let mut collector =\n+            FreeLifetimeCollector { early_bound: &mut early_bound,\n+                                    late_bound: &mut late_bound };\n+        for ty_param in generics.ty_params.iter() {\n+            visit::walk_ty_param_bounds(&mut collector, &ty_param.bounds, ());\n+        }\n+        for predicate in generics.where_clause.predicates.iter() {\n+            visit::walk_ty_param_bounds(&mut collector, &predicate.bounds, ());\n+        }\n     }\n-    for predicate in where_clause.predicates.iter() {\n-        visit::walk_ty_param_bounds(&mut collector, &predicate.bounds, ());\n+\n+    // Any lifetime that either has a bound or is referenced by a\n+    // bound is early.\n+    for lifetime_def in generics.lifetimes.iter() {\n+        if !lifetime_def.bounds.is_empty() {\n+            shuffle(&mut early_bound, &mut late_bound,\n+                    lifetime_def.lifetime.name);\n+            for bound in lifetime_def.bounds.iter() {\n+                shuffle(&mut early_bound, &mut late_bound,\n+                        bound.name);\n+            }\n+        }\n     }\n-    return collector.names;\n+    return early_bound;\n \n-    struct FreeLifetimeCollector {\n-        names: Vec<ast::Name>,\n+    struct FreeLifetimeCollector<'a> {\n+        early_bound: &'a mut Vec<ast::Name>,\n+        late_bound: &'a mut Vec<ast::Name>,\n     }\n \n-    impl Visitor<()> for FreeLifetimeCollector {\n+    impl<'a> Visitor<()> for FreeLifetimeCollector<'a> {\n         fn visit_lifetime_ref(&mut self,\n                               lifetime_ref: &ast::Lifetime,\n                               _: ()) {\n-            self.names.push(lifetime_ref.name);\n+            shuffle(self.early_bound, self.late_bound,\n+                    lifetime_ref.name);\n+        }\n+    }\n+\n+    fn shuffle(early_bound: &mut Vec<ast::Name>,\n+               late_bound: &mut Vec<ast::Name>,\n+               name: ast::Name) {\n+        match late_bound.iter().position(|n| *n == name) {\n+            Some(index) => {\n+                late_bound.swap_remove(index);\n+                early_bound.push(name);\n+            }\n+            None => { }\n         }\n     }\n }"}, {"sha": "cd3f47e8b2f7a07456deb72ecc0cb922dc2ecce7", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -50,6 +50,7 @@ use syntax::attr;\n use syntax::codemap::*;\n use syntax::parse::token;\n use syntax::parse::token::{get_ident,keywords};\n+use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n use syntax::visit::Visitor;\n use syntax::print::pprust::{path_to_string,ty_to_string};\n@@ -653,7 +654,7 @@ impl <'l> DxrVisitor<'l> {\n                      item: &ast::Item,\n                      e: DxrVisitorEnv,\n                      generics: &ast::Generics,\n-                     trait_refs: &Vec<ast::TraitRef>,\n+                     trait_refs: &OwnedSlice<ast::TyParamBound>,\n                      methods: &Vec<ast::TraitItem>) {\n         let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n \n@@ -665,7 +666,16 @@ impl <'l> DxrVisitor<'l> {\n                            e.cur_scope);\n \n         // super-traits\n-        for trait_ref in trait_refs.iter() {\n+        for super_bound in trait_refs.iter() {\n+            let trait_ref = match *super_bound {\n+                ast::TraitTyParamBound(ref trait_ref) => {\n+                    trait_ref\n+                }\n+                ast::UnboxedFnTyParamBound(..) | ast::RegionTyParamBound(..) => {\n+                    continue;\n+                }\n+            };\n+\n             match self.lookup_type_ref(trait_ref.ref_id) {\n                 Some(id) => {\n                     let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n@@ -1499,7 +1509,7 @@ pub fn process_crate(sess: &Session,\n                                   collected_paths: vec!(),\n                                   collecting: false,\n                                   fmt: FmtStrs::new(box Recorder {\n-                                                        out: output_file as Box<Writer>,\n+                                                        out: output_file as Box<Writer+'static>,\n                                                         dump_spans: false,\n                                                     },\n                                                     SpanUtils {"}, {"sha": "0695b6b360c2ccb51491c9a889a036bdde1f13f4", "filename": "src/librustc/middle/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -19,7 +19,7 @@ use syntax::codemap::*;\n \n pub struct Recorder {\n     // output file\n-    pub out: Box<Writer>,\n+    pub out: Box<Writer+'static>,\n     pub dump_spans: bool,\n }\n "}, {"sha": "d992e840b463643f2cef9c382f5bee1903a858e9", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -611,7 +611,7 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n \n         let t1 = match ty::get(t).sty {\n             ty::ty_param(p) => {\n-                check(self, t, self.substs.types.opt_get(p.space, p.idx))\n+                check(self, p, t, self.substs.types.opt_get(p.space, p.idx))\n             }\n             _ => {\n                 ty_fold::super_fold_ty(self, t)\n@@ -627,6 +627,7 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n         return t1;\n \n         fn check(this: &SubstFolder,\n+                 p: ty::ParamTy,\n                  source_ty: ty::t,\n                  opt_ty: Option<&ty::t>)\n                  -> ty::t {\n@@ -636,8 +637,9 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n                     let span = this.span.unwrap_or(DUMMY_SP);\n                     this.tcx().sess.span_bug(\n                         span,\n-                        format!(\"Type parameter {} out of range \\\n+                        format!(\"Type parameter `{}` ({}) out of range \\\n                                  when substituting (root type={})\",\n+                                p.repr(this.tcx()),\n                                 source_ty.repr(this.tcx()),\n                                 this.root_ty.repr(this.tcx())).as_slice());\n                 }"}, {"sha": "bbd6c252849b3db483c0b616e24f487969ec9556", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -340,6 +340,15 @@ struct ArmData<'a, 'b> {\n  * As we proceed `bound_ptrs` are filled with pointers to values to be bound,\n  * these pointers are stored in llmatch variables just before executing `data` arm.\n  */\n+#[cfg(not(stage0))]\n+struct Match<'a, 'b:'a> {\n+    pats: Vec<Gc<ast::Pat>>,\n+    data: &'a ArmData<'a, 'b>,\n+    bound_ptrs: Vec<(Ident, ValueRef)>\n+}\n+\n+///Dox\n+#[cfg(stage0)]\n struct Match<'a, 'b> {\n     pats: Vec<Gc<ast::Pat>>,\n     data: &'a ArmData<'a, 'b>,"}, {"sha": "b36887c80e92009e31637c5bffd06bfd40bdbcbc", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -25,7 +25,6 @@ use middle::ty;\n use syntax::ast;\n use util::ppaux::Repr;\n \n-\n pub struct CleanupScope<'a> {\n     // The id of this cleanup scope. If the id is None,\n     // this is a *temporary scope* that is pushed during trans to\n@@ -35,7 +34,7 @@ pub struct CleanupScope<'a> {\n     kind: CleanupScopeKind<'a>,\n \n     // Cleanups to run upon scope exit.\n-    cleanups: Vec<Box<Cleanup>>,\n+    cleanups: Vec<CleanupObj>,\n \n     cached_early_exits: Vec<CachedEarlyExit>,\n     cached_landing_pad: Option<BasicBlockRef>,\n@@ -73,6 +72,8 @@ pub trait Cleanup {\n     fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a>;\n }\n \n+pub type CleanupObj = Box<Cleanup+'static>;\n+\n pub enum ScopeId {\n     AstScope(ast::NodeId),\n     CustomScope(CustomScopeIndex)\n@@ -238,7 +239,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                cleanup_scope,\n                self.ccx.tn.val_to_string(val));\n \n-        self.schedule_clean(cleanup_scope, drop as Box<Cleanup>);\n+        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n     fn schedule_drop_mem(&self,\n@@ -264,7 +265,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                self.ccx.tn.val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n \n-        self.schedule_clean(cleanup_scope, drop as Box<Cleanup>);\n+        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n     fn schedule_drop_and_zero_mem(&self,\n@@ -291,7 +292,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                ty.repr(self.ccx.tcx()),\n                true);\n \n-        self.schedule_clean(cleanup_scope, drop as Box<Cleanup>);\n+        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n     fn schedule_drop_immediate(&self,\n@@ -316,7 +317,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                self.ccx.tn.val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n \n-        self.schedule_clean(cleanup_scope, drop as Box<Cleanup>);\n+        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n     fn schedule_free_value(&self,\n@@ -336,12 +337,12 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                self.ccx.tn.val_to_string(val),\n                heap);\n \n-        self.schedule_clean(cleanup_scope, drop as Box<Cleanup>);\n+        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n-                      cleanup: Box<Cleanup>) {\n+                      cleanup: CleanupObj) {\n         match cleanup_scope {\n             AstScope(id) => self.schedule_clean_in_ast_scope(id, cleanup),\n             CustomScope(id) => self.schedule_clean_in_custom_scope(id, cleanup),\n@@ -350,7 +351,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n     fn schedule_clean_in_ast_scope(&self,\n                                    cleanup_scope: ast::NodeId,\n-                                   cleanup: Box<Cleanup>) {\n+                                   cleanup: CleanupObj) {\n         /*!\n          * Schedules a cleanup to occur upon exit from `cleanup_scope`.\n          * If `cleanup_scope` is not provided, then the cleanup is scheduled\n@@ -378,7 +379,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n     fn schedule_clean_in_custom_scope(&self,\n                                       custom_scope: CustomScopeIndex,\n-                                      cleanup: Box<Cleanup>) {\n+                                      cleanup: CleanupObj) {\n         /*!\n          * Schedules a cleanup to occur in the top-most scope,\n          * which must be a temporary scope.\n@@ -1021,13 +1022,13 @@ pub trait CleanupMethods<'a> {\n                            content_ty: ty::t);\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n-                      cleanup: Box<Cleanup>);\n+                      cleanup: CleanupObj);\n     fn schedule_clean_in_ast_scope(&self,\n                                    cleanup_scope: ast::NodeId,\n-                                   cleanup: Box<Cleanup>);\n+                                   cleanup: CleanupObj);\n     fn schedule_clean_in_custom_scope(&self,\n                                     custom_scope: CustomScopeIndex,\n-                                    cleanup: Box<Cleanup>);\n+                                    cleanup: CleanupObj);\n     fn needs_invoke(&self) -> bool;\n     fn get_landing_pad(&'a self) -> BasicBlockRef;\n }"}, {"sha": "26973910400ee1f0a60ccaebc75413d56a0580fe", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -498,9 +498,8 @@ impl TypeMap {\n \n                 unique_type_id.push_char(':');\n \n-                for bound in bounds.iter() {\n+                for bound in bounds.builtin_bounds.iter() {\n                     match bound {\n-                        ty::BoundStatic => unique_type_id.push_str(\"'static\"),\n                         ty::BoundSend => unique_type_id.push_str(\"Send\"),\n                         ty::BoundSized => unique_type_id.push_str(\"Sized\"),\n                         ty::BoundCopy => unique_type_id.push_str(\"Copy\"),"}, {"sha": "24c939dc3be8b1318ff6a46c2dddf4d43d6a07de", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -35,7 +35,7 @@ use middle::trans::tvec;\n use middle::trans::type_::Type;\n use middle::trans::type_of::{type_of, sizing_type_of, align_of};\n use middle::ty;\n-use util::ppaux::ty_to_short_str;\n+use util::ppaux::{ty_to_short_str, Repr};\n use util::ppaux;\n \n use arena::TypedArena;\n@@ -131,6 +131,7 @@ pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n pub fn drop_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n                -> &'a Block<'a> {\n     // NB: v is an *alias* of type t here, not a direct value.\n+    debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n     let _icx = push_ctxt(\"drop_ty\");\n     if ty::type_needs_drop(bcx.tcx(), t) {\n         let ccx = bcx.ccx();\n@@ -213,6 +214,7 @@ fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     let _icx = push_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n     let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx(),\n+                                                                 ty::ReStatic,\n                                                                  ty::ReStatic) {\n         Ok(pair) => pair,\n         Err(s) => {"}, {"sha": "c2d0d27be6df773f9f8ca679cb0478e4c48f7586", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 222, "deletions": 90, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -273,7 +273,7 @@ pub enum UnsizeKind {\n     // An unsize coercion applied to the tail field of a struct.\n     // The uint is the index of the type parameter which is unsized.\n     UnsizeStruct(Box<UnsizeKind>, uint),\n-    UnsizeVtable(ty::BuiltinBounds,\n+    UnsizeVtable(ty::ExistentialBounds,\n                  ast::DefId, /* Trait ID */\n                  subst::Substs /* Trait substitutions */)\n }\n@@ -464,7 +464,6 @@ pub struct ctxt {\n     pub lang_items: middle::lang_items::LanguageItems,\n     /// A mapping of fake provided method def_ids to the default implementation\n     pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n-    pub supertraits: RefCell<DefIdMap<Rc<Vec<Rc<TraitRef>>>>>,\n     pub superstructs: RefCell<DefIdMap<Option<ast::DefId>>>,\n     pub struct_fields: RefCell<DefIdMap<Rc<Vec<field_ty>>>>,\n \n@@ -620,7 +619,7 @@ pub struct ClosureTy {\n     pub fn_style: ast::FnStyle,\n     pub onceness: ast::Onceness,\n     pub store: TraitStore,\n-    pub bounds: BuiltinBounds,\n+    pub bounds: ExistentialBounds,\n     pub sig: FnSig,\n     pub abi: abi::Abi,\n }\n@@ -932,7 +931,7 @@ pub enum sty {\n pub struct TyTrait {\n     pub def_id: DefId,\n     pub substs: Substs,\n-    pub bounds: BuiltinBounds\n+    pub bounds: ExistentialBounds\n }\n \n #[deriving(PartialEq, Eq, Hash, Show)]\n@@ -995,18 +994,30 @@ pub enum type_err {\n     terr_variadic_mismatch(expected_found<bool>)\n }\n \n-#[deriving(PartialEq, Eq, Hash, Show)]\n+/// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n+/// as well as the existential type parameter in an object type.\n+#[deriving(PartialEq, Eq, Hash, Clone, Show)]\n pub struct ParamBounds {\n+    pub opt_region_bound: Option<ty::Region>,\n     pub builtin_bounds: BuiltinBounds,\n     pub trait_bounds: Vec<Rc<TraitRef>>\n }\n \n+/// Bounds suitable for an existentially quantified type parameter\n+/// such as those that appear in object types or closure types. The\n+/// major difference between this case and `ParamBounds` is that\n+/// general purpose trait bounds are omitted.\n+#[deriving(PartialEq, Eq, Hash, Clone, Show)]\n+pub struct ExistentialBounds {\n+    pub region_bound: ty::Region,\n+    pub builtin_bounds: BuiltinBounds\n+}\n+\n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n #[deriving(Clone, Encodable, PartialEq, Eq, Decodable, Hash, Show)]\n #[repr(uint)]\n pub enum BuiltinBound {\n-    BoundStatic,\n     BoundSend,\n     BoundSized,\n     BoundCopy,\n@@ -1019,13 +1030,21 @@ pub fn empty_builtin_bounds() -> BuiltinBounds {\n \n pub fn all_builtin_bounds() -> BuiltinBounds {\n     let mut set = EnumSet::empty();\n-    set.add(BoundStatic);\n     set.add(BoundSend);\n     set.add(BoundSized);\n     set.add(BoundSync);\n     set\n }\n \n+pub fn region_existential_bound(r: ty::Region) -> ExistentialBounds {\n+    /*!\n+     * An existential bound that does not implement any traits.\n+     */\n+\n+    ty::ExistentialBounds { region_bound: r,\n+                            builtin_bounds: empty_builtin_bounds() }\n+}\n+\n impl CLike for BuiltinBound {\n     fn to_uint(&self) -> uint {\n         *self as uint\n@@ -1141,8 +1160,8 @@ pub struct TypeParameterDef {\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n     pub index: uint,\n-    pub bounds: Rc<ParamBounds>,\n-    pub default: Option<ty::t>\n+    pub bounds: ParamBounds,\n+    pub default: Option<ty::t>,\n }\n \n #[deriving(Encodable, Decodable, Clone, Show)]\n@@ -1151,6 +1170,7 @@ pub struct RegionParameterDef {\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n     pub index: uint,\n+    pub bounds: Vec<ty::Region>,\n }\n \n /// Information about the type/lifetime parameters associated with an\n@@ -1198,6 +1218,12 @@ pub struct ParameterEnvironment {\n \n     /// Bounds on the various type parameters\n     pub bounds: VecPerParamSpace<ParamBounds>,\n+\n+    /// Each type parameter has an implicit region bound that\n+    /// indicates it must outlive at least the function body (the user\n+    /// may specify stronger requirements). This field indicates the\n+    /// region of the callee.\n+    pub implicit_region_bound: ty::Region,\n }\n \n impl ParameterEnvironment {\n@@ -1292,7 +1318,7 @@ pub struct Polytype {\n /// As `Polytype` but for a trait ref.\n pub struct TraitDef {\n     pub generics: Generics,\n-    pub bounds: BuiltinBounds,\n+    pub bounds: ParamBounds,\n     pub trait_ref: Rc<ty::TraitRef>,\n }\n \n@@ -1382,7 +1408,6 @@ pub fn mk_ctxt(s: Session,\n         normalized_cache: RefCell::new(HashMap::new()),\n         lang_items: lang_items,\n         provided_method_sources: RefCell::new(DefIdMap::new()),\n-        supertraits: RefCell::new(DefIdMap::new()),\n         superstructs: RefCell::new(DefIdMap::new()),\n         struct_fields: RefCell::new(DefIdMap::new()),\n         destructor_for_type: RefCell::new(DefIdMap::new()),\n@@ -1459,6 +1484,9 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         }\n         return f;\n     }\n+    fn flags_for_bounds(bounds: &ExistentialBounds) -> uint {\n+        rflags(bounds.region_bound)\n+    }\n     match &st {\n       &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n       &ty_str => {}\n@@ -1483,8 +1511,9 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n           flags |= sflags(substs);\n       }\n-      &ty_trait(box ty::TyTrait { ref substs, .. }) => {\n+      &ty_trait(box ty::TyTrait { ref substs, ref bounds, .. }) => {\n           flags |= sflags(substs);\n+          flags |= flags_for_bounds(bounds);\n       }\n       &ty_box(tt) | &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n         flags |= get(tt).flags\n@@ -1514,6 +1543,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         flags |= get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n         flags &= !(has_ty_bot as uint);\n+        flags |= flags_for_bounds(&f.bounds);\n       }\n     }\n \n@@ -1711,8 +1741,8 @@ pub fn mk_ctor_fn(cx: &ctxt,\n pub fn mk_trait(cx: &ctxt,\n                 did: ast::DefId,\n                 substs: Substs,\n-                bounds: BuiltinBounds)\n-             -> t {\n+                bounds: ExistentialBounds)\n+                -> t {\n     // take a copy of substs so that we own the vectors inside\n     let inner = box TyTrait {\n         def_id: did,\n@@ -1800,6 +1830,27 @@ pub fn walk_regions_and_ty(cx: &ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n                                    |t| { fldt(t); t }).fold_ty(ty)\n }\n \n+impl ParamTy {\n+    pub fn new(space: subst::ParamSpace,\n+               index: uint,\n+               def_id: ast::DefId)\n+               -> ParamTy {\n+        ParamTy { space: space, idx: index, def_id: def_id }\n+    }\n+\n+    pub fn for_self(trait_def_id: ast::DefId) -> ParamTy {\n+        ParamTy::new(subst::SelfSpace, 0, trait_def_id)\n+    }\n+\n+    pub fn for_def(def: &TypeParameterDef) -> ParamTy {\n+        ParamTy::new(def.space, def.index, def.def_id)\n+    }\n+\n+    pub fn to_ty(self, tcx: &ty::ctxt) -> ty::t {\n+        ty::mk_param(tcx, self.space, self.idx, self.def_id)\n+    }\n+}\n+\n impl ItemSubsts {\n     pub fn empty() -> ItemSubsts {\n         ItemSubsts { substs: Substs::empty() }\n@@ -2115,9 +2166,6 @@ def_type_content_sets!(\n         //       that it neither reaches nor owns a managed pointer.\n         Nonsendable                         = 0b0000_0111__0000_0100__0000,\n \n-        // Things that prevent values from being considered 'static\n-        Nonstatic                           = 0b0000_0010__0000_0000__0000,\n-\n         // Things that prevent values from being considered sized\n         Nonsized                            = 0b0000_0000__0000_0000__0001,\n \n@@ -2142,9 +2190,8 @@ def_type_content_sets!(\n )\n \n impl TypeContents {\n-    pub fn meets_bound(&self, cx: &ctxt, bb: BuiltinBound) -> bool {\n+    pub fn meets_builtin_bound(&self, cx: &ctxt, bb: BuiltinBound) -> bool {\n         match bb {\n-            BoundStatic => self.is_static(cx),\n             BoundSend => self.is_sendable(cx),\n             BoundSized => self.is_sized(cx),\n             BoundCopy => self.is_copy(cx),\n@@ -2160,10 +2207,6 @@ impl TypeContents {\n         (self.bits & tc.bits) != 0\n     }\n \n-    pub fn is_static(&self, _: &ctxt) -> bool {\n-        !self.intersects(TC::Nonstatic)\n-    }\n-\n     pub fn is_sendable(&self, _: &ctxt) -> bool {\n         !self.intersects(TC::Nonsendable)\n     }\n@@ -2272,10 +2315,6 @@ impl fmt::Show for TypeContents {\n     }\n }\n \n-pub fn type_is_static(cx: &ctxt, t: ty::t) -> bool {\n-    type_contents(cx, t).is_static(cx)\n-}\n-\n pub fn type_is_sendable(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_sendable(cx)\n }\n@@ -2482,10 +2521,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n                 let ty_param_defs = cx.ty_param_defs.borrow();\n                 let tp_def = ty_param_defs.get(&p.def_id.node);\n-                kind_bounds_to_contents(cx,\n-                                        tp_def.bounds.builtin_bounds,\n-                                        tp_def.bounds.trait_bounds.as_slice())\n-           }\n+                kind_bounds_to_contents(\n+                    cx,\n+                    tp_def.bounds.builtin_bounds,\n+                    tp_def.bounds.trait_bounds.as_slice())\n+            }\n \n             ty_infer(_) => {\n                 // This occurs during coherence, but shouldn't occur at other\n@@ -2577,10 +2617,10 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n     }\n \n     fn object_contents(cx: &ctxt,\n-                       bounds: BuiltinBounds)\n+                       bounds: ExistentialBounds)\n                        -> TypeContents {\n         // These are the type contents of the (opaque) interior\n-        kind_bounds_to_contents(cx, bounds, [])\n+        kind_bounds_to_contents(cx, bounds.builtin_bounds, [])\n     }\n \n     fn kind_bounds_to_contents(cx: &ctxt,\n@@ -2591,7 +2631,6 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         let mut tc = TC::All;\n         each_inherited_builtin_bound(cx, bounds, traits, |bound| {\n             tc = tc - match bound {\n-                BoundStatic => TC::Nonstatic,\n                 BoundSend => TC::Nonsendable,\n                 BoundSized => TC::Nonsized,\n                 BoundCopy => TC::Noncopy,\n@@ -2612,7 +2651,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n             each_bound_trait_and_supertraits(cx, traits, |trait_ref| {\n                 let trait_def = lookup_trait_def(cx, trait_ref.def_id);\n-                for bound in trait_def.bounds.iter() {\n+                for bound in trait_def.bounds.builtin_bounds.iter() {\n                     f(bound);\n                 }\n                 true\n@@ -3272,16 +3311,19 @@ pub fn adjust_ty(cx: &ctxt,\n                 AutoAddEnv(store) => {\n                     match ty::get(unadjusted_ty).sty {\n                         ty::ty_bare_fn(ref b) => {\n+                            let bounds = ty::ExistentialBounds {\n+                                region_bound: ReStatic,\n+                                builtin_bounds: all_builtin_bounds(),\n+                            };\n+\n                             ty::mk_closure(\n                                 cx,\n-                                ty::ClosureTy {\n-                                    fn_style: b.fn_style,\n-                                    onceness: ast::Many,\n-                                    store: store,\n-                                    bounds: ty::all_builtin_bounds(),\n-                                    sig: b.sig.clone(),\n-                                    abi: b.abi,\n-                                })\n+                                ty::ClosureTy {fn_style: b.fn_style,\n+                                               onceness: ast::Many,\n+                                               store: store,\n+                                               bounds: bounds,\n+                                               sig: b.sig.clone(),\n+                                               abi: b.abi})\n                         }\n                         ref b => {\n                             cx.sess.bug(\n@@ -3920,30 +3962,6 @@ pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n     }\n }\n \n-pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<TraitRef>>> {\n-    // Check the cache.\n-    match cx.supertraits.borrow().find(&id) {\n-        Some(trait_refs) => { return trait_refs.clone(); }\n-        None => {}  // Continue.\n-    }\n-\n-    // Not in the cache. It had better be in the metadata, which means it\n-    // shouldn't be local.\n-    assert!(!is_local(id));\n-\n-    // Get the supertraits out of the metadata and create the\n-    // TraitRef for each.\n-    let result = Rc::new(csearch::get_supertraits(cx, id));\n-    cx.supertraits.borrow_mut().insert(id, result.clone());\n-    result\n-}\n-\n-pub fn trait_ref_supertraits(cx: &ctxt, trait_ref: &ty::TraitRef) -> Vec<Rc<TraitRef>> {\n-    let supertrait_refs = trait_supertraits(cx, trait_ref.def_id);\n-    supertrait_refs.iter().map(\n-        |supertrait_ref| supertrait_ref.subst(cx, &trait_ref.substs)).collect()\n-}\n-\n fn lookup_locally_or_in_crate_store<V:Clone>(\n                                     descr: &str,\n                                     def_id: ast::DefId,\n@@ -4055,9 +4073,12 @@ pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n     def.def_id()\n }\n \n-pub fn try_add_builtin_trait(tcx: &ctxt,\n-                             trait_def_id: ast::DefId,\n-                             builtin_bounds: &mut BuiltinBounds) -> bool {\n+pub fn try_add_builtin_trait(\n+    tcx: &ctxt,\n+    trait_def_id: ast::DefId,\n+    builtin_bounds: &mut EnumSet<BuiltinBound>)\n+    -> bool\n+{\n     //! Checks whether `trait_ref` refers to one of the builtin\n     //! traits, like `Send`, and adds the corresponding\n     //! bound to the set `builtin_bounds` if so. Returns true if `trait_ref`\n@@ -4343,6 +4364,18 @@ pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> Rc<ty::TraitDef> {\n     }\n }\n \n+/// Given a reference to a trait, returns the bounds declared on the\n+/// trait, with appropriate substitutions applied.\n+pub fn bounds_for_trait_ref(tcx: &ctxt,\n+                            trait_ref: &TraitRef)\n+                            -> ty::ParamBounds\n+{\n+    let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n+    debug!(\"bounds_for_trait_ref(trait_def={}, trait_ref={})\",\n+           trait_def.repr(tcx), trait_ref.repr(tcx));\n+    trait_def.bounds.subst(tcx, &trait_ref.substs)\n+}\n+\n /// Iterate over attributes of a definition.\n // (This should really be an iterator, but that would require csearch and\n // decoder to use iterators instead of higher-order functions.)\n@@ -4410,14 +4443,10 @@ pub fn lookup_field_type(tcx: &ctxt,\n         node_id_to_type(tcx, id.node)\n     } else {\n         let mut tcache = tcx.tcache.borrow_mut();\n-        match tcache.find(&id) {\n-           Some(&Polytype {ty, ..}) => ty,\n-           None => {\n-               let tpt = csearch::get_field_type(tcx, struct_id, id);\n-               tcache.insert(id, tpt.clone());\n-               tpt.ty\n-           }\n-        }\n+        let pty = tcache.find_or_insert_with(id, |_| {\n+            csearch::get_field_type(tcx, struct_id, id)\n+        });\n+        pty.ty\n     };\n     t.subst(tcx, substs)\n }\n@@ -4745,9 +4774,10 @@ pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n             }\n \n             // Add supertraits to supertrait_set\n-            let supertrait_refs = trait_ref_supertraits(tcx,\n-                                                        &**trait_refs.get(i));\n-            for supertrait_ref in supertrait_refs.iter() {\n+            let trait_ref = trait_refs.get(i).clone();\n+            let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n+            for supertrait_ref in trait_def.bounds.trait_bounds.iter() {\n+                let supertrait_ref = supertrait_ref.subst(tcx, &trait_ref.substs);\n                 debug!(\"each_bound_trait_and_supertraits(supertrait_ref={})\",\n                        supertrait_ref.repr(tcx));\n \n@@ -4765,6 +4795,61 @@ pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n     return true;\n }\n \n+pub fn required_region_bounds(tcx: &ctxt,\n+                              region_bounds: &[ty::Region],\n+                              builtin_bounds: BuiltinBounds,\n+                              trait_bounds: &[Rc<TraitRef>])\n+                              -> Vec<ty::Region>\n+{\n+    /*!\n+     * Given a type which must meet the builtin bounds and trait\n+     * bounds, returns a set of lifetimes which the type must outlive.\n+     *\n+     * Requires that trait definitions have been processed.\n+     */\n+\n+    let mut all_bounds = Vec::new();\n+\n+    debug!(\"required_region_bounds(builtin_bounds={}, trait_bounds={})\",\n+           builtin_bounds.repr(tcx),\n+           trait_bounds.repr(tcx));\n+\n+    all_bounds.push_all(region_bounds);\n+\n+    push_region_bounds([],\n+                       builtin_bounds,\n+                       &mut all_bounds);\n+\n+    debug!(\"from builtin bounds: all_bounds={}\", all_bounds.repr(tcx));\n+\n+    each_bound_trait_and_supertraits(\n+        tcx,\n+        trait_bounds,\n+        |trait_ref| {\n+            let bounds = ty::bounds_for_trait_ref(tcx, &*trait_ref);\n+            push_region_bounds(bounds.opt_region_bound.as_slice(),\n+                               bounds.builtin_bounds,\n+                               &mut all_bounds);\n+            debug!(\"from {}: bounds={} all_bounds={}\",\n+                   trait_ref.repr(tcx),\n+                   bounds.repr(tcx),\n+                   all_bounds.repr(tcx));\n+            true\n+        });\n+\n+    return all_bounds;\n+\n+    fn push_region_bounds(region_bounds: &[ty::Region],\n+                          builtin_bounds: ty::BuiltinBounds,\n+                          all_bounds: &mut Vec<ty::Region>) {\n+        all_bounds.push_all(region_bounds.as_slice());\n+\n+        if builtin_bounds.contains_elem(ty::BoundSend) {\n+            all_bounds.push(ty::ReStatic);\n+        }\n+    }\n+}\n+\n pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, String> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n         tcx.intrinsic_defs.borrow().find_copy(&tydesc_lang_item)\n@@ -4780,19 +4865,23 @@ pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, String> {\n }\n \n pub fn visitor_object_ty(tcx: &ctxt,\n-                         region: ty::Region) -> Result<(Rc<TraitRef>, t), String> {\n+                         ptr_region: ty::Region,\n+                         trait_region: ty::Region)\n+                         -> Result<(Rc<TraitRef>, t), String>\n+{\n     let trait_lang_item = match tcx.lang_items.require(TyVisitorTraitLangItem) {\n         Ok(id) => id,\n         Err(s) => { return Err(s); }\n     };\n     let substs = Substs::empty();\n     let trait_ref = Rc::new(TraitRef { def_id: trait_lang_item, substs: substs });\n     Ok((trait_ref.clone(),\n-        mk_rptr(tcx, region, mt {mutbl: ast::MutMutable,\n-                                 ty: mk_trait(tcx,\n-                                              trait_ref.def_id,\n-                                              trait_ref.substs.clone(),\n-                                              empty_builtin_bounds()) })))\n+        mk_rptr(tcx, ptr_region,\n+                mt {mutbl: ast::MutMutable,\n+                    ty: mk_trait(tcx,\n+                                 trait_ref.def_id,\n+                                 trait_ref.substs.clone(),\n+                                 ty::region_existential_bound(trait_region))})))\n }\n \n pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n@@ -5184,6 +5273,18 @@ pub fn construct_parameter_environment(\n                               generics.types.get_slice(space));\n     }\n \n+    //\n+    // Compute region bounds. For now, these relations are stored in a\n+    // global table on the tcx, so just enter them there. I'm not\n+    // crazy about this scheme, but it's convenient, at least.\n+    //\n+\n+    for &space in subst::ParamSpace::all().iter() {\n+        record_region_bounds_from_defs(tcx, space, &free_substs,\n+                                       generics.regions.get_slice(space));\n+    }\n+\n+\n     debug!(\"construct_parameter_environment: free_id={} \\\n            free_subst={} \\\n            bounds={}\",\n@@ -5193,7 +5294,8 @@ pub fn construct_parameter_environment(\n \n     return ty::ParameterEnvironment {\n         free_substs: free_substs,\n-        bounds: bounds\n+        bounds: bounds,\n+        implicit_region_bound: ty::ReScope(free_id),\n     };\n \n     fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n@@ -5222,10 +5324,41 @@ pub fn construct_parameter_environment(\n                              free_substs: &subst::Substs,\n                              defs: &[TypeParameterDef]) {\n         for def in defs.iter() {\n-            let b = (*def.bounds).subst(tcx, free_substs);\n+            let b = def.bounds.subst(tcx, free_substs);\n             bounds.push(space, b);\n         }\n     }\n+\n+    fn record_region_bounds_from_defs(tcx: &ty::ctxt,\n+                                      space: subst::ParamSpace,\n+                                      free_substs: &subst::Substs,\n+                                      defs: &[RegionParameterDef]) {\n+        for (subst_region, def) in\n+            free_substs.regions().get_slice(space).iter().zip(\n+                defs.iter())\n+        {\n+            // For each region parameter 'subst...\n+            let bounds = def.bounds.subst(tcx, free_substs);\n+            for bound_region in bounds.iter() {\n+                // Which is declared with a bound like 'subst:'bound...\n+                match (subst_region, bound_region) {\n+                    (&ty::ReFree(subst_fr), &ty::ReFree(bound_fr)) => {\n+                        // Record that 'subst outlives 'bound. Or, put\n+                        // another way, 'bound <= 'subst.\n+                        tcx.region_maps.relate_free_regions(bound_fr, subst_fr);\n+                    },\n+                    _ => {\n+                        // All named regions are instantiated with free regions.\n+                        tcx.sess.bug(\n+                            format!(\"push_region_bounds_from_defs: \\\n+                                     non free region: {} / {}\",\n+                                    subst_region.repr(tcx),\n+                                    bound_region.repr(tcx)).as_slice());\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n impl BorrowKind {\n@@ -5346,4 +5479,3 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n         }\n     })\n }\n-"}, {"sha": "435c591f881bbda26713d1f1cfd9c71fe8a64209", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -85,6 +85,11 @@ pub trait TypeFolder {\n         super_fold_trait_store(self, s)\n     }\n \n+    fn fold_existential_bounds(&mut self, s: ty::ExistentialBounds)\n+                               -> ty::ExistentialBounds {\n+        super_fold_existential_bounds(self, s)\n+    }\n+\n     fn fold_autoref(&mut self, ar: &ty::AutoRef) -> ty::AutoRef {\n         super_fold_autoref(self, ar)\n     }\n@@ -236,9 +241,16 @@ impl TypeFoldable for ty::BuiltinBounds {\n     }\n }\n \n+impl TypeFoldable for ty::ExistentialBounds {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ExistentialBounds {\n+        folder.fold_existential_bounds(*self)\n+    }\n+}\n+\n impl TypeFoldable for ty::ParamBounds {\n     fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ParamBounds {\n         ty::ParamBounds {\n+            opt_region_bound: self.opt_region_bound.fold_with(folder),\n             builtin_bounds: self.builtin_bounds.fold_with(folder),\n             trait_bounds: self.trait_bounds.fold_with(folder),\n         }\n@@ -259,8 +271,14 @@ impl TypeFoldable for ty::TypeParameterDef {\n }\n \n impl TypeFoldable for ty::RegionParameterDef {\n-    fn fold_with<F:TypeFolder>(&self, _folder: &mut F) -> ty::RegionParameterDef {\n-        *self\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::RegionParameterDef {\n+        ty::RegionParameterDef {\n+            name: self.name,\n+            def_id: self.def_id,\n+            space: self.space,\n+            index: self.index,\n+            bounds: self.bounds.fold_with(folder)\n+        }\n     }\n }\n \n@@ -340,7 +358,7 @@ pub fn super_fold_closure_ty<T:TypeFolder>(this: &mut T,\n         sig: fty.sig.fold_with(this),\n         fn_style: fty.fn_style,\n         onceness: fty.onceness,\n-        bounds: fty.bounds,\n+        bounds: fty.bounds.fold_with(this),\n         abi: fty.abi,\n     }\n }\n@@ -389,7 +407,7 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n             ty::ty_trait(box ty::TyTrait {\n                 def_id: def_id,\n                 substs: substs.fold_with(this),\n-                bounds: bounds\n+                bounds: this.fold_existential_bounds(bounds),\n             })\n         }\n         ty::ty_tup(ref ts) => {\n@@ -430,6 +448,15 @@ pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n     }\n }\n \n+pub fn super_fold_existential_bounds<T:TypeFolder>(this: &mut T,\n+                                                   bounds: ty::ExistentialBounds)\n+                                                   -> ty::ExistentialBounds {\n+    ty::ExistentialBounds {\n+        region_bound: bounds.region_bound.fold_with(this),\n+        builtin_bounds: bounds.builtin_bounds,\n+    }\n+}\n+\n pub fn super_fold_autoref<T:TypeFolder>(this: &mut T,\n                                         autoref: &ty::AutoRef)\n                                         -> ty::AutoRef"}, {"sha": "6cd61a8c3f85c9c99936fa988580db099c150b9d", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 316, "deletions": 113, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -57,19 +57,19 @@ use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n use middle::ty;\n-use middle::ty_fold::TypeFolder;\n-use middle::typeck::rscope::RegionScope;\n-use middle::typeck::rscope::{ExplicitRscope, ImpliedSingleRscope};\n-use middle::typeck::{TypeAndSubsts, infer, lookup_def_tcx, rscope};\n+use middle::typeck::lookup_def_tcx;\n+use middle::typeck::infer;\n+use middle::typeck::rscope::{ExplicitRscope, RegionScope, SpecificRscope};\n+use middle::typeck::rscope;\n+use middle::typeck::TypeAndSubsts;\n use middle::typeck;\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr, UserString};\n \n+use std::collections::HashMap;\n use std::rc::Rc;\n use syntax::abi;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n-use syntax::owned_slice::OwnedSlice;\n-use syntax::print::pprust::{lifetime_to_string, path_to_string};\n \n pub trait AstConv {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n@@ -111,8 +111,9 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n     };\n \n     debug!(\"ast_region_to_region(lifetime={} id={}) yields {}\",\n-            lifetime_to_string(lifetime),\n-            lifetime.id, r.repr(tcx));\n+           lifetime.repr(tcx),\n+           lifetime.id,\n+           r.repr(tcx));\n \n     r\n }\n@@ -145,7 +146,7 @@ pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n     };\n \n     debug!(\"opt_ast_region_to_region(opt_lifetime={}) yields {}\",\n-            opt_lifetime.as_ref().map(|e| lifetime_to_string(e)),\n+            opt_lifetime.repr(this.tcx()),\n             r.repr(this.tcx()));\n \n     r\n@@ -284,11 +285,11 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope>(\n }\n \n pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n-        this: &AC,\n-        rscope: &RS,\n-        did: ast::DefId,\n-        path: &ast::Path)\n-     -> TypeAndSubsts\n+    this: &AC,\n+    rscope: &RS,\n+    did: ast::DefId,\n+    path: &ast::Path)\n+    -> TypeAndSubsts\n {\n     let tcx = this.tcx();\n     let ty::Polytype {\n@@ -370,7 +371,7 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n                                       format!(\"unbound path {}\",\n-                                              path_to_string(path)).as_slice())\n+                                              path.repr(tcx)).as_slice())\n                 }\n                 Some(&d) => d\n             };\n@@ -430,7 +431,7 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n                         .sess\n                         .span_bug(ast_ty.span,\n                                   format!(\"unbound path {}\",\n-                                          path_to_string(path)).as_slice())\n+                                          path.repr(this.tcx())).as_slice())\n                 }\n                 Some(&d) => d\n             };\n@@ -520,6 +521,16 @@ enum PointerTy {\n     Uniq\n }\n \n+impl PointerTy {\n+    fn default_region(&self) -> ty::Region {\n+        match *self {\n+            Box => ty::ReStatic,\n+            Uniq => ty::ReStatic,\n+            RPtr(r) => r,\n+        }\n+    }\n+}\n+\n pub fn trait_ref_for_unboxed_function<AC:AstConv,\n                                       RS:RegionScope>(\n                                       this: &AC,\n@@ -589,10 +600,11 @@ fn mk_pointer<AC:AstConv,\n                                                rscope,\n                                                &**unboxed_function,\n                                                None);\n+            let r = ptr_ty.default_region();\n             let tr = ty::mk_trait(this.tcx(),\n                                   def_id,\n                                   substs,\n-                                  ty::empty_builtin_bounds());\n+                                  ty::region_existential_bound(r));\n             match ptr_ty {\n                 Uniq => {\n                     return ty::mk_uniq(this.tcx(), tr);\n@@ -612,7 +624,7 @@ fn mk_pointer<AC:AstConv,\n \n             }\n         }\n-        ast::TyPath(ref path, ref bounds, id) => {\n+        ast::TyPath(ref path, ref opt_bounds, id) => {\n             // Note that the \"bounds must be empty if path is not a trait\"\n             // restriction is enforced in the below case for ty_path, which\n             // will run after this as long as the path isn't a trait.\n@@ -636,14 +648,22 @@ fn mk_pointer<AC:AstConv,\n                 Some(&def::DefTrait(trait_def_id)) => {\n                     let result = ast_path_to_trait_ref(\n                         this, rscope, trait_def_id, None, path);\n-                    let static_region = match ptr_ty {\n-                        RPtr(r) if r == ty::ReStatic => true,\n-                        _ => false\n+                    let bounds = match *opt_bounds {\n+                        None => {\n+                            conv_existential_bounds(this,\n+                                                    rscope,\n+                                                    path.span,\n+                                                    [result.clone()].as_slice(),\n+                                                    [].as_slice())\n+                        }\n+                        Some(ref bounds) => {\n+                            conv_existential_bounds(this,\n+                                                    rscope,\n+                                                    path.span,\n+                                                    [result.clone()].as_slice(),\n+                                                    bounds.as_slice())\n+                        }\n                     };\n-                    let bounds = conv_builtin_bounds(this.tcx(),\n-                                                     path.span,\n-                                                     bounds,\n-                                                     static_region);\n                     let tr = ty::mk_trait(tcx,\n                                           result.def_id,\n                                           result.substs.clone(),\n@@ -737,27 +757,22 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.fn_style,\n                                                   bf.abi, &*bf.decl))\n             }\n-            ast::TyClosure(ref f, ref region) => {\n-\n-                // resolve the function bound region in the original region\n-                // scope `rscope`, not the scope of the function parameters\n-                let bound_region = opt_ast_region_to_region(this, rscope,\n-                                                            ast_ty.span, region);\n-\n+            ast::TyClosure(ref f) => {\n                 // Use corresponding trait store to figure out default bounds\n                 // if none were specified.\n-                let bounds = conv_builtin_bounds(this.tcx(),\n-                                                 ast_ty.span,\n-                                                 &f.bounds,\n-                                                 bound_region == ty::ReStatic);\n-\n-                let store = ty::RegionTraitStore(bound_region, ast::MutMutable);\n+                let bounds = conv_existential_bounds(this,\n+                                                     rscope,\n+                                                     ast_ty.span,\n+                                                     [].as_slice(),\n+                                                     f.bounds.as_slice());\n                 let fn_decl = ty_of_closure(this,\n                                             ast_ty.id,\n                                             f.fn_style,\n                                             f.onceness,\n                                             bounds,\n-                                            store,\n+                                            ty::RegionTraitStore(\n+                                                bounds.region_bound,\n+                                                ast::MutMutable),\n                                             &*f.decl,\n                                             abi::Rust,\n                                             None);\n@@ -766,10 +781,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             ast::TyProc(ref f) => {\n                 // Use corresponding trait store to figure out default bounds\n                 // if none were specified.\n-                let bounds = conv_builtin_bounds(this.tcx(),\n-                                                 ast_ty.span,\n-                                                 &f.bounds,\n-                                                 false);\n+                let bounds = conv_existential_bounds(this, rscope,\n+                                                     ast_ty.span,\n+                                                     [].as_slice(),\n+                                                     f.bounds.as_slice());\n \n                 let fn_decl = ty_of_closure(this,\n                                             ast_ty.id,\n@@ -780,6 +795,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                             &*f.decl,\n                                             abi::Rust,\n                                             None);\n+\n                 ty::mk_closure(tcx, fn_decl)\n             }\n             ast::TyUnboxedFn(..) => {\n@@ -793,7 +809,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n                                      format!(\"unbound path {}\",\n-                                             path_to_string(path)).as_slice())\n+                                             path.repr(tcx)).as_slice())\n                     }\n                     Some(&d) => d\n                 };\n@@ -808,16 +824,22 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 }\n                 match a_def {\n                     def::DefTrait(trait_def_id) => {\n-                    let result = ast_path_to_trait_ref(\n-                        this, rscope, trait_def_id, None, path);\n-                    let bounds = conv_builtin_bounds(this.tcx(),\n-                                                     path.span,\n-                                                     bounds,\n-                                                     false);\n-                    ty::mk_trait(tcx,\n-                                 result.def_id,\n-                                 result.substs.clone(),\n-                                 bounds)\n+                        let result = ast_path_to_trait_ref(\n+                            this, rscope, trait_def_id, None, path);\n+                        let empty_bounds: &[ast::TyParamBound] = &[];\n+                        let ast_bounds = match *bounds {\n+                            Some(ref b) => b.as_slice(),\n+                            None => empty_bounds\n+                        };\n+                        let bounds = conv_existential_bounds(this,\n+                                                             rscope,\n+                                                             ast_ty.span,\n+                                                             &[result.clone()],\n+                                                             ast_bounds);\n+                        ty::mk_trait(tcx,\n+                                     result.def_id,\n+                                     result.substs.clone(),\n+                                     bounds)\n                     }\n                     def::DefTy(did) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty\n@@ -1022,9 +1044,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n         _ => {\n             match implied_output_region {\n                 Some(implied_output_region) => {\n-                    let rb = ImpliedSingleRscope {\n-                        region: implied_output_region,\n-                    };\n+                    let rb = SpecificRscope::new(implied_output_region);\n                     ast_ty_to_ty(this, &rb, &*decl.output)\n                 }\n                 None => {\n@@ -1130,7 +1150,7 @@ pub fn ty_of_closure<AC:AstConv>(\n     id: ast::NodeId,\n     fn_style: ast::FnStyle,\n     onceness: ast::Onceness,\n-    bounds: ty::BuiltinBounds,\n+    bounds: ty::ExistentialBounds,\n     store: ty::TraitStore,\n     decl: &ast::FnDecl,\n     abi: abi::Abi,\n@@ -1176,67 +1196,250 @@ pub fn ty_of_closure<AC:AstConv>(\n     }\n }\n \n-fn conv_builtin_bounds(tcx: &ty::ctxt,\n-                       span: Span,\n-                       ast_bounds: &Option<OwnedSlice<ast::TyParamBound>>,\n-                       static_region: bool)\n-                       -> ty::BuiltinBounds {\n-    //! Converts a list of bounds from the AST into a `BuiltinBounds`\n-    //! struct. Reports an error if any of the bounds that appear\n-    //! in the AST refer to general traits and not the built-in traits\n-    //! like `Send`. Used to translate the bounds that\n-    //! appear in closure and trait types, where only builtin bounds are\n-    //! legal.\n-    //! If no bounds were specified, we choose a \"default\" bound based on\n-    //! the allocation type of the fn/trait, as per issue #7264. The user can\n-    //! override this with an empty bounds list, e.g. \"Box<fn:()>\" or\n-    //! \"Box<Trait:>\".\n-\n-    match ast_bounds {\n-        &Some(ref bound_vec) => {\n-            let mut builtin_bounds = ty::empty_builtin_bounds();\n-            for ast_bound in bound_vec.iter() {\n-                match *ast_bound {\n-                    ast::TraitTyParamBound(ref b) => {\n-                        match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n-                            def::DefTrait(trait_did) => {\n-                                if ty::try_add_builtin_trait(tcx, trait_did,\n-                                                             &mut builtin_bounds) {\n-                                    continue; // success\n-                                }\n+pub fn conv_existential_bounds<AC:AstConv, RS:RegionScope>(\n+    this: &AC,\n+    rscope: &RS,\n+    span: Span,\n+    main_trait_refs: &[Rc<ty::TraitRef>],\n+    ast_bounds: &[ast::TyParamBound])\n+    -> ty::ExistentialBounds\n+{\n+    /*!\n+     * Given an existential type like `Foo+'a+Bar`, this routine\n+     * converts the `'a` and `Bar` intos an `ExistentialBounds`\n+     * struct. The `main_trait_refs` argument specifies the `Foo` --\n+     * it is absent for closures. Eventually this should all be\n+     * normalized, I think, so that there is no \"main trait ref\" and\n+     * instead we just have a flat list of bounds as the existential\n+     * type.\n+     */\n+\n+    let ast_bound_refs: Vec<&ast::TyParamBound> =\n+        ast_bounds.iter().collect();\n+\n+    let PartitionedBounds { builtin_bounds,\n+                            trait_bounds,\n+                            region_bounds,\n+                            unboxed_fn_ty_bounds } =\n+        partition_bounds(this.tcx(), span, ast_bound_refs.as_slice());\n+\n+    if !trait_bounds.is_empty() {\n+        let b = trait_bounds.get(0);\n+        this.tcx().sess.span_err(\n+            b.path.span,\n+            format!(\"only the builtin traits can be used \\\n+                     as closure or object bounds\").as_slice());\n+    }\n+\n+    if !unboxed_fn_ty_bounds.is_empty() {\n+        this.tcx().sess.span_err(\n+            span,\n+            format!(\"only the builtin traits can be used \\\n+                     as closure or object bounds\").as_slice());\n+    }\n+\n+    // The \"main trait refs\", rather annoyingly, have no type\n+    // specified for the `Self` parameter of the trait. The reason for\n+    // this is that they are, after all, *existential* types, and\n+    // hence that type is unknown. However, leaving this type missing\n+    // causes the substitution code to go all awry when walking the\n+    // bounds, so here we clone those trait refs and insert ty::err as\n+    // the self type. Perhaps we should do this more generally, it'd\n+    // be convenient (or perhaps something else, i.e., ty::erased).\n+    let main_trait_refs: Vec<Rc<ty::TraitRef>> =\n+        main_trait_refs.iter()\n+        .map(|t|\n+             Rc::new(ty::TraitRef {\n+                 def_id: t.def_id,\n+                 substs: t.substs.with_self_ty(ty::mk_err()) }))\n+        .collect();\n+\n+    let region_bound = compute_region_bound(this,\n+                                            rscope,\n+                                            span,\n+                                            builtin_bounds,\n+                                            region_bounds.as_slice(),\n+                                            main_trait_refs.as_slice());\n+\n+    ty::ExistentialBounds {\n+        region_bound: region_bound,\n+        builtin_bounds: builtin_bounds,\n+    }\n+}\n+\n+pub fn compute_opt_region_bound(tcx: &ty::ctxt,\n+                                span: Span,\n+                                builtin_bounds: ty::BuiltinBounds,\n+                                region_bounds: &[&ast::Lifetime],\n+                                trait_bounds: &[Rc<ty::TraitRef>])\n+                                -> Option<ty::Region>\n+{\n+    /*!\n+     * Given the bounds on a type parameter / existential type,\n+     * determines what single region bound (if any) we can use to\n+     * summarize this type. The basic idea is that we will use the\n+     * bound the user provided, if they provided one, and otherwise\n+     * search the supertypes of trait bounds for region bounds. It may\n+     * be that we can derive no bound at all, in which case we return\n+     * `None`.\n+     */\n+\n+    if region_bounds.len() > 1 {\n+        tcx.sess.span_err(\n+            region_bounds[1].span,\n+            format!(\"only a single explicit lifetime bound is permitted\").as_slice());\n+    }\n+\n+    if region_bounds.len() != 0 {\n+        // Explicitly specified region bound. Use that.\n+        let r = region_bounds[0];\n+        return Some(ast_region_to_region(tcx, r));\n+    }\n+\n+    // No explicit region bound specified. Therefore, examine trait\n+    // bounds and see if we can derive region bounds from those.\n+    let derived_region_bounds =\n+        ty::required_region_bounds(\n+            tcx,\n+            [],\n+            builtin_bounds,\n+            trait_bounds);\n+\n+    // If there are no derived region bounds, then report back that we\n+    // can find no region bound.\n+    if derived_region_bounds.len() == 0 {\n+        return None;\n+    }\n+\n+    // If any of the derived region bounds are 'static, that is always\n+    // the best choice.\n+    if derived_region_bounds.iter().any(|r| ty::ReStatic == *r) {\n+        return Some(ty::ReStatic);\n+    }\n+\n+    // Determine whether there is exactly one unique region in the set\n+    // of derived region bounds. If so, use that. Otherwise, report an\n+    // error.\n+    let r = *derived_region_bounds.get(0);\n+    if derived_region_bounds.slice_from(1).iter().any(|r1| r != *r1) {\n+        tcx.sess.span_err(\n+            span,\n+            format!(\"ambiguous lifetime bound, \\\n+                     explicit lifetime bound required\").as_slice());\n+    }\n+    return Some(r);\n+}\n+\n+fn compute_region_bound<AC:AstConv, RS:RegionScope>(\n+    this: &AC,\n+    rscope: &RS,\n+    span: Span,\n+    builtin_bounds: ty::BuiltinBounds,\n+    region_bounds: &[&ast::Lifetime],\n+    trait_bounds: &[Rc<ty::TraitRef>])\n+    -> ty::Region\n+{\n+    /*!\n+     * A version of `compute_opt_region_bound` for use where some\n+     * region bound is required (existential types,\n+     * basically). Reports an error if no region bound can be derived\n+     * and we are in an `rscope` that does not provide a default.\n+     */\n+\n+    match compute_opt_region_bound(this.tcx(), span, builtin_bounds,\n+                                   region_bounds, trait_bounds) {\n+        Some(r) => r,\n+        None => {\n+            match rscope.default_region_bound(span) {\n+                Some(r) => { r }\n+                None => {\n+                    this.tcx().sess.span_err(\n+                        span,\n+                        format!(\"explicit lifetime bound required\").as_slice());\n+                    ty::ReStatic\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct PartitionedBounds<'a> {\n+    pub builtin_bounds: ty::BuiltinBounds,\n+    pub trait_bounds: Vec<&'a ast::TraitRef>,\n+    pub unboxed_fn_ty_bounds: Vec<&'a ast::UnboxedFnTy>,\n+    pub region_bounds: Vec<&'a ast::Lifetime>,\n+}\n+\n+pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n+                            _span: Span,\n+                            ast_bounds: &'a [&ast::TyParamBound])\n+                            -> PartitionedBounds<'a>\n+{\n+    /*!\n+     * Divides a list of bounds from the AST into three groups:\n+     * builtin bounds (Copy, Sized etc), general trait bounds,\n+     * and region bounds.\n+     */\n+\n+    let mut builtin_bounds = ty::empty_builtin_bounds();\n+    let mut region_bounds = Vec::new();\n+    let mut trait_bounds = Vec::new();\n+    let mut unboxed_fn_ty_bounds = Vec::new();\n+    let mut trait_def_ids = HashMap::new();\n+    for &ast_bound in ast_bounds.iter() {\n+        match *ast_bound {\n+            ast::TraitTyParamBound(ref b) => {\n+                match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n+                    def::DefTrait(trait_did) => {\n+                        match trait_def_ids.find(&trait_did) {\n+                            // Already seen this trait. We forbid\n+                            // duplicates in the list (for some\n+                            // reason).\n+                            Some(span) => {\n+                                span_err!(\n+                                    tcx.sess, b.path.span, E0127,\n+                                    \"trait `{}` already appears in the \\\n+                                     list of bounds\",\n+                                    b.path.user_string(tcx));\n+                                tcx.sess.span_note(\n+                                    *span,\n+                                    \"previous appearance is here\");\n+\n+                                continue;\n                             }\n-                            _ => { }\n+\n+                            None => { }\n                         }\n-                        tcx.sess.span_fatal(\n-                            b.path.span,\n-                            \"only the builtin traits can be used as closure \\\n-                             or object bounds\");\n-                    }\n-                    ast::StaticRegionTyParamBound => {\n-                        builtin_bounds.add(ty::BoundStatic);\n-                    }\n-                    ast::UnboxedFnTyParamBound(_) => {\n-                        tcx.sess.span_err(span,\n-                                          \"unboxed functions are not allowed \\\n-                                           here\");\n-                    }\n-                    ast::OtherRegionTyParamBound(span) => {\n-                        if !tcx.sess.features.issue_5723_bootstrap.get() {\n-                            tcx.sess.span_err(\n-                                span,\n-                                \"only the 'static lifetime is accepted \\\n-                                 here.\");\n+\n+                        trait_def_ids.insert(trait_did, b.path.span);\n+\n+                        if ty::try_add_builtin_trait(tcx,\n+                                                     trait_did,\n+                                                     &mut builtin_bounds) {\n+                            continue; // success\n                         }\n                     }\n+                    _ => {\n+                        // Not a trait? that's an error, but it'll get\n+                        // reported later.\n+                    }\n                 }\n+                trait_bounds.push(b);\n+            }\n+            ast::RegionTyParamBound(ref l) => {\n+                region_bounds.push(l);\n+            }\n+            ast::UnboxedFnTyParamBound(ref unboxed_function) => {\n+                unboxed_fn_ty_bounds.push(unboxed_function);\n             }\n-            builtin_bounds\n-        },\n-        // &'static Trait is sugar for &'static Trait:'static.\n-        &None if static_region => {\n-            let mut set = ty::empty_builtin_bounds(); set.add(ty::BoundStatic); set\n         }\n-        &None => ty::empty_builtin_bounds(),\n+    }\n+\n+    PartitionedBounds {\n+        builtin_bounds: builtin_bounds,\n+        trait_bounds: trait_bounds,\n+        region_bounds: region_bounds,\n+        unboxed_fn_ty_bounds: unboxed_fn_ty_bounds\n     }\n }\n "}, {"sha": "3c15135807b9fa2f1bb7edfe856d535af440c456", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 59, "deletions": 39, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -87,7 +87,6 @@ use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, PreferMutLvalue, impl_self_ty};\n use middle::typeck::check;\n-use middle::typeck::infer::MiscVariable;\n use middle::typeck::infer;\n use middle::typeck::MethodCallee;\n use middle::typeck::{MethodOrigin, MethodParam};\n@@ -240,6 +239,7 @@ fn construct_transformed_self_ty_for_object(\n     span: Span,\n     trait_def_id: ast::DefId,\n     rcvr_substs: &subst::Substs,\n+    rcvr_bounds: ty::ExistentialBounds,\n     method_ty: &ty::Method)\n     -> ty::t\n {\n@@ -276,8 +276,7 @@ fn construct_transformed_self_ty_for_object(\n             tcx.sess.span_bug(span, \"static method for object type receiver\");\n         }\n         ByValueExplicitSelfCategory => {\n-            let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n-                                  ty::empty_builtin_bounds());\n+            let tr = ty::mk_trait(tcx, trait_def_id, obj_substs, rcvr_bounds);\n             ty::mk_uniq(tcx, tr)\n         }\n         ByReferenceExplicitSelfCategory(..) | ByBoxExplicitSelfCategory => {\n@@ -286,12 +285,12 @@ fn construct_transformed_self_ty_for_object(\n                 ty::ty_rptr(r, mt) => { // must be SelfRegion\n                     let r = r.subst(tcx, rcvr_substs); // handle Early-Bound lifetime\n                     let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n-                                          ty::empty_builtin_bounds());\n+                                          rcvr_bounds);\n                     ty::mk_rptr(tcx, r, ty::mt{ ty: tr, mutbl: mt.mutbl })\n                 }\n                 ty::ty_uniq(_) => { // must be SelfUniq\n                     let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n-                                          ty::empty_builtin_bounds());\n+                                          rcvr_bounds);\n                     ty::mk_uniq(tcx, tr)\n                 }\n                 _ => {\n@@ -442,8 +441,9 @@ impl<'a> LookupContext<'a> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n             match get(self_ty).sty {\n-                ty_trait(box TyTrait { def_id, ref substs, .. }) => {\n-                    self.push_inherent_candidates_from_object(def_id, substs);\n+                ty_trait(box TyTrait { def_id, ref substs, bounds, .. }) => {\n+                    self.push_inherent_candidates_from_object(\n+                        def_id, substs, bounds);\n                     self.push_inherent_impl_candidates_for_type(def_id);\n                 }\n                 ty_enum(did, _) |\n@@ -538,15 +538,13 @@ impl<'a> LookupContext<'a> {\n         }\n \n         let vcx = self.fcx.vtable_context();\n-        let region_params =\n-            vec!(vcx.infcx.next_region_var(MiscVariable(self.span)));\n \n         // Get the tupled type of the arguments.\n         let arguments_type = *closure_function_type.sig.inputs.get(0);\n         let return_type = closure_function_type.sig.output;\n \n         let closure_region =\n-            vcx.infcx.next_region_var(MiscVariable(self.span));\n+            vcx.infcx.next_region_var(infer::MiscVariable(self.span));\n         let unboxed_closure_type = ty::mk_unboxed_closure(self.tcx(),\n                                                           closure_did,\n                                                           closure_region);\n@@ -555,7 +553,7 @@ impl<'a> LookupContext<'a> {\n                 RcvrMatchesIfSubtype(unboxed_closure_type),\n             rcvr_substs: subst::Substs::new_trait(\n                 vec![arguments_type, return_type],\n-                region_params,\n+                vec![],\n                 *vcx.infcx.next_ty_vars(1).get(0)),\n             method_ty: method,\n             origin: MethodStaticUnboxedClosure(closure_did),\n@@ -595,11 +593,11 @@ impl<'a> LookupContext<'a> {\n \n     fn push_inherent_candidates_from_object(&mut self,\n                                             did: DefId,\n-                                            substs: &subst::Substs) {\n+                                            substs: &subst::Substs,\n+                                            bounds: ty::ExistentialBounds) {\n         debug!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n                self.did_to_string(did),\n                substs.repr(self.tcx()));\n-        let _indenter = indenter();\n         let tcx = self.tcx();\n         let span = self.span;\n \n@@ -617,28 +615,30 @@ impl<'a> LookupContext<'a> {\n             substs: rcvr_substs.clone()\n         });\n \n-        self.push_inherent_candidates_from_bounds_inner(&[trait_ref.clone()],\n-            |new_trait_ref, m, method_num, _bound_num| {\n-            let vtable_index = get_method_index(tcx, &*new_trait_ref,\n-                                                trait_ref.clone(), method_num);\n-            let mut m = (*m).clone();\n-            // We need to fix up the transformed self type.\n-            *m.fty.sig.inputs.get_mut(0) =\n-                construct_transformed_self_ty_for_object(\n-                    tcx, span, did, &rcvr_substs, &m);\n-\n-            Some(Candidate {\n-                rcvr_match_condition: RcvrMatchesIfObject(did),\n-                rcvr_substs: new_trait_ref.substs.clone(),\n-                method_ty: Rc::new(m),\n-                origin: MethodObject(MethodObject {\n+        self.push_inherent_candidates_from_bounds_inner(\n+            &[trait_ref.clone()],\n+            |_this, new_trait_ref, m, method_num, _bound_num| {\n+                let vtable_index =\n+                    get_method_index(tcx, &*new_trait_ref,\n+                                     trait_ref.clone(), method_num);\n+                let mut m = (*m).clone();\n+                // We need to fix up the transformed self type.\n+                *m.fty.sig.inputs.get_mut(0) =\n+                    construct_transformed_self_ty_for_object(\n+                        tcx, span, did, &rcvr_substs, bounds, &m);\n+\n+                Some(Candidate {\n+                    rcvr_match_condition: RcvrMatchesIfObject(did),\n+                    rcvr_substs: new_trait_ref.substs.clone(),\n+                    method_ty: Rc::new(m),\n+                    origin: MethodObject(MethodObject {\n                         trait_id: new_trait_ref.def_id,\n                         object_trait_id: did,\n                         method_num: method_num,\n                         real_index: vtable_index\n                     })\n-            })\n-        });\n+                })\n+            });\n     }\n \n     fn push_inherent_candidates_from_param(&mut self,\n@@ -666,7 +666,7 @@ impl<'a> LookupContext<'a> {\n             self.fcx.inh.param_env.bounds.get(space, index).trait_bounds\n             .as_slice();\n         self.push_inherent_candidates_from_bounds_inner(bounds,\n-            |trait_ref, m, method_num, bound_num| {\n+            |this, trait_ref, m, method_num, bound_num| {\n                 match restrict_to {\n                     Some(trait_did) => {\n                         if trait_did != trait_ref.def_id {\n@@ -675,6 +675,18 @@ impl<'a> LookupContext<'a> {\n                     }\n                     _ => {}\n                 }\n+                debug!(\"found match: trait_ref={} substs={} m={}\",\n+                       trait_ref.repr(this.tcx()),\n+                       trait_ref.substs.repr(this.tcx()),\n+                       m.repr(this.tcx()));\n+                assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n+                           trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n+                assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n+                           trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n+                assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n+                           trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n+                assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n+                           trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n                 Some(Candidate {\n                     rcvr_match_condition: RcvrMatchesIfSubtype(self_ty),\n                     rcvr_substs: trait_ref.substs.clone(),\n@@ -691,13 +703,15 @@ impl<'a> LookupContext<'a> {\n \n     // Do a search through a list of bounds, using a callback to actually\n     // create the candidates.\n-    fn push_inherent_candidates_from_bounds_inner(&mut self,\n-                                                  bounds: &[Rc<TraitRef>],\n-                                                  mk_cand: |tr: Rc<TraitRef>,\n-                                                            m: Rc<ty::Method>,\n-                                                            method_num: uint,\n-                                                            bound_num: uint|\n-                                                            -> Option<Candidate>) {\n+    fn push_inherent_candidates_from_bounds_inner(\n+        &mut self,\n+        bounds: &[Rc<TraitRef>],\n+        mk_cand: |this: &mut LookupContext,\n+                  tr: Rc<TraitRef>,\n+                  m: Rc<ty::Method>,\n+                  method_num: uint,\n+                  bound_num: uint|\n+                  -> Option<Candidate>) {\n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n \n@@ -719,7 +733,8 @@ impl<'a> LookupContext<'a> {\n                         ty::MethodTraitItem(ref method) => (*method).clone(),\n                     };\n \n-                    match mk_cand(bound_trait_ref,\n+                    match mk_cand(self,\n+                                  bound_trait_ref,\n                                   method,\n                                   pos,\n                                   this_bound_idx) {\n@@ -1338,6 +1353,11 @@ impl<'a> LookupContext<'a> {\n             }\n         }\n \n+        self.fcx.add_region_obligations_for_parameters(\n+            self.span,\n+            &all_substs,\n+            &candidate.method_ty.generics);\n+\n         MethodCallee {\n             origin: candidate.origin,\n             ty: fty,"}, {"sha": "b9e96c785337a34e2c3fd4b3197e24ed76923edf", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 582, "deletions": 155, "changes": 737, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -102,7 +102,6 @@ use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::method::{DontAutoderefReceiver};\n use middle::typeck::check::method::{IgnoreStaticMethods, ReportStaticMethods};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n-use middle::typeck::check::regionmanip::relate_free_regions;\n use middle::typeck::check::vtable::VtableContext;\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n@@ -173,6 +172,43 @@ pub struct Inherited<'a> {\n     vtable_map: vtable_map,\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n     unboxed_closures: RefCell<DefIdMap<ty::UnboxedClosure>>,\n+\n+    // A mapping from each fn's id to its signature, with all bound\n+    // regions replaced with free ones. Unlike the other tables, this\n+    // one is never copied into the tcx: it is only used by regionck.\n+    fn_sig_map: RefCell<NodeMap<Vec<ty::t>>>,\n+\n+    // A set of constraints that regionck must validate. Each\n+    // constraint has the form `T:'a`, meaning \"some type `T` must\n+    // outlive the lifetime 'a\". These constraints derive from\n+    // instantiated type parameters. So if you had a struct defined\n+    // like\n+    //\n+    //     struct Foo<T:'static> { ... }\n+    //\n+    // then in some expression `let x = Foo { ... }` it will\n+    // instantiate the type parameter `T` with a fresh type `$0`. At\n+    // the same time, it will record a region obligation of\n+    // `$0:'static`. This will get checked later by regionck.  (We\n+    // can't generally check these things right away because we have\n+    // to wait until types are resolved.)\n+    //\n+    // These are stored in a map keyed to the id of the innermost\n+    // enclosing fn body / static initializer expression. This is\n+    // because the location where the obligation was incurred can be\n+    // relevant with respect to which sublifetime assumptions are in\n+    // place. The reason that we store under the fn-id, and not\n+    // something more fine-grained, is so that it is easier for\n+    // regionck to be sure that it has found *all* the region\n+    // obligations (otherwise, it's easy to fail to walk to a\n+    // particular node-id).\n+    region_obligations: RefCell<NodeMap<Vec<RegionObligation>>>,\n+}\n+\n+struct RegionObligation {\n+    sub_region: ty::Region,\n+    sup_type: ty::t,\n+    origin: infer::SubregionOrigin,\n }\n \n /// When type-checking an expression, we propagate downward\n@@ -232,6 +268,8 @@ enum IsBinopAssignment{\n \n #[deriving(Clone)]\n pub struct FnCtxt<'a> {\n+    body_id: ast::NodeId,\n+\n     // This flag is set to true if, during the writeback phase, we encounter\n     // a type error in this function.\n     writeback_errors: Cell<bool>,\n@@ -243,22 +281,8 @@ pub struct FnCtxt<'a> {\n     err_count_on_creation: uint,\n \n     ret_ty: ty::t,\n-    ps: RefCell<FnStyleState>,\n \n-    // Sometimes we generate region pointers where the precise region\n-    // to use is not known. For example, an expression like `&x.f`\n-    // where `x` is of type `@T`: in this case, we will be rooting\n-    // `x` onto the stack frame, and we could choose to root it until\n-    // the end of (almost) any enclosing block or expression.  We\n-    // want to pick the narrowest block that encompasses all uses.\n-    //\n-    // What we do in such cases is to generate a region variable with\n-    // `region_lb` as a lower bound.  The regionck pass then adds\n-    // other constraints based on how the variable is used and region\n-    // inference selects the ultimate value.  Finally, borrowck is\n-    // charged with guaranteeing that the value whose address was taken\n-    // can actually be made to live as long as it needs to live.\n-    region_lb: Cell<ast::NodeId>,\n+    ps: RefCell<FnStyleState>,\n \n     inh: &'a Inherited<'a>,\n \n@@ -313,6 +337,8 @@ impl<'a> Inherited<'a> {\n             vtable_map: RefCell::new(FnvHashMap::new()),\n             upvar_borrow_map: RefCell::new(HashMap::new()),\n             unboxed_closures: RefCell::new(DefIdMap::new()),\n+            fn_sig_map: RefCell::new(NodeMap::new()),\n+            region_obligations: RefCell::new(NodeMap::new()),\n         }\n     }\n }\n@@ -322,25 +348,26 @@ pub fn blank_fn_ctxt<'a>(\n                      ccx: &'a CrateCtxt<'a>,\n                      inh: &'a Inherited<'a>,\n                      rty: ty::t,\n-                     region_bnd: ast::NodeId)\n+                     body_id: ast::NodeId)\n                      -> FnCtxt<'a> {\n     FnCtxt {\n+        body_id: body_id,\n         writeback_errors: Cell::new(false),\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n         ps: RefCell::new(FnStyleState::function(ast::NormalFn, 0)),\n-        region_lb: Cell::new(region_bnd),\n         inh: inh,\n         ccx: ccx\n     }\n }\n \n-fn blank_inherited_fields<'a>(ccx: &'a CrateCtxt<'a>) -> Inherited<'a> {\n+fn static_inherited_fields<'a>(ccx: &'a CrateCtxt<'a>) -> Inherited<'a> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n     let param_env = ty::ParameterEnvironment {\n         free_substs: subst::Substs::empty(),\n-        bounds: subst::VecPerParamSpace::empty()\n+        bounds: subst::VecPerParamSpace::empty(),\n+        implicit_region_bound: ty::ReStatic,\n     };\n     Inherited::new(ccx.tcx, param_env)\n }\n@@ -355,6 +382,15 @@ impl<'a> ExprTyProvider for FnCtxt<'a> {\n     }\n }\n \n+struct CheckTypeWellFormedVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n+\n+impl<'a> Visitor<()> for CheckTypeWellFormedVisitor<'a> {\n+    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n+        check_type_well_formed(self.ccx, i);\n+        visit::walk_item(self, i, ());\n+    }\n+}\n+\n struct CheckItemTypesVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n \n impl<'a> Visitor<()> for CheckItemTypesVisitor<'a> {\n@@ -374,6 +410,13 @@ impl<'a> Visitor<()> for CheckItemSizedTypesVisitor<'a> {\n }\n \n pub fn check_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n+    let mut visit = CheckTypeWellFormedVisitor { ccx: ccx };\n+    visit::walk_crate(&mut visit, krate, ());\n+\n+    // If types are not well-formed, it leads to all manner of errors\n+    // downstream, so stop reporting errors at this point.\n+    ccx.tcx.sess.abort_if_errors();\n+\n     let mut visit = CheckItemTypesVisitor { ccx: ccx };\n     visit::walk_crate(&mut visit, krate, ());\n \n@@ -396,11 +439,11 @@ fn check_bare_fn(ccx: &CrateCtxt,\n     match ty::get(fty).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n-            let fcx = check_fn(ccx, fn_ty.fn_style, &fn_ty.sig,\n+            let fcx = check_fn(ccx, fn_ty.fn_style, id, &fn_ty.sig,\n                                decl, id, body, &inh);\n \n             vtable::resolve_in_block(&fcx, body);\n-            regionck::regionck_fn(&fcx, body);\n+            regionck::regionck_fn(&fcx, id, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n@@ -465,7 +508,7 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n         // non-obvious: the `blk` variable maps to region lb, so\n         // we have to keep this up-to-date.  This\n         // is... unfortunate.  It'd be nice to not need this.\n-        self.fcx.with_region_lb(b.id, || visit::walk_block(self, b, ()));\n+        visit::walk_block(self, b, ());\n     }\n \n     // Since an expr occurs as part of the type fixed size arrays we\n@@ -487,13 +530,16 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n \n }\n \n-fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n-                fn_style: ast::FnStyle,\n-                fn_sig: &ty::FnSig,\n-                decl: &ast::FnDecl,\n-                id: ast::NodeId,\n-                body: &ast::Block,\n-                inherited: &'a Inherited<'a>) -> FnCtxt<'a>\n+fn check_fn<'a>(\n+    ccx: &'a CrateCtxt<'a>,\n+    fn_style: ast::FnStyle,\n+    fn_style_id: ast::NodeId,\n+    fn_sig: &ty::FnSig,\n+    decl: &ast::FnDecl,\n+    fn_id: ast::NodeId,\n+    body: &ast::Block,\n+    inherited: &'a Inherited<'a>)\n+    -> FnCtxt<'a>\n {\n     /*!\n      * Helper used by check_bare_fn and check_expr_fn.  Does the\n@@ -514,30 +560,42 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n         ty::ReFree(ty::FreeRegion {scope_id: body.id, bound_region: br})\n     });\n \n-    relate_free_regions(tcx, &fn_sig);\n-\n     let arg_tys = fn_sig.inputs.as_slice();\n     let ret_ty = fn_sig.output;\n \n-    debug!(\"check_fn(arg_tys={}, ret_ty={})\",\n+    debug!(\"check_fn(arg_tys={}, ret_ty={}, fn_id={})\",\n            arg_tys.repr(tcx),\n-           ret_ty.repr(tcx));\n+           ret_ty.repr(tcx),\n+           fn_id);\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n     let fcx = FnCtxt {\n+        body_id: body.id,\n         writeback_errors: Cell::new(false),\n         err_count_on_creation: err_count_on_creation,\n         ret_ty: ret_ty,\n-        ps: RefCell::new(FnStyleState::function(fn_style, id)),\n-        region_lb: Cell::new(body.id),\n+        ps: RefCell::new(FnStyleState::function(fn_style, fn_style_id)),\n         inh: inherited,\n         ccx: ccx\n     };\n \n-    {\n+    // Remember return type so that regionck can access it later.\n+    let fn_sig_tys: Vec<ty::t> =\n+        arg_tys.iter()\n+        .chain([ret_ty].iter())\n+        .map(|&ty| ty)\n+        .collect();\n+    debug!(\"fn-sig-map: fn_id={} fn_sig_tys={}\",\n+           fn_id,\n+           fn_sig_tys.repr(tcx));\n+    inherited.fn_sig_map\n+        .borrow_mut()\n+        .insert(fn_id, fn_sig_tys);\n \n+    {\n         let mut visit = GatherLocalsVisitor { fcx: &fcx, };\n+\n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n@@ -662,6 +720,71 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n+fn check_type_well_formed(ccx: &CrateCtxt, item: &ast::Item) {\n+    /*!\n+     * Checks that the field types (in a struct def'n) or\n+     * argument types (in an enum def'n) are well-formed,\n+     * meaning that they do not require any constraints not\n+     * declared in the struct definition itself.\n+     * For example, this definition would be illegal:\n+     *\n+     *     struct Ref<'a, T> { x: &'a T }\n+     *\n+     * because the type did not declare that `T:'a`.\n+     *\n+     * We do this check as a pre-pass before checking fn bodies\n+     * because if these constraints are not included it frequently\n+     * leads to confusing errors in fn bodies. So it's better to check\n+     * the types first.\n+     */\n+\n+    debug!(\"check_type_well_formed(it.id={}, it.ident={})\",\n+           item.id,\n+           ty::item_path_str(ccx.tcx, local_def(item.id)));\n+\n+    match item.node {\n+        ast::ItemStruct(..) => {\n+            check_type_defn(ccx, item, |fcx| {\n+                ty::struct_fields(ccx.tcx, local_def(item.id),\n+                                  &fcx.inh.param_env.free_substs)\n+                    .iter()\n+                    .map(|f| f.mt.ty)\n+                    .collect()\n+            });\n+        }\n+        ast::ItemEnum(..) => {\n+            check_type_defn(ccx, item, |fcx| {\n+                ty::substd_enum_variants(ccx.tcx, local_def(item.id),\n+                                         &fcx.inh.param_env.free_substs)\n+                    .iter()\n+                    .flat_map(|variant| {\n+                        variant.args\n+                            .iter()\n+                            .map(|&arg_ty| arg_ty)\n+                    })\n+                    .collect()\n+            });\n+        }\n+        _ => {}\n+    }\n+\n+    fn check_type_defn(ccx: &CrateCtxt,\n+                       item: &ast::Item,\n+                       lookup_fields: |&FnCtxt| -> Vec<ty::t>)\n+    {\n+        let item_def_id = local_def(item.id);\n+        let polytype = ty::lookup_item_type(ccx.tcx, item_def_id);\n+        let param_env =\n+            ty::construct_parameter_environment(ccx.tcx,\n+                                                &polytype.generics,\n+                                                item.id);\n+        let inh = Inherited::new(ccx.tcx, param_env);\n+        let fcx = blank_fn_ctxt(ccx, &inh, polytype.ty, item.id);\n+        let field_tys = lookup_fields(&fcx);\n+        regionck::regionck_type_defn(&fcx, item.span, field_tys.as_slice());\n+    }\n+}\n+\n pub fn check_item_sized(ccx: &CrateCtxt, it: &ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n@@ -977,9 +1100,6 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         return;\n     }\n \n-    let it = trait_m.generics.types.get_slice(subst::FnSpace).iter()\n-        .zip(impl_m.generics.types.get_slice(subst::FnSpace).iter());\n-\n     // This code is best explained by example. Consider a trait:\n     //\n     //     trait Trait<T> {\n@@ -1041,20 +1161,27 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     let impl_to_skol_substs =\n         subst::Substs::new(skol_tps.clone(), skol_regions.clone());\n \n-    // Compute skolemized form of impl method ty.\n-    let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n-    let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n-\n-    // Compute skolemized form of trait method ty.\n+    // Create mapping from trait to skolemized.\n     let trait_to_skol_substs =\n         trait_to_impl_substs\n         .subst(tcx, &impl_to_skol_substs)\n         .with_method(Vec::from_slice(skol_tps.get_slice(subst::FnSpace)),\n                      Vec::from_slice(skol_regions.get_slice(subst::FnSpace)));\n-    let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n-    let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n+\n+    // Check region bounds.\n+    if !check_region_bounds_on_impl_method(tcx,\n+                                           impl_m_span,\n+                                           impl_m,\n+                                           &trait_m.generics,\n+                                           &impl_m.generics,\n+                                           &trait_to_skol_substs,\n+                                           &impl_to_skol_substs) {\n+        return;\n+    }\n \n     // Check bounds.\n+    let it = trait_m.generics.types.get_slice(subst::FnSpace).iter()\n+        .zip(impl_m.generics.types.get_slice(subst::FnSpace).iter());\n     for (i, (trait_param_def, impl_param_def)) in it.enumerate() {\n         // Check that the impl does not require any builtin-bounds\n         // that the trait does not guarantee:\n@@ -1110,6 +1237,12 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         }\n     }\n \n+    // Compute skolemized form of impl and trait method tys.\n+    let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n+    let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n+    let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n+    let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n+\n     // Check the impl method type IM is a subtype of the trait method\n     // type TM. To see why this makes sense, think of a vtable. The\n     // expected type of the function pointers in the vtable is the\n@@ -1134,6 +1267,152 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     // Finally, resolve all regions. This catches wily misuses of lifetime\n     // parameters.\n     infcx.resolve_regions_and_report_errors();\n+\n+    fn check_region_bounds_on_impl_method(tcx: &ty::ctxt,\n+                                          span: Span,\n+                                          impl_m: &ty::Method,\n+                                          trait_generics: &ty::Generics,\n+                                          impl_generics: &ty::Generics,\n+                                          trait_to_skol_substs: &Substs,\n+                                          impl_to_skol_substs: &Substs)\n+                                          -> bool\n+    {\n+        /*!\n+\n+        Check that region bounds on impl method are the same as those\n+        on the trait. In principle, it could be ok for there to be\n+        fewer region bounds on the impl method, but this leads to an\n+        annoying corner case that is painful to handle (described\n+        below), so for now we can just forbid it.\n+\n+        Example (see\n+        `src/test/compile-fail/regions-bound-missing-bound-in-impl.rs`):\n+\n+            trait Foo<'a> {\n+                fn method1<'b>();\n+                fn method2<'b:'a>();\n+            }\n+\n+            impl<'a> Foo<'a> for ... {\n+                fn method1<'b:'a>() { .. case 1, definitely bad .. }\n+                fn method2<'b>() { .. case 2, could be ok .. }\n+            }\n+\n+        The \"definitely bad\" case is case #1. Here, the impl adds an\n+        extra constraint not present in the trait.\n+\n+        The \"maybe bad\" case is case #2. Here, the impl adds an extra\n+        constraint not present in the trait. We could in principle\n+        allow this, but it interacts in a complex way with early/late\n+        bound resolution of lifetimes. Basically the presence or\n+        absence of a lifetime bound affects whether the lifetime is\n+        early/late bound, and right now the code breaks if the trait\n+        has an early bound lifetime parameter and the method does not.\n+\n+        */\n+\n+        let trait_params = trait_generics.regions.get_slice(subst::FnSpace);\n+        let impl_params = impl_generics.regions.get_slice(subst::FnSpace);\n+\n+        debug!(\"check_region_bounds_on_impl_method: \\\n+               trait_generics={} \\\n+               impl_generics={}\",\n+               trait_generics.repr(tcx),\n+               impl_generics.repr(tcx));\n+\n+        // Must have same number of early-bound lifetime parameters.\n+        // Unfortunately, if the user screws up the bounds, then this\n+        // will change classification between early and late.  E.g.,\n+        // if in trait we have `<'a,'b:'a>`, and in impl we just have\n+        // `<'a,'b>`, then we have 2 early-bound lifetime parameters\n+        // in trait but 0 in the impl. But if we report \"expected 2\n+        // but found 0\" it's confusing, because it looks like there\n+        // are zero. Since I don't quite know how to phrase things at\n+        // the moment, give a kind of vague error message.\n+        if trait_params.len() != impl_params.len() {\n+            tcx.sess.span_err(\n+                span,\n+                format!(\"lifetime parameters or bounds on method `{}` do \\\n+                         not match the trait declaration\",\n+                        token::get_ident(impl_m.ident)).as_slice());\n+            return false;\n+        }\n+\n+        // Each parameter `'a:'b+'c+'d` in trait should have the same\n+        // set of bounds in the impl, after subst.\n+        for (trait_param, impl_param) in\n+            trait_params.iter().zip(\n+                impl_params.iter())\n+        {\n+            let trait_bounds =\n+                trait_param.bounds.subst(tcx, trait_to_skol_substs);\n+            let impl_bounds =\n+                impl_param.bounds.subst(tcx, impl_to_skol_substs);\n+\n+            debug!(\"check_region_bounds_on_impl_method: \\\n+                   trait_param={} \\\n+                   impl_param={} \\\n+                   trait_bounds={} \\\n+                   impl_bounds={}\",\n+                   trait_param.repr(tcx),\n+                   impl_param.repr(tcx),\n+                   trait_bounds.repr(tcx),\n+                   impl_bounds.repr(tcx));\n+\n+            // Collect the set of bounds present in trait but not in\n+            // impl.\n+            let missing: Vec<ty::Region> =\n+                trait_bounds.iter()\n+                .filter(|&b| !impl_bounds.contains(b))\n+                .map(|&b| b)\n+                .collect();\n+\n+            // Collect set present in impl but not in trait.\n+            let extra: Vec<ty::Region> =\n+                impl_bounds.iter()\n+                .filter(|&b| !trait_bounds.contains(b))\n+                .map(|&b| b)\n+                .collect();\n+\n+            debug!(\"missing={} extra={}\",\n+                   missing.repr(tcx), extra.repr(tcx));\n+\n+            let err = if missing.len() != 0 || extra.len() != 0 {\n+                tcx.sess.span_err(\n+                    span,\n+                    format!(\n+                        \"the lifetime parameter `{}` declared in the impl \\\n+                         has a distinct set of bounds \\\n+                         from its counterpart `{}` \\\n+                         declared in the trait\",\n+                        impl_param.name.user_string(tcx),\n+                        trait_param.name.user_string(tcx)).as_slice());\n+                true\n+            } else {\n+                false\n+            };\n+\n+            if missing.len() != 0 {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"the impl is missing the following bounds: `{}`\",\n+                            missing.user_string(tcx)).as_slice());\n+            }\n+\n+            if extra.len() != 0 {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"the impl has the following extra bounds: `{}`\",\n+                            extra.user_string(tcx)).as_slice());\n+            }\n+\n+            if err {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n }\n \n fn check_cast(fcx: &FnCtxt,\n@@ -1163,6 +1442,7 @@ fn check_cast(fcx: &FnCtxt,\n         fcx.write_error(id);\n         return\n     }\n+\n     if ty::type_is_bot(t_e) {\n         fcx.write_bot(id);\n         return\n@@ -1301,6 +1581,8 @@ impl<'a> AstConv for FnCtxt<'a> {\n }\n \n impl<'a> FnCtxt<'a> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.ccx.tcx }\n+\n     pub fn infcx<'b>(&'b self) -> &'b infer::InferCtxt<'a> {\n         &self.inh.infcx\n     }\n@@ -1319,6 +1601,10 @@ impl<'a> FnCtxt<'a> {\n }\n \n impl<'a> RegionScope for infer::InferCtxt<'a> {\n+    fn default_region_bound(&self, span: Span) -> Option<ty::Region> {\n+        Some(self.next_region_var(infer::MiscVariable(span)))\n+    }\n+\n     fn anon_regions(&self, span: Span, count: uint)\n                     -> Result<Vec<ty::Region> , ()> {\n         Ok(Vec::from_fn(count, |_| {\n@@ -1494,19 +1780,10 @@ impl<'a> FnCtxt<'a> {\n     }\n \n     pub fn mk_subr(&self,\n-                   a_is_expected: bool,\n                    origin: infer::SubregionOrigin,\n                    sub: ty::Region,\n                    sup: ty::Region) {\n-        infer::mk_subr(self.infcx(), a_is_expected, origin, sub, sup)\n-    }\n-\n-    pub fn with_region_lb<R>(&self, lb: ast::NodeId, f: || -> R) -> R {\n-        let old_region_lb = self.region_lb.get();\n-        self.region_lb.set(lb);\n-        let v = f();\n-        self.region_lb.set(old_region_lb);\n-        v\n+        infer::mk_subr(self.infcx(), origin, sub, sup)\n     }\n \n     pub fn type_error_message(&self,\n@@ -1536,6 +1813,112 @@ impl<'a> FnCtxt<'a> {\n                                    err: &ty::type_err) {\n         self.infcx().report_mismatched_types(sp, e, a, err)\n     }\n+\n+    pub fn register_region_obligation(&self,\n+                                      origin: infer::SubregionOrigin,\n+                                      ty: ty::t,\n+                                      r: ty::Region)\n+    {\n+        /*!\n+         * Registers an obligation for checking later, during\n+         * regionck, that the type `ty` must outlive the region `r`.\n+         */\n+\n+        let mut region_obligations = self.inh.region_obligations.borrow_mut();\n+        let v = region_obligations.find_or_insert_with(self.body_id,\n+                                                       |_| Vec::new());\n+        v.push(RegionObligation { sub_region: r,\n+                                  sup_type: ty,\n+                                  origin: origin });\n+    }\n+\n+    pub fn add_region_obligations_for_parameters(&self,\n+                                                 span: Span,\n+                                                 substs: &Substs,\n+                                                 generics: &ty::Generics)\n+    {\n+        /*!\n+         * Given a set of generic parameter definitions (`generics`)\n+         * and the values provided for each of them (`substs`),\n+         * creates and registers suitable region obligations.\n+         *\n+         * For example, if there is a function:\n+         *\n+         *    fn foo<'a,T:'a>(...)\n+         *\n+         * and a reference:\n+         *\n+         *    let f = foo;\n+         *\n+         * Then we will create a fresh region variable `'$0` and a\n+         * fresh type variable `$1` for `'a` and `T`. This routine\n+         * will add a region obligation `$1:'$0` and register it\n+         * locally.\n+         */\n+\n+        debug!(\"add_region_obligations_for_parameters(substs={}, generics={})\",\n+               substs.repr(self.tcx()),\n+               generics.repr(self.tcx()));\n+\n+        assert_eq!(generics.types.iter().len(),\n+                   substs.types.iter().len());\n+        for (type_def, &type_param) in\n+            generics.types.iter().zip(\n+                substs.types.iter())\n+        {\n+            let param_ty = ty::ParamTy { space: type_def.space,\n+                                         idx: type_def.index,\n+                                         def_id: type_def.def_id };\n+            let bounds = type_def.bounds.subst(self.tcx(), substs);\n+            add_region_obligations_for_type_parameter(\n+                self, span, param_ty, &bounds, type_param);\n+        }\n+\n+        assert_eq!(generics.regions.iter().len(),\n+                   substs.regions().iter().len());\n+        for (region_def, &region_param) in\n+            generics.regions.iter().zip(\n+                substs.regions().iter())\n+        {\n+            let bounds = region_def.bounds.subst(self.tcx(), substs);\n+            add_region_obligations_for_region_parameter(\n+                self, span, bounds.as_slice(), region_param);\n+        }\n+\n+        fn add_region_obligations_for_type_parameter(\n+            fcx: &FnCtxt,\n+            span: Span,\n+            param_ty: ty::ParamTy,\n+            param_bound: &ty::ParamBounds,\n+            ty: ty::t)\n+        {\n+            // For each declared region bound `T:r`, `T` must outlive `r`.\n+            let region_bounds =\n+                ty::required_region_bounds(\n+                    fcx.tcx(),\n+                    param_bound.opt_region_bound.as_slice(),\n+                    param_bound.builtin_bounds,\n+                    param_bound.trait_bounds.as_slice());\n+            for &r in region_bounds.iter() {\n+                let origin = infer::RelateParamBound(span, param_ty, ty);\n+                fcx.register_region_obligation(origin, ty, r);\n+            }\n+        }\n+\n+        fn add_region_obligations_for_region_parameter(\n+            fcx: &FnCtxt,\n+            span: Span,\n+            region_bounds: &[ty::Region],\n+            region_param: ty::Region)\n+        {\n+            for &b in region_bounds.iter() {\n+                // For each bound `region:b`, `b <= region` must hold\n+                // (i.e., `region` must outlive `b`).\n+                let origin = infer::RelateRegionParamBound(span);\n+                fcx.mk_subr(origin, b, region_param);\n+            }\n+        }\n+    }\n }\n \n pub enum LvaluePreference {\n@@ -2269,7 +2652,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                            lvalue_pref: LvaluePreference,\n                            unifier: ||)\n {\n-    debug!(\">> typechecking\");\n+    debug!(\">> typechecking: expr={} expected={}\",\n+           expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: &FnCtxt,\n@@ -2674,17 +3058,19 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                              kind: ast::UnboxedClosureKind,\n                              decl: &ast::FnDecl,\n                              body: ast::P<ast::Block>) {\n-        // The `RegionTraitStore` is a lie, but we ignore it so it doesn't\n-        // matter.\n-        //\n-        // FIXME(pcwalton): Refactor this API.\n         let mut fn_ty = astconv::ty_of_closure(\n             fcx,\n             expr.id,\n             ast::NormalFn,\n             ast::Many,\n-            ty::empty_builtin_bounds(),\n+\n+            // The `RegionTraitStore` and region_existential_bounds\n+            // are lies, but we ignore them so it doesn't matter.\n+            //\n+            // FIXME(pcwalton): Refactor this API.\n+            ty::region_existential_bound(ty::ReStatic),\n             ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n+\n             decl,\n             abi::RustCall,\n             None);\n@@ -2703,6 +3089,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         check_fn(fcx.ccx,\n                  ast::NormalFn,\n+                 expr.id,\n                  &fn_ty.sig,\n                  decl,\n                  expr.id,\n@@ -2776,13 +3163,17 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 }\n                 _ => {\n                     // Not an error! Means we're inferring the closure type\n-                    let mut bounds = ty::empty_builtin_bounds();\n-                    let onceness = match expr.node {\n+                    let (bounds, onceness) = match expr.node {\n                         ast::ExprProc(..) => {\n-                            bounds.add(ty::BoundSend);\n-                            ast::Once\n+                            let mut bounds = ty::region_existential_bound(ty::ReStatic);\n+                            bounds.builtin_bounds.add(ty::BoundSend); // FIXME\n+                            (bounds, ast::Once)\n+                        }\n+                        _ => {\n+                            let region = fcx.infcx().next_region_var(\n+                                infer::AddrOfRegion(expr.span));\n+                            (ty::region_existential_bound(region), ast::Many)\n                         }\n-                        _ => ast::Many\n                     };\n                     (None, onceness, bounds)\n                 }\n@@ -2808,17 +3199,18 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // If the closure is a stack closure and hasn't had some non-standard\n         // style inferred for it, then check it under its parent's style.\n         // Otherwise, use its own\n-        let (inherited_style, id) = match store {\n+        let (inherited_style, inherited_style_id) = match store {\n             ty::RegionTraitStore(..) => (fcx.ps.borrow().fn_style,\n                                          fcx.ps.borrow().def),\n             ty::UniqTraitStore => (ast::NormalFn, expr.id)\n         };\n \n         check_fn(fcx.ccx,\n                  inherited_style,\n+                 inherited_style_id,\n                  &fty_sig,\n-                 decl,\n-                 id,\n+                 &*decl,\n+                 expr.id,\n                  &*body,\n                  fcx.inh);\n     }\n@@ -3080,13 +3472,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                   // places: the exchange heap and the managed heap.\n                   let definition = lookup_def(fcx, path.span, place.id);\n                   let def_id = definition.def_id();\n+                  let referent_ty = fcx.expr_ty(&**subexpr);\n                   if tcx.lang_items.exchange_heap() == Some(def_id) {\n-                      fcx.write_ty(id, ty::mk_uniq(tcx,\n-                                                   fcx.expr_ty(&**subexpr)));\n+                      fcx.write_ty(id, ty::mk_uniq(tcx, referent_ty));\n                       checked = true\n                   } else if tcx.lang_items.managed_heap() == Some(def_id) {\n-                      fcx.write_ty(id, ty::mk_box(tcx,\n-                                                  fcx.expr_ty(&**subexpr)));\n+                      fcx.register_region_obligation(infer::Managed(expr.span),\n+                                                     referent_ty,\n+                                                     ty::ReStatic);\n+                      fcx.write_ty(id, ty::mk_box(tcx, referent_ty));\n                       checked = true\n                   }\n               }\n@@ -3270,7 +3664,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 //ast::ExprLit(lit) if ast_util::lit_is_str(lit) => fcx.expr_ty(oprnd),\n                 // Empty slices live in static memory.\n                 ast::ExprVec(ref elements) if elements.len() == 0 => {\n-                    ty::mk_rptr(tcx, ty::ReStatic, tm)\n+                    // Note: we do not assign a lifetime of\n+                    // static. This is because the resulting type\n+                    // `&'static [T]` would require that T outlives\n+                    // `'static`!\n+                    let region = fcx.infcx().next_region_var(\n+                        infer::AddrOfSlice(expr.span));\n+                    ty::mk_rptr(tcx, region, tm)\n                 }\n                 _ => {\n                     let region = fcx.infcx().next_region_var(infer::AddrOfRegion(expr.span));\n@@ -3281,9 +3681,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_ty(id, oprnd_t);\n       }\n       ast::ExprPath(ref pth) => {\n-        let defn = lookup_def(fcx, pth.span, id);\n-        let pty = polytype_for_def(fcx, expr.span, defn);\n-        instantiate_path(fcx, pth, pty, defn, expr.span, expr.id);\n+          let defn = lookup_def(fcx, pth.span, id);\n+          let pty = polytype_for_def(fcx, expr.span, defn);\n+          instantiate_path(fcx, pth, pty, defn, expr.span, expr.id);\n+\n+          // We always require that the type provided as the value for\n+          // a type parameter outlives the moment of instantiation.\n+          constrain_path_type_parameters(fcx, expr);\n       }\n       ast::ExprInlineAsm(ref ia) => {\n           for &(_, ref input) in ia.inputs.iter() {\n@@ -3708,6 +4112,18 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     unifier();\n }\n \n+fn constrain_path_type_parameters(fcx: &FnCtxt,\n+                                  expr: &ast::Expr)\n+{\n+    fcx.opt_node_ty_substs(expr.id, |item_substs| {\n+        for &ty in item_substs.substs.types.iter() {\n+            let default_bound = ty::ReScope(expr.id);\n+            let origin = infer::RelateDefaultParamBound(expr.span, ty);\n+            fcx.register_region_obligation(origin, ty, default_bound);\n+        }\n+    });\n+}\n+\n impl Expectation {\n     fn only_has_type(self) -> Expectation {\n         match self {\n@@ -3889,80 +4305,78 @@ fn check_block_with_expected(fcx: &FnCtxt,\n         replace(&mut *fcx_ps, fn_style_state)\n     };\n \n-    fcx.with_region_lb(blk.id, || {\n-        let mut warned = false;\n-        let mut last_was_bot = false;\n-        let mut any_bot = false;\n-        let mut any_err = false;\n-        for s in blk.stmts.iter() {\n-            check_stmt(fcx, &**s);\n-            let s_id = ast_util::stmt_id(&**s);\n-            let s_ty = fcx.node_ty(s_id);\n-            if last_was_bot && !warned && match s.node {\n-                  ast::StmtDecl(decl, _) => {\n-                      match decl.node {\n-                          ast::DeclLocal(_) => true,\n-                          _ => false,\n-                      }\n-                  }\n-                  ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => true,\n-                  _ => false\n-                } {\n-                fcx.ccx\n-                   .tcx\n-                   .sess\n-                   .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                             s_id,\n-                             s.span,\n-                             \"unreachable statement\".to_string());\n-                warned = true;\n-            }\n-            if ty::type_is_bot(s_ty) {\n-                last_was_bot = true;\n+    let mut warned = false;\n+    let mut last_was_bot = false;\n+    let mut any_bot = false;\n+    let mut any_err = false;\n+    for s in blk.stmts.iter() {\n+        check_stmt(fcx, &**s);\n+        let s_id = ast_util::stmt_id(&**s);\n+        let s_ty = fcx.node_ty(s_id);\n+        if last_was_bot && !warned && match s.node {\n+            ast::StmtDecl(decl, _) => {\n+                match decl.node {\n+                    ast::DeclLocal(_) => true,\n+                    _ => false,\n+                }\n             }\n-            any_bot = any_bot || ty::type_is_bot(s_ty);\n-            any_err = any_err || ty::type_is_error(s_ty);\n+            ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => true,\n+            _ => false\n+        } {\n+            fcx.ccx\n+                .tcx\n+                .sess\n+                .add_lint(lint::builtin::UNREACHABLE_CODE,\n+                          s_id,\n+                          s.span,\n+                          \"unreachable statement\".to_string());\n+            warned = true;\n         }\n-        match blk.expr {\n-            None => if any_err {\n-                    fcx.write_error(blk.id);\n-                }\n-                else if any_bot {\n-                    fcx.write_bot(blk.id);\n+        if ty::type_is_bot(s_ty) {\n+            last_was_bot = true;\n+        }\n+        any_bot = any_bot || ty::type_is_bot(s_ty);\n+        any_err = any_err || ty::type_is_error(s_ty);\n+    }\n+    match blk.expr {\n+        None => if any_err {\n+            fcx.write_error(blk.id);\n+        }\n+        else if any_bot {\n+            fcx.write_bot(blk.id);\n+        }\n+        else  {\n+            fcx.write_nil(blk.id);\n+        },\n+        Some(e) => {\n+            if any_bot && !warned {\n+                fcx.ccx\n+                    .tcx\n+                    .sess\n+                    .add_lint(lint::builtin::UNREACHABLE_CODE,\n+                              e.id,\n+                              e.span,\n+                              \"unreachable expression\".to_string());\n+            }\n+            let ety = match expected {\n+                ExpectHasType(ety) => {\n+                    check_expr_coercable_to_type(fcx, &*e, ety);\n+                    ety\n                 }\n-                else  {\n-                    fcx.write_nil(blk.id);\n-                },\n-            Some(e) => {\n-                if any_bot && !warned {\n-                    fcx.ccx\n-                       .tcx\n-                       .sess\n-                       .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                                 e.id,\n-                                 e.span,\n-                                 \"unreachable expression\".to_string());\n+                _ => {\n+                    check_expr_with_expectation(fcx, &*e, expected);\n+                    fcx.expr_ty(&*e)\n                 }\n-                let ety = match expected {\n-                    ExpectHasType(ety) => {\n-                        check_expr_coercable_to_type(fcx, &*e, ety);\n-                        ety\n-                    }\n-                    _ => {\n-                        check_expr_with_expectation(fcx, &*e, expected);\n-                        fcx.expr_ty(&*e)\n-                    }\n-                };\n+            };\n \n-                fcx.write_ty(blk.id, ety);\n-                if any_err {\n-                    fcx.write_error(blk.id);\n-                } else if any_bot {\n-                    fcx.write_bot(blk.id);\n-                }\n+            fcx.write_ty(blk.id, ety);\n+            if any_err {\n+                fcx.write_error(blk.id);\n+            } else if any_bot {\n+                fcx.write_bot(blk.id);\n             }\n-        };\n-    });\n+        }\n+    };\n \n     *fcx.ps.borrow_mut() = prev;\n }\n@@ -3980,7 +4394,7 @@ pub fn check_const_in_type(tcx: &ty::ctxt,\n         trait_map: NodeMap::new(),\n         tcx: tcx,\n     };\n-    let inh = blank_inherited_fields(&ccx);\n+    let inh = static_inherited_fields(&ccx);\n     let fcx = blank_fn_ctxt(&ccx, &inh, expected_type, expr.id);\n     check_const_with_ty(&fcx, expr.span, expr, expected_type);\n }\n@@ -3989,7 +4403,7 @@ pub fn check_const(ccx: &CrateCtxt,\n                    sp: Span,\n                    e: &ast::Expr,\n                    id: ast::NodeId) {\n-    let inh = blank_inherited_fields(ccx);\n+    let inh = static_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n     let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).ty;\n@@ -4184,7 +4598,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                 Some(e) => {\n                     debug!(\"disr expr, checking {}\", pprust::expr_to_string(&*e));\n \n-                    let inh = blank_inherited_fields(ccx);\n+                    let inh = static_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n                     let declty = match hint {\n                         attr::ReprAny | attr::ReprPacked | attr::ReprExtern => ty::mk_int(),\n@@ -4495,6 +4909,9 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         assert_eq!(substs.regions().len(space), region_defs.len(space));\n     }\n \n+    fcx.add_region_obligations_for_parameters(\n+        span, &substs, &polytype.generics);\n+\n     fcx.write_ty_substs(node_id, polytype.ty, ty::ItemSubsts {\n         substs: substs,\n     });\n@@ -4888,11 +5305,13 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                   Ok(t) => t,\n                   Err(s) => { tcx.sess.span_fatal(it.span, s.as_slice()); }\n               };\n-              let region = ty::ReLateBound(it.id, ty::BrAnon(0));\n-              let visitor_object_ty = match ty::visitor_object_ty(tcx, region) {\n-                  Ok((_, vot)) => vot,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, s.as_slice()); }\n-              };\n+              let region0 = ty::ReLateBound(it.id, ty::BrAnon(0));\n+              let region1 = ty::ReLateBound(it.id, ty::BrAnon(1));\n+              let visitor_object_ty =\n+                    match ty::visitor_object_ty(tcx, region0, region1) {\n+                        Ok((_, vot)) => vot,\n+                        Err(s) => { tcx.sess.span_fatal(it.span, s.as_slice()); }\n+                    };\n \n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,\n@@ -5097,3 +5516,11 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     }\n }\n \n+impl Repr for RegionObligation {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"RegionObligation(sub_region={}, sup_type={}, origin={})\",\n+                self.sub_region.repr(tcx),\n+                self.sup_type.repr(tcx),\n+                self.origin.repr(tcx))\n+    }\n+}"}, {"sha": "72f33a2f9848c707ac52207795e9569d41b1f4fb", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 485, "deletions": 210, "changes": 695, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -126,14 +126,14 @@ use middle::ty::{ReScope};\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::FnCtxt;\n-use middle::typeck::check::regionmanip::relate_nested_regions;\n+use middle::typeck::check::regionmanip;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::MethodCall;\n use middle::pat_util;\n use util::nodemap::{DefIdMap, NodeMap};\n-use util::ppaux::{ty_to_string, region_to_string, Repr};\n+use util::ppaux::{ty_to_string, Repr};\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -143,6 +143,46 @@ use syntax::visit::Visitor;\n use std::cell::RefCell;\n use std::gc::Gc;\n \n+///////////////////////////////////////////////////////////////////////////\n+// PUBLIC ENTRY POINTS\n+\n+pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n+    let mut rcx = Rcx::new(fcx, e.id);\n+    if fcx.err_count_since_creation() == 0 {\n+        // regionck assumes typeck succeeded\n+        rcx.visit_expr(e, ());\n+        rcx.visit_region_obligations(e.id);\n+    }\n+    fcx.infcx().resolve_regions_and_report_errors();\n+}\n+\n+pub fn regionck_type_defn(fcx: &FnCtxt,\n+                          span: Span,\n+                          component_tys: &[ty::t]) {\n+    let mut rcx = Rcx::new(fcx, 0);\n+    for &component_ty in component_tys.iter() {\n+        // Check that each type outlives the empty region. Since the\n+        // empty region is a subregion of all others, this can't fail\n+        // unless the type does not meet the well-formedness\n+        // requirements.\n+        type_must_outlive(&mut rcx, infer::RelateRegionParamBound(span),\n+                          component_ty, ty::ReEmpty);\n+    }\n+    fcx.infcx().resolve_regions_and_report_errors();\n+}\n+\n+pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, blk: &ast::Block) {\n+    let mut rcx = Rcx::new(fcx, blk.id);\n+    if fcx.err_count_since_creation() == 0 {\n+        // regionck assumes typeck succeeded\n+        rcx.visit_fn_body(id, blk);\n+    }\n+    fcx.infcx().resolve_regions_and_report_errors();\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// INTERNALS\n+\n // If mem categorization results in an error, it's because the type\n // check failed (or will fail, when the error is uncovered and\n // reported during writeback). In this case, we just ignore this part\n@@ -159,10 +199,32 @@ macro_rules! ignore_err(\n pub struct Rcx<'a> {\n     fcx: &'a FnCtxt<'a>,\n \n+    region_param_pairs: Vec<(ty::Region, ty::ParamTy)>,\n+\n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n }\n \n+/// When entering a function, we can derive relationships from the\n+/// signature between various regions and type parameters. Consider\n+/// a function like:\n+///\n+///     fn foo<'a, A>(x: &'a A) { ... }\n+///\n+/// Here, we can derive that `A` must outlive `'a`, because otherwise\n+/// the caller would be illegal. We record this by storing a series of\n+/// pairs (in this case, `('a, A)`). These pairs will be consulted\n+/// later during regionck.\n+///\n+/// In the case of nested fns, additional relationships may be\n+/// derived.  The result is a link list walking up the stack (hence\n+/// the `previous` field).\n+#[deriving(Clone)]\n+pub struct RegionSubParamConstraints<'a> {\n+    pairs: Vec<(ty::Region, ty::ParamTy)>,\n+    previous: Option<&'a RegionSubParamConstraints<'a>>,\n+}\n+\n fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n     /*!\n      * Returns the validity region of `def` -- that is, how long\n@@ -189,6 +251,13 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n }\n \n impl<'a> Rcx<'a> {\n+    pub fn new(fcx: &'a FnCtxt<'a>,\n+               initial_repeating_scope: ast::NodeId) -> Rcx<'a> {\n+        Rcx { fcx: fcx,\n+              repeating_scope: initial_repeating_scope,\n+              region_param_pairs: Vec::new() }\n+    }\n+\n     pub fn tcx(&self) -> &'a ty::ctxt {\n         self.fcx.ccx.tcx\n     }\n@@ -259,6 +328,114 @@ impl<'a> Rcx<'a> {\n                           |method_call| self.resolve_method_type(method_call))\n         }\n     }\n+\n+    fn visit_fn_body(&mut self,\n+                     id: ast::NodeId,\n+                     body: &ast::Block)\n+    {\n+        // When we enter a function, we can derive\n+\n+        let fn_sig_map = self.fcx.inh.fn_sig_map.borrow();\n+        let fn_sig = match fn_sig_map.find(&id) {\n+            Some(f) => f,\n+            None => {\n+                self.tcx().sess.bug(\n+                    format!(\"No fn-sig entry for id={}\", id).as_slice());\n+            }\n+        };\n+\n+        let len = self.region_param_pairs.len();\n+        self.relate_free_regions(fn_sig.as_slice(), body.id);\n+        self.visit_block(body, ());\n+        self.visit_region_obligations(body.id);\n+        self.region_param_pairs.truncate(len);\n+    }\n+\n+    fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n+    {\n+        debug!(\"visit_region_obligations: node_id={}\", node_id);\n+        let region_obligations = self.fcx.inh.region_obligations.borrow();\n+        match region_obligations.find(&node_id) {\n+            None => { }\n+            Some(vec) => {\n+                for r_o in vec.iter() {\n+                    debug!(\"visit_region_obligations: r_o={}\",\n+                           r_o.repr(self.tcx()));\n+                    let sup_type = self.resolve_type(r_o.sup_type);\n+                    type_must_outlive(self, r_o.origin.clone(),\n+                                      sup_type, r_o.sub_region);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn relate_free_regions(&mut self,\n+                           fn_sig_tys: &[ty::t],\n+                           body_id: ast::NodeId) {\n+        /*!\n+         * This method populates the region map's `free_region_map`.\n+         * It walks over the transformed argument and return types for\n+         * each function just before we check the body of that\n+         * function, looking for types where you have a borrowed\n+         * pointer to other borrowed data (e.g., `&'a &'b [uint]`.  We\n+         * do not allow references to outlive the things they point\n+         * at, so we can assume that `'a <= 'b`. This holds for both\n+         * the argument and return types, basically because, on the caller\n+         * side, the caller is responsible for checking that the type of\n+         * every expression (including the actual values for the arguments,\n+         * as well as the return type of the fn call) is well-formed.\n+         *\n+         * Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n+         */\n+\n+        debug!(\"relate_free_regions >>\");\n+        let tcx = self.tcx();\n+\n+        for &ty in fn_sig_tys.iter() {\n+            let ty = self.resolve_type(ty);\n+            debug!(\"relate_free_regions(t={})\", ty.repr(tcx));\n+            let body_scope = ty::ReScope(body_id);\n+            let constraints =\n+                regionmanip::region_wf_constraints(\n+                    tcx,\n+                    ty,\n+                    body_scope);\n+            for constraint in constraints.iter() {\n+                debug!(\"constraint: {}\", constraint.repr(tcx));\n+                match *constraint {\n+                    regionmanip::RegionSubRegionConstraint(_,\n+                                              ty::ReFree(free_a),\n+                                              ty::ReFree(free_b)) => {\n+                        tcx.region_maps.relate_free_regions(free_a, free_b);\n+                    }\n+                    regionmanip::RegionSubRegionConstraint(_,\n+                                              ty::ReFree(free_a),\n+                                              ty::ReInfer(ty::ReVar(vid_b))) => {\n+                        self.fcx.inh.infcx.add_given(free_a, vid_b);\n+                    }\n+                    regionmanip::RegionSubRegionConstraint(..) => {\n+                        // In principle, we could record (and take\n+                        // advantage of) every relationship here, but\n+                        // we are also free not to -- it simply means\n+                        // strictly less that we can successfully type\n+                        // check. (It may also be that we should\n+                        // revise our inference system to be more\n+                        // general and to make use of *every*\n+                        // relationship that arises here, but\n+                        // presently we do not.)\n+                    }\n+                    regionmanip::RegionSubParamConstraint(_, r_a, p_b) => {\n+                        debug!(\"RegionSubParamConstraint: {} <= {}\",\n+                               r_a.repr(tcx), p_b.repr(tcx));\n+\n+                        self.region_param_pairs.push((r_a, p_b));\n+                    }\n+                }\n+            }\n+        }\n+\n+        debug!(\"<< relate_free_regions\");\n+    }\n }\n \n impl<'fcx> mc::Typer for Rcx<'fcx> {\n@@ -302,26 +479,6 @@ impl<'fcx> mc::Typer for Rcx<'fcx> {\n     }\n }\n \n-pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n-    let mut rcx = Rcx { fcx: fcx, repeating_scope: e.id };\n-    let rcx = &mut rcx;\n-    if fcx.err_count_since_creation() == 0 {\n-        // regionck assumes typeck succeeded\n-        rcx.visit_expr(e, ());\n-    }\n-    fcx.infcx().resolve_regions_and_report_errors();\n-}\n-\n-pub fn regionck_fn(fcx: &FnCtxt, blk: &ast::Block) {\n-    let mut rcx = Rcx { fcx: fcx, repeating_scope: blk.id };\n-    let rcx = &mut rcx;\n-    if fcx.err_count_since_creation() == 0 {\n-        // regionck assumes typeck succeeded\n-        rcx.visit_block(blk, ());\n-    }\n-    fcx.infcx().resolve_regions_and_report_errors();\n-}\n-\n impl<'a> Visitor<()> for Rcx<'a> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n@@ -331,6 +488,11 @@ impl<'a> Visitor<()> for Rcx<'a> {\n     // hierarchy, and in particular the relationships between free\n     // regions, until regionck, as described in #3238.\n \n+    fn visit_fn(&mut self, _fk: &visit::FnKind, _fd: &ast::FnDecl,\n+                b: &ast::Block, _s: Span, id: ast::NodeId, _e: ()) {\n+        self.visit_fn_body(id, b)\n+    }\n+\n     fn visit_item(&mut self, i: &ast::Item, _: ()) { visit_item(self, i); }\n \n     fn visit_expr(&mut self, ex: &ast::Expr, _: ()) { visit_expr(self, ex); }\n@@ -396,16 +558,23 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n         // variable's type enclose at least the variable's scope.\n \n         let var_region = tcx.region_maps.var_region(id);\n-        constrain_regions_in_type_of_node(\n-            rcx, id, var_region,\n-            infer::BindingTypeIsNotValidAtDecl(span));\n+        type_of_node_must_outlive(\n+            rcx, infer::BindingTypeIsNotValidAtDecl(span),\n+            id, var_region);\n     })\n }\n \n fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     debug!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n+    // No matter what, the type of each expression must outlive the\n+    // scope of that expression. This also guarantees basic WF.\n+    let expr_ty = rcx.resolve_node_type(expr.id);\n+\n+    type_must_outlive(rcx, infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n+                      expr_ty, ty::ReScope(expr.id));\n+\n     let method_call = MethodCall::expr(expr.id);\n     let has_method_map = rcx.fcx.inh.method_map.borrow().contains_key(&method_call);\n \n@@ -416,53 +585,40 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n-                match ty::adjusted_object_region(adjustment) {\n-                    Some(trait_region) => {\n-                        // Determine if we are casting `expr` to a trait\n-                        // instance.  If so, we have to be sure that the type of\n-                        // the source obeys the trait's region bound.\n-                        //\n-                        // Note: there is a subtle point here concerning type\n-                        // parameters.  It is possible that the type of `source`\n-                        // contains type parameters, which in turn may contain\n-                        // regions that are not visible to us (only the caller\n-                        // knows about them).  The kind checker is ultimately\n-                        // responsible for guaranteeing region safety in that\n-                        // particular case.  There is an extensive comment on the\n-                        // function check_cast_for_escaping_regions() in kind.rs\n-                        // explaining how it goes about doing that.\n-\n-                        constrain_regions_in_type(rcx, trait_region,\n-                                                  infer::RelateObjectBound(expr.span), expr_ty);\n-                    }\n-                    None => {\n-                        for autoref in opt_autoref.iter() {\n-                            link_autoref(rcx, expr, autoderefs, autoref);\n-\n-                            // Require that the resulting region encompasses\n-                            // the current node.\n-                            //\n-                            // FIXME(#6268) remove to support nested method calls\n-                            constrain_regions_in_type_of_node(\n-                                rcx, expr.id, ty::ReScope(expr.id),\n-                                infer::AutoBorrow(expr.span));\n-                        }\n-                    }\n+                for autoref in opt_autoref.iter() {\n+                    link_autoref(rcx, expr, autoderefs, autoref);\n+\n+                    // Require that the resulting region encompasses\n+                    // the current node.\n+                    //\n+                    // FIXME(#6268) remove to support nested method calls\n+                    type_of_node_must_outlive(\n+                        rcx, infer::AutoBorrow(expr.span),\n+                        expr.id, ty::ReScope(expr.id));\n                 }\n             }\n+            /*\n+            ty::AutoObject(_, ref bounds, _, _) => {\n+                // Determine if we are casting `expr` to a trait\n+                // instance. If so, we have to be sure that the type\n+                // of the source obeys the new region bound.\n+                let source_ty = rcx.resolve_node_type(expr.id);\n+                type_must_outlive(rcx, infer::RelateObjectBound(expr.span),\n+                                  source_ty, bounds.region_bound);\n+            }\n+            */\n             _ => {}\n         }\n     }\n \n     match expr.node {\n         ast::ExprCall(ref callee, ref args) => {\n             if has_method_map {\n-                constrain_call(rcx, None, expr, Some(*callee),\n+                constrain_call(rcx, expr, Some(*callee),\n                                args.as_slice(), false);\n             } else {\n                 constrain_callee(rcx, callee.id, expr, &**callee);\n                 constrain_call(rcx,\n-                               Some(callee.id),\n                                expr,\n                                None,\n                                args.as_slice(),\n@@ -473,7 +629,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMethodCall(_, _, ref args) => {\n-            constrain_call(rcx, None, expr, Some(*args.get(0)),\n+            constrain_call(rcx, expr, Some(*args.get(0)),\n                            args.slice_from(1), false);\n \n             visit::walk_expr(rcx, expr, ());\n@@ -486,7 +642,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n         ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n-                constrain_call(rcx, None, expr, Some(lhs.clone()),\n+                constrain_call(rcx, expr, Some(lhs.clone()),\n                                [rhs.clone()], true);\n             }\n \n@@ -501,16 +657,24 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n-            constrain_call(rcx, None, expr, Some(lhs.clone()),\n+            constrain_call(rcx, expr, Some(lhs.clone()),\n                            [rhs.clone()], true);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprUnary(_, ref lhs) if has_method_map => {\n             // As above.\n-            constrain_call(rcx, None, expr, Some(lhs.clone()), [], true);\n+            constrain_call(rcx, expr, Some(lhs.clone()), [], true);\n+\n+            visit::walk_expr(rcx, expr, ());\n+        }\n \n+        ast::ExprUnary(ast::UnBox, ref base) => {\n+            // Managed data must not have borrowed pointers within it:\n+            let base_ty = rcx.resolve_node_type(base.id);\n+            type_must_outlive(rcx, infer::Managed(expr.span),\n+                              base_ty, ty::ReStatic);\n             visit::walk_expr(rcx, expr, ());\n         }\n \n@@ -519,7 +683,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             let method_call = MethodCall::expr(expr.id);\n             let base_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n                 Some(method) => {\n-                    constrain_call(rcx, None, expr, Some(base.clone()), [], true);\n+                    constrain_call(rcx, expr, Some(base.clone()), [], true);\n                     ty::ty_fn_ret(method.ty)\n                 }\n                 None => rcx.resolve_node_type(base.id)\n@@ -547,34 +711,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             // Determine if we are casting `source` to a trait\n             // instance.  If so, we have to be sure that the type of\n             // the source obeys the trait's region bound.\n-            //\n-            // Note: there is a subtle point here concerning type\n-            // parameters.  It is possible that the type of `source`\n-            // contains type parameters, which in turn may contain\n-            // regions that are not visible to us (only the caller\n-            // knows about them).  The kind checker is ultimately\n-            // responsible for guaranteeing region safety in that\n-            // particular case.  There is an extensive comment on the\n-            // function check_cast_for_escaping_regions() in kind.rs\n-            // explaining how it goes about doing that.\n-            let target_ty = rcx.resolve_node_type(expr.id);\n-            match ty::get(target_ty).sty {\n-                ty::ty_rptr(trait_region, ty::mt{ty, ..}) => {\n-                    match ty::get(ty).sty {\n-                        ty::ty_trait(..) => {\n-                            let source_ty = rcx.resolve_expr_type_adjusted(&**source);\n-                            constrain_regions_in_type(\n-                                rcx,\n-                                trait_region,\n-                                infer::RelateObjectBound(expr.span),\n-                                source_ty);\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                _ => ()\n-            }\n-\n+            constrain_cast(rcx, expr, &**source);\n             visit::walk_expr(rcx, expr, ());\n         }\n \n@@ -589,8 +726,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             //\n             // FIXME(#6268) nested method calls requires that this rule change\n             let ty0 = rcx.resolve_node_type(expr.id);\n-            constrain_regions_in_type(rcx, ty::ReScope(expr.id),\n-                                      infer::AddrOf(expr.span), ty0);\n+            type_must_outlive(rcx, infer::AddrOf(expr.span),\n+                              ty0, ty::ReScope(expr.id));\n             visit::walk_expr(rcx, expr, ());\n         }\n \n@@ -644,42 +781,108 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     }\n }\n \n+fn constrain_cast(rcx: &mut Rcx,\n+                  cast_expr: &ast::Expr,\n+                  source_expr: &ast::Expr)\n+{\n+    debug!(\"constrain_cast(cast_expr={}, source_expr={})\",\n+           cast_expr.repr(rcx.tcx()),\n+           source_expr.repr(rcx.tcx()));\n+\n+    let source_ty = rcx.resolve_node_type(source_expr.id);\n+    let target_ty = rcx.resolve_node_type(cast_expr.id);\n+\n+    walk_cast(rcx, cast_expr, source_ty, target_ty);\n+\n+    fn walk_cast(rcx: &mut Rcx,\n+                 cast_expr: &ast::Expr,\n+                 from_ty: ty::t,\n+                 to_ty: ty::t) {\n+        debug!(\"walk_cast(from_ty={}, to_ty={})\",\n+               from_ty.repr(rcx.tcx()),\n+               to_ty.repr(rcx.tcx()));\n+        match (&ty::get(from_ty).sty, &ty::get(to_ty).sty) {\n+            /*From:*/ (&ty::ty_rptr(from_r, ref from_mt),\n+            /*To:  */  &ty::ty_rptr(to_r, ref to_mt)) => {\n+                // Target cannot outlive source, naturally.\n+                rcx.fcx.mk_subr(infer::Reborrow(cast_expr.span), to_r, from_r);\n+                walk_cast(rcx, cast_expr, from_mt.ty, to_mt.ty);\n+            }\n+\n+            /*From:*/ (_,\n+            /*To:  */  &ty::ty_trait(box ty::TyTrait { bounds, .. })) => {\n+                // When T is existentially quantified as a trait\n+                // `Foo+'to`, it must outlive the region bound `'to`.\n+                type_must_outlive(rcx, infer::RelateObjectBound(cast_expr.span),\n+                                  from_ty, bounds.region_bound);\n+            }\n+\n+            /*From:*/ (&ty::ty_uniq(from_referent_ty),\n+            /*To:  */  &ty::ty_uniq(to_referent_ty)) => {\n+                walk_cast(rcx, cast_expr, from_referent_ty, to_referent_ty);\n+            }\n+\n+            _ => { }\n+        }\n+    }\n+}\n+\n fn check_expr_fn_block(rcx: &mut Rcx,\n                        expr: &ast::Expr,\n                        body: &ast::Block) {\n     let tcx = rcx.fcx.tcx();\n     let function_type = rcx.resolve_node_type(expr.id);\n+\n     match ty::get(function_type).sty {\n-        ty::ty_closure(box ty::ClosureTy {\n-                store: ty::RegionTraitStore(region, _), ..}) => {\n+        ty::ty_closure(box ty::ClosureTy{store: ty::RegionTraitStore(..),\n+                                         bounds: ref bounds,\n+                                         ..}) => {\n+            // For closure, ensure that the variables outlive region\n+            // bound, since they are captured by reference.\n             freevars::with_freevars(tcx, expr.id, |freevars| {\n                 if freevars.is_empty() {\n                     // No free variables means that the environment\n                     // will be NULL at runtime and hence the closure\n                     // has static lifetime.\n                 } else {\n-                    // Closure must not outlive the variables it closes over.\n-                    constrain_free_variables(rcx, region, expr, freevars);\n+                    // Variables being referenced must outlive closure.\n+                    constrain_free_variables_in_stack_closure(\n+                        rcx, bounds.region_bound, expr, freevars);\n \n-                    // Closure cannot outlive the appropriate temporary scope.\n+                    // Closure is stack allocated and hence cannot\n+                    // outlive the appropriate temporary scope.\n                     let s = rcx.repeating_scope;\n-                    rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n-                                    region, ty::ReScope(s));\n+                    rcx.fcx.mk_subr(infer::InfStackClosure(expr.span),\n+                                    bounds.region_bound, ty::ReScope(s));\n                 }\n             });\n         }\n+        ty::ty_closure(box ty::ClosureTy{store: ty::UniqTraitStore,\n+                                         bounds: ref bounds,\n+                                         ..}) => {\n+            // For proc, ensure that the *types* of the variables\n+            // outlive region bound, since they are captured by value.\n+            freevars::with_freevars(tcx, expr.id, |freevars| {\n+                ensure_free_variable_types_outlive_closure_bound(\n+                    rcx, bounds.region_bound, expr, freevars);\n+            });\n+        }\n         ty::ty_unboxed_closure(_, region) => {\n             freevars::with_freevars(tcx, expr.id, |freevars| {\n                 // No free variables means that there is no environment and\n                 // hence the closure has static lifetime. Otherwise, the\n                 // closure must not outlive the variables it closes over\n                 // by-reference.\n+                //\n+                // NDM -- this seems wrong, discuss with pcwalton, should\n+                // be straightforward enough.\n                 if !freevars.is_empty() {\n-                    constrain_free_variables(rcx, region, expr, freevars);\n+                    ensure_free_variable_types_outlive_closure_bound(\n+                        rcx, region, expr, freevars);\n                 }\n             })\n         }\n-        _ => ()\n+        _ => { }\n     }\n \n     let repeating_scope = rcx.set_repeating_scope(body.id);\n@@ -698,36 +901,74 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         _ => ()\n     }\n \n-    fn constrain_free_variables(rcx: &mut Rcx,\n-                                region: ty::Region,\n-                                expr: &ast::Expr,\n-                                freevars: &[freevars::freevar_entry]) {\n+    fn ensure_free_variable_types_outlive_closure_bound(\n+        rcx: &mut Rcx,\n+        region_bound: ty::Region,\n+        expr: &ast::Expr,\n+        freevars: &[freevars::freevar_entry])\n+    {\n         /*!\n-         * Make sure that all free variables referenced inside the closure\n-         * outlive the closure itself. Also, create an entry in the\n-         * upvar_borrows map with a region.\n+         * Make sure that the type of all free variables referenced\n+         * inside a closure/proc outlive the closure/proc's lifetime\n+         * bound. This is just a special case of the usual rules about\n+         * closed over values outliving the object's lifetime bound.\n+         */\n+\n+        let tcx = rcx.fcx.ccx.tcx;\n+\n+        debug!(\"ensure_free_variable_types_outlive_closure_bound({}, {})\",\n+               region_bound.repr(tcx), expr.repr(tcx));\n+\n+        for freevar in freevars.iter() {\n+            let var_node_id = {\n+                let def_id = freevar.def.def_id();\n+                assert!(def_id.krate == ast::LOCAL_CRATE);\n+                def_id.node\n+            };\n+\n+            let var_ty = rcx.resolve_node_type(var_node_id);\n+\n+            type_must_outlive(\n+                rcx, infer::RelateProcBound(expr.span, var_node_id, var_ty),\n+                var_ty, region_bound);\n+        }\n+    }\n+\n+    fn constrain_free_variables_in_stack_closure(\n+        rcx: &mut Rcx,\n+        region_bound: ty::Region,\n+        expr: &ast::Expr,\n+        freevars: &[freevars::freevar_entry])\n+    {\n+        /*!\n+         * Make sure that all free variables referenced inside the\n+         * closure outlive the closure's lifetime bound. Also, create\n+         * an entry in the upvar_borrows map with a region.\n          */\n \n         let tcx = rcx.fcx.ccx.tcx;\n         let infcx = rcx.fcx.infcx();\n         debug!(\"constrain_free_variables({}, {})\",\n-               region.repr(tcx), expr.repr(tcx));\n+               region_bound.repr(tcx), expr.repr(tcx));\n         for freevar in freevars.iter() {\n             debug!(\"freevar def is {:?}\", freevar.def);\n \n             // Identify the variable being closed over and its node-id.\n             let def = freevar.def;\n-            let def_id = def.def_id();\n-            assert!(def_id.krate == ast::LOCAL_CRATE);\n-            let upvar_id = ty::UpvarId { var_id: def_id.node,\n+            let var_node_id = {\n+                let def_id = def.def_id();\n+                assert!(def_id.krate == ast::LOCAL_CRATE);\n+                def_id.node\n+            };\n+            let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                          closure_expr_id: expr.id };\n \n             // Create a region variable to represent this borrow. This borrow\n             // must outlive the region on the closure.\n             let origin = infer::UpvarRegion(upvar_id, expr.span);\n             let freevar_region = infcx.next_region_var(origin);\n-            rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span, def_id.node),\n-                            region, freevar_region);\n+            rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n+                            region_bound, freevar_region);\n \n             // Create a UpvarBorrow entry. Note that we begin with a\n             // const borrow_kind, but change it to either mut or\n@@ -738,10 +979,10 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                                                              upvar_borrow);\n \n             // Guarantee that the closure does not outlive the variable itself.\n-            let en_region = region_of_def(rcx.fcx, def);\n-            debug!(\"en_region = {}\", en_region.repr(tcx));\n-            rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span, def_id.node),\n-                            region, en_region);\n+            let enclosing_region = region_of_def(rcx.fcx, def);\n+            debug!(\"enclosing_region = {}\", enclosing_region.repr(tcx));\n+            rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n+                            region_bound, enclosing_region);\n         }\n     }\n \n@@ -817,7 +1058,7 @@ fn constrain_callee(rcx: &mut Rcx,\n                 }\n                 ty::UniqTraitStore => ty::ReStatic\n             };\n-            rcx.fcx.mk_subr(true, infer::InvokeClosure(callee_expr.span),\n+            rcx.fcx.mk_subr(infer::InvokeClosure(callee_expr.span),\n                             call_region, region);\n         }\n         _ => {\n@@ -832,9 +1073,6 @@ fn constrain_callee(rcx: &mut Rcx,\n }\n \n fn constrain_call(rcx: &mut Rcx,\n-                  // might be expr_call, expr_method_call, or an overloaded\n-                  // operator\n-                  fn_expr_id: Option<ast::NodeId>,\n                   call_expr: &ast::Expr,\n                   receiver: Option<Gc<ast::Expr>>,\n                   arg_exprs: &[Gc<ast::Expr>],\n@@ -853,16 +1091,6 @@ fn constrain_call(rcx: &mut Rcx,\n             receiver.repr(tcx),\n             arg_exprs.repr(tcx),\n             implicitly_ref_args);\n-    let callee_ty = match fn_expr_id {\n-        Some(id) => rcx.resolve_node_type(id),\n-        None => rcx.resolve_method_type(MethodCall::expr(call_expr.id))\n-                   .expect(\"call should have been to a method\")\n-    };\n-    if ty::type_is_error(callee_ty) {\n-        // Bail, as function type is unknown\n-        return;\n-    }\n-    let fn_sig = ty::ty_fn_sig(callee_ty);\n \n     // `callee_region` is the scope representing the time in which the\n     // call occurs.\n@@ -871,14 +1099,16 @@ fn constrain_call(rcx: &mut Rcx,\n     let callee_scope = call_expr.id;\n     let callee_region = ty::ReScope(callee_scope);\n \n+    debug!(\"callee_region={}\", callee_region.repr(tcx));\n+\n     for arg_expr in arg_exprs.iter() {\n-        debug!(\"Argument\");\n+        debug!(\"Argument: {}\", arg_expr.repr(tcx));\n \n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n-        constrain_regions_in_type_of_node(\n-            rcx, arg_expr.id, callee_region,\n-            infer::CallArg(arg_expr.span));\n+        type_of_node_must_outlive(\n+            rcx, infer::CallArg(arg_expr.span),\n+            arg_expr.id, callee_region);\n \n         // unfortunately, there are two means of taking implicit\n         // references, and we need to propagate constraints as a\n@@ -891,19 +1121,14 @@ fn constrain_call(rcx: &mut Rcx,\n \n     // as loop above, but for receiver\n     for r in receiver.iter() {\n-        debug!(\"Receiver\");\n-        constrain_regions_in_type_of_node(\n-            rcx, r.id, callee_region, infer::CallRcvr(r.span));\n+        debug!(\"receiver: {}\", r.repr(tcx));\n+        type_of_node_must_outlive(\n+            rcx, infer::CallRcvr(r.span),\n+            r.id, callee_region);\n         if implicitly_ref_args {\n             link_by_ref(rcx, &**r, callee_scope);\n         }\n     }\n-\n-    // constrain regions that may appear in the return type to be\n-    // valid for the function call:\n-    constrain_regions_in_type(\n-        rcx, callee_region, infer::CallReturn(call_expr.span),\n-        fn_sig.output);\n }\n \n fn constrain_autoderefs(rcx: &mut Rcx,\n@@ -942,12 +1167,10 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                 }\n \n                 // Specialized version of constrain_call.\n-                constrain_regions_in_type(rcx, r_deref_expr,\n-                                          infer::CallRcvr(deref_expr.span),\n-                                          self_ty);\n-                constrain_regions_in_type(rcx, r_deref_expr,\n-                                          infer::CallReturn(deref_expr.span),\n-                                          fn_sig.output);\n+                type_must_outlive(rcx, infer::CallRcvr(deref_expr.span),\n+                                  self_ty, r_deref_expr);\n+                type_must_outlive(rcx, infer::CallReturn(deref_expr.span),\n+                                  fn_sig.output, r_deref_expr);\n                 fn_sig.output\n             }\n             None => derefd_ty\n@@ -974,7 +1197,7 @@ pub fn mk_subregion_due_to_dereference(rcx: &mut Rcx,\n                                        deref_span: Span,\n                                        minimum_lifetime: ty::Region,\n                                        maximum_lifetime: ty::Region) {\n-    rcx.fcx.mk_subr(true, infer::DerefPointer(deref_span),\n+    rcx.fcx.mk_subr(infer::DerefPointer(deref_span),\n                     minimum_lifetime, maximum_lifetime)\n }\n \n@@ -996,7 +1219,7 @@ fn constrain_index(rcx: &mut Rcx,\n     match ty::get(indexed_ty).sty {\n         ty::ty_rptr(r_ptr, mt) => match ty::get(mt.ty).sty {\n             ty::ty_vec(_, None) | ty::ty_str => {\n-                rcx.fcx.mk_subr(true, infer::IndexSlice(index_expr.span),\n+                rcx.fcx.mk_subr(infer::IndexSlice(index_expr.span),\n                                 r_index_expr, r_ptr);\n             }\n             _ => {}\n@@ -1006,14 +1229,17 @@ fn constrain_index(rcx: &mut Rcx,\n     }\n }\n \n-fn constrain_regions_in_type_of_node(\n+fn type_of_node_must_outlive(\n     rcx: &mut Rcx,\n+    origin: infer::SubregionOrigin,\n     id: ast::NodeId,\n-    minimum_lifetime: ty::Region,\n-    origin: infer::SubregionOrigin) {\n-    //! Guarantees that any lifetimes which appear in the type of\n-    //! the node `id` (after applying adjustments) are valid for at\n-    //! least `minimum_lifetime`\n+    minimum_lifetime: ty::Region)\n+{\n+    /*!\n+     * Guarantees that any lifetimes which appear in the type of\n+     * the node `id` (after applying adjustments) are valid for at\n+     * least `minimum_lifetime`\n+     */\n \n     let tcx = rcx.fcx.tcx();\n \n@@ -1028,54 +1254,7 @@ fn constrain_regions_in_type_of_node(\n             ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n            ty_to_string(tcx, ty), ty_to_string(tcx, ty0),\n            id, minimum_lifetime);\n-    constrain_regions_in_type(rcx, minimum_lifetime, origin, ty);\n-}\n-\n-fn constrain_regions_in_type(\n-    rcx: &mut Rcx,\n-    minimum_lifetime: ty::Region,\n-    origin: infer::SubregionOrigin,\n-    ty: ty::t) {\n-    /*!\n-     * Requires that any regions which appear in `ty` must be\n-     * superregions of `minimum_lifetime`.  Also enforces the constraint\n-     * that given a pointer type `&'r T`, T must not contain regions\n-     * that outlive 'r, as well as analogous constraints for other\n-     * lifetime'd types.\n-     *\n-     * This check prevents regions from being used outside of the block in\n-     * which they are valid.  Recall that regions represent blocks of\n-     * code or expressions: this requirement basically says \"any place\n-     * that uses or may use a region R must be within the block of\n-     * code that R corresponds to.\"\n-     */\n-\n-    let tcx = rcx.fcx.ccx.tcx;\n-\n-    debug!(\"constrain_regions_in_type(minimum_lifetime={}, ty={})\",\n-           region_to_string(tcx, \"\", false, minimum_lifetime),\n-           ty_to_string(tcx, ty));\n-\n-    relate_nested_regions(tcx, Some(minimum_lifetime), ty, |r_sub, r_sup| {\n-        debug!(\"relate_nested_regions(r_sub={}, r_sup={})\",\n-                r_sub.repr(tcx),\n-                r_sup.repr(tcx));\n-\n-        if r_sup.is_bound() || r_sub.is_bound() {\n-            // a bound region is one which appears inside an fn type.\n-            // (e.g., the `&` in `fn(&T)`).  Such regions need not be\n-            // constrained by `minimum_lifetime` as they are placeholders\n-            // for regions that are as-yet-unknown.\n-        } else if r_sub == minimum_lifetime {\n-            rcx.fcx.mk_subr(\n-                true, origin.clone(),\n-                r_sub, r_sup);\n-        } else {\n-            rcx.fcx.mk_subr(\n-                true, infer::ReferenceOutlivesReferent(ty, origin.span()),\n-                r_sub, r_sup);\n-        }\n-    });\n+    type_must_outlive(rcx, origin, ty, minimum_lifetime);\n }\n \n fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n@@ -1290,7 +1469,7 @@ fn link_region(rcx: &Rcx,\n                 debug!(\"link_region: {} <= {}\",\n                        region_min.repr(rcx.tcx()),\n                        r_borrowed.repr(rcx.tcx()));\n-                rcx.fcx.mk_subr(true, cause, region_min, r_borrowed);\n+                rcx.fcx.mk_subr(cause, region_min, r_borrowed);\n \n                 if kind != ty::ImmBorrow {\n                     // If this is a mutable borrow, then the thing\n@@ -1522,3 +1701,99 @@ fn adjust_upvar_borrow_kind(upvar_id: ty::UpvarId,\n         }\n     }\n }\n+\n+fn type_must_outlive(rcx: &mut Rcx,\n+                     origin: infer::SubregionOrigin,\n+                     ty: ty::t,\n+                     region: ty::Region)\n+{\n+    /*!\n+     * Ensures that all borrowed data reachable via `ty` outlives `region`.\n+     */\n+\n+    debug!(\"type_must_outlive(ty={}, region={})\",\n+           ty.repr(rcx.tcx()),\n+           region.repr(rcx.tcx()));\n+\n+    let constraints =\n+        regionmanip::region_wf_constraints(\n+            rcx.tcx(),\n+            ty,\n+            region);\n+    for constraint in constraints.iter() {\n+        debug!(\"constraint: {}\", constraint.repr(rcx.tcx()));\n+        match *constraint {\n+            regionmanip::RegionSubRegionConstraint(None, r_a, r_b) => {\n+                rcx.fcx.mk_subr(origin.clone(), r_a, r_b);\n+            }\n+            regionmanip::RegionSubRegionConstraint(Some(ty), r_a, r_b) => {\n+                let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n+                rcx.fcx.mk_subr(o1, r_a, r_b);\n+            }\n+            regionmanip::RegionSubParamConstraint(None, r_a, param_b) => {\n+                param_must_outlive(rcx, origin.clone(), r_a, param_b);\n+            }\n+            regionmanip::RegionSubParamConstraint(Some(ty), r_a, param_b) => {\n+                let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n+                param_must_outlive(rcx, o1, r_a, param_b);\n+            }\n+        }\n+    }\n+}\n+\n+fn param_must_outlive(rcx: &Rcx,\n+                      origin: infer::SubregionOrigin,\n+                      region: ty::Region,\n+                      param_ty: ty::ParamTy) {\n+    let param_env = &rcx.fcx.inh.param_env;\n+\n+    debug!(\"param_must_outlive(region={}, param_ty={})\",\n+           region.repr(rcx.tcx()),\n+           param_ty.repr(rcx.tcx()));\n+\n+    // Collect all regions that `param_ty` is known to outlive into\n+    // this vector:\n+    let mut param_bounds;\n+\n+    // To start, collect bounds from user:\n+    let param_bound = param_env.bounds.get(param_ty.space, param_ty.idx);\n+    param_bounds =\n+        ty::required_region_bounds(rcx.tcx(),\n+                                   param_bound.opt_region_bound.as_slice(),\n+                                   param_bound.builtin_bounds,\n+                                   param_bound.trait_bounds.as_slice());\n+\n+    // Collect default bound of fn body that applies to all in scope\n+    // type parameters:\n+    param_bounds.push(param_env.implicit_region_bound);\n+\n+    // Finally, collect regions we scraped from the well-formedness\n+    // constraints in the fn signature. To do that, we walk the list\n+    // of known relations from the fn ctxt.\n+    //\n+    // This is crucial because otherwise code like this fails:\n+    //\n+    //     fn foo<'a, A>(x: &'a A) { x.bar() }\n+    //\n+    // The problem is that the type of `x` is `&'a A`. To be\n+    // well-formed, then, A must be lower-bounded by `'a`, but we\n+    // don't know that this holds from first principles.\n+    for &(ref r, ref p) in rcx.region_param_pairs.iter() {\n+        debug!(\"param_ty={}/{} p={}/{}\",\n+               param_ty.repr(rcx.tcx()),\n+               param_ty.def_id,\n+               p.repr(rcx.tcx()),\n+               p.def_id);\n+        if param_ty == *p {\n+            param_bounds.push(*r);\n+        }\n+    }\n+\n+    // Inform region inference that this parameter type must be\n+    // properly bounded.\n+    infer::verify_param_bound(rcx.fcx.infcx(),\n+                              origin,\n+                              param_ty,\n+                              region,\n+                              param_bounds);\n+}"}, {"sha": "577da159162fc6d909ac39bafec2085d058bf864", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 337, "deletions": 97, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -10,13 +10,15 @@\n \n // #![warn(deprecated_mode)]\n \n+use middle::subst::{ParamSpace, Subst, Substs};\n use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n \n+use syntax::ast;\n+\n use std::collections::HashMap;\n use util::ppaux::Repr;\n-use util::ppaux;\n \n // Helper functions related to manipulating region types.\n \n@@ -44,125 +46,363 @@ pub fn replace_late_bound_regions_in_fn_sig(\n     (map, fn_sig)\n }\n \n-pub fn relate_nested_regions(tcx: &ty::ctxt,\n-                             opt_region: Option<ty::Region>,\n-                             ty: ty::t,\n-                             relate_op: |ty::Region, ty::Region|) {\n+pub enum WfConstraint {\n+    RegionSubRegionConstraint(Option<ty::t>, ty::Region, ty::Region),\n+    RegionSubParamConstraint(Option<ty::t>, ty::Region, ty::ParamTy),\n+}\n+\n+struct Wf<'a> {\n+    tcx: &'a ty::ctxt,\n+    stack: Vec<(ty::Region, Option<ty::t>)>,\n+    out: Vec<WfConstraint>,\n+}\n+\n+pub fn region_wf_constraints(\n+    tcx: &ty::ctxt,\n+    ty: ty::t,\n+    outer_region: ty::Region)\n+    -> Vec<WfConstraint>\n+{\n     /*!\n-     * This rather specialized function walks each region `r` that appear\n-     * in `ty` and invokes `relate_op(r_encl, r)` for each one.  `r_encl`\n-     * here is the region of any enclosing `&'r T` pointer.  If there is\n-     * no enclosing pointer, and `opt_region` is Some, then `opt_region.get()`\n-     * is used instead.  Otherwise, no callback occurs at all).\n-     *\n-     * Here are some examples to give you an intution:\n-     *\n-     * - `relate_nested_regions(Some('r1), &'r2 uint)` invokes\n-     *   - `relate_op('r1, 'r2)`\n-     * - `relate_nested_regions(Some('r1), &'r2 &'r3 uint)` invokes\n-     *   - `relate_op('r1, 'r2)`\n-     *   - `relate_op('r2, 'r3)`\n-     * - `relate_nested_regions(None, &'r2 &'r3 uint)` invokes\n-     *   - `relate_op('r2, 'r3)`\n-     * - `relate_nested_regions(None, &'r2 &'r3 &'r4 uint)` invokes\n-     *   - `relate_op('r2, 'r3)`\n-     *   - `relate_op('r2, 'r4)`\n-     *   - `relate_op('r3, 'r4)`\n-     *\n-     * This function is used in various pieces of code because we enforce the\n-     * constraint that a region pointer cannot outlive the things it points at.\n-     * Hence, in the second example above, `'r2` must be a subregion of `'r3`.\n+     * This routine computes the well-formedness constraints that must\n+     * hold for the type `ty` to appear in a context with lifetime\n+     * `outer_region`\n      */\n \n-    let mut rr = RegionRelator { tcx: tcx,\n-                                 stack: Vec::new(),\n-                                 relate_op: relate_op };\n-    match opt_region {\n-        Some(o_r) => { rr.stack.push(o_r); }\n-        None => {}\n-    }\n-    rr.fold_ty(ty);\n+    let mut stack = Vec::new();\n+    stack.push((outer_region, None));\n+    let mut wf = Wf { tcx: tcx,\n+                      stack: stack,\n+                      out: Vec::new() };\n+    wf.accumulate_from_ty(ty);\n+    wf.out\n+}\n \n-    struct RegionRelator<'a> {\n-        tcx: &'a ty::ctxt,\n-        stack: Vec<ty::Region>,\n-        relate_op: |ty::Region, ty::Region|: 'a,\n-    }\n+impl<'a> Wf<'a> {\n+    fn accumulate_from_ty(&mut self, ty: ty::t) {\n+        debug!(\"Wf::accumulate_from_ty(ty={})\",\n+               ty.repr(self.tcx));\n \n-    // FIXME(#10151) -- Define more precisely when a region is\n-    // considered \"nested\". Consider taking variance into account as\n-    // well.\n+        match ty::get(ty).sty {\n+            ty::ty_nil |\n+            ty::ty_bot |\n+            ty::ty_bool |\n+            ty::ty_char |\n+            ty::ty_int(..) |\n+            ty::ty_uint(..) |\n+            ty::ty_float(..) |\n+            ty::ty_bare_fn(..) |\n+            ty::ty_err |\n+            ty::ty_str => {\n+                // No borrowed content reachable here.\n+            }\n \n-    impl<'a> TypeFolder for RegionRelator<'a> {\n-        fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n-            self.tcx\n-        }\n+            ty::ty_closure(box ref c) => {\n+                self.accumulate_from_closure_ty(ty, c);\n+            }\n \n-        fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n-            match ty::get(ty).sty {\n-                ty::ty_rptr(r, ty::mt {ty, ..}) => {\n-                    self.relate(r);\n-                    self.stack.push(r);\n-                    ty_fold::super_fold_ty(self, ty);\n-                    self.stack.pop().unwrap();\n-                }\n+            ty::ty_unboxed_closure(_, region) => {\n+                // An \"unboxed closure type\" is basically\n+                // modeled here as equivalent to a struct like\n+                //\n+                //     struct TheClosure<'b> {\n+                //         ...\n+                //     }\n+                //\n+                // where the `'b` is the lifetime bound of the\n+                // contents (i.e., all contents must outlive 'b).\n+                self.push_region_constraint_from_top(region);\n+            }\n \n-                _ => {\n-                    ty_fold::super_fold_ty(self, ty);\n-                }\n+            ty::ty_trait(ref t) => {\n+                self.accumulate_from_object_ty(ty, &t.bounds)\n             }\n \n-            ty\n-        }\n+            ty::ty_enum(def_id, ref substs) |\n+            ty::ty_struct(def_id, ref substs) => {\n+                self.accumulate_from_adt(ty, def_id, substs)\n+            }\n \n-        fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-            self.relate(r);\n-            r\n-        }\n-    }\n+            ty::ty_vec(t, _) |\n+            ty::ty_ptr(ty::mt { ty: t, .. }) |\n+            ty::ty_box(t) |\n+            ty::ty_uniq(t) => {\n+                self.accumulate_from_ty(t)\n+            }\n+\n+            ty::ty_rptr(r_b, mt) => {\n+                self.accumulate_from_rptr(ty, r_b, mt.ty);\n+            }\n+\n+            ty::ty_param(p) => {\n+                self.push_param_constraint_from_top(p);\n+            }\n \n-    impl<'a> RegionRelator<'a> {\n-        fn relate(&mut self, r_sub: ty::Region) {\n-            for &r in self.stack.iter() {\n-                if !r.is_bound() && !r_sub.is_bound() {\n-                    (self.relate_op)(r, r_sub);\n+            ty::ty_tup(ref tuptys) => {\n+                for &tupty in tuptys.iter() {\n+                    self.accumulate_from_ty(tupty);\n                 }\n             }\n+\n+            ty::ty_infer(_) => {\n+                // This should not happen, BUT:\n+                //\n+                //   Currently we uncover region relationships on\n+                //   entering the fn check. We should do this after\n+                //   the fn check, then we can call this case a bug().\n+            }\n+\n+            ty::ty_open(_) => {\n+                self.tcx.sess.bug(\n+                    format!(\"Unexpected type encountered while doing wf check: {}\",\n+                            ty.repr(self.tcx)).as_slice());\n+            }\n         }\n     }\n-}\n \n-pub fn relate_free_regions(tcx: &ty::ctxt, fn_sig: &ty::FnSig) {\n-    /*!\n-     * This function populates the region map's `free_region_map`.\n-     * It walks over the transformed self type and argument types\n-     * for each function just before we check the body of that\n-     * function, looking for types where you have a borrowed\n-     * pointer to other borrowed data (e.g., `&'a &'b [uint]`.\n-     * We do not allow references to outlive the things they\n-     * point at, so we can assume that `'a <= 'b`.\n-     *\n-     * Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n-     */\n+    fn accumulate_from_rptr(&mut self,\n+                            ty: ty::t,\n+                            r_b: ty::Region,\n+                            ty_b: ty::t) {\n+        // We are walking down a type like this, and current\n+        // position is indicated by caret:\n+        //\n+        //     &'a &'b ty_b\n+        //         ^\n+        //\n+        // At this point, top of stack will be `'a`. We must\n+        // require that `'a <= 'b`.\n+\n+        self.push_region_constraint_from_top(r_b);\n+\n+        // Now we push `'b` onto the stack, because it must\n+        // constrain any borrowed content we find within `T`.\n \n-    debug!(\"relate_free_regions >>\");\n+        self.stack.push((r_b, Some(ty)));\n+        self.accumulate_from_ty(ty_b);\n+        self.stack.pop().unwrap();\n+    }\n+\n+    fn push_region_constraint_from_top(&mut self,\n+                                       r_b: ty::Region) {\n+        /*!\n+         * Pushes a constraint that `r_b` must outlive the\n+         * top region on the stack.\n+         */\n+\n+        // Indicates that we have found borrowed content with a lifetime\n+        // of at least `r_b`. This adds a constraint that `r_b` must\n+        // outlive the region `r_a` on top of the stack.\n+        //\n+        // As an example, imagine walking a type like:\n+        //\n+        //     &'a &'b T\n+        //         ^\n+        //\n+        // when we hit the inner pointer (indicated by caret), `'a` will\n+        // be on top of stack and `'b` will be the lifetime of the content\n+        // we just found. So we add constraint that `'a <= 'b`.\n+\n+        let &(r_a, opt_ty) = self.stack.last().unwrap();\n+        self.push_sub_region_constraint(opt_ty, r_a, r_b);\n+    }\n \n-    let mut all_tys = Vec::new();\n-    for arg in fn_sig.inputs.iter() {\n-        all_tys.push(*arg);\n+    fn push_sub_region_constraint(&mut self,\n+                                  opt_ty: Option<ty::t>,\n+                                  r_a: ty::Region,\n+                                  r_b: ty::Region) {\n+        /*! Pushes a constraint that `r_a <= r_b`, due to `opt_ty` */\n+        self.out.push(RegionSubRegionConstraint(opt_ty, r_a, r_b));\n     }\n \n-    for &t in all_tys.iter() {\n-        debug!(\"relate_free_regions(t={})\", ppaux::ty_to_string(tcx, t));\n-        relate_nested_regions(tcx, None, t, |a, b| {\n-            match (&a, &b) {\n-                (&ty::ReFree(free_a), &ty::ReFree(free_b)) => {\n-                    tcx.region_maps.relate_free_regions(free_a, free_b);\n+    fn push_param_constraint_from_top(&mut self,\n+                                      param_ty: ty::ParamTy) {\n+        /*!\n+         * Pushes a constraint that `param_ty` must outlive the\n+         * top region on the stack.\n+         */\n+\n+        let &(region, opt_ty) = self.stack.last().unwrap();\n+        self.push_param_constraint(region, opt_ty, param_ty);\n+    }\n+\n+    fn push_param_constraint(&mut self,\n+                             region: ty::Region,\n+                             opt_ty: Option<ty::t>,\n+                             param_ty: ty::ParamTy) {\n+        /*! Pushes a constraint that `region <= param_ty`, due to `opt_ty` */\n+        self.out.push(RegionSubParamConstraint(opt_ty, region, param_ty));\n+    }\n+\n+    fn accumulate_from_adt(&mut self,\n+                           ty: ty::t,\n+                           def_id: ast::DefId,\n+                           substs: &Substs)\n+    {\n+        // The generic declarations from the type, appropriately\n+        // substituted for the actual substitutions.\n+        let generics =\n+            ty::lookup_item_type(self.tcx, def_id)\n+            .generics\n+            .subst(self.tcx, substs);\n+\n+        // Variance of each type/region parameter.\n+        let variances = ty::item_variances(self.tcx, def_id);\n+\n+        for &space in ParamSpace::all().iter() {\n+            let region_params = substs.regions().get_slice(space);\n+            let region_variances = variances.regions.get_slice(space);\n+            let region_param_defs = generics.regions.get_slice(space);\n+            assert_eq!(region_params.len(), region_variances.len());\n+            for (&region_param, (&region_variance, region_param_def)) in\n+                region_params.iter().zip(\n+                    region_variances.iter().zip(\n+                        region_param_defs.iter()))\n+            {\n+                match region_variance {\n+                    ty::Covariant | ty::Bivariant => {\n+                        // Ignore covariant or bivariant region\n+                        // parameters.  To understand why, consider a\n+                        // struct `Foo<'a>`. If `Foo` contains any\n+                        // references with lifetime `'a`, then `'a` must\n+                        // be at least contravariant (and possibly\n+                        // invariant). The only way to have a covariant\n+                        // result is if `Foo` contains only a field with a\n+                        // type like `fn() -> &'a T`; i.e., a bare\n+                        // function that can produce a reference of\n+                        // lifetime `'a`. In this case, there is no\n+                        // *actual data* with lifetime `'a` that is\n+                        // reachable. (Presumably this bare function is\n+                        // really returning static data.)\n+                    }\n+\n+                    ty::Contravariant | ty::Invariant => {\n+                        // If the parameter is contravariant or\n+                        // invariant, there may indeed be reachable\n+                        // data with this lifetime. See other case for\n+                        // more details.\n+                        self.push_region_constraint_from_top(region_param);\n+                    }\n+                }\n+\n+                for &region_bound in region_param_def.bounds.iter() {\n+                    // The type declared a constraint like\n+                    //\n+                    //     'b : 'a\n+                    //\n+                    // which means that `'a <= 'b` (after\n+                    // substitution).  So take the region we\n+                    // substituted for `'a` (`region_bound`) and make\n+                    // it a subregion of the region we substituted\n+                    // `'b` (`region_param`).\n+                    self.push_sub_region_constraint(\n+                        Some(ty), region_bound, region_param);\n                 }\n-                _ => {}\n             }\n-        })\n+\n+            let types = substs.types.get_slice(space);\n+            let type_variances = variances.types.get_slice(space);\n+            let type_param_defs = generics.types.get_slice(space);\n+            assert_eq!(types.len(), type_variances.len());\n+            for (&type_param_ty, (&variance, type_param_def)) in\n+                types.iter().zip(\n+                    type_variances.iter().zip(\n+                        type_param_defs.iter()))\n+            {\n+                debug!(\"type_param_ty={} variance={}\",\n+                       type_param_ty.repr(self.tcx),\n+                       variance.repr(self.tcx));\n+\n+                match variance {\n+                    ty::Contravariant | ty::Bivariant => {\n+                        // As above, except that in this it is a\n+                        // *contravariant* reference that indices that no\n+                        // actual data of type T is reachable.\n+                    }\n+\n+                    ty::Covariant | ty::Invariant => {\n+                        self.accumulate_from_ty(type_param_ty);\n+                    }\n+                }\n+\n+                // Inspect bounds on this type parameter for any\n+                // region bounds.\n+                for &r in type_param_def.bounds.opt_region_bound.iter() {\n+                    self.stack.push((r, Some(ty)));\n+                    self.accumulate_from_ty(type_param_ty);\n+                    self.stack.pop().unwrap();\n+                }\n+            }\n+        }\n+    }\n+\n+    fn accumulate_from_closure_ty(&mut self,\n+                                  ty: ty::t,\n+                                  c: &ty::ClosureTy)\n+    {\n+        match c.store {\n+            ty::RegionTraitStore(r_b, _) => {\n+                self.push_region_constraint_from_top(r_b);\n+            }\n+            ty::UniqTraitStore => { }\n+        }\n+\n+        self.accumulate_from_object_ty(ty, &c.bounds)\n     }\n \n-    debug!(\"<< relate_free_regions\");\n+    fn accumulate_from_object_ty(&mut self,\n+                                 ty: ty::t,\n+                                 bounds: &ty::ExistentialBounds)\n+    {\n+        // Imagine a type like this:\n+        //\n+        //     trait Foo { }\n+        //     trait Bar<'c> : 'c { }\n+        //\n+        //     &'b (Foo+'c+Bar<'d>)\n+        //         ^\n+        //\n+        // In this case, the following relationships must hold:\n+        //\n+        //     'b <= 'c\n+        //     'd <= 'c\n+        //\n+        // The first conditions is due to the normal region pointer\n+        // rules, which say that a reference cannot outlive its\n+        // referent.\n+        //\n+        // The final condition may be a bit surprising. In particular,\n+        // you may expect that it would have been `'c <= 'd`, since\n+        // usually lifetimes of outer things are conservative\n+        // approximations for inner things. However, it works somewhat\n+        // differently with trait objects: here the idea is that if the\n+        // user specifies a region bound (`'c`, in this case) it is the\n+        // \"master bound\" that *implies* that bounds from other traits are\n+        // all met. (Remember that *all bounds* in a type like\n+        // `Foo+Bar+Zed` must be met, not just one, hence if we write\n+        // `Foo<'x>+Bar<'y>`, we know that the type outlives *both* 'x and\n+        // 'y.)\n+        //\n+        // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n+        // am looking forward to the future here.\n+\n+        // The content of this object type must outlive\n+        // `bounds.region_bound`:\n+        let r_c = bounds.region_bound;\n+        self.push_region_constraint_from_top(r_c);\n+\n+        // And then, in turn, to be well-formed, the\n+        // `region_bound` that user specified must imply the\n+        // region bounds required from all of the trait types:\n+        let required_region_bounds =\n+            ty::required_region_bounds(self.tcx,\n+                                       [],\n+                                       bounds.builtin_bounds,\n+                                       []);\n+        for &r_d in required_region_bounds.iter() {\n+            // Each of these is an instance of the `'c <= 'b`\n+            // constraint above\n+            self.out.push(RegionSubRegionConstraint(Some(ty), r_d, r_c));\n+        }\n+    }\n }"}, {"sha": "2d4022a2eaa52a2409172e9b175ca9fe9b82c7c3", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -94,7 +94,7 @@ fn lookup_vtables(vcx: &VtableContext,\n     let result = type_param_defs.map_rev(|def| {\n         let ty = *substs.types.get(def.space, def.index);\n         lookup_vtables_for_param(vcx, span, Some(substs),\n-                                 &*def.bounds, ty, is_early)\n+                                 &def.bounds, ty, is_early)\n     });\n \n     debug!(\"lookup_vtables result(\\\n@@ -564,7 +564,7 @@ fn fixup_substs(vcx: &VtableContext,\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx,\n                          id, substs,\n-                         ty::empty_builtin_bounds());\n+                         ty::region_existential_bound(ty::ReStatic));\n     fixup_ty(vcx, span, t, is_early).map(|t_f| {\n         match ty::get(t_f).sty {\n           ty::ty_trait(ref inner) => inner.substs.clone(),\n@@ -644,7 +644,6 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n           (&ty::ty_uniq(..), &ty::ty_uniq(..) ) => {}\n           (&ty::ty_rptr(r_t, _), &ty::ty_rptr(r_s, _)) => {\n               infer::mk_subr(fcx.infcx(),\n-                             false,\n                              infer::RelateObjectBound(ex.span),\n                              r_t,\n                              r_s);\n@@ -702,9 +701,11 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n               });\n \n               let param_bounds = ty::ParamBounds {\n+                  opt_region_bound: None,\n                   builtin_bounds: ty::empty_builtin_bounds(),\n                   trait_bounds: vec!(target_trait_ref)\n               };\n+\n               let vtables =\n                     lookup_vtables_for_param(&vcx,\n                                              ex.span,"}, {"sha": "e7bc06d4972e48e05c507ce413e6b65c671f2280", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 254, "deletions": 218, "changes": 472, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -42,47 +42,31 @@ use middle::ty::{Polytype};\n use middle::ty;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n-use middle::typeck::astconv::{ast_ty_to_ty};\n+use middle::typeck::astconv::{ast_ty_to_ty, ast_region_to_region};\n use middle::typeck::astconv;\n use middle::typeck::infer;\n use middle::typeck::rscope::*;\n use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n use middle::typeck;\n use util::ppaux;\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr,UserString};\n \n use std::collections::{HashMap, HashSet};\n use std::rc::Rc;\n use std::gc::Gc;\n \n use syntax::abi;\n-use syntax::ast::{StaticRegionTyParamBound, OtherRegionTyParamBound};\n-use syntax::ast::{TraitTyParamBound, UnboxedFnTyParamBound};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, split_trait_methods, PostExpansionMethod};\n use syntax::codemap::Span;\n-use syntax::codemap;\n-use syntax::owned_slice::OwnedSlice;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::{special_idents};\n use syntax::parse::token;\n use syntax::print::pprust::{path_to_string};\n use syntax::visit;\n \n-struct CollectItemTypesVisitor<'a> {\n-    ccx: &'a CrateCtxt<'a>\n-}\n-\n-impl<'a> visit::Visitor<()> for CollectItemTypesVisitor<'a> {\n-    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n-        convert(self.ccx, i);\n-        visit::walk_item(self, i, ());\n-    }\n-    fn visit_foreign_item(&mut self, i: &ast::ForeignItem, _: ()) {\n-        convert_foreign(self.ccx, i);\n-        visit::walk_foreign_item(self, i, ());\n-    }\n-}\n+///////////////////////////////////////////////////////////////////////////\n+// Main entry point\n \n pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n@@ -99,10 +83,57 @@ pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n         Some(id) => { collect_intrinsic_type(ccx, id); } None => {}\n     }\n \n+    let mut visitor = CollectTraitDefVisitor{ ccx: ccx };\n+    visit::walk_crate(&mut visitor, krate, ());\n+\n     let mut visitor = CollectItemTypesVisitor{ ccx: ccx };\n     visit::walk_crate(&mut visitor, krate, ());\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// First phase: just collect *trait definitions* -- basically, the set\n+// of type parameters and supertraits. This is information we need to\n+// know later when parsing field defs.\n+\n+struct CollectTraitDefVisitor<'a> {\n+    ccx: &'a CrateCtxt<'a>\n+}\n+\n+impl<'a> visit::Visitor<()> for CollectTraitDefVisitor<'a> {\n+    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n+        match i.node {\n+            ast::ItemTrait(..) => {\n+                // computing the trait def also fills in the table\n+                let _ = trait_def_of_item(self.ccx, i);\n+            }\n+            _ => { }\n+        }\n+\n+        visit::walk_item(self, i, ());\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Second phase: collection proper.\n+\n+struct CollectItemTypesVisitor<'a> {\n+    ccx: &'a CrateCtxt<'a>\n+}\n+\n+impl<'a> visit::Visitor<()> for CollectItemTypesVisitor<'a> {\n+    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n+        convert(self.ccx, i);\n+        visit::walk_item(self, i, ());\n+    }\n+    fn visit_foreign_item(&mut self, i: &ast::ForeignItem, _: ()) {\n+        convert_foreign(self.ccx, i);\n+        visit::walk_foreign_item(self, i, ());\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Utility types and common code for the above passes.\n+\n pub trait ToTy {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t;\n }\n@@ -193,9 +224,9 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn ensure_trait_methods(ccx: &CrateCtxt,\n-                            trait_id: ast::NodeId,\n-                            trait_def: &ty::TraitDef) {\n+fn collect_trait_methods(ccx: &CrateCtxt,\n+                         trait_id: ast::NodeId,\n+                         trait_def: &ty::TraitDef) {\n     let tcx = ccx.tcx;\n     match tcx.map.get(trait_id) {\n         ast_map::NodeItem(item) => {\n@@ -360,7 +391,13 @@ fn convert_methods(ccx: &CrateCtxt,\n                    ms: &[Gc<ast::Method>],\n                    untransformed_rcvr_ty: ty::t,\n                    rcvr_ty_generics: &ty::Generics,\n-                   rcvr_visibility: ast::Visibility) {\n+                   rcvr_visibility: ast::Visibility)\n+{\n+    debug!(\"convert_methods(untransformed_rcvr_ty={}, \\\n+            rcvr_ty_generics={})\",\n+           untransformed_rcvr_ty.repr(ccx.tcx),\n+           rcvr_ty_generics.repr(ccx.tcx));\n+\n     let tcx = ccx.tcx;\n     let mut seen_methods = HashSet::new();\n     for m in ms.iter() {\n@@ -388,6 +425,9 @@ fn convert_methods(ccx: &CrateCtxt,\n \n         write_ty_to_tcx(tcx, m.id, fty);\n \n+        debug!(\"writing method type: def_id={} mty={}\",\n+               mty.def_id, mty.repr(ccx.tcx));\n+\n         tcx.impl_or_trait_items\n            .borrow_mut()\n            .insert(mty.def_id, ty::MethodTraitItem(mty));\n@@ -448,9 +488,20 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n     for ty_param in generics.ty_params.iter() {\n-        if ty_param.bounds.len() > 0 {\n-            span_err!(ccx.tcx.sess, span, E0122,\n-                      \"trait bounds are not allowed in {} definitions\", thing);\n+        for bound in ty_param.bounds.iter() {\n+            match *bound {\n+                ast::TraitTyParamBound(..) | ast::UnboxedFnTyParamBound(..) => {\n+                    // According to accepted RFC #XXX, we should\n+                    // eventually accept these, but it will not be\n+                    // part of this PR. Still, convert to warning to\n+                    // make bootstrapping easier.\n+                    span_warn!(ccx.tcx.sess, span, E0122,\n+                               \"trait bounds are not (yet) enforced \\\n+                                in {} definitions\",\n+                               thing);\n+                }\n+                ast::RegionTyParamBound(..) => { }\n+            }\n         }\n     }\n }\n@@ -520,6 +571,10 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n             let trait_def = trait_def_of_item(ccx, it);\n \n+            debug!(\"trait_def: ident={} trait_def={}\",\n+                   it.ident.repr(ccx.tcx),\n+                   trait_def.repr(ccx.tcx()));\n+\n             for trait_method in trait_methods.iter() {\n                 let self_type = ty::mk_param(ccx.tcx,\n                                              subst::SelfSpace,\n@@ -556,7 +611,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             // We need to do this *after* converting methods, since\n             // convert_methods produces a tcache entry that is wrong for\n             // static trait methods. This is somewhat unfortunate.\n-            ensure_trait_methods(ccx, it.id, &*trait_def);\n+            collect_trait_methods(ccx, it.id, &*trait_def);\n         },\n         ast::ItemStruct(struct_def, _) => {\n             // Write the class type.\n@@ -739,6 +794,19 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n     }\n }\n \n+pub fn instantiate_unboxed_fn_ty(ccx: &CrateCtxt,\n+                                 unboxed_function: &ast::UnboxedFnTy,\n+                                 param_ty: ty::ParamTy)\n+                                 -> Rc<ty::TraitRef>\n+{\n+    let rscope = ExplicitRscope;\n+    let param_ty = param_ty.to_ty(ccx.tcx);\n+    Rc::new(astconv::trait_ref_for_unboxed_function(ccx,\n+                                                    &rscope,\n+                                                    unboxed_function,\n+                                                    Some(param_ty)))\n+}\n+\n fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n     if trait_id.krate != ast::LOCAL_CRATE {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n@@ -761,9 +829,9 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n         _ => {}\n     }\n \n-    let (generics, unbound, supertraits) = match it.node {\n-        ast::ItemTrait(ref generics, ref unbound, ref supertraits, _) => {\n-            (generics, unbound, supertraits)\n+    let (generics, unbound, bounds) = match it.node {\n+        ast::ItemTrait(ref generics, ref unbound, ref bounds, _) => {\n+            (generics, unbound, bounds)\n         }\n         ref s => {\n             tcx.sess.span_bug(\n@@ -779,13 +847,16 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n                                             &substs,\n                                             generics);\n \n-    let builtin_bounds =\n-        ensure_supertraits(ccx, it.id, it.span, supertraits, unbound);\n+    let self_param_ty = ty::ParamTy::for_self(def_id);\n+\n+    let bounds = compute_bounds(ccx, token::SELF_KEYWORD_NAME, self_param_ty,\n+                                bounds.as_slice(), unbound, it.span,\n+                                &generics.where_clause);\n \n     let substs = mk_item_substs(ccx, &ty_generics);\n     let trait_def = Rc::new(ty::TraitDef {\n         generics: ty_generics,\n-        bounds: builtin_bounds,\n+        bounds: bounds,\n         trait_ref: Rc::new(ty::TraitRef {\n             def_id: def_id,\n             substs: substs\n@@ -824,55 +895,6 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n \n         subst::Substs::new_trait(types, regions, self_ty)\n     }\n-\n-    fn ensure_supertraits(ccx: &CrateCtxt,\n-                          id: ast::NodeId,\n-                          sp: codemap::Span,\n-                          ast_trait_refs: &Vec<ast::TraitRef>,\n-                          unbound: &Option<ast::TyParamBound>)\n-                          -> ty::BuiltinBounds\n-    {\n-        let tcx = ccx.tcx;\n-\n-        // Called only the first time trait_def_of_item is called.\n-        // Supertraits are ensured at the same time.\n-        assert!(!tcx.supertraits.borrow().contains_key(&local_def(id)));\n-\n-        let self_ty = ty::mk_self_type(ccx.tcx, local_def(id));\n-        let mut ty_trait_refs: Vec<Rc<ty::TraitRef>> = Vec::new();\n-        let mut bounds = ty::empty_builtin_bounds();\n-        for ast_trait_ref in ast_trait_refs.iter() {\n-            let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, ast_trait_ref);\n-\n-            // FIXME(#8559): Need to instantiate the trait_ref whether\n-            // or not it's a builtin trait, so that the trait's node\n-            // id appears in the tcx trait_ref map. This is only\n-            // needed for metadata; see the similar fixme in\n-            // encoder.rs.\n-\n-            let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, self_ty);\n-            if !ty::try_add_builtin_trait(ccx.tcx, trait_def_id, &mut bounds) {\n-\n-                // FIXME(#5527) Could have same trait multiple times\n-                if ty_trait_refs.iter().any(\n-                    |other_trait| other_trait.def_id == trait_ref.def_id)\n-                {\n-                    // This means a trait inherited from the same\n-                    // supertrait more than once.\n-                    span_err!(tcx.sess, sp, E0127,\n-                              \"duplicate supertrait in trait declaration\");\n-                    break;\n-                } else {\n-                    ty_trait_refs.push(trait_ref);\n-                }\n-            }\n-        }\n-\n-        add_unsized_bound(ccx, unbound, &mut bounds, \"trait\", sp);\n-        tcx.supertraits.borrow_mut().insert(local_def(id),\n-                                            Rc::new(ty_trait_refs));\n-        bounds\n-    }\n }\n \n pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n@@ -984,11 +1006,12 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n \n fn ty_generics_for_type(ccx: &CrateCtxt,\n                         generics: &ast::Generics)\n-                        -> ty::Generics {\n+                        -> ty::Generics\n+{\n     ty_generics(ccx,\n                 subst::TypeSpace,\n-                &generics.lifetimes,\n-                &generics.ty_params,\n+                generics.lifetimes.as_slice(),\n+                generics.ty_params.as_slice(),\n                 ty::Generics::empty(),\n                 &generics.where_clause)\n }\n@@ -1000,8 +1023,8 @@ fn ty_generics_for_trait(ccx: &CrateCtxt,\n                          -> ty::Generics {\n     let mut generics = ty_generics(ccx,\n                                    subst::TypeSpace,\n-                                   &generics.lifetimes,\n-                                   &generics.ty_params,\n+                                   generics.lifetimes.as_slice(),\n+                                   generics.ty_params.as_slice(),\n                                    ty::Generics::empty(),\n                                    &generics.where_clause);\n \n@@ -1018,10 +1041,11 @@ fn ty_generics_for_trait(ccx: &CrateCtxt,\n         index: 0,\n         ident: special_idents::type_self,\n         def_id: local_def(param_id),\n-        bounds: Rc::new(ty::ParamBounds {\n+        bounds: ty::ParamBounds {\n+            opt_region_bound: None,\n             builtin_bounds: ty::empty_builtin_bounds(),\n             trait_bounds: vec!(self_trait_ref),\n-        }),\n+        },\n         default: None\n     };\n \n@@ -1039,8 +1063,8 @@ fn ty_generics_for_fn_or_method(ccx: &CrateCtxt,\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n     ty_generics(ccx,\n                 subst::FnSpace,\n-                &early_lifetimes,\n-                &generics.ty_params,\n+                early_lifetimes.as_slice(),\n+                generics.ty_params.as_slice(),\n                 base_generics,\n                 &generics.where_clause)\n }\n@@ -1053,7 +1077,7 @@ fn add_unsized_bound(ccx: &CrateCtxt,\n                      span: Span) {\n     let kind_id = ccx.tcx.lang_items.require(SizedTraitLangItem);\n     match unbound {\n-        &Some(TraitTyParamBound(ref tpb)) => {\n+        &Some(ast::TraitTyParamBound(ref tpb)) => {\n             // #FIXME(8559) currently requires the unbound to be built-in.\n             let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, tpb);\n             match kind_id {\n@@ -1084,18 +1108,23 @@ fn add_unsized_bound(ccx: &CrateCtxt,\n \n fn ty_generics(ccx: &CrateCtxt,\n                space: subst::ParamSpace,\n-               lifetimes: &Vec<ast::LifetimeDef>,\n-               types: &OwnedSlice<ast::TyParam>,\n+               lifetime_defs: &[ast::LifetimeDef],\n+               types: &[ast::TyParam],\n                base_generics: ty::Generics,\n                where_clause: &ast::WhereClause)\n-               -> ty::Generics {\n+               -> ty::Generics\n+{\n     let mut result = base_generics;\n \n-    for (i, l) in lifetimes.iter().enumerate() {\n+    for (i, l) in lifetime_defs.iter().enumerate() {\n+        let bounds = l.bounds.iter()\n+                             .map(|l| ast_region_to_region(ccx.tcx, l))\n+                             .collect();\n         let def = ty::RegionParameterDef { name: l.lifetime.name,\n                                            space: space,\n                                            index: i,\n-                                           def_id: local_def(l.lifetime.id) };\n+                                           def_id: local_def(l.lifetime.id),\n+                                           bounds: bounds };\n         debug!(\"ty_generics: def for region param: {}\", def);\n         result.regions.push(space, def);\n     }\n@@ -1123,19 +1152,17 @@ fn ty_generics(ccx: &CrateCtxt,\n             None => { }\n         }\n \n-        let param_ty = ty::ParamTy {space: space,\n-                                    idx: index,\n-                                    def_id: local_def(param.id)};\n-        let bounds = Rc::new(compute_bounds(ccx,\n-                                            param_ty,\n-                                            &param.bounds,\n-                                            &param.unbound,\n-                                            param.ident,\n-                                            param.span,\n-                                            where_clause));\n+        let param_ty = ty::ParamTy::new(space, index, local_def(param.id));\n+        let bounds = compute_bounds(ccx,\n+                                    param.ident.name,\n+                                    param_ty,\n+                                    param.bounds.as_slice(),\n+                                    &param.unbound,\n+                                    param.span,\n+                                    where_clause);\n         let default = param.default.map(|path| {\n             let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*path);\n-            let cur_idx = param_ty.idx;\n+            let cur_idx = index;\n \n             ty::walk_ty(ty, |t| {\n                 match ty::get(t).sty {\n@@ -1164,130 +1191,139 @@ fn ty_generics(ccx: &CrateCtxt,\n \n         def\n     }\n+}\n \n-    fn compute_bounds(ccx: &CrateCtxt,\n-                      param_ty: ty::ParamTy,\n-                      ast_bounds: &OwnedSlice<ast::TyParamBound>,\n-                      unbound: &Option<ast::TyParamBound>,\n-                      ident: ast::Ident,\n-                      span: Span,\n-                      where_clause: &ast::WhereClause)\n-                      -> ty::ParamBounds {\n-        /*!\n-         * Translate the AST's notion of ty param bounds (which are an\n-         * enum consisting of a newtyped Ty or a region) to ty's\n-         * notion of ty param bounds, which can either be user-defined\n-         * traits, or the built-in trait (formerly known as kind): Send.\n-         */\n-\n-        let mut param_bounds = ty::ParamBounds {\n-            builtin_bounds: ty::empty_builtin_bounds(),\n-            trait_bounds: Vec::new()\n-        };\n-        for ast_bound in ast_bounds.iter() {\n-            compute_bound(ccx, &mut param_bounds, param_ty, ast_bound);\n-        }\n-        for predicate in where_clause.predicates.iter() {\n-            let predicate_param_id = ccx.tcx\n-                                        .def_map\n-                                        .borrow()\n-                                        .find(&predicate.id)\n-                                        .expect(\"compute_bounds(): resolve \\\n-                                                 didn't resolve the type \\\n-                                                 parameter identifier in a \\\n-                                                 `where` clause\")\n-                                        .def_id();\n-            if param_ty.def_id != predicate_param_id {\n-                continue\n-            }\n-            for bound in predicate.bounds.iter() {\n-                compute_bound(ccx, &mut param_bounds, param_ty, bound);\n-            }\n-        }\n-\n-        add_unsized_bound(ccx,\n-                          unbound,\n-                          &mut param_bounds.builtin_bounds,\n-                          \"type parameter\",\n-                          span);\n-\n-        check_bounds_compatible(ccx.tcx, &param_bounds, ident, span);\n+fn compute_bounds(\n+    ccx: &CrateCtxt,\n+    name_of_bounded_thing: ast::Name,\n+    param_ty: ty::ParamTy,\n+    ast_bounds: &[ast::TyParamBound],\n+    unbound: &Option<ast::TyParamBound>,\n+    span: Span,\n+    where_clause: &ast::WhereClause)\n+    -> ty::ParamBounds\n+{\n+    /*!\n+     * Translate the AST's notion of ty param bounds (which are an\n+     * enum consisting of a newtyped Ty or a region) to ty's\n+     * notion of ty param bounds, which can either be user-defined\n+     * traits, or the built-in trait (formerly known as kind): Send.\n+     */\n \n-        param_bounds.trait_bounds.sort_by(|a,b| a.def_id.cmp(&b.def_id));\n+    let mut param_bounds = conv_param_bounds(ccx,\n+                                             span,\n+                                             param_ty,\n+                                             ast_bounds,\n+                                             where_clause);\n \n-        param_bounds\n-    }\n \n-    /// Translates the AST's notion of a type parameter bound to\n-    /// typechecking's notion of the same, and pushes the resulting bound onto\n-    /// the appropriate section of `param_bounds`.\n-    fn compute_bound(ccx: &CrateCtxt,\n-                     param_bounds: &mut ty::ParamBounds,\n-                     param_ty: ty::ParamTy,\n-                     ast_bound: &ast::TyParamBound) {\n-        match *ast_bound {\n-            TraitTyParamBound(ref b) => {\n-                let ty = ty::mk_param(ccx.tcx, param_ty.space,\n-                                      param_ty.idx, param_ty.def_id);\n-                let trait_ref = instantiate_trait_ref(ccx, b, ty);\n-                if !ty::try_add_builtin_trait(\n-                        ccx.tcx, trait_ref.def_id,\n-                        &mut param_bounds.builtin_bounds) {\n-                    // Must be a user-defined trait\n-                    param_bounds.trait_bounds.push(trait_ref);\n-                }\n-            }\n+    add_unsized_bound(ccx,\n+                      unbound,\n+                      &mut param_bounds.builtin_bounds,\n+                      \"type parameter\",\n+                      span);\n \n-            StaticRegionTyParamBound => {\n-                param_bounds.builtin_bounds.add(ty::BoundStatic);\n-            }\n+    check_bounds_compatible(ccx.tcx, name_of_bounded_thing,\n+                            &param_bounds, span);\n \n-            UnboxedFnTyParamBound(ref unboxed_function) => {\n-                let rscope = ExplicitRscope;\n-                let self_ty = ty::mk_param(ccx.tcx,\n-                                           param_ty.space,\n-                                           param_ty.idx,\n-                                           param_ty.def_id);\n-                let trait_ref =\n-                    astconv::trait_ref_for_unboxed_function(ccx,\n-                                                            &rscope,\n-                                                            unboxed_function,\n-                                                            Some(self_ty));\n-                param_bounds.trait_bounds.push(Rc::new(trait_ref));\n-            }\n+    param_bounds.trait_bounds.sort_by(|a,b| a.def_id.cmp(&b.def_id));\n \n-            OtherRegionTyParamBound(span) => {\n-                if !ccx.tcx.sess.features.issue_5723_bootstrap.get() {\n-                    ccx.tcx.sess.span_err(\n-                        span,\n-                        \"only the 'static lifetime is accepted here.\");\n-                }\n-            }\n-        }\n-    }\n+    param_bounds\n+}\n \n-    fn check_bounds_compatible(tcx: &ty::ctxt,\n-                               param_bounds: &ty::ParamBounds,\n-                               ident: ast::Ident,\n-                               span: Span) {\n-        // Currently the only bound which is incompatible with other bounds is\n-        // Sized/Unsized.\n-        if !param_bounds.builtin_bounds.contains_elem(ty::BoundSized) {\n-            ty::each_bound_trait_and_supertraits(tcx,\n-                                                 param_bounds.trait_bounds.as_slice(),\n-                                                 |trait_ref| {\n+fn check_bounds_compatible(tcx: &ty::ctxt,\n+                           name_of_bounded_thing: ast::Name,\n+                           param_bounds: &ty::ParamBounds,\n+                           span: Span) {\n+    // Currently the only bound which is incompatible with other bounds is\n+    // Sized/Unsized.\n+    if !param_bounds.builtin_bounds.contains_elem(ty::BoundSized) {\n+        ty::each_bound_trait_and_supertraits(\n+            tcx,\n+            param_bounds.trait_bounds.as_slice(),\n+            |trait_ref| {\n                 let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n-                if trait_def.bounds.contains_elem(ty::BoundSized) {\n+                if trait_def.bounds.builtin_bounds.contains_elem(ty::BoundSized) {\n                     span_err!(tcx.sess, span, E0129,\n-                              \"incompatible bounds on type parameter {}, \\\n-                               bound {} does not allow unsized type\",\n-                              token::get_ident(ident),\n+                              \"incompatible bounds on type parameter `{}`, \\\n+                               bound `{}` does not allow unsized type\",\n+                              name_of_bounded_thing.user_string(tcx),\n                               ppaux::trait_ref_to_string(tcx, &*trait_ref));\n                 }\n                 true\n             });\n+    }\n+}\n+\n+fn conv_param_bounds(ccx: &CrateCtxt,\n+                     span: Span,\n+                     param_ty: ty::ParamTy,\n+                     ast_bounds: &[ast::TyParamBound],\n+                     where_clause: &ast::WhereClause)\n+                     -> ty::ParamBounds\n+{\n+    let all_bounds =\n+        merge_param_bounds(ccx, param_ty, ast_bounds, where_clause);\n+    let astconv::PartitionedBounds { builtin_bounds,\n+                                     trait_bounds,\n+                                     region_bounds,\n+                                     unboxed_fn_ty_bounds } =\n+        astconv::partition_bounds(ccx.tcx, span, all_bounds.as_slice());\n+    let unboxed_fn_ty_bounds =\n+        unboxed_fn_ty_bounds.move_iter()\n+        .map(|b| instantiate_unboxed_fn_ty(ccx, b, param_ty));\n+    let trait_bounds: Vec<Rc<ty::TraitRef>> =\n+        trait_bounds.move_iter()\n+        .map(|b| instantiate_trait_ref(ccx, b, param_ty.to_ty(ccx.tcx)))\n+        .chain(unboxed_fn_ty_bounds)\n+        .collect();\n+    let opt_region_bound =\n+        astconv::compute_opt_region_bound(\n+            ccx.tcx, span, builtin_bounds, region_bounds.as_slice(),\n+            trait_bounds.as_slice());\n+    ty::ParamBounds {\n+        opt_region_bound: opt_region_bound,\n+        builtin_bounds: builtin_bounds,\n+        trait_bounds: trait_bounds,\n+    }\n+}\n+\n+fn merge_param_bounds<'a>(ccx: &CrateCtxt,\n+                          param_ty: ty::ParamTy,\n+                          ast_bounds: &'a [ast::TyParamBound],\n+                          where_clause: &'a ast::WhereClause)\n+                          -> Vec<&'a ast::TyParamBound>\n+{\n+    /*!\n+     * Merges the bounds declared on a type parameter with those\n+     * found from where clauses into a single list.\n+     */\n+\n+    let mut result = Vec::new();\n+\n+    for ast_bound in ast_bounds.iter() {\n+        result.push(ast_bound);\n+    }\n+\n+    for predicate in where_clause.predicates.iter() {\n+        let predicate_param_id = ccx.tcx\n+            .def_map\n+            .borrow()\n+            .find(&predicate.id)\n+            .expect(\"compute_bounds(): resolve \\\n+                     didn't resolve the type \\\n+                     parameter identifier in a \\\n+                     `where` clause\")\n+            .def_id();\n+        if param_ty.def_id != predicate_param_id {\n+            continue\n+        }\n+        for bound in predicate.bounds.iter() {\n+            result.push(bound);\n         }\n     }\n+\n+    result\n }\n \n pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,"}, {"sha": "47085877ad7763832813c814a2a8477db73f6367", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -221,7 +221,7 @@ pub trait Combine {\n         };\n         let fn_style = if_ok!(self.fn_styles(a.fn_style, b.fn_style));\n         let onceness = if_ok!(self.oncenesses(a.onceness, b.onceness));\n-        let bounds = if_ok!(self.bounds(a.bounds, b.bounds));\n+        let bounds = if_ok!(self.existential_bounds(a.bounds, b.bounds));\n         let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n         let abi = if_ok!(self.abi(a.abi, b.abi));\n         Ok(ty::ClosureTy {\n@@ -251,9 +251,26 @@ pub trait Combine {\n     }\n \n     fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness>;\n-    fn bounds(&self, a: BuiltinBounds, b: BuiltinBounds) -> cres<BuiltinBounds>;\n+\n+    fn existential_bounds(&self,\n+                          a: ty::ExistentialBounds,\n+                          b: ty::ExistentialBounds)\n+                          -> cres<ty::ExistentialBounds>\n+    {\n+        let r = try!(self.contraregions(a.region_bound, b.region_bound));\n+        let nb = try!(self.builtin_bounds(a.builtin_bounds, b.builtin_bounds));\n+        Ok(ty::ExistentialBounds { region_bound: r,\n+                                   builtin_bounds: nb })\n+    }\n+\n+    fn builtin_bounds(&self,\n+                      a: ty::BuiltinBounds,\n+                      b: ty::BuiltinBounds)\n+                      -> cres<ty::BuiltinBounds>;\n+\n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                   -> cres<ty::Region>;\n+\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n \n     fn trait_stores(&self,\n@@ -479,7 +496,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       if a_.def_id == b_.def_id => {\n           debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n           let substs = if_ok!(this.substs(a_.def_id, &a_.substs, &b_.substs));\n-          let bounds = if_ok!(this.bounds(a_.bounds, b_.bounds));\n+          let bounds = if_ok!(this.existential_bounds(a_.bounds, b_.bounds));\n           Ok(ty::mk_trait(tcx,\n                           a_.def_id,\n                           substs.clone(),"}, {"sha": "2883a960df9d70a6b1fac916db7bf80a9b803d38", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 214, "deletions": 18, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -75,6 +75,7 @@ use middle::typeck::infer::region_inference::RegionResolutionError;\n use middle::typeck::infer::region_inference::ConcreteFailure;\n use middle::typeck::infer::region_inference::SubSupConflict;\n use middle::typeck::infer::region_inference::SupSupConflict;\n+use middle::typeck::infer::region_inference::ParamBoundFailure;\n use middle::typeck::infer::region_inference::ProcessedErrors;\n use middle::typeck::infer::region_inference::SameRegions;\n use std::cell::{Cell, RefCell};\n@@ -89,10 +90,13 @@ use syntax::owned_slice::OwnedSlice;\n use syntax::codemap;\n use syntax::parse::token;\n use syntax::print::pprust;\n-use util::ppaux::UserString;\n use util::ppaux::bound_region_to_string;\n use util::ppaux::note_and_explain_region;\n \n+// Note: only import UserString, not Repr, since user-facing error\n+// messages shouldn't include debug serializations.\n+use util::ppaux::UserString;\n+\n pub trait ErrorReporting {\n     fn report_region_errors(&self,\n                             errors: &Vec<RegionResolutionError>);\n@@ -118,6 +122,12 @@ pub trait ErrorReporting {\n                                sub: Region,\n                                sup: Region);\n \n+    fn report_param_bound_failure(&self,\n+                                  origin: SubregionOrigin,\n+                                  param_ty: ty::ParamTy,\n+                                  sub: Region,\n+                                  sups: Vec<Region>);\n+\n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin,\n@@ -145,7 +155,7 @@ trait ErrorReportingHelpers {\n                                 var_origin: RegionVariableOrigin);\n \n     fn note_region_origin(&self,\n-                          origin: SubregionOrigin);\n+                          origin: &SubregionOrigin);\n \n     fn give_expl_lifetime_param(&self,\n                                 decl: &ast::FnDecl,\n@@ -167,6 +177,10 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     self.report_concrete_failure(origin, sub, sup);\n                 }\n \n+                ParamBoundFailure(origin, param_ty, sub, sups) => {\n+                    self.report_param_bound_failure(origin, param_ty, sub, sups);\n+                }\n+\n                 SubSupConflict(var_origin,\n                                sub_origin, sub_r,\n                                sup_origin, sup_r) => {\n@@ -410,6 +424,62 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                      found.user_string(self.tcx)))\n     }\n \n+    fn report_param_bound_failure(&self,\n+                                  origin: SubregionOrigin,\n+                                  param_ty: ty::ParamTy,\n+                                  sub: Region,\n+                                  _sups: Vec<Region>) {\n+\n+        // FIXME: it would be better to report the first error message\n+        // with the span of the parameter itself, rather than the span\n+        // where the error was detected. But that span is not readily\n+        // accessible.\n+\n+        match sub {\n+            ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n+                // Does the required lifetime have a nice name we can print?\n+                self.tcx.sess.span_err(\n+                    origin.span(),\n+                    format!(\n+                        \"the parameter type `{}` may not live long enough; \\\n+                         consider adding an explicit lifetime bound `{}:{}`...\",\n+                        param_ty.user_string(self.tcx),\n+                        param_ty.user_string(self.tcx),\n+                        sub.user_string(self.tcx)).as_slice());\n+            }\n+\n+            ty::ReStatic => {\n+                // Does the required lifetime have a nice name we can print?\n+                self.tcx.sess.span_err(\n+                    origin.span(),\n+                    format!(\n+                        \"the parameter type `{}` may not live long enough; \\\n+                         consider adding an explicit lifetime bound `{}:'static`...\",\n+                        param_ty.user_string(self.tcx),\n+                        param_ty.user_string(self.tcx)).as_slice());\n+            }\n+\n+            _ => {\n+                // If not, be less specific.\n+                self.tcx.sess.span_err(\n+                    origin.span(),\n+                    format!(\n+                        \"the parameter type `{}` may not live long enough; \\\n+                         consider adding an explicit lifetime bound to `{}`\",\n+                        param_ty.user_string(self.tcx),\n+                        param_ty.user_string(self.tcx)).as_slice());\n+                note_and_explain_region(\n+                    self.tcx,\n+                    format!(\"the parameter type `{}` must be valid for \",\n+                            param_ty.user_string(self.tcx)).as_slice(),\n+                    sub,\n+                    \"...\");\n+            }\n+        }\n+\n+        self.note_region_origin(&origin);\n+    }\n+\n     fn report_concrete_failure(&self,\n                                origin: SubregionOrigin,\n                                sub: Region,\n@@ -538,6 +608,67 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     sup,\n                     \"\");\n             }\n+            infer::RelateProcBound(span, var_node_id, ty) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\n+                        \"the type `{}` of captured variable `{}` \\\n+                         outlives the `proc()` it \\\n+                         is captured in\",\n+                        self.ty_to_string(ty),\n+                        ty::local_var_name_str(self.tcx,\n+                                               var_node_id)).as_slice());\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"`proc()` is valid for \",\n+                    sub,\n+                    \"\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    format!(\"the type `{}` is only valid for \",\n+                            self.ty_to_string(ty)).as_slice(),\n+                    sup,\n+                    \"\");\n+            }\n+            infer::RelateParamBound(span, param_ty, ty) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\"the type `{}` (provided as the value of \\\n+                             the parameter `{}`) does not fulfill the \\\n+                             required lifetime\",\n+                            self.ty_to_string(ty),\n+                            param_ty.user_string(self.tcx)).as_slice());\n+                note_and_explain_region(self.tcx,\n+                                        \"type must outlive \",\n+                                        sub,\n+                                        \"\");\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"declared lifetime bound not satisfied\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"lifetime parameter instantiated with \",\n+                    sup,\n+                    \"\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"but lifetime parameter must outlive \",\n+                    sub,\n+                    \"\");\n+            }\n+            infer::RelateDefaultParamBound(span, ty) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\"the type `{}` (provided as the value of \\\n+                             a type parameter) is not valid at this point\",\n+                            self.ty_to_string(ty)).as_slice());\n+                note_and_explain_region(self.tcx,\n+                                        \"type must outlive \",\n+                                        sub,\n+                                        \"\");\n+            }\n             infer::CallRcvr(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n@@ -593,6 +724,18 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     sup,\n                     \"\");\n             }\n+            infer::ExprTypeIsNotInScope(t, span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\"type of expression contains references \\\n+                             that are not valid during the expression: `{}`\",\n+                            self.ty_to_string(t)).as_slice());\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"type is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n@@ -606,9 +749,9 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"in type `{}`, pointer has a longer lifetime than \\\n-                          the data it references\",\n-                         ty.user_string(self.tcx)).as_slice());\n+                    format!(\"in type `{}`, reference has a longer lifetime \\\n+                             than the data it references\",\n+                            self.ty_to_string(ty)).as_slice());\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the pointer is valid for \",\n@@ -620,6 +763,11 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     sup,\n                     \"\");\n             }\n+            infer::Managed(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\"cannot put borrowed references into managed memory\").as_slice());\n+            }\n         }\n     }\n \n@@ -637,15 +785,15 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n             sup_region,\n             \"...\");\n \n-        self.note_region_origin(sup_origin);\n+        self.note_region_origin(&sup_origin);\n \n         note_and_explain_region(\n             self.tcx,\n             \"but, the lifetime must be valid for \",\n             sub_region,\n             \"...\");\n \n-        self.note_region_origin(sub_origin);\n+        self.note_region_origin(&sub_origin);\n     }\n \n     fn report_sup_sup_conflict(&self,\n@@ -662,15 +810,15 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n             region1,\n             \"...\");\n \n-        self.note_region_origin(origin1);\n+        self.note_region_origin(&origin1);\n \n         note_and_explain_region(\n             self.tcx,\n             \"but, the lifetime must also be contained by \",\n             region2,\n             \"...\");\n \n-        self.note_region_origin(origin2);\n+        self.note_region_origin(&origin2);\n     }\n \n     fn report_processed_errors(&self,\n@@ -920,8 +1068,12 @@ impl<'a> Rebuilder<'a> {\n                                -> OwnedSlice<ast::TyParamBound> {\n         ty_param_bounds.map(|tpb| {\n             match tpb {\n-                &ast::StaticRegionTyParamBound => ast::StaticRegionTyParamBound,\n-                &ast::OtherRegionTyParamBound(s) => ast::OtherRegionTyParamBound(s),\n+                &ast::RegionTyParamBound(lt) => {\n+                    // FIXME -- it's unclear whether I'm supposed to\n+                    // substitute lifetime here. I suspect we need to\n+                    // be passing down a map.\n+                    ast::RegionTyParamBound(lt)\n+                }\n                 &ast::UnboxedFnTyParamBound(unboxed_function_type) => {\n                     ast::UnboxedFnTyParamBound(unboxed_function_type)\n                 }\n@@ -1291,8 +1443,8 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                     var_description).as_slice());\n     }\n \n-    fn note_region_origin(&self, origin: SubregionOrigin) {\n-        match origin {\n+    fn note_region_origin(&self, origin: &SubregionOrigin) {\n+        match *origin {\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n                     infer::Misc(_) => {\n@@ -1384,8 +1536,16 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n             infer::RelateObjectBound(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    \"...so that source pointer does not outlive \\\n-                     lifetime bound of the object type\");\n+                    \"...so that it can be closed over into an object\");\n+            }\n+            infer::RelateProcBound(span, var_node_id, _ty) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\n+                        \"...so that the variable `{}` can be captured \\\n+                         into a proc\",\n+                        ty::local_var_name_str(self.tcx,\n+                                               var_node_id)).as_slice());\n             }\n             infer::CallRcvr(span) => {\n                 self.tcx.sess.span_note(\n@@ -1414,16 +1574,52 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                     \"...so that reference is valid \\\n                      at the time of implicit borrow\");\n             }\n+            infer::ExprTypeIsNotInScope(t, span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    format!(\"...so type `{}` of expression is valid during the \\\n+                             expression\",\n+                            self.ty_to_string(t)).as_slice());\n+            }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     \"...so that variable is valid at time of its declaration\");\n             }\n-            infer::ReferenceOutlivesReferent(_, span) => {\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    format!(\"...so that the reference type `{}` \\\n+                             does not outlive the data it points at\",\n+                            self.ty_to_string(ty)).as_slice());\n+            }\n+            infer::Managed(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that the value can be stored in managed memory.\");\n+            }\n+            infer::RelateParamBound(span, param_ty, t) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    format!(\"...so that the parameter `{}`, \\\n+                             when instantiated with `{}`, \\\n+                             will meet its declared lifetime bounds.\",\n+                            param_ty.user_string(self.tcx),\n+                            self.ty_to_string(t)).as_slice());\n+            }\n+            infer::RelateDefaultParamBound(span, t) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    format!(\"...so that type parameter \\\n+                             instantiated with `{}`, \\\n+                             will meet its declared lifetime bounds.\",\n+                            self.ty_to_string(t)).as_slice());\n+            }\n+            infer::RelateRegionParamBound(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    \"...so that the pointer does not outlive the \\\n-                    data it points at\");\n+                    format!(\"...so that the declared lifetime parameter bounds \\\n+                                are satisfied\").as_slice());\n             }\n         }\n     }"}, {"sha": "00eaa4d235b2e1ddf8e2d5cd0c2913648b7fa4be", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -96,7 +96,10 @@ impl<'f> Combine for Glb<'f> {\n         }\n     }\n \n-    fn bounds(&self, a: BuiltinBounds, b: BuiltinBounds) -> cres<BuiltinBounds> {\n+    fn builtin_bounds(&self,\n+                      a: ty::BuiltinBounds,\n+                      b: ty::BuiltinBounds)\n+                      -> cres<ty::BuiltinBounds> {\n         // More bounds is a subtype of fewer bounds, so\n         // the GLB (mutual subtype) is the union.\n         Ok(a.union(b))"}, {"sha": "8707efc622b6cfe625a7ac0dd515fe7ea040a14e", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -90,7 +90,10 @@ impl<'f> Combine for Lub<'f> {\n         }\n     }\n \n-    fn bounds(&self, a: BuiltinBounds, b: BuiltinBounds) -> cres<BuiltinBounds> {\n+    fn builtin_bounds(&self,\n+                      a: ty::BuiltinBounds,\n+                      b: ty::BuiltinBounds)\n+                      -> cres<ty::BuiltinBounds> {\n         // More bounds is a subtype of fewer bounds, so\n         // the LUB (mutual supertype) is the intersection.\n         Ok(a.intersection(b))"}, {"sha": "ed96effdd83dfecebcf9294c84e52577680fccdf", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 76, "deletions": 4, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -168,6 +168,22 @@ pub enum SubregionOrigin {\n     // relating `'a` to `'b`\n     RelateObjectBound(Span),\n \n+    // When closing over a variable in a closure/proc, ensure that the\n+    // type of the variable outlives the lifetime bound.\n+    RelateProcBound(Span, ast::NodeId, ty::t),\n+\n+    // The given type parameter was instantiated with the given type,\n+    // and that type must outlive some region.\n+    RelateParamBound(Span, ty::ParamTy, ty::t),\n+\n+    // The given region parameter was instantiated with a region\n+    // that must outlive some other region.\n+    RelateRegionParamBound(Span),\n+\n+    // A bound placed on type parameters that states that must outlive\n+    // the moment of their instantiation.\n+    RelateDefaultParamBound(Span, ty::t),\n+\n     // Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n \n@@ -177,6 +193,9 @@ pub enum SubregionOrigin {\n     // (&'a &'b T) where a >= b\n     ReferenceOutlivesReferent(ty::t, Span),\n \n+    // The type T of an expression E must outlive the lifetime for E.\n+    ExprTypeIsNotInScope(ty::t, Span),\n+\n     // A `ref b` whose region does not enclose the decl site\n     BindingTypeIsNotValidAtDecl(Span),\n \n@@ -194,6 +213,9 @@ pub enum SubregionOrigin {\n \n     // An auto-borrow that does not enclose the expr where it occurs\n     AutoBorrow(Span),\n+\n+    // Managed data cannot contain borrowed pointers.\n+    Managed(Span),\n }\n \n /// Reasons to create a region inference variable\n@@ -336,7 +358,6 @@ pub fn can_mk_subty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n }\n \n pub fn mk_subr(cx: &InferCtxt,\n-               _a_is_expected: bool,\n                origin: SubregionOrigin,\n                a: ty::Region,\n                b: ty::Region) {\n@@ -346,6 +367,18 @@ pub fn mk_subr(cx: &InferCtxt,\n     cx.region_vars.commit(snapshot);\n }\n \n+pub fn verify_param_bound(cx: &InferCtxt,\n+                          origin: SubregionOrigin,\n+                          param_ty: ty::ParamTy,\n+                          a: ty::Region,\n+                          bs: Vec<ty::Region>) {\n+    debug!(\"verify_param_bound({}, {} <: {})\",\n+           param_ty.repr(cx.tcx),\n+           a.repr(cx.tcx),\n+           bs.repr(cx.tcx));\n+\n+    cx.region_vars.verify_param_bound(origin, param_ty, a, bs);\n+}\n pub fn mk_eqty(cx: &InferCtxt,\n                a_is_expected: bool,\n                origin: TypeOrigin,\n@@ -589,6 +622,13 @@ impl<'a> InferCtxt<'a> {\n         self.rollback_to(snapshot);\n         r\n     }\n+\n+    pub fn add_given(&self,\n+                     sub: ty::FreeRegion,\n+                     sup: ty::RegionVid)\n+    {\n+        self.region_vars.add_given(sub, sup);\n+    }\n }\n \n impl<'a> InferCtxt<'a> {\n@@ -687,14 +727,13 @@ impl<'a> InferCtxt<'a> {\n     }\n \n     pub fn resolve_type_vars_in_trait_ref_if_possible(&self,\n-                                                      trait_ref:\n-                                                      &ty::TraitRef)\n+                                                      trait_ref: &ty::TraitRef)\n                                                       -> ty::TraitRef {\n         // make up a dummy type just to reuse/abuse the resolve machinery\n         let dummy0 = ty::mk_trait(self.tcx,\n                                   trait_ref.def_id,\n                                   trait_ref.substs.clone(),\n-                                  ty::empty_builtin_bounds());\n+                                  ty::region_existential_bound(ty::ReStatic));\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n         match ty::get(dummy1).sty {\n             ty::ty_trait(box ty::TyTrait { ref def_id, ref substs, .. }) => {\n@@ -896,15 +935,21 @@ impl SubregionOrigin {\n             FreeVariable(a, _) => a,\n             IndexSlice(a) => a,\n             RelateObjectBound(a) => a,\n+            RelateProcBound(a, _, _) => a,\n+            RelateParamBound(a, _, _) => a,\n+            RelateRegionParamBound(a) => a,\n+            RelateDefaultParamBound(a, _) => a,\n             Reborrow(a) => a,\n             ReborrowUpvar(a, _) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n+            ExprTypeIsNotInScope(_, a) => a,\n             BindingTypeIsNotValidAtDecl(a) => a,\n             CallRcvr(a) => a,\n             CallArg(a) => a,\n             CallReturn(a) => a,\n             AddrOf(a) => a,\n             AutoBorrow(a) => a,\n+            Managed(a) => a,\n         }\n     }\n }\n@@ -933,13 +978,39 @@ impl Repr for SubregionOrigin {\n             RelateObjectBound(a) => {\n                 format!(\"RelateObjectBound({})\", a.repr(tcx))\n             }\n+            RelateProcBound(a, b, c) => {\n+                format!(\"RelateProcBound({},{},{})\",\n+                        a.repr(tcx),\n+                        b,\n+                        c.repr(tcx))\n+            }\n+            RelateParamBound(a, b, c) => {\n+                format!(\"RelateParamBound({},{},{})\",\n+                        a.repr(tcx),\n+                        b.repr(tcx),\n+                        c.repr(tcx))\n+            }\n+            RelateRegionParamBound(a) => {\n+                format!(\"RelateRegionParamBound({})\",\n+                        a.repr(tcx))\n+            }\n+            RelateDefaultParamBound(a, b) => {\n+                format!(\"RelateDefaultParamBound({},{})\",\n+                        a.repr(tcx),\n+                        b.repr(tcx))\n+            }\n             Reborrow(a) => format!(\"Reborrow({})\", a.repr(tcx)),\n             ReborrowUpvar(a, b) => {\n                 format!(\"ReborrowUpvar({},{:?})\", a.repr(tcx), b)\n             }\n             ReferenceOutlivesReferent(_, a) => {\n                 format!(\"ReferenceOutlivesReferent({})\", a.repr(tcx))\n             }\n+            ExprTypeIsNotInScope(a, b) => {\n+                format!(\"ExprTypeIsNotInScope({}, {})\",\n+                        a.repr(tcx),\n+                        b.repr(tcx))\n+            }\n             BindingTypeIsNotValidAtDecl(a) => {\n                 format!(\"BindingTypeIsNotValidAtDecl({})\", a.repr(tcx))\n             }\n@@ -948,6 +1019,7 @@ impl Repr for SubregionOrigin {\n             CallReturn(a) => format!(\"CallReturn({})\", a.repr(tcx)),\n             AddrOf(a) => format!(\"AddrOf({})\", a.repr(tcx)),\n             AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr(tcx)),\n+            Managed(a) => format!(\"Managed({})\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "7c8d10dd9941644c8d7c485f72e5f044a17ae868", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 344, "deletions": 133, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -30,12 +30,32 @@ use syntax::ast;\n \n mod doc;\n \n+// A constraint that influences the inference process.\n #[deriving(PartialEq, Eq, Hash)]\n pub enum Constraint {\n+    // One region variable is subregion of another\n     ConstrainVarSubVar(RegionVid, RegionVid),\n+\n+    // Concrete region is subregion of region variable\n     ConstrainRegSubVar(Region, RegionVid),\n+\n+    // Region variable is subregion of concrete region\n     ConstrainVarSubReg(RegionVid, Region),\n-    ConstrainRegSubReg(Region, Region),\n+}\n+\n+// Something we have to verify after region inference is done, but\n+// which does not directly influence the inference process\n+pub enum Verify {\n+    // VerifyRegSubReg(a, b): Verify that `a <= b`. Neither `a` nor\n+    // `b` are inference variables.\n+    VerifyRegSubReg(SubregionOrigin, Region, Region),\n+\n+    // VerifyParamBound(T, _, R, RS): The parameter type `T` must\n+    // outlive the region `R`. `T` is known to outlive `RS`. Therefore\n+    // verify that `R <= RS[i]` for some `i`. Inference variables may\n+    // be involved (but this verification step doesn't influence\n+    // inference).\n+    VerifyParamBound(ty::ParamTy, SubregionOrigin, Region, Vec<Region>),\n }\n \n #[deriving(PartialEq, Eq, Hash)]\n@@ -51,6 +71,8 @@ pub enum UndoLogEntry {\n     Mark,\n     AddVar(RegionVid),\n     AddConstraint(Constraint),\n+    AddVerify(uint),\n+    AddGiven(ty::FreeRegion, ty::RegionVid),\n     AddCombination(CombineMapType, TwoRegions)\n }\n \n@@ -66,6 +88,13 @@ pub enum RegionResolutionError {\n     /// `o` requires that `a <= b`, but this does not hold\n     ConcreteFailure(SubregionOrigin, Region, Region),\n \n+    /// `ParamBoundFailure(p, s, a, bs)\n+    ///\n+    /// The parameter type `p` must be known to outlive the lifetime\n+    /// `a`, but it is only known to outlive `bs` (and none of the\n+    /// regions in `bs` outlive `a`).\n+    ParamBoundFailure(SubregionOrigin, ty::ParamTy, Region, Vec<Region>),\n+\n     /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n     /// Could not infer a value for `v` because `sub_r <= v` (due to\n@@ -125,7 +154,38 @@ pub type CombineMap = HashMap<TwoRegions, RegionVid>;\n pub struct RegionVarBindings<'a> {\n     tcx: &'a ty::ctxt,\n     var_origins: RefCell<Vec<RegionVariableOrigin>>,\n+\n+    // Constraints of the form `A <= B` introduced by the region\n+    // checker.  Here at least one of `A` and `B` must be a region\n+    // variable.\n     constraints: RefCell<HashMap<Constraint, SubregionOrigin>>,\n+\n+    // A \"verify\" is something that we need to verify after inference is\n+    // done, but which does not directly affect inference in any way.\n+    //\n+    // An example is a `A <= B` where neither `A` nor `B` are\n+    // inference variables.\n+    verifys: RefCell<Vec<Verify>>,\n+\n+    // A \"given\" is a relationship that is known to hold. In particular,\n+    // we often know from closure fn signatures that a particular free\n+    // region must be a subregion of a region variable:\n+    //\n+    //    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n+    //\n+    // In situations like this, `'b` is in fact a region variable\n+    // introduced by the call to `iter()`, and `'a` is a bound region\n+    // on the closure (as indicated by the `<'a>` prefix). If we are\n+    // naive, we wind up inferring that `'b` must be `'static`,\n+    // because we require that it be greater than `'a` and we do not\n+    // know what `'a` is precisely.\n+    //\n+    // This hashmap is used to avoid that naive scenario. Basically we\n+    // record the fact that `'a <= 'b` is implied by the fn signature,\n+    // and then ignore the constraint when solving equations. This is\n+    // a bit of a hack but seems to work.\n+    givens: RefCell<HashSet<(ty::FreeRegion, ty::RegionVid)>>,\n+\n     lubs: RefCell<CombineMap>,\n     glbs: RefCell<CombineMap>,\n     skolemization_count: Cell<uint>,\n@@ -164,6 +224,8 @@ impl<'a> RegionVarBindings<'a> {\n             var_origins: RefCell::new(Vec::new()),\n             values: RefCell::new(None),\n             constraints: RefCell::new(HashMap::new()),\n+            verifys: RefCell::new(Vec::new()),\n+            givens: RefCell::new(HashSet::new()),\n             lubs: RefCell::new(HashMap::new()),\n             glbs: RefCell::new(HashMap::new()),\n             skolemization_count: Cell::new(0),\n@@ -216,12 +278,19 @@ impl<'a> RegionVarBindings<'a> {\n                 Mark | CommitedSnapshot => { }\n                 AddVar(vid) => {\n                     let mut var_origins = self.var_origins.borrow_mut();\n-                    assert_eq!(var_origins.len(), vid.index + 1);\n                     var_origins.pop().unwrap();\n+                    assert_eq!(var_origins.len(), vid.index);\n                 }\n                 AddConstraint(ref constraint) => {\n                     self.constraints.borrow_mut().remove(constraint);\n                 }\n+                AddVerify(index) => {\n+                    self.verifys.borrow_mut().pop();\n+                    assert_eq!(self.verifys.borrow().len(), index);\n+                }\n+                AddGiven(sub, sup) => {\n+                    self.givens.borrow_mut().remove(&(sub, sup));\n+                }\n                 AddCombination(Glb, ref regions) => {\n                     self.glbs.borrow_mut().remove(regions);\n                 }\n@@ -289,13 +358,14 @@ impl<'a> RegionVarBindings<'a> {\n         self.values.borrow().is_none()\n     }\n \n-    pub fn add_constraint(&self,\n-                          constraint: Constraint,\n-                          origin: SubregionOrigin) {\n+    fn add_constraint(&self,\n+                      constraint: Constraint,\n+                      origin: SubregionOrigin) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n+        debug!(\"RegionVarBindings: add_constraint({})\",\n+               constraint.repr(self.tcx));\n \n         if self.constraints.borrow_mut().insert(constraint, origin) {\n             if self.in_snapshot() {\n@@ -304,6 +374,38 @@ impl<'a> RegionVarBindings<'a> {\n         }\n     }\n \n+    fn add_verify(&self,\n+                  verify: Verify) {\n+        // cannot add verifys once regions are resolved\n+        assert!(self.values_are_none());\n+\n+        debug!(\"RegionVarBindings: add_verify({})\",\n+               verify.repr(self.tcx));\n+\n+        let mut verifys = self.verifys.borrow_mut();\n+        let index = verifys.len();\n+        verifys.push(verify);\n+        if self.in_snapshot() {\n+            self.undo_log.borrow_mut().push(AddVerify(index));\n+        }\n+    }\n+\n+    pub fn add_given(&self,\n+                     sub: ty::FreeRegion,\n+                     sup: ty::RegionVid) {\n+        // cannot add givens once regions are resolved\n+        assert!(self.values_are_none());\n+\n+        let mut givens = self.givens.borrow_mut();\n+        if givens.insert((sub, sup)) {\n+            debug!(\"add_given({} <= {})\",\n+                   sub.repr(self.tcx),\n+                   sup);\n+\n+            self.undo_log.borrow_mut().push(AddGiven(sub, sup));\n+        }\n+    }\n+\n     pub fn make_subregion(&self,\n                           origin: SubregionOrigin,\n                           sub: Region,\n@@ -320,7 +422,9 @@ impl<'a> RegionVarBindings<'a> {\n           (ReEarlyBound(..), ReEarlyBound(..)) => {\n             // This case is used only to make sure that explicitly-specified\n             // `Self` types match the real self type in implementations.\n-            self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n+            //\n+            // FIXME(NDM) -- we really shouldn't be comparing bound things\n+            self.add_verify(VerifyRegSubReg(origin, sub, sup));\n           }\n           (ReEarlyBound(..), _) |\n           (ReLateBound(..), _) |\n@@ -345,11 +449,19 @@ impl<'a> RegionVarBindings<'a> {\n             self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n           }\n           _ => {\n-            self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n+            self.add_verify(VerifyRegSubReg(origin, sub, sup));\n           }\n         }\n     }\n \n+    pub fn verify_param_bound(&self,\n+                              origin: SubregionOrigin,\n+                              param_ty: ty::ParamTy,\n+                              sub: Region,\n+                              sups: Vec<Region>) {\n+        self.add_verify(VerifyParamBound(param_ty, origin, sub, sups));\n+    }\n+\n     pub fn lub_regions(&self,\n                        origin: SubregionOrigin,\n                        a: Region,\n@@ -358,7 +470,9 @@ impl<'a> RegionVarBindings<'a> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n+        debug!(\"RegionVarBindings: lub_regions({}, {})\",\n+               a.repr(self.tcx),\n+               b.repr(self.tcx));\n         match (a, b) {\n             (ReStatic, _) | (_, ReStatic) => {\n                 ReStatic // nothing lives longer than static\n@@ -381,7 +495,9 @@ impl<'a> RegionVarBindings<'a> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n+        debug!(\"RegionVarBindings: glb_regions({}, {})\",\n+               a.repr(self.tcx),\n+               b.repr(self.tcx));\n         match (a, b) {\n             (ReStatic, r) | (r, ReStatic) => {\n                 // static lives longer than everything else\n@@ -397,30 +513,29 @@ impl<'a> RegionVarBindings<'a> {\n         }\n     }\n \n+    pub fn max_regions(&self,\n+                       a: Region,\n+                       b: Region)\n+                       -> Option<Region>\n+    {\n+        match self.glb_concrete_regions(a, b) {\n+            Ok(r) => Some(r),\n+            Err(_) => None\n+        }\n+    }\n+\n     pub fn resolve_var(&self, rid: RegionVid) -> ty::Region {\n-        let v = match *self.values.borrow() {\n+        match *self.values.borrow() {\n             None => {\n                 self.tcx.sess.span_bug(\n                     self.var_origins.borrow().get(rid.index).span(),\n                     \"attempt to resolve region variable before values have \\\n                      been computed!\")\n             }\n-            Some(ref values) => *values.get(rid.index)\n-        };\n-\n-        debug!(\"RegionVarBindings: resolve_var({:?}={})={:?}\",\n-               rid, rid.index, v);\n-        match v {\n-            Value(r) => r,\n-\n-            NoValue => {\n-                // No constraints, return ty::ReEmpty\n-                ReEmpty\n-            }\n-\n-            ErrorValue => {\n-                // An error that has previously been reported.\n-                ReStatic\n+            Some(ref values) => {\n+                let r = lookup(values, rid);\n+                debug!(\"resolve_var({}) = {}\", rid, r.repr(self.tcx));\n+                r\n             }\n         }\n     }\n@@ -456,7 +571,7 @@ impl<'a> RegionVarBindings<'a> {\n         }\n         relate(self, a, ReInfer(ReVar(c)));\n         relate(self, b, ReInfer(ReVar(c)));\n-        debug!(\"combine_vars() c={:?}\", c);\n+        debug!(\"combine_vars() c={}\", c);\n         ReInfer(ReVar(c))\n     }\n \n@@ -493,40 +608,53 @@ impl<'a> RegionVarBindings<'a> {\n         while result_index < result_set.len() {\n             // nb: can't use uint::range() here because result_set grows\n             let r = *result_set.get(result_index);\n-            debug!(\"result_index={}, r={:?}\", result_index, r);\n+            debug!(\"result_index={}, r={}\", result_index, r);\n \n             for undo_entry in\n                 self.undo_log.borrow().slice_from(mark.length).iter()\n             {\n-                let regs = match undo_entry {\n-                    &AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n-                        Some((ReInfer(ReVar(*a)), ReInfer(ReVar(*b))))\n+                match undo_entry {\n+                    &AddConstraint(ConstrainVarSubVar(a, b)) => {\n+                        consider_adding_bidirectional_edges(\n+                            &mut result_set, r,\n+                            ReInfer(ReVar(a)), ReInfer(ReVar(b)));\n+                    }\n+                    &AddConstraint(ConstrainRegSubVar(a, b)) => {\n+                        consider_adding_bidirectional_edges(\n+                            &mut result_set, r,\n+                            a, ReInfer(ReVar(b)));\n                     }\n-                    &AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n-                        Some((*a, ReInfer(ReVar(*b))))\n+                    &AddConstraint(ConstrainVarSubReg(a, b)) => {\n+                        consider_adding_bidirectional_edges(\n+                            &mut result_set, r,\n+                            ReInfer(ReVar(a)), b);\n                     }\n-                    &AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n-                        Some((ReInfer(ReVar(*a)), *b))\n+                    &AddGiven(a, b) => {\n+                        consider_adding_bidirectional_edges(\n+                            &mut result_set, r,\n+                            ReFree(a), ReInfer(ReVar(b)));\n                     }\n-                    &AddConstraint(ConstrainRegSubReg(a, b)) => {\n-                        Some((a, b))\n+                    &AddVerify(i) => {\n+                        match self.verifys.borrow().get(i) {\n+                            &VerifyRegSubReg(_, a, b) => {\n+                                consider_adding_bidirectional_edges(\n+                                    &mut result_set, r,\n+                                    a, b);\n+                            }\n+                            &VerifyParamBound(_, _, a, ref bs) => {\n+                                for &b in bs.iter() {\n+                                    consider_adding_bidirectional_edges(\n+                                        &mut result_set, r,\n+                                        a, b);\n+                                }\n+                            }\n+                        }\n                     }\n                     &AddCombination(..) |\n                     &Mark |\n                     &AddVar(..) |\n                     &OpenSnapshot |\n                     &CommitedSnapshot => {\n-                        None\n-                    }\n-                };\n-\n-                match regs {\n-                    None => {}\n-                    Some((r1, r2)) => {\n-                        result_set =\n-                            consider_adding_edge(result_set, r, r1, r2);\n-                        result_set =\n-                            consider_adding_edge(result_set, r, r2, r1);\n                     }\n                 }\n             }\n@@ -536,17 +664,24 @@ impl<'a> RegionVarBindings<'a> {\n \n         return result_set;\n \n-        fn consider_adding_edge(result_set: Vec<Region> ,\n-                                r: Region,\n-                                r1: Region,\n-                                r2: Region) -> Vec<Region> {\n-            let mut result_set = result_set;\n-            if r == r1 { // Clearly, this is potentially inefficient.\n+        fn consider_adding_bidirectional_edges(result_set: &mut Vec<Region>,\n+                                               r: Region,\n+                                               r1: Region,\n+                                               r2: Region) {\n+            consider_adding_directed_edge(result_set, r, r1, r2);\n+            consider_adding_directed_edge(result_set, r, r2, r1);\n+        }\n+\n+        fn consider_adding_directed_edge(result_set: &mut Vec<Region>,\n+                                         r: Region,\n+                                         r1: Region,\n+                                         r2: Region) {\n+            if r == r1 {\n+                // Clearly, this is potentially inefficient.\n                 if !result_set.iter().any(|x| *x == r2) {\n                     result_set.push(r2);\n                 }\n             }\n-            return result_set;\n         }\n     }\n \n@@ -595,7 +730,7 @@ impl<'a> RegionVarBindings<'a> {\n             self.tcx.sess.span_bug(\n                 self.var_origins.borrow().get(v_id.index).span(),\n                 format!(\"lub_concrete_regions invoked with \\\n-                         non-concrete regions: {:?}, {:?}\",\n+                         non-concrete regions: {}, {}\",\n                         a,\n                         b).as_slice());\n           }\n@@ -675,7 +810,7 @@ impl<'a> RegionVarBindings<'a> {\n                             a: Region,\n                             b: Region)\n                          -> cres<Region> {\n-        debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n+        debug!(\"glb_concrete_regions({}, {})\", a, b);\n         match (a, b) {\n             (ReLateBound(..), _) |\n             (_, ReLateBound(..)) |\n@@ -702,7 +837,7 @@ impl<'a> RegionVarBindings<'a> {\n                 self.tcx.sess.span_bug(\n                     self.var_origins.borrow().get(v_id.index).span(),\n                     format!(\"glb_concrete_regions invoked with \\\n-                             non-concrete regions: {:?}, {:?}\",\n+                             non-concrete regions: {}, {}\",\n                             a,\n                             b).as_slice());\n             }\n@@ -783,7 +918,7 @@ impl<'a> RegionVarBindings<'a> {\n         // scopes or two free regions.  So, if one of\n         // these scopes is a subscope of the other, return\n         // it.  Otherwise fail.\n-        debug!(\"intersect_scopes(scope_a={:?}, scope_b={:?}, region_a={:?}, region_b={:?})\",\n+        debug!(\"intersect_scopes(scope_a={}, scope_b={}, region_a={}, region_b={})\",\n                scope_a, scope_b, region_a, region_b);\n         match self.tcx.region_maps.nearest_common_ancestor(scope_a, scope_b) {\n             Some(r_id) if scope_a == r_id => Ok(ReScope(scope_b)),\n@@ -815,12 +950,16 @@ type RegionGraph = graph::Graph<(), Constraint>;\n impl<'a> RegionVarBindings<'a> {\n     fn infer_variable_values(&self,\n                              errors: &mut Vec<RegionResolutionError>)\n-                             -> Vec<VarValue> {\n+                             -> Vec<VarValue>\n+    {\n         let mut var_data = self.construct_var_data();\n         self.expansion(var_data.as_mut_slice());\n         self.contraction(var_data.as_mut_slice());\n-        self.collect_concrete_region_errors(&mut *errors);\n-        self.extract_values_and_collect_conflicts(var_data.as_slice(), errors)\n+        let values =\n+            self.extract_values_and_collect_conflicts(var_data.as_slice(),\n+                                                      errors);\n+        self.collect_concrete_region_errors(&values, errors);\n+        values\n     }\n \n     fn construct_var_data(&self) -> Vec<VarData> {\n@@ -838,6 +977,12 @@ impl<'a> RegionVarBindings<'a> {\n \n     fn expansion(&self, var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n+            debug!(\"expansion: constraint={} origin={}\",\n+                   constraint.repr(self.tcx),\n+                   self.constraints.borrow()\n+                                   .find(constraint)\n+                                   .unwrap()\n+                                   .repr(self.tcx));\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n                 let b_data = &mut var_data[b_vid.index];\n@@ -856,10 +1001,6 @@ impl<'a> RegionVarBindings<'a> {\n                 // This is a contraction constraint.  Ignore it.\n                 false\n               }\n-              ConstrainRegSubReg(..) => {\n-                // No region variables involved. Ignore.\n-                false\n-              }\n             }\n         })\n     }\n@@ -868,14 +1009,29 @@ impl<'a> RegionVarBindings<'a> {\n                    a_region: Region,\n                    b_vid: RegionVid,\n                    b_data: &mut VarData)\n-                   -> bool {\n-        debug!(\"expand_node({:?}, {:?} == {:?})\",\n-               a_region, b_vid, b_data.value);\n+                   -> bool\n+    {\n+        debug!(\"expand_node({}, {} == {})\",\n+               a_region.repr(self.tcx),\n+               b_vid,\n+               b_data.value.repr(self.tcx));\n+\n+        // Check if this relationship is implied by a given.\n+        match a_region {\n+            ty::ReFree(fr) => {\n+                if self.givens.borrow().contains(&(fr, b_vid)) {\n+                    debug!(\"given\");\n+                    return false;\n+                }\n+            }\n+            _ => { }\n+        }\n \n         b_data.classification = Expanding;\n         match b_data.value {\n           NoValue => {\n-            debug!(\"Setting initial value of {:?} to {:?}\", b_vid, a_region);\n+            debug!(\"Setting initial value of {} to {}\",\n+                   b_vid, a_region.repr(self.tcx));\n \n             b_data.value = Value(a_region);\n             return true;\n@@ -887,8 +1043,10 @@ impl<'a> RegionVarBindings<'a> {\n                 return false;\n             }\n \n-            debug!(\"Expanding value of {:?} from {:?} to {:?}\",\n-                   b_vid, cur_region, lub);\n+            debug!(\"Expanding value of {} from {} to {}\",\n+                   b_vid,\n+                   cur_region.repr(self.tcx),\n+                   lub.repr(self.tcx));\n \n             b_data.value = Value(lub);\n             return true;\n@@ -903,6 +1061,12 @@ impl<'a> RegionVarBindings<'a> {\n     fn contraction(&self,\n                    var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Contraction\", |constraint| {\n+            debug!(\"contraction: constraint={} origin={}\",\n+                   constraint.repr(self.tcx),\n+                   self.constraints.borrow()\n+                                   .find(constraint)\n+                                   .unwrap()\n+                                   .repr(self.tcx));\n             match *constraint {\n               ConstrainRegSubVar(..) => {\n                 // This is an expansion constraint.  Ignore.\n@@ -921,10 +1085,6 @@ impl<'a> RegionVarBindings<'a> {\n                 let a_data = &mut var_data[a_vid.index];\n                 self.contract_node(a_vid, a_data, b_region)\n               }\n-              ConstrainRegSubReg(..) => {\n-                // No region variables involved. Ignore.\n-                false\n-              }\n             }\n         })\n     }\n@@ -934,8 +1094,9 @@ impl<'a> RegionVarBindings<'a> {\n                      a_data: &mut VarData,\n                      b_region: Region)\n                      -> bool {\n-        debug!(\"contract_node({:?} == {:?}/{:?}, {:?})\",\n-               a_vid, a_data.value, a_data.classification, b_region);\n+        debug!(\"contract_node({} == {}/{}, {})\",\n+               a_vid, a_data.value.repr(self.tcx),\n+               a_data.classification, b_region.repr(self.tcx));\n \n         return match a_data.value {\n             NoValue => {\n@@ -967,8 +1128,10 @@ impl<'a> RegionVarBindings<'a> {\n                       b_region: Region)\n                    -> bool {\n             if !this.is_subregion_of(a_region, b_region) {\n-                debug!(\"Setting {:?} to ErrorValue: {:?} not subregion of {:?}\",\n-                       a_vid, a_region, b_region);\n+                debug!(\"Setting {} to ErrorValue: {} not subregion of {}\",\n+                       a_vid,\n+                       a_region.repr(this.tcx),\n+                       b_region.repr(this.tcx));\n                 a_data.value = ErrorValue;\n             }\n             false\n@@ -985,54 +1148,73 @@ impl<'a> RegionVarBindings<'a> {\n                     if glb == a_region {\n                         false\n                     } else {\n-                        debug!(\"Contracting value of {:?} from {:?} to {:?}\",\n-                               a_vid, a_region, glb);\n+                        debug!(\"Contracting value of {} from {} to {}\",\n+                               a_vid,\n+                               a_region.repr(this.tcx),\n+                               glb.repr(this.tcx));\n                         a_data.value = Value(glb);\n                         true\n                     }\n                 }\n                 Err(_) => {\n-                    debug!(\"Setting {:?} to ErrorValue: no glb of {:?}, {:?}\",\n-                           a_vid, a_region, b_region);\n+                    debug!(\"Setting {} to ErrorValue: no glb of {}, {}\",\n+                           a_vid,\n+                           a_region.repr(this.tcx),\n+                           b_region.repr(this.tcx));\n                     a_data.value = ErrorValue;\n                     false\n                 }\n             }\n         }\n     }\n \n-    fn collect_concrete_region_errors(\n-        &self,\n-        errors: &mut Vec<RegionResolutionError>)\n+    fn collect_concrete_region_errors(&self,\n+                                      values: &Vec<VarValue>,\n+                                      errors: &mut Vec<RegionResolutionError>)\n     {\n-        for (constraint, _) in self.constraints.borrow().iter() {\n-            let (sub, sup) = match *constraint {\n-                ConstrainVarSubVar(..) |\n-                ConstrainRegSubVar(..) |\n-                ConstrainVarSubReg(..) => {\n-                    continue;\n-                }\n-                ConstrainRegSubReg(sub, sup) => {\n-                    (sub, sup)\n+        let mut reg_reg_dups = HashSet::new();\n+        for verify in self.verifys.borrow().iter() {\n+            match *verify {\n+                VerifyRegSubReg(ref origin, sub, sup) => {\n+                    if self.is_subregion_of(sub, sup) {\n+                        continue;\n+                    }\n+\n+                    if !reg_reg_dups.insert((sub, sup)) {\n+                        continue;\n+                    }\n+\n+                    debug!(\"ConcreteFailure: !(sub <= sup): sub={}, sup={}\",\n+                           sub.repr(self.tcx),\n+                           sup.repr(self.tcx));\n+                    errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n                 }\n-            };\n \n-            if self.is_subregion_of(sub, sup) {\n-                continue;\n-            }\n+                VerifyParamBound(ref param_ty, ref origin, sub, ref sups) => {\n+                    let sub = normalize(values, sub);\n+                    if sups.iter()\n+                           .map(|&sup| normalize(values, sup))\n+                           .any(|sup| self.is_subregion_of(sub, sup))\n+                    {\n+                        continue;\n+                    }\n \n-            debug!(\"ConcreteFailure: !(sub <= sup): sub={:?}, sup={:?}\",\n-                   sub, sup);\n-            let origin = self.constraints.borrow().get_copy(constraint);\n-            errors.push(ConcreteFailure(origin, sub, sup));\n+                    let sups = sups.iter().map(|&sup| normalize(values, sup))\n+                                          .collect();\n+                    errors.push(\n+                        ParamBoundFailure(\n+                            (*origin).clone(), *param_ty, sub, sups));\n+                }\n+            }\n         }\n     }\n \n     fn extract_values_and_collect_conflicts(\n         &self,\n         var_data: &[VarData],\n         errors: &mut Vec<RegionResolutionError>)\n-        -> Vec<VarValue> {\n+        -> Vec<VarValue>\n+    {\n         debug!(\"extract_values_and_collect_conflicts()\");\n \n         // This is the best way that I have found to suppress\n@@ -1141,10 +1323,6 @@ impl<'a> RegionVarBindings<'a> {\n                                    dummy_idx,\n                                    *constraint);\n                 }\n-                ConstrainRegSubReg(..) => {\n-                    // Relations between two concrete regions do not\n-                    // require an edge in the graph.\n-                }\n             }\n         }\n \n@@ -1206,16 +1384,10 @@ impl<'a> RegionVarBindings<'a> {\n         self.tcx.sess.span_bug(\n             self.var_origins.borrow().get(node_idx.index).span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n-                  for var {:?}, lower_bounds={}, upper_bounds={}\",\n-                 node_idx,\n-                 lower_bounds.iter()\n-                             .map(|x| x.region)\n-                             .collect::<Vec<ty::Region>>()\n-                             .repr(self.tcx),\n-                 upper_bounds.iter()\n-                             .map(|x| x.region)\n-                             .collect::<Vec<ty::Region>>()\n-                             .repr(self.tcx)).as_slice());\n+                    for var {}, lower_bounds={}, upper_bounds={}\",\n+                    node_idx,\n+                    lower_bounds.repr(self.tcx),\n+                    upper_bounds.repr(self.tcx)).as_slice());\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1257,12 +1429,9 @@ impl<'a> RegionVarBindings<'a> {\n         self.tcx.sess.span_bug(\n             self.var_origins.borrow().get(node_idx.index).span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n-                  for var {:?}, upper_bounds={}\",\n-                 node_idx,\n-                 upper_bounds.iter()\n-                             .map(|x| x.region)\n-                             .collect::<Vec<ty::Region>>()\n-                             .repr(self.tcx)).as_slice());\n+                     for var {}, upper_bounds={}\",\n+                    node_idx,\n+                    upper_bounds.repr(self.tcx)).as_slice());\n     }\n \n     fn collect_concrete_regions(&self,\n@@ -1301,8 +1470,8 @@ impl<'a> RegionVarBindings<'a> {\n                 state.dup_found = true;\n             }\n \n-            debug!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?}, \\\n-                    classification={:?})\",\n+            debug!(\"collect_concrete_regions(orig_node_idx={}, node_idx={}, \\\n+                    classification={})\",\n                    orig_node_idx, node_idx, classification);\n \n             // figure out the direction from which this node takes its\n@@ -1323,7 +1492,7 @@ impl<'a> RegionVarBindings<'a> {\n                          graph: &RegionGraph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n-            debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n+            debug!(\"process_edges(source_vid={}, dir={})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.index);\n             graph.each_adjacent_edge(source_node_index, dir, |_, edge| {\n@@ -1343,8 +1512,6 @@ impl<'a> RegionVarBindings<'a> {\n                             origin: this.constraints.borrow().get_copy(&edge.data)\n                         });\n                     }\n-\n-                    ConstrainRegSubReg(..) => {}\n                 }\n                 true\n             });\n@@ -1386,9 +1553,53 @@ impl Repr for Constraint {\n             ConstrainVarSubReg(a, b) => {\n                 format!(\"ConstrainVarSubReg({}, {})\", a.repr(tcx), b.repr(tcx))\n             }\n-            ConstrainRegSubReg(a, b) => {\n-                format!(\"ConstrainRegSubReg({}, {})\", a.repr(tcx), b.repr(tcx))\n+        }\n+    }\n+}\n+\n+impl Repr for Verify {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            VerifyRegSubReg(_, ref a, ref b) => {\n+                format!(\"VerifyRegSubReg({}, {})\", a.repr(tcx), b.repr(tcx))\n+            }\n+            VerifyParamBound(_, ref p, ref a, ref bs) => {\n+                format!(\"VerifyParamBound({}, {}, {})\",\n+                        p.repr(tcx), a.repr(tcx), bs.repr(tcx))\n             }\n         }\n     }\n }\n+\n+fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n+    match r {\n+        ty::ReInfer(ReVar(rid)) => lookup(values, rid),\n+        _ => r\n+    }\n+}\n+\n+fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n+    match *values.get(rid.index) {\n+        Value(r) => r,\n+        NoValue => ReEmpty, // No constraints, return ty::ReEmpty\n+        ErrorValue => ReStatic, // Previously reported error.\n+    }\n+}\n+\n+impl Repr for VarValue {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            NoValue => format!(\"NoValue\"),\n+            Value(r) => format!(\"Value({})\", r.repr(tcx)),\n+            ErrorValue => format!(\"ErrorValue\"),\n+        }\n+    }\n+}\n+\n+impl Repr for RegionAndOrigin {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"RegionAndOrigin({},{})\",\n+                self.region.repr(tcx),\n+                self.origin.repr(tcx))\n+    }\n+}"}, {"sha": "a9e8d1e860333cc9253247451f4f6add05dac5d2", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -102,7 +102,8 @@ impl<'f> Combine for Sub<'f> {\n         })\n     }\n \n-    fn bounds(&self, a: BuiltinBounds, b: BuiltinBounds) -> cres<BuiltinBounds> {\n+    fn builtin_bounds(&self, a: BuiltinBounds, b: BuiltinBounds)\n+                      -> cres<BuiltinBounds> {\n         // More bounds is a subtype of fewer bounds.\n         //\n         // e.g., fn:Copy() <: fn(), because the former is a function"}, {"sha": "33bdded52341f304b7f8a3716f57de9388edf9d8", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -555,3 +555,12 @@ impl SimplyUnifiable for ast::FloatTy {\n         return ty::terr_float_mismatch(err);\n     }\n }\n+\n+impl<K:Repr,V:Repr> Repr for VarValue<K,V> {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            Redirect(ref k) => format!(\"Redirect({})\", k.repr(tcx)),\n+            Root(ref v, r) => format!(\"Root({}, {})\", v.repr(tcx), r)\n+        }\n+    }\n+}"}, {"sha": "530f65855d42c90dd5361ff8fa9d890872f82199", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -30,12 +30,19 @@ pub trait RegionScope {\n                     span: Span,\n                     count: uint)\n                     -> Result<Vec<ty::Region> , ()>;\n+\n+    fn default_region_bound(&self, span: Span) -> Option<ty::Region>;\n }\n \n-// A scope in which all regions must be explicitly named\n+// A scope in which all regions must be explicitly named. This is used\n+// for types that appear in structs and so on.\n pub struct ExplicitRscope;\n \n impl RegionScope for ExplicitRscope {\n+    fn default_region_bound(&self, _span: Span) -> Option<ty::Region> {\n+        None\n+    }\n+\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: uint)\n@@ -44,6 +51,33 @@ impl RegionScope for ExplicitRscope {\n     }\n }\n \n+// A scope in which any omitted region defaults to `default`. This is\n+// used after the `->` in function signatures, but also for backwards\n+// compatibility with object types. The latter use may go away.\n+pub struct SpecificRscope {\n+    default: ty::Region\n+}\n+\n+impl SpecificRscope {\n+    pub fn new(r: ty::Region) -> SpecificRscope {\n+        SpecificRscope { default: r }\n+    }\n+}\n+\n+impl RegionScope for SpecificRscope {\n+    fn default_region_bound(&self, _span: Span) -> Option<ty::Region> {\n+        Some(self.default)\n+    }\n+\n+    fn anon_regions(&self,\n+                    _span: Span,\n+                    count: uint)\n+                    -> Result<Vec<ty::Region> , ()>\n+    {\n+        Ok(Vec::from_elem(count, self.default))\n+    }\n+}\n+\n /// A scope in which we generate anonymous, late-bound regions for\n /// omitted regions. This occurs in function signatures.\n pub struct BindingRscope {\n@@ -58,30 +92,26 @@ impl BindingRscope {\n             anon_bindings: Cell::new(0),\n         }\n     }\n-}\n \n-impl RegionScope for BindingRscope {\n-    fn anon_regions(&self,\n-                    _: Span,\n-                    count: uint)\n-                    -> Result<Vec<ty::Region>, ()> {\n+    fn next_region(&self) -> ty::Region {\n         let idx = self.anon_bindings.get();\n-        self.anon_bindings.set(idx + count);\n-        Ok(Vec::from_fn(count, |i| ty::ReLateBound(self.binder_id,\n-                                                   ty::BrAnon(idx + i))))\n+        self.anon_bindings.set(idx + 1);\n+        ty::ReLateBound(self.binder_id, ty::BrAnon(idx))\n     }\n }\n \n-/// A scope in which we generate one specific region. This occurs after the\n-/// `->` (i.e. in the return type) of function signatures.\n-pub struct ImpliedSingleRscope {\n-    pub region: ty::Region,\n-}\n+impl RegionScope for BindingRscope {\n+    fn default_region_bound(&self, _span: Span) -> Option<ty::Region>\n+    {\n+        Some(self.next_region())\n+    }\n \n-impl RegionScope for ImpliedSingleRscope {\n-    fn anon_regions(&self, _: Span, count: uint)\n-                    -> Result<Vec<ty::Region>,()> {\n-        Ok(Vec::from_elem(count, self.region.clone()))\n+    fn anon_regions(&self,\n+                    _: Span,\n+                    count: uint)\n+                    -> Result<Vec<ty::Region> , ()>\n+    {\n+        Ok(Vec::from_fn(count, |_| self.next_region()))\n     }\n }\n "}, {"sha": "61ef9df99e86d364edab6734b553e2aac1cee1e7", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -10,6 +10,8 @@\n \n #![allow(non_camel_case_types)]\n \n+use std::hash::{Hash, Hasher};\n+use std::collections::HashMap;\n use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -105,3 +107,51 @@ pub fn block_query(b: ast::P<ast::Block>, p: |&ast::Expr| -> bool) -> bool {\n     visit::walk_block(&mut v, &*b, ());\n     return v.flag;\n }\n+\n+// K: Eq + Hash<S>, V, S, H: Hasher<S>\n+pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n+    edges_map: &HashMap<T,Vec<T>,H>,\n+    source: T,\n+    destination: T)\n+    -> bool\n+{\n+    /*!\n+     * Determines whether there exists a path from `source` to\n+     * `destination`.  The graph is defined by the `edges_map`, which\n+     * maps from a node `S` to a list of its adjacent nodes `T`.\n+     *\n+     * Efficiency note: This is implemented in an inefficient way\n+     * because it is typically invoked on very small graphs. If the graphs\n+     * become larger, a more efficient graph representation and algorithm\n+     * would probably be advised.\n+     */\n+\n+    if source == destination {\n+        return true;\n+    }\n+\n+    // Do a little breadth-first-search here.  The `queue` list\n+    // doubles as a way to detect if we've seen a particular FR\n+    // before.  Note that we expect this graph to be an *extremely\n+    // shallow* tree.\n+    let mut queue = vec!(source);\n+    let mut i = 0;\n+    while i < queue.len() {\n+        match edges_map.find(queue.get(i)) {\n+            Some(edges) => {\n+                for target in edges.iter() {\n+                    if *target == destination {\n+                        return true;\n+                    }\n+\n+                    if !queue.iter().any(|x| x == target) {\n+                        queue.push((*target).clone());\n+                    }\n+                }\n+            }\n+            None => {}\n+        }\n+        i += 1;\n+    }\n+    return false;\n+}"}, {"sha": "11f16f1ea9511f9ffd297a26373474aa0ec4a34d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 207, "deletions": 86, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -23,11 +23,9 @@ use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n use middle::ty::{ty_unboxed_closure};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n-use middle::typeck::infer::region_inference;\n-use middle::typeck::infer::unify::VarValue as VV;\n-use middle::typeck::infer::unify;\n-use middle::typeck::infer;\n use middle::typeck;\n+use middle::typeck::check::regionmanip;\n+use middle::typeck::infer;\n \n use std::gc::Gc;\n use std::rc::Rc;\n@@ -66,6 +64,22 @@ pub fn note_and_explain_region(cx: &ctxt,\n     }\n }\n \n+fn item_scope_tag(item: &ast::Item) -> &'static str {\n+    /*!\n+     * When a free region is associated with `item`, how should we describe\n+     * the item in the error message.\n+     */\n+\n+    match item.node {\n+        ast::ItemImpl(..) => \"impl\",\n+        ast::ItemStruct(..) => \"struct\",\n+        ast::ItemEnum(..) => \"enum\",\n+        ast::ItemTrait(..) => \"trait\",\n+        ast::ItemFn(..) => \"function body\",\n+        _ => \"item\"\n+    }\n+}\n+\n pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n                             -> (String, Option<Span>) {\n     return match region {\n@@ -87,9 +101,9 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           Some(ast_map::NodeStmt(stmt)) => {\n               explain_span(cx, \"statement\", stmt.span)\n           }\n-          Some(ast_map::NodeItem(it)) if (match it.node {\n-                ast::ItemFn(..) => true, _ => false}) => {\n-              explain_span(cx, \"function body\", it.span)\n+          Some(ast_map::NodeItem(it)) => {\n+              let tag = item_scope_tag(&*it);\n+              explain_span(cx, tag, it.span)\n           }\n           Some(_) | None => {\n             // this really should not happen\n@@ -112,17 +126,17 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n \n         match cx.map.find(fr.scope_id) {\n           Some(ast_map::NodeBlock(ref blk)) => {\n-            let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n-            (format!(\"{} {}\", prefix, msg), opt_span)\n+              let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n+              (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n-          Some(ast_map::NodeItem(it)) if match it.node {\n-                ast::ItemImpl(..) => true, _ => false} => {\n-            let (msg, opt_span) = explain_span(cx, \"impl\", it.span);\n-            (format!(\"{} {}\", prefix, msg), opt_span)\n+          Some(ast_map::NodeItem(it)) => {\n+              let tag = item_scope_tag(&*it);\n+              let (msg, opt_span) = explain_span(cx, tag, it.span);\n+              (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n           Some(_) | None => {\n-            // this really should not happen\n-            (format!(\"{} node {}\", prefix, fr.scope_id), None)\n+              // this really should not happen\n+              (format!(\"{} node {}\", prefix, fr.scope_id), None)\n           }\n         }\n       }\n@@ -143,7 +157,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n     };\n \n     fn explain_span(cx: &ctxt, heading: &str, span: Span)\n-        -> (String, Option<Span>) {\n+                    -> (String, Option<Span>) {\n         let lo = cx.sess.codemap().lookup_char_pos_adj(span.lo);\n         (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_uint()),\n          Some(span))\n@@ -273,7 +287,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n             _ => { }\n         }\n \n-        push_sig_to_string(cx, &mut s, '(', ')', sig);\n+        push_sig_to_string(cx, &mut s, '(', ')', sig, \"\");\n \n         s\n     }\n@@ -296,34 +310,34 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n             }\n         };\n \n+        let bounds_str = cty.bounds.user_string(cx);\n+\n         match cty.store {\n             ty::UniqTraitStore => {\n                 assert_eq!(cty.onceness, ast::Once);\n                 s.push_str(\"proc\");\n-                push_sig_to_string(cx, &mut s, '(', ')', &cty.sig);\n+                push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n+                                   bounds_str.as_slice());\n             }\n             ty::RegionTraitStore(..) => {\n                 match cty.onceness {\n                     ast::Many => {}\n                     ast::Once => s.push_str(\"once \")\n                 }\n-                push_sig_to_string(cx, &mut s, '|', '|', &cty.sig);\n+                push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n+                                   bounds_str.as_slice());\n             }\n         }\n \n-        if !cty.bounds.is_empty() {\n-            s.push_str(\":\");\n-            s.push_str(cty.bounds.repr(cx).as_slice());\n-        }\n-\n-        s\n+        s.into_owned()\n     }\n \n     fn push_sig_to_string(cx: &ctxt,\n                        s: &mut String,\n                        bra: char,\n                        ket: char,\n-                       sig: &ty::FnSig) {\n+                       sig: &ty::FnSig,\n+                       bounds: &str) {\n         s.push_char(bra);\n         let strs: Vec<String> = sig.inputs.iter().map(|a| fn_input_to_string(cx, *a)).collect();\n         s.push_str(strs.connect(\", \").as_slice());\n@@ -332,6 +346,11 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         }\n         s.push_char(ket);\n \n+        if !bounds.is_empty() {\n+            s.push_str(\":\");\n+            s.push_str(bounds);\n+        }\n+\n         if ty::get(sig.output).sty != ty_nil {\n             s.push_str(\" -> \");\n             if ty::type_is_bot(sig.output) {\n@@ -383,18 +402,8 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n       }\n       ty_infer(infer_ty) => infer_ty.to_string(),\n       ty_err => \"[type error]\".to_string(),\n-      ty_param(ParamTy {idx: id, def_id: did, ..}) => {\n-          let ident = match cx.ty_param_defs.borrow().find(&did.node) {\n-              Some(def) => token::get_ident(def.ident).get().to_string(),\n-              // This can only happen when a type mismatch error happens and\n-              // the actual type has more type parameters than the expected one.\n-              None => format!(\"<generic #{}>\", id),\n-          };\n-          if !cx.sess.verbose() {\n-              ident\n-          } else {\n-              format!(\"{}:{:?}\", ident, did)\n-          }\n+      ty_param(ref param_ty) => {\n+          param_ty.repr(cx)\n       }\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n           let base = ty::item_path_str(cx, did);\n@@ -408,8 +417,8 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n           let trait_def = ty::lookup_trait_def(cx, did);\n           let ty = parameterized(cx, base.as_slice(),\n                                  substs, &trait_def.generics);\n-          let bound_sep = if bounds.is_empty() { \"\" } else { \"+\" };\n-          let bound_str = bounds.repr(cx);\n+          let bound_str = bounds.user_string(cx);\n+          let bound_sep = if bound_str.is_empty() { \"\" } else { \"+\" };\n           format!(\"{}{}{}\",\n                   ty,\n                   bound_sep,\n@@ -573,6 +582,14 @@ impl<T:Repr> Repr for Vec<T> {\n     }\n }\n \n+impl<T:UserString> UserString for Vec<T> {\n+    fn user_string(&self, tcx: &ctxt) -> String {\n+        let strs: Vec<String> =\n+            self.iter().map(|t| t.user_string(tcx)).collect();\n+        strs.connect(\", \")\n+    }\n+}\n+\n impl Repr for def::Def {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{:?}\", *self)\n@@ -581,16 +598,18 @@ impl Repr for def::Def {\n \n impl Repr for ty::TypeParameterDef {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"TypeParameterDef({:?}, {})\", self.def_id,\n+        format!(\"TypeParameterDef({}, {})\",\n+                self.def_id.repr(tcx),\n                 self.bounds.repr(tcx))\n     }\n }\n \n impl Repr for ty::RegionParameterDef {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"RegionParameterDef({}, {:?})\",\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"RegionParameterDef(name={}, def_id={}, bounds={})\",\n                 token::get_name(self.name),\n-                self.def_id)\n+                self.def_id.repr(tcx),\n+                self.bounds.repr(tcx))\n     }\n }\n \n@@ -638,18 +657,31 @@ impl Repr for subst::RegionSubsts {\n     }\n }\n \n-impl Repr for ty::ParamBounds {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl Repr for ty::BuiltinBounds {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         let mut res = Vec::new();\n-        for b in self.builtin_bounds.iter() {\n+        for b in self.iter() {\n             res.push(match b {\n-                ty::BoundStatic => \"'static\".to_string(),\n-                ty::BoundSend => \"Send\".to_string(),\n-                ty::BoundSized => \"Sized\".to_string(),\n-                ty::BoundCopy => \"Copy\".to_string(),\n-                ty::BoundSync => \"Sync\".to_string(),\n+                ty::BoundSend => \"Send\".to_owned(),\n+                ty::BoundSized => \"Sized\".to_owned(),\n+                ty::BoundCopy => \"Copy\".to_owned(),\n+                ty::BoundSync => \"Sync\".to_owned(),\n             });\n         }\n+        res.connect(\"+\")\n+    }\n+}\n+\n+impl Repr for ty::ExistentialBounds {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        self.user_string(tcx)\n+    }\n+}\n+\n+impl Repr for ty::ParamBounds {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        let mut res = Vec::new();\n+        res.push(self.builtin_bounds.repr(tcx));\n         for t in self.trait_bounds.iter() {\n             res.push(t.repr(tcx));\n         }\n@@ -663,6 +695,15 @@ impl Repr for ty::TraitRef {\n     }\n }\n \n+impl Repr for ty::TraitDef {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"TraitDef(generics={}, bounds={}, trait_ref={})\",\n+                self.generics.repr(tcx),\n+                self.bounds.repr(tcx),\n+                self.trait_ref.repr(tcx))\n+    }\n+}\n+\n impl Repr for ast::Expr {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"expr({}: {})\", self.id, pprust::expr_to_string(self))\n@@ -675,12 +716,24 @@ impl Repr for ast::Path {\n     }\n }\n \n+impl UserString for ast::Path {\n+    fn user_string(&self, _tcx: &ctxt) -> String {\n+        pprust::path_to_string(self)\n+    }\n+}\n+\n impl Repr for ast::Item {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"item({})\", tcx.map.node_to_string(self.id))\n     }\n }\n \n+impl Repr for ast::Lifetime {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"lifetime({}: {})\", self.id, pprust::lifetime_to_string(self))\n+    }\n+}\n+\n impl Repr for ast::Stmt {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"stmt({}: {})\",\n@@ -724,11 +777,7 @@ impl Repr for ty::Region {\n                         bound_region.repr(tcx))\n             }\n \n-            ty::ReFree(ref fr) => {\n-                format!(\"ReFree({}, {})\",\n-                        fr.scope_id,\n-                        fr.bound_region.repr(tcx))\n-            }\n+            ty::ReFree(ref fr) => fr.repr(tcx),\n \n             ty::ReScope(id) => {\n                 format!(\"ReScope({})\", id)\n@@ -753,6 +802,20 @@ impl Repr for ty::Region {\n     }\n }\n \n+impl UserString for ty::Region {\n+    fn user_string(&self, tcx: &ctxt) -> String {\n+        region_to_string(tcx, \"\", false, *self)\n+    }\n+}\n+\n+impl Repr for ty::FreeRegion {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"ReFree({}, {})\",\n+                self.scope_id,\n+                self.bound_region.repr(tcx))\n+    }\n+}\n+\n impl Repr for ast::DefId {\n     fn repr(&self, tcx: &ctxt) -> String {\n         // Unfortunately, there seems to be no way to attempt to print\n@@ -833,6 +896,12 @@ impl Repr for ast::Name {\n     }\n }\n \n+impl UserString for ast::Name {\n+    fn user_string(&self, _tcx: &ctxt) -> String {\n+        token::get_name(*self).get().to_string()\n+    }\n+}\n+\n impl Repr for ast::Ident {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         token::get_ident(*self).get().to_string()\n@@ -928,21 +997,14 @@ impl Repr for ty::BuiltinBound {\n impl UserString for ty::BuiltinBound {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         match *self {\n-            ty::BoundStatic => \"'static\".to_string(),\n-            ty::BoundSend => \"Send\".to_string(),\n-            ty::BoundSized => \"Sized\".to_string(),\n-            ty::BoundCopy => \"Copy\".to_string(),\n-            ty::BoundSync => \"Sync\".to_string(),\n+            ty::BoundSend => \"Send\".to_owned(),\n+            ty::BoundSized => \"Sized\".to_owned(),\n+            ty::BoundCopy => \"Copy\".to_owned(),\n+            ty::BoundSync => \"Sync\".to_owned(),\n         }\n     }\n }\n \n-impl Repr for ty::BuiltinBounds {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        self.user_string(tcx)\n-    }\n-}\n-\n impl Repr for Span {\n     fn repr(&self, tcx: &ctxt) -> String {\n         tcx.sess.codemap().span_to_string(*self).to_string()\n@@ -956,6 +1018,43 @@ impl<A:UserString> UserString for Rc<A> {\n     }\n }\n \n+impl UserString for ty::ParamBounds {\n+    fn user_string(&self, tcx: &ctxt) -> String {\n+        let mut result = Vec::new();\n+        let s = self.builtin_bounds.user_string(tcx);\n+        if !s.is_empty() {\n+            result.push(s);\n+        }\n+        for n in self.trait_bounds.iter() {\n+            result.push(n.user_string(tcx));\n+        }\n+        result.connect(\"+\")\n+    }\n+}\n+\n+impl UserString for ty::ExistentialBounds {\n+    fn user_string(&self, tcx: &ctxt) -> String {\n+        if self.builtin_bounds.contains_elem(ty::BoundSend) &&\n+            self.region_bound == ty::ReStatic\n+        { // Region bound is implied by builtin bounds:\n+            return self.builtin_bounds.repr(tcx);\n+        }\n+\n+        let mut res = Vec::new();\n+\n+        let region_str = self.region_bound.user_string(tcx);\n+        if !region_str.is_empty() {\n+            res.push(region_str);\n+        }\n+\n+        for bound in self.builtin_bounds.iter() {\n+            res.push(bound.user_string(tcx));\n+        }\n+\n+        res.connect(\"+\")\n+    }\n+}\n+\n impl UserString for ty::BuiltinBounds {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         self.iter()\n@@ -1083,33 +1182,55 @@ impl<T:Repr> Repr for infer::Bounds<T> {\n     }\n }\n \n-impl<K:Repr,V:Repr> Repr for VV<K,V> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        match *self {\n-            unify::Redirect(ref k) =>\n-                format!(\"Redirect({})\", k.repr(tcx)),\n-            unify::Root(ref v, r) =>\n-                format!(\"Root({}, {})\", v.repr(tcx), r)\n-        }\n+impl Repr for ty::ExplicitSelfCategory {\n+    fn repr(&self, _: &ctxt) -> String {\n+        explicit_self_category_to_str(self).to_string()\n     }\n }\n \n-impl Repr for region_inference::VarValue {\n+\n+impl Repr for regionmanip::WfConstraint {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n-            infer::region_inference::NoValue =>\n-                format!(\"NoValue\"),\n-            infer::region_inference::Value(r) =>\n-                format!(\"Value({})\", r.repr(tcx)),\n-            infer::region_inference::ErrorValue =>\n-                format!(\"ErrorValue\"),\n+            regionmanip::RegionSubRegionConstraint(_, r_a, r_b) => {\n+                format!(\"RegionSubRegionConstraint({}, {})\",\n+                        r_a.repr(tcx),\n+                        r_b.repr(tcx))\n+            }\n+\n+            regionmanip::RegionSubParamConstraint(_, r, p) => {\n+                format!(\"RegionSubParamConstraint({}, {})\",\n+                        r.repr(tcx),\n+                        p.repr(tcx))\n+            }\n         }\n     }\n }\n \n-impl Repr for ty::ExplicitSelfCategory {\n-    fn repr(&self, _: &ctxt) -> String {\n-        explicit_self_category_to_str(self).to_string()\n+impl UserString for ParamTy {\n+    fn user_string(&self, tcx: &ctxt) -> String {\n+        let id = self.idx;\n+        let did = self.def_id;\n+        let ident = match tcx.ty_param_defs.borrow().find(&did.node) {\n+            Some(def) => token::get_ident(def.ident).get().to_string(),\n+\n+            // This can only happen when a type mismatch error happens and\n+            // the actual type has more type parameters than the expected one.\n+            None => format!(\"<generic #{}>\", id),\n+        };\n+        ident\n+    }\n+}\n+\n+impl Repr for ParamTy {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        self.user_string(tcx)\n     }\n }\n \n+impl<A:Repr,B:Repr> Repr for (A,B) {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        let &(ref a, ref b) = self;\n+        format!(\"({},{})\", a.repr(tcx), b.repr(tcx))\n+    }\n+}"}, {"sha": "522941cee8c9d877940527c30491c75cf2a35dd5", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -192,7 +192,7 @@ impl AttrHelper for SpecialAttribute {\n }\n \n pub struct AttrBuilder {\n-    attrs: Vec<(uint, Box<AttrHelper>)>\n+    attrs: Vec<(uint, Box<AttrHelper+'static>)>\n }\n \n impl AttrBuilder {\n@@ -203,12 +203,12 @@ impl AttrBuilder {\n     }\n \n     pub fn arg<'a, T: AttrHelper + 'static>(&'a mut self, idx: uint, a: T) -> &'a mut AttrBuilder {\n-        self.attrs.push((idx, box a as Box<AttrHelper>));\n+        self.attrs.push((idx, box a as Box<AttrHelper+'static>));\n         self\n     }\n \n     pub fn ret<'a, T: AttrHelper + 'static>(&'a mut self, a: T) -> &'a mut AttrBuilder {\n-        self.attrs.push((ReturnIndex as uint, box a as Box<AttrHelper>));\n+        self.attrs.push((ReturnIndex as uint, box a as Box<AttrHelper+'static>));\n         self\n     }\n "}, {"sha": "ee1b51683c2d0c297cb76f5fd895c54fec93235a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -159,18 +159,12 @@ pub fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> clean::Trait {\n             clean::RequiredMethod(trait_item)\n         }\n     });\n-    let supertraits = ty::trait_supertraits(tcx, did);\n-    let mut parents = supertraits.iter().map(|i| {\n-        match i.clean() {\n-            clean::TraitBound(ty) => ty,\n-            clean::RegionBound => unreachable!()\n-        }\n-    });\n-\n+    let trait_def = ty::lookup_trait_def(tcx, did);\n+    let bounds = trait_def.bounds.clean();\n     clean::Trait {\n         generics: (&def.generics, subst::TypeSpace).clean(),\n         items: items.collect(),\n-        parents: parents.collect()\n+        bounds: bounds,\n     }\n }\n "}, {"sha": "af4df81f99655f76f4c06500727738206733e7bb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -481,15 +481,14 @@ impl Clean<TyParam> for ty::TypeParameterDef {\n \n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub enum TyParamBound {\n-    RegionBound,\n+    RegionBound, // FIXME(#16518) -- need to include name of actual region\n     TraitBound(Type)\n }\n \n impl Clean<TyParamBound> for ast::TyParamBound {\n     fn clean(&self) -> TyParamBound {\n         match *self {\n-            ast::StaticRegionTyParamBound => RegionBound,\n-            ast::OtherRegionTyParamBound(_) => RegionBound,\n+            ast::RegionTyParamBound(_) => RegionBound,\n             ast::UnboxedFnTyParamBound(_) => {\n                 // FIXME(pcwalton): Wrong.\n                 RegionBound\n@@ -499,6 +498,16 @@ impl Clean<TyParamBound> for ast::TyParamBound {\n     }\n }\n \n+impl Clean<Vec<TyParamBound>> for ty::ExistentialBounds {\n+    fn clean(&self) -> Vec<TyParamBound> {\n+        let mut vec = vec!(RegionBound);\n+        for bb in self.builtin_bounds.iter() {\n+            vec.push(bb.clean());\n+        }\n+        vec\n+    }\n+}\n+\n fn external_path(name: &str, substs: &subst::Substs) -> Path {\n     let lifetimes = substs.regions().get_slice(subst::TypeSpace)\n                     .iter()\n@@ -525,7 +534,6 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n         };\n         let empty = subst::Substs::empty();\n         let (did, path) = match *self {\n-            ty::BoundStatic => return RegionBound,\n             ty::BoundSend =>\n                 (tcx.lang_items.send_trait().unwrap(),\n                  external_path(\"Send\", &empty)),\n@@ -810,10 +818,7 @@ impl Clean<ClosureDecl> for ast::ClosureTy {\n             decl: self.decl.clean(),\n             onceness: self.onceness,\n             fn_style: self.fn_style,\n-            bounds: match self.bounds {\n-                Some(ref x) => x.clean(),\n-                None        => Vec::new()\n-            },\n+            bounds: self.bounds.clean()\n         }\n     }\n }\n@@ -909,7 +914,7 @@ impl Clean<RetStyle> for ast::RetStyle {\n pub struct Trait {\n     pub items: Vec<TraitItem>,\n     pub generics: Generics,\n-    pub parents: Vec<Type>,\n+    pub bounds: Vec<TyParamBound>,\n }\n \n impl Clean<Item> for doctree::Trait {\n@@ -924,7 +929,7 @@ impl Clean<Item> for doctree::Trait {\n             inner: TraitItem(Trait {\n                 items: self.items.clean(),\n                 generics: self.generics.clean(),\n-                parents: self.parents.clean(),\n+                bounds: self.bounds.clean(),\n             }),\n         }\n     }\n@@ -1060,7 +1065,7 @@ pub enum Type {\n     Self(ast::DefId),\n     /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n     Primitive(Primitive),\n-    Closure(Box<ClosureDecl>, Option<Lifetime>),\n+    Closure(Box<ClosureDecl>),\n     Proc(Box<ClosureDecl>),\n     /// extern \"ABI\" fn\n     BareFunction(Box<BareFunctionDecl>),\n@@ -1208,7 +1213,7 @@ impl Clean<Type> for ast::Ty {\n                              tpbs.clean().map(|x| x),\n                              id)\n             }\n-            TyClosure(ref c, region) => Closure(box c.clean(), region.clean()),\n+            TyClosure(ref c) => Closure(box c.clean()),\n             TyProc(ref c) => Proc(box c.clean()),\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean()),\n             TyParen(ref ty) => ty.clean(),\n@@ -1273,11 +1278,11 @@ impl Clean<Type> for ty::t {\n                     decl: (ast_util::local_def(0), &fty.sig).clean(),\n                     onceness: fty.onceness,\n                     fn_style: fty.fn_style,\n-                    bounds: fty.bounds.iter().map(|i| i.clean()).collect(),\n+                    bounds: fty.bounds.clean(),\n                 };\n                 match fty.store {\n                     ty::UniqTraitStore => Proc(decl),\n-                    ty::RegionTraitStore(ref r, _) => Closure(decl, r.clean()),\n+                    ty::RegionTraitStore(..) => Closure(decl),\n                 }\n             }\n             ty::ty_struct(did, ref substs) |"}, {"sha": "4d2cf852b8ab7cb3637abeac01ba8618b3af828f", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -156,7 +156,7 @@ pub struct Trait {\n     pub name: Ident,\n     pub items: Vec<ast::TraitItem>, //should be TraitItem\n     pub generics: ast::Generics,\n-    pub parents: Vec<ast::TraitRef>,\n+    pub bounds: Vec<ast::TyParamBound>,\n     pub attrs: Vec<ast::Attribute>,\n     pub id: ast::NodeId,\n     pub whence: Span,"}, {"sha": "e526286ef467ef9c6812553053ce7c0106fa9a8d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -355,7 +355,7 @@ impl fmt::Show for clean::Type {\n             }\n             clean::Self(..) => f.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => primitive_link(f, prim, prim.to_string()),\n-            clean::Closure(ref decl, ref region) => {\n+            clean::Closure(ref decl) => {\n                 write!(f, \"{style}{lifetimes}|{args}|{bounds}{arrow}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n@@ -370,13 +370,6 @@ impl fmt::Show for clean::Type {\n                        },\n                        bounds = {\n                            let mut ret = String::new();\n-                           match *region {\n-                               Some(ref lt) => {\n-                                   ret.push_str(format!(\": {}\",\n-                                                        *lt).as_slice());\n-                               }\n-                               None => {}\n-                           }\n                            for bound in decl.bounds.iter() {\n                                 match *bound {\n                                     clean::RegionBound => {}"}, {"sha": "8342b6bd6756a3abd9a0b0da92f9501526c22361", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -1610,12 +1610,12 @@ fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n \n fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n-    let mut parents = String::new();\n-    if t.parents.len() > 0 {\n-        parents.push_str(\": \");\n-        for (i, p) in t.parents.iter().enumerate() {\n-            if i > 0 { parents.push_str(\" + \"); }\n-            parents.push_str(format!(\"{}\", *p).as_slice());\n+    let mut bounds = String::new();\n+    if t.bounds.len() > 0 {\n+        bounds.push_str(\": \");\n+        for (i, p) in t.bounds.iter().enumerate() {\n+            if i > 0 { bounds.push_str(\" + \"); }\n+            bounds.push_str(format!(\"{}\", *p).as_slice());\n         }\n     }\n \n@@ -1624,7 +1624,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                   VisSpace(it.visibility),\n                   it.name.get_ref().as_slice(),\n                   t.generics,\n-                  parents));\n+                  bounds));\n     let required = t.items.iter()\n                           .filter(|m| {\n                               match **m {"}, {"sha": "1706ebfbcf445b9857a2622188d7cdc56f13dab3", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -317,12 +317,12 @@ impl<'a> RustdocVisitor<'a> {\n                 };\n                 om.statics.push(s);\n             },\n-            ast::ItemTrait(ref gen, _, ref tr, ref items) => {\n+            ast::ItemTrait(ref gen, _, ref b, ref items) => {\n                 let t = Trait {\n                     name: item.ident,\n                     items: items.iter().map(|x| (*x).clone()).collect(),\n                     generics: gen.clone(),\n-                    parents: tr.iter().map(|x| (*x).clone()).collect(),\n+                    bounds: b.iter().map(|x| (*x).clone()).collect(),\n                     id: item.id,\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n                     whence: item.span,"}, {"sha": "28514bec5b49130bedbfa143ce16977bab3b8625", "filename": "src/librustrt/exclusive.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustrt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustrt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fexclusive.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -26,14 +26,24 @@ pub struct Exclusive<T> {\n     data: UnsafeCell<T>,\n }\n \n-/// An RAII guard returned via `lock`\n+/// stage0 only\n+#[cfg(stage0)]\n pub struct ExclusiveGuard<'a, T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _data: &'a mut T,\n     _guard: mutex::LockGuard<'a>,\n }\n \n+/// An RAII guard returned via `lock`\n+#[cfg(not(stage0))]\n+pub struct ExclusiveGuard<'a, T:'a> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _data: &'a mut T,\n+    _guard: mutex::LockGuard<'a>,\n+}\n+\n impl<T: Send> Exclusive<T> {\n     /// Creates a new `Exclusive` which will protect the data provided.\n     pub fn new(user_data: T) -> Exclusive<T> {"}, {"sha": "5ca46a728c346b7d4374ab36bab16f844f7e7a0d", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -19,6 +19,7 @@\n #![feature(macro_rules, phase, globs, thread_local, managed_boxes, asm)]\n #![feature(linkage, lang_items, unsafe_destructor, default_type_params)]\n #![feature(import_shadowing)]\n+#![feature(issue_5723_bootstrap)]\n #![no_std]\n #![experimental]\n \n@@ -98,7 +99,7 @@ pub trait Runtime {\n     fn can_block(&self) -> bool;\n \n     // FIXME: This is a serious code smell and this should not exist at all.\n-    fn wrap(self: Box<Self>) -> Box<Any>;\n+    fn wrap(self: Box<Self>) -> Box<Any+'static>;\n }\n \n /// The default error code of the rust runtime if the main task fails instead"}, {"sha": "fedea3c31e0b1f249cb9221a8063bcebd736335e", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -144,6 +144,16 @@ unsafe fn get_local_map<'a>() -> Option<&'a mut Map> {\n ///\n /// The task-local data can be accessed through this value, and when this\n /// structure is dropped it will return the borrow on the data.\n+#[cfg(not(stage0))]\n+pub struct Ref<T:'static> {\n+    // FIXME #12808: strange names to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _inner: &'static TLDValueBox<T>,\n+    _marker: marker::NoSend\n+}\n+\n+/// stage0 only\n+#[cfg(stage0)]\n pub struct Ref<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref"}, {"sha": "1afd88edbc287c360c827dd893155ca6bdc6cda4", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -120,7 +120,7 @@ pub struct ProcessConfig<'a> {\n }\n \n pub struct LocalIo<'a> {\n-    factory: &'a mut IoFactory,\n+    factory: &'a mut IoFactory+'a,\n }\n \n #[unsafe_destructor]\n@@ -174,7 +174,7 @@ impl<'a> LocalIo<'a> {\n         }\n     }\n \n-    pub fn new<'a>(io: &'a mut IoFactory) -> LocalIo<'a> {\n+    pub fn new<'a>(io: &'a mut IoFactory+'a) -> LocalIo<'a> {\n         LocalIo { factory: io }\n     }\n "}, {"sha": "e39071864a7ec9ccba73ac05818d2d61ab30dfe7", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -103,7 +103,7 @@ pub struct Task {\n     pub name: Option<SendStr>,\n \n     state: TaskState,\n-    imp: Option<Box<Runtime + Send>>,\n+    imp: Option<Box<Runtime + Send + 'static>>,\n }\n \n // Once a task has entered the `Armed` state it must be destroyed via `drop`,\n@@ -353,14 +353,14 @@ impl Task {\n     /// Inserts a runtime object into this task, transferring ownership to the\n     /// task. It is illegal to replace a previous runtime object in this task\n     /// with this argument.\n-    pub fn put_runtime(&mut self, ops: Box<Runtime + Send>) {\n+    pub fn put_runtime(&mut self, ops: Box<Runtime + Send + 'static>) {\n         assert!(self.imp.is_none());\n         self.imp = Some(ops);\n     }\n \n     /// Removes the runtime from this task, transferring ownership to the\n     /// caller.\n-    pub fn take_runtime(&mut self) -> Box<Runtime + Send> {\n+    pub fn take_runtime(&mut self) -> Box<Runtime + Send + 'static> {\n         assert!(self.imp.is_some());\n         self.imp.take().unwrap()\n     }\n@@ -390,7 +390,7 @@ impl Task {\n                 Ok(t) => Some(t),\n                 Err(t) => {\n                     let data = mem::transmute::<_, raw::TraitObject>(t).data;\n-                    let obj: Box<Runtime + Send> =\n+                    let obj: Box<Runtime + Send + 'static> =\n                         mem::transmute(raw::TraitObject {\n                             vtable: vtable,\n                             data: data,"}, {"sha": "0fa89ce989a980c4571aa44f2cd5d7ea96d5057a", "filename": "src/librustuv/access.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -26,11 +26,18 @@ pub struct Access<T> {\n     inner: Arc<UnsafeCell<Inner<T>>>,\n }\n \n+#[cfg(stage0)]\n pub struct Guard<'a, T> {\n     access: &'a mut Access<T>,\n     missile: Option<HomingMissile>,\n }\n \n+#[cfg(not(stage0))]\n+pub struct Guard<'a, T:'static> {\n+    access: &'a mut Access<T>,\n+    missile: Option<HomingMissile>,\n+}\n+\n struct Inner<T> {\n     queue: Vec<(BlockedTask, uint)>,\n     held: bool,"}, {"sha": "d2482ee6b60f533ec218471b5ba7dc8f5ac752f4", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -28,12 +28,20 @@ pub struct AccessTimeout<T> {\n     pub access: access::Access<T>,\n }\n \n+#[cfg(stage0)]\n pub struct Guard<'a, T> {\n     state: &'a mut TimeoutState,\n     pub access: access::Guard<'a, T>,\n     pub can_timeout: bool,\n }\n \n+#[cfg(not(stage0))]\n+pub struct Guard<'a, T:'static> {\n+    state: &'a mut TimeoutState,\n+    pub access: access::Guard<'a, T>,\n+    pub can_timeout: bool,\n+}\n+\n #[deriving(PartialEq)]\n enum TimeoutState {\n     NoTimeout,"}, {"sha": "d70b6b4d57bb8367eaff7cbec19a08a35edaa7a4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -382,7 +382,7 @@ fn fmt_number_or_null(v: f64) -> String {\n \n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n-    writer: &'a mut io::Writer,\n+    writer: &'a mut io::Writer+'a,\n }\n \n impl<'a> Encoder<'a> {\n@@ -594,7 +594,7 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n pub struct PrettyEncoder<'a> {\n-    writer: &'a mut io::Writer,\n+    writer: &'a mut io::Writer+'a,\n     curr_indent: uint,\n     indent: uint,\n }"}, {"sha": "44ea56f4c73936bb01a8c92cd66d32392b1d6ae0", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -24,6 +24,7 @@ Core encoding and decoding interfaces.\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(macro_rules, managed_boxes, default_type_params, phase)]\n+#![feature(issue_5723_bootstrap)]\n \n // test harness access\n #[cfg(test)]"}, {"sha": "714712d9ebaacfa95b8a36b33dbedca5c83fde0b", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -409,20 +409,38 @@ mod table {\n         assert_eq!(size_of::<SafeHash>(), size_of::<u64>())\n     }\n \n-    /// Iterator over shared references to entries in a table.\n+    /// Note: stage0-specific version that lacks bound.\n+    #[cfg(stage0)]\n     pub struct Entries<'a, K, V> {\n         table: &'a RawTable<K, V>,\n         idx: uint,\n         elems_seen: uint,\n     }\n \n-    /// Iterator over mutable references to entries in a table.\n+    /// Iterator over shared references to entries in a table.\n+    #[cfg(not(stage0))]\n+    pub struct Entries<'a, K:'a, V:'a> {\n+        table: &'a RawTable<K, V>,\n+        idx: uint,\n+        elems_seen: uint,\n+    }\n+\n+    /// Note: stage0-specific version that lacks bound.\n+    #[cfg(stage0)]\n     pub struct MutEntries<'a, K, V> {\n         table: &'a mut RawTable<K, V>,\n         idx: uint,\n         elems_seen: uint,\n     }\n \n+    /// Iterator over mutable references to entries in a table.\n+    #[cfg(not(stage0))]\n+    pub struct MutEntries<'a, K:'a, V:'a> {\n+        table: &'a mut RawTable<K, V>,\n+        idx: uint,\n+        elems_seen: uint,\n+    }\n+\n     /// Iterator over the entries in a table, consuming the table.\n     pub struct MoveEntries<K, V> {\n         table: RawTable<K, V>,"}, {"sha": "ffbcdd87bfe79a677ca63b7edc02d82b4ff21f02", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -37,10 +37,29 @@ use ptr::RawPtr;\n ///\n /// Any error other than `EndOfFile` that is produced by the underlying Reader\n /// is returned by the iterator and should be handled by the caller.\n+#[cfg(stage0)]\n pub struct Bytes<'r, T> {\n     reader: &'r mut T,\n }\n \n+/// An iterator that reads a single byte on each iteration,\n+/// until `.read_byte()` returns `EndOfFile`.\n+///\n+/// # Notes about the Iteration Protocol\n+///\n+/// The `Bytes` may yield `None` and thus terminate\n+/// an iteration, but continue to yield elements if iteration\n+/// is attempted again.\n+///\n+/// # Error\n+///\n+/// Any error other than `EndOfFile` that is produced by the underlying Reader\n+/// is returned by the iterator and should be handled by the caller.\n+#[cfg(not(stage0))]\n+pub struct Bytes<'r, T:'r> {\n+    reader: &'r mut T,\n+}\n+\n impl<'r, R: Reader> Bytes<'r, R> {\n     /// Constructs a new byte iterator from the given Reader instance.\n     pub fn new(r: &'r mut R) -> Bytes<'r, R> {"}, {"sha": "38aa58f1c6abfefa4e87e980213c187435c3f742", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 100, "deletions": 7, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -945,11 +945,11 @@ pub trait Reader {\n     }\n }\n \n-impl Reader for Box<Reader> {\n+impl Reader for Box<Reader+'static> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.read(buf) }\n }\n \n-impl<'a> Reader for &'a mut Reader {\n+impl<'a> Reader for &'a mut Reader+'a {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.read(buf) }\n }\n \n@@ -976,6 +976,13 @@ unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -\n     })\n }\n \n+/// Note: stage0-specific version that lacks bound.\n+#[cfg(stage0)]\n+pub struct RefReader<'a, R> {\n+    /// The underlying reader which this is referencing\n+    inner: &'a mut R\n+}\n+\n /// A `RefReader` is a struct implementing `Reader` which contains a reference\n /// to another reader. This is often useful when composing streams.\n ///\n@@ -1000,7 +1007,8 @@ unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -\n ///\n /// # }\n /// ```\n-pub struct RefReader<'a, R> {\n+#[cfg(not(stage0))]\n+pub struct RefReader<'a, R:'a> {\n     /// The underlying reader which this is referencing\n     inner: &'a mut R\n }\n@@ -1058,12 +1066,21 @@ pub trait Writer {\n     ///\n     /// This function will return any I/O error reported while formatting.\n     fn write_fmt(&mut self, fmt: &fmt::Arguments) -> IoResult<()> {\n+        // Note: stage0-specific version that lacks bound.\n+        #[cfg(stage0)]\n+        struct Adaptor<'a, T> {\n+            inner: &'a mut T,\n+            error: IoResult<()>,\n+        }\n+\n         // Create a shim which translates a Writer to a FormatWriter and saves\n         // off I/O errors. instead of discarding them\n-        struct Adaptor<'a, T> {\n+        #[cfg(not(stage0))]\n+        struct Adaptor<'a, T:'a> {\n             inner: &'a mut T,\n             error: IoResult<()>,\n         }\n+\n         impl<'a, T: Writer> fmt::FormatWriter for Adaptor<'a, T> {\n             fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n                 match self.inner.write(bytes) {\n@@ -1278,15 +1295,15 @@ pub trait Writer {\n     }\n }\n \n-impl Writer for Box<Writer> {\n+impl Writer for Box<Writer+'static> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }\n \n     #[inline]\n     fn flush(&mut self) -> IoResult<()> { self.flush() }\n }\n \n-impl<'a> Writer for &'a mut Writer {\n+impl<'a> Writer for &'a mut Writer+'a {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }\n \n@@ -1318,11 +1335,42 @@ impl<'a> Writer for &'a mut Writer {\n /// println!(\"input processed: {}\", output.unwrap());\n /// # }\n /// ```\n+#[cfg(stage0)]\n pub struct RefWriter<'a, W> {\n     /// The underlying writer which this is referencing\n     inner: &'a mut W\n }\n \n+/// A `RefWriter` is a struct implementing `Writer` which contains a reference\n+/// to another writer. This is often useful when composing streams.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # fn main() {}\n+/// # fn process_input<R: Reader>(r: R) {}\n+/// # fn foo () {\n+/// use std::io::util::TeeReader;\n+/// use std::io::{stdin, MemWriter};\n+///\n+/// let mut output = MemWriter::new();\n+///\n+/// {\n+///     // Don't give ownership of 'output' to the 'tee'. Instead we keep a\n+///     // handle to it in the outer scope\n+///     let mut tee = TeeReader::new(stdin(), output.by_ref());\n+///     process_input(tee);\n+/// }\n+///\n+/// println!(\"input processed: {}\", output.unwrap());\n+/// # }\n+/// ```\n+#[cfg(not(stage0))]\n+pub struct RefWriter<'a, W:'a> {\n+    /// The underlying writer which this is referencing\n+    inner: &'a mut W\n+}\n+\n impl<'a, W: Writer> Writer for RefWriter<'a, W> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write(buf) }\n@@ -1351,10 +1399,29 @@ impl<T: Reader + Writer> Stream for T {}\n ///\n /// Any error other than `EndOfFile` that is produced by the underlying Reader\n /// is returned by the iterator and should be handled by the caller.\n+#[cfg(stage0)]\n pub struct Lines<'r, T> {\n     buffer: &'r mut T,\n }\n \n+/// An iterator that reads a line on each iteration,\n+/// until `.read_line()` encounters `EndOfFile`.\n+///\n+/// # Notes about the Iteration Protocol\n+///\n+/// The `Lines` may yield `None` and thus terminate\n+/// an iteration, but continue to yield elements if iteration\n+/// is attempted again.\n+///\n+/// # Error\n+///\n+/// Any error other than `EndOfFile` that is produced by the underlying Reader\n+/// is returned by the iterator and should be handled by the caller.\n+#[cfg(not(stage0))]\n+pub struct Lines<'r, T:'r> {\n+    buffer: &'r mut T,\n+}\n+\n impl<'r, T: Buffer> Iterator<IoResult<String>> for Lines<'r, T> {\n     fn next(&mut self) -> Option<IoResult<String>> {\n         match self.buffer.read_line() {\n@@ -1378,10 +1445,29 @@ impl<'r, T: Buffer> Iterator<IoResult<String>> for Lines<'r, T> {\n ///\n /// Any error other than `EndOfFile` that is produced by the underlying Reader\n /// is returned by the iterator and should be handled by the caller.\n+#[cfg(stage0)]\n pub struct Chars<'r, T> {\n     buffer: &'r mut T\n }\n \n+/// An iterator that reads a utf8-encoded character on each iteration,\n+/// until `.read_char()` encounters `EndOfFile`.\n+///\n+/// # Notes about the Iteration Protocol\n+///\n+/// The `Chars` may yield `None` and thus terminate\n+/// an iteration, but continue to yield elements if iteration\n+/// is attempted again.\n+///\n+/// # Error\n+///\n+/// Any error other than `EndOfFile` that is produced by the underlying Reader\n+/// is returned by the iterator and should be handled by the caller.\n+#[cfg(not(stage0))]\n+pub struct Chars<'r, T:'r> {\n+    buffer: &'r mut T\n+}\n+\n impl<'r, T: Buffer> Iterator<IoResult<char>> for Chars<'r, T> {\n     fn next(&mut self) -> Option<IoResult<char>> {\n         match self.buffer.read_char() {\n@@ -1611,14 +1697,21 @@ pub trait Acceptor<T> {\n     }\n }\n \n+/// Note: stage0-specific version that lacks bound on A.\n+#[cfg(stage0)]\n+pub struct IncomingConnections<'a, A> {\n+    inc: &'a mut A,\n+}\n+\n /// An infinite iterator over incoming connection attempts.\n /// Calling `next` will block the task until a connection is attempted.\n ///\n /// Since connection attempts can continue forever, this iterator always returns\n /// `Some`. The `Some` contains the `IoResult` representing whether the\n /// connection attempt was successful.  A successful connection will be wrapped\n /// in `Ok`. A failed connection is represented as an `Err`.\n-pub struct IncomingConnections<'a, A> {\n+#[cfg(not(stage0))]\n+pub struct IncomingConnections<'a, A:'a> {\n     inc: &'a mut A,\n }\n "}, {"sha": "7fba0bc85a6b9ec6a75009e5bbb3b58f32231dc9", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -126,12 +126,12 @@ impl Buffer for NullReader {\n /// The `Writer`s are delegated to in order. If any `Writer` returns an error,\n /// that error is returned immediately and remaining `Writer`s are not called.\n pub struct MultiWriter {\n-    writers: Vec<Box<Writer>>\n+    writers: Vec<Box<Writer+'static>>\n }\n \n impl MultiWriter {\n     /// Creates a new `MultiWriter`\n-    pub fn new(writers: Vec<Box<Writer>>) -> MultiWriter {\n+    pub fn new(writers: Vec<Box<Writer+'static>>) -> MultiWriter {\n         MultiWriter { writers: writers }\n     }\n }"}, {"sha": "8c1ed7cfa8f928d60cf3d46ac21e94ee5d13f51c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -108,6 +108,7 @@\n #![feature(macro_rules, globs, managed_boxes, linkage)]\n #![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n #![feature(import_shadowing)]\n+#![feature(issue_5723_bootstrap)]\n \n // Don't link to std. We are std.\n #![no_std]"}, {"sha": "6a10be84a621be239c95c5a4770fffdcc675b0ff", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -825,12 +825,20 @@ pub trait GenericPathUnsafe {\n     unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T);\n }\n \n-/// Helper struct for printing paths with format!()\n+/// Note: stage0-specific version that lacks bound.\n+#[cfg(stage0)]\n pub struct Display<'a, P> {\n     path: &'a P,\n     filename: bool\n }\n \n+/// Helper struct for printing paths with format!()\n+#[cfg(not(stage0))]\n+pub struct Display<'a, P:'a> {\n+    path: &'a P,\n+    filename: bool\n+}\n+\n impl<'a, P: GenericPath> fmt::Show for Display<'a, P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_maybe_owned().as_slice().fmt(f)"}, {"sha": "58b3179a297ce747c0eb2cd6ebb6bb94e63599b7", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -291,7 +291,7 @@ mod imp {\n \n         struct Context<'a> {\n             idx: int,\n-            writer: &'a mut Writer,\n+            writer: &'a mut Writer+'a,\n             last_error: Option<IoError>,\n         }\n "}, {"sha": "16f6eea6144f8afd4f694f7e0e362d188f26645c", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -386,6 +386,14 @@ pub struct Receiver<T> {\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n #[unstable]\n+#[cfg(not(stage0))]\n+pub struct Messages<'a, T:'a> {\n+    rx: &'a Receiver<T>\n+}\n+\n+/// Stage0 only\n+#[cfg(stage0)]\n+#[unstable]\n pub struct Messages<'a, T> {\n     rx: &'a Receiver<T>\n }"}, {"sha": "dc9891dd1eedda6af0161dcd9d34d3767e15c263", "filename": "src/libsync/comm/select.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fselect.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -76,6 +76,24 @@ pub struct Select {\n /// A handle to a receiver which is currently a member of a `Select` set of\n /// receivers.  This handle is used to keep the receiver in the set as well as\n /// interact with the underlying receiver.\n+#[cfg(not(stage0))]\n+pub struct Handle<'rx, T:'rx> {\n+    /// The ID of this handle, used to compare against the return value of\n+    /// `Select::wait()`\n+    id: uint,\n+    selector: &'rx Select,\n+    next: *mut Handle<'static, ()>,\n+    prev: *mut Handle<'static, ()>,\n+    added: bool,\n+    packet: &'rx Packet+'rx,\n+\n+    // due to our fun transmutes, we be sure to place this at the end. (nothing\n+    // previous relies on T)\n+    rx: &'rx Receiver<T>,\n+}\n+\n+/// Stage0 only\n+#[cfg(stage0)]\n pub struct Handle<'rx, T> {\n     /// The ID of this handle, used to compare against the return value of\n     /// `Select::wait()`\n@@ -84,7 +102,7 @@ pub struct Handle<'rx, T> {\n     next: *mut Handle<'static, ()>,\n     prev: *mut Handle<'static, ()>,\n     added: bool,\n-    packet: &'rx Packet,\n+    packet: &'rx Packet+'rx,\n \n     // due to our fun transmutes, we be sure to place this at the end. (nothing\n     // previous relies on T)"}, {"sha": "c2744751ee5c265b6ce79f30583047dba7e3d45c", "filename": "src/libsync/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -29,6 +29,7 @@\n \n #![feature(phase, globs, macro_rules, unsafe_destructor)]\n #![feature(import_shadowing)]\n+#![feature(issue_5723_bootstrap)]\n #![deny(missing_doc)]\n #![no_std]\n "}, {"sha": "e1cae6c62d5287f0254b7b4733e31c7014a234a9", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -180,6 +180,18 @@ pub struct Mutex<T> {\n \n /// An guard which is created by locking a mutex. Through this guard the\n /// underlying data can be accessed.\n+#[cfg(not(stage0))]\n+pub struct MutexGuard<'a, T:'a> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _data: &'a mut T,\n+    /// Inner condition variable connected to the locked mutex that this guard\n+    /// was created from. This can be used for atomic-unlock-and-deschedule.\n+    pub cond: Condvar<'a>,\n+}\n+\n+/// stage0 only\n+#[cfg(stage0)]\n pub struct MutexGuard<'a, T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -280,6 +292,18 @@ pub struct RWLock<T> {\n \n /// A guard which is created by locking an rwlock in write mode. Through this\n /// guard the underlying data can be accessed.\n+#[cfg(not(stage0))]\n+pub struct RWLockWriteGuard<'a, T:'a> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _data: &'a mut T,\n+    /// Inner condition variable that can be used to sleep on the write mode of\n+    /// this rwlock.\n+    pub cond: Condvar<'a>,\n+}\n+\n+/// stage0 only\n+#[cfg(stage0)]\n pub struct RWLockWriteGuard<'a, T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -291,6 +315,16 @@ pub struct RWLockWriteGuard<'a, T> {\n \n /// A guard which is created by locking an rwlock in read mode. Through this\n /// guard the underlying data can be accessed.\n+#[cfg(not(stage0))]\n+pub struct RWLockReadGuard<'a, T:'a> {\n+    // FIXME #12808: strange names to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _data: &'a T,\n+    _guard: raw::RWLockReadGuard<'a>,\n+}\n+\n+/// Stage0 only\n+#[cfg(stage0)]\n pub struct RWLockReadGuard<'a, T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref"}, {"sha": "98934d87474e9b1a579c7ca87ebb43640556155f", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -103,10 +103,17 @@ struct SemInner<Q> {\n }\n \n #[must_use]\n+#[cfg(stage0)]\n struct SemGuard<'a, Q> {\n     sem: &'a Sem<Q>,\n }\n \n+#[must_use]\n+#[cfg(not(stage0))]\n+struct SemGuard<'a, Q:'a> {\n+    sem: &'a Sem<Q>,\n+}\n+\n impl<Q: Send> Sem<Q> {\n     fn new(count: int, q: Q) -> Sem<Q> {\n         assert!(count >= 0,"}, {"sha": "32b77be78a43806487c8d777556aec1de5525b45", "filename": "src/libsync/spsc_queue.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fspsc_queue.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -315,27 +315,6 @@ mod test {\n         assert_eq!(consumer.pop(), None);\n     }\n \n-    // This behaviour is blocked by the type system if using the safe constructor\n-    #[test]\n-    fn pop_peeked_unchecked() {\n-        let q = unsafe { Queue::new(0) };\n-        q.push(vec![1i]);\n-        q.push(vec![2]);\n-        let peeked = q.peek().unwrap();\n-\n-        assert_eq!(*peeked, vec![1]);\n-        assert_eq!(q.pop(), Some(vec![1]));\n-\n-        assert_eq!(*peeked, vec![1]);\n-        q.push(vec![7]);\n-\n-        // Note: This should actually expect 1, but this test is to highlight\n-        // the unsafety allowed by the unchecked usage. A Rust user would not\n-        // expect their peeked value to mutate like this without the type system\n-        // complaining.\n-        assert_eq!(*peeked, vec![7]);\n-    }\n-\n     #[test]\n     fn peek() {\n         let (mut consumer, mut producer) = queue(0);"}, {"sha": "d574a02fded22088bff65c640359c16d77ac5a65", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -224,16 +224,17 @@ pub static DUMMY_NODE_ID: NodeId = -1;\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TyParamBound {\n     TraitTyParamBound(TraitRef),\n-    StaticRegionTyParamBound,\n     UnboxedFnTyParamBound(UnboxedFnTy),\n-    OtherRegionTyParamBound(Span) // FIXME -- just here until work for #5723 lands\n+    RegionTyParamBound(Lifetime)\n }\n \n+pub type TyParamBounds = OwnedSlice<TyParamBound>;\n+\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct TyParam {\n     pub ident: Ident,\n     pub id: NodeId,\n-    pub bounds: OwnedSlice<TyParamBound>,\n+    pub bounds: TyParamBounds,\n     pub unbound: Option<TyParamBound>,\n     pub default: Option<P<Ty>>,\n     pub span: Span\n@@ -892,11 +893,7 @@ pub struct ClosureTy {\n     pub fn_style: FnStyle,\n     pub onceness: Onceness,\n     pub decl: P<FnDecl>,\n-    /// Optional optvec distinguishes between \"fn()\" and \"fn:()\" so we can\n-    /// implement issue #7264. None means \"fn()\", which means infer a default\n-    /// bound based on pointer sigil during typeck. Some(Empty) means \"fn:()\",\n-    /// which means use no bounds (e.g., not even Owned on a ~fn()).\n-    pub bounds: Option<OwnedSlice<TyParamBound>>,\n+    pub bounds: TyParamBounds,\n }\n \n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n@@ -923,12 +920,12 @@ pub enum Ty_ {\n     TyFixedLengthVec(P<Ty>, Gc<Expr>),\n     TyPtr(MutTy),\n     TyRptr(Option<Lifetime>, MutTy),\n-    TyClosure(Gc<ClosureTy>, Option<Lifetime>),\n+    TyClosure(Gc<ClosureTy>),\n     TyProc(Gc<ClosureTy>),\n     TyBareFn(Gc<BareFnTy>),\n     TyUnboxedFn(Gc<UnboxedFnTy>),\n     TyTup(Vec<P<Ty>> ),\n-    TyPath(Path, Option<OwnedSlice<TyParamBound>>, NodeId), // for #7264; see above\n+    TyPath(Path, Option<TyParamBounds>, NodeId), // for #7264; see above\n     /// No-op; kept solely so that we can pretty-print faithfully\n     TyParen(P<Ty>),\n     TyTypeof(Gc<Expr>),\n@@ -1281,7 +1278,7 @@ pub enum Item_ {\n     ItemTrait(Generics,\n               Option<TyParamBound>, // (optional) default bound not required for Self.\n                                     // Currently, only Sized makes sense here.\n-              Vec<TraitRef> ,\n+              TyParamBounds,\n               Vec<TraitItem>),\n     ItemImpl(Generics,\n              Option<TraitRef>, // (optional) trait this impl implements"}, {"sha": "993c5ce676ae83551ee85a23e2e8fa42b7ae5f9e", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -68,10 +68,15 @@ impl<'a> Iterator<PathElem> for LinkedPath<'a> {\n     }\n }\n \n-// HACK(eddyb) move this into libstd (value wrapper for slice::Items).\n+#[cfg(stage0)]\n #[deriving(Clone)]\n pub struct Values<'a, T>(pub slice::Items<'a, T>);\n \n+// HACK(eddyb) move this into libstd (value wrapper for slice::Items).\n+#[cfg(not(stage0))]\n+#[deriving(Clone)]\n+pub struct Values<'a, T:'a>(pub slice::Items<'a, T>);\n+\n impl<'a, T: Copy> Iterator<T> for Values<'a, T> {\n     fn next(&mut self) -> Option<T> {\n         let &Values(ref mut items) = self;\n@@ -478,13 +483,22 @@ impl Map {\n     }\n }\n \n+#[cfg(stage0)]\n pub struct NodesMatchingSuffix<'a, S> {\n     map: &'a Map,\n     item_name: &'a S,\n     in_which: &'a [S],\n     idx: NodeId,\n }\n \n+#[cfg(not(stage0))]\n+pub struct NodesMatchingSuffix<'a, S:'a> {\n+    map: &'a Map,\n+    item_name: &'a S,\n+    in_which: &'a [S],\n+    idx: NodeId,\n+}\n+\n impl<'a,S:Str> NodesMatchingSuffix<'a,S> {\n     /// Returns true only if some suffix of the module path for parent\n     /// matches `self.in_which`.\n@@ -676,11 +690,7 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n                     None => {}\n                 }\n             }\n-            ItemTrait(_, _, ref traits, ref methods) => {\n-                for t in traits.iter() {\n-                    self.insert(t.ref_id, EntryItem(self.parent, i));\n-                }\n-\n+            ItemTrait(_, _, _, ref methods) => {\n                 for tm in methods.iter() {\n                     match *tm {\n                         RequiredMethod(ref m) => {"}, {"sha": "cc586a3affac3f0d80d9d68c5ce5a580e7a20371", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -349,12 +349,20 @@ pub trait IdVisitingOperation {\n /// A visitor that applies its operation to all of the node IDs\n /// in a visitable thing.\n \n+#[cfg(stage0)]\n pub struct IdVisitor<'a, O> {\n     pub operation: &'a O,\n     pub pass_through_items: bool,\n     pub visited_outermost: bool,\n }\n \n+#[cfg(not(stage0))]\n+pub struct IdVisitor<'a, O:'a> {\n+    pub operation: &'a O,\n+    pub pass_through_items: bool,\n+    pub visited_outermost: bool,\n+}\n+\n impl<'a, O: IdVisitingOperation> IdVisitor<'a, O> {\n     fn visit_generics_helper(&self, generics: &Generics) {\n         for type_parameter in generics.ty_params.iter() {"}, {"sha": "25a6a4c01bd4757d4cd9ed70918e6f7460547ecc", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -45,8 +45,10 @@ fn with_used_diagnostics<T>(f: |&mut HashMap<Name, Span>| -> T) -> T {\n     }\n }\n \n-pub fn expand_diagnostic_used(ecx: &mut ExtCtxt, span: Span,\n-                              token_tree: &[TokenTree]) -> Box<MacResult> {\n+pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n+                                   span: Span,\n+                                   token_tree: &[TokenTree])\n+                                   -> Box<MacResult+'cx> {\n     let code = match token_tree {\n         [ast::TTTok(_, token::IDENT(code, _))] => code,\n         _ => unreachable!()\n@@ -75,8 +77,10 @@ pub fn expand_diagnostic_used(ecx: &mut ExtCtxt, span: Span,\n     MacExpr::new(quote_expr!(ecx, ()))\n }\n \n-pub fn expand_register_diagnostic(ecx: &mut ExtCtxt, span: Span,\n-                                  token_tree: &[TokenTree]) -> Box<MacResult> {\n+pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n+                                       span: Span,\n+                                       token_tree: &[TokenTree])\n+                                       -> Box<MacResult+'cx> {\n     let (code, description) = match token_tree {\n         [ast::TTTok(_, token::IDENT(ref code, _))] => {\n             (code, None)\n@@ -101,8 +105,10 @@ pub fn expand_register_diagnostic(ecx: &mut ExtCtxt, span: Span,\n     MacItem::new(quote_item!(ecx, mod $sym {}).unwrap())\n }\n \n-pub fn expand_build_diagnostic_array(ecx: &mut ExtCtxt, span: Span,\n-                                     token_tree: &[TokenTree]) -> Box<MacResult> {\n+pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n+                                          span: Span,\n+                                          token_tree: &[TokenTree])\n+                                          -> Box<MacResult+'cx> {\n     let name = match token_tree {\n         [ast::TTTok(_, token::IDENT(ref name, _))] => name,\n         _ => unreachable!()"}, {"sha": "8028d51a7b5cf9471eba7f809806ab227b623fb8", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -45,8 +45,8 @@ impl State {\n \n static OPTIONS: &'static [&'static str] = &[\"volatile\", \"alignstack\", \"intel\"];\n \n-pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                  -> Box<base::MacResult> {\n+pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                       -> Box<base::MacResult+'cx> {\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut asm = InternedString::new(\"\");\n     let mut asm_str_style = None;"}, {"sha": "b3b66a6a6048576ae6cc4701e33f6037165cd2ab", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -52,23 +52,23 @@ pub struct BasicMacroExpander {\n \n /// Represents a thing that maps token trees to Macro Results\n pub trait TTMacroExpander {\n-    fn expand(&self,\n-              ecx: &mut ExtCtxt,\n-              span: Span,\n-              token_tree: &[ast::TokenTree])\n-              -> Box<MacResult>;\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   span: Span,\n+                   token_tree: &[ast::TokenTree])\n+                   -> Box<MacResult+'cx>;\n }\n \n pub type MacroExpanderFn =\n-    fn(ecx: &mut ExtCtxt, span: codemap::Span, token_tree: &[ast::TokenTree])\n-       -> Box<MacResult>;\n+    fn<'cx>(ecx: &'cx mut ExtCtxt, span: codemap::Span, token_tree: &[ast::TokenTree])\n+            -> Box<MacResult+'cx>;\n \n impl TTMacroExpander for BasicMacroExpander {\n-    fn expand(&self,\n-              ecx: &mut ExtCtxt,\n-              span: Span,\n-              token_tree: &[ast::TokenTree])\n-              -> Box<MacResult> {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   span: Span,\n+                   token_tree: &[ast::TokenTree])\n+                   -> Box<MacResult+'cx> {\n         (self.expander)(ecx, span, token_tree)\n     }\n }\n@@ -79,27 +79,27 @@ pub struct BasicIdentMacroExpander {\n }\n \n pub trait IdentMacroExpander {\n-    fn expand(&self,\n-              cx: &mut ExtCtxt,\n-              sp: Span,\n-              ident: ast::Ident,\n-              token_tree: Vec<ast::TokenTree> )\n-              -> Box<MacResult>;\n+    fn expand<'cx>(&self,\n+                   cx: &'cx mut ExtCtxt,\n+                   sp: Span,\n+                   ident: ast::Ident,\n+                   token_tree: Vec<ast::TokenTree> )\n+                   -> Box<MacResult+'cx>;\n }\n \n impl IdentMacroExpander for BasicIdentMacroExpander {\n-    fn expand(&self,\n-              cx: &mut ExtCtxt,\n-              sp: Span,\n-              ident: ast::Ident,\n-              token_tree: Vec<ast::TokenTree> )\n-              -> Box<MacResult> {\n+    fn expand<'cx>(&self,\n+                   cx: &'cx mut ExtCtxt,\n+                   sp: Span,\n+                   ident: ast::Ident,\n+                   token_tree: Vec<ast::TokenTree> )\n+                   -> Box<MacResult+'cx> {\n         (self.expander)(cx, sp, ident, token_tree)\n     }\n }\n \n pub type IdentMacroExpanderFn =\n-    fn(&mut ExtCtxt, Span, ast::Ident, Vec<ast::TokenTree>) -> Box<MacResult>;\n+    fn<'cx>(&'cx mut ExtCtxt, Span, ast::Ident, Vec<ast::TokenTree>) -> Box<MacResult+'cx>;\n \n /// The result of a macro expansion. The return values of the various\n /// methods are spliced into the AST at the callsite of the macro (or\n@@ -146,8 +146,8 @@ pub struct MacExpr {\n     e: Gc<ast::Expr>,\n }\n impl MacExpr {\n-    pub fn new(e: Gc<ast::Expr>) -> Box<MacResult> {\n-        box MacExpr { e: e } as Box<MacResult>\n+    pub fn new(e: Gc<ast::Expr>) -> Box<MacResult+'static> {\n+        box MacExpr { e: e } as Box<MacResult+'static>\n     }\n }\n impl MacResult for MacExpr {\n@@ -160,8 +160,8 @@ pub struct MacPat {\n     p: Gc<ast::Pat>,\n }\n impl MacPat {\n-    pub fn new(p: Gc<ast::Pat>) -> Box<MacResult> {\n-        box MacPat { p: p } as Box<MacResult>\n+    pub fn new(p: Gc<ast::Pat>) -> Box<MacResult+'static> {\n+        box MacPat { p: p } as Box<MacResult+'static>\n     }\n }\n impl MacResult for MacPat {\n@@ -174,8 +174,8 @@ pub struct MacItem {\n     i: Gc<ast::Item>\n }\n impl MacItem {\n-    pub fn new(i: Gc<ast::Item>) -> Box<MacResult> {\n-        box MacItem { i: i } as Box<MacResult>\n+    pub fn new(i: Gc<ast::Item>) -> Box<MacResult+'static> {\n+        box MacItem { i: i } as Box<MacResult+'static>\n     }\n }\n impl MacResult for MacItem {\n@@ -203,17 +203,17 @@ impl DummyResult {\n     ///\n     /// Use this as a return value after hitting any errors and\n     /// calling `span_err`.\n-    pub fn any(sp: Span) -> Box<MacResult> {\n-        box DummyResult { expr_only: false, span: sp } as Box<MacResult>\n+    pub fn any(sp: Span) -> Box<MacResult+'static> {\n+        box DummyResult { expr_only: false, span: sp } as Box<MacResult+'static>\n     }\n \n     /// Create a default MacResult that can only be an expression.\n     ///\n     /// Use this for macros that must expand to an expression, so even\n     /// if an error is encountered internally, the user will receive\n     /// an error that they also used it in the wrong place.\n-    pub fn expr(sp: Span) -> Box<MacResult> {\n-        box DummyResult { expr_only: true, span: sp } as Box<MacResult>\n+    pub fn expr(sp: Span) -> Box<MacResult+'static> {\n+        box DummyResult { expr_only: true, span: sp } as Box<MacResult+'static>\n     }\n \n     /// A plain dummy expression."}, {"sha": "183675114954e1f2e6a805717e550d09f4fa8744", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -17,8 +17,10 @@ use ext::base;\n use ext::build::AstBuilder;\n \n \n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult> {\n+pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n+                              sp: Span,\n+                              tts: &[ast::TokenTree])\n+                              -> Box<base::MacResult+'cx> {\n     cx.span_warn(sp, \"`bytes!` is deprecated, use `b\\\"foo\\\"` literals instead\");\n     cx.parse_sess.span_diagnostic.span_note(sp,\n         \"see http://doc.rust-lang.org/rust.html#byte-and-byte-string-literals \\"}, {"sha": "0c3a951c98241e58bb259dba307c79a2a9172211", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -26,8 +26,10 @@ use parse::token::InternedString;\n use parse::token;\n \n \n-pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                  -> Box<base::MacResult> {\n+pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n+                       sp: Span,\n+                       tts: &[ast::TokenTree])\n+                       -> Box<base::MacResult+'static> {\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut cfgs = Vec::new();\n     // parse `cfg!(meta_item, meta_item(x,y), meta_item=\"foo\", ...)`"}, {"sha": "ea7a4d061c0c502fee26ce5dfe1e8241fc88d2d9", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -19,7 +19,7 @@ use std::string::String;\n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n                          tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult> {\n+                         -> Box<base::MacResult+'static> {\n     let es = match base::get_exprs_from_tts(cx, sp, tts) {\n         Some(e) => e,\n         None => return base::DummyResult::expr(sp)"}, {"sha": "0ac26a3a90490a1fc04343ddae6320880fa7545f", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -18,8 +18,8 @@ use parse::token::{str_to_ident};\n \n use std::gc::GC;\n \n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult> {\n+pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                              -> Box<base::MacResult+'cx> {\n     let mut res_str = String::new();\n     for (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {"}, {"sha": "50bdc296aad766e37875235368069776c56e9a25", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -407,9 +407,15 @@ impl<'a> TraitDef<'a> {\n                     cx.typarambound(p.to_path(cx, self.span,\n                                                   type_ident, generics))\n                 }).collect();\n+\n             // require the current trait\n             bounds.push(cx.typarambound(trait_path.clone()));\n \n+            // also add in any bounds from the declaration\n+            for declared_bound in ty_param.bounds.iter() {\n+                bounds.push((*declared_bound).clone());\n+            }\n+\n             cx.typaram(self.span,\n                        ty_param.ident,\n                        OwnedSlice::from_vec(bounds),"}, {"sha": "aae92ae85fc5be8d0b5bcdb514bfd3552d952d67", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -23,8 +23,8 @@ use parse::token;\n \n use std::os;\n \n-pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult> {\n+pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                              -> Box<base::MacResult+'cx> {\n     let var = match get_single_str_from_tts(cx, sp, tts, \"option_env!\") {\n         None => return DummyResult::expr(sp),\n         Some(v) => v\n@@ -59,8 +59,8 @@ pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     MacExpr::new(e)\n }\n \n-pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                  -> Box<base::MacResult> {\n+pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                       -> Box<base::MacResult+'cx> {\n     let exprs = match get_exprs_from_tts(cx, sp, tts) {\n         Some(ref exprs) if exprs.len() == 0 => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");"}, {"sha": "9dbea1c9ac2c66c8d9b68692834834af10f2a72a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 102, "deletions": 89, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -31,6 +31,10 @@ use util::small_vector::SmallVector;\n \n use std::gc::{Gc, GC};\n \n+enum Either<L,R> {\n+    Left(L),\n+    Right(R)\n+}\n \n fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n     match e.node {\n@@ -102,7 +106,8 @@ fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n                        parse_thunk: |Box<MacResult>|->Option<T>,\n                        mark_thunk: |T,Mrk|->T,\n                        fld: &mut MacroExpander)\n-    -> Option<T> {\n+                       -> Option<T>\n+{\n     match (*mac).node {\n         // it would almost certainly be cleaner to pass the whole\n         // macro invocation in, rather than pulling it apart and\n@@ -149,10 +154,13 @@ fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n                         // the macro.\n                         let mac_span = original_span(fld.cx);\n \n-                        let expanded = expandfun.expand(fld.cx,\n-                                                        mac_span.call_site,\n-                                                        marked_before.as_slice());\n-                        let parsed = match parse_thunk(expanded) {\n+                        let opt_parsed = {\n+                            let expanded = expandfun.expand(fld.cx,\n+                                                            mac_span.call_site,\n+                                                            marked_before.as_slice());\n+                            parse_thunk(expanded)\n+                        };\n+                        let parsed = match opt_parsed {\n                             Some(e) => e,\n                             None => {\n                                 fld.cx.span_err(\n@@ -358,7 +366,8 @@ fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n-                       -> SmallVector<Gc<ast::Item>> {\n+                   -> SmallVector<Gc<ast::Item>>\n+{\n     let (pth, tts) = match it.node {\n         ItemMac(codemap::Spanned {\n             node: MacInvocTT(ref pth, ref tts, _),\n@@ -372,86 +381,93 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n     let extname = pth.segments.get(0).identifier;\n     let extnamestr = token::get_ident(extname);\n     let fm = fresh_mark();\n-    let expanded = match fld.cx.syntax_env.find(&extname.name) {\n-        None => {\n-            fld.cx.span_err(pth.span,\n-                            format!(\"macro undefined: '{}!'\",\n-                                    extnamestr).as_slice());\n-            // let compilation continue\n-            return SmallVector::zero();\n-        }\n+    let def_or_items = {\n+        let expanded = match fld.cx.syntax_env.find(&extname.name) {\n+            None => {\n+                fld.cx.span_err(pth.span,\n+                                format!(\"macro undefined: '{}!'\",\n+                                        extnamestr).as_slice());\n+                // let compilation continue\n+                return SmallVector::zero();\n+            }\n \n-        Some(rc) => match *rc {\n-            NormalTT(ref expander, span) => {\n-                if it.ident.name != parse::token::special_idents::invalid.name {\n-                    fld.cx\n-                    .span_err(pth.span,\n-                                format!(\"macro {}! expects no ident argument, \\\n+            Some(rc) => match *rc {\n+                NormalTT(ref expander, span) => {\n+                    if it.ident.name != parse::token::special_idents::invalid.name {\n+                        fld.cx\n+                            .span_err(pth.span,\n+                                      format!(\"macro {}! expects no ident argument, \\\n                                         given '{}'\",\n-                                        extnamestr,\n-                                        token::get_ident(it.ident)).as_slice());\n-                    return SmallVector::zero();\n+                                      extnamestr,\n+                                      token::get_ident(it.ident)).as_slice());\n+                        return SmallVector::zero();\n+                    }\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: it.span,\n+                        callee: NameAndSpan {\n+                            name: extnamestr.get().to_string(),\n+                            format: MacroBang,\n+                            span: span\n+                        }\n+                    });\n+                    // mark before expansion:\n+                    let marked_before = mark_tts(tts.as_slice(), fm);\n+                    expander.expand(fld.cx, it.span, marked_before.as_slice())\n                 }\n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: it.span,\n-                    callee: NameAndSpan {\n-                        name: extnamestr.get().to_string(),\n-                        format: MacroBang,\n-                        span: span\n+                IdentTT(ref expander, span) => {\n+                    if it.ident.name == parse::token::special_idents::invalid.name {\n+                        fld.cx.span_err(pth.span,\n+                                        format!(\"macro {}! expects an ident argument\",\n+                                                extnamestr.get()).as_slice());\n+                        return SmallVector::zero();\n                     }\n-                });\n-                // mark before expansion:\n-                let marked_before = mark_tts(tts.as_slice(), fm);\n-                expander.expand(fld.cx, it.span, marked_before.as_slice())\n-            }\n-            IdentTT(ref expander, span) => {\n-                if it.ident.name == parse::token::special_idents::invalid.name {\n-                    fld.cx.span_err(pth.span,\n-                                    format!(\"macro {}! expects an ident argument\",\n-                                            extnamestr.get()).as_slice());\n-                    return SmallVector::zero();\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: it.span,\n+                        callee: NameAndSpan {\n+                            name: extnamestr.get().to_string(),\n+                            format: MacroBang,\n+                            span: span\n+                        }\n+                    });\n+                    // mark before expansion:\n+                    let marked_tts = mark_tts(tts.as_slice(), fm);\n+                    expander.expand(fld.cx, it.span, it.ident, marked_tts)\n                 }\n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: it.span,\n-                    callee: NameAndSpan {\n-                        name: extnamestr.get().to_string(),\n-                        format: MacroBang,\n-                        span: span\n+                LetSyntaxTT(ref expander, span) => {\n+                    if it.ident.name == parse::token::special_idents::invalid.name {\n+                        fld.cx.span_err(pth.span,\n+                                        format!(\"macro {}! expects an ident argument\",\n+                                                extnamestr.get()).as_slice());\n+                        return SmallVector::zero();\n                     }\n-                });\n-                // mark before expansion:\n-                let marked_tts = mark_tts(tts.as_slice(), fm);\n-                expander.expand(fld.cx, it.span, it.ident, marked_tts)\n-            }\n-            LetSyntaxTT(ref expander, span) => {\n-                if it.ident.name == parse::token::special_idents::invalid.name {\n-                    fld.cx.span_err(pth.span,\n-                                    format!(\"macro {}! expects an ident argument\",\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: it.span,\n+                        callee: NameAndSpan {\n+                            name: extnamestr.get().to_string(),\n+                            format: MacroBang,\n+                            span: span\n+                        }\n+                    });\n+                    // DON'T mark before expansion:\n+                    expander.expand(fld.cx, it.span, it.ident, tts)\n+                }\n+                _ => {\n+                    fld.cx.span_err(it.span,\n+                                    format!(\"{}! is not legal in item position\",\n                                             extnamestr.get()).as_slice());\n                     return SmallVector::zero();\n                 }\n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: it.span,\n-                    callee: NameAndSpan {\n-                        name: extnamestr.get().to_string(),\n-                        format: MacroBang,\n-                        span: span\n-                    }\n-                });\n-                // DON'T mark before expansion:\n-                expander.expand(fld.cx, it.span, it.ident, tts)\n-            }\n-            _ => {\n-                fld.cx.span_err(it.span,\n-                                format!(\"{}! is not legal in item position\",\n-                                        extnamestr.get()).as_slice());\n-                return SmallVector::zero();\n             }\n+        };\n+\n+        match expanded.make_def() {\n+            Some(def) => Left(def),\n+            None => Right(expanded.make_items())\n         }\n     };\n \n-    let items = match expanded.make_def() {\n-        Some(MacroDef { name, ext }) => {\n+    let items = match def_or_items {\n+        Left(MacroDef { name, ext }) => {\n             // hidden invariant: this should only be possible as the\n             // result of expanding a LetSyntaxTT, and thus doesn't\n             // need to be marked. Not that it could be marked anyway.\n@@ -462,23 +478,20 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             }\n             SmallVector::zero()\n         }\n-        None => {\n-            match expanded.make_items() {\n-                Some(items) => {\n-                    items.move_iter()\n-                        .map(|i| mark_item(i, fm))\n-                        .flat_map(|i| fld.fold_item(i).move_iter())\n-                        .collect()\n-                }\n-                None => {\n-                    fld.cx.span_err(pth.span,\n-                                    format!(\"non-item macro in item position: {}\",\n-                                            extnamestr.get()).as_slice());\n-                    return SmallVector::zero();\n-                }\n-            }\n+        Right(Some(items)) => {\n+            items.move_iter()\n+                .map(|i| mark_item(i, fm))\n+                .flat_map(|i| fld.fold_item(i).move_iter())\n+                .collect()\n+        }\n+        Right(None) => {\n+            fld.cx.span_err(pth.span,\n+                            format!(\"non-item macro in item position: {}\",\n+                                    extnamestr.get()).as_slice());\n+            return SmallVector::zero();\n         }\n     };\n+\n     fld.cx.bt_pop();\n     return items;\n }\n@@ -901,7 +914,7 @@ fn expand_and_rename_fn_decl_and_block(fn_decl: &ast::FnDecl, block: Gc<ast::Blo\n }\n \n /// A tree-folder that performs macro expansion\n-pub struct MacroExpander<'a, 'b> {\n+pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n }\n "}, {"sha": "5352cfaf749b0904c7ac75d6bd218efa52e14f15", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -19,7 +19,7 @@ use ext::build::AstBuilder;\n pub fn expand_syntax_ext(ecx: &mut base::ExtCtxt,\n                          sp: Span,\n                          _tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult> {\n+                         -> Box<base::MacResult+'static> {\n     ecx.span_err(sp, \"`fmt!` is deprecated, use `format!` instead\");\n     ecx.parse_sess.span_diagnostic.span_note(sp,\n         \"see http://doc.rust-lang.org/std/fmt/ \\"}, {"sha": "0994abaadc709dabf6bb5986a2aa35dfd918fbe4", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -33,7 +33,7 @@ enum Position {\n     Named(String),\n }\n \n-struct Context<'a, 'b> {\n+struct Context<'a, 'b:'a> {\n     ecx: &'a mut ExtCtxt<'b>,\n     fmtsp: Span,\n \n@@ -668,8 +668,9 @@ impl<'a, 'b> Context<'a, 'b> {\n     }\n }\n \n-pub fn expand_format_args(ecx: &mut ExtCtxt, sp: Span,\n-                          tts: &[ast::TokenTree]) -> Box<base::MacResult> {\n+pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n+                               tts: &[ast::TokenTree])\n+                               -> Box<base::MacResult+'cx> {\n \n     match parse_args(ecx, sp, false, tts) {\n         (invocation, Some((efmt, args, order, names))) => {\n@@ -680,8 +681,8 @@ pub fn expand_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n }\n \n-pub fn expand_format_args_method(ecx: &mut ExtCtxt, sp: Span,\n-                                 tts: &[ast::TokenTree]) -> Box<base::MacResult> {\n+pub fn expand_format_args_method<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n+                                      tts: &[ast::TokenTree]) -> Box<base::MacResult+'cx> {\n \n     match parse_args(ecx, sp, true, tts) {\n         (invocation, Some((efmt, args, order, names))) => {"}, {"sha": "8df5746e412d49aab017be628cb2b8c5768f0c89", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -15,10 +15,10 @@ use print;\n \n use std::rc::Rc;\n \n-pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n-                         sp: codemap::Span,\n-                         tt: &[ast::TokenTree])\n-                         -> Box<base::MacResult> {\n+pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt,\n+                              sp: codemap::Span,\n+                              tt: &[ast::TokenTree])\n+                              -> Box<base::MacResult+'cx> {\n \n     cx.print_backtrace();\n     println!(\"{}\", print::pprust::tt_to_string(&ast::TTDelim("}, {"sha": "0c41db7ecd685180b9d58b31b471906b74ca19c3", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -410,51 +410,52 @@ pub mod rt {\n \n }\n \n-pub fn expand_quote_tokens(cx: &mut ExtCtxt,\n-                           sp: Span,\n-                           tts: &[ast::TokenTree])\n-                           -> Box<base::MacResult> {\n+pub fn expand_quote_tokens<'cx>(cx: &'cx mut ExtCtxt,\n+                                sp: Span,\n+                                tts: &[ast::TokenTree])\n+                                -> Box<base::MacResult+'cx> {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n     let expanded = expand_wrapper(cx, sp, cx_expr, expr);\n     base::MacExpr::new(expanded)\n }\n \n-pub fn expand_quote_expr(cx: &mut ExtCtxt,\n-                         sp: Span,\n-                         tts: &[ast::TokenTree]) -> Box<base::MacResult> {\n+pub fn expand_quote_expr<'cx>(cx: &'cx mut ExtCtxt,\n+                              sp: Span,\n+                              tts: &[ast::TokenTree])\n+                              -> Box<base::MacResult+'cx> {\n     let expanded = expand_parse_call(cx, sp, \"parse_expr\", Vec::new(), tts);\n     base::MacExpr::new(expanded)\n }\n \n-pub fn expand_quote_item(cx: &mut ExtCtxt,\n-                         sp: Span,\n-                         tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult> {\n+pub fn expand_quote_item<'cx>(cx: &mut ExtCtxt,\n+                              sp: Span,\n+                              tts: &[ast::TokenTree])\n+                              -> Box<base::MacResult+'cx> {\n     let expanded = expand_parse_call(cx, sp, \"parse_item_with_outer_attributes\",\n                                     vec!(), tts);\n     base::MacExpr::new(expanded)\n }\n \n-pub fn expand_quote_pat(cx: &mut ExtCtxt,\n-                        sp: Span,\n-                        tts: &[ast::TokenTree])\n-                        -> Box<base::MacResult> {\n+pub fn expand_quote_pat<'cx>(cx: &'cx mut ExtCtxt,\n+                             sp: Span,\n+                             tts: &[ast::TokenTree])\n+                             -> Box<base::MacResult+'cx> {\n     let expanded = expand_parse_call(cx, sp, \"parse_pat\", vec!(), tts);\n     base::MacExpr::new(expanded)\n }\n \n pub fn expand_quote_arm(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[ast::TokenTree])\n-                        -> Box<base::MacResult> {\n+                        -> Box<base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_arm\", vec!(), tts);\n     base::MacExpr::new(expanded)\n }\n \n pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[ast::TokenTree])\n-                       -> Box<base::MacResult> {\n+                       -> Box<base::MacResult+'static> {\n     let e_param_colons = cx.expr_lit(sp, ast::LitBool(false));\n     let expanded = expand_parse_call(cx, sp, \"parse_ty\",\n                                      vec!(e_param_colons), tts);\n@@ -464,7 +465,7 @@ pub fn expand_quote_ty(cx: &mut ExtCtxt,\n pub fn expand_quote_method(cx: &mut ExtCtxt,\n                            sp: Span,\n                            tts: &[ast::TokenTree])\n-                           -> Box<base::MacResult> {\n+                           -> Box<base::MacResult+'static> {\n     let e_param_colons = cx.expr_none(sp);\n     let expanded = expand_parse_call(cx, sp, \"parse_method\",\n                                      vec!(e_param_colons), tts);\n@@ -474,7 +475,7 @@ pub fn expand_quote_method(cx: &mut ExtCtxt,\n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult> {\n+                         -> Box<base::MacResult+'static> {\n     let e_attrs = cx.expr_vec_ng(sp);\n     let expanded = expand_parse_call(cx, sp, \"parse_stmt\",\n                                     vec!(e_attrs), tts);"}, {"sha": "5cc0ec4a122900f67ac5127ee891f1135be51ee2", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -29,7 +29,7 @@ use std::rc::Rc;\n \n /// line!(): expands to the current line number\n pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                   -> Box<base::MacResult> {\n+                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n@@ -40,7 +40,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n /* col!(): expands to the current column number */\n pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                  -> Box<base::MacResult> {\n+                  -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n@@ -52,7 +52,7 @@ pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n /// The filemap (`loc.file`) contains a bunch more information we could spit\n /// out if we wanted.\n pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                   -> Box<base::MacResult> {\n+                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n@@ -62,14 +62,14 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                        -> Box<base::MacResult> {\n+                        -> Box<base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n     base::MacExpr::new(cx.expr_str(sp,\n                                    token::intern_and_get_ident(s.as_slice())))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                  -> Box<base::MacResult> {\n+                  -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let string = cx.mod_path()\n                    .iter()\n@@ -85,7 +85,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n /// This is generally a bad idea because it's going to behave\n /// unhygienically.\n pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                      -> Box<base::MacResult> {\n+                      -> Box<base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp),\n@@ -105,7 +105,7 @@ pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n // include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                          -> Box<base::MacResult> {\n+                          -> Box<base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp)\n@@ -141,7 +141,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                          -> Box<base::MacResult> {\n+                          -> Box<base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bin!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp)"}, {"sha": "1f50eb933bb4e80a1c7b731b9a9b0db2aba178a0", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -18,7 +18,7 @@ use parse::token::{keywords, is_keyword};\n pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                            sp: Span,\n                            tt: &[ast::TokenTree])\n-                           -> Box<base::MacResult> {\n+                           -> Box<base::MacResult+'static> {\n     match tt {\n         [ast::TTTok(_, ref tok)] if is_keyword(keywords::True, tok) => {\n             cx.set_trace_macros(true);"}, {"sha": "d8f0eb32ad7bfc0f11ee6ef1f2cb7bb968400a38", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -14,7 +14,6 @@ use ast;\n use codemap::{Span, Spanned, DUMMY_SP};\n use ext::base::{ExtCtxt, MacResult, MacroDef};\n use ext::base::{NormalTT, TTMacroExpander};\n-use ext::base;\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_or_else};\n@@ -113,11 +112,11 @@ struct MacroRulesMacroExpander {\n }\n \n impl TTMacroExpander for MacroRulesMacroExpander {\n-    fn expand(&self,\n-              cx: &mut ExtCtxt,\n-              sp: Span,\n-              arg: &[ast::TokenTree])\n-              -> Box<MacResult> {\n+    fn expand<'cx>(&self,\n+                   cx: &'cx mut ExtCtxt,\n+                   sp: Span,\n+                   arg: &[ast::TokenTree])\n+                   -> Box<MacResult+'cx> {\n         generic_extension(cx,\n                           sp,\n                           self.name,\n@@ -137,13 +136,13 @@ impl MacResult for MacroRulesDefiner {\n }\n \n /// Given `lhses` and `rhses`, this is the new macro we create\n-fn generic_extension(cx: &ExtCtxt,\n-                     sp: Span,\n-                     name: Ident,\n-                     arg: &[ast::TokenTree],\n-                     lhses: &[Rc<NamedMatch>],\n-                     rhses: &[Rc<NamedMatch>])\n-                     -> Box<MacResult> {\n+fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n+                          sp: Span,\n+                          name: Ident,\n+                          arg: &[ast::TokenTree],\n+                          lhses: &[Rc<NamedMatch>],\n+                          rhses: &[Rc<NamedMatch>])\n+                          -> Box<MacResult+'cx> {\n     if cx.trace_macros() {\n         println!(\"{}! {} {} {}\",\n                  token::get_ident(name),\n@@ -195,7 +194,7 @@ fn generic_extension(cx: &ExtCtxt,\n                 // Weird, but useful for X-macros.\n                 return box ParserAnyMacro {\n                     parser: RefCell::new(p),\n-                } as Box<MacResult>\n+                } as Box<MacResult+'cx>\n               }\n               Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                 best_fail_spot = sp;\n@@ -213,11 +212,11 @@ fn generic_extension(cx: &ExtCtxt,\n /// This procedure performs the expansion of the\n /// macro_rules! macro. It parses the RHS and adds\n /// an extension to the current context.\n-pub fn add_new_extension(cx: &mut ExtCtxt,\n-                         sp: Span,\n-                         name: Ident,\n-                         arg: Vec<ast::TokenTree> )\n-                         -> Box<base::MacResult> {\n+pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n+                              sp: Span,\n+                              name: Ident,\n+                              arg: Vec<ast::TokenTree> )\n+                              -> Box<MacResult+'cx> {\n     // these spans won't matter, anyways\n     fn ms(m: Matcher_) -> Matcher {\n         Spanned {\n@@ -274,5 +273,5 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n             name: token::get_ident(name).to_string(),\n             ext: NormalTT(exp, Some(sp))\n         }))\n-    } as Box<MacResult>\n+    } as Box<MacResult+'cx>\n }"}, {"sha": "be1c0d967116ad4fdc43b67c224c6542e5b13f41", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -227,15 +227,20 @@ pub trait Folder {\n         noop_fold_variant_arg(va, self)\n     }\n \n-    fn fold_ty_param_bound(&mut self, tpb: &TyParamBound) -> TyParamBound {\n-        noop_fold_ty_param_bound(tpb, self)\n-    }\n-\n     fn fold_opt_bounds(&mut self, b: &Option<OwnedSlice<TyParamBound>>)\n                        -> Option<OwnedSlice<TyParamBound>> {\n         noop_fold_opt_bounds(b, self)\n     }\n \n+    fn fold_bounds(&mut self, b: &OwnedSlice<TyParamBound>)\n+                       -> OwnedSlice<TyParamBound> {\n+        noop_fold_bounds(b, self)\n+    }\n+\n+    fn fold_ty_param_bound(&mut self, tpb: &TyParamBound) -> TyParamBound {\n+        noop_fold_ty_param_bound(tpb, self)\n+    }\n+\n     fn fold_mt(&mut self, mt: &MutTy) -> MutTy {\n         noop_fold_mt(mt, self)\n     }\n@@ -349,20 +354,20 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n         TyRptr(ref region, ref mt) => {\n             TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n         }\n-        TyClosure(ref f, ref region) => {\n+        TyClosure(ref f) => {\n             TyClosure(box(GC) ClosureTy {\n                 fn_style: f.fn_style,\n                 onceness: f.onceness,\n-                bounds: fld.fold_opt_bounds(&f.bounds),\n+                bounds: fld.fold_bounds(&f.bounds),\n                 decl: fld.fold_fn_decl(&*f.decl),\n                 lifetimes: fld.fold_lifetime_defs(f.lifetimes.as_slice()),\n-            }, fld.fold_opt_lifetime(region))\n+            })\n         }\n         TyProc(ref f) => {\n             TyProc(box(GC) ClosureTy {\n                 fn_style: f.fn_style,\n                 onceness: f.onceness,\n-                bounds: fld.fold_opt_bounds(&f.bounds),\n+                bounds: fld.fold_bounds(&f.bounds),\n                 decl: fld.fold_fn_decl(&*f.decl),\n                 lifetimes: fld.fold_lifetime_defs(f.lifetimes.as_slice()),\n             })\n@@ -648,14 +653,13 @@ pub fn noop_fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n                                            -> TyParamBound {\n     match *tpb {\n         TraitTyParamBound(ref ty) => TraitTyParamBound(fld.fold_trait_ref(ty)),\n-        StaticRegionTyParamBound => StaticRegionTyParamBound,\n+        RegionTyParamBound(ref lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n         UnboxedFnTyParamBound(ref unboxed_function_type) => {\n             UnboxedFnTyParamBound(UnboxedFnTy {\n                 decl: fld.fold_fn_decl(&*unboxed_function_type.decl),\n                 kind: unboxed_function_type.kind,\n             })\n         }\n-        OtherRegionTyParamBound(s) => OtherRegionTyParamBound(s)\n     }\n }\n \n@@ -664,7 +668,7 @@ pub fn noop_fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {\n     TyParam {\n         ident: tp.ident,\n         id: id,\n-        bounds: tp.bounds.map(|x| fld.fold_ty_param_bound(x)),\n+        bounds: fld.fold_bounds(&tp.bounds),\n         unbound: tp.unbound.as_ref().map(|x| fld.fold_ty_param_bound(x)),\n         default: tp.default.map(|x| fld.fold_ty(x)),\n         span: tp.span\n@@ -792,11 +796,12 @@ pub fn noop_fold_mt<T: Folder>(mt: &MutTy, folder: &mut T) -> MutTy {\n \n pub fn noop_fold_opt_bounds<T: Folder>(b: &Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n                               -> Option<OwnedSlice<TyParamBound>> {\n-    b.as_ref().map(|bounds| {\n-        bounds.map(|bound| {\n-            folder.fold_ty_param_bound(bound)\n-        })\n-    })\n+    b.as_ref().map(|bounds| folder.fold_bounds(bounds))\n+}\n+\n+fn noop_fold_bounds<T: Folder>(bounds: &TyParamBounds, folder: &mut T)\n+                          -> TyParamBounds {\n+    bounds.map(|bound| folder.fold_ty_param_bound(bound))\n }\n \n pub fn noop_fold_variant_arg<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {\n@@ -889,7 +894,8 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n                                }).collect()\n             )\n         }\n-        ItemTrait(ref generics, ref unbound, ref traits, ref methods) => {\n+        ItemTrait(ref generics, ref unbound, ref bounds, ref methods) => {\n+            let bounds = folder.fold_bounds(bounds);\n             let methods = methods.iter().flat_map(|method| {\n                 let r = match *method {\n                     RequiredMethod(ref m) => {\n@@ -911,7 +917,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n             }).collect();\n             ItemTrait(folder.fold_generics(generics),\n                       unbound.clone(),\n-                      traits.iter().map(|p| folder.fold_trait_ref(p)).collect(),\n+                      bounds,\n                       methods)\n         }\n         ItemMac(ref m) => ItemMac(folder.fold_mac(m)),"}, {"sha": "9bbd6b2a36ea3c3db327c4eaa58ca1e92bd41ae6", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -25,6 +25,7 @@\n \n #![feature(macro_rules, globs, managed_boxes, default_type_params, phase)]\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n+#![feature(issue_5723_bootstrap)]\n #![allow(deprecated)]\n \n // NOTE(stage0, pcwalton): Remove after snapshot."}, {"sha": "37bda15ac2c414301c76b705712dcf5cf17a555a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 71, "deletions": 113, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -12,7 +12,7 @@\n \n use abi;\n use ast::{BareFnTy, ClosureTy};\n-use ast::{StaticRegionTyParamBound, OtherRegionTyParamBound, TraitTyParamBound};\n+use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{ProvidedMethod, Public, FnStyle};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, Block};\n@@ -70,7 +70,7 @@ use parse;\n use parse::attr::ParserAttr;\n use parse::classify;\n use parse::common::{SeqSep, seq_sep_none};\n-use parse::common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed};\n+use parse::common::{seq_sep_trailing_allowed};\n use parse::lexer::Reader;\n use parse::lexer::TokenAndSpan;\n use parse::obsolete::*;\n@@ -120,7 +120,7 @@ pub enum PathParsingMode {\n /// A path paired with optional type bounds.\n pub struct PathAndBounds {\n     pub path: ast::Path,\n-    pub bounds: Option<OwnedSlice<TyParamBound>>,\n+    pub bounds: Option<ast::TyParamBounds>,\n }\n \n enum ItemOrViewItem {\n@@ -309,7 +309,7 @@ pub struct Parser<'a> {\n     pub tokens_consumed: uint,\n     pub restriction: restriction,\n     pub quote_depth: uint, // not (yet) related to the quasiquoter\n-    pub reader: Box<Reader>,\n+    pub reader: Box<Reader+'a>,\n     pub interner: Rc<token::IdentInterner>,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice\n@@ -346,8 +346,11 @@ fn real_token(rdr: &mut Reader) -> TokenAndSpan {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn new(sess: &'a ParseSess, cfg: ast::CrateConfig,\n-               mut rdr: Box<Reader>) -> Parser<'a> {\n+    pub fn new(sess: &'a ParseSess,\n+               cfg: ast::CrateConfig,\n+               mut rdr: Box<Reader+'a>)\n+               -> Parser<'a>\n+    {\n         let tok0 = real_token(rdr);\n         let span = tok0.sp;\n         let placeholder = TokenAndSpan {\n@@ -1073,14 +1076,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let (inputs, variadic) = self.parse_fn_args(false, false);\n-        let bounds = {\n-            if self.eat(&token::COLON) {\n-                let (_, bounds) = self.parse_ty_param_bounds(false);\n-                Some(bounds)\n-            } else {\n-                None\n-            }\n-        };\n+        let bounds = self.parse_colon_then_ty_param_bounds();\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         let decl = P(FnDecl {\n             inputs: inputs,\n@@ -1168,14 +1164,7 @@ impl<'a> Parser<'a> {\n             (optional_unboxed_closure_kind, inputs)\n         };\n \n-        let (region, bounds) = {\n-            if self.eat(&token::COLON) {\n-                let (region, bounds) = self.parse_ty_param_bounds(true);\n-                (region, Some(bounds))\n-            } else {\n-                (None, None)\n-            }\n-        };\n+        let bounds = self.parse_colon_then_ty_param_bounds();\n \n         let (return_style, output) = self.parse_ret_ty();\n         let decl = P(FnDecl {\n@@ -1199,7 +1188,7 @@ impl<'a> Parser<'a> {\n                     bounds: bounds,\n                     decl: decl,\n                     lifetimes: lifetime_defs,\n-                }, region)\n+                })\n             }\n         }\n     }\n@@ -1687,7 +1676,7 @@ impl<'a> Parser<'a> {\n             Some(INTERPOLATED(token::NtPath(box path))) => {\n                 return PathAndBounds {\n                     path: path,\n-                    bounds: None,\n+                    bounds: None\n                 }\n             }\n             _ => {}\n@@ -1744,25 +1733,31 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        // Next, parse a plus and bounded type parameters, if applicable.\n-        let bounds = if mode == LifetimeAndTypesAndBounds {\n-            let bounds = {\n-                if self.eat(&token::BINOP(token::PLUS)) {\n-                    let (_, bounds) = self.parse_ty_param_bounds(false);\n-                    if bounds.len() == 0 {\n-                        let last_span = self.last_span;\n-                        self.span_err(last_span,\n-                                      \"at least one type parameter bound \\\n-                                       must be specified after the `+`\");\n-                    }\n-                    Some(bounds)\n-                } else {\n-                    None\n+        // Next, parse a plus and bounded type parameters, if\n+        // applicable. We need to remember whether the separate was\n+        // present for later, because in some contexts it's a parse\n+        // error.\n+        let opt_bounds = {\n+            if mode == LifetimeAndTypesAndBounds &&\n+                self.eat(&token::BINOP(token::PLUS))\n+            {\n+                let bounds = self.parse_ty_param_bounds();\n+\n+                // For some reason that I do not fully understand, we\n+                // do not permit an empty list in the case where it is\n+                // introduced by a `+`, but we do for `:` and other\n+                // separators. -nmatsakis\n+                if bounds.len() == 0 {\n+                    let last_span = self.last_span;\n+                    self.span_err(last_span,\n+                                  \"at least one type parameter bound \\\n+                                   must be specified\");\n                 }\n-            };\n-            bounds\n-        } else {\n-            None\n+\n+                Some(bounds)\n+            } else {\n+                None\n+            }\n         };\n \n         // Assemble the span.\n@@ -1775,7 +1770,7 @@ impl<'a> Parser<'a> {\n                 global: is_global,\n                 segments: segments,\n             },\n-            bounds: bounds,\n+            bounds: opt_bounds,\n         }\n     }\n \n@@ -3604,45 +3599,34 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// matches optbounds = ( ( : ( boundseq )? )? )\n-    /// where   boundseq  = ( bound + boundseq ) | bound\n-    /// and     bound     = 'static | ty\n-    /// Returns \"None\" if there's no colon (e.g. \"T\");\n-    /// Returns \"Some(Empty)\" if there's a colon but nothing after (e.g. \"T:\")\n-    /// Returns \"Some(stuff)\" otherwise (e.g. \"T:stuff\").\n-    /// NB: The None/Some distinction is important for issue #7264.\n-    ///\n-    /// Note that the `allow_any_lifetime` argument is a hack for now while the\n-    /// AST doesn't support arbitrary lifetimes in bounds on type parameters. In\n-    /// the future, this flag should be removed, and the return value of this\n-    /// function should be Option<~[TyParamBound]>\n-    fn parse_ty_param_bounds(&mut self, allow_any_lifetime: bool)\n-                             -> (Option<ast::Lifetime>,\n-                                 OwnedSlice<TyParamBound>) {\n-        let mut ret_lifetime = None;\n+    // Parses a sequence of bounds if a `:` is found,\n+    // otherwise returns empty list.\n+    fn parse_colon_then_ty_param_bounds(&mut self)\n+                                        -> OwnedSlice<TyParamBound>\n+    {\n+        if !self.eat(&token::COLON) {\n+            OwnedSlice::empty()\n+        } else {\n+            self.parse_ty_param_bounds()\n+        }\n+    }\n+\n+    // matches bounds    = ( boundseq )?\n+    // where   boundseq  = ( bound + boundseq ) | bound\n+    // and     bound     = 'region | ty\n+    // NB: The None/Some distinction is important for issue #7264.\n+    fn parse_ty_param_bounds(&mut self)\n+                             -> OwnedSlice<TyParamBound>\n+    {\n         let mut result = vec!();\n         loop {\n             match self.token {\n                 token::LIFETIME(lifetime) => {\n-                    let lifetime_interned_string = token::get_ident(lifetime);\n-                    if lifetime_interned_string.equiv(&(\"'static\")) {\n-                        result.push(StaticRegionTyParamBound);\n-                        if allow_any_lifetime && ret_lifetime.is_none() {\n-                            ret_lifetime = Some(ast::Lifetime {\n-                                id: ast::DUMMY_NODE_ID,\n-                                span: self.span,\n-                                name: lifetime.name\n-                            });\n-                        }\n-                    } else if allow_any_lifetime && ret_lifetime.is_none() {\n-                        ret_lifetime = Some(ast::Lifetime {\n-                            id: ast::DUMMY_NODE_ID,\n-                            span: self.span,\n-                            name: lifetime.name\n-                        });\n-                    } else {\n-                        result.push(OtherRegionTyParamBound(self.span));\n-                    }\n+                    result.push(RegionTyParamBound(ast::Lifetime {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: self.span,\n+                        name: lifetime.name\n+                    }));\n                     self.bump();\n                 }\n                 token::MOD_SEP | token::IDENT(..) => {\n@@ -3662,7 +3646,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return (ret_lifetime, OwnedSlice::from_vec(result));\n+        return OwnedSlice::from_vec(result);\n     }\n \n     fn trait_ref_from_ident(ident: Ident, span: Span) -> ast::TraitRef {\n@@ -3699,16 +3683,7 @@ impl<'a> Parser<'a> {\n             ident = self.parse_ident();\n         }\n \n-        let opt_bounds = {\n-            if self.eat(&token::COLON) {\n-                let (_, bounds) = self.parse_ty_param_bounds(false);\n-                Some(bounds)\n-            } else {\n-                None\n-            }\n-        };\n-        // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n-        let bounds = opt_bounds.unwrap_or_default();\n+        let bounds = self.parse_colon_then_ty_param_bounds();\n \n         let default = if self.token == token::EQ {\n             self.bump();\n@@ -3797,7 +3772,7 @@ impl<'a> Parser<'a> {\n             };\n             self.expect(&token::COLON);\n \n-            let (_, bounds) = self.parse_ty_param_bounds(false);\n+            let bounds = self.parse_ty_param_bounds();\n             let hi = self.span.hi;\n             let span = mk_sp(lo, hi);\n \n@@ -4273,19 +4248,13 @@ impl<'a> Parser<'a> {\n         let mut tps = self.parse_generics();\n         let sized = self.parse_for_sized();\n \n-        // Parse traits, if necessary.\n-        let traits;\n-        if self.token == token::COLON {\n-            self.bump();\n-            traits = self.parse_trait_ref_list(&token::LBRACE);\n-        } else {\n-            traits = Vec::new();\n-        }\n+        // Parse supertrait bounds.\n+        let bounds = self.parse_colon_then_ty_param_bounds();\n \n         self.parse_where_clause(&mut tps);\n \n         let meths = self.parse_trait_methods();\n-        (ident, ItemTrait(tps, sized, traits, meths), None)\n+        (ident, ItemTrait(tps, sized, bounds, meths), None)\n     }\n \n     fn parse_impl_items(&mut self) -> (Vec<ImplItem>, Vec<Attribute>) {\n@@ -4319,12 +4288,10 @@ impl<'a> Parser<'a> {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n                 TyPath(ref path, None, node_id) => {\n-                    Some(TraitRef {\n-                        path: /* bad */ (*path).clone(),\n-                        ref_id: node_id\n-                    })\n+                    Some(TraitRef { path: (*path).clone(),\n+                                    ref_id: node_id })\n                 }\n-                TyPath(..) => {\n+                TyPath(_, Some(_), _) => {\n                     self.span_err(ty.span,\n                                   \"bounded traits are only valid in type position\");\n                     None\n@@ -4359,15 +4326,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse B + C<String,int> + D\n-    fn parse_trait_ref_list(&mut self, ket: &token::Token) -> Vec<TraitRef> {\n-        self.parse_seq_to_before_end(\n-            ket,\n-            seq_sep_trailing_disallowed(token::BINOP(token::PLUS)),\n-            |p| p.parse_trait_ref()\n-        )\n-    }\n-\n     /// Parse struct Foo { ... }\n     fn parse_item_struct(&mut self, is_virtual: bool) -> ItemInfo {\n         let class_name = self.parse_ident();"}, {"sha": "70da4e11961f9e39750ee6db1a168eb471b93b85", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -155,7 +155,7 @@ pub struct PrintStackElem {\n \n static SIZE_INFINITY: int = 0xffff;\n \n-pub fn mk_printer(out: Box<io::Writer>, linewidth: uint) -> Printer {\n+pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: uint) -> Printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3 * linewidth;\n@@ -260,7 +260,7 @@ pub fn mk_printer(out: Box<io::Writer>, linewidth: uint) -> Printer {\n /// the method called 'pretty_print', and the 'PRINT' process is the method\n /// called 'print'.\n pub struct Printer {\n-    pub out: Box<io::Writer>,\n+    pub out: Box<io::Writer+'static>,\n     buf_len: uint,\n     /// Width of lines we're constrained to\n     margin: int,"}, {"sha": "da265d8125088242b8bc4f968350efe29b2a642a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 49, "deletions": 90, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -10,8 +10,8 @@\n \n use abi;\n use ast::{FnMutUnboxedClosureKind, FnOnceUnboxedClosureKind};\n-use ast::{FnUnboxedClosureKind, MethodImplItem, P, OtherRegionTyParamBound};\n-use ast::{StaticRegionTyParamBound, TraitTyParamBound, UnboxedClosureKind};\n+use ast::{FnUnboxedClosureKind, MethodImplItem, P};\n+use ast::{RegionTyParamBound, TraitTyParamBound, UnboxedClosureKind};\n use ast::{UnboxedFnTyParamBound, RequiredMethod, ProvidedMethod};\n use ast;\n use ast_util;\n@@ -60,16 +60,16 @@ pub struct State<'a> {\n     literals: Option<Vec<comments::Literal> >,\n     cur_cmnt_and_lit: CurrentCommentAndLiteral,\n     boxes: Vec<pp::Breaks>,\n-    ann: &'a PpAnn,\n+    ann: &'a PpAnn+'a,\n     encode_idents_with_hygiene: bool,\n }\n \n-pub fn rust_printer(writer: Box<io::Writer>) -> State<'static> {\n+pub fn rust_printer(writer: Box<io::Writer+'static>) -> State<'static> {\n     static NO_ANN: NoAnn = NoAnn;\n     rust_printer_annotated(writer, &NO_ANN)\n }\n \n-pub fn rust_printer_annotated<'a>(writer: Box<io::Writer>,\n+pub fn rust_printer_annotated<'a>(writer: Box<io::Writer+'static>,\n                                   ann: &'a PpAnn) -> State<'a> {\n     State {\n         s: pp::mk_printer(writer, default_columns),\n@@ -98,7 +98,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        krate: &ast::Crate,\n                        filename: String,\n                        input: &mut io::Reader,\n-                       out: Box<io::Writer>,\n+                       out: Box<io::Writer+'static>,\n                        ann: &'a PpAnn,\n                        is_expanded: bool) -> IoResult<()> {\n     let mut s = State::new_from_input(cm,\n@@ -118,7 +118,7 @@ impl<'a> State<'a> {\n                           span_diagnostic: &diagnostic::SpanHandler,\n                           filename: String,\n                           input: &mut io::Reader,\n-                          out: Box<io::Writer>,\n+                          out: Box<io::Writer+'static>,\n                           ann: &'a PpAnn,\n                           is_expanded: bool) -> State<'a> {\n         let (cmnts, lits) = comments::gather_comments_and_literals(\n@@ -138,7 +138,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn new(cm: &'a CodeMap,\n-               out: Box<io::Writer>,\n+               out: Box<io::Writer+'static>,\n                ann: &'a PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n                literals: Option<Vec<comments::Literal>>) -> State<'a> {\n@@ -594,17 +594,16 @@ impl<'a> State<'a> {\n                 };\n                 try!(self.print_ty_fn(Some(f.abi),\n                                       None,\n-                                      &None,\n                                       f.fn_style,\n                                       ast::Many,\n                                       &*f.decl,\n                                       None,\n-                                      &None,\n+                                      &OwnedSlice::empty(),\n                                       Some(&generics),\n                                       None,\n                                       None));\n             }\n-            ast::TyClosure(f, ref region) => {\n+            ast::TyClosure(f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n                     ty_params: OwnedSlice::empty(),\n@@ -615,7 +614,6 @@ impl<'a> State<'a> {\n                 };\n                 try!(self.print_ty_fn(None,\n                                       Some('&'),\n-                                      region,\n                                       f.fn_style,\n                                       f.onceness,\n                                       &*f.decl,\n@@ -636,7 +634,6 @@ impl<'a> State<'a> {\n                 };\n                 try!(self.print_ty_fn(None,\n                                       Some('~'),\n-                                      &None,\n                                       f.fn_style,\n                                       f.onceness,\n                                       &*f.decl,\n@@ -649,12 +646,11 @@ impl<'a> State<'a> {\n             ast::TyUnboxedFn(f) => {\n                 try!(self.print_ty_fn(None,\n                                       None,\n-                                      &None,\n                                       ast::NormalFn,\n                                       ast::Many,\n                                       &*f.decl,\n                                       None,\n-                                      &None,\n+                                      &OwnedSlice::empty(),\n                                       None,\n                                       None,\n                                       Some(f.kind)));\n@@ -837,7 +833,7 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemTrait(ref generics, ref unbound, ref traits, ref methods) => {\n+            ast::ItemTrait(ref generics, ref unbound, ref bounds, ref methods) => {\n                 try!(self.head(visibility_qualified(item.vis,\n                                                     \"trait\").as_slice()));\n                 try!(self.print_ident(item.ident));\n@@ -851,16 +847,7 @@ impl<'a> State<'a> {\n                     }\n                     _ => {}\n                 }\n-                if traits.len() != 0u {\n-                    try!(word(&mut self.s, \":\"));\n-                    for (i, trait_) in traits.iter().enumerate() {\n-                        try!(self.nbsp());\n-                        if i != 0 {\n-                            try!(self.word_space(\"+\"));\n-                        }\n-                        try!(self.print_path(&trait_.path, false));\n-                    }\n-                }\n+                try!(self.print_bounds(\":\", bounds));\n                 try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n@@ -1073,12 +1060,11 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(m.attrs.as_slice()));\n         try!(self.print_ty_fn(None,\n                               None,\n-                              &None,\n                               m.fn_style,\n                               ast::Many,\n                               &*m.decl,\n                               Some(m.ident),\n-                              &None,\n+                              &OwnedSlice::empty(),\n                               Some(&m.generics),\n                               Some(m.explicit_self.node),\n                               None));\n@@ -1808,7 +1794,7 @@ impl<'a> State<'a> {\n \n         match *opt_bounds {\n             None => Ok(()),\n-            Some(ref bounds) => self.print_bounds(&None, bounds, true, true),\n+            Some(ref bounds) => self.print_bounds(\"+\", bounds)\n         }\n     }\n \n@@ -2132,30 +2118,12 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_bounds(&mut self,\n-                        region: &Option<ast::Lifetime>,\n-                        bounds: &OwnedSlice<ast::TyParamBound>,\n-                        print_colon_anyway: bool,\n-                        print_plus_before_bounds: bool)\n+                        prefix: &str,\n+                        bounds: &OwnedSlice<ast::TyParamBound>)\n                         -> IoResult<()> {\n-        let separator = if print_plus_before_bounds {\n-            \"+\"\n-        } else {\n-            \":\"\n-        };\n-        if !bounds.is_empty() || region.is_some() {\n-            try!(word(&mut self.s, separator));\n+        if !bounds.is_empty() {\n+            try!(word(&mut self.s, prefix));\n             let mut first = true;\n-            match *region {\n-                Some(ref lt) => {\n-                    let token = token::get_name(lt.name);\n-                    if token.get() != \"'static\" {\n-                        try!(self.nbsp());\n-                        first = false;\n-                        try!(self.print_lifetime(lt));\n-                    }\n-                }\n-                None => {}\n-            }\n             for bound in bounds.iter() {\n                 try!(self.nbsp());\n                 if first {\n@@ -2165,27 +2133,27 @@ impl<'a> State<'a> {\n                 }\n \n                 try!(match *bound {\n-                    TraitTyParamBound(ref tref) => self.print_trait_ref(tref),\n-                    StaticRegionTyParamBound => word(&mut self.s, \"'static\"),\n+                    TraitTyParamBound(ref tref) => {\n+                        self.print_trait_ref(tref)\n+                    }\n+                    RegionTyParamBound(ref lt) => {\n+                        self.print_lifetime(lt)\n+                    }\n                     UnboxedFnTyParamBound(ref unboxed_function_type) => {\n                         self.print_ty_fn(None,\n                                          None,\n-                                         &None,\n                                          ast::NormalFn,\n                                          ast::Many,\n                                          &*unboxed_function_type.decl,\n                                          None,\n-                                         &None,\n+                                         &OwnedSlice::empty(),\n                                          None,\n                                          None,\n                                          Some(unboxed_function_type.kind))\n                     }\n-                    OtherRegionTyParamBound(_) => Ok(())\n                 })\n             }\n             Ok(())\n-        } else if print_colon_anyway {\n-            word(&mut self.s, separator)\n         } else {\n             Ok(())\n         }\n@@ -2212,23 +2180,29 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_type_parameters(&mut self,\n-                             lifetimes: &[ast::LifetimeDef],\n-                             ty_params: &[ast::TyParam])\n-                             -> IoResult<()> {\n-        let total = lifetimes.len() + ty_params.len();\n+    pub fn print_generics(&mut self,\n+                          generics: &ast::Generics)\n+                          -> IoResult<()>\n+    {\n+        let total = generics.lifetimes.len() + generics.ty_params.len();\n+        if total == 0 {\n+            return Ok(());\n+        }\n+\n+        try!(word(&mut self.s, \"<\"));\n+\n         let mut ints = Vec::new();\n         for i in range(0u, total) {\n             ints.push(i);\n         }\n \n-        self.commasep(Inconsistent, ints.as_slice(), |s, &idx| {\n-            if idx < lifetimes.len() {\n-                let lifetime = &lifetimes[idx];\n+        try!(self.commasep(Inconsistent, ints.as_slice(), |s, &idx| {\n+            if idx < generics.lifetimes.len() {\n+                let lifetime = generics.lifetimes.get(idx);\n                 s.print_lifetime_def(lifetime)\n             } else {\n-                let idx = idx - lifetimes.len();\n-                let param = &ty_params[idx];\n+                let idx = idx - generics.lifetimes.len();\n+                let param = generics.ty_params.get(idx);\n                 match param.unbound {\n                     Some(TraitTyParamBound(ref tref)) => {\n                         try!(s.print_trait_ref(tref));\n@@ -2237,10 +2211,7 @@ impl<'a> State<'a> {\n                     _ => {}\n                 }\n                 try!(s.print_ident(param.ident));\n-                try!(s.print_bounds(&None,\n-                                    &param.bounds,\n-                                    false,\n-                                    false));\n+                try!(s.print_bounds(\":\", &param.bounds));\n                 match param.default {\n                     Some(ref default) => {\n                         try!(space(&mut s.s));\n@@ -2250,19 +2221,10 @@ impl<'a> State<'a> {\n                     _ => Ok(())\n                 }\n             }\n-        })\n-    }\n+        }));\n \n-    pub fn print_generics(&mut self, generics: &ast::Generics)\n-                          -> IoResult<()> {\n-        if generics.lifetimes.len() + generics.ty_params.len() > 0 {\n-            try!(word(&mut self.s, \"<\"));\n-            try!(self.print_type_parameters(generics.lifetimes.as_slice(),\n-                                            generics.ty_params.as_slice()));\n-            word(&mut self.s, \">\")\n-        } else {\n-            Ok(())\n-        }\n+        try!(word(&mut self.s, \">\"));\n+        Ok(())\n     }\n \n     pub fn print_where_clause(&mut self, generics: &ast::Generics)\n@@ -2283,7 +2245,7 @@ impl<'a> State<'a> {\n             }\n \n             try!(self.print_ident(predicate.ident));\n-            try!(self.print_bounds(&None, &predicate.bounds, false, false));\n+            try!(self.print_bounds(\":\", &predicate.bounds));\n         }\n \n         Ok(())\n@@ -2421,12 +2383,11 @@ impl<'a> State<'a> {\n     pub fn print_ty_fn(&mut self,\n                        opt_abi: Option<abi::Abi>,\n                        opt_sigil: Option<char>,\n-                       opt_region: &Option<ast::Lifetime>,\n                        fn_style: ast::FnStyle,\n                        onceness: ast::Onceness,\n                        decl: &ast::FnDecl,\n                        id: Option<ast::Ident>,\n-                       opt_bounds: &Option<OwnedSlice<ast::TyParamBound>>,\n+                       bounds: &OwnedSlice<ast::TyParamBound>,\n                        generics: Option<&ast::Generics>,\n                        opt_explicit_self: Option<ast::ExplicitSelf_>,\n                        opt_unboxed_closure_kind:\n@@ -2495,9 +2456,7 @@ impl<'a> State<'a> {\n             try!(self.pclose());\n         }\n \n-        opt_bounds.as_ref().map(|bounds| {\n-            self.print_bounds(opt_region, bounds, true, false)\n-        });\n+        try!(self.print_bounds(\":\", bounds));\n \n         try!(self.maybe_print_comment(decl.output.span.lo));\n "}, {"sha": "7a35d82b0e430fc8f56f82612ca77c494afc7dc7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -298,13 +298,9 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n                                      item.id,\n                                      env.clone())\n         }\n-        ItemTrait(ref generics, _, ref trait_paths, ref methods) => {\n+        ItemTrait(ref generics, _, ref bounds, ref methods) => {\n             visitor.visit_generics(generics, env.clone());\n-            for trait_path in trait_paths.iter() {\n-                visitor.visit_path(&trait_path.path,\n-                                   trait_path.ref_id,\n-                                   env.clone())\n-            }\n+            walk_ty_param_bounds(visitor, bounds, env.clone());\n             for method in methods.iter() {\n                 visitor.visit_trait_item(method, env.clone())\n             }\n@@ -375,18 +371,13 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n                 visitor.visit_ty(&*tuple_element_type, env.clone())\n             }\n         }\n-        TyClosure(ref function_declaration, ref region) => {\n+        TyClosure(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&*argument.ty, env.clone())\n             }\n             visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n-            for bounds in function_declaration.bounds.iter() {\n-                walk_ty_param_bounds(visitor, bounds, env.clone())\n-            }\n-            visitor.visit_opt_lifetime_ref(\n-                typ.span,\n-                region,\n-                env.clone());\n+            walk_ty_param_bounds(visitor, &function_declaration.bounds,\n+                                 env.clone());\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n                                 env.clone());\n         }\n@@ -395,9 +386,8 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n                 visitor.visit_ty(&*argument.ty, env.clone())\n             }\n             visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n-            for bounds in function_declaration.bounds.iter() {\n-                walk_ty_param_bounds(visitor, bounds, env.clone())\n-            }\n+            walk_ty_param_bounds(visitor, &function_declaration.bounds,\n+                                 env.clone());\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n                                 env.clone());\n         }\n@@ -415,10 +405,13 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n             }\n             visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n         }\n-        TyPath(ref path, ref bounds, id) => {\n+        TyPath(ref path, ref opt_bounds, id) => {\n             visitor.visit_path(path, id, env.clone());\n-            for bounds in bounds.iter() {\n-                walk_ty_param_bounds(visitor, bounds, env.clone())\n+            match *opt_bounds {\n+                Some(ref bounds) => {\n+                    walk_ty_param_bounds(visitor, bounds, env.clone());\n+                }\n+                None => { }\n             }\n         }\n         TyFixedLengthVec(ref ty, ref expression) => {\n@@ -532,15 +525,16 @@ pub fn walk_ty_param_bounds<E: Clone, V: Visitor<E>>(visitor: &mut V,\n             TraitTyParamBound(ref typ) => {\n                 walk_trait_ref_helper(visitor, typ, env.clone())\n             }\n-            StaticRegionTyParamBound => {}\n             UnboxedFnTyParamBound(ref function_declaration) => {\n                 for argument in function_declaration.decl.inputs.iter() {\n                     visitor.visit_ty(&*argument.ty, env.clone())\n                 }\n                 visitor.visit_ty(&*function_declaration.decl.output,\n                                  env.clone());\n             }\n-            OtherRegionTyParamBound(..) => {}\n+            RegionTyParamBound(ref lifetime) => {\n+                visitor.visit_lifetime_ref(lifetime, env.clone());\n+            }\n         }\n     }\n }"}, {"sha": "4790e3833b72f1e9d4ba18d4af21bdee1c6dfd28", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -135,10 +135,10 @@ pub trait TDynBenchFn {\n pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut Bencher)),\n-    StaticMetricFn(proc(&mut MetricMap)),\n+    StaticMetricFn(proc(&mut MetricMap):'static),\n     DynTestFn(proc():Send),\n-    DynMetricFn(proc(&mut MetricMap)),\n-    DynBenchFn(Box<TDynBenchFn>)\n+    DynMetricFn(proc(&mut MetricMap):'static),\n+    DynBenchFn(Box<TDynBenchFn+'static>)\n }\n \n impl TestFn {"}, {"sha": "1cba738c56406c08c63ea7a50a8daa9beece7fef", "filename": "src/test/auxiliary/issue-2380.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2380.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -14,8 +14,8 @@\n \n pub trait i<T> { }\n \n-pub fn f<T>() -> Box<i<T>> {\n+pub fn f<T>() -> Box<i<T>+'static> {\n     impl<T> i<T> for () { }\n \n-    box() () as Box<i<T>>\n+    box() () as Box<i<T>+'static>\n }"}, {"sha": "18b464bd924e9b8e8a579f8f1035619527040c34", "filename": "src/test/auxiliary/issue-7178.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fauxiliary%2Fissue-7178.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fauxiliary%2Fissue-7178.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-7178.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct Foo<'a, A>(&'a A);\n+pub struct Foo<'a, A:'a>(&'a A);\n \n impl<'a, A> Foo<'a, A> {\n     pub fn new(a: &'a A) -> Foo<'a, A> {"}, {"sha": "0a9cfb5884fcf7bad1f7a6433810c825e5fe98cd", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -40,7 +40,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n }\n \n fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n-                   -> Box<MacResult> {\n+                   -> Box<MacResult+'static> {\n     if !tts.is_empty() {\n         cx.span_fatal(sp, \"make_a_1 takes no arguments\");\n     }\n@@ -49,7 +49,7 @@ fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n \n // See Issue #15750\n fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n-                   -> Box<MacResult> {\n+                   -> Box<MacResult+'static> {\n     // Parse an expression and emit it unchanged.\n     let mut parser = parse::new_parser_from_tts(cx.parse_sess(),\n         cx.cfg(), Vec::from_slice(tts));\n@@ -65,7 +65,7 @@ fn expand_into_foo(cx: &mut ExtCtxt, sp: Span, attr: Gc<MetaItem>, it: Gc<Item>)\n     }\n }\n \n-fn expand_forged_ident(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult> {\n+fn expand_forged_ident(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult+'static> {\n     use syntax::ext::quote::rt::*;\n \n     if !tts.is_empty() {"}, {"sha": "a7429ca534bdf07f62458ac20e9cba7ad837dc0a", "filename": "src/test/auxiliary/regions-bounded-method-type-parameters-cross-crate-lib.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fauxiliary%2Fregions-bounded-method-type-parameters-cross-crate-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fauxiliary%2Fregions-bounded-method-type-parameters-cross-crate-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fregions-bounded-method-type-parameters-cross-crate-lib.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that method bounds declared on traits/impls in a cross-crate\n+// scenario work. This is the libary portion of the test.\n+\n+pub enum MaybeOwned<'a> {\n+    Owned(int),\n+    Borrowed(&'a int)\n+}\n+\n+struct Inv<'a> { // invariant w/r/t 'a\n+    x: &'a mut &'a int\n+}\n+\n+// I encountered a bug at some point with encoding the IntoMaybeOwned\n+// trait, so I'll use that as the template for this test.\n+pub trait IntoMaybeOwned<'a> {\n+    fn into_maybe_owned(self) -> MaybeOwned<'a>;\n+    fn bigger_region<'b:'a>(self, b: Inv<'b>);\n+}\n+\n+impl<'a> IntoMaybeOwned<'a> for Inv<'a> {\n+    fn into_maybe_owned(self) -> MaybeOwned<'a> { fail!() }\n+    fn bigger_region<'b:'a>(self, b: Inv<'b>) { fail!() }\n+}"}, {"sha": "7a4339aa9f0428cc14e50417b9e7acb827b42f44", "filename": "src/test/auxiliary/syntax-extension-with-dll-deps-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fauxiliary%2Fsyntax-extension-with-dll-deps-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fauxiliary%2Fsyntax-extension-with-dll-deps-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsyntax-extension-with-dll-deps-2.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -29,7 +29,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n }\n \n fn expand_foo(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n-              -> Box<MacResult> {\n+              -> Box<MacResult+'static> {\n     let answer = other::the_answer();\n     MacExpr::new(quote_expr!(cx, $answer))\n }"}, {"sha": "03f986863240c90f3d1aa44a0984082e9867bdbd", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -77,7 +77,7 @@ struct AminoAcid {\n     p: f32,\n }\n \n-struct RepeatFasta<'a, W> {\n+struct RepeatFasta<'a, W:'a> {\n     alu: &'static str,\n     out: &'a mut W\n }\n@@ -126,7 +126,7 @@ fn make_lookup(a: &[AminoAcid]) -> [AminoAcid, ..LOOKUP_SIZE] {\n     lookup\n }\n \n-struct RandomFasta<'a, W> {\n+struct RandomFasta<'a, W:'a> {\n     seed: u32,\n     lookup: [AminoAcid, ..LOOKUP_SIZE],\n     out: &'a mut W,"}, {"sha": "c46c44abcd4c809f0ad5d461a4b2a476f6af5529", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -69,11 +69,11 @@ impl<'a, T> Iterator<T> for Iterate<'a, T> {\n }\n \n // a linked list using borrowed next.\n-enum List<'a, T> {\n+enum List<'a, T:'a> {\n     Nil,\n     Cons(T, &'a List<'a, T>)\n }\n-struct ListIterator<'a, T> {\n+struct ListIterator<'a, T:'a> {\n     cur: &'a List<'a, T>\n }\n impl<'a, T> List<'a, T> {"}, {"sha": "b63ecc6b66f2623dfb92c60b75669f384143426a", "filename": "src/test/compile-fail/bad-method-typaram-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo<T>() {\n+fn foo<T:'static>() {\n     1u.bar::<T>(); //~ ERROR: does not fulfill `Send`\n }\n "}, {"sha": "eb2ea6b3de42ffcf91120e764b8185d578033364", "filename": "src/test/compile-fail/borrowck-call-sendfn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct Foo {\n-    f: proc()\n+    f: proc():'static\n }\n \n fn call(x: Foo) {"}, {"sha": "bbb58e211988ec115c61fee884cd1735907a4747", "filename": "src/test/compile-fail/borrowck-object-lifetime.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,17 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that borrows that occur due to calls to object methods\n+// properly \"claim\" the object path.\n \n trait Foo {\n     fn borrowed(&self) -> &();\n+    fn mut_borrowed(&mut self) -> &();\n }\n \n-fn borrowed_receiver(x: &Foo) -> &() {\n-    x.borrowed()\n+fn borrowed_receiver(x: &Foo) {\n+    let _y = x.borrowed();\n+    let _z = x.borrowed();\n }\n \n-fn owned_receiver(x: Box<Foo>) -> &'static () {\n-    x.borrowed() //~ ERROR `*x` does not live long enough\n+fn mut_borrowed_receiver(x: &mut Foo) {\n+    let _y = x.borrowed();\n+    let _z = x.mut_borrowed(); //~ ERROR cannot borrow\n }\n \n fn mut_owned_receiver(mut x: Box<Foo>) {"}, {"sha": "29ee79b0079c32839a36fa083c3d3cf4a287de2e", "filename": "src/test/compile-fail/box-static-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fbox-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fbox-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbox-static-bound.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -12,7 +12,7 @@\n use std::gc::{Gc, GC};\n \n fn f<T>(x: T) -> Gc<T> {\n-    box(GC) x  //~ ERROR value may contain references\n+    box(GC) x  //~ ERROR the parameter type `T` may not live long enough\n }\n \n fn g<T:'static>(x: T) -> Gc<T> {"}, {"sha": "726413981a5f1931d032e08c45ea9b6c99689c13", "filename": "src/test/compile-fail/builtin-superkinds-self-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -11,7 +11,7 @@\n // Tests (negatively) the ability for the Self type in default methods\n // to use capabilities granted by builtin kinds as supertraits.\n \n-trait Foo : Sync {\n+trait Foo : Sync+'static {\n     fn foo(self, mut chan: Sender<Self>) {\n         chan.send(self); //~ ERROR does not fulfill `Send`\n     }"}, {"sha": "1ff9dc9dac4c296315b271d3660ab22e344f9d14", "filename": "src/test/compile-fail/closure-bounds-cant-promote-superkind-in-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -13,7 +13,7 @@ struct X {\n }\n \n fn foo(blk: ||:'static) -> X {\n-    return X { field: blk }; //~ ERROR expected bounds `'static+Send`\n+    return X { field: blk }; //~ ERROR expected bounds `Send`\n }\n \n fn main() {"}, {"sha": "c0b463535d4c33290eea27cf8f4109daf38bbfcd", "filename": "src/test/compile-fail/closure-bounds-static-cant-capture-borrowed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -12,8 +12,8 @@ fn bar(blk: ||:'static) {\n }\n \n fn foo(x: &()) {\n-    bar(|| { //~ ERROR cannot infer an appropriate lifetime\n-        let _ = x;\n+    bar(|| {\n+        let _ = x; //~ ERROR captured variable `x` does not outlive\n     })\n }\n "}, {"sha": "5bd9f20dd834368d7913a6c691360b25c841af78", "filename": "src/test/compile-fail/closure-bounds-subtype.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n \n-fn take_any(_: ||:) {\n+fn take_any(_: ||) {\n }\n \n fn take_const_owned(_: ||:Sync+Send) {\n }\n \n-fn give_any(f: ||:) {\n+fn give_any(f: ||) {\n     take_any(f);\n }\n "}, {"sha": "af4c12c754b9633a5a98f0d91da2d2874ff26536", "filename": "src/test/compile-fail/drop-on-non-struct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -14,7 +14,6 @@ type Foo = Vec<u8>;\n \n impl Drop for Foo {\n //~^ ERROR cannot provide an extension implementation\n-//~^^ ERROR multiple applicable methods\n     fn drop(&mut self) {\n         println!(\"kaboom\");\n     }"}, {"sha": "aa7e3cd3739b2765d218342f1dc6e4d83b9715a8", "filename": "src/test/compile-fail/issue-12470.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-12470.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-12470.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12470.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -24,7 +24,7 @@ impl X for B {\n }\n \n struct A<'a> {\n-    p: &'a X\n+    p: &'a X+'a\n }\n \n fn make_a<'a>(p: &'a X) -> A<'a> {", "previous_filename": "src/test/compile-fail/isuue-12470.rs"}, {"sha": "624ddf0c8bbdc041d06ee2947cfb97aacf26f263", "filename": "src/test/compile-fail/issue-14285.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-14285.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-14285.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14285.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -14,7 +14,7 @@ struct A;\n \n impl Foo for A {}\n \n-struct B<'a>(&'a Foo);\n+struct B<'a>(&'a Foo+'a);\n \n fn foo<'a>(a: &Foo) -> B<'a> {\n     B(a)    //~ ERROR cannot infer an appropriate lifetime"}, {"sha": "5f55c550aeb3979de774361b0d5f1df0ebabe703", "filename": "src/test/compile-fail/issue-3154.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct thing<'a, Q> {\n+struct thing<'a, Q:'a> {\n     x: &'a Q\n }\n "}, {"sha": "71f91050256edc6a19fd8ce8ad7e52211b1721ac", "filename": "src/test/compile-fail/issue-3907-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -11,12 +11,12 @@\n // aux-build:issue_3907.rs\n extern crate issue_3907;\n \n-type Foo = issue_3907::Foo;\n+type Foo = issue_3907::Foo+'static;\n \n struct S {\n     name: int\n }\n \n-fn bar(_x: Foo) {} //~ ERROR variable `_x` has dynamically sized type `issue_3907::Foo`\n+fn bar(_x: Foo) {} //~ ERROR variable `_x` has dynamically sized type\n \n fn main() {}"}, {"sha": "ab2018af99900a65d213c16a20d258664f86a91c", "filename": "src/test/compile-fail/issue-3953.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -12,15 +12,9 @@\n \n use std::cmp::PartialEq;\n \n-trait Hahaha: PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + //~ ERROR duplicate supertrait\n-              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n-              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n-              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n-              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n-              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n-              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n-              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n-              PartialEq {}\n+trait Hahaha: PartialEq + PartialEq {\n+    //~^ ERROR trait `PartialEq` already appears in the list of bounds\n+}\n \n struct Lol(int);\n "}, {"sha": "bff167fa391d55f767ef85bb9bb904765589d914", "filename": "src/test/compile-fail/issue-4972.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -12,12 +12,12 @@\n trait MyTrait { }\n \n pub enum TraitWrapper {\n-    A(Box<MyTrait>),\n+    A(Box<MyTrait+'static>),\n }\n \n fn get_tw_map(tw: &TraitWrapper) -> &MyTrait {\n     match *tw {\n-        A(box ref map) => map, //~ ERROR type `Box<MyTrait>` cannot be dereferenced\n+        A(box ref map) => map, //~ ERROR cannot be dereferenced\n     }\n }\n "}, {"sha": "0251a06c5bd394d9e0cab975fff6e6ceeb3c48ed", "filename": "src/test/compile-fail/issue-5035-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n trait I {}\n-type K = I;\n+type K = I+'static;\n \n-fn foo(_x: K) {} //~ ERROR: variable `_x` has dynamically sized type `I`\n+fn foo(_x: K) {} //~ ERROR: variable `_x` has dynamically sized type\n \n fn main() {}"}, {"sha": "18af9736ed9f8408224d80d0c78095a9d1e0a189", "filename": "src/test/compile-fail/issue-5216.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n fn f() { }\n-struct S(||); //~ ERROR missing lifetime specifier\n+struct S(||); //~ ERROR explicit lifetime bound required\n pub static C: S = S(f);\n \n \n fn g() { }\n-type T = ||;  //~ ERROR missing lifetime specifier\n+type T = ||;  //~ ERROR explicit lifetime bound required\n pub static D: T = g;\n \n fn main() {}"}, {"sha": "f3bbb8051b76b6143fa711638053f19d248b8c03", "filename": "src/test/compile-fail/issue-5883.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -11,14 +11,14 @@\n trait A {}\n \n struct Struct {\n-    r: A\n+    r: A+'static\n }\n \n-fn new_struct(r: A) -> Struct {\n-    //~^ ERROR variable `r` has dynamically sized type `A`\n+fn new_struct(r: A+'static) -> Struct {\n+    //~^ ERROR variable `r` has dynamically sized type\n     Struct { r: r } //~ ERROR trying to initialise a dynamically sized struct\n }\n \n trait Curve {}\n-enum E {X(Curve)}\n+enum E {X(Curve+'static)}\n fn main() {}"}, {"sha": "4cc03ee3dcd445fbb9efa40a93b69753fecb19d7", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -28,7 +28,7 @@ fn f<T>(val: T) {\n fn main() {\n     let t: S<&int> = S;\n     let a = &t as &Gettable<&int>;\n-    //~^ ERROR instantiating a type parameter with an incompatible type `&int`\n+    //~^ ERROR instantiating a type parameter with an incompatible type\n     let t: Box<S<String>> = box S;\n     let a = t as Box<Gettable<String>>;\n     //~^ ERROR instantiating a type parameter with an incompatible type"}, {"sha": "57c8cc3da8aab721b4fbb646588c15ce3012c6b5", "filename": "src/test/compile-fail/kindck-proc-bounds.rs", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fkindck-proc-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fkindck-proc-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-proc-bounds.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -10,16 +10,13 @@\n \n fn is_send<T: Send>() {}\n fn is_freeze<T: Sync>() {}\n-fn is_static<T: 'static>() {}\n \n-fn main() {\n+fn foo<'a>() {\n     is_send::<proc()>();\n     //~^ ERROR: instantiating a type parameter with an incompatible type\n \n     is_freeze::<proc()>();\n     //~^ ERROR: instantiating a type parameter with an incompatible type\n-\n-    is_static::<proc()>();\n-    //~^ ERROR: instantiating a type parameter with an incompatible type\n }\n \n+fn main() { }", "previous_filename": "src/test/compile-fail/proc-bounds.rs"}, {"sha": "99519263923be5ba05423deac107f1c4df3d928f", "filename": "src/test/compile-fail/kindck-send-object.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test which of the builtin types are considered sendable. The tests\n+// in this file all test the \"kind\" violates detected during kindck.\n+// See all `regions-bounded-by-send.rs`\n+\n+fn assert_send<T:Send>() { }\n+trait Dummy { }\n+trait Message : Send { }\n+\n+// careful with object types, who knows what they close over...\n+\n+fn object_ref_with_static_bound_not_ok() {\n+    assert_send::<&'static Dummy+'static>(); //~ ERROR does not fulfill\n+}\n+\n+fn box_object_with_no_bound_not_ok<'a>() {\n+    assert_send::<Box<Dummy>>(); //~ ERROR does not fulfill\n+}\n+\n+fn proc_with_no_bound_not_ok<'a>() {\n+    assert_send::<proc()>(); //~ ERROR does not fulfill\n+}\n+\n+fn closure_with_no_bound_not_ok<'a>() {\n+    assert_send::<||:'static>(); //~ ERROR does not fulfill\n+}\n+\n+fn object_with_send_bound_ok() {\n+    assert_send::<&'static Dummy+Send>();\n+    assert_send::<Box<Dummy+Send>>();\n+    assert_send::<proc():Send>;\n+    assert_send::<||:Send>;\n+}\n+\n+fn main() { }"}, {"sha": "424c7a4e4303f3d2bb3fc8b3fb65585263606a79", "filename": "src/test/compile-fail/kindck-send.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3ee047ae1ffab454270bc1859b3beef3556ef8f9/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee047ae1ffab454270bc1859b3beef3556ef8f9/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs?ref=3ee047ae1ffab454270bc1859b3beef3556ef8f9", "patch": "@@ -1,60 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test which of the builtin types are considered sendable.\n-\n-\n-fn assert_send<T:Send>() { }\n-trait Dummy { }\n-\n-fn test<'a,T,U:Send>(_: &'a int) {\n-    // lifetime pointers with 'static lifetime are ok\n-    assert_send::<&'static int>();\n-    assert_send::<&'static str>();\n-    assert_send::<&'static [int]>();\n-\n-    // whether or not they are mutable\n-    assert_send::<&'static mut int>();\n-\n-    // otherwise lifetime pointers are not ok\n-    assert_send::<&'a int>(); //~ ERROR does not fulfill `Send`\n-    assert_send::<&'a str>(); //~ ERROR does not fulfill `Send`\n-    assert_send::<&'a [int]>(); //~ ERROR does not fulfill `Send`\n-\n-    // boxes are ok\n-    assert_send::<Box<int>>();\n-    assert_send::<String>();\n-    assert_send::<Vec<int> >();\n-\n-    // but not if they own a bad thing\n-    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill `Send`\n-\n-    // careful with object types, who knows what they close over...\n-    assert_send::<&'static Dummy>(); //~ ERROR does not fulfill `Send`\n-    assert_send::<&'a Dummy>(); //~ ERROR does not fulfill `Send`\n-    assert_send::<&'a Dummy+Send>(); //~ ERROR does not fulfill `Send`\n-    assert_send::<Box<Dummy>>(); //~ ERROR does not fulfill `Send`\n-\n-    // ...unless they are properly bounded\n-    assert_send::<&'static Dummy+Send>();\n-    assert_send::<Box<Dummy+Send>>();\n-\n-    // but closure and object types can have lifetime bounds which make\n-    // them not ok (FIXME #5121)\n-    // assert_send::<proc:'a()>(); // ERROR does not fulfill `Send`\n-    // assert_send::<Box<Dummy+'a>>(); // ERROR does not fulfill `Send`\n-\n-    // unsafe ptrs are ok unless they point at unsendable things\n-    assert_send::<*const int>();\n-    assert_send::<*const &'a int>(); //~ ERROR does not fulfill `Send`\n-}\n-\n-fn main() {\n-}"}, {"sha": "21bd676a225f7888ae8ddd0735bdbea5da334b7d", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-3.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+struct Bar<'x, 'y, 'z> { bar: &'y int, baz: int }\n+fn bar1<'a>(x: &Bar) -> (&'a int, &'a int, &'a int) {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar1<'b, 'c, 'a>(x: &'a Bar<'b, 'a, 'c>) -> (&'a int, &'a int, &'a int)\n+    (x.bar, &x.baz, &x.baz)\n+    //~^ ERROR: cannot infer\n+    //~^^ ERROR: cannot infer\n+    //~^^^ ERROR: cannot infer\n+}\n+\n+fn bar2<'a, 'b, 'c>(x: &Bar<'a, 'b, 'c>) -> (&'a int, &'a int, &'a int) {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar2<'a, 'c>(x: &'a Bar<'a, 'a, 'c>) -> (&'a int, &'a int, &'a int)\n+    (x.bar, &x.baz, &x.baz)\n+    //~^ ERROR: cannot infer\n+    //~^^ ERROR: cannot infer\n+    //~^^^ ERROR: cannot infer\n+}\n+\n+fn main() { }"}, {"sha": "b7da4d73489bdd68f9500b0f27c9627ddc0ec2fb", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -33,21 +33,6 @@ fn foo4<'a, 'b>(x: &'a Foo) -> (&'b int, &'a int, &'b int) {\n     //~^ ERROR: cannot infer\n }\n \n-struct Bar<'x, 'y, 'z> { bar: &'y int, baz: int }\n-fn bar1<'a>(x: &Bar) -> (&'a int, &'a int, &'a int) {\n-//~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar1<'b, 'c, 'a>(x: &'a Bar<'b, 'a, 'c>) -> (&'a int, &'a int, &'a int)\n-    (x.bar, &x.baz, &x.baz) //~ ERROR: cannot infer\n-    //~^ ERROR: cannot infer\n-    //~^^ ERROR: cannot infer\n-}\n-\n-fn bar2<'a, 'b, 'c>(x: &Bar<'a, 'b, 'c>) -> (&'a int, &'a int, &'a int) {\n-//~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar2<'a, 'c>(x: &'a Bar<'a, 'a, 'c>) -> (&'a int, &'a int, &'a int)\n-    (x.bar, &x.baz, &x.baz) //~ ERROR: cannot infer\n-    //~^ ERROR: cannot infer\n-    //~^^ ERROR: cannot infer\n-}\n-\n struct Cat<'x, T> { cat: &'x int, t: T }\n struct Dog<'y> { dog: &'y int }\n "}, {"sha": "74e5e6b12027f2e8bc2e1e7e06b62c0b01ca1881", "filename": "src/test/compile-fail/moves-sru-moved-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-type Noncopyable = proc();\n+type Noncopyable = proc():'static;\n \n struct Foo {\n     copied: int,"}, {"sha": "40cff3e466b7123eb8d85b1fe703b685183a3ce0", "filename": "src/test/compile-fail/region-bounds-on-objects-and-type-parameters.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test related to when a region bound is required to be specified.\n+\n+trait IsStatic : 'static { }\n+trait IsSend : Send { }\n+trait Is<'a> : 'a { }\n+trait Is2<'a> : 'a { }\n+trait SomeTrait { }\n+\n+// Bounds on object types:\n+\n+struct Foo<'a,'b,'c> {\n+    // All of these are ok, because we can derive exactly one bound:\n+    a: Box<IsStatic>,\n+    b: Box<Is<'static>>,\n+    c: Box<Is<'a>>,\n+    d: Box<IsSend>,\n+    e: Box<Is<'a>+Send>, // we can derive two bounds, but one is 'static, so ok\n+    f: Box<SomeTrait>, //~ ERROR explicit lifetime bound required\n+    g: Box<SomeTrait+'a>,\n+\n+    z: Box<Is<'a>+'b+'c>, //~ ERROR only a single explicit lifetime bound is permitted\n+}\n+\n+fn test<\n+    'a,\n+    'b,\n+    A:IsStatic,\n+    B:Is<'a>+Is2<'b>,    //~ ERROR ambiguous lifetime bound\n+    C:'b+Is<'a>+Is2<'b>,\n+    D:Is<'a>+Is2<'static>,\n+    E:'a+'b //~ ERROR only a single explicit lifetime bound is permitted\n+>() { }\n+\n+fn main() { }"}, {"sha": "01daeb628ef57082ec5cb074bcaa6f0333ed009f", "filename": "src/test/compile-fail/region-object-lifetime-1.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various tests related to testing how region inference works\n+// with respect to the object receivers.\n+\n+trait Foo {\n+    fn borrowed<'a>(&'a self) -> &'a ();\n+}\n+\n+// Here the receiver and return value all have the same lifetime,\n+// so no error results.\n+fn borrowed_receiver_same_lifetime<'a>(x: &'a Foo) -> &'a () {\n+    x.borrowed()\n+}\n+\n+// Borrowed receiver but two distinct lifetimes, we get an error.\n+fn borrowed_receiver_different_lifetimes<'a,'b>(x: &'a Foo) -> &'b () {\n+    x.borrowed() //~ ERROR cannot infer\n+}\n+\n+// Borrowed receiver with two distinct lifetimes, but we know that\n+// 'b:'a, hence &'a () is permitted.\n+fn borrowed_receiver_related_lifetimes<'a,'b>(x: &'a Foo+'b) -> &'a () {\n+    x.borrowed()\n+}\n+\n+// Here we have two distinct lifetimes, but we try to return a pointer\n+// with the longer lifetime when (from the signature) we only know\n+// that it lives as long as the shorter lifetime. Therefore, error.\n+fn borrowed_receiver_related_lifetimes2<'a,'b>(x: &'a Foo+'b) -> &'b () {\n+    x.borrowed() //~ ERROR cannot infer\n+}\n+\n+// Here, the object is bounded by an anonymous lifetime and returned\n+// as `&'static`, so you get an error.\n+fn owned_receiver(x: Box<Foo>) -> &'static () {\n+    x.borrowed() //~ ERROR cannot infer\n+}\n+\n+fn main() {}\n+"}, {"sha": "bb895a318ff17d272128783425d352b16278e6a0", "filename": "src/test/compile-fail/regionck-closure-lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -15,7 +15,7 @@ fn env<'a>(blk: |p: ||: 'a|) {\n \n     let mut state = 0i;\n     let statep = &mut state;\n-    blk(|| *statep = 1i); //~ ERROR cannot infer\n+    blk(|| *statep = 1i); //~ ERROR captured variable `statep` does not outlive\n }\n \n fn no_env_no_for<'a>(blk: |p: |||: 'a) {"}, {"sha": "7520a4c125a78b84d65119842065a7129560caa6", "filename": "src/test/compile-fail/regionck-unboxed-closure-lifetimes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -16,9 +16,8 @@ fn main() {\n     let mut f;\n     {\n         let c = 1;\n-        let c_ref = &c;\n+        let c_ref = &c; //~ ERROR `c` does not live long enough\n         f = |&mut: a: int, b: int| { a + b + *c_ref };\n-        //~^ ERROR cannot infer an appropriate lifetime\n     }\n }\n "}, {"sha": "0c9f5004f57872193f4845b533dd56f76b8d2caa", "filename": "src/test/compile-fail/regions-bound-missing-bound-in-impl.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that explicit region bounds are allowed on the various\n+// nominal types (but not on other types) and that they are type\n+// checked.\n+\n+#![no_std]\n+\n+struct Inv<'a> { // invariant w/r/t 'a\n+    x: &'a mut &'a int\n+}\n+\n+pub trait Foo<'a> {\n+    fn no_bound<'b>(self, b: Inv<'b>);\n+    fn has_bound<'b:'a>(self, b: Inv<'b>);\n+    fn wrong_bound1<'b,'c,'d:'a+'b>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>);\n+    fn wrong_bound2<'b,'c,'d:'a+'b+'c>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>);\n+}\n+\n+\n+impl<'a> Foo<'a> for &'a int {\n+    fn no_bound<'b:'a>(self, b: Inv<'b>) {\n+        //~^ ERROR lifetime parameters or bounds on method `no_bound` do not match\n+    }\n+\n+    fn has_bound<'b>(self, b: Inv<'b>) {\n+        //~^ ERROR lifetime parameters or bounds on method `has_bound` do not match\n+    }\n+\n+    fn wrong_bound1<'b,'c,'d:'a+'c>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>) {\n+        //~^ ERROR method `wrong_bound1` has an incompatible type for trait\n+        //\n+        // Note: This is a terrible error message. It is caused\n+        // because, in the trait, 'b is early bound, and in the impl,\n+        // 'c is early bound, so -- after substitution -- the\n+        // lifetimes themselves look isomorphic.  We fail because the\n+        // lifetimes that appear in the types are in the wrong\n+        // order. This should really be fixed by keeping more\n+        // information about the lifetime declarations in the trait so\n+        // that we can compare better to the impl, even in cross-crate\n+        // cases.\n+    }\n+\n+    fn wrong_bound2<'b,'c,'e:'b+'c>(self, b: Inv<'b>, c: Inv<'c>, e: Inv<'e>) {\n+        //~^ ERROR distinct set of bounds from its counterpart\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "3c7ffbc8d1fb179ce4e6f24e510812cd63a5a823", "filename": "src/test/compile-fail/regions-bounded-by-send.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test which of the builtin types are considered sendable. The tests\n+// in this file all test region bound and lifetime violations that are\n+// detected during type check.\n+\n+fn assert_send<T:Send>() { }\n+trait Dummy { }\n+\n+// lifetime pointers with 'static lifetime are ok\n+\n+fn static_lifime_ok<'a,T,U:Send>(_: &'a int) {\n+    assert_send::<&'static int>();\n+    assert_send::<&'static str>();\n+    assert_send::<&'static [int]>();\n+\n+    // whether or not they are mutable\n+    assert_send::<&'static mut int>();\n+}\n+\n+// otherwise lifetime pointers are not ok\n+\n+fn param_not_ok<'a>(x: &'a int) {\n+    assert_send::<&'a int>(); //~ ERROR does not fulfill\n+}\n+\n+fn param_not_ok1<'a>(_: &'a int) {\n+    assert_send::<&'a str>(); //~ ERROR does not fulfill\n+}\n+\n+fn param_not_ok2<'a>(_: &'a int) {\n+    assert_send::<&'a [int]>(); //~ ERROR does not fulfill\n+}\n+\n+// boxes are ok\n+\n+fn box_ok() {\n+    assert_send::<Box<int>>();\n+    assert_send::<String>();\n+    assert_send::<Vec<int>>();\n+}\n+\n+// but not if they own a bad thing\n+\n+fn box_with_region_not_ok<'a>() {\n+    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill\n+}\n+\n+// objects with insufficient bounds no ok\n+\n+fn object_with_random_bound_not_ok<'a>() {\n+    assert_send::<&'a Dummy+'a>(); //~ ERROR does not fulfill\n+}\n+\n+fn object_with_send_bound_not_ok<'a>() {\n+    assert_send::<&'a Dummy+Send>(); //~ ERROR does not fulfill\n+}\n+\n+fn proc_with_lifetime_not_ok<'a>() {\n+    assert_send::<proc():'a>(); //~ ERROR does not fulfill\n+}\n+\n+fn closure_with_lifetime_not_ok<'a>() {\n+    assert_send::<||:'a>(); //~ ERROR does not fulfill\n+}\n+\n+// unsafe pointers are ok unless they point at unsendable things\n+\n+fn unsafe_ok1<'a>(_: &'a int) {\n+    assert_send::<*const int>();\n+    assert_send::<*mut int>();\n+}\n+\n+fn unsafe_ok2<'a>(_: &'a int) {\n+    assert_send::<*const &'a int>(); //~ ERROR does not fulfill\n+}\n+\n+fn unsafe_ok3<'a>(_: &'a int) {\n+    assert_send::<*mut &'a int>(); //~ ERROR does not fulfill\n+}\n+\n+fn main() {\n+}"}, {"sha": "04a94b75215a7a9950bb8fc62208eaea4a34558c", "filename": "src/test/compile-fail/regions-bounded-by-trait-requiring-static.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test which of the builtin types are considered sendable. The tests\n+// in this file all test region bound and lifetime violations that are\n+// detected during type check.\n+\n+trait Dummy : 'static { }\n+fn assert_send<T:'static>() { }\n+\n+// lifetime pointers with 'static lifetime are ok\n+\n+fn static_lifime_ok<'a,T,U:Send>(_: &'a int) {\n+    assert_send::<&'static int>();\n+    assert_send::<&'static str>();\n+    assert_send::<&'static [int]>();\n+\n+    // whether or not they are mutable\n+    assert_send::<&'static mut int>();\n+}\n+\n+// otherwise lifetime pointers are not ok\n+\n+fn param_not_ok<'a>(x: &'a int) {\n+    assert_send::<&'a int>(); //~ ERROR does not fulfill\n+}\n+\n+fn param_not_ok1<'a>(_: &'a int) {\n+    assert_send::<&'a str>(); //~ ERROR does not fulfill\n+}\n+\n+fn param_not_ok2<'a>(_: &'a int) {\n+    assert_send::<&'a [int]>(); //~ ERROR does not fulfill\n+}\n+\n+// boxes are ok\n+\n+fn box_ok() {\n+    assert_send::<Box<int>>();\n+    assert_send::<String>();\n+    assert_send::<Vec<int>>();\n+}\n+\n+// but not if they own a bad thing\n+\n+fn box_with_region_not_ok<'a>() {\n+    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill\n+}\n+\n+// unsafe pointers are ok unless they point at unsendable things\n+\n+fn unsafe_ok1<'a>(_: &'a int) {\n+    assert_send::<*const int>();\n+    assert_send::<*mut int>();\n+}\n+\n+fn unsafe_ok2<'a>(_: &'a int) {\n+    assert_send::<*const &'a int>(); //~ ERROR does not fulfill\n+}\n+\n+fn unsafe_ok3<'a>(_: &'a int) {\n+    assert_send::<*mut &'a int>(); //~ ERROR does not fulfill\n+}\n+\n+fn main() {\n+}"}, {"sha": "ab97bad5bc2186e5b15d7633329d48024a647663", "filename": "src/test/compile-fail/regions-bounded-method-type-parameters-cross-crate.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-cross-crate.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:regions-bounded-method-type-parameters-cross-crate-lib.rs\n+\n+// Check explicit region bounds on methods in the cross crate case.\n+\n+extern crate lib = \"regions-bounded-method-type-parameters-cross-crate-lib\";\n+\n+use lib::Inv;\n+use lib::MaybeOwned;\n+use lib::IntoMaybeOwned;\n+\n+fn call_into_maybe_owned<'a,F:IntoMaybeOwned<'a>>(f: F) {\n+    // Exercise a code path I found to be buggy. We were not encoding\n+    // the region parameters from the receiver correctly on trait\n+    // methods.\n+    f.into_maybe_owned();\n+}\n+\n+fn call_bigger_region<'a, 'b>(a: Inv<'a>, b: Inv<'b>) {\n+    // Here the value provided for 'y is 'b, and hence 'b:'a does not hold.\n+    a.bigger_region(b) //~ ERROR cannot infer\n+}\n+\n+fn main() { }"}, {"sha": "e628eb3285ae62810aba9ea1140c353411a955da", "filename": "src/test/compile-fail/regions-bounded-method-type-parameters-trait-bound.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-trait-bound.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![no_std]\n+#![feature(lang_items)]\n+\n+// Check that explicit region bounds are allowed on the various\n+// nominal types (but not on other types) and that they are type\n+// checked.\n+\n+#[lang=\"sized\"]\n+trait Sized { }\n+\n+struct Inv<'a> { // invariant w/r/t 'a\n+    x: &'a mut &'a int\n+}\n+\n+trait Foo<'x> {\n+    fn method<'y:'x>(self, y: Inv<'y>);\n+}\n+\n+fn caller1<'a,'b,F:Foo<'a>>(a: Inv<'a>, b: Inv<'b>, f: F) {\n+    // Here the value provided for 'y is 'a, and hence 'a:'a holds.\n+    f.method(a);\n+}\n+\n+fn caller2<'a,'b,F:Foo<'a>>(a: Inv<'a>, b: Inv<'b>, f: F) {\n+    // Here the value provided for 'y is 'b, and hence 'b:'a does not hold.\n+    f.method(b); //~ ERROR cannot infer\n+}\n+\n+fn caller3<'a,'b:'a,F:Foo<'a>>(a: Inv<'a>, b: Inv<'b>, f: F) {\n+    // Here the value provided for 'y is 'b, and hence 'b:'a holds.\n+    f.method(b);\n+}\n+\n+fn main() { }"}, {"sha": "ba1993686d5d9167e4f91259a689fbd6d20d517b", "filename": "src/test/compile-fail/regions-bounded-method-type-parameters.rs", "status": "renamed", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -8,19 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main() {\n-    let mut x = Some(1);\n-    let mut p: proc(&mut Option<int>) = proc(_) {};\n-    match x {\n-        Some(ref y) => {\n-            p = proc(z: &mut Option<int>) {\n-                *z = None;\n-                let _ = y;\n-                //~^ ERROR cannot capture variable of type `&int`, which does not fulfill `'static`\n-            };\n-        }\n-        None => {}\n-    }\n-    p(&mut x);\n+#![no_std]\n+\n+// Check that explicit region bounds are allowed on the various\n+// nominal types (but not on other types) and that they are type\n+// checked.\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn some_method<A:'static>(self) { }\n+}\n+\n+fn caller<'a>(x: &int) {\n+    Foo.some_method::<&'a int>();\n+    //~^ ERROR does not fulfill the required lifetime\n }\n \n+fn main() { }", "previous_filename": "src/test/compile-fail/proc-static-bound.rs"}, {"sha": "a45c8e1db5482d49019a5e4328b7b5d1302e4d77", "filename": "src/test/compile-fail/regions-close-object-into-object.rs", "status": "renamed", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -10,21 +10,25 @@\n \n \n trait A<T> {}\n-struct B<'a, T>(&'a A<T>);\n+struct B<'a, T>(&'a A<T>+'a);\n \n trait X {}\n impl<'a, T> X for B<'a, T> {}\n \n-fn f<'a, T, U>(v: Box<A<T>>) -> Box<X> {\n-    box B(v) as Box<X> //~ ERROR value may contain references; add `'static` bound to `T`\n+fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n+    box B(v) as Box<X>\n }\n \n-fn g<'a, T, U>(v: Box<A<U>>) -> Box<X> {\n-    box B(v) as Box<X> //~ ERROR value may contain references; add `'static` bound to `U`\n+fn g<'a, T: 'static>(v: Box<A<T>>) -> Box<X+'static> {\n+    box B(v) as Box<X> //~ ERROR cannot infer\n }\n \n-fn h<'a, T: 'static>(v: Box<A<T>>) -> Box<X> {\n-    box B(v) as Box<X> // ok\n+fn h<'a, T, U>(v: Box<A<U>+'static>) -> Box<X+'static> {\n+    box B(v) as Box<X>\n+}\n+\n+fn i<'a, T, U>(v: Box<A<U>>) -> Box<X+'static> {\n+    box B(v) as Box<X> //~ ERROR cannot infer\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/owned-ptr-static-bound.rs"}, {"sha": "037514f45c743ad5edcb461e007ad7c4e53bd4b1", "filename": "src/test/compile-fail/regions-close-over-borrowed-ref-in-obj.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -8,11 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n trait Foo { }\n \n-fn foo<'a, 'b:'a>() { //~ ERROR region bounds require `issue_5723_bootstrap`\n-}\n+impl<'a> Foo for &'a int { }\n \n-pub fn main() { }\n+fn main() {\n+    let blah;\n+    {\n+        let ss: &int = &1; //~ ERROR borrowed value does not live long enough\n+        blah = box ss as Box<Foo>;\n+    }\n+}", "previous_filename": "src/test/compile-fail/regions-bound-lists-feature-gate-2.rs"}, {"sha": "5465f199f406fead270cabe7d3393d03ac0283e4", "filename": "src/test/compile-fail/regions-close-over-type-parameter-1.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for what happens when a type parameter `A` is closed over into\n+// an object. This should yield errors unless `A` (and the object)\n+// both have suitable bounds.\n+\n+trait SomeTrait { fn get(&self) -> int; }\n+\n+fn make_object1<A:SomeTrait>(v: A) -> Box<SomeTrait+'static> {\n+    box v as Box<SomeTrait+'static>\n+        //~^ ERROR the parameter type `A` may not live long enough\n+}\n+\n+fn make_object2<'a,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'a> {\n+    box v as Box<SomeTrait+'a>\n+}\n+\n+fn make_object3<'a,'b,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'b> {\n+    box v as Box<SomeTrait+'b>\n+        //~^ ERROR the parameter type `A` may not live long enough\n+}\n+\n+fn main() { }"}, {"sha": "0ee349aaebfcf77e6d06f32808a67170053b6806", "filename": "src/test/compile-fail/regions-close-over-type-parameter-2.rs", "status": "renamed", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-2.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,25 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test for what happens when a type parameter `A` is closed over into\n+// an object. This should yield errors unless `A` (and the object)\n+// both have suitable bounds.\n \n-trait Repeat<A> { fn get(&self) -> A; }\n+trait Foo { fn get(&self); }\n \n-impl<A:Clone> Repeat<A> for A {\n-    fn get(&self) -> A { self.clone() }\n+impl<A> Foo for A {\n+    fn get(&self) { }\n }\n \n-fn repeater<A:Clone>(v: A) -> Box<Repeat<A>> {\n-    box v as Box<Repeat<A>> // No\n+fn repeater3<'a,A:'a>(v: A) -> Box<Foo+'a> {\n+    box v as Box<Foo+'a>\n }\n \n fn main() {\n     // Error results because the type of is inferred to be\n     // ~Repeat<&'blk int> where blk is the lifetime of the block below.\n \n-    let y = {\n+    let _ = {\n         let tmp0 = 3i;\n         let tmp1 = &tmp0; //~ ERROR `tmp0` does not live long enough\n-        repeater(tmp1)\n+        repeater3(tmp1)\n     };\n-    assert!(3 == *(y.get()));\n }", "previous_filename": "src/test/compile-fail/kindck-owned-trait-contains.rs"}, {"sha": "5da281d93dd556737fe7055a9316c7bbf4946674", "filename": "src/test/compile-fail/regions-early-bound-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -15,7 +15,7 @@ trait GetRef<'a, T> {\n     fn get(&self) -> &'a T;\n }\n \n-struct Box<'a, T> {\n+struct Box<'a, T:'a> {\n     t: &'a T\n }\n "}, {"sha": "6395ee62f16a6d76db159c1715d423205d467fbb", "filename": "src/test/compile-fail/regions-enum-not-wf.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various examples of structs whose fields are not well-formed.\n+\n+#![no_std]\n+#![allow(dead_code)]\n+\n+enum Ref1<'a, T> { //~ ERROR the parameter type `T` may not live long enough\n+    Ref1Variant1(&'a T)\n+}\n+\n+enum Ref2<'a, T> { //~ ERROR the parameter type `T` may not live long enough\n+    Ref2Variant1,\n+    Ref2Variant2(int, &'a T),\n+}\n+\n+enum RefOk<'a, T:'a> {\n+    RefOkVariant1(&'a T)\n+}\n+\n+enum RefIndirect<'a, T> { //~ ERROR the parameter type `T` may not live long enough\n+    RefIndirectVariant1(int, RefOk<'a,T>)\n+}\n+\n+enum RefDouble<'a, 'b, T> { //~ ERROR reference has a longer lifetime than the data\n+    RefDoubleVariant1(&'a &'b T)\n+}\n+\n+fn main() { }"}, {"sha": "d752bc97cac79b2cf5d814378a0cf966d5efb059", "filename": "src/test/compile-fail/regions-escape-bound-fn-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -16,5 +16,6 @@ fn with_int(f: |x: &int|) {\n fn main() {\n     let mut x = None;\n          //~^ ERROR lifetime of variable does not enclose its declaration\n+         //~^^ ERROR type of expression contains references that are not valid during the expression\n     with_int(|y| x = Some(y));\n }"}, {"sha": "adef1f901fd0adf4e15f655cd5c57103b5f72de8", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -8,17 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait deref {\n+#![no_std]\n+\n+#![allow(dead_code)]\n+\n+trait Deref {\n     fn get(self) -> int;\n }\n \n-impl<'a> deref for &'a int {\n+impl<'a> Deref for &'a int {\n     fn get(self) -> int {\n         *self\n     }\n }\n \n-fn with<R:deref>(f: |x: &int| -> R) -> int {\n+fn with<R:Deref>(f: |x: &int| -> R) -> int {\n     f(&3).get()\n }\n "}, {"sha": "26cf3be429bd6dc36063cac66aff5996ec37f559", "filename": "src/test/compile-fail/regions-free-region-ordering-callee.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -31,6 +31,12 @@ fn ordering3<'a, 'b>(x: &'a uint, y: &'b uint) -> &'a &'b uint {\n }\n \n fn ordering4<'a, 'b>(a: &'a uint, b: &'b uint, x: |&'a &'b uint|) {\n+    // Do not infer ordering from closure argument types.\n+    let z: Option<&'a &'b uint> = None;\n+    //~^ ERROR reference has a longer lifetime than the data it references\n+}\n+\n+fn ordering5<'a, 'b>(a: &'a uint, b: &'b uint, x: Option<&'a &'b uint>) {\n     let z: Option<&'a &'b uint> = None;\n }\n "}, {"sha": "55c0cf3bb260dc690ddd3372e3cc06f82b1792c8", "filename": "src/test/compile-fail/regions-free-region-ordering-caller.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -16,18 +16,18 @@ struct Paramd<'a> { x: &'a uint }\n \n fn call2<'a, 'b>(a: &'a uint, b: &'b uint) {\n     let z: Option<&'b &'a uint> = None;\n-    //~^ ERROR pointer has a longer lifetime than the data it references\n+    //~^ ERROR reference has a longer lifetime than the data it references\n }\n \n fn call3<'a, 'b>(a: &'a uint, b: &'b uint) {\n     let y: Paramd<'a> = Paramd { x: a };\n     let z: Option<&'b Paramd<'a>> = None;\n-    //~^ ERROR pointer has a longer lifetime than the data it references\n+    //~^ ERROR reference has a longer lifetime than the data it references\n }\n \n fn call4<'a, 'b>(a: &'a uint, b: &'b uint) {\n-    let z: Option<|&'a &'b uint|> = None;\n-    //~^ ERROR pointer has a longer lifetime than the data it references\n+    let z: Option<&'a &'b uint> = None;\n+    //~^ ERROR reference has a longer lifetime than the data it references\n }\n \n "}, {"sha": "9cb61c24922eed25c1404f9274b77aab1bf98734", "filename": "src/test/compile-fail/regions-free-region-ordering-incorrect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -15,7 +15,7 @@\n //\n // This test began its life as a test for issue #4325.\n \n-struct Node<'b, T> {\n+struct Node<'b, T:'b> {\n   val: T,\n   next: Option<&'b Node<'b, T>>\n }"}, {"sha": "76bbe71cf75b5ba067ded39edfc32b3d20ef2ccb", "filename": "src/test/compile-fail/regions-freevar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -12,7 +12,7 @@ fn wants_static_fn(_x: ||: 'static) {}\n \n fn main() {\n     let i = 3i;\n-    wants_static_fn(|| { //~ ERROR cannot infer\n-        println!(\"i={}\", i);\n+    wants_static_fn(|| {\n+        println!(\"i={}\", i); //~ ERROR captured variable `i` does not outlive\n     })\n }"}, {"sha": "25fd20b6ec5654428494206c10ff02e09aa71a13", "filename": "src/test/compile-fail/regions-infer-bound-from-trait-self.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-infer-bound-from-trait-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-infer-bound-from-trait-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-bound-from-trait-self.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can derive lifetime bounds on `Self` from trait\n+// inheritance.\n+\n+trait Static : 'static { }\n+\n+trait Is<'a> : 'a { }\n+\n+struct Inv<'a> {\n+    x: Option<&'a mut &'a int>\n+}\n+\n+fn check_bound<'a,A:'a>(x: Inv<'a>, a: A) { }\n+\n+// In these case, `Self` inherits `'static`.\n+\n+trait InheritsFromStatic : 'static {\n+    fn foo1<'a>(self, x: Inv<'a>) {\n+        check_bound(x, self)\n+    }\n+}\n+trait InheritsFromStaticIndirectly : Static {\n+    fn foo1<'a>(self, x: Inv<'a>) {\n+        check_bound(x, self)\n+    }\n+}\n+\n+\n+// In these case, `Self` inherits `'a`.\n+\n+trait InheritsFromIs<'a> : 'a {\n+    fn foo(self, x: Inv<'a>) {\n+        check_bound(x, self)\n+    }\n+}\n+\n+trait InheritsFromIsIndirectly<'a> : Is<'a> {\n+    fn foo(self, x: Inv<'a>) {\n+        check_bound(x, self)\n+    }\n+}\n+\n+// In this case, `Self` inherits nothing.\n+\n+trait InheritsFromNothing<'a> {\n+    fn foo(self, x: Inv<'a>) {\n+        check_bound(x, self)\n+            //~^ ERROR parameter type `Self` may not live long enough\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "d1111377f1e4b3542d0aaaff23cb16c4fe207977", "filename": "src/test/compile-fail/regions-infer-bound-from-trait.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-infer-bound-from-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-infer-bound-from-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-bound-from-trait.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can derive lifetime bounds on type parameters\n+// from trait inheritance.\n+\n+trait Static : 'static { }\n+\n+trait Is<'a> : 'a { }\n+\n+struct Inv<'a> {\n+    x: Option<&'a mut &'a int>\n+}\n+\n+fn check_bound<'a,A:'a>(x: Inv<'a>, a: A) { }\n+\n+// In all of these cases, we can derive a bound for A that is longer\n+// than 'a based on the trait bound of A:\n+\n+fn foo1<'a,A:Static>(x: Inv<'a>, a: A) {\n+    check_bound(x, a)\n+}\n+\n+fn foo2<'a,A:Static>(x: Inv<'static>, a: A) {\n+    check_bound(x, a)\n+}\n+\n+fn foo3<'a,A:Is<'a>>(x: Inv<'a>, a: A) {\n+    check_bound(x, a)\n+}\n+\n+// In these cases, there is no trait bound, so we cannot derive any\n+// bound for A and we get an error:\n+\n+fn bar1<'a,A>(x: Inv<'a>, a: A) {\n+    check_bound(x, a) //~ ERROR parameter type `A` may not live long enough\n+}\n+\n+fn bar2<'a,'b,A:Is<'b>>(x: Inv<'a>, y: Inv<'b>, a: A) {\n+    check_bound(x, a) //~ ERROR parameter type `A` may not live long enough\n+}\n+\n+fn main() { }"}, {"sha": "0fa4969b54ca149d6c65903bb0db48641cf5497f", "filename": "src/test/compile-fail/regions-infer-region-in-fn-but-not-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -11,7 +11,7 @@\n \n // check that the &int here does not cause us to think that `foo`\n // contains region pointers\n-struct foo(proc(x: &int));\n+struct foo(proc(x: &int):'static);\n \n fn take_foo(x: foo<'static>) {} //~ ERROR wrong number of lifetime parameters\n "}, {"sha": "a52d2f9f9a0f738335a689a278f8824ae642449c", "filename": "src/test/compile-fail/regions-lifetime-bounds-on-fns.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![no_std]\n+\n+fn a<'a, 'b:'a>(x: &mut &'a int, y: &mut &'b int) {\n+    // Note: this is legal because of the `'b:'a` declaration.\n+    *x = *y;\n+}\n+\n+fn b<'a, 'b>(x: &mut &'a int, y: &mut &'b int) {\n+    // Illegal now because there is no `'b:'a` declaration.\n+    *x = *y; //~ ERROR mismatched types\n+}\n+\n+fn c<'a,'b>(x: &mut &'a int, y: &mut &'b int) {\n+    // Here we try to call `foo` but do not know that `'a` and `'b` are\n+    // related as required.\n+    a(x, y); //~ ERROR cannot infer\n+}\n+\n+fn d() {\n+    // 'a and 'b are early bound in the function `a` because they appear\n+    // inconstraints:\n+    let _: fn(&mut &int, &mut &int) = a; //~ ERROR mismatched types\n+}\n+\n+fn e() {\n+    // 'a and 'b are late bound in the function `b` because there are\n+    // no constraints:\n+    let _: fn(&mut &int, &mut &int) = b;\n+}\n+\n+fn main() { }"}, {"sha": "e32ef2752566bb6c14cfd646e1347b9ccd55c6d7", "filename": "src/test/compile-fail/regions-proc-bound-capture.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn borrowed_proc<'a>(x: &'a int) -> proc():'a -> int {\n+    // This is legal, because the region bound on `proc`\n+    // states that it captures `x`.\n+    proc() {\n+        *x\n+    }\n+}\n+\n+fn static_proc<'a>(x: &'a int) -> proc():'static -> int {\n+    // This is illegal, because the region bound on `proc` is 'static.\n+    proc() { //~ ERROR captured variable `x` outlives the `proc()`\n+        *x\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "db71bc4e15c0225b52382b32163391ac08bbfd9a", "filename": "src/test/compile-fail/regions-proc-bounds.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-proc-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-proc-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bounds.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+fn is_static<T: 'static>() {}\n \n-trait Foo { }\n+fn foo<'a>() {\n+    is_static::<proc():'a>();\n+    //~^ ERROR does not fulfill the required lifetime\n \n-fn foo<'a>(x: Box<Foo + 'a>) { //~ ERROR only the 'static lifetime is accepted here\n-}\n-\n-fn bar<'a, T:'a>() { //~ ERROR only the 'static lifetime is accepted here\n+    is_static::<proc():'static>();\n }\n \n fn main() { }", "previous_filename": "src/test/compile-fail/regions-bound-lists-feature-gate.rs"}, {"sha": "50ea8b1f2ed126708fb6085a9b4661beaf8b8f97", "filename": "src/test/compile-fail/regions-reborrow-from-shorter-mut-ref-mut-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -11,7 +11,7 @@\n // Issue #8624. Test for reborrowing with 3 levels, not just two.\n \n fn copy_borrowed_ptr<'a, 'b, 'c>(p: &'a mut &'b mut &'c mut int) -> &'b mut int {\n-    &mut ***p //~ ERROR cannot infer an appropriate lifetime\n+    &mut ***p //~ ERROR lifetime of `p` is too short to guarantee its contents\n }\n \n fn main() {"}, {"sha": "aac81a2af6b1f3ef3448070908512d7525b2ce30", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -18,8 +18,9 @@ fn with<R>(f: <'a>|x: &'a int| -> R) -> R {\n \n fn return_it<'a>() -> &'a int {\n     with(|o| o)\n-        //~^ ERROR lifetime of return value does not outlive the function call\n-        //~^^ ERROR cannot infer\n+        //~^ ERROR cannot infer\n+        //~^^ ERROR not valid during the expression\n+        //~^^^ ERROR not valid at this point\n }\n \n fn main() {"}, {"sha": "dd9421ee2ef2cdf20cf69ae252d07c8f05a19bda", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -21,8 +21,9 @@ fn with<R>(f: |x: &int| -> R) -> R {\n \n fn return_it<'a>() -> &'a int {\n     with(|o| o)\n-        //~^ ERROR lifetime of return value does not outlive the function call\n-        //~^^ ERROR cannot infer\n+        //~^ ERROR cannot infer\n+        //~^^ ERROR not valid during the expression\n+        //~^^^ ERROR not valid at this point\n }\n \n fn main() {"}, {"sha": "3de137a9efbd71758c6bc87288126c7aea15f74f", "filename": "src/test/compile-fail/regions-struct-not-wf.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-struct-not-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-struct-not-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-struct-not-wf.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various examples of structs whose fields are not well-formed.\n+\n+#![no_std]\n+#![allow(dead_code)]\n+\n+struct Ref<'a, T> { //~ ERROR the parameter type `T` may not live long enough\n+    field: &'a T\n+}\n+\n+struct RefOk<'a, T:'a> {\n+    field: &'a T\n+}\n+\n+struct RefIndirect<'a, T> { //~ ERROR the parameter type `T` may not live long enough\n+    field: RefOk<'a, T>\n+}\n+\n+struct DoubleRef<'a, 'b, T> { //~ ERROR reference has a longer lifetime than the data it references\n+    field: &'a &'b T\n+}\n+\n+fn main() { }"}, {"sha": "3ceb4e3fef6df07e54cdaa55ffb7eac9d3f647bf", "filename": "src/test/compile-fail/regions-trait-variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-trait-variance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-trait-variance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-variance.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -31,7 +31,7 @@ impl Drop for B {\n }\n \n struct A<'r> {\n-    p: &'r X\n+    p: &'r X+'r\n }\n \n fn make_a(p:&X) -> A {"}, {"sha": "7dcdc9875e3954c46086c40192c37e8409bf68cf", "filename": "src/test/compile-fail/regions-variance-covariant-use-contravariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -31,7 +31,7 @@ fn use_<'short,'long>(c: Covariant<'long>,\n     // contravariant with respect to its parameter 'a.\n \n     let _: Covariant<'short> = c; //~ ERROR mismatched types\n-    //~^ ERROR  cannot infer an appropriate lifetime\n+    //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "d09e6babe096a9752730113a01a240e304b99f0d", "filename": "src/test/compile-fail/regions-variance-invariant-use-contravariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -15,7 +15,7 @@\n // variance inference works in the first place.\n \n struct Invariant<'a> {\n-    f: &'static mut &'a int\n+    f: &'a mut &'a int\n }\n \n fn use_<'short,'long>(c: Invariant<'long>,"}, {"sha": "861668ad50d34e471831e8e78cb13f14e3e29f1b", "filename": "src/test/compile-fail/regions-variance-invariant-use-covariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -15,7 +15,7 @@\n // variance inference works in the first place.\n \n struct Invariant<'a> {\n-    f: &'static mut &'a int\n+    f: &'a mut &'a int\n }\n \n fn use_<'b>(c: Invariant<'b>) {"}, {"sha": "bf7c3b261fd7dcd2eac4111920e73ff74eb6a812", "filename": "src/test/compile-fail/selftype-traittype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -13,7 +13,7 @@ trait add {\n     fn plus(&self, x: Self) -> Self;\n }\n \n-fn do_add(x: Box<add>, y: Box<add>) -> Box<add> {\n+fn do_add(x: Box<add+'static>, y: Box<add+'static>) -> Box<add+'static> {\n     x.plus(y) //~ ERROR cannot call a method whose type contains a self-type through an object\n }\n "}, {"sha": "2cb1f462e1daedb7613f7f5bfd64197b087299e3", "filename": "src/test/compile-fail/static-region-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fstatic-region-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fstatic-region-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-region-bound.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -16,6 +16,6 @@ fn f<T:'static>(_: T) {}\n fn main() {\n     let x = box(GC) 3i;\n     f(x);\n-    let x = &3i;\n-    f(x);   //~ ERROR instantiating a type parameter with an incompatible type\n+    let x = &3i; //~ ERROR borrowed value does not live long enough\n+    f(x);\n }"}, {"sha": "b189acb685a338de68d80823e1816d966f1fa834", "filename": "src/test/compile-fail/trailing-plus-in-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Ftrailing-plus-in-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Ftrailing-plus-in-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrailing-plus-in-bounds.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -11,7 +11,7 @@\n use std::fmt::Show;\n \n fn main() {\n-    let x: Box<Show+> = box 3 as Box<Show+>;\n+    let x: Box<Show+> = box 3i as Box<Show+>;\n     //~^ ERROR at least one type parameter bound must be specified\n     //~^^ ERROR at least one type parameter bound must be specified\n }"}, {"sha": "7ed8db4fcd2911bea39c3da1e41ee94bfcc158eb", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -16,15 +16,16 @@ trait Foo {}\n fn a(_x: Box<Foo+Send>) {\n }\n \n-fn b(_x: &'static Foo) { // should be same as &'static Foo+'static\n+fn b(_x: &'static Foo+'static) {\n }\n \n fn c(x: Box<Foo+Sync>) {\n-    a(x); //~ ERROR expected bounds `Send`\n+    a(x); //~ ERROR mismatched types\n }\n \n fn d(x: &'static Foo+Sync) {\n-    b(x); //~ ERROR expected bounds `'static`\n+    b(x); //~ ERROR cannot infer\n+    //~^ ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "9694c1d9f980e9bd753079a9286df7b1fdca4d1e", "filename": "src/test/compile-fail/typeck_type_placeholder_lifetime_1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_1.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -11,7 +11,7 @@\n // This test checks that the `_` type placeholder does not react\n // badly if put as a lifetime parameter.\n \n-struct Foo<'a, T> {\n+struct Foo<'a, T:'a> {\n     r: &'a T\n }\n "}, {"sha": "365b786cc1a2a5ac5b8af8372e9140dbaf21052d", "filename": "src/test/compile-fail/typeck_type_placeholder_lifetime_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_2.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -11,7 +11,7 @@\n // This test checks that the `_` type placeholder does not react\n // badly if put as a lifetime parameter.\n \n-struct Foo<'a, T> {\n+struct Foo<'a, T:'a> {\n     r: &'a T\n }\n "}, {"sha": "87647cdb546141ece59c8cfa8b7014a82f15dfaa", "filename": "src/test/compile-fail/unconstrained-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S<'a, T> {\n+struct S<'a, T:'a> {\n     o: &'a Option<T>\n }\n "}, {"sha": "a66c1d85009c343da21563643c43d69bf9d95ef6", "filename": "src/test/compile-fail/unsized4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized4.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -12,7 +12,7 @@\n \n trait T {}\n fn f<Sized? Y: T>() {\n-//~^ERROR incompatible bounds on type parameter Y, bound T does not allow unsized type\n+//~^ERROR incompatible bounds on type parameter `Y`, bound `T` does not allow unsized type\n }\n \n pub fn main() {"}, {"sha": "3f2f43b0c9b84de267baef50c57e99b1860731b7", "filename": "src/test/compile-fail/use-after-move-implicity-coerced-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -23,10 +23,10 @@ impl fmt::Show for Number {\n }\n \n struct List {\n-    list: Vec<Box<ToString>> }\n+    list: Vec<Box<ToString+'static>> }\n \n impl List {\n-    fn push(&mut self, n: Box<ToString>) {\n+    fn push(&mut self, n: Box<ToString+'static>) {\n         self.list.push(n);\n     }\n }"}, {"sha": "fa38482b21c50eea054a66293810fa16c7fcc37c", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -32,7 +32,7 @@ struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[]]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b> { //~ ERROR regions=[[-, o];[];[]]\n+struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[]]\n     x: &'a mut &'b int,\n }\n \n@@ -64,7 +64,7 @@ struct Test7<'a> { //~ ERROR regions=[[*];[];[]]\n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c> { //~ ERROR regions=[[+, -, o];[];[]]\n+enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),"}, {"sha": "c049fbc0fedbc758ca213476087b234949c06e72", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -13,29 +13,29 @@\n // Try enums too.\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c, 'd> { //~ ERROR regions=[[+, -, o, *];[];[]]\n+enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[]]\n+struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[]]\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n-struct Derived2<'a, 'b, 'c> { //~ ERROR regions=[[o, o, *];[];[]]\n+struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[];[]]\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[]]\n+struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[]]\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c> { //~ ERROR regions=[[+, -, o];[];[]]\n+struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}, {"sha": "eb20a09477d3cf9d642b841741590dc85c852d6f", "filename": "src/test/pretty/closure-reform-pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -17,7 +17,7 @@ fn call_it(f: proc(String) -> String) { }\n \n fn call_this(f: |&str|: Send) { }\n \n-fn call_that(f: <'a>|&'a int, &'a int|: -> int) { }\n+fn call_that(f: <'a>|&'a int, &'a int| -> int) { }\n \n fn call_extern(f: fn() -> int) { }\n "}, {"sha": "86e394e5408781e0120a3bbb32378fa46840157d", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -48,8 +48,8 @@\n                        as core::fmt::rt::Piece<'static>)] as\n                      [core::fmt::rt::Piece<'static>, .. 1]);\n              let __args_vec =\n-                 (&([] as [core::fmt::Argument<'static>, .. 0]) as\n-                     &'static [core::fmt::Argument<'static>, .. 0]);\n+                 (&([] as [core::fmt::Argument<'_>, .. 0]) as\n+                     &[core::fmt::Argument<'_>, .. 0]);\n              let __args =\n                  (unsafe {\n                       ((::std::fmt::Arguments::new as\n@@ -58,9 +58,9 @@\n                                                                                                                                                [core::fmt::rt::Piece<'static>, .. 1]),\n                                                                                                                                            (__args_vec\n                                                                                                                                                as\n-                                                                                                                                               &'static [core::fmt::Argument<'static>, .. 0]))\n-                          as core::fmt::Arguments<'static>)\n-                  } as core::fmt::Arguments<'static>);\n+                                                                                                                                               &[core::fmt::Argument<'_>, .. 0]))\n+                          as core::fmt::Arguments<'_>)\n+                  } as core::fmt::Arguments<'_>);\n \n \n \n@@ -72,9 +72,9 @@\n              ((::std::fmt::format as\n                   fn(&core::fmt::Arguments<'_>) -> collections::string::String)((&(__args\n                                                                                       as\n-                                                                                      core::fmt::Arguments<'static>)\n+                                                                                      core::fmt::Arguments<'_>)\n                                                                                     as\n-                                                                                    &core::fmt::Arguments<'static>))\n+                                                                                    &core::fmt::Arguments<'_>))\n                  as collections::string::String)\n          }\n      } as collections::string::String);"}, {"sha": "f575fb3292480387ed27bc0fae45cf561b5959f0", "filename": "src/test/pretty/path-type-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -14,7 +14,7 @@\n trait Tr { }\n impl Tr for int { }\n \n-fn foo(x: Box<Tr+ Sync>) -> Box<Tr+ Sync> { x }\n+fn foo<'a>(x: Box<Tr+ Sync + 'a>) -> Box<Tr+ Sync + 'a> { x }\n \n fn main() {\n     let x: Box<Tr+ Sync>;"}, {"sha": "c5455ab90dc8b585a7ba0786899c3c2ea7ee0705", "filename": "src/test/run-make/graphviz-flowgraph/f01.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -2,8 +2,10 @@ digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n     N2[label=\"expr 1i\"];\n-    N3[label=\"block { 1i; }\"];\n+    N3[label=\"stmt 1i;\"];\n+    N4[label=\"block { 1i; }\"];\n     N0 -> N2;\n     N2 -> N3;\n-    N3 -> N1;\n+    N3 -> N4;\n+    N4 -> N1;\n }"}, {"sha": "230dcbaeb98f83ee215ddf84a67655c0496d82e9", "filename": "src/test/run-make/graphviz-flowgraph/f02.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -2,8 +2,10 @@ digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n     N2[label=\"local _x\"];\n-    N3[label=\"block { let _x: int; }\"];\n+    N3[label=\"stmt let _x: int;\"];\n+    N4[label=\"block { let _x: int; }\"];\n     N0 -> N2;\n     N2 -> N3;\n-    N3 -> N1;\n+    N3 -> N4;\n+    N4 -> N1;\n }"}, {"sha": "e60d349ad14bb286a01ce03c6624bcebf2c28927", "filename": "src/test/run-make/graphviz-flowgraph/f03.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -4,10 +4,12 @@ digraph block {\n     N2[label=\"expr 3i\"];\n     N3[label=\"expr 33i\"];\n     N4[label=\"expr 3i + 33i\"];\n-    N5[label=\"block { 3i + 33i; }\"];\n+    N5[label=\"stmt 3i + 33i;\"];\n+    N6[label=\"block { 3i + 33i; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n-    N5 -> N1;\n+    N5 -> N6;\n+    N6 -> N1;\n }"}, {"sha": "82cdcb39fbfd47f70e9404e9b4af6c72d80d3810", "filename": "src/test/run-make/graphviz-flowgraph/f04.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,9 +3,11 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 4i\"];\n     N3[label=\"local _x\"];\n-    N4[label=\"block { let _x = 4i; }\"];\n+    N4[label=\"stmt let _x = 4i;\"];\n+    N5[label=\"block { let _x = 4i; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n-    N4 -> N1;\n+    N4 -> N5;\n+    N5 -> N1;\n }"}, {"sha": "8a27d536ffc80b5e001dfbc98289ab354ff1b9b8", "filename": "src/test/run-make/graphviz-flowgraph/f05.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -7,13 +7,15 @@ digraph block {\n     N5[label=\"local _x\"];\n     N6[label=\"local _y\"];\n     N7[label=\"pat (_x, _y)\"];\n-    N8[label=\"block { let (_x, _y) = (5i, 55i); }\"];\n+    N8[label=\"stmt let (_x, _y) = (5i, 55i);\"];\n+    N9[label=\"block { let (_x, _y) = (5i, 55i); }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n     N7 -> N8;\n-    N8 -> N1;\n+    N8 -> N9;\n+    N9 -> N1;\n }"}, {"sha": "54e9d89d3fb56bb39dd1d9a1a1b615518bb1ff60", "filename": "src/test/run-make/graphviz-flowgraph/f06.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -5,11 +5,13 @@ digraph block {\n     N3[label=\"expr S6{val: 6,}\"];\n     N4[label=\"local _x\"];\n     N5[label=\"pat S6 { val: _x }\"];\n-    N6[label=\"block { let S6 { val: _x } = S6{val: 6,}; }\"];\n+    N6[label=\"stmt let S6 { val: _x } = S6{val: 6,};\"];\n+    N7[label=\"block { let S6 { val: _x } = S6{val: 6,}; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n-    N6 -> N1;\n+    N6 -> N7;\n+    N7 -> N1;\n }"}, {"sha": "4c6383324e5f9b85bf85162d6c270e7f06a81484", "filename": "src/test/run-make/graphviz-flowgraph/f07.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -15,7 +15,8 @@ digraph block {\n     N13[label=\"expr x\"];\n     N14[label=\"expr y\"];\n     N15[label=\"expr x + y\"];\n-    N16[label=\"block { match [7i, 77i, 777i, 7777i] { [x, y, ..] => x + y, }; }\"];\n+    N16[label=\"stmt match [7i, 77i, 777i, 7777i] { [x, y, ..] => x + y, };\"];\n+    N17[label=\"block { match [7i, 77i, 777i, 7777i] { [x, y, ..] => x + y, }; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -31,5 +32,6 @@ digraph block {\n     N14 -> N15;\n     N15 -> N7;\n     N7 -> N16;\n-    N16 -> N1;\n+    N16 -> N17;\n+    N17 -> N1;\n }"}, {"sha": "27a240ed18255c5c864e25242fb2c6546b56eec0", "filename": "src/test/run-make/graphviz-flowgraph/f08.dot-expected.dot", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,16 +3,19 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 8i\"];\n     N3[label=\"local x\"];\n-    N4[label=\"local _y\"];\n-    N5[label=\"expr x\"];\n-    N6[label=\"expr 88i\"];\n-    N7[label=\"expr x > 88i\"];\n-    N8[label=\"expr 888i\"];\n-    N9[label=\"expr _y\"];\n-    N10[label=\"expr _y = 888i\"];\n-    N11[label=\"block { _y = 888i; }\"];\n-    N12[label=\"expr if x > 88i { _y = 888i; }\"];\n-    N13[label=\"block { let x = 8i; let _y; if x > 88i { _y = 888i; } }\"];\n+    N4[label=\"stmt let x = 8i;\"];\n+    N5[label=\"local _y\"];\n+    N6[label=\"stmt let _y;\"];\n+    N7[label=\"expr x\"];\n+    N8[label=\"expr 88i\"];\n+    N9[label=\"expr x > 88i\"];\n+    N10[label=\"expr 888i\"];\n+    N11[label=\"expr _y\"];\n+    N12[label=\"expr _y = 888i\"];\n+    N13[label=\"stmt _y = 888i;\"];\n+    N14[label=\"block { _y = 888i; }\"];\n+    N15[label=\"expr if x > 88i { _y = 888i; }\"];\n+    N16[label=\"block { let x = 8i; let _y; if x > 88i { _y = 888i; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -23,8 +26,11 @@ digraph block {\n     N8 -> N9;\n     N9 -> N10;\n     N10 -> N11;\n-    N7 -> N12;\n     N11 -> N12;\n     N12 -> N13;\n-    N13 -> N1;\n+    N13 -> N14;\n+    N9 -> N15;\n+    N14 -> N15;\n+    N15 -> N16;\n+    N16 -> N1;\n }"}, {"sha": "d2c58c6d59aeb7719fbe1d5f62a884bb6a9e8587", "filename": "src/test/run-make/graphviz-flowgraph/f09.dot-expected.dot", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,23 +3,27 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 91i\"];\n     N3[label=\"local x\"];\n-    N4[label=\"local _y\"];\n-    N5[label=\"expr x\"];\n-    N6[label=\"expr 92i\"];\n-    N7[label=\"expr x > 92i\"];\n-    N8[label=\"expr 93i\"];\n-    N9[label=\"expr _y\"];\n-    N10[label=\"expr _y = 93i\"];\n-    N11[label=\"block { _y = 93i; }\"];\n-    N12[label=\"expr 94i\"];\n-    N13[label=\"expr 95i\"];\n-    N14[label=\"expr 94i + 95i\"];\n-    N15[label=\"expr _y\"];\n-    N16[label=\"expr _y = 94i + 95i\"];\n-    N17[label=\"block { _y = 94i + 95i; }\"];\n-    N18[label=\"expr { _y = 94i + 95i; }\"];\n-    N19[label=\"expr if x > 92i { _y = 93i; } else { _y = 94i + 95i; }\"];\n-    N20[label=\"block { let x = 91i; let _y; if x > 92i { _y = 93i; } else { _y = 94i + 95i; } }\"];\n+    N4[label=\"stmt let x = 91i;\"];\n+    N5[label=\"local _y\"];\n+    N6[label=\"stmt let _y;\"];\n+    N7[label=\"expr x\"];\n+    N8[label=\"expr 92i\"];\n+    N9[label=\"expr x > 92i\"];\n+    N10[label=\"expr 93i\"];\n+    N11[label=\"expr _y\"];\n+    N12[label=\"expr _y = 93i\"];\n+    N13[label=\"stmt _y = 93i;\"];\n+    N14[label=\"block { _y = 93i; }\"];\n+    N15[label=\"expr 94i\"];\n+    N16[label=\"expr 95i\"];\n+    N17[label=\"expr 94i + 95i\"];\n+    N18[label=\"expr _y\"];\n+    N19[label=\"expr _y = 94i + 95i\"];\n+    N20[label=\"stmt _y = 94i + 95i;\"];\n+    N21[label=\"block { _y = 94i + 95i; }\"];\n+    N22[label=\"expr { _y = 94i + 95i; }\"];\n+    N23[label=\"expr if x > 92i { _y = 93i; } else { _y = 94i + 95i; }\"];\n+    N24[label=\"block { let x = 91i; let _y; if x > 92i { _y = 93i; } else { _y = 94i + 95i; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -30,15 +34,19 @@ digraph block {\n     N8 -> N9;\n     N9 -> N10;\n     N10 -> N11;\n-    N7 -> N12;\n+    N11 -> N12;\n     N12 -> N13;\n     N13 -> N14;\n-    N14 -> N15;\n+    N9 -> N15;\n     N15 -> N16;\n     N16 -> N17;\n     N17 -> N18;\n-    N11 -> N19;\n     N18 -> N19;\n     N19 -> N20;\n-    N20 -> N1;\n+    N20 -> N21;\n+    N21 -> N22;\n+    N14 -> N23;\n+    N22 -> N23;\n+    N23 -> N24;\n+    N24 -> N1;\n }"}, {"sha": "421a79fd136b3fbd69a71d28e089df4c68706179", "filename": "src/test/run-make/graphviz-flowgraph/f10.dot-expected.dot", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,28 +3,32 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 10i\"];\n     N3[label=\"local mut x\"];\n-    N4[label=\"(dummy_node)\"];\n-    N5[label=\"expr x\"];\n-    N6[label=\"expr 0i\"];\n-    N7[label=\"expr x > 0i\"];\n-    N8[label=\"expr while x > 0i { x -= 1i; }\"];\n-    N9[label=\"expr 1i\"];\n-    N10[label=\"expr x\"];\n-    N11[label=\"expr x -= 1i\"];\n-    N12[label=\"block { x -= 1i; }\"];\n-    N13[label=\"block { let mut x = 10i; while x > 0i { x -= 1i; } }\"];\n+    N4[label=\"stmt let mut x = 10i;\"];\n+    N5[label=\"(dummy_node)\"];\n+    N6[label=\"expr x\"];\n+    N7[label=\"expr 0i\"];\n+    N8[label=\"expr x > 0i\"];\n+    N9[label=\"expr while x > 0i { x -= 1i; }\"];\n+    N10[label=\"expr 1i\"];\n+    N11[label=\"expr x\"];\n+    N12[label=\"expr x -= 1i\"];\n+    N13[label=\"stmt x -= 1i;\"];\n+    N14[label=\"block { x -= 1i; }\"];\n+    N15[label=\"block { let mut x = 10i; while x > 0i { x -= 1i; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n     N7 -> N8;\n-    N7 -> N9;\n-    N9 -> N10;\n+    N8 -> N9;\n+    N8 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n-    N12 -> N4;\n-    N8 -> N13;\n-    N13 -> N1;\n+    N12 -> N13;\n+    N13 -> N14;\n+    N14 -> N5;\n+    N9 -> N15;\n+    N15 -> N1;\n }"}, {"sha": "b928058fed99c6afe5e34072eb603f4663075bdf", "filename": "src/test/run-make/graphviz-flowgraph/f11.dot-expected.dot", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,23 +3,31 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 11i\"];\n     N3[label=\"local mut _x\"];\n-    N4[label=\"(dummy_node)\"];\n-    N5[label=\"expr loop  { _x -= 1i; }\"];\n-    N6[label=\"expr 1i\"];\n-    N7[label=\"expr _x\"];\n-    N8[label=\"expr _x -= 1i\"];\n-    N9[label=\"block { _x -= 1i; }\"];\n-    N10[label=\"expr \\\"unreachable\\\"\"];\n-    N11[label=\"block { let mut _x = 11i; loop  { _x -= 1i; } \\\"unreachable\\\"; }\"];\n+    N4[label=\"stmt let mut _x = 11i;\"];\n+    N5[label=\"(dummy_node)\"];\n+    N6[label=\"expr loop  { _x -= 1i; }\"];\n+    N7[label=\"expr 1i\"];\n+    N8[label=\"expr _x\"];\n+    N9[label=\"expr _x -= 1i\"];\n+    N10[label=\"stmt _x -= 1i;\"];\n+    N11[label=\"block { _x -= 1i; }\"];\n+    N12[label=\"stmt loop  { _x -= 1i; }\"];\n+    N13[label=\"expr \\\"unreachable\\\"\"];\n+    N14[label=\"stmt \\\"unreachable\\\";\"];\n+    N15[label=\"block { let mut _x = 11i; loop  { _x -= 1i; } \\\"unreachable\\\"; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n-    N4 -> N6;\n-    N6 -> N7;\n+    N4 -> N5;\n+    N5 -> N7;\n     N7 -> N8;\n     N8 -> N9;\n-    N9 -> N4;\n-    N5 -> N10;\n+    N9 -> N10;\n     N10 -> N11;\n-    N11 -> N1;\n+    N11 -> N5;\n+    N6 -> N12;\n+    N12 -> N13;\n+    N13 -> N14;\n+    N14 -> N15;\n+    N15 -> N1;\n }"}, {"sha": "d89a37308de062686dcf30e3c36a066a64cc3f52", "filename": "src/test/run-make/graphviz-flowgraph/f12.dot-expected.dot", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,38 +3,46 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 12i\"];\n     N3[label=\"local mut x\"];\n-    N4[label=\"(dummy_node)\"];\n-    N5[label=\"expr loop  { x -= 1i; if x == 2i { break ; \\\"unreachable\\\"; } }\"];\n-    N6[label=\"expr 1i\"];\n-    N7[label=\"expr x\"];\n-    N8[label=\"expr x -= 1i\"];\n-    N9[label=\"expr x\"];\n-    N10[label=\"expr 2i\"];\n-    N11[label=\"expr x == 2i\"];\n-    N12[label=\"expr break\"];\n-    N13[label=\"(dummy_node)\"];\n-    N14[label=\"expr \\\"unreachable\\\"\"];\n-    N15[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N16[label=\"expr if x == 2i { break ; \\\"unreachable\\\"; }\"];\n-    N17[label=\"block { x -= 1i; if x == 2i { break ; \\\"unreachable\\\"; } }\"];\n-    N18[label=\"block { let mut x = 12i; loop  { x -= 1i; if x == 2i { break ; \\\"unreachable\\\"; } } }\"];\n+    N4[label=\"stmt let mut x = 12i;\"];\n+    N5[label=\"(dummy_node)\"];\n+    N6[label=\"expr loop  { x -= 1i; if x == 2i { break ; \\\"unreachable\\\"; } }\"];\n+    N7[label=\"expr 1i\"];\n+    N8[label=\"expr x\"];\n+    N9[label=\"expr x -= 1i\"];\n+    N10[label=\"stmt x -= 1i;\"];\n+    N11[label=\"expr x\"];\n+    N12[label=\"expr 2i\"];\n+    N13[label=\"expr x == 2i\"];\n+    N14[label=\"expr break\"];\n+    N15[label=\"(dummy_node)\"];\n+    N16[label=\"stmt break ;\"];\n+    N17[label=\"expr \\\"unreachable\\\"\"];\n+    N18[label=\"stmt \\\"unreachable\\\";\"];\n+    N19[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N20[label=\"expr if x == 2i { break ; \\\"unreachable\\\"; }\"];\n+    N21[label=\"block { x -= 1i; if x == 2i { break ; \\\"unreachable\\\"; } }\"];\n+    N22[label=\"block { let mut x = 12i; loop  { x -= 1i; if x == 2i { break ; \\\"unreachable\\\"; } } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n-    N4 -> N6;\n-    N6 -> N7;\n+    N4 -> N5;\n+    N5 -> N7;\n     N7 -> N8;\n     N8 -> N9;\n     N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n-    N12 -> N5[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 2i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 block { x -= 1i; if x == 2i { break ; \\\"unreachable\\\"; } }\"];\n+    N12 -> N13;\n     N13 -> N14;\n-    N14 -> N15;\n-    N11 -> N16;\n+    N14 -> N6[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 2i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 block { x -= 1i; if x == 2i { break ; \\\"unreachable\\\"; } }\"];\n     N15 -> N16;\n     N16 -> N17;\n-    N17 -> N4;\n-    N5 -> N18;\n-    N18 -> N1;\n+    N17 -> N18;\n+    N18 -> N19;\n+    N13 -> N20;\n+    N19 -> N20;\n+    N20 -> N21;\n+    N21 -> N5;\n+    N6 -> N22;\n+    N22 -> N1;\n }"}, {"sha": "aa43ef515343a22cc094a9ff88450b399c09a4b8", "filename": "src/test/run-make/graphviz-flowgraph/f13.dot-expected.dot", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -5,44 +5,48 @@ digraph block {\n     N3[label=\"expr 13\"];\n     N4[label=\"expr E13b(13)\"];\n     N5[label=\"local x\"];\n-    N6[label=\"local _y\"];\n-    N7[label=\"expr x\"];\n-    N8[label=\"expr match x { E13a => _y = 1, E13b(v) => _y = v + 1, }\"];\n-    N9[label=\"(dummy_node)\"];\n-    N10[label=\"local E13a\"];\n-    N11[label=\"expr 1\"];\n-    N12[label=\"expr _y\"];\n-    N13[label=\"expr _y = 1\"];\n-    N14[label=\"(dummy_node)\"];\n-    N15[label=\"local v\"];\n-    N16[label=\"pat E13b(v)\"];\n-    N17[label=\"expr v\"];\n-    N18[label=\"expr 1\"];\n-    N19[label=\"expr v + 1\"];\n-    N20[label=\"expr _y\"];\n-    N21[label=\"expr _y = v + 1\"];\n-    N22[label=\"block {\\l    let x = E13b(13);\\l    let _y;\\l    match x { E13a => _y = 1, E13b(v) => _y = v + 1, }\\l}\\l\"];\n+    N6[label=\"stmt let x = E13b(13);\"];\n+    N7[label=\"local _y\"];\n+    N8[label=\"stmt let _y;\"];\n+    N9[label=\"expr x\"];\n+    N10[label=\"expr match x { E13a => _y = 1, E13b(v) => _y = v + 1, }\"];\n+    N11[label=\"(dummy_node)\"];\n+    N12[label=\"local E13a\"];\n+    N13[label=\"expr 1\"];\n+    N14[label=\"expr _y\"];\n+    N15[label=\"expr _y = 1\"];\n+    N16[label=\"(dummy_node)\"];\n+    N17[label=\"local v\"];\n+    N18[label=\"pat E13b(v)\"];\n+    N19[label=\"expr v\"];\n+    N20[label=\"expr 1\"];\n+    N21[label=\"expr v + 1\"];\n+    N22[label=\"expr _y\"];\n+    N23[label=\"expr _y = v + 1\"];\n+    N24[label=\"block {\\l    let x = E13b(13);\\l    let _y;\\l    match x { E13a => _y = 1, E13b(v) => _y = v + 1, }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n-    N7 -> N9;\n-    N9 -> N10;\n-    N10 -> N11;\n+    N7 -> N8;\n+    N8 -> N9;\n+    N9 -> N11;\n     N11 -> N12;\n     N12 -> N13;\n-    N13 -> N8;\n-    N9 -> N14;\n+    N13 -> N14;\n     N14 -> N15;\n-    N15 -> N16;\n+    N15 -> N10;\n+    N11 -> N16;\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n     N20 -> N21;\n-    N21 -> N8;\n-    N8 -> N22;\n-    N22 -> N1;\n+    N21 -> N22;\n+    N22 -> N23;\n+    N23 -> N10;\n+    N10 -> N24;\n+    N24 -> N1;\n }"}, {"sha": "bdb2c133badf870b81eb2dd439bc64850583a612", "filename": "src/test/run-make/graphviz-flowgraph/f14.dot-expected.dot", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,26 +3,32 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 14i\"];\n     N3[label=\"local x\"];\n-    N4[label=\"expr x\"];\n-    N5[label=\"expr 1i\"];\n-    N6[label=\"expr x > 1i\"];\n-    N7[label=\"expr return\"];\n-    N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\\"unreachable\\\"\"];\n-    N10[label=\"block { return; \\\"unreachable\\\"; }\"];\n-    N11[label=\"expr if x > 1i { return; \\\"unreachable\\\"; }\"];\n-    N12[label=\"block { let x = 14i; if x > 1i { return; \\\"unreachable\\\"; } }\"];\n+    N4[label=\"stmt let x = 14i;\"];\n+    N5[label=\"expr x\"];\n+    N6[label=\"expr 1i\"];\n+    N7[label=\"expr x > 1i\"];\n+    N8[label=\"expr return\"];\n+    N9[label=\"(dummy_node)\"];\n+    N10[label=\"stmt return;\"];\n+    N11[label=\"expr \\\"unreachable\\\"\"];\n+    N12[label=\"stmt \\\"unreachable\\\";\"];\n+    N13[label=\"block { return; \\\"unreachable\\\"; }\"];\n+    N14[label=\"expr if x > 1i { return; \\\"unreachable\\\"; }\"];\n+    N15[label=\"block { let x = 14i; if x > 1i { return; \\\"unreachable\\\"; } }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n-    N7 -> N1;\n-    N8 -> N9;\n+    N7 -> N8;\n+    N8 -> N1;\n     N9 -> N10;\n-    N6 -> N11;\n     N10 -> N11;\n     N11 -> N12;\n-    N12 -> N1;\n+    N12 -> N13;\n+    N7 -> N14;\n+    N13 -> N14;\n+    N14 -> N15;\n+    N15 -> N1;\n }"}, {"sha": "4bd9fc9ec1ad1bc5204429f1feb414d8e13be504", "filename": "src/test/run-make/graphviz-flowgraph/f15.dot-expected.dot", "status": "modified", "additions": 71, "deletions": 47, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,77 +3,101 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 15i\"];\n     N3[label=\"local mut x\"];\n-    N4[label=\"expr 151i\"];\n-    N5[label=\"local mut y\"];\n-    N6[label=\"(dummy_node)\"];\n-    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { break ; \\\"unreachable\\\"; }\\l                y -= 3i;\\l            }\\l        y -= 4i;\\l        x -= 5i;\\l    }\\l\"];\n+    N4[label=\"stmt let mut x = 15i;\"];\n+    N5[label=\"expr 151i\"];\n+    N6[label=\"local mut y\"];\n+    N7[label=\"stmt let mut y = 151i;\"];\n     N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l\"];\n-    N10[label=\"expr x\"];\n-    N11[label=\"expr 1i\"];\n-    N12[label=\"expr x == 1i\"];\n-    N13[label=\"expr break \\'outer\"];\n-    N14[label=\"(dummy_node)\"];\n-    N15[label=\"expr \\\"unreachable\\\"\"];\n-    N16[label=\"block { break \\'outer ; \\\"unreachable\\\"; }\"];\n-    N17[label=\"expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\"];\n-    N18[label=\"expr y\"];\n-    N19[label=\"expr 2i\"];\n-    N20[label=\"expr y >= 2i\"];\n-    N21[label=\"expr break\"];\n-    N22[label=\"(dummy_node)\"];\n-    N23[label=\"expr \\\"unreachable\\\"\"];\n-    N24[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N25[label=\"expr if y >= 2i { break ; \\\"unreachable\\\"; }\"];\n-    N26[label=\"expr 3i\"];\n-    N27[label=\"expr y\"];\n-    N28[label=\"expr y -= 3i\"];\n-    N29[label=\"block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l\"];\n-    N30[label=\"expr 4i\"];\n-    N31[label=\"expr y\"];\n-    N32[label=\"expr y -= 4i\"];\n-    N33[label=\"expr 5i\"];\n-    N34[label=\"expr x\"];\n-    N35[label=\"expr x -= 5i\"];\n-    N36[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { break ; \\\"unreachable\\\"; }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n-    N37[label=\"block {\\l    let mut x = 15i;\\l    let mut y = 151i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2i { break ; \\\"unreachable\\\"; }\\l                    y -= 3i;\\l                }\\l            y -= 4i;\\l            x -= 5i;\\l        }\\l}\\l\"];\n+    N9[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { break ; \\\"unreachable\\\"; }\\l                y -= 3i;\\l            }\\l        y -= 4i;\\l        x -= 5i;\\l    }\\l\"];\n+    N10[label=\"(dummy_node)\"];\n+    N11[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l\"];\n+    N12[label=\"expr x\"];\n+    N13[label=\"expr 1i\"];\n+    N14[label=\"expr x == 1i\"];\n+    N15[label=\"expr break \\'outer\"];\n+    N16[label=\"(dummy_node)\"];\n+    N17[label=\"stmt break \\'outer ;\"];\n+    N18[label=\"expr \\\"unreachable\\\"\"];\n+    N19[label=\"stmt \\\"unreachable\\\";\"];\n+    N20[label=\"block { break \\'outer ; \\\"unreachable\\\"; }\"];\n+    N21[label=\"expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\"];\n+    N22[label=\"stmt if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\"];\n+    N23[label=\"expr y\"];\n+    N24[label=\"expr 2i\"];\n+    N25[label=\"expr y >= 2i\"];\n+    N26[label=\"expr break\"];\n+    N27[label=\"(dummy_node)\"];\n+    N28[label=\"stmt break ;\"];\n+    N29[label=\"expr \\\"unreachable\\\"\"];\n+    N30[label=\"stmt \\\"unreachable\\\";\"];\n+    N31[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N32[label=\"expr if y >= 2i { break ; \\\"unreachable\\\"; }\"];\n+    N33[label=\"stmt if y >= 2i { break ; \\\"unreachable\\\"; }\"];\n+    N34[label=\"expr 3i\"];\n+    N35[label=\"expr y\"];\n+    N36[label=\"expr y -= 3i\"];\n+    N37[label=\"stmt y -= 3i;\"];\n+    N38[label=\"block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l\"];\n+    N39[label=\"stmt \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l\"];\n+    N40[label=\"expr 4i\"];\n+    N41[label=\"expr y\"];\n+    N42[label=\"expr y -= 4i\"];\n+    N43[label=\"stmt y -= 4i;\"];\n+    N44[label=\"expr 5i\"];\n+    N45[label=\"expr x\"];\n+    N46[label=\"expr x -= 5i\"];\n+    N47[label=\"stmt x -= 5i;\"];\n+    N48[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { break ; \\\"unreachable\\\"; }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n+    N49[label=\"block {\\l    let mut x = 15i;\\l    let mut y = 151i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2i { break ; \\\"unreachable\\\"; }\\l                    y -= 3i;\\l                }\\l            y -= 4i;\\l            x -= 5i;\\l        }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n-    N6 -> N8;\n+    N6 -> N7;\n+    N7 -> N8;\n     N8 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n+    N10 -> N12;\n     N12 -> N13;\n-    N13 -> N7[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { break ; \\\"unreachable\\\"; }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n+    N13 -> N14;\n     N14 -> N15;\n-    N15 -> N16;\n-    N12 -> N17;\n+    N15 -> N9[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { break ; \\\"unreachable\\\"; }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n+    N14 -> N21;\n     N20 -> N21;\n-    N21 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y >= 2i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y >= 2i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l\"];\n+    N21 -> N22;\n     N22 -> N23;\n     N23 -> N24;\n-    N20 -> N25;\n     N24 -> N25;\n     N25 -> N26;\n-    N26 -> N27;\n+    N26 -> N11[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y >= 2i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y >= 2i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l\"];\n     N27 -> N28;\n     N28 -> N29;\n-    N29 -> N8;\n-    N9 -> N30;\n+    N29 -> N30;\n     N30 -> N31;\n+    N25 -> N32;\n     N31 -> N32;\n     N32 -> N33;\n     N33 -> N34;\n     N34 -> N35;\n     N35 -> N36;\n-    N36 -> N6;\n-    N7 -> N37;\n-    N37 -> N1;\n+    N36 -> N37;\n+    N37 -> N38;\n+    N38 -> N10;\n+    N11 -> N39;\n+    N39 -> N40;\n+    N40 -> N41;\n+    N41 -> N42;\n+    N42 -> N43;\n+    N43 -> N44;\n+    N44 -> N45;\n+    N45 -> N46;\n+    N46 -> N47;\n+    N47 -> N48;\n+    N48 -> N8;\n+    N9 -> N49;\n+    N49 -> N1;\n }"}, {"sha": "16b871bd844bf21779eb275fcabfc8a193a5ec60", "filename": "src/test/run-make/graphviz-flowgraph/f16.dot-expected.dot", "status": "modified", "additions": 76, "deletions": 48, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,79 +3,107 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 16i\"];\n     N3[label=\"local mut x\"];\n-    N4[label=\"expr 16i\"];\n-    N5[label=\"local mut y\"];\n-    N6[label=\"(dummy_node)\"];\n-    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 1i { break ; \\\"unreachable\\\"; }\\l                y -= 1i;\\l            }\\l        y -= 1i;\\l        x -= 1i;\\l    }\\l\"];\n+    N4[label=\"stmt let mut x = 16i;\"];\n+    N5[label=\"expr 16i\"];\n+    N6[label=\"local mut y\"];\n+    N7[label=\"stmt let mut y = 16i;\"];\n     N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l\"];\n-    N10[label=\"expr x\"];\n-    N11[label=\"expr 1i\"];\n-    N12[label=\"expr x == 1i\"];\n-    N13[label=\"expr continue \\'outer\"];\n-    N14[label=\"(dummy_node)\"];\n-    N15[label=\"expr \\\"unreachable\\\"\"];\n-    N16[label=\"block { continue \\'outer ; \\\"unreachable\\\"; }\"];\n-    N17[label=\"expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\"];\n-    N18[label=\"expr y\"];\n-    N19[label=\"expr 1i\"];\n-    N20[label=\"expr y >= 1i\"];\n-    N21[label=\"expr break\"];\n-    N22[label=\"(dummy_node)\"];\n-    N23[label=\"expr \\\"unreachable\\\"\"];\n-    N24[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N25[label=\"expr if y >= 1i { break ; \\\"unreachable\\\"; }\"];\n-    N26[label=\"expr 1i\"];\n-    N27[label=\"expr y\"];\n-    N28[label=\"expr y -= 1i\"];\n-    N29[label=\"block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l\"];\n-    N30[label=\"expr 1i\"];\n-    N31[label=\"expr y\"];\n-    N32[label=\"expr y -= 1i\"];\n-    N33[label=\"expr 1i\"];\n-    N34[label=\"expr x\"];\n-    N35[label=\"expr x -= 1i\"];\n-    N36[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 1i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n-    N37[label=\"expr \\\"unreachable\\\"\"];\n-    N38[label=\"block {\\l    let mut x = 16i;\\l    let mut y = 16i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 1i { break ; \\\"unreachable\\\"; }\\l                    y -= 1i;\\l                }\\l            y -= 1i;\\l            x -= 1i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N9[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 1i { break ; \\\"unreachable\\\"; }\\l                y -= 1i;\\l            }\\l        y -= 1i;\\l        x -= 1i;\\l    }\\l\"];\n+    N10[label=\"(dummy_node)\"];\n+    N11[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l\"];\n+    N12[label=\"expr x\"];\n+    N13[label=\"expr 1i\"];\n+    N14[label=\"expr x == 1i\"];\n+    N15[label=\"expr continue \\'outer\"];\n+    N16[label=\"(dummy_node)\"];\n+    N17[label=\"stmt continue \\'outer ;\"];\n+    N18[label=\"expr \\\"unreachable\\\"\"];\n+    N19[label=\"stmt \\\"unreachable\\\";\"];\n+    N20[label=\"block { continue \\'outer ; \\\"unreachable\\\"; }\"];\n+    N21[label=\"expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\"];\n+    N22[label=\"stmt if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\"];\n+    N23[label=\"expr y\"];\n+    N24[label=\"expr 1i\"];\n+    N25[label=\"expr y >= 1i\"];\n+    N26[label=\"expr break\"];\n+    N27[label=\"(dummy_node)\"];\n+    N28[label=\"stmt break ;\"];\n+    N29[label=\"expr \\\"unreachable\\\"\"];\n+    N30[label=\"stmt \\\"unreachable\\\";\"];\n+    N31[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N32[label=\"expr if y >= 1i { break ; \\\"unreachable\\\"; }\"];\n+    N33[label=\"stmt if y >= 1i { break ; \\\"unreachable\\\"; }\"];\n+    N34[label=\"expr 1i\"];\n+    N35[label=\"expr y\"];\n+    N36[label=\"expr y -= 1i\"];\n+    N37[label=\"stmt y -= 1i;\"];\n+    N38[label=\"block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l\"];\n+    N39[label=\"stmt \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l\"];\n+    N40[label=\"expr 1i\"];\n+    N41[label=\"expr y\"];\n+    N42[label=\"expr y -= 1i\"];\n+    N43[label=\"stmt y -= 1i;\"];\n+    N44[label=\"expr 1i\"];\n+    N45[label=\"expr x\"];\n+    N46[label=\"expr x -= 1i\"];\n+    N47[label=\"stmt x -= 1i;\"];\n+    N48[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 1i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n+    N49[label=\"stmt \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 1i { break ; \\\"unreachable\\\"; }\\l                y -= 1i;\\l            }\\l        y -= 1i;\\l        x -= 1i;\\l    }\\l\"];\n+    N50[label=\"expr \\\"unreachable\\\"\"];\n+    N51[label=\"stmt \\\"unreachable\\\";\"];\n+    N52[label=\"block {\\l    let mut x = 16i;\\l    let mut y = 16i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 1i { break ; \\\"unreachable\\\"; }\\l                    y -= 1i;\\l                }\\l            y -= 1i;\\l            x -= 1i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n-    N6 -> N8;\n+    N6 -> N7;\n+    N7 -> N8;\n     N8 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n+    N10 -> N12;\n     N12 -> N13;\n-    N13 -> N6[label=\"exiting scope_0 expr continue \\'outer,\\lexiting scope_1 stmt continue \\'outer ;,\\lexiting scope_2 block { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 1i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n+    N13 -> N14;\n     N14 -> N15;\n-    N15 -> N16;\n-    N12 -> N17;\n+    N15 -> N8[label=\"exiting scope_0 expr continue \\'outer,\\lexiting scope_1 stmt continue \\'outer ;,\\lexiting scope_2 block { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 1i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n+    N14 -> N21;\n     N20 -> N21;\n-    N21 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y >= 1i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y >= 1i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l\"];\n+    N21 -> N22;\n     N22 -> N23;\n     N23 -> N24;\n-    N20 -> N25;\n     N24 -> N25;\n     N25 -> N26;\n-    N26 -> N27;\n+    N26 -> N11[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y >= 1i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y >= 1i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l\"];\n     N27 -> N28;\n     N28 -> N29;\n-    N29 -> N8;\n-    N9 -> N30;\n+    N29 -> N30;\n     N30 -> N31;\n+    N25 -> N32;\n     N31 -> N32;\n     N32 -> N33;\n     N33 -> N34;\n     N34 -> N35;\n     N35 -> N36;\n-    N36 -> N6;\n-    N7 -> N37;\n+    N36 -> N37;\n     N37 -> N38;\n-    N38 -> N1;\n+    N38 -> N10;\n+    N11 -> N39;\n+    N39 -> N40;\n+    N40 -> N41;\n+    N41 -> N42;\n+    N42 -> N43;\n+    N43 -> N44;\n+    N44 -> N45;\n+    N45 -> N46;\n+    N46 -> N47;\n+    N47 -> N48;\n+    N48 -> N8;\n+    N9 -> N49;\n+    N49 -> N50;\n+    N50 -> N51;\n+    N51 -> N52;\n+    N52 -> N1;\n }"}, {"sha": "c78224c00df8a552bd7cb300ac081362003e0ca0", "filename": "src/test/run-make/graphviz-flowgraph/f17.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -6,12 +6,14 @@ digraph block {\n     N4[label=\"expr 17i\"];\n     N5[label=\"expr [1i, 7i, 17i]\"];\n     N6[label=\"local _v\"];\n-    N7[label=\"block { let _v = [1i, 7i, 17i]; }\"];\n+    N7[label=\"stmt let _v = [1i, 7i, 17i];\"];\n+    N8[label=\"block { let _v = [1i, 7i, 17i]; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n-    N7 -> N1;\n+    N7 -> N8;\n+    N8 -> N1;\n }"}, {"sha": "c4a39a519eddf7cd2d193588ef7cba5ddc77abb5", "filename": "src/test/run-make/graphviz-flowgraph/f18.dot-expected.dot", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -1,17 +1,21 @@\n digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n-    N2[label=\"expr inner\"];\n+    N2[label=\"stmt fn inner(x: int) -> int { x + x }\"];\n     N3[label=\"expr inner\"];\n-    N4[label=\"expr 18\"];\n-    N5[label=\"expr inner(18)\"];\n-    N6[label=\"expr inner(inner(18))\"];\n-    N7[label=\"block {\\l    fn inner(x: int) -> int { x + x }\\l    inner(inner(18));\\l}\\l\"];\n+    N4[label=\"expr inner\"];\n+    N5[label=\"expr 18\"];\n+    N6[label=\"expr inner(18)\"];\n+    N7[label=\"expr inner(inner(18))\"];\n+    N8[label=\"stmt inner(inner(18));\"];\n+    N9[label=\"block {\\l    fn inner(x: int) -> int { x + x }\\l    inner(inner(18));\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n-    N7 -> N1;\n+    N7 -> N8;\n+    N8 -> N9;\n+    N9 -> N1;\n }"}, {"sha": "8d21ef8091734631e524299d8d163aec1dcc8365", "filename": "src/test/run-make/graphviz-flowgraph/f19.dot-expected.dot", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -1,19 +1,27 @@\n digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n-    N2[label=\"expr 19\"];\n-    N3[label=\"expr S19{x: 19,}\"];\n-    N4[label=\"local s\"];\n-    N5[label=\"expr s\"];\n-    N6[label=\"expr s.inner()\"];\n-    N7[label=\"expr s.inner().inner()\"];\n-    N8[label=\"block {\\l    struct S19 {\\l        x: int,\\l    }\\l    impl S19 {\\l        fn inner(self) -> S19 { S19{x: self.x + self.x,} }\\l    }\\l    let s = S19{x: 19,};\\l    s.inner().inner();\\l}\\l\"];\n+    N2[label=\"stmt struct S19 {\\l    x: int,\\l}\\l\"];\n+    N3[label=\"stmt impl S19 {\\l    fn inner(self) -> S19 { S19{x: self.x + self.x,} }\\l}\\l\"];\n+    N4[label=\"expr 19\"];\n+    N5[label=\"expr S19{x: 19,}\"];\n+    N6[label=\"local s\"];\n+    N7[label=\"stmt let s = S19{x: 19,};\"];\n+    N8[label=\"expr s\"];\n+    N9[label=\"expr s.inner()\"];\n+    N10[label=\"expr s.inner().inner()\"];\n+    N11[label=\"stmt s.inner().inner();\"];\n+    N12[label=\"block {\\l    struct S19 {\\l        x: int,\\l    }\\l    impl S19 {\\l        fn inner(self) -> S19 { S19{x: self.x + self.x,} }\\l    }\\l    let s = S19{x: 19,};\\l    s.inner().inner();\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n     N7 -> N8;\n-    N8 -> N1;\n+    N8 -> N9;\n+    N9 -> N10;\n+    N10 -> N11;\n+    N11 -> N12;\n+    N12 -> N1;\n }"}, {"sha": "a625a1a0026fa254c52bd1753c217ef33ba7a4fc", "filename": "src/test/run-make/graphviz-flowgraph/f20.dot-expected.dot", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -6,10 +6,12 @@ digraph block {\n     N4[label=\"expr 20u\"];\n     N5[label=\"expr [2u, 0u, 20u]\"];\n     N6[label=\"local v\"];\n-    N7[label=\"expr v\"];\n-    N8[label=\"expr 20u\"];\n-    N9[label=\"expr v[20u]\"];\n-    N10[label=\"block { let v = [2u, 0u, 20u]; v[20u]; }\"];\n+    N7[label=\"stmt let v = [2u, 0u, 20u];\"];\n+    N8[label=\"expr v\"];\n+    N9[label=\"expr 20u\"];\n+    N10[label=\"expr v[20u]\"];\n+    N11[label=\"stmt v[20u];\"];\n+    N12[label=\"block { let v = [2u, 0u, 20u]; v[20u]; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -19,5 +21,7 @@ digraph block {\n     N7 -> N8;\n     N8 -> N9;\n     N9 -> N10;\n-    N10 -> N1;\n+    N10 -> N11;\n+    N11 -> N12;\n+    N12 -> N1;\n }"}, {"sha": "ad2ef60ce29183d7040f09abcc1de7dcefe9700f", "filename": "src/test/run-make/graphviz-flowgraph/f21.dot-expected.dot", "status": "modified", "additions": 69, "deletions": 45, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,73 +3,97 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 15i\"];\n     N3[label=\"local mut x\"];\n-    N4[label=\"expr 151i\"];\n-    N5[label=\"local mut y\"];\n-    N6[label=\"(dummy_node)\"];\n-    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { return; \\\"unreachable\\\"; }\\l                y -= 3i;\\l                x -= 5i;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n+    N4[label=\"stmt let mut x = 15i;\"];\n+    N5[label=\"expr 151i\"];\n+    N6[label=\"local mut y\"];\n+    N7[label=\"stmt let mut y = 151i;\"];\n     N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        y -= 3i;\\l        x -= 5i;\\l    }\\l\"];\n-    N10[label=\"expr x\"];\n-    N11[label=\"expr 1i\"];\n-    N12[label=\"expr x == 1i\"];\n-    N13[label=\"expr break \\'outer\"];\n-    N14[label=\"(dummy_node)\"];\n-    N15[label=\"expr \\\"unreachable\\\"\"];\n-    N16[label=\"block { break \\'outer ; \\\"unreachable\\\"; }\"];\n-    N17[label=\"expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\"];\n-    N18[label=\"expr y\"];\n-    N19[label=\"expr 2i\"];\n-    N20[label=\"expr y >= 2i\"];\n-    N21[label=\"expr return\"];\n-    N22[label=\"(dummy_node)\"];\n-    N23[label=\"expr \\\"unreachable\\\"\"];\n-    N24[label=\"block { return; \\\"unreachable\\\"; }\"];\n-    N25[label=\"expr if y >= 2i { return; \\\"unreachable\\\"; }\"];\n-    N26[label=\"expr 3i\"];\n-    N27[label=\"expr y\"];\n-    N28[label=\"expr y -= 3i\"];\n-    N29[label=\"expr 5i\"];\n-    N30[label=\"expr x\"];\n-    N31[label=\"expr x -= 5i\"];\n-    N32[label=\"block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { return; \\\"unreachable\\\"; }\\l    y -= 3i;\\l    x -= 5i;\\l}\\l\"];\n-    N33[label=\"expr \\\"unreachable\\\"\"];\n-    N34[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { return; \\\"unreachable\\\"; }\\l            y -= 3i;\\l            x -= 5i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n-    N35[label=\"block {\\l    let mut x = 15i;\\l    let mut y = 151i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2i { return; \\\"unreachable\\\"; }\\l                    y -= 3i;\\l                    x -= 5i;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l}\\l\"];\n+    N9[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { return; \\\"unreachable\\\"; }\\l                y -= 3i;\\l                x -= 5i;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n+    N10[label=\"(dummy_node)\"];\n+    N11[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        y -= 3i;\\l        x -= 5i;\\l    }\\l\"];\n+    N12[label=\"expr x\"];\n+    N13[label=\"expr 1i\"];\n+    N14[label=\"expr x == 1i\"];\n+    N15[label=\"expr break \\'outer\"];\n+    N16[label=\"(dummy_node)\"];\n+    N17[label=\"stmt break \\'outer ;\"];\n+    N18[label=\"expr \\\"unreachable\\\"\"];\n+    N19[label=\"stmt \\\"unreachable\\\";\"];\n+    N20[label=\"block { break \\'outer ; \\\"unreachable\\\"; }\"];\n+    N21[label=\"expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\"];\n+    N22[label=\"stmt if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\"];\n+    N23[label=\"expr y\"];\n+    N24[label=\"expr 2i\"];\n+    N25[label=\"expr y >= 2i\"];\n+    N26[label=\"expr return\"];\n+    N27[label=\"(dummy_node)\"];\n+    N28[label=\"stmt return;\"];\n+    N29[label=\"expr \\\"unreachable\\\"\"];\n+    N30[label=\"stmt \\\"unreachable\\\";\"];\n+    N31[label=\"block { return; \\\"unreachable\\\"; }\"];\n+    N32[label=\"expr if y >= 2i { return; \\\"unreachable\\\"; }\"];\n+    N33[label=\"stmt if y >= 2i { return; \\\"unreachable\\\"; }\"];\n+    N34[label=\"expr 3i\"];\n+    N35[label=\"expr y\"];\n+    N36[label=\"expr y -= 3i\"];\n+    N37[label=\"stmt y -= 3i;\"];\n+    N38[label=\"expr 5i\"];\n+    N39[label=\"expr x\"];\n+    N40[label=\"expr x -= 5i\"];\n+    N41[label=\"stmt x -= 5i;\"];\n+    N42[label=\"block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { return; \\\"unreachable\\\"; }\\l    y -= 3i;\\l    x -= 5i;\\l}\\l\"];\n+    N43[label=\"stmt \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        y -= 3i;\\l        x -= 5i;\\l    }\\l\"];\n+    N44[label=\"expr \\\"unreachable\\\"\"];\n+    N45[label=\"stmt \\\"unreachable\\\";\"];\n+    N46[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { return; \\\"unreachable\\\"; }\\l            y -= 3i;\\l            x -= 5i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N47[label=\"block {\\l    let mut x = 15i;\\l    let mut y = 151i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2i { return; \\\"unreachable\\\"; }\\l                    y -= 3i;\\l                    x -= 5i;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n-    N6 -> N8;\n+    N6 -> N7;\n+    N7 -> N8;\n     N8 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n+    N10 -> N12;\n     N12 -> N13;\n-    N13 -> N7[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { return; \\\"unreachable\\\"; }\\l    y -= 3i;\\l    x -= 5i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        y -= 3i;\\l        x -= 5i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        y -= 3i;\\l        x -= 5i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { return; \\\"unreachable\\\"; }\\l            y -= 3i;\\l            x -= 5i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N13 -> N14;\n     N14 -> N15;\n-    N15 -> N16;\n-    N12 -> N17;\n+    N15 -> N9[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { return; \\\"unreachable\\\"; }\\l    y -= 3i;\\l    x -= 5i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        y -= 3i;\\l        x -= 5i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        y -= 3i;\\l        x -= 5i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { return; \\\"unreachable\\\"; }\\l            y -= 3i;\\l            x -= 5i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n+    N14 -> N21;\n     N20 -> N21;\n-    N21 -> N1[label=\"exiting scope_0 expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        y -= 3i;\\l        x -= 5i;\\l    }\\l,\\lexiting scope_1 expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { return; \\\"unreachable\\\"; }\\l                y -= 3i;\\l                x -= 5i;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n+    N21 -> N22;\n     N22 -> N23;\n     N23 -> N24;\n-    N20 -> N25;\n     N24 -> N25;\n     N25 -> N26;\n-    N26 -> N27;\n+    N26 -> N1[label=\"exiting scope_0 expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        y -= 3i;\\l        x -= 5i;\\l    }\\l,\\lexiting scope_1 expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { return; \\\"unreachable\\\"; }\\l                y -= 3i;\\l                x -= 5i;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n     N27 -> N28;\n     N28 -> N29;\n     N29 -> N30;\n     N30 -> N31;\n+    N25 -> N32;\n     N31 -> N32;\n-    N32 -> N8;\n-    N9 -> N33;\n+    N32 -> N33;\n     N33 -> N34;\n-    N34 -> N6;\n-    N7 -> N35;\n-    N35 -> N1;\n+    N34 -> N35;\n+    N35 -> N36;\n+    N36 -> N37;\n+    N37 -> N38;\n+    N38 -> N39;\n+    N39 -> N40;\n+    N40 -> N41;\n+    N41 -> N42;\n+    N42 -> N10;\n+    N11 -> N43;\n+    N43 -> N44;\n+    N44 -> N45;\n+    N45 -> N46;\n+    N46 -> N8;\n+    N9 -> N47;\n+    N47 -> N1;\n }"}, {"sha": "dcceb5bb937dac5548de1e1100de6d2eb3bfb8f0", "filename": "src/test/run-make/graphviz-flowgraph/f22.dot-expected.dot", "status": "modified", "additions": 74, "deletions": 46, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,75 +3,103 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 15i\"];\n     N3[label=\"local mut x\"];\n-    N4[label=\"expr 151i\"];\n-    N5[label=\"local mut y\"];\n-    N6[label=\"(dummy_node)\"];\n-    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { return; \\\"unreachable\\\"; }\\l                x -= 1i;\\l                y -= 3i;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n+    N4[label=\"stmt let mut x = 15i;\"];\n+    N5[label=\"expr 151i\"];\n+    N6[label=\"local mut y\"];\n+    N7[label=\"stmt let mut y = 151i;\"];\n     N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        y -= 3i;\\l    }\\l\"];\n-    N10[label=\"expr x\"];\n-    N11[label=\"expr 1i\"];\n-    N12[label=\"expr x == 1i\"];\n-    N13[label=\"expr continue \\'outer\"];\n-    N14[label=\"(dummy_node)\"];\n-    N15[label=\"expr \\\"unreachable\\\"\"];\n-    N16[label=\"block { continue \\'outer ; \\\"unreachable\\\"; }\"];\n-    N17[label=\"expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\"];\n-    N18[label=\"expr y\"];\n-    N19[label=\"expr 2i\"];\n-    N20[label=\"expr y >= 2i\"];\n-    N21[label=\"expr return\"];\n-    N22[label=\"(dummy_node)\"];\n-    N23[label=\"expr \\\"unreachable\\\"\"];\n-    N24[label=\"block { return; \\\"unreachable\\\"; }\"];\n-    N25[label=\"expr if y >= 2i { return; \\\"unreachable\\\"; }\"];\n-    N26[label=\"expr 1i\"];\n-    N27[label=\"expr x\"];\n-    N28[label=\"expr x -= 1i\"];\n-    N29[label=\"expr 3i\"];\n-    N30[label=\"expr y\"];\n-    N31[label=\"expr y -= 3i\"];\n-    N32[label=\"block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { return; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    y -= 3i;\\l}\\l\"];\n-    N33[label=\"expr \\\"unreachable\\\"\"];\n-    N34[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { return; \\\"unreachable\\\"; }\\l            x -= 1i;\\l            y -= 3i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n-    N35[label=\"expr \\\"unreachable\\\"\"];\n-    N36[label=\"block {\\l    let mut x = 15i;\\l    let mut y = 151i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2i { return; \\\"unreachable\\\"; }\\l                    x -= 1i;\\l                    y -= 3i;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N9[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { return; \\\"unreachable\\\"; }\\l                x -= 1i;\\l                y -= 3i;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n+    N10[label=\"(dummy_node)\"];\n+    N11[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        y -= 3i;\\l    }\\l\"];\n+    N12[label=\"expr x\"];\n+    N13[label=\"expr 1i\"];\n+    N14[label=\"expr x == 1i\"];\n+    N15[label=\"expr continue \\'outer\"];\n+    N16[label=\"(dummy_node)\"];\n+    N17[label=\"stmt continue \\'outer ;\"];\n+    N18[label=\"expr \\\"unreachable\\\"\"];\n+    N19[label=\"stmt \\\"unreachable\\\";\"];\n+    N20[label=\"block { continue \\'outer ; \\\"unreachable\\\"; }\"];\n+    N21[label=\"expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\"];\n+    N22[label=\"stmt if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\"];\n+    N23[label=\"expr y\"];\n+    N24[label=\"expr 2i\"];\n+    N25[label=\"expr y >= 2i\"];\n+    N26[label=\"expr return\"];\n+    N27[label=\"(dummy_node)\"];\n+    N28[label=\"stmt return;\"];\n+    N29[label=\"expr \\\"unreachable\\\"\"];\n+    N30[label=\"stmt \\\"unreachable\\\";\"];\n+    N31[label=\"block { return; \\\"unreachable\\\"; }\"];\n+    N32[label=\"expr if y >= 2i { return; \\\"unreachable\\\"; }\"];\n+    N33[label=\"stmt if y >= 2i { return; \\\"unreachable\\\"; }\"];\n+    N34[label=\"expr 1i\"];\n+    N35[label=\"expr x\"];\n+    N36[label=\"expr x -= 1i\"];\n+    N37[label=\"stmt x -= 1i;\"];\n+    N38[label=\"expr 3i\"];\n+    N39[label=\"expr y\"];\n+    N40[label=\"expr y -= 3i\"];\n+    N41[label=\"stmt y -= 3i;\"];\n+    N42[label=\"block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { return; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    y -= 3i;\\l}\\l\"];\n+    N43[label=\"stmt \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        y -= 3i;\\l    }\\l\"];\n+    N44[label=\"expr \\\"unreachable\\\"\"];\n+    N45[label=\"stmt \\\"unreachable\\\";\"];\n+    N46[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { return; \\\"unreachable\\\"; }\\l            x -= 1i;\\l            y -= 3i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N47[label=\"stmt \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { return; \\\"unreachable\\\"; }\\l                x -= 1i;\\l                y -= 3i;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n+    N48[label=\"expr \\\"unreachable\\\"\"];\n+    N49[label=\"stmt \\\"unreachable\\\";\"];\n+    N50[label=\"block {\\l    let mut x = 15i;\\l    let mut y = 151i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2i { return; \\\"unreachable\\\"; }\\l                    x -= 1i;\\l                    y -= 3i;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n-    N6 -> N8;\n+    N6 -> N7;\n+    N7 -> N8;\n     N8 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n+    N10 -> N12;\n     N12 -> N13;\n-    N13 -> N6[label=\"exiting scope_0 expr continue \\'outer,\\lexiting scope_1 stmt continue \\'outer ;,\\lexiting scope_2 block { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { return; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    y -= 3i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        y -= 3i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        y -= 3i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { return; \\\"unreachable\\\"; }\\l            x -= 1i;\\l            y -= 3i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N13 -> N14;\n     N14 -> N15;\n-    N15 -> N16;\n-    N12 -> N17;\n+    N15 -> N8[label=\"exiting scope_0 expr continue \\'outer,\\lexiting scope_1 stmt continue \\'outer ;,\\lexiting scope_2 block { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { return; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    y -= 3i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        y -= 3i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        y -= 3i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { return; \\\"unreachable\\\"; }\\l            x -= 1i;\\l            y -= 3i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n+    N14 -> N21;\n     N20 -> N21;\n-    N21 -> N1[label=\"exiting scope_0 expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        y -= 3i;\\l    }\\l,\\lexiting scope_1 expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { return; \\\"unreachable\\\"; }\\l                x -= 1i;\\l                y -= 3i;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n+    N21 -> N22;\n     N22 -> N23;\n     N23 -> N24;\n-    N20 -> N25;\n     N24 -> N25;\n     N25 -> N26;\n-    N26 -> N27;\n+    N26 -> N1[label=\"exiting scope_0 expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { return; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        y -= 3i;\\l    }\\l,\\lexiting scope_1 expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { return; \\\"unreachable\\\"; }\\l                x -= 1i;\\l                y -= 3i;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n     N27 -> N28;\n     N28 -> N29;\n     N29 -> N30;\n     N30 -> N31;\n+    N25 -> N32;\n     N31 -> N32;\n-    N32 -> N8;\n-    N9 -> N33;\n+    N32 -> N33;\n     N33 -> N34;\n-    N34 -> N6;\n-    N7 -> N35;\n+    N34 -> N35;\n     N35 -> N36;\n-    N36 -> N1;\n+    N36 -> N37;\n+    N37 -> N38;\n+    N38 -> N39;\n+    N39 -> N40;\n+    N40 -> N41;\n+    N41 -> N42;\n+    N42 -> N10;\n+    N11 -> N43;\n+    N43 -> N44;\n+    N44 -> N45;\n+    N45 -> N46;\n+    N46 -> N8;\n+    N9 -> N47;\n+    N47 -> N48;\n+    N48 -> N49;\n+    N49 -> N50;\n+    N50 -> N1;\n }"}, {"sha": "034ecfb7f2099d2a74fe09266f93caf5ad2413e4", "filename": "src/test/run-make/graphviz-flowgraph/f23.dot-expected.dot", "status": "modified", "additions": 73, "deletions": 55, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,46 +3,55 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 23i\"];\n     N3[label=\"local mut x\"];\n-    N4[label=\"expr 23i\"];\n-    N5[label=\"local mut y\"];\n-    N6[label=\"expr 23i\"];\n-    N7[label=\"local mut z\"];\n-    N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr x\"];\n-    N10[label=\"expr 0i\"];\n-    N11[label=\"expr x > 0i\"];\n-    N12[label=\"expr while x > 0i {\\l    x -= 1i;\\l    while y > 0i {\\l        y -= 1i;\\l        while z > 0i { z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n-    N13[label=\"expr 1i\"];\n-    N14[label=\"expr x\"];\n-    N15[label=\"expr x -= 1i\"];\n-    N16[label=\"(dummy_node)\"];\n-    N17[label=\"expr y\"];\n-    N18[label=\"expr 0i\"];\n-    N19[label=\"expr y > 0i\"];\n-    N20[label=\"expr while y > 0i {\\l    y -= 1i;\\l    while z > 0i { z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l\"];\n-    N21[label=\"expr 1i\"];\n-    N22[label=\"expr y\"];\n-    N23[label=\"expr y -= 1i\"];\n-    N24[label=\"(dummy_node)\"];\n-    N25[label=\"expr z\"];\n-    N26[label=\"expr 0i\"];\n-    N27[label=\"expr z > 0i\"];\n-    N28[label=\"expr while z > 0i { z -= 1i; }\"];\n-    N29[label=\"expr 1i\"];\n+    N4[label=\"stmt let mut x = 23i;\"];\n+    N5[label=\"expr 23i\"];\n+    N6[label=\"local mut y\"];\n+    N7[label=\"stmt let mut y = 23i;\"];\n+    N8[label=\"expr 23i\"];\n+    N9[label=\"local mut z\"];\n+    N10[label=\"stmt let mut z = 23i;\"];\n+    N11[label=\"(dummy_node)\"];\n+    N12[label=\"expr x\"];\n+    N13[label=\"expr 0i\"];\n+    N14[label=\"expr x > 0i\"];\n+    N15[label=\"expr while x > 0i {\\l    x -= 1i;\\l    while y > 0i {\\l        y -= 1i;\\l        while z > 0i { z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N16[label=\"expr 1i\"];\n+    N17[label=\"expr x\"];\n+    N18[label=\"expr x -= 1i\"];\n+    N19[label=\"stmt x -= 1i;\"];\n+    N20[label=\"(dummy_node)\"];\n+    N21[label=\"expr y\"];\n+    N22[label=\"expr 0i\"];\n+    N23[label=\"expr y > 0i\"];\n+    N24[label=\"expr while y > 0i {\\l    y -= 1i;\\l    while z > 0i { z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N25[label=\"expr 1i\"];\n+    N26[label=\"expr y\"];\n+    N27[label=\"expr y -= 1i\"];\n+    N28[label=\"stmt y -= 1i;\"];\n+    N29[label=\"(dummy_node)\"];\n     N30[label=\"expr z\"];\n-    N31[label=\"expr z -= 1i\"];\n-    N32[label=\"block { z -= 1i; }\"];\n-    N33[label=\"expr x\"];\n-    N34[label=\"expr 10i\"];\n-    N35[label=\"expr x > 10i\"];\n-    N36[label=\"expr return\"];\n-    N37[label=\"(dummy_node)\"];\n-    N38[label=\"expr \\\"unreachable\\\"\"];\n-    N39[label=\"block { return; \\\"unreachable\\\"; }\"];\n-    N40[label=\"expr if x > 10i { return; \\\"unreachable\\\"; }\"];\n-    N41[label=\"block { y -= 1i; while z > 0i { z -= 1i; } if x > 10i { return; \\\"unreachable\\\"; } }\"];\n-    N42[label=\"block {\\l    x -= 1i;\\l    while y > 0i {\\l        y -= 1i;\\l        while z > 0i { z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n-    N43[label=\"block {\\l    let mut x = 23i;\\l    let mut y = 23i;\\l    let mut z = 23i;\\l    while x > 0i {\\l        x -= 1i;\\l        while y > 0i {\\l            y -= 1i;\\l            while z > 0i { z -= 1i; }\\l            if x > 10i { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n+    N31[label=\"expr 0i\"];\n+    N32[label=\"expr z > 0i\"];\n+    N33[label=\"expr while z > 0i { z -= 1i; }\"];\n+    N34[label=\"expr 1i\"];\n+    N35[label=\"expr z\"];\n+    N36[label=\"expr z -= 1i\"];\n+    N37[label=\"stmt z -= 1i;\"];\n+    N38[label=\"block { z -= 1i; }\"];\n+    N39[label=\"stmt while z > 0i { z -= 1i; }\"];\n+    N40[label=\"expr x\"];\n+    N41[label=\"expr 10i\"];\n+    N42[label=\"expr x > 10i\"];\n+    N43[label=\"expr return\"];\n+    N44[label=\"(dummy_node)\"];\n+    N45[label=\"stmt return;\"];\n+    N46[label=\"expr \\\"unreachable\\\"\"];\n+    N47[label=\"stmt \\\"unreachable\\\";\"];\n+    N48[label=\"block { return; \\\"unreachable\\\"; }\"];\n+    N49[label=\"expr if x > 10i { return; \\\"unreachable\\\"; }\"];\n+    N50[label=\"block { y -= 1i; while z > 0i { z -= 1i; } if x > 10i { return; \\\"unreachable\\\"; } }\"];\n+    N51[label=\"block {\\l    x -= 1i;\\l    while y > 0i {\\l        y -= 1i;\\l        while z > 0i { z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N52[label=\"block {\\l    let mut x = 23i;\\l    let mut y = 23i;\\l    let mut z = 23i;\\l    while x > 0i {\\l        x -= 1i;\\l        while y > 0i {\\l            y -= 1i;\\l            while z > 0i { z -= 1i; }\\l            if x > 10i { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -54,40 +63,49 @@ digraph block {\n     N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n-    N11 -> N13;\n+    N12 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n-    N15 -> N16;\n+    N14 -> N16;\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n-    N19 -> N21;\n+    N20 -> N21;\n     N21 -> N22;\n     N22 -> N23;\n     N23 -> N24;\n-    N24 -> N25;\n+    N23 -> N25;\n     N25 -> N26;\n     N26 -> N27;\n     N27 -> N28;\n-    N27 -> N29;\n+    N28 -> N29;\n     N29 -> N30;\n     N30 -> N31;\n     N31 -> N32;\n-    N32 -> N24;\n-    N28 -> N33;\n-    N33 -> N34;\n+    N32 -> N33;\n+    N32 -> N34;\n     N34 -> N35;\n     N35 -> N36;\n-    N36 -> N1[label=\"exiting scope_0 expr while y > 0i {\\l    y -= 1i;\\l    while z > 0i { z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l,\\lexiting scope_1 expr while x > 0i {\\l    x -= 1i;\\l    while y > 0i {\\l        y -= 1i;\\l        while z > 0i { z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N36 -> N37;\n     N37 -> N38;\n-    N38 -> N39;\n-    N35 -> N40;\n+    N38 -> N29;\n+    N33 -> N39;\n     N39 -> N40;\n     N40 -> N41;\n-    N41 -> N16;\n-    N20 -> N42;\n-    N42 -> N8;\n-    N12 -> N43;\n-    N43 -> N1;\n+    N41 -> N42;\n+    N42 -> N43;\n+    N43 -> N1[label=\"exiting scope_0 expr while y > 0i {\\l    y -= 1i;\\l    while z > 0i { z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l,\\lexiting scope_1 expr while x > 0i {\\l    x -= 1i;\\l    while y > 0i {\\l        y -= 1i;\\l        while z > 0i { z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N44 -> N45;\n+    N45 -> N46;\n+    N46 -> N47;\n+    N47 -> N48;\n+    N42 -> N49;\n+    N48 -> N49;\n+    N49 -> N50;\n+    N50 -> N20;\n+    N24 -> N51;\n+    N51 -> N11;\n+    N15 -> N52;\n+    N52 -> N1;\n }"}, {"sha": "ddb5b865c2edb1bbd53de287e27bab725440ae73", "filename": "src/test/run-make/graphviz-flowgraph/f24.dot-expected.dot", "status": "modified", "additions": 116, "deletions": 80, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,121 +3,157 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 24i\"];\n     N3[label=\"local mut x\"];\n-    N4[label=\"expr 24i\"];\n-    N5[label=\"local mut y\"];\n-    N6[label=\"expr 24i\"];\n-    N7[label=\"local mut z\"];\n-    N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr loop  {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    loop  {\\l        if y == 0i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l        loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n-    N10[label=\"expr x\"];\n-    N11[label=\"expr 0i\"];\n-    N12[label=\"expr x == 0i\"];\n-    N13[label=\"expr break\"];\n-    N14[label=\"(dummy_node)\"];\n-    N15[label=\"expr \\\"unreachable\\\"\"];\n-    N16[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N17[label=\"expr if x == 0i { break ; \\\"unreachable\\\"; }\"];\n-    N18[label=\"expr 1i\"];\n-    N19[label=\"expr x\"];\n-    N20[label=\"expr x -= 1i\"];\n-    N21[label=\"(dummy_node)\"];\n-    N22[label=\"expr loop  {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l\"];\n-    N23[label=\"expr y\"];\n-    N24[label=\"expr 0i\"];\n-    N25[label=\"expr y == 0i\"];\n-    N26[label=\"expr break\"];\n-    N27[label=\"(dummy_node)\"];\n-    N28[label=\"expr \\\"unreachable\\\"\"];\n-    N29[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N30[label=\"expr if y == 0i { break ; \\\"unreachable\\\"; }\"];\n-    N31[label=\"expr 1i\"];\n-    N32[label=\"expr y\"];\n-    N33[label=\"expr y -= 1i\"];\n+    N4[label=\"stmt let mut x = 24i;\"];\n+    N5[label=\"expr 24i\"];\n+    N6[label=\"local mut y\"];\n+    N7[label=\"stmt let mut y = 24i;\"];\n+    N8[label=\"expr 24i\"];\n+    N9[label=\"local mut z\"];\n+    N10[label=\"stmt let mut z = 24i;\"];\n+    N11[label=\"(dummy_node)\"];\n+    N12[label=\"expr loop  {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    loop  {\\l        if y == 0i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l        loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N13[label=\"expr x\"];\n+    N14[label=\"expr 0i\"];\n+    N15[label=\"expr x == 0i\"];\n+    N16[label=\"expr break\"];\n+    N17[label=\"(dummy_node)\"];\n+    N18[label=\"stmt break ;\"];\n+    N19[label=\"expr \\\"unreachable\\\"\"];\n+    N20[label=\"stmt \\\"unreachable\\\";\"];\n+    N21[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N22[label=\"expr if x == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N23[label=\"stmt if x == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N24[label=\"expr 1i\"];\n+    N25[label=\"expr x\"];\n+    N26[label=\"expr x -= 1i\"];\n+    N27[label=\"stmt x -= 1i;\"];\n+    N28[label=\"(dummy_node)\"];\n+    N29[label=\"expr loop  {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N30[label=\"expr y\"];\n+    N31[label=\"expr 0i\"];\n+    N32[label=\"expr y == 0i\"];\n+    N33[label=\"expr break\"];\n     N34[label=\"(dummy_node)\"];\n-    N35[label=\"expr loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n-    N36[label=\"expr z\"];\n-    N37[label=\"expr 0i\"];\n-    N38[label=\"expr z == 0i\"];\n-    N39[label=\"expr break\"];\n-    N40[label=\"(dummy_node)\"];\n-    N41[label=\"expr \\\"unreachable\\\"\"];\n-    N42[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N43[label=\"expr if z == 0i { break ; \\\"unreachable\\\"; }\"];\n-    N44[label=\"expr 1i\"];\n-    N45[label=\"expr z\"];\n-    N46[label=\"expr z -= 1i\"];\n-    N47[label=\"block { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n-    N48[label=\"expr x\"];\n-    N49[label=\"expr 10i\"];\n-    N50[label=\"expr x > 10i\"];\n-    N51[label=\"expr return\"];\n-    N52[label=\"(dummy_node)\"];\n+    N35[label=\"stmt break ;\"];\n+    N36[label=\"expr \\\"unreachable\\\"\"];\n+    N37[label=\"stmt \\\"unreachable\\\";\"];\n+    N38[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N39[label=\"expr if y == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N40[label=\"stmt if y == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N41[label=\"expr 1i\"];\n+    N42[label=\"expr y\"];\n+    N43[label=\"expr y -= 1i\"];\n+    N44[label=\"stmt y -= 1i;\"];\n+    N45[label=\"(dummy_node)\"];\n+    N46[label=\"expr loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n+    N47[label=\"expr z\"];\n+    N48[label=\"expr 0i\"];\n+    N49[label=\"expr z == 0i\"];\n+    N50[label=\"expr break\"];\n+    N51[label=\"(dummy_node)\"];\n+    N52[label=\"stmt break ;\"];\n     N53[label=\"expr \\\"unreachable\\\"\"];\n-    N54[label=\"block { return; \\\"unreachable\\\"; }\"];\n-    N55[label=\"expr if x > 10i { return; \\\"unreachable\\\"; }\"];\n-    N56[label=\"block {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l\"];\n-    N57[label=\"block {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    loop  {\\l        if y == 0i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l        loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n-    N58[label=\"block {\\l    let mut x = 24i;\\l    let mut y = 24i;\\l    let mut z = 24i;\\l    loop  {\\l        if x == 0i { break ; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        loop  {\\l            if y == 0i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l            loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l            if x > 10i { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n+    N54[label=\"stmt \\\"unreachable\\\";\"];\n+    N55[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N56[label=\"expr if z == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N57[label=\"stmt if z == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N58[label=\"expr 1i\"];\n+    N59[label=\"expr z\"];\n+    N60[label=\"expr z -= 1i\"];\n+    N61[label=\"stmt z -= 1i;\"];\n+    N62[label=\"block { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n+    N63[label=\"stmt loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n+    N64[label=\"expr x\"];\n+    N65[label=\"expr 10i\"];\n+    N66[label=\"expr x > 10i\"];\n+    N67[label=\"expr return\"];\n+    N68[label=\"(dummy_node)\"];\n+    N69[label=\"stmt return;\"];\n+    N70[label=\"expr \\\"unreachable\\\"\"];\n+    N71[label=\"stmt \\\"unreachable\\\";\"];\n+    N72[label=\"block { return; \\\"unreachable\\\"; }\"];\n+    N73[label=\"expr if x > 10i { return; \\\"unreachable\\\"; }\"];\n+    N74[label=\"block {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N75[label=\"block {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    loop  {\\l        if y == 0i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l        loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N76[label=\"block {\\l    let mut x = 24i;\\l    let mut y = 24i;\\l    let mut z = 24i;\\l    loop  {\\l        if x == 0i { break ; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        loop  {\\l            if y == 0i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l            loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l            if x > 10i { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n     N7 -> N8;\n-    N8 -> N10;\n+    N8 -> N9;\n+    N9 -> N10;\n     N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n-    N13 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    loop  {\\l        if y == 0i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l        loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N11 -> N13;\n+    N13 -> N14;\n     N14 -> N15;\n     N15 -> N16;\n-    N12 -> N17;\n-    N16 -> N17;\n+    N16 -> N12[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    loop  {\\l        if y == 0i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l        loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n     N20 -> N21;\n-    N21 -> N23;\n+    N15 -> N22;\n+    N21 -> N22;\n+    N22 -> N23;\n     N23 -> N24;\n     N24 -> N25;\n     N25 -> N26;\n-    N26 -> N22[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N26 -> N27;\n     N27 -> N28;\n-    N28 -> N29;\n-    N25 -> N30;\n-    N29 -> N30;\n+    N28 -> N30;\n     N30 -> N31;\n     N31 -> N32;\n     N32 -> N33;\n-    N33 -> N34;\n-    N34 -> N36;\n+    N33 -> N29[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N34 -> N35;\n+    N35 -> N36;\n     N36 -> N37;\n     N37 -> N38;\n+    N32 -> N39;\n     N38 -> N39;\n-    N39 -> N35[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if z == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if z == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n+    N39 -> N40;\n     N40 -> N41;\n     N41 -> N42;\n-    N38 -> N43;\n     N42 -> N43;\n     N43 -> N44;\n     N44 -> N45;\n-    N45 -> N46;\n-    N46 -> N47;\n-    N47 -> N34;\n-    N35 -> N48;\n+    N45 -> N47;\n+    N47 -> N48;\n     N48 -> N49;\n     N49 -> N50;\n-    N50 -> N51;\n-    N51 -> N1[label=\"exiting scope_0 expr loop  {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l,\\lexiting scope_1 expr loop  {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    loop  {\\l        if y == 0i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l        loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N50 -> N46[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if z == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if z == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n+    N51 -> N52;\n     N52 -> N53;\n     N53 -> N54;\n-    N50 -> N55;\n     N54 -> N55;\n+    N49 -> N56;\n     N55 -> N56;\n-    N56 -> N21;\n-    N22 -> N57;\n-    N57 -> N8;\n-    N9 -> N58;\n-    N58 -> N1;\n+    N56 -> N57;\n+    N57 -> N58;\n+    N58 -> N59;\n+    N59 -> N60;\n+    N60 -> N61;\n+    N61 -> N62;\n+    N62 -> N45;\n+    N46 -> N63;\n+    N63 -> N64;\n+    N64 -> N65;\n+    N65 -> N66;\n+    N66 -> N67;\n+    N67 -> N1[label=\"exiting scope_0 expr loop  {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { return; \\\"unreachable\\\"; }\\l}\\l,\\lexiting scope_1 expr loop  {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    loop  {\\l        if y == 0i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l        loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l        if x > 10i { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N68 -> N69;\n+    N69 -> N70;\n+    N70 -> N71;\n+    N71 -> N72;\n+    N66 -> N73;\n+    N72 -> N73;\n+    N73 -> N74;\n+    N74 -> N28;\n+    N29 -> N75;\n+    N75 -> N11;\n+    N12 -> N76;\n+    N76 -> N1;\n }"}, {"sha": "9fd4dbfc395533a2af883b4303ead75beb20c957", "filename": "src/test/run-make/graphviz-flowgraph/f25.dot-expected.dot", "status": "modified", "additions": 116, "deletions": 80, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -3,121 +3,157 @@ digraph block {\n     N1[label=\"exit\"];\n     N2[label=\"expr 25i\"];\n     N3[label=\"local mut x\"];\n-    N4[label=\"expr 25i\"];\n-    N5[label=\"local mut y\"];\n-    N6[label=\"expr 25i\"];\n-    N7[label=\"local mut z\"];\n-    N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'a:\\l    loop  {\\l        if x == 0i { break ; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        \\'a:\\l            loop  {\\l                if y == 0i { break ; \\\"unreachable\\\"; }\\l                y -= 1i;\\l                \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l                if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l            }\\l    }\\l\"];\n-    N10[label=\"expr x\"];\n-    N11[label=\"expr 0i\"];\n-    N12[label=\"expr x == 0i\"];\n-    N13[label=\"expr break\"];\n-    N14[label=\"(dummy_node)\"];\n-    N15[label=\"expr \\\"unreachable\\\"\"];\n-    N16[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N17[label=\"expr if x == 0i { break ; \\\"unreachable\\\"; }\"];\n-    N18[label=\"expr 1i\"];\n-    N19[label=\"expr x\"];\n-    N20[label=\"expr x -= 1i\"];\n-    N21[label=\"(dummy_node)\"];\n-    N22[label=\"expr \\'a:\\l    loop  {\\l        if y == 0i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l        \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l        if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l    }\\l\"];\n-    N23[label=\"expr y\"];\n-    N24[label=\"expr 0i\"];\n-    N25[label=\"expr y == 0i\"];\n-    N26[label=\"expr break\"];\n-    N27[label=\"(dummy_node)\"];\n-    N28[label=\"expr \\\"unreachable\\\"\"];\n-    N29[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N30[label=\"expr if y == 0i { break ; \\\"unreachable\\\"; }\"];\n-    N31[label=\"expr 1i\"];\n-    N32[label=\"expr y\"];\n-    N33[label=\"expr y -= 1i\"];\n+    N4[label=\"stmt let mut x = 25i;\"];\n+    N5[label=\"expr 25i\"];\n+    N6[label=\"local mut y\"];\n+    N7[label=\"stmt let mut y = 25i;\"];\n+    N8[label=\"expr 25i\"];\n+    N9[label=\"local mut z\"];\n+    N10[label=\"stmt let mut z = 25i;\"];\n+    N11[label=\"(dummy_node)\"];\n+    N12[label=\"expr \\'a:\\l    loop  {\\l        if x == 0i { break ; \\\"unreachable\\\"; }\\l        x -= 1i;\\l        \\'a:\\l            loop  {\\l                if y == 0i { break ; \\\"unreachable\\\"; }\\l                y -= 1i;\\l                \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l                if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l            }\\l    }\\l\"];\n+    N13[label=\"expr x\"];\n+    N14[label=\"expr 0i\"];\n+    N15[label=\"expr x == 0i\"];\n+    N16[label=\"expr break\"];\n+    N17[label=\"(dummy_node)\"];\n+    N18[label=\"stmt break ;\"];\n+    N19[label=\"expr \\\"unreachable\\\"\"];\n+    N20[label=\"stmt \\\"unreachable\\\";\"];\n+    N21[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N22[label=\"expr if x == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N23[label=\"stmt if x == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N24[label=\"expr 1i\"];\n+    N25[label=\"expr x\"];\n+    N26[label=\"expr x -= 1i\"];\n+    N27[label=\"stmt x -= 1i;\"];\n+    N28[label=\"(dummy_node)\"];\n+    N29[label=\"expr \\'a:\\l    loop  {\\l        if y == 0i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l        \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l        if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l    }\\l\"];\n+    N30[label=\"expr y\"];\n+    N31[label=\"expr 0i\"];\n+    N32[label=\"expr y == 0i\"];\n+    N33[label=\"expr break\"];\n     N34[label=\"(dummy_node)\"];\n-    N35[label=\"expr \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n-    N36[label=\"expr z\"];\n-    N37[label=\"expr 0i\"];\n-    N38[label=\"expr z == 0i\"];\n-    N39[label=\"expr break\"];\n-    N40[label=\"(dummy_node)\"];\n-    N41[label=\"expr \\\"unreachable\\\"\"];\n-    N42[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N43[label=\"expr if z == 0i { break ; \\\"unreachable\\\"; }\"];\n-    N44[label=\"expr 1i\"];\n-    N45[label=\"expr z\"];\n-    N46[label=\"expr z -= 1i\"];\n-    N47[label=\"block { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n-    N48[label=\"expr x\"];\n-    N49[label=\"expr 10i\"];\n-    N50[label=\"expr x > 10i\"];\n-    N51[label=\"expr continue \\'a\"];\n-    N52[label=\"(dummy_node)\"];\n+    N35[label=\"stmt break ;\"];\n+    N36[label=\"expr \\\"unreachable\\\"\"];\n+    N37[label=\"stmt \\\"unreachable\\\";\"];\n+    N38[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N39[label=\"expr if y == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N40[label=\"stmt if y == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N41[label=\"expr 1i\"];\n+    N42[label=\"expr y\"];\n+    N43[label=\"expr y -= 1i\"];\n+    N44[label=\"stmt y -= 1i;\"];\n+    N45[label=\"(dummy_node)\"];\n+    N46[label=\"expr \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n+    N47[label=\"expr z\"];\n+    N48[label=\"expr 0i\"];\n+    N49[label=\"expr z == 0i\"];\n+    N50[label=\"expr break\"];\n+    N51[label=\"(dummy_node)\"];\n+    N52[label=\"stmt break ;\"];\n     N53[label=\"expr \\\"unreachable\\\"\"];\n-    N54[label=\"block { continue \\'a ; \\\"unreachable\\\"; }\"];\n-    N55[label=\"expr if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\"];\n-    N56[label=\"block {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n-    N57[label=\"block {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    \\'a:\\l        loop  {\\l            if y == 0i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l            \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l            if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l        }\\l}\\l\"];\n-    N58[label=\"block {\\l    let mut x = 25i;\\l    let mut y = 25i;\\l    let mut z = 25i;\\l    \\'a:\\l        loop  {\\l            if x == 0i { break ; \\\"unreachable\\\"; }\\l            x -= 1i;\\l            \\'a:\\l                loop  {\\l                    if y == 0i { break ; \\\"unreachable\\\"; }\\l                    y -= 1i;\\l                    \\'a:\\l                        loop  {\\l                            if z == 0i { break ; \\\"unreachable\\\"; }\\l                            z -= 1i;\\l                        }\\l                    if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l                }\\l        }\\l}\\l\"];\n+    N54[label=\"stmt \\\"unreachable\\\";\"];\n+    N55[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N56[label=\"expr if z == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N57[label=\"stmt if z == 0i { break ; \\\"unreachable\\\"; }\"];\n+    N58[label=\"expr 1i\"];\n+    N59[label=\"expr z\"];\n+    N60[label=\"expr z -= 1i\"];\n+    N61[label=\"stmt z -= 1i;\"];\n+    N62[label=\"block { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n+    N63[label=\"stmt \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n+    N64[label=\"expr x\"];\n+    N65[label=\"expr 10i\"];\n+    N66[label=\"expr x > 10i\"];\n+    N67[label=\"expr continue \\'a\"];\n+    N68[label=\"(dummy_node)\"];\n+    N69[label=\"stmt continue \\'a ;\"];\n+    N70[label=\"expr \\\"unreachable\\\"\"];\n+    N71[label=\"stmt \\\"unreachable\\\";\"];\n+    N72[label=\"block { continue \\'a ; \\\"unreachable\\\"; }\"];\n+    N73[label=\"expr if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\"];\n+    N74[label=\"block {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N75[label=\"block {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    \\'a:\\l        loop  {\\l            if y == 0i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l            \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l            if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l        }\\l}\\l\"];\n+    N76[label=\"block {\\l    let mut x = 25i;\\l    let mut y = 25i;\\l    let mut z = 25i;\\l    \\'a:\\l        loop  {\\l            if x == 0i { break ; \\\"unreachable\\\"; }\\l            x -= 1i;\\l            \\'a:\\l                loop  {\\l                    if y == 0i { break ; \\\"unreachable\\\"; }\\l                    y -= 1i;\\l                    \\'a:\\l                        loop  {\\l                            if z == 0i { break ; \\\"unreachable\\\"; }\\l                            z -= 1i;\\l                        }\\l                    if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l                }\\l        }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n     N6 -> N7;\n     N7 -> N8;\n-    N8 -> N10;\n+    N8 -> N9;\n+    N9 -> N10;\n     N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n-    N13 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    \\'a:\\l        loop  {\\l            if y == 0i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l            \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l            if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l        }\\l}\\l\"];\n+    N11 -> N13;\n+    N13 -> N14;\n     N14 -> N15;\n     N15 -> N16;\n-    N12 -> N17;\n-    N16 -> N17;\n+    N16 -> N12[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 0i { break ; \\\"unreachable\\\"; }\\l    x -= 1i;\\l    \\'a:\\l        loop  {\\l            if y == 0i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l            \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l            if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l        }\\l}\\l\"];\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n     N20 -> N21;\n-    N21 -> N23;\n+    N15 -> N22;\n+    N21 -> N22;\n+    N22 -> N23;\n     N23 -> N24;\n     N24 -> N25;\n     N25 -> N26;\n-    N26 -> N22[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N26 -> N27;\n     N27 -> N28;\n-    N28 -> N29;\n-    N25 -> N30;\n-    N29 -> N30;\n+    N28 -> N30;\n     N30 -> N31;\n     N31 -> N32;\n     N32 -> N33;\n-    N33 -> N34;\n-    N34 -> N36;\n+    N33 -> N29[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N34 -> N35;\n+    N35 -> N36;\n     N36 -> N37;\n     N37 -> N38;\n+    N32 -> N39;\n     N38 -> N39;\n-    N39 -> N35[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if z == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if z == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n+    N39 -> N40;\n     N40 -> N41;\n     N41 -> N42;\n-    N38 -> N43;\n     N42 -> N43;\n     N43 -> N44;\n     N44 -> N45;\n-    N45 -> N46;\n-    N46 -> N47;\n-    N47 -> N34;\n-    N35 -> N48;\n+    N45 -> N47;\n+    N47 -> N48;\n     N48 -> N49;\n     N49 -> N50;\n-    N50 -> N51;\n-    N51 -> N21[label=\"exiting scope_0 expr continue \\'a,\\lexiting scope_1 stmt continue \\'a ;,\\lexiting scope_2 block { continue \\'a ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x > 10i { continue \\'a ; \\\"unreachable\\\"; },\\lexiting scope_4 block {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N50 -> N46[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if z == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if z == 0i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\"];\n+    N51 -> N52;\n     N52 -> N53;\n     N53 -> N54;\n-    N50 -> N55;\n     N54 -> N55;\n+    N49 -> N56;\n     N55 -> N56;\n-    N56 -> N21;\n-    N22 -> N57;\n-    N57 -> N8;\n-    N9 -> N58;\n-    N58 -> N1;\n+    N56 -> N57;\n+    N57 -> N58;\n+    N58 -> N59;\n+    N59 -> N60;\n+    N60 -> N61;\n+    N61 -> N62;\n+    N62 -> N45;\n+    N46 -> N63;\n+    N63 -> N64;\n+    N64 -> N65;\n+    N65 -> N66;\n+    N66 -> N67;\n+    N67 -> N28[label=\"exiting scope_0 expr continue \\'a,\\lexiting scope_1 stmt continue \\'a ;,\\lexiting scope_2 block { continue \\'a ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x > 10i { continue \\'a ; \\\"unreachable\\\"; },\\lexiting scope_4 block {\\l    if y == 0i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l    \\'a: loop  { if z == 0i { break ; \\\"unreachable\\\"; } z -= 1i; }\\l    if x > 10i { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N68 -> N69;\n+    N69 -> N70;\n+    N70 -> N71;\n+    N71 -> N72;\n+    N66 -> N73;\n+    N72 -> N73;\n+    N73 -> N74;\n+    N74 -> N28;\n+    N29 -> N75;\n+    N75 -> N11;\n+    N12 -> N76;\n+    N76 -> N1;\n }"}, {"sha": "6e67b3f6add66eecc36e8d21b964dd18b64113a4", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -29,11 +29,11 @@ impl<A:Clone> Invokable<A> for Invoker<A> {\n     }\n }\n \n-fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>> {\n+fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>+'static> {\n     box Invoker {\n         a: a,\n         b: b,\n-    } as (Box<Invokable<A>>)\n+    } as (Box<Invokable<A>+'static>)\n }\n \n pub fn main() {"}, {"sha": "f224042bc79430d4fd748e8c7cd63e9ee33d9d79", "filename": "src/test/run-pass/borrowck-freeze-frozen-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -10,7 +10,7 @@\n \n // Test that a `&mut` inside of an `&` is freezable.\n \n-struct MutSlice<'a, T> {\n+struct MutSlice<'a, T:'a> {\n     data: &'a mut [T]\n }\n "}, {"sha": "69878d4a06b6bf4566a0c52e405546ec1833db1b", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -33,11 +33,11 @@ impl<A:Clone> Invokable<A> for Invoker<A> {\n     }\n }\n \n-fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>> {\n+fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>+'static> {\n     box Invoker {\n         a: a,\n         b: b,\n-    } as (Box<Invokable<A>>)\n+    } as (Box<Invokable<A>+'static>)\n }\n \n pub fn main() {"}, {"sha": "aa4d48e5ae0e1f90de4bbe8ff0884a2b82479448", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -26,7 +26,7 @@ fn call_this(f: |&str|:Send) {\n     f(\"Hello!\");\n }\n \n-fn call_that(f: <'a>|&'a int, &'a int|: -> int) {\n+fn call_that(f: <'a>|&'a int, &'a int| -> int) {\n     let (ten, forty_two) = (10, 42);\n     println!(\"Your lucky number is {}\", f(&ten, &forty_two));\n }"}, {"sha": "c2fbc2a4bf24ca92388ea4ee36373f7b310eb3cd", "filename": "src/test/run-pass/closure-syntax.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -13,26 +13,26 @@\n fn foo<T>() {}\n \n trait Bar1 {}\n-impl Bar1 for proc() {}\n+impl Bar1 for proc():'static {}\n \n trait Bar2 {}\n-impl Bar2 for proc(): Send {}\n+impl Bar2 for proc():Send {}\n \n trait Bar3 {}\n impl<'b> Bar3 for <'a>|&'a int|: 'b + Send -> &'a int {}\n \n trait Bar4 {}\n-impl Bar4 for proc<'a>(&'a int) -> &'a int {}\n+impl Bar4 for proc<'a>(&'a int):'static -> &'a int {}\n \n struct Foo<'a> {\n     a: ||: 'a,\n     b: ||: 'static,\n     c: <'b>||: 'a,\n     d: ||: 'a + Sync,\n     e: <'b>|int|: 'a + Sync -> &'b f32,\n-    f: proc(),\n-    g: proc(): 'static + Sync,\n-    h: proc<'b>(int): Sync -> &'b f32,\n+    f: proc():'static,\n+    g: proc():'static+Sync,\n+    h: proc<'b>(int):'static+Sync -> &'b f32,\n }\n \n fn f<'a>(a: &'a int, f: <'b>|&'b int| -> &'b int) -> &'a int {"}, {"sha": "60b6d8f8be064586772aec9af9236dbcfc21b566", "filename": "src/test/run-pass/colorful-write-macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -18,7 +18,7 @@ use std::fmt;\n use std::fmt::FormatWriter;\n \n struct Foo<'a> {\n-    writer: &'a mut Writer,\n+    writer: &'a mut Writer+'a,\n     other: &'a str,\n }\n "}, {"sha": "e95b1ed2f0efbc869127595819bf10a319852223", "filename": "src/test/run-pass/explicit-self-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -13,8 +13,8 @@\n  *\n  * The hash should concentrate entropy in the lower bits.\n  */\n-type HashFn<K> = proc(K) -> uint;\n-type EqFn<K> = proc(K, K) -> bool;\n+type HashFn<K> = proc(K):'static -> uint;\n+type EqFn<K> = proc(K, K):'static -> bool;\n \n struct LM { resize_at: uint, size: uint }\n "}, {"sha": "7487ea81fa8f2a04550f0d35fd4e80d21ed06a7d", "filename": "src/test/run-pass/issue-10802.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-10802.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-10802.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10802.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -30,9 +30,9 @@ trait MyTrait { }\n impl MyTrait for Box<DroppableStruct> {}\n impl MyTrait for Box<DroppableEnum> {}\n \n-struct Whatever { w: Box<MyTrait> }\n+struct Whatever { w: Box<MyTrait+'static> }\n impl  Whatever {\n-    fn new(w: Box<MyTrait>) -> Whatever {\n+    fn new(w: Box<MyTrait+'static>) -> Whatever {\n         Whatever { w: w }\n     }\n }"}, {"sha": "c2c291c0becc85319d7441f290dff30891b90610", "filename": "src/test/run-pass/issue-11205.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11205.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -49,7 +49,7 @@ fn main() {\n     foog(x, &[box 1i]);\n \n     struct T<'a> {\n-        t: [&'a Foo, ..2]\n+        t: [&'a Foo+'a, ..2]\n     }\n     let _n = T {\n         t: [&1i, &2i]\n@@ -64,7 +64,7 @@ fn main() {\n     };\n \n     struct F<'b> {\n-        t: &'b [&'b Foo]\n+        t: &'b [&'b Foo+'b]\n     }\n     let _n = F {\n         t: &[&1i, &2i]\n@@ -80,7 +80,7 @@ fn main() {\n     };\n \n     struct M<'a> {\n-        t: &'a [Box<Foo>]\n+        t: &'a [Box<Foo+'static>]\n     }\n     let _n = M {\n         t: &[box 1i, box 2i]"}, {"sha": "fa25d25df054e169d3a30bf79012bf08109b1d86", "filename": "src/test/run-pass/issue-11612.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-11612.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-11612.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11612.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -14,7 +14,7 @@\n \n trait A {}\n \n-struct B<'a, T> {\n+struct B<'a, T:'a> {\n     f: &'a T\n }\n "}, {"sha": "14c1b1b06eabf2ad1c280659d3cdc1f9169ae3c0", "filename": "src/test/run-pass/issue-11677.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-11677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-11677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11677.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -14,7 +14,8 @@\n \n trait X<T> {}\n \n-struct S<T> {f: Box<X<T>>, g: Box<X<T>>}\n+struct S<T> {f: Box<X<T>+'static>,\n+             g: Box<X<T>+'static>}\n \n struct F;\n impl X<int> for F {}"}, {"sha": "c2bd8c5b3e50cb29932ec5a5b6542552026b170c", "filename": "src/test/run-pass/issue-14958.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14958.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -14,7 +14,7 @@ trait Foo {}\n \n struct Bar;\n \n-impl<'a> std::ops::Fn<(&'a Foo,), ()> for Bar {\n+impl<'a> std::ops::Fn<(&'a Foo+'a,), ()> for Bar {\n     extern \"rust-call\" fn call(&self, _: (&'a Foo,)) {}\n }\n "}, {"sha": "74b9df9b88d87a42f0bab323883bd5522e28ae9a", "filename": "src/test/run-pass/issue-14959.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14959.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -33,8 +33,8 @@ impl Alloy {\n     }\n }\n \n-impl<'a, 'b> Fn<(&'b mut Response,),()> for SendFile<'a> {\n-    extern \"rust-call\" fn call(&self, (_res,): (&'b mut Response,)) {}\n+impl<'a, 'b> Fn<(&'b mut Response+'b,),()> for SendFile<'a> {\n+    extern \"rust-call\" fn call(&self, (_res,): (&'b mut Response+'b,)) {}\n }\n \n impl<Rq: Request, Rs: Response> Ingot<Rq, Rs> for HelloWorld {"}, {"sha": "9eec2d048d473adf6fb04723eb2aa383af4b26b9", "filename": "src/test/run-pass/issue-2734.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2734.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -12,8 +12,8 @@\n trait hax { }\n impl<A> hax for A { }\n \n-fn perform_hax<T: 'static>(x: Box<T>) -> Box<hax> {\n-    box x as Box<hax>\n+fn perform_hax<T: 'static>(x: Box<T>) -> Box<hax+'static> {\n+    box x as Box<hax+'static>\n }\n \n fn deadcode() {"}, {"sha": "74b64bb87cfc507e7dd9dd5a593e0f3e6fe295dc", "filename": "src/test/run-pass/issue-2735.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -12,8 +12,8 @@\n trait hax { }\n impl<A> hax for A { }\n \n-fn perform_hax<T: 'static>(x: Box<T>) -> Box<hax> {\n-    box x as Box<hax>\n+fn perform_hax<T: 'static>(x: Box<T>) -> Box<hax+'static> {\n+    box x as Box<hax+'static>\n }\n \n fn deadcode() {"}, {"sha": "2dac64b2ec81ffc3cdf5013f15a0bf935e1d956e", "filename": "src/test/run-pass/issue-3424.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3424.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -15,7 +15,7 @@ use std::path::{Path};\n use std::path;\n use std::result;\n \n-type rsrc_loader = proc(path: &Path) -> result::Result<String, String>;\n+type rsrc_loader = proc(path: &Path):'static -> result::Result<String, String>;\n \n fn tester()\n {"}, {"sha": "3b1a8c4a19077c99f0f1abfa6eb7e9df3d957563", "filename": "src/test/run-pass/issue-5192.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-5192.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-5192.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5192.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -28,12 +28,12 @@ impl EventLoop for UvEventLoop {\n }\n \n pub struct Scheduler {\n-    event_loop: Box<EventLoop>,\n+    event_loop: Box<EventLoop+'static>,\n }\n \n impl Scheduler {\n \n-    pub fn new(event_loop: Box<EventLoop>) -> Scheduler {\n+    pub fn new(event_loop: Box<EventLoop+'static>) -> Scheduler {\n         Scheduler {\n             event_loop: event_loop,\n         }"}, {"sha": "24dcc3838c5fc4c2f7d05a7cf22bafc28b8127ab", "filename": "src/test/run-pass/issue-5554.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-5554.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-5554.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5554.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -17,7 +17,10 @@ pub struct X<T> {\n }\n \n // reordering these bounds stops the ICE\n-impl<T: Default + PartialEq + Default> Default for X<T> {\n+//\n+// nmatsakis: This test used to have the bounds Default + PartialEq +\n+// Default, but having duplicate bounds became illegal.\n+impl<T: Default + PartialEq> Default for X<T> {\n     fn default() -> X<T> {\n         X { a: Default::default() }\n     }"}, {"sha": "6168753b6d783620a61427ebe83df6cf997e2b21", "filename": "src/test/run-pass/issue-5708.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5708.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -29,7 +29,7 @@ impl Inner for int {\n }\n \n struct Outer<'a> {\n-    inner: &'a Inner\n+    inner: &'a Inner+'a\n }\n \n impl<'a> Outer<'a> {\n@@ -51,7 +51,7 @@ pub fn main() {\n trait MyTrait<T> { }\n \n pub struct MyContainer<'a, T> {\n-    foos: Vec<&'a MyTrait<T>> ,\n+    foos: Vec<&'a MyTrait<T>+'a> ,\n }\n \n impl<'a, T> MyContainer<'a, T> {"}, {"sha": "a4576bc7c8cebd8d6c7fb6e3f39456b0426e1877", "filename": "src/test/run-pass/issue-6318.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-6318.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-6318.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6318.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -10,7 +10,7 @@\n \n \n pub enum Thing {\n-    A(Box<Foo>)\n+    A(Box<Foo+'static>)\n }\n \n pub trait Foo {}\n@@ -20,7 +20,7 @@ pub struct Struct;\n impl Foo for Struct {}\n \n pub fn main() {\n-    match A(box Struct as Box<Foo>) {\n+    match A(box Struct as Box<Foo+'static>) {\n         A(_a) => 0i,\n     };\n }"}, {"sha": "dae5db11b0a807f5238fb1ca48bff7bfe91543be", "filename": "src/test/run-pass/issue-8249.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-8249.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-8249.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8249.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -13,7 +13,7 @@ struct B;\n impl A for B {}\n \n struct C<'a> {\n-    foo: &'a mut A,\n+    foo: &'a mut A+'a,\n }\n \n fn foo(a: &mut A) {"}, {"sha": "0f054a3083d4d843006881c68b0e81db6ebb3df7", "filename": "src/test/run-pass/issue-9719.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-9719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fissue-9719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9719.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -16,15 +16,15 @@ mod a {\n     pub trait X {}\n     impl X for int {}\n \n-    pub struct Z<'a>(Enum<&'a X>);\n+    pub struct Z<'a>(Enum<&'a X+'a>);\n     fn foo() { let x = 42i; let z = Z(A(&x as &X)); let _ = z; }\n }\n \n mod b {\n     trait X {}\n     impl X for int {}\n     struct Y<'a>{\n-        x:Option<&'a X>,\n+        x:Option<&'a X+'a>,\n     }\n \n     fn bar() {\n@@ -36,7 +36,7 @@ mod b {\n mod c {\n     pub trait X { fn f(&self); }\n     impl X for int { fn f(&self) {} }\n-    pub struct Z<'a>(Option<&'a X>);\n+    pub struct Z<'a>(Option<&'a X+'a>);\n     fn main() { let x = 42i; let z = Z(Some(&x as &X)); let _ = z; }\n }\n "}, {"sha": "fbd6c92a0206516e5ecae0e84f7cb61a560c9fb9", "filename": "src/test/run-pass/kindck-owned-trait-contains-1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -17,9 +17,8 @@ impl<A:Clone + 'static> repeat<A> for Box<A> {\n     }\n }\n \n-fn repeater<A:Clone + 'static>(v: Box<A>) -> Box<repeat<A>> {\n-    // Note: owned kind is not necessary as A appears in the trait type\n-    box v as Box<repeat<A>> // No\n+fn repeater<A:Clone + 'static>(v: Box<A>) -> Box<repeat<A>+'static> {\n+    box v as Box<repeat<A>+'static> // No\n }\n \n pub fn main() {"}, {"sha": "f704545af3375c5888cdeb1e91cea437ecf9b022", "filename": "src/test/run-pass/newlambdas-ret-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -11,7 +11,7 @@\n // Test that the lambda kind is inferred correctly as a return\n // expression\n \n-fn unique() -> proc() { return proc() (); }\n+fn unique() -> proc():'static { return proc() (); }\n \n pub fn main() {\n }"}, {"sha": "22e51ea9a75836935adb34b3920f0a8558fba071", "filename": "src/test/run-pass/newlambdas-ret-infer2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -11,7 +11,7 @@\n // Test that the lambda kind is inferred correctly as a return\n // expression\n \n-fn unique() -> proc() { proc() () }\n+fn unique() -> proc():'static { proc() () }\n \n pub fn main() {\n }"}, {"sha": "5c4befcd0c825563b3bcbacfdf168f8b2c1956eb", "filename": "src/test/run-pass/overloaded-autoderef-indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct DerefArray<'a, T> {\n+struct DerefArray<'a, T:'a> {\n     inner: &'a [T]\n }\n "}, {"sha": "27ef90d7376895e3f0ce334a34dc9f62ab71dcf2", "filename": "src/test/run-pass/regions-early-bound-trait-param.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -30,7 +30,7 @@ fn object_invoke1<'d>(x: &'d Trait<'d>) -> (int, int) {\n }\n \n struct Struct1<'e> {\n-    f: &'e Trait<'e>\n+    f: &'e Trait<'e>+'e\n }\n \n fn field_invoke1<'f, 'g>(x: &'g Struct1<'f>) -> (int,int) {\n@@ -40,7 +40,7 @@ fn field_invoke1<'f, 'g>(x: &'g Struct1<'f>) -> (int,int) {\n }\n \n struct Struct2<'h, 'i> {\n-    f: &'h Trait<'i>\n+    f: &'h Trait<'i>+'h\n }\n \n fn object_invoke2<'j, 'k>(x: &'k Trait<'j>) -> int {\n@@ -78,8 +78,8 @@ impl<'s> Trait<'s> for (int,int) {\n     }\n }\n \n-impl<'t> MakerTrait<'t> for Box<Trait<'t>> {\n-    fn mk() -> Box<Trait<'t>> { box() (4i,5i) as Box<Trait> }\n+impl<'t> MakerTrait<'t> for Box<Trait<'t>+'static> {\n+    fn mk() -> Box<Trait<'t>+'static> { box() (4i,5i) as Box<Trait> }\n }\n \n enum List<'l> {"}, {"sha": "58de2e0e20e0c857c43ece6968f689de518818b3", "filename": "src/test/run-pass/regions-early-bound-used-in-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -15,7 +15,7 @@ trait GetRef<'a, T> {\n     fn get(&self) -> &'a T;\n }\n \n-struct Box<'a, T> {\n+struct Box<'a, T:'a> {\n     t: &'a T\n }\n "}, {"sha": "f33483d31bfca0bc4d159866ca43e9674b2802d5", "filename": "src/test/run-pass/swap-overlapping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -34,8 +34,8 @@ pub enum TestName {\n }\n \n pub enum TestFn {\n-    DynTestFn(proc()),\n-    DynBenchFn(proc(&mut int))\n+    DynTestFn(proc():'static),\n+    DynBenchFn(proc(&mut int):'static)\n }\n \n pub struct TestDesc {"}, {"sha": "5b744a4413271c6c2bcbc29c399fdf00899fc65d", "filename": "src/test/run-pass/trait-bounds-impl-comparison-duplicates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Ftrait-bounds-impl-comparison-duplicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Ftrait-bounds-impl-comparison-duplicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-impl-comparison-duplicates.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -17,7 +17,7 @@ trait A {\n }\n \n impl A for int {\n-    fn foo<T: Ord + Ord>(&self) {}\n+    fn foo<T: Ord>(&self) {} // Ord implies Eq, so this is ok.\n }\n \n fn main() {}"}, {"sha": "e3234f037547b66235bae0318cd3c9cca449ced4", "filename": "src/test/run-pass/trait-bounds-on-structs-and-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-on-structs-and-enums.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -12,11 +12,11 @@ trait U {}\n trait T<X: U> {}\n \n trait S2<Y: U> {\n-    fn m(x: Box<T<Y>>) {}\n+    fn m(x: Box<T<Y>+'static>) {}\n }\n \n struct St<X: U> {\n-    f: Box<T<X>>,\n+    f: Box<T<X>+'static>,\n }\n \n impl<X: U> St<X> {"}, {"sha": "b20915763f25021b13516c68d71a81d74d24f16b", "filename": "src/test/run-pass/trait-object-generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Ftrait-object-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Ftrait-object-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-object-generics.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -21,7 +21,7 @@ pub struct Impl<A1, A2, A3> {\n      * task <unnamed> failed at 'index out of bounds: the len is 1 but the index is 1',\n      * src/librustc/middle/subst.rs:58\n      */\n-    t: Box<Trait2<A2>>\n+    t: Box<Trait2<A2>+'static>\n }\n \n impl<A1, A2, A3> Impl<A1, A2, A3> {"}, {"sha": "746af1b9cf524a78834072f2d96675ff176f34b5", "filename": "src/test/run-pass/unboxed-closures-boxed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Funboxed-closures-boxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f/src%2Ftest%2Frun-pass%2Funboxed-closures-boxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-boxed.rs?ref=1b487a890695e7d6dfbfe5dcd7d4fa0e8ca8003f", "patch": "@@ -12,8 +12,8 @@\n \n use std::ops::FnMut;\n \n-fn make_adder(x: int) -> Box<FnMut<(int,),int>> {\n-    (box |&mut: y: int| -> int { x + y }) as Box<FnMut<(int,),int>>\n+ fn make_adder(x: int) -> Box<FnMut<(int,),int>+'static> {\n+    (box |&mut: y: int| -> int { x + y }) as Box<FnMut<(int,),int>+'static>\n }\n \n pub fn main() {"}]}