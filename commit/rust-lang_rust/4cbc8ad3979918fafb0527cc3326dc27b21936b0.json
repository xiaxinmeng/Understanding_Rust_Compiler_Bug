{"sha": "4cbc8ad3979918fafb0527cc3326dc27b21936b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYmM4YWQzOTc5OTE4ZmFmYjA1MjdjYzMzMjZkYzI3YjIxOTM2YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-23T03:56:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-23T03:56:05Z"}, "message": "auto merge of #9654 : catamorphism/rust/rustpkg-c-dependencies, r=brson\n\nr? @brson api::install_pkg now accepts an argument that's a list of\r\n(kind, path) dependency pairs. This allows custom package scripts to\r\ndeclare C dependencies, as is demonstrated in\r\nrustpkg::tests::test_c_dependency_ok.\r\n\r\nCloses #6403", "tree": {"sha": "beccf76bab71fe556b8560fb55a84c5bb4d2e4ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/beccf76bab71fe556b8560fb55a84c5bb4d2e4ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cbc8ad3979918fafb0527cc3326dc27b21936b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cbc8ad3979918fafb0527cc3326dc27b21936b0", "html_url": "https://github.com/rust-lang/rust/commit/4cbc8ad3979918fafb0527cc3326dc27b21936b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cbc8ad3979918fafb0527cc3326dc27b21936b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78573149cbeb0d0b626d128a8950f1220ed551ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/78573149cbeb0d0b626d128a8950f1220ed551ad", "html_url": "https://github.com/rust-lang/rust/commit/78573149cbeb0d0b626d128a8950f1220ed551ad"}, {"sha": "c97957588b7e26d32e7800072df4c31da56703ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/c97957588b7e26d32e7800072df4c31da56703ef", "html_url": "https://github.com/rust-lang/rust/commit/c97957588b7e26d32e7800072df4c31da56703ef"}], "stats": {"total": 618, "additions": 514, "deletions": 104}, "files": [{"sha": "d6fc5ecb8e5af118f5f23269823aff546ed1a7b3", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -370,6 +370,7 @@ $(3)/stage$(1)/test/rustpkgtest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX_$(2)) \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2)) \\\n+\t\t$$(HBIN$(1)_H_$(3))/rustpkg$$(X_$(2)) \\\n \t\t$$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$$(X_$(2)) \\\n \t\t$$(TBIN$(1)_T_$(2)_H_$(3))/rustc$$(X_$(2))\n \t@$$(call E, compile_and_link: $$@)"}, {"sha": "c67b6f52c7e399cff7bed8dd1fa44f91dfbf408c", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 86, "deletions": 10, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -12,22 +12,35 @@ use context::*;\n use crate::*;\n use package_id::*;\n use package_source::*;\n+use path_util::{platform_library_name, target_build_dir};\n use target::*;\n use version::Version;\n+use workspace::pkg_parent_workspaces;\n use workcache_support::*;\n+pub use path_util::default_workspace;\n \n pub use source_control::{safe_git_clone, git_clone_url};\n \n-use std::os;\n+use std::{os, run};\n use extra::arc::{Arc,RWArc};\n use extra::workcache;\n use extra::workcache::{Database, Logger, FreshnessMap};\n use extra::treemap::TreeMap;\n \n+// A little sad -- duplicated from rustc::back::*\n+#[cfg(target_arch = \"arm\")]\n+fn cc_args() -> ~[~str] { ~[~\"-marm\"] }\n+#[cfg(target_arch = \"mips\")]\n+fn cc_args() -> ~[~str] { ~[] }\n+#[cfg(target_arch = \"x86\")]\n+fn cc_args() -> ~[~str] { ~[~\"-m32\"] }\n+#[cfg(target_arch = \"x86_64\")]\n+fn cc_args() -> ~[~str] { ~[~\"-m64\"] }\n+\n /// Convenience functions intended for calling from pkg.rs\n /// p is where to put the cache file for dependencies\n-pub fn default_context(p: Path) -> BuildContext {\n-    new_default_context(new_workcache_context(&p), p)\n+pub fn default_context(sysroot: Path, p: Path) -> BuildContext {\n+    new_default_context(new_workcache_context(&p), sysroot)\n }\n \n pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n@@ -68,7 +81,7 @@ pub fn new_workcache_context(p: &Path) -> workcache::Context {\n \n pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n                  lib: Path) {\n-    let cx = default_context(sysroot);\n+    let cx = default_context(sysroot, root.clone());\n     let pkg_src = PkgSrc {\n         source_workspace: root.clone(),\n         build_in_destination: false,\n@@ -81,12 +94,12 @@ pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n         tests: ~[],\n         benchs: ~[]\n     };\n-    pkg_src.build(&cx, ~[]);\n+    pkg_src.build(&cx, ~[], []);\n }\n \n pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n                  main: Path) {\n-    let cx = default_context(sysroot);\n+    let cx = default_context(sysroot, root.clone());\n     let pkg_src = PkgSrc {\n         source_workspace: root.clone(),\n         build_in_destination: false,\n@@ -100,13 +113,76 @@ pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n         benchs: ~[]\n     };\n \n-    pkg_src.build(&cx, ~[]);\n+    pkg_src.build(&cx, ~[], []);\n }\n \n-pub fn install_pkg(sysroot: Path, workspace: Path, name: ~str, version: Version) {\n-    let cx = default_context(sysroot);\n+pub fn install_pkg(cx: &BuildContext,\n+                   workspace: Path,\n+                   name: ~str,\n+                   version: Version,\n+                   // For now, these inputs are assumed to be inputs to each of the crates\n+                   more_inputs: ~[(~str, Path)]) { // pairs of Kind and Path\n     let pkgid = PkgId{ version: version, ..PkgId::new(name)};\n-    cx.install(PkgSrc::new(workspace.clone(), workspace, false, pkgid), &Everything);\n+    cx.install(PkgSrc::new(workspace.clone(), workspace, false, pkgid),\n+               &WhatToBuild{ build_type: Inferred,\n+                             inputs_to_discover: more_inputs,\n+                             sources: Everything });\n+}\n+\n+/// Builds an arbitrary library whose short name is `output`,\n+/// by invoking `tool` with arguments `args` plus \"-o %s\", where %s\n+/// is the platform-specific library name for `output`.\n+/// Returns that platform-specific name.\n+pub fn build_library_in_workspace(exec: &mut workcache::Exec,\n+                                  context: &mut Context,\n+                                  package_name: &str,\n+                                  tool: &str,\n+                                  flags: &[~str],\n+                                  paths: &[~str],\n+                                  output: &str) -> ~str {\n+    use command_failed = conditions::command_failed::cond;\n+\n+    let workspace = my_workspace(context, package_name);\n+    let workspace_build_dir = target_build_dir(&workspace);\n+    let out_name = workspace_build_dir.join_many([package_name.to_str(),\n+                                                  platform_library_name(output)]);\n+    // make paths absolute\n+    let pkgid = PkgId::new(package_name);\n+    let absolute_paths = paths.map(|s| {\n+            let whatever = workspace.join_many([~\"src\",\n+                                pkgid.to_str(),\n+                                s.to_owned()]);\n+            whatever.as_str().unwrap().to_owned()\n+        });\n+\n+    let cc_args = cc_args();\n+\n+    let all_args = flags + absolute_paths + cc_args +\n+         ~[~\"-o\", out_name.as_str().unwrap().to_owned()];\n+    let exit_code = run::process_status(tool, all_args);\n+    if exit_code != 0 {\n+        command_failed.raise((tool.to_owned(), all_args, exit_code))\n+    }\n+    else {\n+        let out_name_str = out_name.as_str().unwrap().to_owned();\n+        exec.discover_output(\"binary\",\n+                             out_name_str,\n+                             digest_only_date(&out_name));\n+        context.add_library_path(out_name.dir_path());\n+        out_name_str\n+    }\n+}\n+\n+pub fn my_workspace(context: &Context, package_name: &str) -> Path {\n+    use bad_pkg_id     = conditions::bad_pkg_id::cond;\n+\n+    // (this assumes no particular version is requested)\n+    let pkgid = PkgId::new(package_name);\n+    let workspaces = pkg_parent_workspaces(context, &pkgid);\n+    if workspaces.is_empty() {\n+        bad_pkg_id.raise((Path::new(package_name), package_name.to_owned()));\n+    }\n+    workspaces[0]\n }\n \n fn mk_crate(p: Path) -> Crate {"}, {"sha": "046ba405dbb842c655e55501b573df6f4b6080e9", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -54,3 +54,9 @@ condition! {\n condition! {\n     pub git_checkout_failed: (~str, Path) -> ();\n }\n+\n+condition! {\n+    // str is output of applying the command (first component)\n+    // to the args (second component)\n+    pub command_failed: (~str, ~[~str], int) -> ~str;\n+}"}, {"sha": "72197219fc5aecd477c1e20c249f7cc44dad8866", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -54,6 +54,15 @@ impl BuildContext {\n     pub fn compile_upto(&self) -> StopBefore {\n         self.context.compile_upto()\n     }\n+\n+    pub fn add_library_path(&mut self, p: Path) {\n+        debug!(\"Adding library path: {}\", p.display());\n+        self.context.add_library_path(p);\n+    }\n+\n+    pub fn additional_library_paths(&self) -> ~[Path] {\n+        self.context.rustc_flags.additional_library_paths.clone()\n+    }\n }\n \n /*\n@@ -85,6 +94,9 @@ pub struct RustcFlags {\n     target: Option<~str>,\n     // Target CPU (defaults to rustc's default target CPU)\n     target_cpu: Option<~str>,\n+    // Additional library directories, which get passed with the -L flag\n+    // This can't be set with a rustpkg flag, only from package scripts\n+    additional_library_paths: ~[Path],\n     // Any -Z features\n     experimental_features: Option<~[~str]>\n }\n@@ -99,6 +111,7 @@ impl Clone for RustcFlags {\n             save_temps: self.save_temps,\n             target: self.target.clone(),\n             target_cpu: self.target_cpu.clone(),\n+            additional_library_paths: self.additional_library_paths.clone(),\n             experimental_features: self.experimental_features.clone()\n         }\n     }\n@@ -148,6 +161,10 @@ impl Context {\n     pub fn compile_upto(&self) -> StopBefore {\n         self.rustc_flags.compile_upto\n     }\n+\n+    pub fn add_library_path(&mut self, p: Path) {\n+        self.rustc_flags.additional_library_paths.push(p);\n+    }\n }\n \n /// We assume that if ../../rustc exists, then we're running\n@@ -210,6 +227,7 @@ impl RustcFlags {\n             save_temps: false,\n             target: None,\n             target_cpu: None,\n+            additional_library_paths: ~[],\n             experimental_features: None\n         }\n     }"}, {"sha": "17ba79862e0cab0966fba99bafdc378348ed0f63", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -23,7 +23,7 @@ use path_util::{find_dir_using_rust_path_hack, make_dir_rwx_recursive, default_w\n use path_util::{target_build_dir, versionize, dir_has_crate_file};\n use util::{compile_crate, DepMap};\n use workcache_support;\n-use workcache_support::crate_tag;\n+use workcache_support::{digest_only_date, digest_file_with_date, crate_tag};\n use extra::workcache;\n use extra::treemap::TreeMap;\n \n@@ -390,7 +390,8 @@ impl PkgSrc {\n                     deps: &mut DepMap,\n                     crates: &[Crate],\n                     cfgs: &[~str],\n-                    what: OutputType) {\n+                    what: OutputType,\n+                    inputs_to_discover: &[(~str, Path)]) {\n         for crate in crates.iter() {\n             let path = self.start_dir.join(&crate.file);\n             debug!(\"build_crates: compiling {}\", path.display());\n@@ -408,7 +409,19 @@ impl PkgSrc {\n                 let sub_dir = self.build_workspace().clone();\n                 let sub_flags = crate.flags.clone();\n                 let sub_deps = deps.clone();\n+                let inputs = inputs_to_discover.map(|&(ref k, ref p)|\n+                                                    (k.clone(), p.as_str().unwrap().to_owned()));\n                 do prep.exec |exec| {\n+                    for &(ref kind, ref p) in inputs.iter() {\n+                        let pth = Path::new(p.clone());\n+                        exec.discover_input(*kind, *p, if *kind == ~\"file\" {\n+                                digest_file_with_date(&pth)\n+                            } else if *kind == ~\"binary\" {\n+                                digest_only_date(&Path::new(p.clone()))\n+                            } else {\n+                                fail!(\"Bad kind in build_crates\")\n+                            });\n+                    }\n                     let result = compile_crate(&subcx,\n                                                exec,\n                                                &id,\n@@ -452,22 +465,43 @@ impl PkgSrc {\n                  build_context: &BuildContext,\n                  // DepMap is a map from str (crate name) to (kind, name) --\n                  // it tracks discovered dependencies per-crate\n-                 cfgs: ~[~str]) -> DepMap {\n+                 cfgs: ~[~str],\n+                 inputs_to_discover: &[(~str, Path)]) -> DepMap {\n         let mut deps = TreeMap::new();\n-\n         let libs = self.libs.clone();\n         let mains = self.mains.clone();\n         let tests = self.tests.clone();\n         let benchs = self.benchs.clone();\n         debug!(\"Building libs in {}, destination = {}\",\n-               self.source_workspace.display(), self.build_workspace().display());\n-        self.build_crates(build_context, &mut deps, libs, cfgs, Lib);\n+               self.destination_workspace.display(),\n+               self.destination_workspace.display());\n+        self.build_crates(build_context,\n+                          &mut deps,\n+                          libs,\n+                          cfgs,\n+                          Lib,\n+                          inputs_to_discover);\n         debug!(\"Building mains\");\n-        self.build_crates(build_context, &mut deps, mains, cfgs, Main);\n+        self.build_crates(build_context,\n+                          &mut deps,\n+                          mains,\n+                          cfgs,\n+                          Main,\n+                          inputs_to_discover);\n         debug!(\"Building tests\");\n-        self.build_crates(build_context, &mut deps, tests, cfgs, Test);\n+        self.build_crates(build_context,\n+                          &mut deps,\n+                          tests,\n+                          cfgs,\n+                          Test,\n+                          inputs_to_discover);\n         debug!(\"Building benches\");\n-        self.build_crates(build_context, &mut deps, benchs, cfgs, Bench);\n+        self.build_crates(build_context,\n+                          &mut deps,\n+                          benchs,\n+                          cfgs,\n+                          Bench,\n+                          inputs_to_discover);\n         deps\n     }\n "}, {"sha": "a48ef23115ccf71c3ebe832cc646270cae4e75cf", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -461,7 +461,6 @@ pub fn versionize(p: &Path, v: &Version) -> Path {\n     p.with_filename(q)\n }\n \n-\n #[cfg(target_os = \"win32\")]\n pub fn chmod_read_only(p: &Path) -> bool {\n     #[fixed_stack_segment];\n@@ -483,3 +482,6 @@ pub fn chmod_read_only(p: &Path) -> bool {\n     }\n }\n \n+pub fn platform_library_name(s: &str) -> ~str {\n+    format!(\"{}{}{}\", os::consts::DLL_PREFIX, s, os::consts::DLL_SUFFIX)\n+}"}, {"sha": "37a5a2ea711329b9b369a17178dc467b7476fd20", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 66, "deletions": 47, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -33,7 +33,6 @@ use rustc::metadata::filesearch;\n use rustc::metadata::filesearch::rust_path;\n use extra::{getopts};\n use syntax::{ast, diagnostic};\n-use util::*;\n use messages::{error, warn, note};\n use path_util::{build_pkg_id_in_workspace, built_test_in_workspace};\n use path_util::{U_RWX, in_rust_path};\n@@ -47,15 +46,16 @@ use context::{Context, BuildContext,\n                        LLVMAssemble, LLVMCompileBitcode};\n use package_id::PkgId;\n use package_source::PkgSrc;\n-use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench, Tests};\n+use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n+use target::{Tests, MaybeCustom, Inferred, JustOne};\n use workcache_support::digest_only_date;\n use exit_codes::{COPY_FAILED_CODE, BAD_FLAG_CODE};\n \n pub mod api;\n mod conditions;\n-mod context;\n+pub mod context;\n mod crate;\n-mod exit_codes;\n+pub mod exit_codes;\n mod installed_packages;\n mod messages;\n mod package_id;\n@@ -67,7 +67,7 @@ mod target;\n #[cfg(test)]\n mod tests;\n mod util;\n-mod version;\n+pub mod version;\n pub mod workcache_support;\n mod workspace;\n \n@@ -96,7 +96,7 @@ impl<'self> PkgScript<'self> {\n     /// Given the path name for a package script\n     /// and a package ID, parse the package script into\n     /// a PkgScript that we can then execute\n-    fn parse<'a>(sysroot: @Path,\n+    fn parse<'a>(sysroot: Path,\n                  script: Path,\n                  workspace: &Path,\n                  id: &'a PkgId) -> PkgScript<'a> {\n@@ -107,7 +107,7 @@ impl<'self> PkgScript<'self> {\n         debug!(\"pkgscript parse: {}\", sysroot.display());\n         let options = @session::options {\n             binary: binary,\n-            maybe_sysroot: Some(sysroot),\n+            maybe_sysroot: Some(@sysroot),\n             crate_type: session::bin_crate,\n             .. (*session::basic_options()).clone()\n         };\n@@ -132,12 +132,7 @@ impl<'self> PkgScript<'self> {\n         }\n     }\n \n-    /// Run the contents of this package script, where <what>\n-    /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n-    /// Returns a pair of an exit code and list of configs (obtained by\n-    /// calling the package script's configs() function if it exists\n-    fn run_custom(&mut self, exec: &mut workcache::Exec,\n-                  sysroot: &Path) -> (~[~str], ExitCode) {\n+    fn build_custom(&mut self, exec: &mut workcache::Exec) -> ~str {\n         let sess = self.sess;\n \n         debug!(\"Working directory = {}\", self.build_dir.display());\n@@ -152,24 +147,36 @@ impl<'self> PkgScript<'self> {\n                                        &self.build_dir,\n                                        sess,\n                                        crate);\n-        debug!(\"Running program: {} {} {}\", exe.display(),\n-               sysroot.display(), \"install\");\n         // Discover the output\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        exec.discover_output(\"binary\", exe.as_str().unwrap(), digest_only_date(&exe));\n+        // Discover the output\n+        exec.discover_output(\"binary\", exe.as_str().unwrap().to_owned(), digest_only_date(&exe));\n+        exe.as_str().unwrap().to_owned()\n+    }\n+\n+\n+    /// Run the contents of this package script, where <what>\n+    /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n+    /// Returns a pair of an exit code and list of configs (obtained by\n+    /// calling the package script's configs() function if it exists\n+    fn run_custom(exe: &Path, sysroot: &Path) -> (~[~str], int) {\n+        debug!(\"Running program: {} {} {}\", exe.as_str().unwrap().to_owned(),\n+               sysroot.display(), \"install\");\n         // FIXME #7401 should support commands besides `install`\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let status = run::process_status(exe.as_str().unwrap(),\n                                          [sysroot.as_str().unwrap().to_owned(), ~\"install\"]);\n         if status != 0 {\n-            return (~[], status);\n+            debug!(\"run_custom: first pkg command failed with {:?}\", status);\n+            (~[], status)\n         }\n         else {\n             debug!(\"Running program (configs): {} {} {}\",\n                    exe.display(), sysroot.display(), \"configs\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let output = run::process_output(exe.as_str().unwrap(),\n                                              [sysroot.as_str().unwrap().to_owned(), ~\"configs\"]);\n+            debug!(\"run_custom: second pkg command did {:?}\", output.status);\n             // Run the configs() function to get the configs\n             let cfgs = str::from_utf8_slice(output.output).word_iter()\n                 .map(|w| w.to_owned()).collect();\n@@ -263,7 +270,7 @@ impl CtxMethods for BuildContext {\n         let cwd = os::getcwd();\n         match cmd {\n             \"build\" => {\n-                self.build_args(args, &Everything);\n+                self.build_args(args, &WhatToBuild::new(MaybeCustom, Everything));\n             }\n             \"clean\" => {\n                 if args.len() < 1 {\n@@ -301,12 +308,14 @@ impl CtxMethods for BuildContext {\n                             let inferred_pkgid =\n                                 PkgId::new(cwd.filename_str().unwrap());\n                             self.install(PkgSrc::new(cwd, default_workspace(),\n-                                                     true, inferred_pkgid), &Everything);\n+                                                     true, inferred_pkgid),\n+                                         &WhatToBuild::new(MaybeCustom, Everything));\n                         }\n                         None  => { usage::install(); return; }\n                         Some((ws, pkgid))                => {\n                             let pkg_src = PkgSrc::new(ws.clone(), ws.clone(), false, pkgid);\n-                            self.install(pkg_src, &Everything);\n+                            self.install(pkg_src, &WhatToBuild::new(MaybeCustom,\n+                                                                    Everything));\n                       }\n                   }\n                 }\n@@ -320,7 +329,7 @@ impl CtxMethods for BuildContext {\n                     if workspaces.is_empty() {\n                         let d = default_workspace();\n                         let src = PkgSrc::new(d.clone(), d, false, pkgid.clone());\n-                        self.install(src, &Everything);\n+                        self.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n                     }\n                     else {\n                         for workspace in workspaces.iter() {\n@@ -331,7 +340,7 @@ impl CtxMethods for BuildContext {\n                                                   dest,\n                                                   self.context.use_rust_path_hack,\n                                                   pkgid.clone());\n-                            self.install(src, &Everything);\n+                            self.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n                         };\n                     }\n                 }\n@@ -354,7 +363,8 @@ impl CtxMethods for BuildContext {\n             }\n             \"test\" => {\n                 // Build the test executable\n-                let maybe_id_and_workspace = self.build_args(args, &Tests);\n+                let maybe_id_and_workspace = self.build_args(args,\n+                                                             &WhatToBuild::new(MaybeCustom, Tests));\n                 match maybe_id_and_workspace {\n                     Some((pkg_id, workspace)) => {\n                         // Assuming it's built, run the tests\n@@ -420,6 +430,7 @@ impl CtxMethods for BuildContext {\n                 pkgid = {} pkgsrc start_dir = {}\", workspace.display(),\n                in_rust_path(&workspace), is_git_dir(&workspace.join(&pkgid.path)),\n                pkgid.to_str(), pkg_src.start_dir.display());\n+        debug!(\"build: what to build = {:?}\", what_to_build);\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n@@ -448,27 +459,27 @@ impl CtxMethods for BuildContext {\n         debug!(\"Package source directory = {}\", pkg_src.to_str());\n         let opt = pkg_src.package_script_option();\n         debug!(\"Calling pkg_script_option on {:?}\", opt);\n-        let cfgs = match pkg_src.package_script_option() {\n-            Some(package_script_path) => {\n+        let cfgs = match (pkg_src.package_script_option(), what_to_build.build_type) {\n+            (Some(package_script_path), MaybeCustom)  => {\n                 let sysroot = self.sysroot_to_use();\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let pkg_script_path_str = package_script_path.as_str().unwrap();\n-                let (cfgs, hook_result) =\n-                    do self.workcache_context.with_prep(pkg_script_path_str) |prep| {\n-                    let sub_sysroot = sysroot.clone();\n-                    let package_script_path_clone = package_script_path.clone();\n-                    let sub_ws = workspace.clone();\n-                    let sub_id = pkgid.clone();\n-                    declare_package_script_dependency(prep, &*pkg_src);\n+                // Build the package script if needed\n+                let script_build = format!(\"build_package_script({})\",\n+                                           package_script_path.display());\n+                let pkg_exe = do self.workcache_context.with_prep(script_build) |prep| {\n+                    let subsysroot = sysroot.clone();\n+                    let psp = package_script_path.clone();\n+                    let ws = workspace.clone();\n+                    let pid = pkgid.clone();\n                     do prep.exec |exec| {\n-                        let mut pscript = PkgScript::parse(@sub_sysroot.clone(),\n-                                                          package_script_path_clone.clone(),\n-                                                          &sub_ws,\n-                                                          &sub_id);\n-\n-                        pscript.run_custom(exec, &sub_sysroot)\n+                        let mut pscript = PkgScript::parse(subsysroot.clone(),\n+                                                           psp.clone(),\n+                                                           &ws,\n+                                                           &pid);\n+                        pscript.build_custom(exec)\n                     }\n                 };\n+                // We always *run* the package script\n+                let (cfgs, hook_result) = PkgScript::run_custom(&Path::new(pkg_exe), &sysroot);\n                 debug!(\"Command return code = {:?}\", hook_result);\n                 if hook_result != 0 {\n                     fail!(\"Error running custom build command\")\n@@ -477,7 +488,11 @@ impl CtxMethods for BuildContext {\n                 // otherwise, the package script succeeded\n                 cfgs\n             }\n-            None => {\n+            (Some(_), Inferred) => {\n+                debug!(\"There is a package script, but we're ignoring it\");\n+                ~[]\n+            }\n+            (None, _) => {\n                 debug!(\"No package script, continuing\");\n                 ~[]\n             }\n@@ -486,13 +501,13 @@ impl CtxMethods for BuildContext {\n         // If there was a package script, it should have finished\n         // the build already. Otherwise...\n         if !custom {\n-            match what_to_build {\n+            match what_to_build.sources {\n                 // Find crates inside the workspace\n-                &Everything => pkg_src.find_crates(),\n+                Everything => pkg_src.find_crates(),\n                 // Find only tests\n-                &Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path::new(s)) }),\n+                Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path::new(s)) }),\n                 // Don't infer any crates -- just build the one that was requested\n-                &JustOne(ref p) => {\n+                JustOne(ref p) => {\n                     // We expect that p is relative to the package source's start directory,\n                     // so check that assumption\n                     debug!(\"JustOne: p = {}\", p.display());\n@@ -512,7 +527,7 @@ impl CtxMethods for BuildContext {\n                 }\n             }\n             // Build it!\n-            pkg_src.build(self, cfgs);\n+            pkg_src.build(self, cfgs, []);\n         }\n     }\n \n@@ -551,6 +566,8 @@ impl CtxMethods for BuildContext {\n         // just means inferring all the crates in it, then building each one.\n         self.build(&mut pkg_src, what);\n \n+        debug!(\"Done building package source {}\", pkg_src.to_str());\n+\n         let to_do = ~[pkg_src.libs.clone(), pkg_src.mains.clone(),\n                       pkg_src.tests.clone(), pkg_src.benchs.clone()];\n         debug!(\"In declare inputs for {}\", id.to_str());\n@@ -823,6 +840,7 @@ pub fn main_args(args: &[~str]) -> int {\n         save_temps: save_temps,\n         target: target,\n         target_cpu: target_cpu,\n+        additional_library_paths: ~[], // No way to set this from the rustpkg command line\n         experimental_features: experimental_features\n     };\n \n@@ -895,7 +913,8 @@ pub fn main_args(args: &[~str]) -> int {\n                 use_rust_path_hack: use_rust_path_hack,\n                 sysroot: sroot.clone(), // Currently, only tests override this\n             },\n-            workcache_context: api::default_context(default_workspace()).workcache_context\n+            workcache_context: api::default_context(sroot.clone(),\n+                                                    default_workspace()).workcache_context\n         }.run(sub_cmd, rm_args.clone())\n     };\n     // FIXME #9262: This is using the same error code for all errors,"}, {"sha": "9863fd0a89ee9357fb2dd9c8fb95f2df14c6dda7", "filename": "src/librustpkg/target.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftarget.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -23,7 +23,31 @@ pub enum Target {\n }\n \n #[deriving(Eq, Clone)]\n-pub enum WhatToBuild {\n+pub struct WhatToBuild {\n+    build_type: BuildType, // Whether or not to ignore the pkg.rs file\n+    sources: SourceType, // Which crates to build\n+    inputs_to_discover: ~[(~str, Path)] // Inputs to these crates to be discovered\n+        // (For now all of these inputs will be taken as discovered inputs\n+        // for all of the crates)\n+        // (Paired with their kinds)\n+}\n+\n+impl WhatToBuild {\n+    pub fn new(build_type: BuildType, sources: SourceType) -> WhatToBuild {\n+        WhatToBuild { build_type: build_type,\n+                      sources: sources,\n+                      inputs_to_discover: ~[] }\n+    }\n+}\n+\n+#[deriving(Eq, Clone)]\n+pub enum BuildType {\n+    Inferred, // Ignore the pkg.rs file even if one exists\n+    MaybeCustom // Use the pkg.rs file if it exists\n+}\n+\n+#[deriving(Eq, Clone)]\n+pub enum SourceType {\n     /// Build just one lib.rs file in `path`, which is relative to the active workspace's src/ dir\n     JustOne(Path),\n     /// Build any test.rs files that can be recursively found in the active workspace"}, {"sha": "16e13f700921246d932a0b018e44db84be392d42", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 109, "deletions": 12, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -28,7 +28,7 @@ use path_util::{target_executable_in_workspace, target_test_in_workspace,\n                library_in_workspace, installed_library_in_workspace,\n                built_bench_in_workspace, built_test_in_workspace,\n                built_library_in_workspace, built_executable_in_workspace, target_build_dir,\n-               chmod_read_only};\n+               chmod_read_only, platform_library_name};\n use rustc::back::link::get_cc_prog;\n use rustc::metadata::filesearch::rust_path;\n use rustc::driver::driver::{build_session, build_session_options, host_triple, optgroups};\n@@ -299,12 +299,6 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n                     cmd, args, str::from_utf8(output.output),\n                    str::from_utf8(output.error),\n                    output.status);\n-/*\n-By the way, rustpkg *won't* return a nonzero exit code if it fails --\n-see #4547\n-So tests that use this need to check the existence of a file\n-to make sure the command succeeded\n-*/\n     if output.status != 0 {\n         debug!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} ---\",\n               cmd, args, output.status,\n@@ -600,7 +594,7 @@ fn test_install_valid() {\n                           temp_workspace.clone(),\n                           false,\n                           temp_pkg_id.clone());\n-    ctxt.install(src, &Everything);\n+    ctxt.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"exec = {}\", exec.display());\n@@ -639,7 +633,7 @@ fn test_install_invalid() {\n                                   temp_workspace.clone(),\n                                   false,\n                                   pkgid.clone());\n-        ctxt.install(pkg_src, &Everything);\n+        ctxt.install(pkg_src, &WhatToBuild::new(MaybeCustom, Everything));\n     };\n     // Not the best test -- doesn't test that we failed in the right way.\n     // Best we can do for now.\n@@ -897,22 +891,25 @@ fn rustpkg_local_pkg() {\n }\n \n #[test]\n-#[ignore (reason = \"test makes bogus assumptions about build directory layout: issue #8690\")]\n fn package_script_with_default_build() {\n     let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n     let dir = dir.path();\n     debug!(\"dir = {}\", dir.display());\n     let mut source = test_sysroot().dir_path();\n     source.pop(); source.pop();\n-    source.push_many([\"src\", \"librustpkg\", \"testsuite\", \"pass\", \"src\", \"fancy-lib\", \"pkg.rs\"]);\n+    let source = Path::new(file!()).dir_path().join_many(\n+        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n     debug!(\"package_script_with_default_build: {}\", source.display());\n     if !os::copy_file(&source,\n                       &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"])) {\n         fail!(\"Couldn't copy file\");\n     }\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n     assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n-    assert!(os::path_exists(&target_build_dir(dir).join_many([\"fancy-lib\", \"generated.rs\"])));\n+    assert!(os::path_exists(&target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"])));\n+    let generated_path = target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]);\n+    debug!(\"generated path = {}\", generated_path.display());\n+    assert!(os::path_exists(&generated_path));\n }\n \n #[test]\n@@ -2251,6 +2248,106 @@ fn find_sources_in_cwd() {\n     assert_executable_exists(&source_dir.join(\".rust\"), \"foo\");\n }\n \n+#[test]\n+fn test_c_dependency_ok() {\n+    // Pkg has a custom build script that adds a single C file as a dependency, and\n+    // registers a hook to build it if it's not fresh\n+    // After running `build`, test that the C library built\n+\n+    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = dir.path();\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n+              \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n+              \\n#[fixed_stack_segment]\\nfn main() { unsafe { f(); } }\");\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]), \"void f() {}\");\n+\n+    debug!(\"dir = {}\", dir.display());\n+    let source = Path::new(file!()).dir_path().join_many(\n+        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n+    if !os::copy_file(&source,\n+                      &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"])) {\n+        fail!(\"Couldn't copy file\");\n+    }\n+    command_line_test([~\"build\", ~\"cdep\"], dir);\n+    assert_executable_exists(dir, \"cdep\");\n+    let out_dir = target_build_dir(dir).join(\"cdep\");\n+    let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n+    debug!(\"c library path: {}\", c_library_path.display());\n+    assert!(os::path_exists(&c_library_path));\n+}\n+\n+#[test]\n+fn test_c_dependency_no_rebuilding() {\n+    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = dir.path();\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n+              \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n+              \\n#[fixed_stack_segment]\\nfn main() { unsafe { f(); } }\");\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]), \"void f() {}\");\n+\n+    debug!(\"dir = {}\", dir.display());\n+    let source = Path::new(file!()).dir_path().join_many(\n+        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n+    if !os::copy_file(&source,\n+                      &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"])) {\n+        fail!(\"Couldn't copy file\");\n+    }\n+    command_line_test([~\"build\", ~\"cdep\"], dir);\n+    assert_executable_exists(dir, \"cdep\");\n+    let out_dir = target_build_dir(dir).join(\"cdep\");\n+    let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n+    debug!(\"c library path: {}\", c_library_path.display());\n+    assert!(os::path_exists(&c_library_path));\n+\n+    // Now, make it read-only so rebuilding will fail\n+    assert!(chmod_read_only(&c_library_path));\n+\n+    match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n+        Success(*) => (), // ok\n+        Fail(status) if status == 65 => fail!(\"test_c_dependency_no_rebuilding failed: \\\n+                                              it tried to rebuild foo.c\"),\n+        Fail(_) => fail!(\"test_c_dependency_no_rebuilding failed for some other reason\")\n+    }\n+}\n+\n+#[test]\n+fn test_c_dependency_yes_rebuilding() {\n+    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = dir.path();\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n+              \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n+              \\n#[fixed_stack_segment]\\nfn main() { unsafe { f(); } }\");\n+    let c_file_name = dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]);\n+    writeFile(&c_file_name, \"void f() {}\");\n+\n+    let source = Path::new(file!()).dir_path().join_many(\n+        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n+    let target = dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]);\n+    debug!(\"Copying {} -> {}\", source.display(), target.display());\n+    if !os::copy_file(&source, &target) {\n+        fail!(\"Couldn't copy file\");\n+    }\n+    command_line_test([~\"build\", ~\"cdep\"], dir);\n+    assert_executable_exists(dir, \"cdep\");\n+    let out_dir = target_build_dir(dir).join(\"cdep\");\n+    let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n+    debug!(\"c library path: {}\", c_library_path.display());\n+    assert!(os::path_exists(&c_library_path));\n+\n+    // Now, make the Rust library read-only so rebuilding will fail\n+    match built_library_in_workspace(&PkgId::new(\"cdep\"), dir) {\n+        Some(ref pth) => assert!(chmod_read_only(pth)),\n+        None => assert_built_library_exists(dir, \"cdep\")\n+    }\n+\n+    match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n+        Success(*) => fail!(\"test_c_dependency_yes_rebuilding failed: \\\n+                            it didn't rebuild and should have\"),\n+        Fail(status) if status == 65 => (),\n+        Fail(_) => fail!(\"test_c_dependency_yes_rebuilding failed for some other reason\")\n+    }\n+}\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};"}, {"sha": "ffbc6e2a7f9b2a68f07a2a3137e5dd25eb9a18dc", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/bar.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fbar.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn assert_true() {\n+    assert!(true);\n+}"}, {"sha": "542a6af402d055053afffe3c366fb145e51c4b83", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/foo.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn do_nothing() {\n+}\n\\ No newline at end of file"}, {"sha": "bd1cb240a34cb88f3b2bb6a4df568aa797dece35", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/lib.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Flib.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod std;\n+\n+pub mod foo;\n+pub mod bar;"}, {"sha": "b667dc0a576fdf7e5f1ac2cf3968514e97c0adc7", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod rustpkg;\n+extern mod rustc;\n+\n+use std::{io, os, task};\n+use rustpkg::api;\n+use rustpkg::version::NoVersion;\n+use rustpkg::workcache_support::digest_file_with_date;\n+use rustpkg::exit_codes::COPY_FAILED_CODE;\n+\n+pub fn main() {\n+    let args = os::args();\n+\n+// by convention, first arg is sysroot\n+    if args.len() < 2 {\n+        fail!(\"Package script requires a directory where rustc libraries live as the first \\\n+               argument\");\n+    }\n+\n+    let path_for_db = api::default_workspace();\n+    debug!(\"path_for_db = {}\", path_for_db.display());\n+\n+    let sysroot_arg = args[1].clone();\n+    let sysroot = Path::new(sysroot_arg);\n+    if !os::path_exists(&sysroot) {\n+        fail!(\"Package script requires a sysroot that exists; {} doesn't\", sysroot.display());\n+    }\n+\n+    if args[2] != ~\"install\" {\n+        io::println(format!(\"Warning: I don't know how to {}\", args[2]));\n+        return;\n+    }\n+\n+    let mut context = api::default_context(sysroot, path_for_db);\n+    let my_workspace = api::my_workspace(&context.context, \"cdep\");\n+    let foo_c_name = my_workspace.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]);\n+\n+    let out_lib_path = do context.workcache_context.with_prep(\"foo.c\") |prep| {\n+        let sub_cx = context.context.clone();\n+        debug!(\"foo_c_name = {}\", foo_c_name.display());\n+        prep.declare_input(\"file\",\n+                           foo_c_name.as_str().unwrap().to_owned(),\n+                           digest_file_with_date(&foo_c_name));\n+        let out_path = do prep.exec |exec| {\n+            let out_path = api::build_library_in_workspace(exec,\n+                                                           &mut sub_cx.clone(),\n+                                                           \"cdep\",\n+                                                           \"gcc\",\n+                                                           [~\"-c\"],\n+                                                           [~\"foo.c\"],\n+                                                           \"foo\");\n+            let out_p = Path::new(out_path);\n+            out_p.as_str().unwrap().to_owned()\n+        };\n+        out_path\n+    };\n+    let out_lib_path = Path::new(out_lib_path);\n+    debug!(\"out_lib_path = {}\", out_lib_path.display());\n+    context.add_library_path(out_lib_path.dir_path());\n+\n+    let context_clone = context.clone();\n+    let task_res = do task::try {\n+        let mut cc = context_clone.clone();\n+        api::install_pkg(&mut cc,\n+                         os::getcwd(),\n+                         ~\"cdep\",\n+                         NoVersion,\n+                         ~[(~\"binary\", out_lib_path.clone()), (~\"file\", foo_c_name.clone())]);\n+    };\n+\n+    if task_res.is_err() {\n+        os::set_exit_status(COPY_FAILED_CODE);\n+    }\n+}"}, {"sha": "17386cd03c22b605a6edd3c6f758005bbcb67d00", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -21,4 +21,4 @@ extern mod std;\n \n pub mod foo;\n pub mod bar;\n-#[path = \"../../build/fancy_lib/generated.rs\"] pub mod generated;\n+#[path = \"../../build/fancy-lib/generated.rs\"] pub mod generated;"}, {"sha": "0b838b3e0f9e34547e207d6313113fb6d14e0a98", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -15,42 +15,37 @@ use std::{io, os};\n use rustpkg::api;\n use rustpkg::version::NoVersion;\n \n-use rustc::metadata::filesearch;\n-\n pub fn main() {\n-    use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n     let args = os::args();\n \n // by convention, first arg is sysroot\n     if args.len() < 2 {\n+        debug!(\"Failing, arg len\");\n         fail!(\"Package script requires a directory where rustc libraries live as the first \\\n                argument\");\n     }\n \n     let sysroot_arg = args[1].clone();\n-    let sysroot = Path(sysroot_arg);\n+    let sysroot = Path::new(sysroot_arg);\n     if !os::path_exists(&sysroot) {\n-        fail!(\"Package script requires a sysroot that exists; %s doesn't\", sysroot.to_str());\n+        debug!(\"Failing, sysroot\");\n+        fail!(\"Package script requires a sysroot that exists;{} doesn't\", sysroot.display());\n     }\n \n     if args[2] != ~\"install\" {\n+        debug!(\"Failing, weird command\");\n         println!(\"Warning: I don't know how to {}\", args[2]);\n         return;\n     }\n \n-    let out_path = Path(\"build/fancy-lib\");\n-    if !os::path_exists(&out_path) {\n-        assert!(os::make_dir(&out_path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    }\n-\n-    let file = io::file_writer(&out_path.push(\"generated.rs\"),\n-                               [io::Create]).unwrap();\n-    file.write_str(\"pub fn wheeeee() { for [1, 2, 3].each() |_| { assert!(true); } }\");\n-\n+    debug!(\"Checking self_exe_path\");\n+    let out_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n \n-    debug!(\"api_____install_____lib, my sysroot:\");\n-    debug!(sysroot.to_str());\n+    debug!(\"Writing file\");\n+    let file = io::file_writer(&out_path.join(\"generated.rs\"), [io::Create]).unwrap();\n+    file.write_str(\"pub fn wheeeee() { let xs = [1, 2, 3]; \\\n+                   for _ in xs.iter() { assert!(true); } }\");\n \n-    api::install_lib(@sysroot, os::getcwd(), ~\"fancy-lib\", Path(\"lib.rs\"),\n-                     NoVersion);\n+    let context = api::default_context(sysroot, api::default_workspace());\n+    api::install_pkg(&context, os::getcwd(), ~\"fancy-lib\", NoVersion, ~[]);\n }"}, {"sha": "0e4fbbf2c10fbabc682f2d7624317af17778a89e", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc8ad3979918fafb0527cc3326dc27b21936b0/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=4cbc8ad3979918fafb0527cc3326dc27b21936b0", "patch": "@@ -27,11 +27,13 @@ use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n use package_id::PkgId;\n use package_source::PkgSrc;\n use workspace::pkg_parent_workspaces;\n-use path_util::{U_RWX, system_library, target_build_dir};\n+use path_util::{system_library, target_build_dir};\n use path_util::{default_workspace, built_library_in_workspace};\n pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n pub use target::{Target, Build, Install};\n use extra::treemap::TreeMap;\n+use path_util::U_RWX;\n+pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Inferred};\n use workcache_support::{digest_file_with_date, digest_only_date};\n \n // It would be nice to have the list of commands in just one place -- for example,\n@@ -233,19 +235,23 @@ pub fn compile_input(context: &BuildContext,\n         Nothing => link::output_type_exe\n     };\n \n+    debug!(\"Output type = {:?}\", output_type);\n+\n     let options = @session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: what == Test || what == Bench,\n         maybe_sysroot: Some(sysroot_to_use),\n-        addl_lib_search_paths: @mut (~[]),\n+        addl_lib_search_paths: @mut context.additional_library_paths(),\n         output_type: output_type,\n         .. (*driver::build_session_options(binary,\n                                            &matches,\n                                            @diagnostic::DefaultEmitter as\n                                             @diagnostic::Emitter)).clone()\n     };\n \n+    debug!(\"Created options...\");\n+\n     let addl_lib_search_paths = @mut options.addl_lib_search_paths;\n     // Make sure all the library directories actually exist, since the linker will complain\n     // otherwise\n@@ -258,16 +264,22 @@ pub fn compile_input(context: &BuildContext,\n         }\n     }\n \n+    debug!(\"About to build session...\");\n+\n     let sess = driver::build_session(options,\n                                      @diagnostic::DefaultEmitter as\n                                         @diagnostic::Emitter);\n \n+    debug!(\"About to build config...\");\n+\n     // Infer dependencies that rustpkg needs to build, by scanning for\n     // `extern mod` directives.\n     let cfg = driver::build_configuration(sess);\n     let mut crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n     crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n \n+    debug!(\"About to call find_and_install_dependencies...\");\n+\n     find_and_install_dependencies(context, pkg_id, in_file, sess, exec, &crate, deps,\n                                   |p| {\n                                       debug!(\"a dependency: {}\", p.display());\n@@ -377,7 +389,6 @@ pub fn compile_crate_from_input(input: &Path,\n \n     debug!(\"Built {}, date = {:?}\", outputs.out_filename.display(),\n            datestamp(&outputs.out_filename));\n-\n     Some(outputs.out_filename)\n }\n \n@@ -431,7 +442,9 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                 };\n                 debug!(\"Finding and installing... {}\", lib_name);\n                 // Check standard Rust library path first\n-                match system_library(&self.context.sysroot(), lib_name) {\n+                let whatever = system_library(&self.context.sysroot(), lib_name);\n+                debug!(\"system library returned {:?}\", whatever);\n+                match whatever {\n                     Some(ref installed_path) => {\n                         debug!(\"It exists: {}\", installed_path.display());\n                         // Say that [path for c] has a discovered dependency on\n@@ -478,7 +491,10 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                   self.context.context.use_rust_path_hack,\n                                                   pkg_id.clone());\n                         let (outputs_disc, inputs_disc) =\n-                            self.context.install(pkg_src, &JustOne(Path::new(lib_crate_filename)));\n+                            self.context.install(\n+                                pkg_src,\n+                                &WhatToBuild::new(Inferred,\n+                                                  JustOne(Path::new(lib_crate_filename))));\n                         debug!(\"Installed {}, returned {:?} dependencies and \\\n                                {:?} transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());"}]}