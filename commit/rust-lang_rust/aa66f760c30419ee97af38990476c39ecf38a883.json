{"sha": "aa66f760c30419ee97af38990476c39ecf38a883", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNjZmNzYwYzMwNDE5ZWU5N2FmMzg5OTA0NzZjMzllY2YzOGE4ODM=", "commit": {"author": {"name": "Krishna Veera Reddy", "email": "veerareddy@email.arizona.edu", "date": "2019-12-22T19:05:19Z"}, "committer": {"name": "Krishna Veera Reddy", "email": "veerareddy@email.arizona.edu", "date": "2019-12-31T17:22:35Z"}, "message": "Destructure `mem:replace` arguments", "tree": {"sha": "4e5590e3c46aaa3439d3e8023deb5abfcd150c71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e5590e3c46aaa3439d3e8023deb5abfcd150c71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa66f760c30419ee97af38990476c39ecf38a883", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa66f760c30419ee97af38990476c39ecf38a883", "html_url": "https://github.com/rust-lang/rust/commit/aa66f760c30419ee97af38990476c39ecf38a883", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa66f760c30419ee97af38990476c39ecf38a883/comments", "author": {"login": "krishna-veerareddy", "id": 41484652, "node_id": "MDQ6VXNlcjQxNDg0NjUy", "avatar_url": "https://avatars.githubusercontent.com/u/41484652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krishna-veerareddy", "html_url": "https://github.com/krishna-veerareddy", "followers_url": "https://api.github.com/users/krishna-veerareddy/followers", "following_url": "https://api.github.com/users/krishna-veerareddy/following{/other_user}", "gists_url": "https://api.github.com/users/krishna-veerareddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/krishna-veerareddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krishna-veerareddy/subscriptions", "organizations_url": "https://api.github.com/users/krishna-veerareddy/orgs", "repos_url": "https://api.github.com/users/krishna-veerareddy/repos", "events_url": "https://api.github.com/users/krishna-veerareddy/events{/privacy}", "received_events_url": "https://api.github.com/users/krishna-veerareddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "krishna-veerareddy", "id": 41484652, "node_id": "MDQ6VXNlcjQxNDg0NjUy", "avatar_url": "https://avatars.githubusercontent.com/u/41484652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krishna-veerareddy", "html_url": "https://github.com/krishna-veerareddy", "followers_url": "https://api.github.com/users/krishna-veerareddy/followers", "following_url": "https://api.github.com/users/krishna-veerareddy/following{/other_user}", "gists_url": "https://api.github.com/users/krishna-veerareddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/krishna-veerareddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krishna-veerareddy/subscriptions", "organizations_url": "https://api.github.com/users/krishna-veerareddy/orgs", "repos_url": "https://api.github.com/users/krishna-veerareddy/repos", "events_url": "https://api.github.com/users/krishna-veerareddy/events{/privacy}", "received_events_url": "https://api.github.com/users/krishna-veerareddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78b4dfc57cffd96c5f48b0bc0b350066ab1d0ceb", "url": "https://api.github.com/repos/rust-lang/rust/commits/78b4dfc57cffd96c5f48b0bc0b350066ab1d0ceb", "html_url": "https://github.com/rust-lang/rust/commit/78b4dfc57cffd96c5f48b0bc0b350066ab1d0ceb"}], "stats": {"total": 40, "additions": 20, "deletions": 20}, "files": [{"sha": "4e0d2c24f751a4b2973d0006b8d8f463d487039a", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/aa66f760c30419ee97af38990476c39ecf38a883/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66f760c30419ee97af38990476c39ecf38a883/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=aa66f760c30419ee97af38990476c39ecf38a883", "patch": "@@ -3,10 +3,11 @@ use crate::utils::{\n };\n use if_chain::if_chain;\n use rustc::declare_lint_pass;\n-use rustc::hir::{BorrowKind, Expr, ExprKind, HirVec, Mutability, QPath};\n+use rustc::hir::{BorrowKind, Expr, ExprKind, Mutability, QPath};\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintPass};\n use rustc_errors::Applicability;\n use rustc_session::declare_tool_lint;\n+use syntax::source_map::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `mem::replace()` on an `Option` with\n@@ -94,16 +95,16 @@ declare_clippy_lint! {\n declare_lint_pass!(MemReplace =>\n     [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT, MEM_REPLACE_WITH_DEFAULT]);\n \n-fn check_replace_option_with_none(cx: &LateContext<'_, '_>, expr: &'_ Expr, args: &HirVec<Expr>) {\n-    if let ExprKind::Path(ref replacement_qpath) = args[1].kind {\n+fn check_replace_option_with_none(cx: &LateContext<'_, '_>, src: &Expr, dest: &Expr, expr_span: Span) {\n+    if let ExprKind::Path(ref replacement_qpath) = src.kind {\n         // Check that second argument is `Option::None`\n         if match_qpath(replacement_qpath, &paths::OPTION_NONE) {\n             // Since this is a late pass (already type-checked),\n             // and we already know that the second argument is an\n             // `Option`, we do not need to check the first\n             // argument's type. All that's left is to get\n             // replacee's path.\n-            let replaced_path = match args[0].kind {\n+            let replaced_path = match dest.kind {\n                 ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, ref replaced) => {\n                     if let ExprKind::Path(QPath::Resolved(None, ref replaced_path)) = replaced.kind {\n                         replaced_path\n@@ -119,7 +120,7 @@ fn check_replace_option_with_none(cx: &LateContext<'_, '_>, expr: &'_ Expr, args\n             span_lint_and_sugg(\n                 cx,\n                 MEM_REPLACE_OPTION_WITH_NONE,\n-                expr.span,\n+                expr_span,\n                 \"replacing an `Option` with `None`\",\n                 \"consider `Option::take()` instead\",\n                 format!(\n@@ -132,8 +133,8 @@ fn check_replace_option_with_none(cx: &LateContext<'_, '_>, expr: &'_ Expr, args\n     }\n }\n \n-fn check_replace_with_uninit(cx: &LateContext<'_, '_>, expr: &'_ Expr, args: &HirVec<Expr>) {\n-    if let ExprKind::Call(ref repl_func, ref repl_args) = args[1].kind {\n+fn check_replace_with_uninit(cx: &LateContext<'_, '_>, src: &Expr, expr_span: Span) {\n+    if let ExprKind::Call(ref repl_func, ref repl_args) = src.kind {\n         if_chain! {\n             if repl_args.is_empty();\n             if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n@@ -143,16 +144,16 @@ fn check_replace_with_uninit(cx: &LateContext<'_, '_>, expr: &'_ Expr, args: &Hi\n                     span_help_and_lint(\n                         cx,\n                         MEM_REPLACE_WITH_UNINIT,\n-                        expr.span,\n+                        expr_span,\n                         \"replacing with `mem::uninitialized()`\",\n                         \"consider using the `take_mut` crate instead\",\n                     );\n                 } else if match_def_path(cx, repl_def_id, &paths::MEM_ZEROED) &&\n-                        !cx.tables.expr_ty(&args[1]).is_primitive() {\n+                        !cx.tables.expr_ty(src).is_primitive() {\n                     span_help_and_lint(\n                         cx,\n                         MEM_REPLACE_WITH_UNINIT,\n-                        expr.span,\n+                        expr_span,\n                         \"replacing with `mem::zeroed()`\",\n                         \"consider using a default value or the `take_mut` crate instead\",\n                     );\n@@ -162,10 +163,10 @@ fn check_replace_with_uninit(cx: &LateContext<'_, '_>, expr: &'_ Expr, args: &Hi\n     }\n }\n \n-fn check_replace_with_default(cx: &LateContext<'_, '_>, expr: &'_ Expr, args: &HirVec<Expr>) {\n-    if let ExprKind::Call(ref repl_func, _) = args[1].kind {\n+fn check_replace_with_default(cx: &LateContext<'_, '_>, src: &Expr, dest: &Expr, expr_span: Span) {\n+    if let ExprKind::Call(ref repl_func, _) = src.kind {\n         if_chain! {\n-            if !in_macro(expr.span) && !in_external_macro(cx.tcx.sess, expr.span);\n+            if !in_macro(expr_span) && !in_external_macro(cx.tcx.sess, expr_span);\n             if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n             if let Some(repl_def_id) = cx.tables.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n             if match_def_path(cx, repl_def_id, &paths::DEFAULT_TRAIT_METHOD);\n@@ -175,12 +176,12 @@ fn check_replace_with_default(cx: &LateContext<'_, '_>, expr: &'_ Expr, args: &H\n                 span_lint_and_sugg(\n                     cx,\n                     MEM_REPLACE_WITH_DEFAULT,\n-                    expr.span,\n+                    expr_span,\n                     \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\",\n                     \"consider using\",\n                     format!(\n                         \"std::mem::take({})\",\n-                        snippet_with_applicability(cx, args[0].span, \"\", &mut applicability)\n+                        snippet_with_applicability(cx, dest.span, \"\", &mut applicability)\n                     ),\n                     applicability,\n                 );\n@@ -194,15 +195,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n         if_chain! {\n             // Check that `expr` is a call to `mem::replace()`\n             if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n-            if func_args.len() == 2;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::MEM_REPLACE);\n-\n+            if let [dest, src] = &**func_args;\n             then {\n-                check_replace_option_with_none(cx, expr, &func_args);\n-                check_replace_with_uninit(cx, expr, &func_args);\n-                check_replace_with_default(cx, expr, &func_args);\n+                check_replace_option_with_none(cx, src, dest, expr.span);\n+                check_replace_with_uninit(cx, src, expr.span);\n+                check_replace_with_default(cx, src, dest, expr.span);\n             }\n         }\n     }"}]}