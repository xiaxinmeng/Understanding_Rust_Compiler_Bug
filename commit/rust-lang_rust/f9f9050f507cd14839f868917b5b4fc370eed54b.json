{"sha": "f9f9050f507cd14839f868917b5b4fc370eed54b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZjkwNTBmNTA3Y2QxNDgzOWY4Njg5MTdiNWI0ZmMzNzBlZWQ1NGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-13T07:34:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-13T07:34:37Z"}, "message": "Auto merge of #49389 - fanzier:euclidean-division, r=KodrAus\n\nImplement RFC #2169 (Euclidean modulo).\n\nTracking issue: #49048", "tree": {"sha": "f3f87ea503aad52e3cb90da78c09ef5d8abdbcfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3f87ea503aad52e3cb90da78c09ef5d8abdbcfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9f9050f507cd14839f868917b5b4fc370eed54b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f9050f507cd14839f868917b5b4fc370eed54b", "html_url": "https://github.com/rust-lang/rust/commit/f9f9050f507cd14839f868917b5b4fc370eed54b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9f9050f507cd14839f868917b5b4fc370eed54b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eec3208c4cee937356199b30e0419357777c5070", "url": "https://api.github.com/repos/rust-lang/rust/commits/eec3208c4cee937356199b30e0419357777c5070", "html_url": "https://github.com/rust-lang/rust/commit/eec3208c4cee937356199b30e0419357777c5070"}, {"sha": "ca4e458089d0fecb8684de0437534d5f40b003bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca4e458089d0fecb8684de0437534d5f40b003bf", "html_url": "https://github.com/rust-lang/rust/commit/ca4e458089d0fecb8684de0437534d5f40b003bf"}], "stats": {"total": 541, "additions": 541, "deletions": 0}, "files": [{"sha": "35d70609c19edfe6b08800e328c5d95c6b17dd9e", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 440, "deletions": 0, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/f9f9050f507cd14839f868917b5b4fc370eed54b/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f9050f507cd14839f868917b5b4fc370eed54b/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=f9f9050f507cd14839f868917b5b4fc370eed54b", "patch": "@@ -643,6 +643,32 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked Euclidean division. Computes `self.div_euc(rhs)`,\n+returning `None` if `rhs == 0` or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+assert_eq!((\", stringify!($SelfT),\n+\"::min_value() + 1).checked_div_euc(-1), Some(\", stringify!($Max), \"));\n+assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euc(-1), None);\n+assert_eq!((1\", stringify!($SelfT), \").checked_div_euc(0), None);\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn checked_div_euc(self, rhs: Self) -> Option<Self> {\n+                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                    None\n+                } else {\n+                    Some(self.div_euc(rhs))\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer remainder. Computes `self % rhs`, returning `None` if\n `rhs == 0` or the division results in overflow.\n@@ -670,6 +696,33 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked Euclidean modulo. Computes `self.mod_euc(rhs)`, returning `None` if\n+`rhs == 0` or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(0), None);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_mod_euc(-1), None);\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn checked_mod_euc(self, rhs: Self) -> Option<Self> {\n+                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                    None\n+                } else {\n+                    Some(self.mod_euc(rhs))\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked negation. Computes `-self`, returning `None` if `self == MIN`.\n \n@@ -1003,6 +1056,34 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean division. Computes `self.div_euc(rhs)`,\n+wrapping around at the boundary of the type.\n+\n+Wrapping will only occur in `MIN / -1` on a signed type (where `MIN` is the negative minimal value\n+for the type). This is equivalent to `-MIN`, a positive value that is too large to represent in the\n+type. In this case, this method returns `MIN` itself.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euc(10), 10);\n+assert_eq!((-128i8).wrapping_div_euc(-1), -128);\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn wrapping_div_euc(self, rhs: Self) -> Self {\n+                self.overflowing_div_euc(rhs).0\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at the\n boundary of the type.\n@@ -1031,6 +1112,33 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean modulo. Computes `self.mod_euc(rhs)`, wrapping around at the\n+boundary of the type.\n+\n+Wrapping will only occur in `MIN % -1` on a signed type (where `MIN` is the negative minimal value\n+for the type). In this case, this method returns 0.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_mod_euc(10), 0);\n+assert_eq!((-128i8).wrapping_mod_euc(-1), 0);\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn wrapping_mod_euc(self, rhs: Self) -> Self {\n+                self.overflowing_mod_euc(rhs).0\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n of the type.\n@@ -1296,6 +1404,39 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Calculates the quotient of Euclidean division `self.div_euc(rhs)`.\n+\n+Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n+occur. If an overflow would occur then `self` is returned.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euc(2), (2, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euc(-1), (\", stringify!($SelfT),\n+\"::MIN, true));\n+```\"),\n+            #[inline]\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            pub fn overflowing_div_euc(self, rhs: Self) -> (Self, bool) {\n+                if self == Self::min_value() && rhs == -1 {\n+                    (self, true)\n+                } else {\n+                    (self.div_euc(rhs), false)\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates the remainder when `self` is divided by `rhs`.\n \n@@ -1328,6 +1469,40 @@ $EndFeature, \"\n             }\n         }\n \n+\n+        doc_comment! {\n+            concat!(\"Calculates the remainder `self.mod_euc(rhs)` by Euclidean division.\n+\n+Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n+arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_mod_euc(2), (1, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_mod_euc(-1), (0, true));\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn overflowing_mod_euc(self, rhs: Self) -> (Self, bool) {\n+                if self == Self::min_value() && rhs == -1 {\n+                    (0, true)\n+                } else {\n+                    (self.mod_euc(rhs), false)\n+                }\n+            }\n+        }\n+\n+\n         doc_comment! {\n             concat!(\"Negates self, overflowing if this is equal to the minimum value.\n \n@@ -1522,6 +1697,80 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Calculates the quotient of Euclidean division of `self` by `rhs`.\n+\n+This computes the integer `n` such that `self = n * rhs + self.mod_euc(rhs)`.\n+In other words, the result is `self / rhs` rounded to the integer `n`\n+such that `self >= n * rhs`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n+let b = 4;\n+\n+assert_eq!(a.div_euc(b), 1); // 7 >= 4 * 1\n+assert_eq!(a.div_euc(-b), -1); // 7 >= -4 * -1\n+assert_eq!((-a).div_euc(b), -2); // -7 >= 4 * -2\n+assert_eq!((-a).div_euc(-b), 2); // -7 >= -4 * 2\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub fn div_euc(self, rhs: Self) -> Self {\n+                let q = self / rhs;\n+                if self % rhs < 0 {\n+                    return if rhs > 0 { q - 1 } else { q + 1 }\n+                }\n+                q\n+            }\n+        }\n+\n+\n+        doc_comment! {\n+            concat!(\"Calculates the remainder `self mod rhs` by Euclidean division.\n+\n+In particular, the result `n` satisfies `0 <= n < rhs.abs()`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n+let b = 4;\n+\n+assert_eq!(a.mod_euc(b), 3);\n+assert_eq!((-a).mod_euc(b), 1);\n+assert_eq!(a.mod_euc(-b), 3);\n+assert_eq!((-a).mod_euc(-b), 1);\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub fn mod_euc(self, rhs: Self) -> Self {\n+                let r = self % rhs;\n+                if r < 0 {\n+                    r + rhs.abs()\n+                } else {\n+                    r\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Computes the absolute value of `self`.\n \n@@ -2109,6 +2358,31 @@ assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked Euclidean division. Computes `self.div_euc(rhs)`, returning `None`\n+if `rhs == 0`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\n+assert_eq!(1\", stringify!($SelfT), \".checked_div_euc(0), None);\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn checked_div_euc(self, rhs: Self) -> Option<Self> {\n+                if rhs == 0 {\n+                    None\n+                } else {\n+                    Some(self.div_euc(rhs))\n+                }\n+            }\n+        }\n+\n+\n         doc_comment! {\n             concat!(\"Checked integer remainder. Computes `self % rhs`, returning `None`\n if `rhs == 0`.\n@@ -2132,6 +2406,30 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked Euclidean modulo. Computes `self.mod_euc(rhs)`, returning `None`\n+if `rhs == 0`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(0), None);\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn checked_mod_euc(self, rhs: Self) -> Option<Self> {\n+                if rhs == 0 {\n+                    None\n+                } else {\n+                    Some(self.mod_euc(rhs))\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked negation. Computes `-self`, returning `None` unless `self ==\n 0`.\n@@ -2411,6 +2709,28 @@ Basic usage:\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean division. Computes `self.div_euc(rhs)`.\n+Wrapped division on unsigned types is just normal division.\n+There's no way wrapping could ever happen.\n+This function exists, so that all operations\n+are accounted for in the wrapping operations.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euc(10), 10);\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn wrapping_div_euc(self, rhs: Self) -> Self {\n+                self / rhs\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) remainder. Computes `self % rhs`.\n Wrapped remainder calculation on unsigned types is\n@@ -2433,6 +2753,29 @@ Basic usage:\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean modulo. Computes `self.mod_euc(rhs)`.\n+Wrapped modulo calculation on unsigned types is\n+just the regular remainder calculation.\n+There's no way wrapping could ever happen.\n+This function exists, so that all operations\n+are accounted for in the wrapping operations.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_mod_euc(10), 0);\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn wrapping_mod_euc(self, rhs: Self) -> Self {\n+                self % rhs\n+            }\n+        }\n+\n         /// Wrapping (modular) negation. Computes `-self`,\n         /// wrapping around at the boundary of the type.\n         ///\n@@ -2666,6 +3009,33 @@ Basic usage\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Calculates the quotient of Euclidean division `self.div_euc(rhs)`.\n+\n+Returns a tuple of the divisor along with a boolean indicating\n+whether an arithmetic overflow would occur. Note that for unsigned\n+integers overflow never occurs, so the second value is always\n+`false`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+#![feature(euclidean_division)]\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euc(2), (2, false));\n+```\"),\n+            #[inline]\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            pub fn overflowing_div_euc(self, rhs: Self) -> (Self, bool) {\n+                (self / rhs, false)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates the remainder when `self` is divided by `rhs`.\n \n@@ -2692,6 +3062,33 @@ Basic usage\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Calculates the remainder `self.mod_euc(rhs)` by Euclidean division.\n+\n+Returns a tuple of the modulo after dividing along with a boolean\n+indicating whether an arithmetic overflow would occur. Note that for\n+unsigned integers overflow never occurs, so the second value is\n+always `false`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+#![feature(euclidean_division)]\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_mod_euc(2), (1, false));\n+```\"),\n+            #[inline]\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            pub fn overflowing_mod_euc(self, rhs: Self) -> (Self, bool) {\n+                (self % rhs, false)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Negates self in an overflowing fashion.\n \n@@ -2849,6 +3246,49 @@ Basic usage:\n         }\n     }\n \n+            doc_comment! {\n+            concat!(\"Performs Euclidean division.\n+\n+For unsigned types, this is just the same as `self / rhs`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+assert_eq!(7\", stringify!($SelfT), \".div_euc(4), 1); // or any other integer type\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub fn div_euc(self, rhs: Self) -> Self {\n+                self / rhs\n+            }\n+        }\n+\n+\n+        doc_comment! {\n+            concat!(\"Calculates the remainder `self mod rhs` by Euclidean division.\n+\n+For unsigned types, this is just the same as `self % rhs`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(euclidean_division)]\n+assert_eq!(7\", stringify!($SelfT), \".mod_euc(4), 3); // or any other integer type\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub fn mod_euc(self, rhs: Self) -> Self {\n+                self % rhs\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Returns `true` if and only if `self == 2^k` for some `k`.\n "}, {"sha": "ca39089a9583acf553e6a164e20b71207e34290f", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f9f9050f507cd14839f868917b5b4fc370eed54b/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f9050f507cd14839f868917b5b4fc370eed54b/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=f9f9050f507cd14839f868917b5b4fc370eed54b", "patch": "@@ -329,6 +329,57 @@ impl f32 {\n         unsafe { intrinsics::fmaf32(self, a, b) }\n     }\n \n+    /// Calculates Euclidean division, the matching method for `mod_euc`.\n+    ///\n+    /// This computes the integer `n` such that\n+    /// `self = n * rhs + self.mod_euc(rhs)`.\n+    /// In other words, the result is `self / rhs` rounded to the integer `n`\n+    /// such that `self >= n * rhs`.\n+    ///\n+    /// ```\n+    /// #![feature(euclidean_division)]\n+    /// let a: f32 = 7.0;\n+    /// let b = 4.0;\n+    /// assert_eq!(a.div_euc(b), 1.0); // 7.0 > 4.0 * 1.0\n+    /// assert_eq!((-a).div_euc(b), -2.0); // -7.0 >= 4.0 * -2.0\n+    /// assert_eq!(a.div_euc(-b), -1.0); // 7.0 >= -4.0 * -1.0\n+    /// assert_eq!((-a).div_euc(-b), 2.0); // -7.0 >= -4.0 * 2.0\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    pub fn div_euc(self, rhs: f32) -> f32 {\n+        let q = (self / rhs).trunc();\n+        if self % rhs < 0.0 {\n+            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 }\n+        }\n+        q\n+    }\n+\n+    /// Calculates the Euclidean modulo (self mod rhs), which is never negative.\n+    ///\n+    /// In particular, the result `n` satisfies `0 <= n < rhs.abs()`.\n+    ///\n+    /// ```\n+    /// #![feature(euclidean_division)]\n+    /// let a: f32 = 7.0;\n+    /// let b = 4.0;\n+    /// assert_eq!(a.mod_euc(b), 3.0);\n+    /// assert_eq!((-a).mod_euc(b), 1.0);\n+    /// assert_eq!(a.mod_euc(-b), 3.0);\n+    /// assert_eq!((-a).mod_euc(-b), 1.0);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    pub fn mod_euc(self, rhs: f32) -> f32 {\n+        let r = self % rhs;\n+        if r < 0.0 {\n+            r + rhs.abs()\n+        } else {\n+            r\n+        }\n+    }\n+\n+\n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```"}, {"sha": "a9585670ad043d4242de60eab2f1e4071adf702b", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f9f9050f507cd14839f868917b5b4fc370eed54b/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f9050f507cd14839f868917b5b4fc370eed54b/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=f9f9050f507cd14839f868917b5b4fc370eed54b", "patch": "@@ -315,6 +315,56 @@ impl f64 {\n         unsafe { intrinsics::fmaf64(self, a, b) }\n     }\n \n+    /// Calculates Euclidean division, the matching method for `mod_euc`.\n+    ///\n+    /// This computes the integer `n` such that\n+    /// `self = n * rhs + self.mod_euc(rhs)`.\n+    /// In other words, the result is `self / rhs` rounded to the integer `n`\n+    /// such that `self >= n * rhs`.\n+    ///\n+    /// ```\n+    /// #![feature(euclidean_division)]\n+    /// let a: f64 = 7.0;\n+    /// let b = 4.0;\n+    /// assert_eq!(a.div_euc(b), 1.0); // 7.0 > 4.0 * 1.0\n+    /// assert_eq!((-a).div_euc(b), -2.0); // -7.0 >= 4.0 * -2.0\n+    /// assert_eq!(a.div_euc(-b), -1.0); // 7.0 >= -4.0 * -1.0\n+    /// assert_eq!((-a).div_euc(-b), 2.0); // -7.0 >= -4.0 * 2.0\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    pub fn div_euc(self, rhs: f64) -> f64 {\n+        let q = (self / rhs).trunc();\n+        if self % rhs < 0.0 {\n+            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 }\n+        }\n+        q\n+    }\n+\n+    /// Calculates the Euclidean modulo (self mod rhs), which is never negative.\n+    ///\n+    /// In particular, the result `n` satisfies `0 <= n < rhs.abs()`.\n+    ///\n+    /// ```\n+    /// #![feature(euclidean_division)]\n+    /// let a: f64 = 7.0;\n+    /// let b = 4.0;\n+    /// assert_eq!(a.mod_euc(b), 3.0);\n+    /// assert_eq!((-a).mod_euc(b), 1.0);\n+    /// assert_eq!(a.mod_euc(-b), 3.0);\n+    /// assert_eq!((-a).mod_euc(-b), 1.0);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    pub fn mod_euc(self, rhs: f64) -> f64 {\n+        let r = self % rhs;\n+        if r < 0.0 {\n+            r + rhs.abs()\n+        } else {\n+            r\n+        }\n+    }\n+\n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```"}]}