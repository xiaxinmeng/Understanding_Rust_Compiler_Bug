{"sha": "86a8b031f5eaa80ed9b1f789bd857257cdd7122c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YThiMDMxZjVlYWE4MGVkOWIxZjc4OWJkODU3MjU3Y2RkNzEyMmM=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-01-24T07:40:54Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-01-24T16:35:39Z"}, "message": "Move macro_rules! macros to libstd\n\nThey all have to go into a single module at the moment unfortunately.\nIdeally, the logging macros would live in std::logging, condition! would\nlive in std::condition, format! in std::fmt, etc. However, this\nintroduces cyclic dependencies between those modules and the macros they\nuse which the current expansion system can't deal with. We may be able\nto get around this by changing the expansion phase to a two-pass system\nbut that's for a later PR.\n\nCloses #2247\ncc #11763", "tree": {"sha": "38fdc73c124518f14eb351a05f5c73d81f92faa6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38fdc73c124518f14eb351a05f5c73d81f92faa6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86a8b031f5eaa80ed9b1f789bd857257cdd7122c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86a8b031f5eaa80ed9b1f789bd857257cdd7122c", "html_url": "https://github.com/rust-lang/rust/commit/86a8b031f5eaa80ed9b1f789bd857257cdd7122c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5ab960d2e443f61511b19ad80221d1f99fd0692", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ab960d2e443f61511b19ad80221d1f99fd0692", "html_url": "https://github.com/rust-lang/rust/commit/a5ab960d2e443f61511b19ad80221d1f99fd0692"}], "stats": {"total": 518, "additions": 247, "deletions": 271}, "files": [{"sha": "9e11e8f9b370a9fd41ae767d10ed8ad418fb3c7b", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=86a8b031f5eaa80ed9b1f789bd857257cdd7122c", "patch": "@@ -176,17 +176,16 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     time(time_passes, \"gated feature checking\", (), |_|\n          front::feature_gate::check_crate(sess, &crate));\n \n+    crate = time(time_passes, \"crate injection\", crate, |crate|\n+                 front::std_inject::maybe_inject_crates_ref(sess, crate));\n+\n     // strip before expansion to allow macros to depend on\n     // configuration variables e.g/ in\n     //\n     //   #[macro_escape] #[cfg(foo)]\n     //   mod bar { macro_rules! baz!(() => {{}}) }\n     //\n     // baz! should not use this definition unless foo is enabled.\n-    crate = time(time_passes, \"std macros injection\", crate, |crate|\n-                 syntax::ext::expand::inject_std_macros(sess.parse_sess,\n-                                                        cfg.clone(),\n-                                                        crate));\n \n     crate = time(time_passes, \"configuration 1\", crate, |crate|\n                  front::config::strip_unconfigured_items(crate));\n@@ -207,8 +206,8 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     crate = time(time_passes, \"maybe building test harness\", crate, |crate|\n                  front::test::modify_for_testing(sess, crate));\n \n-    crate = time(time_passes, \"std injection\", crate, |crate|\n-                 front::std_inject::maybe_inject_libstd_ref(sess, crate));\n+    crate = time(time_passes, \"prelude injection\", crate, |crate|\n+                 front::std_inject::maybe_inject_prelude(sess, crate));\n \n     time(time_passes, \"assinging node ids and indexing ast\", crate, |crate|\n          front::assign_node_ids_and_map::assign_node_ids_and_map(sess, crate))"}, {"sha": "71a82536aee0c54cf0ac4edf5538be62218987cc", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=86a8b031f5eaa80ed9b1f789bd857257cdd7122c", "patch": "@@ -23,10 +23,18 @@ use syntax::util::small_vector::SmallVector;\n \n pub static VERSION: &'static str = \"0.10-pre\";\n \n-pub fn maybe_inject_libstd_ref(sess: Session, crate: ast::Crate)\n+pub fn maybe_inject_crates_ref(sess: Session, crate: ast::Crate)\n                                -> ast::Crate {\n     if use_std(&crate) {\n-        inject_libstd_ref(sess, crate)\n+        inject_crates_ref(sess, crate)\n+    } else {\n+        crate\n+    }\n+}\n+\n+pub fn maybe_inject_prelude(sess: Session, crate: ast::Crate) -> ast::Crate {\n+    if use_std(&crate) {\n+        inject_prelude(sess, crate)\n     } else {\n         crate\n     }\n@@ -44,13 +52,6 @@ fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"no_implicit_prelude\")\n }\n \n-fn spanned<T>(x: T) -> codemap::Spanned<T> {\n-    codemap::Spanned {\n-        node: x,\n-        span: DUMMY_SP,\n-    }\n-}\n-\n struct StandardLibraryInjector {\n     sess: Session,\n }\n@@ -71,7 +72,11 @@ impl fold::Folder for StandardLibraryInjector {\n             node: ast::ViewItemExternMod(self.sess.ident_of(\"std\"),\n                                          with_version(\"std\"),\n                                          ast::DUMMY_NODE_ID),\n-            attrs: ~[],\n+            attrs: ~[\n+                attr::mk_attr(attr::mk_list_item(@\"phase\",\n+                                                 ~[attr::mk_word_item(@\"syntax\"),\n+                                                   attr::mk_word_item(@\"link\")]))\n+            ],\n             vis: ast::Inherited,\n             span: DUMMY_SP\n         }];\n@@ -96,22 +101,43 @@ impl fold::Folder for StandardLibraryInjector {\n         }\n \n         vis.push_all(crate.module.view_items);\n-        let mut new_module = ast::Mod {\n+        let new_module = ast::Mod {\n             view_items: vis,\n             ..crate.module.clone()\n         };\n \n-        if !no_prelude(crate.attrs) {\n-            // only add `use std::prelude::*;` if there wasn't a\n-            // `#[no_implicit_prelude];` at the crate level.\n-            new_module = self.fold_mod(&new_module);\n-        }\n-\n         ast::Crate {\n             module: new_module,\n             ..crate\n         }\n     }\n+}\n+\n+fn inject_crates_ref(sess: Session, crate: ast::Crate) -> ast::Crate {\n+    let mut fold = StandardLibraryInjector {\n+        sess: sess,\n+    };\n+    fold.fold_crate(crate)\n+}\n+\n+struct PreludeInjector {\n+    sess: Session,\n+}\n+\n+\n+impl fold::Folder for PreludeInjector {\n+    fn fold_crate(&mut self, crate: ast::Crate) -> ast::Crate {\n+        if !no_prelude(crate.attrs) {\n+            // only add `use std::prelude::*;` if there wasn't a\n+            // `#[no_implicit_prelude];` at the crate level.\n+            ast::Crate {\n+                module: self.fold_mod(&crate.module),\n+                ..crate\n+            }\n+        } else {\n+            crate\n+        }\n+    }\n \n     fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n         if !no_prelude(item.attrs) {\n@@ -142,7 +168,7 @@ impl fold::Folder for StandardLibraryInjector {\n             ],\n         };\n \n-        let vp = @spanned(ast::ViewPathGlob(prelude_path, ast::DUMMY_NODE_ID));\n+        let vp = @codemap::dummy_spanned(ast::ViewPathGlob(prelude_path, ast::DUMMY_NODE_ID));\n         let vi2 = ast::ViewItem {\n             node: ast::ViewItemUse(~[vp]),\n             attrs: ~[],\n@@ -161,8 +187,8 @@ impl fold::Folder for StandardLibraryInjector {\n     }\n }\n \n-fn inject_libstd_ref(sess: Session, crate: ast::Crate) -> ast::Crate {\n-    let mut fold = StandardLibraryInjector {\n+fn inject_prelude(sess: Session, crate: ast::Crate) -> ast::Crate {\n+    let mut fold = PreludeInjector {\n         sess: sess,\n     };\n     fold.fold_crate(crate)"}, {"sha": "4f13a51787871163774a23571dacafc3ba679fcd", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=86a8b031f5eaa80ed9b1f789bd857257cdd7122c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -76,6 +76,8 @@\n #[cfg(test)] pub use ops = realstd::ops;\n #[cfg(test)] pub use cmp = realstd::cmp;\n \n+mod macros;\n+\n mod rtdeps;\n \n /* The Prelude. */"}, {"sha": "effc9a77c1d71b919a122d47e7527b62386fb2fa", "filename": "src/libstd/macros.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=86a8b031f5eaa80ed9b1f789bd857257cdd7122c", "patch": "@@ -0,0 +1,192 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#[macro_escape];\n+\n+#[macro_export]\n+macro_rules! ignore (($($x:tt)*) => (()))\n+\n+#[macro_export]\n+macro_rules! log(\n+    ($lvl:expr, $($arg:tt)+) => ({\n+        let lvl = $lvl;\n+        if lvl <= __log_level() {\n+            format_args!(|args| {\n+                ::std::logging::log(lvl, args)\n+            }, $($arg)+)\n+        }\n+    })\n+)\n+#[macro_export]\n+macro_rules! error( ($($arg:tt)*) => (log!(1u32, $($arg)*)) )\n+#[macro_export]\n+macro_rules! warn ( ($($arg:tt)*) => (log!(2u32, $($arg)*)) )\n+#[macro_export]\n+macro_rules! info ( ($($arg:tt)*) => (log!(3u32, $($arg)*)) )\n+#[macro_export]\n+macro_rules! debug( ($($arg:tt)*) => (\n+    if cfg!(not(ndebug)) { log!(4u32, $($arg)*) }\n+))\n+\n+#[macro_export]\n+macro_rules! log_enabled(\n+    ($lvl:expr) => ( {\n+        let lvl = $lvl;\n+        lvl <= __log_level() && (lvl != 4 || cfg!(not(ndebug)))\n+    } )\n+)\n+\n+#[macro_export]\n+macro_rules! fail(\n+    () => (\n+        fail!(\"explicit failure\")\n+    );\n+    ($msg:expr) => (\n+        ::std::rt::begin_unwind($msg, file!(), line!())\n+    );\n+    ($fmt:expr, $($arg:tt)*) => (\n+        ::std::rt::begin_unwind(format!($fmt, $($arg)*), file!(), line!())\n+    )\n+)\n+\n+#[macro_export]\n+macro_rules! assert(\n+    ($cond:expr) => {\n+        if !$cond {\n+            fail!(\"assertion failed: {:s}\", stringify!($cond))\n+        }\n+    };\n+    ($cond:expr, $msg:expr) => {\n+        if !$cond {\n+            fail!($msg)\n+        }\n+    };\n+    ($cond:expr, $( $arg:expr ),+) => {\n+        if !$cond {\n+            fail!( $($arg),+ )\n+        }\n+    }\n+)\n+\n+#[macro_export]\n+macro_rules! assert_eq (\n+    ($given:expr , $expected:expr) => (\n+        {\n+            let given_val = &($given);\n+            let expected_val = &($expected);\n+            // check both directions of equality....\n+            if !((*given_val == *expected_val) &&\n+                 (*expected_val == *given_val)) {\n+                fail!(\"assertion failed: `(left == right) && (right == left)` \\\n+                       (left: `{:?}`, right: `{:?}`)\", *given_val, *expected_val)\n+            }\n+        }\n+    )\n+)\n+\n+/// A utility macro for indicating unreachable code. It will fail if\n+/// executed. This is occasionally useful to put after loops that never\n+/// terminate normally, but instead directly return from a function.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// fn choose_weighted_item(v: &[Item]) -> Item {\n+///     assert!(!v.is_empty());\n+///     let mut so_far = 0u;\n+///     for item in v.iter() {\n+///         so_far += item.weight;\n+///         if so_far > 100 {\n+///             return item;\n+///         }\n+///     }\n+///     // The above loop always returns, so we must hint to the\n+///     // type checker that it isn't possible to get down here\n+///     unreachable!();\n+/// }\n+/// ```\n+#[macro_export]\n+macro_rules! unreachable (() => (\n+    fail!(\"internal error: entered unreachable code\");\n+))\n+\n+#[macro_export]\n+macro_rules! condition (\n+\n+    { pub $c:ident: $input:ty -> $out:ty; } => {\n+\n+        pub mod $c {\n+            #[allow(unused_imports)];\n+            #[allow(non_uppercase_statics)];\n+            #[allow(missing_doc)];\n+\n+            use super::*;\n+\n+            local_data_key!(key: @::std::condition::Handler<$input, $out>)\n+\n+            pub static cond :\n+                ::std::condition::Condition<$input,$out> =\n+                ::std::condition::Condition {\n+                    name: stringify!($c),\n+                    key: key\n+                };\n+        }\n+    };\n+\n+    { $c:ident: $input:ty -> $out:ty; } => {\n+\n+        mod $c {\n+            #[allow(unused_imports)];\n+            #[allow(non_uppercase_statics)];\n+            #[allow(dead_code)];\n+\n+            use super::*;\n+\n+            local_data_key!(key: @::std::condition::Handler<$input, $out>)\n+\n+            pub static cond :\n+                ::std::condition::Condition<$input,$out> =\n+                ::std::condition::Condition {\n+                    name: stringify!($c),\n+                    key: key\n+                };\n+        }\n+    }\n+)\n+\n+#[macro_export]\n+macro_rules! format(($($arg:tt)*) => (\n+    format_args!(::std::fmt::format, $($arg)*)\n+))\n+#[macro_export]\n+macro_rules! write(($dst:expr, $($arg:tt)*) => (\n+    format_args!(|args| { ::std::fmt::write($dst, args) }, $($arg)*)\n+))\n+#[macro_export]\n+macro_rules! writeln(($dst:expr, $($arg:tt)*) => (\n+    format_args!(|args| { ::std::fmt::writeln($dst, args) }, $($arg)*)\n+))\n+#[macro_export]\n+macro_rules! print (\n+    ($($arg:tt)*) => (format_args!(::std::io::stdio::print_args, $($arg)*))\n+)\n+#[macro_export]\n+macro_rules! println (\n+    ($($arg:tt)*) => (format_args!(::std::io::stdio::println_args, $($arg)*))\n+)\n+\n+#[macro_export]\n+macro_rules! local_data_key (\n+    ($name:ident: $ty:ty) => (\n+        static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n+    );\n+    (pub $name:ident: $ty:ty) => (\n+        pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n+    )\n+)"}, {"sha": "43a5b01698b4ea73ea41543d3078095e0d549210", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=86a8b031f5eaa80ed9b1f789bd857257cdd7122c", "patch": "@@ -22,7 +22,6 @@ use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use ext::base::*;\n use fold::*;\n use parse;\n-use parse::{parse_item_from_source_str};\n use parse::token;\n use parse::token::{fresh_mark, fresh_name, ident_to_str, intern};\n use visit;\n@@ -754,218 +753,6 @@ pub fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n     }\n }\n \n-// FIXME (#2247): this is a moderately bad kludge to inject some macros into\n-// the default compilation environment in that it injects strings, rather than\n-// syntax elements.\n-\n-pub fn std_macros() -> @str {\n-@r#\"mod __std_macros {\n-    #[macro_escape];\n-    #[doc(hidden)];\n-    #[allow(dead_code)];\n-\n-    macro_rules! ignore (($($x:tt)*) => (()))\n-\n-    macro_rules! log(\n-        ($lvl:expr, $($arg:tt)+) => ({\n-            let lvl = $lvl;\n-            if lvl <= __log_level() {\n-                format_args!(|args| {\n-                    ::std::logging::log(lvl, args)\n-                }, $($arg)+)\n-            }\n-        })\n-    )\n-    macro_rules! error( ($($arg:tt)*) => (log!(1u32, $($arg)*)) )\n-    macro_rules! warn ( ($($arg:tt)*) => (log!(2u32, $($arg)*)) )\n-    macro_rules! info ( ($($arg:tt)*) => (log!(3u32, $($arg)*)) )\n-    macro_rules! debug( ($($arg:tt)*) => (\n-        if cfg!(not(ndebug)) { log!(4u32, $($arg)*) }\n-    ))\n-\n-    macro_rules! log_enabled(\n-        ($lvl:expr) => ( {\n-            let lvl = $lvl;\n-            lvl <= __log_level() && (lvl != 4 || cfg!(not(ndebug)))\n-        } )\n-    )\n-\n-    macro_rules! fail(\n-        () => (\n-            fail!(\"explicit failure\")\n-        );\n-        ($msg:expr) => (\n-            ::std::rt::begin_unwind($msg, file!(), line!())\n-        );\n-        ($fmt:expr, $($arg:tt)*) => (\n-            ::std::rt::begin_unwind(format!($fmt, $($arg)*), file!(), line!())\n-        )\n-    )\n-\n-    macro_rules! assert(\n-        ($cond:expr) => {\n-            if !$cond {\n-                fail!(\"assertion failed: {:s}\", stringify!($cond))\n-            }\n-        };\n-        ($cond:expr, $msg:expr) => {\n-            if !$cond {\n-                fail!($msg)\n-            }\n-        };\n-        ($cond:expr, $( $arg:expr ),+) => {\n-            if !$cond {\n-                fail!( $($arg),+ )\n-            }\n-        }\n-    )\n-\n-    macro_rules! assert_eq (\n-        ($given:expr , $expected:expr) => (\n-            {\n-                let given_val = &($given);\n-                let expected_val = &($expected);\n-                // check both directions of equality....\n-                if !((*given_val == *expected_val) &&\n-                     (*expected_val == *given_val)) {\n-                    fail!(\"assertion failed: `(left == right) && (right == left)` \\\n-                           (left: `{:?}`, right: `{:?}`)\", *given_val, *expected_val)\n-                }\n-            }\n-        )\n-    )\n-\n-    /// A utility macro for indicating unreachable code. It will fail if\n-    /// executed. This is occasionally useful to put after loops that never\n-    /// terminate normally, but instead directly return from a function.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// fn choose_weighted_item(v: &[Item]) -> Item {\n-    ///     assert!(!v.is_empty());\n-    ///     let mut so_far = 0u;\n-    ///     for item in v.iter() {\n-    ///         so_far += item.weight;\n-    ///         if so_far > 100 {\n-    ///             return item;\n-    ///         }\n-    ///     }\n-    ///     // The above loop always returns, so we must hint to the\n-    ///     // type checker that it isn't possible to get down here\n-    ///     unreachable!();\n-    /// }\n-    /// ```\n-    macro_rules! unreachable (() => (\n-        fail!(\"internal error: entered unreachable code\");\n-    ))\n-\n-    macro_rules! condition (\n-\n-        { pub $c:ident: $input:ty -> $out:ty; } => {\n-\n-            pub mod $c {\n-                #[allow(unused_imports)];\n-                #[allow(non_uppercase_statics)];\n-                #[allow(missing_doc)];\n-\n-                use super::*;\n-\n-                local_data_key!(key: @::std::condition::Handler<$input, $out>)\n-\n-                pub static cond :\n-                    ::std::condition::Condition<$input,$out> =\n-                    ::std::condition::Condition {\n-                        name: stringify!($c),\n-                        key: key\n-                    };\n-            }\n-        };\n-\n-        { $c:ident: $input:ty -> $out:ty; } => {\n-\n-            mod $c {\n-                #[allow(unused_imports)];\n-                #[allow(non_uppercase_statics)];\n-                #[allow(dead_code)];\n-\n-                use super::*;\n-\n-                local_data_key!(key: @::std::condition::Handler<$input, $out>)\n-\n-                pub static cond :\n-                    ::std::condition::Condition<$input,$out> =\n-                    ::std::condition::Condition {\n-                        name: stringify!($c),\n-                        key: key\n-                    };\n-            }\n-        }\n-    )\n-\n-    macro_rules! format(($($arg:tt)*) => (\n-        format_args!(::std::fmt::format, $($arg)*)\n-    ))\n-    macro_rules! write(($dst:expr, $($arg:tt)*) => (\n-        format_args!(|args| { ::std::fmt::write($dst, args) }, $($arg)*)\n-    ))\n-    macro_rules! writeln(($dst:expr, $($arg:tt)*) => (\n-        format_args!(|args| { ::std::fmt::writeln($dst, args) }, $($arg)*)\n-    ))\n-    macro_rules! print (\n-        ($($arg:tt)*) => (format_args!(::std::io::stdio::print_args, $($arg)*))\n-    )\n-    macro_rules! println (\n-        ($($arg:tt)*) => (format_args!(::std::io::stdio::println_args, $($arg)*))\n-    )\n-\n-    macro_rules! local_data_key (\n-        ($name:ident: $ty:ty) => (\n-            static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n-        );\n-        (pub $name:ident: $ty:ty) => (\n-            pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n-        )\n-    )\n-}\"#\n-}\n-\n-struct Injector {\n-    sm: @ast::Item,\n-}\n-\n-impl Folder for Injector {\n-    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n-        // Just inject the standard macros at the start of the first module\n-        // in the crate: that is, at the start of the crate file itself.\n-        let items = vec::append(~[ self.sm ], module.items);\n-        ast::Mod {\n-            items: items,\n-            ..(*module).clone() // FIXME #2543: Bad copy.\n-        }\n-    }\n-}\n-\n-// add a bunch of macros as though they were placed at the head of the\n-// program (ick). This should run before cfg stripping.\n-pub fn inject_std_macros(parse_sess: @parse::ParseSess,\n-                         cfg: ast::CrateConfig,\n-                         c: Crate)\n-                         -> Crate {\n-    let sm = match parse_item_from_source_str(@\"<std-macros>\",\n-                                              std_macros(),\n-                                              cfg.clone(),\n-                                              parse_sess) {\n-        Some(item) => item,\n-        None => fail!(\"expected core macros to parse correctly\")\n-    };\n-\n-    let mut injector = Injector {\n-        sm: sm,\n-    };\n-    injector.fold_crate(c)\n-}\n-\n pub struct MacroExpander<'a> {\n     extsbox: SyntaxEnv,\n     cx: &'a mut ExtCtxt<'a>,\n@@ -1231,20 +1018,6 @@ mod test {\n         }\n     }\n \n-    // make sure that fail! is present\n-    #[test] fn fail_exists_test () {\n-        let src = @\"fn main() { fail!(\\\"something appropriately gloomy\\\");}\";\n-        let sess = parse::new_parse_sess(None);\n-        let crate_ast = parse::parse_crate_from_source_str(\n-            @\"<test>\",\n-            src,\n-            ~[],sess);\n-        let crate_ast = inject_std_macros(sess, ~[], crate_ast);\n-        // don't bother with striping, doesn't affect fail!.\n-        let mut loader = ErrLoader;\n-        expand_crate(sess,&mut loader,~[],crate_ast);\n-    }\n-\n     // these following tests are quite fragile, in that they don't test what\n     // *kind* of failure occurs.\n \n@@ -1292,20 +1065,6 @@ mod test {\n         expand_crate(sess,&mut loader,~[],crate_ast);\n     }\n \n-    #[test] fn std_macros_must_parse () {\n-        let src = super::std_macros();\n-        let sess = parse::new_parse_sess(None);\n-        let cfg = ~[];\n-        let item_ast = parse::parse_item_from_source_str(\n-            @\"<test>\",\n-            src,\n-            cfg,sess);\n-        match item_ast {\n-            Some(_) => (), // success\n-            None => fail!(\"expected this to parse\")\n-        }\n-    }\n-\n     #[test] fn test_contains_flatten (){\n         let attr1 = make_dummy_attr (@\"foo\");\n         let attr2 = make_dummy_attr (@\"bar\");"}, {"sha": "0fc3b3912b17b39123083d59349efe3db807a4ee", "filename": "src/test/compile-fail/tag-that-dare-not-speak-its-name.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a8b031f5eaa80ed9b1f789bd857257cdd7122c/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs?ref=86a8b031f5eaa80ed9b1f789bd857257cdd7122c", "patch": "@@ -11,9 +11,7 @@\n // error-pattern:mismatched types: expected `char` but found\n // Issue #876\n \n-#[no_std];\n-\n-extern mod std;\n+#[no_implicit_prelude];\n \n fn last<T>(v: ~[&T]) -> std::option::Option<T> {\n     fail!();"}]}