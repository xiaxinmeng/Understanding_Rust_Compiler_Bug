{"sha": "9f16892b94817d144f37dfe0081b39aacec65635", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMTY4OTJiOTQ4MTdkMTQ0ZjM3ZGZlMDA4MWIzOWFhY2VjNjU2MzU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T14:17:28Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T14:17:28Z"}, "message": "remove watcher ctx", "tree": {"sha": "0aeca750f2aefb68ee1e062b41d852d8d0ca9dd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0aeca750f2aefb68ee1e062b41d852d8d0ca9dd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f16892b94817d144f37dfe0081b39aacec65635", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f16892b94817d144f37dfe0081b39aacec65635", "html_url": "https://github.com/rust-lang/rust/commit/9f16892b94817d144f37dfe0081b39aacec65635", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f16892b94817d144f37dfe0081b39aacec65635/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf98fc609e2b587d8455bf2bec3ca35f85cf0700", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf98fc609e2b587d8455bf2bec3ca35f85cf0700", "html_url": "https://github.com/rust-lang/rust/commit/bf98fc609e2b587d8455bf2bec3ca35f85cf0700"}], "stats": {"total": 142, "additions": 77, "deletions": 65}, "files": [{"sha": "d764c534aa62bea8e9f86d320cdb8317e010977a", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 77, "deletions": 65, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/9f16892b94817d144f37dfe0081b39aacec65635/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f16892b94817d144f37dfe0081b39aacec65635/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=9f16892b94817d144f37dfe0081b39aacec65635", "patch": "@@ -13,8 +13,6 @@ use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watc\n \n use crate::{RootConfig, Roots, VfsRoot};\n \n-type Result<T> = std::result::Result<T, crossbeam_channel::SendError<TaskResult>>;\n-\n pub(crate) enum Task {\n     AddRoot {\n         root: VfsRoot,\n@@ -62,7 +60,6 @@ impl Worker {\n     pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n         // This is a pretty elaborate setup of threads & channels! It is\n         // explained by the following concerns:\n-\n         //    * we need to burn a thread translating from notify's mpsc to\n         //      crossbeam_channel.\n         //    * we want to read all files from a single thread, to gurantee that\n@@ -79,48 +76,57 @@ impl Worker {\n                 let (notify_sender, notify_receiver) = mpsc::channel();\n                 // These are the corresponding crossbeam channels\n                 let (watcher_sender, watcher_receiver) = unbounded();\n-                let watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n+\n+                let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n                     .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n                     .ok();\n-                let mut ctx = WatcherCtx {\n-                    roots,\n-                    watcher,\n-                    sender: output_sender,\n-                };\n+                // Start a silly thread to tranform between two channels\n                 let thread = thread::spawn(move || {\n-                    let _ = notify_receiver\n+                    notify_receiver\n                         .into_iter()\n-                        // forward relevant events only\n-                        .for_each(|event| convert_notify_event(event, &watcher_sender));\n+                        .for_each(|event| convert_notify_event(event, &watcher_sender))\n                 });\n \n+                // Process requests from the called or notifications from\n+                // watcher until the caller says stop.\n                 loop {\n                     select! {\n                         // Received request from the caller. If this channel is\n                         // closed, we should shutdown everything.\n                         recv(input_receiver) -> t => match t {\n-                            Err(RecvError) => break,\n-                            Ok(Task::AddRoot { root, config }) => watch_root(&mut ctx, root, Arc::clone(&config)),\n+                            Err(RecvError) => {\n+                                drop(input_receiver);\n+                                break\n+                            },\n+                            Ok(Task::AddRoot { root, config }) => {\n+                                watch_root(watcher.as_mut(), &output_sender, root, Arc::clone(&config));\n+                            }\n                         },\n                         // Watcher send us changes. If **this** channel is\n                         // closed, the watcher has died, which indicates a bug\n                         // -- escalate!\n                         recv(watcher_receiver) -> event => match event {\n                             Err(RecvError) => panic!(\"watcher is dead\"),\n-                            Ok((path, change)) => WatcherCtx::handle_change(&mut ctx, path, change).unwrap(),\n+                            Ok((path, change)) => {\n+                                handle_change(watcher.as_mut(), &output_sender, &*roots, path, change);\n+                            }\n                         },\n                     }\n                 }\n-                drop(ctx.watcher.take());\n-                drop(ctx);\n-                let res2 = thread.join();\n-                match &res2 {\n+                // Stopped the watcher\n+                drop(watcher.take());\n+                // Drain pending events: we are not inrerested in them anyways!\n+                watcher_receiver.into_iter().for_each(|_| ());\n+\n+                let res = thread.join();\n+                match &res {\n                     Ok(()) => log::info!(\"... Watcher terminated with ok\"),\n                     Err(_) => log::error!(\"... Watcher terminated with err\"),\n                 }\n-                res2.unwrap();\n+                res.unwrap();\n             },\n         );\n+\n         Worker {\n             worker,\n             worker_handle,\n@@ -141,30 +147,29 @@ impl Worker {\n     }\n }\n \n-fn watch_root(woker: &mut WatcherCtx, root: VfsRoot, config: Arc<RootConfig>) {\n+fn watch_root(\n+    watcher: Option<&mut RecommendedWatcher>,\n+    sender: &Sender<TaskResult>,\n+    root: VfsRoot,\n+    config: Arc<RootConfig>,\n+) {\n     log::debug!(\"loading {} ...\", config.root.as_path().display());\n-    let files = watch_recursive(woker.watcher.as_mut(), config.root.as_path(), &*config)\n+    let files = watch_recursive(watcher, config.root.as_path(), &*config)\n         .into_iter()\n         .filter_map(|path| {\n             let abs_path = path.to_path(&config.root);\n             let text = read_to_string(&abs_path)?;\n             Some((path, text))\n         })\n         .collect();\n-    woker\n-        .sender\n+    sender\n         .send(TaskResult::BulkLoadRoot { root, files })\n         .unwrap();\n     log::debug!(\"... loaded {}\", config.root.as_path().display());\n }\n \n-struct WatcherCtx {\n-    roots: Arc<Roots>,\n-    watcher: Option<RecommendedWatcher>,\n-    sender: Sender<TaskResult>,\n-}\n-\n fn convert_notify_event(event: DebouncedEvent, sender: &Sender<(PathBuf, ChangeKind)>) {\n+    // forward relevant events only\n     match event {\n         DebouncedEvent::NoticeWrite(_)\n         | DebouncedEvent::NoticeRemove(_)\n@@ -194,48 +199,55 @@ fn convert_notify_event(event: DebouncedEvent, sender: &Sender<(PathBuf, ChangeK\n     }\n }\n \n-impl WatcherCtx {\n-    fn handle_change(&mut self, path: PathBuf, kind: ChangeKind) -> Result<()> {\n-        let (root, rel_path) = match self.roots.find(&path) {\n-            None => return Ok(()),\n-            Some(it) => it,\n-        };\n-        let config = &self.roots[root];\n-        match kind {\n-            ChangeKind::Create => {\n-                let mut paths = Vec::new();\n-                if path.is_dir() {\n-                    paths.extend(watch_recursive(self.watcher.as_mut(), &path, &config));\n-                } else {\n-                    paths.push(rel_path);\n-                }\n-                paths\n-                    .into_iter()\n-                    .filter_map(|rel_path| {\n-                        let abs_path = rel_path.to_path(&config.root);\n-                        let text = read_to_string(&abs_path)?;\n-                        Some((rel_path, text))\n-                    })\n-                    .try_for_each(|(path, text)| {\n-                        self.sender\n-                            .send(TaskResult::AddSingleFile { root, path, text })\n-                    })?\n+fn handle_change(\n+    watcher: Option<&mut RecommendedWatcher>,\n+    sender: &Sender<TaskResult>,\n+    roots: &Roots,\n+    path: PathBuf,\n+    kind: ChangeKind,\n+) {\n+    let (root, rel_path) = match roots.find(&path) {\n+        None => return,\n+        Some(it) => it,\n+    };\n+    let config = &roots[root];\n+    match kind {\n+        ChangeKind::Create => {\n+            let mut paths = Vec::new();\n+            if path.is_dir() {\n+                paths.extend(watch_recursive(watcher, &path, &config));\n+            } else {\n+                paths.push(rel_path);\n             }\n-            ChangeKind::Write => {\n-                if let Some(text) = read_to_string(&path) {\n-                    self.sender.send(TaskResult::ChangeSingleFile {\n+            paths\n+                .into_iter()\n+                .filter_map(|rel_path| {\n+                    let abs_path = rel_path.to_path(&config.root);\n+                    let text = read_to_string(&abs_path)?;\n+                    Some((rel_path, text))\n+                })\n+                .try_for_each(|(path, text)| {\n+                    sender.send(TaskResult::AddSingleFile { root, path, text })\n+                })\n+                .unwrap()\n+        }\n+        ChangeKind::Write => {\n+            if let Some(text) = read_to_string(&path) {\n+                sender\n+                    .send(TaskResult::ChangeSingleFile {\n                         root,\n                         path: rel_path,\n                         text,\n-                    })?;\n-                }\n+                    })\n+                    .unwrap();\n             }\n-            ChangeKind::Remove => self.sender.send(TaskResult::RemoveSingleFile {\n+        }\n+        ChangeKind::Remove => sender\n+            .send(TaskResult::RemoveSingleFile {\n                 root,\n                 path: rel_path,\n-            })?,\n-        }\n-        Ok(())\n+            })\n+            .unwrap(),\n     }\n }\n "}]}