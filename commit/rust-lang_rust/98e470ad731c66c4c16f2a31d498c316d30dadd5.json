{"sha": "98e470ad731c66c4c16f2a31d498c316d30dadd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZTQ3MGFkNzMxYzY2YzRjMTZmMmEzMWQ0OThjMzE2ZDMwZGFkZDU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-08-28T21:52:37Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-08-30T22:48:41Z"}, "message": "rustpkg: Allow package directories to appear in the RUST_PATH\n\nThis commit adds a rustpkg flag, --rust-path-hack, that allows\nrustpkg to *search* inside package directories if they appear in\nthe RUST_PATH, while *building* libraries and executables into a\ndifferent target directory.\n\nThis behavior is hidden behind a flag because I believe we only\nwant to support it temporarily, to make it easier to port servo to\nrustpkg.\n\nThis commit also includes a fix for how rustpkg fetches sources\nfrom git repositories -- it uses a temporary directory as the target\nwhen invoking `git clone`, then moves that directory into the workspace\nif the clone was successful. (The old behavior was that when the\n`git clone` failed, the empty target directory would be left lying\naround anyway.)", "tree": {"sha": "1c7ba6a99c82aaffc776f4ff34081efabb52a646", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c7ba6a99c82aaffc776f4ff34081efabb52a646"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98e470ad731c66c4c16f2a31d498c316d30dadd5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98e470ad731c66c4c16f2a31d498c316d30dadd5", "html_url": "https://github.com/rust-lang/rust/commit/98e470ad731c66c4c16f2a31d498c316d30dadd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98e470ad731c66c4c16f2a31d498c316d30dadd5/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cbdee1663d3d729f3dde3b295ef5574a5839127", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cbdee1663d3d729f3dde3b295ef5574a5839127", "html_url": "https://github.com/rust-lang/rust/commit/7cbdee1663d3d729f3dde3b295ef5574a5839127"}], "stats": {"total": 531, "additions": 428, "deletions": 103}, "files": [{"sha": "dfe80674b7fa114bcbb457851c652a0c4d1f0b6f", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=98e470ad731c66c4c16f2a31d498c316d30dadd5", "patch": "@@ -20,7 +20,12 @@ use std::hashmap::*;\n /// Convenience functions intended for calling from pkg.rs\n \n fn default_ctxt(p: @Path) -> Ctx {\n-    Ctx { sysroot_opt: Some(p), json: false, dep_cache: @mut HashMap::new() }\n+    Ctx {\n+        use_rust_path_hack: false,\n+        sysroot_opt: Some(p),\n+        json: false,\n+        dep_cache: @mut HashMap::new()\n+    }\n }\n \n pub fn build_lib(sysroot: @Path, root: Path, name: ~str, version: Version,"}, {"sha": "4087fdd7ca5048820a19a567e89416985a349002", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=98e470ad731c66c4c16f2a31d498c316d30dadd5", "patch": "@@ -15,6 +15,11 @@ use std::hashmap::HashMap;\n use std::os;\n \n pub struct Ctx {\n+    // If use_rust_path_hack is true, rustpkg searches for sources\n+    // in *package* directories that are in the RUST_PATH (for example,\n+    // FOO/src/bar-0.1 instead of FOO). The flag doesn't affect where\n+    // rustpkg stores build artifacts.\n+    use_rust_path_hack: bool,\n     // Sysroot -- if this is None, uses rustc filesearch's\n     // idea of the default\n     sysroot_opt: Option<@Path>,"}, {"sha": "ae2083f1b22c12a3f3abea19e775e6995fd34e23", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 80, "deletions": 22, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=98e470ad731c66c4c16f2a31d498c316d30dadd5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+extern mod extra;\n+\n use target::*;\n use package_id::PkgId;\n use std::path::Path;\n@@ -16,8 +18,9 @@ use context::*;\n use crate::Crate;\n use messages::*;\n use source_control::{git_clone, git_clone_general};\n-use path_util::pkgid_src_in_workspace;\n+use path_util::{pkgid_src_in_workspace, find_dir_using_rust_path_hack, default_workspace};\n use util::compile_crate;\n+use workspace::is_workspace;\n \n // An enumeration of the unpacked source of a package workspace.\n // This contains a list of files found in the source workspace.\n@@ -48,7 +51,7 @@ impl PkgSrc {\n     }\n \n \n-    fn check_dir(&self) -> Path {\n+    fn check_dir(&self, cx: &Ctx) -> Path {\n         use conditions::nonexistent_package::cond;\n \n         debug!(\"Pushing onto root: %s | %s\", self.id.path.to_str(), self.root.to_str());\n@@ -59,12 +62,21 @@ impl PkgSrc {\n \n         let dir = match path {\n             Some(d) => (*d).clone(),\n-            None => match self.fetch_git() {\n-                Some(d) => d,\n-                None => cond.raise((self.id.clone(), ~\"supplied path for package dir does not \\\n-                                      exist, and couldn't interpret it as a URL fragment\"))\n+            None => {\n+                match self.fetch_git() {\n+                    Some(d) => d,\n+                    None => {\n+                        match find_dir_using_rust_path_hack(cx, &self.id) {\n+                            Some(d) => d,\n+                            None => cond.raise((self.id.clone(),\n+                               ~\"supplied path for package dir does not \\\n+                                 exist, and couldn't interpret it as a URL fragment\"))\n+                        }\n+                    }\n+                }\n             }\n         };\n+        debug!(\"For package id %s, returning %s\", self.id.to_str(), dir.to_str());\n         if !os::path_is_dir(&dir) {\n             cond.raise((self.id.clone(), ~\"supplied path for package dir is a \\\n                                         non-directory\"));\n@@ -79,11 +91,19 @@ impl PkgSrc {\n     /// refers to a git repo on the local version, also check it out.\n     /// (right now we only support git)\n     pub fn fetch_git(&self) -> Option<Path> {\n+        use conditions::failed_to_create_temp_dir::cond;\n+\n+        // We use a temporary directory because if the git clone fails,\n+        // it creates the target directory anyway and doesn't delete it\n+\n+        let scratch_dir = extra::tempfile::mkdtemp(&os::tmpdir(), \"rustpkg\");\n+        let clone_target = match scratch_dir {\n+            Some(d) => d.push(\"rustpkg_temp\"),\n+            None    => cond.raise(~\"Failed to create temporary directory for fetching git sources\")\n+        };\n \n         let mut local = self.root.push(\"src\");\n         local = local.push(self.id.to_str());\n-        // Git can't clone into a non-empty directory\n-        os::remove_dir_recursive(&local);\n \n         debug!(\"Checking whether %s exists locally. Cwd = %s, does it? %?\",\n                self.id.path.to_str(),\n@@ -93,15 +113,28 @@ impl PkgSrc {\n         if os::path_exists(&self.id.path) {\n             debug!(\"%s exists locally! Cloning it into %s\",\n                    self.id.path.to_str(), local.to_str());\n+            // Ok to use local here; we know it will succeed\n             git_clone(&self.id.path, &local, &self.id.version);\n             return Some(local);\n         }\n \n+        if (self.id.path.clone()).components().len() < 2 {\n+            // If a non-URL, don't bother trying to fetch\n+            return None;\n+        }\n+\n         let url = fmt!(\"https://%s\", self.id.path.to_str());\n         note(fmt!(\"Fetching package: git clone %s %s [version=%s]\",\n-                  url, local.to_str(), self.id.version.to_str()));\n-        if git_clone_general(url, &local, &self.id.version) {\n-            Some(local)\n+                  url, clone_target.to_str(), self.id.version.to_str()));\n+\n+        if git_clone_general(url, &clone_target, &self.id.version) {\n+            // since the operation succeeded, move clone_target to local\n+            if !os::rename_file(&clone_target, &local) {\n+                 None\n+            }\n+            else {\n+                 Some(local)\n+            }\n         }\n         else {\n             None\n@@ -138,10 +171,10 @@ impl PkgSrc {\n \n     /// Infers crates to build. Called only in the case where there\n     /// is no custom build logic\n-    pub fn find_crates(&mut self) {\n+    pub fn find_crates(&mut self, cx: &Ctx) {\n         use conditions::missing_pkg_files::cond;\n \n-        let dir = self.check_dir();\n+        let dir = self.check_dir(cx);\n         debug!(\"Called check_dir, I'm in %s\", dir.to_str());\n         let prefix = dir.components.len();\n         debug!(\"Matching against %?\", self.id.short_name);\n@@ -183,6 +216,7 @@ impl PkgSrc {\n     fn build_crates(&self,\n                     ctx: &Ctx,\n                     src_dir: &Path,\n+                    destination_dir: &Path,\n                     crates: &[Crate],\n                     cfgs: &[~str],\n                     what: OutputType) {\n@@ -194,8 +228,8 @@ impl PkgSrc {\n             let result = compile_crate(ctx,\n                                        &self.id,\n                                        path,\n-                                       // compile_crate wants the workspace\n-                                       &self.root,\n+                                       // compile_crate wants the destination workspace\n+                                       destination_dir,\n                                        crate.flags,\n                                        crate.cfgs + cfgs,\n                                        false,\n@@ -209,15 +243,39 @@ impl PkgSrc {\n         }\n     }\n \n-    pub fn build(&self, ctx: &Ctx, cfgs: ~[~str]) {\n-        let dir = self.check_dir();\n-        debug!(\"Building libs in %s\", dir.to_str());\n-        self.build_crates(ctx, &dir, self.libs, cfgs, Lib);\n+    pub fn build(&self, ctx: &Ctx, cfgs: ~[~str]) -> Path {\n+        use conditions::not_a_workspace::cond;\n+\n+        // Determine the destination workspace (which depends on whether\n+        // we're using the rust_path_hack)\n+        let destination_workspace = if is_workspace(&self.root) {\n+            debug!(\"%s is indeed a workspace\", self.root.to_str());\n+            self.root.clone()\n+        }\n+        else {\n+            // It would be nice to have only one place in the code that checks\n+            // for the use_rust_path_hack flag...\n+            if ctx.use_rust_path_hack {\n+                let rs = default_workspace();\n+                debug!(\"Using hack: %s\", rs.to_str());\n+                rs\n+            }\n+            else {\n+                cond.raise(fmt!(\"Package root %s is not a workspace; pass in --rust_path_hack \\\n+                                if you want to treat it as a package source\", self.root.to_str()))\n+            }\n+        };\n+\n+        let dir = self.check_dir(ctx);\n+        debug!(\"Building libs in %s, destination = %s\", dir.to_str(),\n+            destination_workspace.to_str());\n+        self.build_crates(ctx, &dir, &destination_workspace, self.libs, cfgs, Lib);\n         debug!(\"Building mains\");\n-        self.build_crates(ctx, &dir, self.mains, cfgs, Main);\n+        self.build_crates(ctx, &dir, &destination_workspace, self.mains, cfgs, Main);\n         debug!(\"Building tests\");\n-        self.build_crates(ctx, &dir, self.tests, cfgs, Test);\n+        self.build_crates(ctx, &dir, &destination_workspace, self.tests, cfgs, Test);\n         debug!(\"Building benches\");\n-        self.build_crates(ctx, &dir, self.benchs, cfgs, Bench);\n+        self.build_crates(ctx, &dir, &destination_workspace, self.benchs, cfgs, Bench);\n+        destination_workspace\n     }\n }"}, {"sha": "af70a79f93d2be91ffdba46e606c0373175b16c4", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=98e470ad731c66c4c16f2a31d498c316d30dadd5", "patch": "@@ -14,6 +14,7 @@ pub use package_id::PkgId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n pub use version::{Version, NoVersion, split_version_general, try_parsing_version};\n pub use rustc::metadata::filesearch::rust_path;\n+use context::Ctx;\n \n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::os::mkdir_recursive;\n@@ -51,18 +52,23 @@ pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, U_RWX) }\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n     debug!(\"Checking in src dir of %s for %s\",\n            workspace.to_str(), pkgid.to_str());\n+    workspace_contains_package_id_(pkgid, workspace, |p| { p.push(\"src\") }).is_some()\n+}\n \n-    let src_dir = workspace.push(\"src\");\n+pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n+// Returns the directory it was actually found in\n+             workspace_to_src_dir: &fn(&Path) -> Path) -> Option<Path> {\n+    let src_dir = workspace_to_src_dir(workspace);\n \n-    let mut found = false;\n+    let mut found = None;\n     do os::walk_dir(&src_dir) |p| {\n         debug!(\"=> p = %s\", p.to_str());\n \n-        let was_found = os::path_is_dir(p) && {\n+        if os::path_is_dir(p) {\n             debug!(\"p = %s, path = %s [%s]\", p.to_str(), pkgid.path.to_str(),\n                    src_dir.push_rel(&pkgid.path).to_str());\n \n-            *p == src_dir.push_rel(&pkgid.path) || {\n+            if *p == src_dir.push_rel(&pkgid.path) || {\n                 let pf = p.filename();\n                 do pf.iter().any |pf| {\n                     let g = pf.to_str();\n@@ -76,16 +82,15 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n                         }\n                     }\n                 }\n+            } {\n+                found = Some(p.clone());\n             }\n-        };\n \n-        if was_found {\n-            found = true\n-        }\n+        };\n         true\n     };\n \n-    debug!(if found { fmt!(\"Found %s in %s\", pkgid.to_str(), workspace.to_str()) }\n+    debug!(if found.is_some() { fmt!(\"Found %s in %s\", pkgid.to_str(), workspace.to_str()) }\n            else     { fmt!(\"Didn't find %s in %s\", pkgid.to_str(), workspace.to_str()) });\n     found\n }\n@@ -123,8 +128,7 @@ pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<\n         Some(result)\n     }\n     else {\n-        // This is not an error, but it's worth logging it\n-        error!(fmt!(\"built_executable_in_workspace: %s does not exist\", result.to_str()));\n+        debug!(\"built_executable_in_workspace: %s does not exist\", result.to_str());\n         None\n     }\n }\n@@ -164,7 +168,7 @@ pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Pat\n \n /// Does the actual searching stuff\n pub fn installed_library_in_workspace(short_name: &str, workspace: &Path) -> Option<Path> {\n-    // NOTE: this could break once we're handling multiple versions better... want a test for it\n+    // This could break once we're handling multiple versions better -- I should add a test for it\n     library_in_workspace(&Path(short_name), short_name, Install, workspace, \"lib\", &NoVersion)\n }\n \n@@ -246,8 +250,8 @@ pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n     } // for\n \n     if result_filename.is_none() {\n-        warn(fmt!(\"library_in_workspace didn't find a library in %s for %s\",\n-                  dir_to_search.to_str(), short_name));\n+        debug!(\"warning: library_in_workspace didn't find a library in %s for %s\",\n+                  dir_to_search.to_str(), short_name);\n     }\n \n     // Return the filename that matches, which we now know exists\n@@ -392,3 +396,25 @@ pub fn uninstall_package_from(workspace: &Path, pkgid: &PkgId) {\n     }\n \n }\n+\n+fn dir_has_file(dir: &Path, file: &str) -> bool {\n+    assert!(dir.is_absolute());\n+    os::path_exists(&dir.push(file))\n+}\n+\n+pub fn find_dir_using_rust_path_hack(cx: &Ctx, p: &PkgId) -> Option<Path> {\n+    if !cx.use_rust_path_hack {\n+        return None;\n+    }\n+    let rp = rust_path();\n+    for dir in rp.iter() {\n+        debug!(\"In find_dir_using_rust_path_hack: checking dir %s\", dir.to_str());\n+        if dir_has_file(dir, \"lib.rs\") || dir_has_file(dir, \"main.rs\")\n+            || dir_has_file(dir, \"test.rs\") || dir_has_file(dir, \"bench.rs\") {\n+            debug!(\"Did find id %s in dir %s\", p.to_str(), dir.to_str());\n+            return Some(dir.clone());\n+        }\n+        debug!(\"Didn't find id %s in dir %s\", p.to_str(), dir.to_str())\n+    }\n+    None\n+}"}, {"sha": "6a6e7569a6518577a4206a8fdde11e23dcccbddd", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 77, "deletions": 44, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=98e470ad731c66c4c16f2a31d498c316d30dadd5", "patch": "@@ -22,12 +22,7 @@ extern mod extra;\n extern mod rustc;\n extern mod syntax;\n \n-use std::result;\n-use std::io;\n-use std::os;\n-use std::run;\n-use std::str;\n-\n+use std::{io, os, result, run, str};\n pub use std::path::Path;\n use std::hashmap::HashMap;\n \n@@ -173,7 +168,8 @@ impl<'self> PkgScript<'self> {\n pub trait CtxMethods {\n     fn run(&self, cmd: &str, args: ~[~str]);\n     fn do_cmd(&self, _cmd: &str, _pkgname: &str);\n-    fn build(&self, workspace: &Path, pkgid: &PkgId);\n+    /// Returns the destination workspace\n+    fn build(&self, workspace: &Path, pkgid: &PkgId) -> Path;\n     fn clean(&self, workspace: &Path, id: &PkgId);\n     fn info(&self);\n     fn install(&self, workspace: &Path, id: &PkgId);\n@@ -191,15 +187,19 @@ impl CtxMethods for Ctx {\n             \"build\" => {\n                 if args.len() < 1 {\n                     match cwd_to_workspace() {\n-                        None => { usage::build(); return }\n-                        Some((ws, pkgid)) => self.build(&ws, &pkgid)\n+                        None if self.use_rust_path_hack => {\n+                            let cwd = os::getcwd();\n+                            self.build(&cwd, &PkgId::new(cwd.components[cwd.components.len() - 1]));\n+                        }\n+                        None => { usage::build(); return; }\n+                        Some((ws, pkgid)) => { self.build(&ws, &pkgid); }\n                     }\n                 }\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n                     let pkgid = PkgId::new(args[0].clone());\n-                    do each_pkg_parent_workspace(&pkgid) |workspace| {\n+                    do each_pkg_parent_workspace(self, &pkgid) |workspace| {\n                         debug!(\"found pkg %s in workspace %s, trying to build\",\n                                pkgid.to_str(), workspace.to_str());\n                         self.build(workspace, &pkgid);\n@@ -238,15 +238,20 @@ impl CtxMethods for Ctx {\n             \"install\" => {\n                 if args.len() < 1 {\n                     match cwd_to_workspace() {\n-                        None => { usage::install(); return }\n-                        Some((ws, pkgid)) => self.install(&ws, &pkgid)\n-                    }\n+                        None if self.use_rust_path_hack => {\n+                            let cwd = os::getcwd();\n+                            self.install(&cwd,\n+                                &PkgId::new(cwd.components[cwd.components.len() - 1]));\n+                        }\n+                        None  => { usage::install(); return; }\n+                        Some((ws, pkgid))                => self.install(&ws, &pkgid),\n+                     }\n                 }\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n                     let pkgid = PkgId::new(args[0]);\n-                    let workspaces = pkg_parent_workspaces(&pkgid);\n+                    let workspaces = pkg_parent_workspaces(self, &pkgid);\n                     debug!(\"package ID = %s, found it in %? workspaces\",\n                            pkgid.to_str(), workspaces.len());\n                     if workspaces.is_empty() {\n@@ -257,7 +262,7 @@ impl CtxMethods for Ctx {\n                         self.install(&rp[0], &pkgid);\n                     }\n                     else {\n-                        do each_pkg_parent_workspace(&pkgid) |workspace| {\n+                        do each_pkg_parent_workspace(self, &pkgid) |workspace| {\n                             self.install(workspace, &pkgid);\n                             true\n                         };\n@@ -294,7 +299,7 @@ impl CtxMethods for Ctx {\n                 else {\n                     let rp = rust_path();\n                     assert!(!rp.is_empty());\n-                    do each_pkg_parent_workspace(&pkgid) |workspace| {\n+                    do each_pkg_parent_workspace(self, &pkgid) |workspace| {\n                         path_util::uninstall_package_from(workspace, &pkgid);\n                         note(fmt!(\"Uninstalled package %s (was installed in %s)\",\n                                   pkgid.to_str(), workspace.to_str()));\n@@ -318,7 +323,9 @@ impl CtxMethods for Ctx {\n         fail!(\"`do` not yet implemented\");\n     }\n \n-    fn build(&self, workspace: &Path, pkgid: &PkgId) {\n+    /// Returns the destination workspace\n+    /// In the case of a custom build, we don't know, so we just return the source workspace\n+    fn build(&self, workspace: &Path, pkgid: &PkgId) -> Path {\n         debug!(\"build: workspace = %s (in Rust path? %? is git dir? %? \\\n                 pkgid = %s\", workspace.to_str(),\n                in_rust_path(workspace), is_git_dir(&workspace.push_rel(&pkgid.path)),\n@@ -374,9 +381,13 @@ impl CtxMethods for Ctx {\n         // the build already. Otherwise...\n         if !custom {\n             // Find crates inside the workspace\n-            src.find_crates();\n+            src.find_crates(self);\n             // Build it!\n-            src.build(self, cfgs);\n+            src.build(self, cfgs)\n+        }\n+        else {\n+            // Just return the source workspace\n+            workspace.clone()\n         }\n     }\n \n@@ -402,12 +413,15 @@ impl CtxMethods for Ctx {\n     }\n \n     fn install(&self, workspace: &Path, id: &PkgId)  {\n-        // FIXME #7402: Use RUST_PATH to determine target dir\n         // Also should use workcache to not build if not necessary.\n-        self.build(workspace, id);\n-        debug!(\"install: workspace = %s, id = %s\", workspace.to_str(),\n-               id.to_str());\n-        self.install_no_build(workspace, id);\n+        let destination_workspace = self.build(workspace, id);\n+        // See #7402: This still isn't quite right yet; we want to\n+        // install to the first workspace in the RUST_PATH if there's\n+        // a non-default RUST_PATH. This code installs to the same\n+        // workspace the package was built in.\n+        debug!(\"install: destination workspace = %s, id = %s\",\n+               destination_workspace.to_str(), id.to_str());\n+        self.install_no_build(&destination_workspace, id);\n \n     }\n \n@@ -473,7 +487,8 @@ pub fn main_args(args: &[~str]) {\n     let opts = ~[getopts::optflag(\"h\"), getopts::optflag(\"help\"),\n                  getopts::optflag(\"j\"), getopts::optflag(\"json\"),\n                  getopts::optmulti(\"c\"), getopts::optmulti(\"cfg\"),\n-                 getopts::optflag(\"v\"), getopts::optflag(\"version\")];\n+                 getopts::optflag(\"v\"), getopts::optflag(\"version\"),\n+                 getopts::optflag(\"r\"), getopts::optflag(\"rust-path-hack\")];\n     let matches = &match getopts::getopts(args, opts) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n@@ -493,6 +508,9 @@ pub fn main_args(args: &[~str]) {\n         return;\n     }\n \n+    let use_rust_path_hack = getopts::opt_present(matches, \"r\") ||\n+                             getopts::opt_present(matches, \"rust-path-hack\");\n+\n     let mut args = matches.free.clone();\n \n     args.shift();\n@@ -501,33 +519,48 @@ pub fn main_args(args: &[~str]) {\n         return usage::general();\n     }\n \n-    let cmd = args.shift();\n-\n-    if !util::is_cmd(cmd) {\n-        return usage::general();\n-    } else if help {\n-        return match cmd {\n-            ~\"build\" => usage::build(),\n-            ~\"clean\" => usage::clean(),\n-            ~\"do\" => usage::do_cmd(),\n-            ~\"info\" => usage::info(),\n-            ~\"install\" => usage::install(),\n-            ~\"list\"    => usage::list(),\n-            ~\"prefer\" => usage::prefer(),\n-            ~\"test\" => usage::test(),\n-            ~\"uninstall\" => usage::uninstall(),\n-            ~\"unprefer\" => usage::unprefer(),\n-            _ => usage::general()\n-        };\n+    let mut cmd_opt = None;\n+    for a in args.iter() {\n+        if util::is_cmd(*a) {\n+            cmd_opt = Some(a);\n+            break;\n+        }\n     }\n+    let cmd = match cmd_opt {\n+        None => return usage::general(),\n+        Some(cmd) => if help {\n+            return match *cmd {\n+                ~\"build\" => usage::build(),\n+                ~\"clean\" => usage::clean(),\n+                ~\"do\" => usage::do_cmd(),\n+                ~\"info\" => usage::info(),\n+                ~\"install\" => usage::install(),\n+                ~\"list\"    => usage::list(),\n+                ~\"prefer\" => usage::prefer(),\n+                ~\"test\" => usage::test(),\n+                ~\"uninstall\" => usage::uninstall(),\n+                ~\"unprefer\" => usage::unprefer(),\n+                _ => usage::general()\n+            };\n+        }\n+        else {\n+            cmd\n+        }\n+    };\n \n+    // Pop off all flags, plus the command\n+    let remaining_args = args.iter().skip_while(|s| !util::is_cmd(**s));\n+    // I had to add this type annotation to get the code to typecheck\n+    let mut remaining_args: ~[~str] = remaining_args.map(|s| (*s).clone()).collect();\n+    remaining_args.shift();\n     let sroot = Some(@filesearch::get_or_default_sysroot());\n     debug!(\"Using sysroot: %?\", sroot);\n     Ctx {\n+        use_rust_path_hack: use_rust_path_hack,\n         sysroot_opt: sroot, // Currently, only tests override this\n         json: json,\n         dep_cache: @mut HashMap::new()\n-    }.run(cmd, args);\n+    }.run(*cmd, remaining_args)\n }\n \n /**"}, {"sha": "4f8e80f56d5d7a1f89595f093d5c9e4b3d4ea6e1", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 195, "deletions": 16, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=98e470ad731c66c4c16f2a31d498c316d30dadd5", "patch": "@@ -34,6 +34,7 @@ fn datestamp(p: &Path) -> Option<libc::time_t> {\n \n fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n     Ctx {\n+        use_rust_path_hack: false,\n         sysroot_opt: sysroot_opt,\n         json: false,\n         dep_cache: @mut HashMap::new()\n@@ -70,8 +71,8 @@ fn writeFile(file_path: &Path, contents: &str) {\n     out.write_line(contents);\n }\n \n-fn mk_empty_workspace(short_name: &Path, version: &Version) -> Path {\n-    let workspace_dir = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n+fn mk_empty_workspace(short_name: &Path, version: &Version, tag: &str) -> Path {\n+    let workspace_dir = mkdtemp(&os::tmpdir(), tag).expect(\"couldn't create temp dir\");\n     mk_workspace(&workspace_dir, short_name, version);\n     workspace_dir\n }\n@@ -86,7 +87,7 @@ fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path\n \n fn mk_temp_workspace(short_name: &Path, version: &Version) -> Path {\n     let package_dir = mk_empty_workspace(short_name,\n-                                         version).push(\"src\").push(fmt!(\"%s-%s\",\n+                          version, \"temp_workspace\").push(\"src\").push(fmt!(\"%s-%s\",\n                                                             short_name.to_str(),\n                                                             version.to_str()));\n \n@@ -304,29 +305,54 @@ fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n \n }\n \n-fn assert_lib_exists(repo: &Path, short_name: &str, _v: Version) { // ??? version?\n+fn assert_lib_exists(repo: &Path, short_name: &str, v: Version) {\n+    assert!(lib_exists(repo, short_name, v));\n+}\n+\n+fn lib_exists(repo: &Path, short_name: &str, _v: Version) -> bool { // ??? version?\n     debug!(\"assert_lib_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n     let lib = installed_library_in_workspace(short_name, repo);\n     debug!(\"assert_lib_exists: checking whether %? exists\", lib);\n-    assert!(lib.is_some());\n-    let libname = lib.get_ref();\n-    assert!(os::path_exists(libname));\n-    assert!(is_rwx(libname));\n+    lib.is_some() && {\n+        let libname = lib.get_ref();\n+        os::path_exists(libname) && is_rwx(libname)\n+    }\n }\n \n fn assert_executable_exists(repo: &Path, short_name: &str) {\n+    assert!(executable_exists(repo, short_name));\n+}\n+\n+fn executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"assert_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n     let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n-    assert!(os::path_exists(&exec));\n-    assert!(is_rwx(&exec));\n+    os::path_exists(&exec) && is_rwx(&exec)\n }\n \n fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n+    assert!(built_executable_exists(repo, short_name));\n+}\n+\n+fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"assert_built_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n-    let exec = built_executable_in_workspace(&PkgId::new(short_name),\n-                                             repo).expect(\"assert_built_executable_exists failed\");\n-    assert!(os::path_exists(&exec));\n-    assert!(is_rwx(&exec));\n+    let exec = built_executable_in_workspace(&PkgId::new(short_name), repo);\n+    exec.is_some() && {\n+       let execname = exec.get_ref();\n+       os::path_exists(execname) && is_rwx(execname)\n+    }\n+}\n+\n+fn assert_built_library_exists(repo: &Path, short_name: &str) {\n+    assert!(built_library_exists(repo, short_name));\n+}\n+\n+fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n+    debug!(\"assert_built_library_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    let lib = built_library_in_workspace(&PkgId::new(short_name), repo);\n+    lib.is_some() && {\n+        let libname = lib.get_ref();\n+        os::path_exists(libname) && is_rwx(libname)\n+    }\n }\n \n fn command_line_test_output(args: &[~str]) -> ~[~str] {\n@@ -452,23 +478,30 @@ fn test_install_valid() {\n fn test_install_invalid() {\n     use conditions::nonexistent_package::cond;\n     use cond1 = conditions::missing_pkg_files::cond;\n+    use cond2 = conditions::not_a_workspace::cond;\n \n     let ctxt = fake_ctxt(None);\n     let pkgid = fake_pkg();\n     let temp_workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n     let mut error_occurred = false;\n     let mut error1_occurred = false;\n+    let mut error2_occurred = false;\n     do cond1.trap(|_| {\n         error1_occurred = true;\n     }).inside {\n         do cond.trap(|_| {\n             error_occurred = true;\n             temp_workspace.clone()\n         }).inside {\n-            ctxt.install(&temp_workspace, &pkgid);\n+            do cond2.trap(|_| {\n+               error2_occurred = true;\n+               temp_workspace.clone()\n+            }).inside {\n+                 ctxt.install(&temp_workspace, &pkgid);\n+            }\n         }\n     }\n-    assert!(error_occurred && error1_occurred);\n+    assert!(error_occurred && error1_occurred && error2_occurred);\n }\n \n // Tests above should (maybe) be converted to shell out to rustpkg, too\n@@ -1087,6 +1120,152 @@ fn multiple_workspaces() {\n     command_line_test_with_env([~\"install\", ~\"bar\"], &c_loc, env);\n }\n \n+fn rust_path_hack_test(hack_flag: bool) {\n+/*\n+      Make a workspace containing a pkg foo [A]\n+      Make a second, empty workspace        [B]\n+      Set RUST_PATH to B:A\n+      rustpkg install foo\n+      make sure built files for foo are in B\n+      make sure nothing gets built into A or A/../build[lib,bin]\n+*/\n+   let p_id = PkgId::new(\"foo\");\n+   let workspace = create_local_package(&p_id);\n+   let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let rust_path = Some(~[(~\"RUST_PATH\",\n+       fmt!(\"%s:%s\", dest_workspace.to_str(), workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n+   debug!(\"declare -x RUST_PATH=%s:%s\",\n+       dest_workspace.to_str(), workspace.push_many([\"src\", \"foo-0.1\"]).to_str());\n+   command_line_test_with_env(~[~\"install\"] + if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } +\n+                               ~[~\"foo\"], &dest_workspace, rust_path);\n+   assert_lib_exists(&dest_workspace, \"foo\", NoVersion);\n+   assert_executable_exists(&dest_workspace, \"foo\");\n+   assert_built_library_exists(&dest_workspace, \"foo\");\n+   assert_built_executable_exists(&dest_workspace, \"foo\");\n+   assert!(!lib_exists(&workspace, \"foo\", NoVersion));\n+   assert!(!executable_exists(&workspace, \"foo\"));\n+   assert!(!built_library_exists(&workspace, \"foo\"));\n+   assert!(!built_executable_exists(&workspace, \"foo\"));\n+}\n+\n+#[test]\n+fn test_rust_path_can_contain_package_dirs_with_flag() {\n+/*\n+   Test that the temporary hack added for bootstrapping Servo builds\n+   works. That is: if you add $FOO/src/some_pkg to the RUST_PATH,\n+   it will find the sources in some_pkg, build them, and install them\n+   into the first entry in the RUST_PATH.\n+\n+   When the hack is removed, we should change this to a should_fail test.\n+*/\n+   rust_path_hack_test(true);\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_rust_path_can_contain_package_dirs_without_flag() {\n+   rust_path_hack_test(false);\n+}\n+\n+#[test]\n+fn rust_path_hack_cwd() {\n+   // Same as rust_path_hack_test, but the CWD is the dir to build out of\n+   let cwd = mkdtemp(&os::tmpdir(), \"pkg_files\").expect(\"rust_path_hack_cwd\");\n+   writeFile(&cwd.push(\"lib.rs\"), \"pub fn f() { }\");\n+\n+   let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n+   debug!(\"declare -x RUST_PATH=%s\", dest_workspace.to_str());\n+   command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n+   debug!(\"Checking that foo exists in %s\", dest_workspace.to_str());\n+   assert_lib_exists(&dest_workspace, \"foo\", NoVersion);\n+   assert_built_library_exists(&dest_workspace, \"foo\");\n+   assert!(!lib_exists(&cwd, \"foo\", NoVersion));\n+   assert!(!built_library_exists(&cwd, \"foo\"));\n+}\n+\n+#[test]\n+fn rust_path_hack_multi_path() {\n+   // Same as rust_path_hack_test, but with a more complex package ID\n+   let cwd = mkdtemp(&os::tmpdir(), \"pkg_files\").expect(\"rust_path_hack_cwd\");\n+   let subdir = cwd.push_many([~\"foo\", ~\"bar\", ~\"quux\"]);\n+   assert!(os::mkdir_recursive(&subdir, U_RWX));\n+   writeFile(&subdir.push(\"lib.rs\"), \"pub fn f() { }\");\n+   let name = ~\"foo/bar/quux\";\n+\n+   let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n+   debug!(\"declare -x RUST_PATH=%s\", dest_workspace.to_str());\n+   command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n+   debug!(\"Checking that %s exists in %s\", name, dest_workspace.to_str());\n+   assert_lib_exists(&dest_workspace, \"quux\", NoVersion);\n+   assert_built_library_exists(&dest_workspace, name);\n+   assert!(!lib_exists(&subdir, \"quux\", NoVersion));\n+   assert!(!built_library_exists(&subdir, name));\n+}\n+\n+#[test]\n+fn rust_path_hack_install_no_arg() {\n+   // Same as rust_path_hack_cwd, but making rustpkg infer the pkg id\n+   let cwd = mkdtemp(&os::tmpdir(), \"pkg_files\").expect(\"rust_path_hack_install_no_arg\");\n+   let source_dir = cwd.push(\"foo\");\n+   assert!(make_dir_rwx(&source_dir));\n+   writeFile(&source_dir.push(\"lib.rs\"), \"pub fn f() { }\");\n+\n+   let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n+   debug!(\"declare -x RUST_PATH=%s\", dest_workspace.to_str());\n+   command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n+   debug!(\"Checking that foo exists in %s\", dest_workspace.to_str());\n+   assert_lib_exists(&dest_workspace, \"foo\", NoVersion);\n+   assert_built_library_exists(&dest_workspace, \"foo\");\n+   assert!(!lib_exists(&source_dir, \"foo\", NoVersion));\n+   assert!(!built_library_exists(&cwd, \"foo\"));\n+}\n+\n+#[test]\n+fn rust_path_hack_build_no_arg() {\n+   // Same as rust_path_hack_install_no_arg, but building instead of installing\n+   let cwd = mkdtemp(&os::tmpdir(), \"pkg_files\").expect(\"rust_path_hack_build_no_arg\");\n+   let source_dir = cwd.push(\"foo\");\n+   assert!(make_dir_rwx(&source_dir));\n+   writeFile(&source_dir.push(\"lib.rs\"), \"pub fn f() { }\");\n+\n+   let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n+   debug!(\"declare -x RUST_PATH=%s\", dest_workspace.to_str());\n+   command_line_test_with_env([~\"build\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n+   debug!(\"Checking that foo exists in %s\", dest_workspace.to_str());\n+   assert_built_library_exists(&dest_workspace, \"foo\");\n+   assert!(!built_library_exists(&source_dir, \"foo\"));\n+}\n+\n+#[test]\n+#[ignore (reason = \"#7402 not yet implemented\")]\n+fn rust_path_install_target() {\n+    let dir_for_path = mkdtemp(&os::tmpdir(),\n+        \"source_workspace\").expect(\"rust_path_install_target failed\");\n+    let dir = mk_workspace(&dir_for_path, &Path(\"foo\"), &NoVersion);\n+    debug!(\"dir = %s\", dir.to_str());\n+    writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n+    let dir_to_install_to = mkdtemp(&os::tmpdir(),\n+        \"dest_workspace\").expect(\"rust_path_install_target failed\");\n+    let dir = dir.pop().pop();\n+\n+    let rust_path = Some(~[(~\"RUST_PATH\", fmt!(\"%s:%s\", dir_to_install_to.to_str(),\n+                                               dir.to_str()))]);\n+    let cwd = os::getcwd();\n+\n+    debug!(\"RUST_PATH=%s:%s\", dir_to_install_to.to_str(), dir.to_str());\n+    command_line_test_with_env([~\"install\", ~\"foo\"],\n+                               &cwd,\n+                               rust_path);\n+\n+    assert_executable_exists(&dir_to_install_to, \"foo\");\n+\n+}\n+\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};"}, {"sha": "958786b7cf4e20a4039e0528828f341ecf25ef9b", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=98e470ad731c66c4c16f2a31d498c316d30dadd5", "patch": "@@ -452,6 +452,13 @@ mod test {\n \n }\n \n+pub fn option_to_vec<T>(x: Option<T>) -> ~[T] {\n+    match x {\n+       Some(y) => ~[y],\n+       None    => ~[]\n+    }\n+}\n+\n // tjc: cheesy\n fn debug_flags() -> ~[~str] { ~[] }\n // static DEBUG_FLAGS: ~[~str] = ~[~\"-Z\", ~\"time-passes\"];"}, {"sha": "5ad2dfd6d2f4987157b9fa8202d0dbcdac36878a", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e470ad731c66c4c16f2a31d498c316d30dadd5/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=98e470ad731c66c4c16f2a31d498c316d30dadd5", "patch": "@@ -12,15 +12,17 @@\n \n use std::{os,util};\n use std::path::Path;\n-use path_util::workspace_contains_package_id;\n+use context::Ctx;\n+use path_util::{workspace_contains_package_id, find_dir_using_rust_path_hack};\n+use util::option_to_vec;\n use package_id::PkgId;\n \n use path_util::rust_path;\n \n-pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n+pub fn each_pkg_parent_workspace(cx: &Ctx, pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n-    let workspaces = pkg_parent_workspaces(pkgid);\n+    let workspaces = pkg_parent_workspaces(cx, pkgid);\n     if workspaces.is_empty() {\n         // tjc: make this a condition\n         fail!(\"Package %s not found in any of \\\n@@ -36,10 +38,20 @@ pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> b\n     return true;\n }\n \n-pub fn pkg_parent_workspaces(pkgid: &PkgId) -> ~[Path] {\n-    rust_path().move_iter()\n+pub fn pkg_parent_workspaces(cx: &Ctx, pkgid: &PkgId) -> ~[Path] {\n+    let rs: ~[Path] = rust_path().move_iter()\n         .filter(|ws| workspace_contains_package_id(pkgid, ws))\n-        .collect()\n+        .collect();\n+    if cx.use_rust_path_hack {\n+        rs + option_to_vec(find_dir_using_rust_path_hack(cx, pkgid))\n+    }\n+    else {\n+        rs\n+    }\n+}\n+\n+pub fn is_workspace(p: &Path) -> bool {\n+    os::path_is_dir(&p.push(\"src\"))\n }\n \n /// Construct a workspace and package-ID name based on the current directory."}]}