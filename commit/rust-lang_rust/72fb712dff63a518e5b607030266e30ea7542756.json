{"sha": "72fb712dff63a518e5b607030266e30ea7542756", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyZmI3MTJkZmY2M2E1MThlNWI2MDcwMzAyNjZlMzBlYTc1NDI3NTY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T21:44:58Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T22:27:57Z"}, "message": "Add new module for project loading stuff", "tree": {"sha": "151e9acae2c8c3e409adbdc987edf04869a3c7ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/151e9acae2c8c3e409adbdc987edf04869a3c7ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72fb712dff63a518e5b607030266e30ea7542756", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72fb712dff63a518e5b607030266e30ea7542756", "html_url": "https://github.com/rust-lang/rust/commit/72fb712dff63a518e5b607030266e30ea7542756", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72fb712dff63a518e5b607030266e30ea7542756/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d0f78213879be78064d70a54411e40a6392a224", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0f78213879be78064d70a54411e40a6392a224", "html_url": "https://github.com/rust-lang/rust/commit/3d0f78213879be78064d70a54411e40a6392a224"}], "stats": {"total": 498, "additions": 260, "deletions": 238}, "files": [{"sha": "b1250f2fe0ab23887346301e1cc4e6ac17b6f93b", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72fb712dff63a518e5b607030266e30ea7542756/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fb712dff63a518e5b607030266e30ea7542756/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=72fb712dff63a518e5b607030266e30ea7542756", "patch": "@@ -9,7 +9,7 @@ use ra_ide::{AnalysisChange, AnalysisHost};\n use ra_project_model::{CargoConfig, ProcMacroClient, ProjectManifest, ProjectWorkspace};\n use vfs::{loader::Handle, AbsPath};\n \n-use crate::global_state::{ProjectFolders, SourceRootConfig};\n+use crate::reload::{ProjectFolders, SourceRootConfig};\n \n pub fn load_cargo(\n     root: &Path,"}, {"sha": "6b17ce18ba05ab01719a1cc20674f880d6ee50d6", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72fb712dff63a518e5b607030266e30ea7542756/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fb712dff63a518e5b607030266e30ea7542756/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=72fb712dff63a518e5b607030266e30ea7542756", "patch": "@@ -30,7 +30,7 @@ pub struct Config {\n \n     pub cargo: CargoConfig,\n     pub rustfmt: RustfmtConfig,\n-    pub check: Option<FlycheckConfig>,\n+    pub flycheck: Option<FlycheckConfig>,\n \n     pub inlay_hints: InlayHintsConfig,\n     pub completion: CompletionConfig,\n@@ -147,7 +147,7 @@ impl Config {\n \n             cargo: CargoConfig::default(),\n             rustfmt: RustfmtConfig::Rustfmt { extra_args: Vec::new() },\n-            check: Some(FlycheckConfig::CargoCommand {\n+            flycheck: Some(FlycheckConfig::CargoCommand {\n                 command: \"check\".to_string(),\n                 all_targets: true,\n                 all_features: false,\n@@ -227,22 +227,22 @@ impl Config {\n \n         if let Some(false) = get(value, \"/checkOnSave/enable\") {\n             // check is disabled\n-            self.check = None;\n+            self.flycheck = None;\n         } else {\n             // check is enabled\n             match get::<Vec<String>>(value, \"/checkOnSave/overrideCommand\") {\n                 // first see if the user has completely overridden the command\n                 Some(mut args) if !args.is_empty() => {\n                     let command = args.remove(0);\n-                    self.check = Some(FlycheckConfig::CustomCommand {\n+                    self.flycheck = Some(FlycheckConfig::CustomCommand {\n                         command,\n                         args,\n                     });\n                 }\n                 // otherwise configure command customizations\n                 _ => {\n                     if let Some(FlycheckConfig::CargoCommand { command, extra_args, all_targets, all_features, features })\n-                        = &mut self.check\n+                        = &mut self.flycheck\n                     {\n                         set(value, \"/checkOnSave/extraArgs\", extra_args);\n                         set(value, \"/checkOnSave/command\", command);"}, {"sha": "8486da627ca11542b14a8fbedc0b19f717f092a0", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 12, "deletions": 232, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/72fb712dff63a518e5b607030266e30ea7542756/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fb712dff63a518e5b607030266e30ea7542756/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=72fb712dff63a518e5b607030266e30ea7542756", "patch": "@@ -3,24 +3,25 @@\n //!\n //! Each tick provides an immutable snapshot of the state as `WorldSnapshot`.\n \n-use std::{convert::TryFrom, sync::Arc};\n+use std::sync::Arc;\n \n use crossbeam_channel::{unbounded, Receiver, Sender};\n-use flycheck::{FlycheckConfig, FlycheckHandle};\n-use lsp_types::{request::Request, Url};\n+use flycheck::FlycheckHandle;\n+use lsp_types::Url;\n use parking_lot::RwLock;\n-use ra_db::{CrateId, SourceRoot, VfsPath};\n-use ra_ide::{Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId};\n-use ra_project_model::{CargoWorkspace, PackageRoot, ProcMacroClient, ProjectWorkspace, Target};\n+use ra_db::{CrateId, VfsPath};\n+use ra_ide::{Analysis, AnalysisChange, AnalysisHost, FileId};\n+use ra_project_model::{CargoWorkspace, ProcMacroClient, ProjectWorkspace, Target};\n use stdx::format_to;\n-use vfs::{file_set::FileSetConfig, loader::Handle, AbsPath, AbsPathBuf};\n+use vfs::loader::Handle;\n \n use crate::{\n-    config::{Config, FilesWatcher, LinkedProject},\n+    config::Config,\n     diagnostics::{CheckFixes, DiagnosticCollection},\n     from_proto,\n     line_endings::LineEndings,\n     main_loop::{ReqQueue, Task},\n+    reload::SourceRootConfig,\n     request_metrics::{LatestRequests, RequestMetrics},\n     show_message,\n     thread_pool::TaskPool,\n@@ -29,26 +30,6 @@ use crate::{\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-fn create_flycheck(\n-    workspaces: &[ProjectWorkspace],\n-    config: &FlycheckConfig,\n-) -> Option<(FlycheckHandle, Receiver<flycheck::Message>)> {\n-    // FIXME: Figure out the multi-workspace situation\n-    workspaces.iter().find_map(move |w| match w {\n-        ProjectWorkspace::Cargo { cargo, .. } => {\n-            let (sender, receiver) = unbounded();\n-            let sender = Box::new(move |msg| sender.send(msg).unwrap());\n-            let cargo_project_root = cargo.workspace_root().to_path_buf();\n-            let flycheck = FlycheckHandle::spawn(sender, config.clone(), cargo_project_root.into());\n-            Some((flycheck, receiver))\n-        }\n-        ProjectWorkspace::Json { .. } => {\n-            log::warn!(\"Cargo check watching only supported for cargo workspaces, disabling\");\n-            None\n-        }\n-    })\n-}\n-\n #[derive(Eq, PartialEq)]\n pub(crate) enum Status {\n     Loading,\n@@ -79,10 +60,10 @@ pub(crate) struct GlobalState {\n     pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n     pub(crate) status: Status,\n     pub(crate) req_queue: ReqQueue,\n+    pub(crate) source_root_config: SourceRootConfig,\n+    pub(crate) proc_macro_client: ProcMacroClient,\n+    pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n     latest_requests: Arc<RwLock<LatestRequests>>,\n-    source_root_config: SourceRootConfig,\n-    proc_macro_client: ProcMacroClient,\n-    workspaces: Arc<Vec<ProjectWorkspace>>,\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n@@ -135,132 +116,6 @@ impl GlobalState {\n         }\n     }\n \n-    pub(crate) fn reload(&mut self) {\n-        let workspaces = {\n-            if self.config.linked_projects.is_empty()\n-                && self.config.notifications.cargo_toml_not_found\n-            {\n-                self.show_message(\n-                    lsp_types::MessageType::Error,\n-                    \"rust-analyzer failed to discover workspace\".to_string(),\n-                );\n-            };\n-\n-            self.config\n-                .linked_projects\n-                .iter()\n-                .filter_map(|project| match project {\n-                    LinkedProject::ProjectManifest(manifest) => {\n-                        ra_project_model::ProjectWorkspace::load(\n-                            manifest.clone(),\n-                            &self.config.cargo,\n-                            self.config.with_sysroot,\n-                        )\n-                        .map_err(|err| {\n-                            log::error!(\"failed to load workspace: {:#}\", err);\n-                            self.show_message(\n-                                lsp_types::MessageType::Error,\n-                                format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n-                            );\n-                        })\n-                        .ok()\n-                    }\n-                    LinkedProject::InlineJsonProject(it) => {\n-                        Some(ra_project_model::ProjectWorkspace::Json { project: it.clone() })\n-                    }\n-                })\n-                .collect::<Vec<_>>()\n-        };\n-\n-        if let FilesWatcher::Client = self.config.files.watcher {\n-            let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n-                watchers: workspaces\n-                    .iter()\n-                    .flat_map(ProjectWorkspace::to_roots)\n-                    .filter(PackageRoot::is_member)\n-                    .map(|root| format!(\"{}/**/*.rs\", root.path().display()))\n-                    .map(|glob_pattern| lsp_types::FileSystemWatcher { glob_pattern, kind: None })\n-                    .collect(),\n-            };\n-            let registration = lsp_types::Registration {\n-                id: \"file-watcher\".to_string(),\n-                method: \"workspace/didChangeWatchedFiles\".to_string(),\n-                register_options: Some(serde_json::to_value(registration_options).unwrap()),\n-            };\n-            let params = lsp_types::RegistrationParams { registrations: vec![registration] };\n-            let request = self.req_queue.outgoing.register(\n-                lsp_types::request::RegisterCapability::METHOD.to_string(),\n-                params,\n-                |_, _| (),\n-            );\n-            self.send(request.into());\n-        }\n-\n-        let mut change = AnalysisChange::new();\n-\n-        let project_folders = ProjectFolders::new(&workspaces);\n-\n-        self.proc_macro_client = match &self.config.proc_macro_srv {\n-            None => ProcMacroClient::dummy(),\n-            Some((path, args)) => match ProcMacroClient::extern_process(path.into(), args) {\n-                Ok(it) => it,\n-                Err(err) => {\n-                    log::error!(\n-                        \"Failed to run ra_proc_macro_srv from path {}, error: {:?}\",\n-                        path.display(),\n-                        err\n-                    );\n-                    ProcMacroClient::dummy()\n-                }\n-            },\n-        };\n-        let watch = match self.config.files.watcher {\n-            FilesWatcher::Client => vec![],\n-            FilesWatcher::Notify => project_folders.watch,\n-        };\n-        self.loader.set_config(vfs::loader::Config { load: project_folders.load, watch });\n-\n-        // Create crate graph from all the workspaces\n-        let crate_graph = {\n-            let mut crate_graph = CrateGraph::default();\n-            let vfs = &mut self.vfs.write().0;\n-            let loader = &mut self.loader;\n-            let mut load = |path: &AbsPath| {\n-                let contents = loader.load_sync(path);\n-                let path = vfs::VfsPath::from(path.to_path_buf());\n-                vfs.set_file_contents(path.clone(), contents);\n-                vfs.file_id(&path)\n-            };\n-            for ws in workspaces.iter() {\n-                crate_graph.extend(ws.to_crate_graph(\n-                    self.config.cargo.target.as_deref(),\n-                    &self.proc_macro_client,\n-                    &mut load,\n-                ));\n-            }\n-\n-            crate_graph\n-        };\n-        change.set_crate_graph(crate_graph);\n-\n-        self.flycheck = self.config.check.as_ref().and_then(|c| create_flycheck(&workspaces, c));\n-        self.source_root_config = project_folders.source_root_config;\n-        self.workspaces = Arc::new(workspaces);\n-\n-        self.analysis_host.apply_change(change);\n-        self.process_changes();\n-    }\n-\n-    pub(crate) fn update_configuration(&mut self, config: Config) {\n-        self.analysis_host.update_lru_capacity(config.lru_capacity);\n-        if config.check != self.config.check {\n-            self.flycheck =\n-                config.check.as_ref().and_then(|it| create_flycheck(&self.workspaces, it));\n-        }\n-\n-        self.config = config;\n-    }\n-\n     pub(crate) fn process_changes(&mut self) -> bool {\n         let change = {\n             let mut change = AnalysisChange::new();\n@@ -408,78 +263,3 @@ pub(crate) fn file_id_to_url(vfs: &vfs::Vfs, id: FileId) -> Url {\n     let path = path.as_path().unwrap();\n     url_from_abs_path(&path)\n }\n-\n-#[derive(Default)]\n-pub(crate) struct ProjectFolders {\n-    pub(crate) load: Vec<vfs::loader::Entry>,\n-    pub(crate) watch: Vec<usize>,\n-    pub(crate) source_root_config: SourceRootConfig,\n-}\n-\n-impl ProjectFolders {\n-    pub(crate) fn new(workspaces: &[ProjectWorkspace]) -> ProjectFolders {\n-        let mut res = ProjectFolders::default();\n-        let mut fsc = FileSetConfig::builder();\n-        let mut local_filesets = vec![];\n-\n-        for root in workspaces.iter().flat_map(|it| it.to_roots()) {\n-            let path = root.path().to_owned();\n-\n-            let mut file_set_roots: Vec<VfsPath> = vec![];\n-\n-            let entry = if root.is_member() {\n-                vfs::loader::Entry::local_cargo_package(path.to_path_buf())\n-            } else {\n-                vfs::loader::Entry::cargo_package_dependency(path.to_path_buf())\n-            };\n-            res.load.push(entry);\n-            if root.is_member() {\n-                res.watch.push(res.load.len() - 1);\n-            }\n-\n-            if let Some(out_dir) = root.out_dir() {\n-                let out_dir = AbsPathBuf::try_from(out_dir.to_path_buf()).unwrap();\n-                res.load.push(vfs::loader::Entry::rs_files_recursively(out_dir.clone()));\n-                if root.is_member() {\n-                    res.watch.push(res.load.len() - 1);\n-                }\n-                file_set_roots.push(out_dir.into());\n-            }\n-            file_set_roots.push(path.to_path_buf().into());\n-\n-            if root.is_member() {\n-                local_filesets.push(fsc.len());\n-            }\n-            fsc.add_file_set(file_set_roots)\n-        }\n-\n-        let fsc = fsc.build();\n-        res.source_root_config = SourceRootConfig { fsc, local_filesets };\n-\n-        res\n-    }\n-}\n-\n-#[derive(Default, Debug)]\n-pub(crate) struct SourceRootConfig {\n-    pub(crate) fsc: FileSetConfig,\n-    pub(crate) local_filesets: Vec<usize>,\n-}\n-\n-impl SourceRootConfig {\n-    pub(crate) fn partition(&self, vfs: &vfs::Vfs) -> Vec<SourceRoot> {\n-        self.fsc\n-            .partition(vfs)\n-            .into_iter()\n-            .enumerate()\n-            .map(|(idx, file_set)| {\n-                let is_local = self.local_filesets.contains(&idx);\n-                if is_local {\n-                    SourceRoot::new_local(file_set)\n-                } else {\n-                    SourceRoot::new_library(file_set)\n-                }\n-            })\n-            .collect()\n-    }\n-}"}, {"sha": "a24dfe58c63bcc6bd128fc60affc73f333a54047", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72fb712dff63a518e5b607030266e30ea7542756/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fb712dff63a518e5b607030266e30ea7542756/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=72fb712dff63a518e5b607030266e30ea7542756", "patch": "@@ -18,6 +18,7 @@ macro_rules! eprintln {\n }\n \n mod global_state;\n+mod reload;\n mod main_loop;\n mod dispatch;\n mod handlers;"}, {"sha": "1981a97da2b3ad7cf7abcd71de7036b296c3d40f", "filename": "crates/rust-analyzer/src/reload.rs", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/72fb712dff63a518e5b607030266e30ea7542756/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fb712dff63a518e5b607030266e30ea7542756/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=72fb712dff63a518e5b607030266e30ea7542756", "patch": "@@ -0,0 +1,241 @@\n+//! Project loading & configuration updates\n+use std::sync::Arc;\n+\n+use crossbeam_channel::unbounded;\n+use flycheck::FlycheckHandle;\n+use lsp_types::request::Request;\n+use ra_db::{CrateGraph, SourceRoot, VfsPath};\n+use ra_ide::AnalysisChange;\n+use ra_project_model::{PackageRoot, ProcMacroClient, ProjectWorkspace};\n+use vfs::{file_set::FileSetConfig, AbsPath};\n+\n+use crate::{\n+    config::{Config, FilesWatcher, LinkedProject},\n+    global_state::GlobalState,\n+};\n+\n+impl GlobalState {\n+    pub(crate) fn update_configuration(&mut self, new_config: Config) {\n+        self.analysis_host.update_lru_capacity(new_config.lru_capacity);\n+        if new_config.flycheck != self.config.flycheck {\n+            self.reload_flycheck();\n+        }\n+        self.config = new_config;\n+    }\n+    pub(crate) fn reload(&mut self) {\n+        let workspaces = {\n+            if self.config.linked_projects.is_empty()\n+                && self.config.notifications.cargo_toml_not_found\n+            {\n+                self.show_message(\n+                    lsp_types::MessageType::Error,\n+                    \"rust-analyzer failed to discover workspace\".to_string(),\n+                );\n+            };\n+\n+            self.config\n+                .linked_projects\n+                .iter()\n+                .filter_map(|project| match project {\n+                    LinkedProject::ProjectManifest(manifest) => {\n+                        ra_project_model::ProjectWorkspace::load(\n+                            manifest.clone(),\n+                            &self.config.cargo,\n+                            self.config.with_sysroot,\n+                        )\n+                        .map_err(|err| {\n+                            log::error!(\"failed to load workspace: {:#}\", err);\n+                            self.show_message(\n+                                lsp_types::MessageType::Error,\n+                                format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n+                            );\n+                        })\n+                        .ok()\n+                    }\n+                    LinkedProject::InlineJsonProject(it) => {\n+                        Some(ra_project_model::ProjectWorkspace::Json { project: it.clone() })\n+                    }\n+                })\n+                .collect::<Vec<_>>()\n+        };\n+\n+        if let FilesWatcher::Client = self.config.files.watcher {\n+            let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n+                watchers: workspaces\n+                    .iter()\n+                    .flat_map(ProjectWorkspace::to_roots)\n+                    .filter(PackageRoot::is_member)\n+                    .map(|root| format!(\"{}/**/*.rs\", root.path().display()))\n+                    .map(|glob_pattern| lsp_types::FileSystemWatcher { glob_pattern, kind: None })\n+                    .collect(),\n+            };\n+            let registration = lsp_types::Registration {\n+                id: \"file-watcher\".to_string(),\n+                method: \"workspace/didChangeWatchedFiles\".to_string(),\n+                register_options: Some(serde_json::to_value(registration_options).unwrap()),\n+            };\n+            let params = lsp_types::RegistrationParams { registrations: vec![registration] };\n+            let request = self.req_queue.outgoing.register(\n+                lsp_types::request::RegisterCapability::METHOD.to_string(),\n+                params,\n+                |_, _| (),\n+            );\n+            self.send(request.into());\n+        }\n+\n+        let mut change = AnalysisChange::new();\n+\n+        let project_folders = ProjectFolders::new(&workspaces);\n+\n+        self.proc_macro_client = match &self.config.proc_macro_srv {\n+            None => ProcMacroClient::dummy(),\n+            Some((path, args)) => match ProcMacroClient::extern_process(path.into(), args) {\n+                Ok(it) => it,\n+                Err(err) => {\n+                    log::error!(\n+                        \"Failed to run ra_proc_macro_srv from path {}, error: {:?}\",\n+                        path.display(),\n+                        err\n+                    );\n+                    ProcMacroClient::dummy()\n+                }\n+            },\n+        };\n+        let watch = match self.config.files.watcher {\n+            FilesWatcher::Client => vec![],\n+            FilesWatcher::Notify => project_folders.watch,\n+        };\n+        self.loader.set_config(vfs::loader::Config { load: project_folders.load, watch });\n+\n+        // Create crate graph from all the workspaces\n+        let crate_graph = {\n+            let mut crate_graph = CrateGraph::default();\n+            let vfs = &mut self.vfs.write().0;\n+            let loader = &mut self.loader;\n+            let mut load = |path: &AbsPath| {\n+                let contents = loader.load_sync(path);\n+                let path = vfs::VfsPath::from(path.to_path_buf());\n+                vfs.set_file_contents(path.clone(), contents);\n+                vfs.file_id(&path)\n+            };\n+            for ws in workspaces.iter() {\n+                crate_graph.extend(ws.to_crate_graph(\n+                    self.config.cargo.target.as_deref(),\n+                    &self.proc_macro_client,\n+                    &mut load,\n+                ));\n+            }\n+\n+            crate_graph\n+        };\n+        change.set_crate_graph(crate_graph);\n+\n+        self.source_root_config = project_folders.source_root_config;\n+        self.workspaces = Arc::new(workspaces);\n+\n+        self.analysis_host.apply_change(change);\n+        self.process_changes();\n+        self.reload_flycheck();\n+    }\n+\n+    fn reload_flycheck(&mut self) {\n+        let config = match self.config.flycheck.clone() {\n+            Some(it) => it,\n+            None => {\n+                self.flycheck = None;\n+                return;\n+            }\n+        };\n+\n+        // FIXME: Figure out the multi-workspace situation\n+        self.flycheck = self.workspaces.iter().find_map(move |w| match w {\n+            ProjectWorkspace::Cargo { cargo, .. } => {\n+                let (sender, receiver) = unbounded();\n+                let sender = Box::new(move |msg| sender.send(msg).unwrap());\n+                let cargo_project_root = cargo.workspace_root().to_path_buf();\n+                let flycheck =\n+                    FlycheckHandle::spawn(sender, config.clone(), cargo_project_root.into());\n+                Some((flycheck, receiver))\n+            }\n+            ProjectWorkspace::Json { .. } => {\n+                log::warn!(\"Cargo check watching only supported for cargo workspaces, disabling\");\n+                None\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Default)]\n+pub(crate) struct ProjectFolders {\n+    pub(crate) load: Vec<vfs::loader::Entry>,\n+    pub(crate) watch: Vec<usize>,\n+    pub(crate) source_root_config: SourceRootConfig,\n+}\n+\n+impl ProjectFolders {\n+    pub(crate) fn new(workspaces: &[ProjectWorkspace]) -> ProjectFolders {\n+        let mut res = ProjectFolders::default();\n+        let mut fsc = FileSetConfig::builder();\n+        let mut local_filesets = vec![];\n+\n+        for root in workspaces.iter().flat_map(|it| it.to_roots()) {\n+            let path = root.path().to_owned();\n+\n+            let mut file_set_roots: Vec<VfsPath> = vec![];\n+\n+            let entry = if root.is_member() {\n+                vfs::loader::Entry::local_cargo_package(path.to_path_buf())\n+            } else {\n+                vfs::loader::Entry::cargo_package_dependency(path.to_path_buf())\n+            };\n+            res.load.push(entry);\n+            if root.is_member() {\n+                res.watch.push(res.load.len() - 1);\n+            }\n+\n+            if let Some(out_dir) = root.out_dir() {\n+                let out_dir = out_dir.to_path_buf();\n+                res.load.push(vfs::loader::Entry::rs_files_recursively(out_dir.clone()));\n+                if root.is_member() {\n+                    res.watch.push(res.load.len() - 1);\n+                }\n+                file_set_roots.push(out_dir.into());\n+            }\n+            file_set_roots.push(path.to_path_buf().into());\n+\n+            if root.is_member() {\n+                local_filesets.push(fsc.len());\n+            }\n+            fsc.add_file_set(file_set_roots)\n+        }\n+\n+        let fsc = fsc.build();\n+        res.source_root_config = SourceRootConfig { fsc, local_filesets };\n+\n+        res\n+    }\n+}\n+\n+#[derive(Default, Debug)]\n+pub(crate) struct SourceRootConfig {\n+    pub(crate) fsc: FileSetConfig,\n+    pub(crate) local_filesets: Vec<usize>,\n+}\n+\n+impl SourceRootConfig {\n+    pub(crate) fn partition(&self, vfs: &vfs::Vfs) -> Vec<SourceRoot> {\n+        self.fsc\n+            .partition(vfs)\n+            .into_iter()\n+            .enumerate()\n+            .map(|(idx, file_set)| {\n+                let is_local = self.local_filesets.contains(&idx);\n+                if is_local {\n+                    SourceRoot::new_local(file_set)\n+                } else {\n+                    SourceRoot::new_library(file_set)\n+                }\n+            })\n+            .collect()\n+    }\n+}"}]}