{"sha": "780adfffc39bcb9d32685bd36e2f6b6e6a178dee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MGFkZmZmYzM5YmNiOWQzMjY4NWJkMzZlMmY2YjZlNmExNzhkZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-27T04:01:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-27T04:01:42Z"}, "message": "auto merge of #12486 : MicahChalmer/rust/emacs-fixes-round-3, r=brson\n\nI've added details in the description of each comment as to what it does, which I won't redundantly repeat here in the PR.  They all relate to indentation in the emacs rust-mode.\r\n\r\nWhat I will note here is that this closes #8787.  It addresses the last remaining case (not in the original issue description but in a comment), of indenting `match` statements.  With the changes here, I believe every problem described in the issue description or comments of #8787 is addressed.", "tree": {"sha": "ecb87056ae5ea12b9fcc0ca925b188a4ee72b13c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecb87056ae5ea12b9fcc0ca925b188a4ee72b13c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/780adfffc39bcb9d32685bd36e2f6b6e6a178dee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/780adfffc39bcb9d32685bd36e2f6b6e6a178dee", "html_url": "https://github.com/rust-lang/rust/commit/780adfffc39bcb9d32685bd36e2f6b6e6a178dee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/780adfffc39bcb9d32685bd36e2f6b6e6a178dee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd02f908befa8f3bd57ef9100970ff783830db5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd02f908befa8f3bd57ef9100970ff783830db5f", "html_url": "https://github.com/rust-lang/rust/commit/fd02f908befa8f3bd57ef9100970ff783830db5f"}, {"sha": "04dc3e4985b635d21d2af9b1fd65ad0eb0884b74", "url": "https://api.github.com/repos/rust-lang/rust/commits/04dc3e4985b635d21d2af9b1fd65ad0eb0884b74", "html_url": "https://github.com/rust-lang/rust/commit/04dc3e4985b635d21d2af9b1fd65ad0eb0884b74"}], "stats": {"total": 286, "additions": 239, "deletions": 47}, "files": [{"sha": "63c1a077c8c3de951a9a80f1f4487fbf73373cb7", "filename": "src/etc/emacs/rust-mode-tests.el", "status": "modified", "additions": 168, "deletions": 1, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/780adfffc39bcb9d32685bd36e2f6b6e6a178dee/src%2Fetc%2Femacs%2Frust-mode-tests.el", "raw_url": "https://github.com/rust-lang/rust/raw/780adfffc39bcb9d32685bd36e2f6b6e6a178dee/src%2Fetc%2Femacs%2Frust-mode-tests.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode-tests.el?ref=780adfffc39bcb9d32685bd36e2f6b6e6a178dee", "patch": "@@ -425,6 +425,108 @@ fn foo()\n \"\n    ))\n \n+(ert-deftest indent-match ()\n+  (test-indent\n+   \"\n+fn foo() {\n+    match blah {\n+        Pattern => stuff(),\n+        _ => whatever\n+    }\n+}\n+\"\n+   ))\n+\n+(ert-deftest indent-match-multiline-pattern ()\n+  (test-indent\n+   \"\n+fn foo() {\n+    match blah {\n+        Pattern |\n+        Pattern2 => {\n+            hello()\n+        },\n+        _ => whatever\n+    }\n+}\n+\"\n+   ))\n+\n+(ert-deftest indent-indented-match ()\n+  (test-indent\n+   \"\n+fn foo() {\n+    let x = \n+        match blah {\n+            Pattern |\n+            Pattern2 => {\n+                hello()\n+            },\n+            _ => whatever\n+        };\n+    y();\n+}\n+\"\n+   ))\n+\n+(ert-deftest indent-curly-braces-within-parens ()\n+  (test-indent\n+   \"\n+fn foo() {\n+    let x = \n+        foo(bar(|x| {\n+            only_one_indent_here();\n+        }));\n+    y();\n+}\n+\"\n+   ))\n+\n+(ert-deftest indent-weirdly-indented-block ()\n+  (rust-test-manip-code\n+   \"\n+fn foo() {\n+ {\n+this_block_is_over_to_the_left_for_some_reason();\n+ }\n+\n+}\n+\"\n+   16\n+   #'indent-for-tab-command\n+   \"\n+fn foo() {\n+ {\n+     this_block_is_over_to_the_left_for_some_reason();\n+ }\n+\n+}\n+\"\n+   ))\n+\n+(ert-deftest indent-multi-line-attrib ()\n+  (test-indent\n+   \"\n+#[attrib(\n+    this,\n+    that,\n+    theotherthing)]\n+fn function_with_multiline_attribute() {}\n+\"\n+   ))\n+\n+\n+;; Make sure that in effort to cover match patterns we don't mistreat || or expressions\n+(ert-deftest indent-nonmatch-or-expression ()\n+  (test-indent\n+   \"\n+fn foo() {\n+    let x = foo() ||\n+        bar();\n+}\n+\"\n+   ))\n+\n (setq rust-test-motion-string\n       \"\n fn fn1(arg: int) -> bool {\n@@ -450,6 +552,26 @@ struct Foo {\n }\n \"\n       rust-test-region-string rust-test-motion-string\n+      rust-test-indent-motion-string\n+      \"\n+fn blank_line(arg:int) -> bool {\n+\n+}\n+\n+fn indenting_closing_brace() {\n+    if(true) {\n+}\n+}\n+\n+fn indenting_middle_of_line() {\n+    if(true) {\n+ push_me_out();\n+} else {\n+               pull_me_back_in();\n+}\n+}\n+\"\n+\n       ;; Symbol -> (line column)\n       rust-test-positions-alist '((start-of-fn1 (2 0))\n                                   (start-of-fn1-middle-of-line (2 15))\n@@ -464,7 +586,17 @@ struct Foo {\n                                   (middle-of-fn3 (16 4))\n                                   (middle-of-struct (21 10))\n                                   (before-start-of-struct (19 0))\n-                                  (after-end-of-struct (23 0))))\n+                                  (after-end-of-struct (23 0))\n+                                  (blank-line-indent-start (3 0))\n+                                  (blank-line-indent-target (3 4))\n+                                  (closing-brace-indent-start (8 1))\n+                                  (closing-brace-indent-target (8 5))\n+                                  (middle-push-indent-start (13 2))\n+                                  (middle-push-indent-target (13 9))\n+                                  (after-whitespace-indent-start (13 1))\n+                                  (after-whitespace-indent-target (13 8))\n+                                  (middle-pull-indent-start (15 19))\n+                                  (middle-pull-indent-target (15 12))))\n \n (defun rust-get-buffer-pos (pos-symbol)\n   \"Get buffer position from POS-SYMBOL.\n@@ -626,3 +758,38 @@ All positions are position symbols found in `rust-test-positions-alist'.\"\n    'middle-of-struct\n    'before-start-of-struct 'after-end-of-struct\n    #'mark-defun))\n+\n+(ert-deftest indent-line-blank-line-motion ()\n+  (rust-test-motion\n+   rust-test-indent-motion-string\n+   'blank-line-indent-start\n+   'blank-line-indent-target\n+   #'indent-for-tab-command))\n+\n+(ert-deftest indent-line-closing-brace-motion ()\n+  (rust-test-motion\n+   rust-test-indent-motion-string\n+   'closing-brace-indent-start\n+   'closing-brace-indent-target\n+   #'indent-for-tab-command))\n+\n+(ert-deftest indent-line-middle-push-motion ()\n+  (rust-test-motion\n+   rust-test-indent-motion-string\n+   'middle-push-indent-start\n+   'middle-push-indent-target\n+   #'indent-for-tab-command))\n+\n+(ert-deftest indent-line-after-whitespace-motion ()\n+  (rust-test-motion\n+   rust-test-indent-motion-string\n+   'after-whitespace-indent-start\n+   'after-whitespace-indent-target\n+   #'indent-for-tab-command))\n+\n+(ert-deftest indent-line-middle-pull-motion ()\n+  (rust-test-motion\n+   rust-test-indent-motion-string\n+   'middle-pull-indent-start\n+   'middle-pull-indent-target\n+   #'indent-for-tab-command))"}, {"sha": "b304df8f14c1661e7755e28c95bb65953df69291", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 71, "deletions": 46, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/780adfffc39bcb9d32685bd36e2f6b6e6a178dee/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/780adfffc39bcb9d32685bd36e2f6b6e6a178dee/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=780adfffc39bcb9d32685bd36e2f6b6e6a178dee", "patch": "@@ -59,70 +59,95 @@\n \t(backward-word 1))\n       (current-column))))\n \n+(defun rust-rewind-to-beginning-of-current-level-expr ()\n+  (let ((current-level (rust-paren-level)))\n+    (back-to-indentation)\n+    (while (> (rust-paren-level) current-level)\n+      (backward-up-list)\n+      (back-to-indentation))))\n+\n (defun rust-mode-indent-line ()\n   (interactive)\n   (let ((indent\n          (save-excursion\n            (back-to-indentation)\n-           (let ((level (rust-paren-level)))\n+           ;; Point is now at beginning of current line\n+           (let* ((level (rust-paren-level))\n+                  (baseline\n+                   ;; Our \"baseline\" is one level out from the indentation of the expression\n+                   ;; containing the innermost enclosing opening bracket.  That\n+                   ;; way if we are within a block that has a different\n+                   ;; indentation than this mode would give it, we still indent\n+                   ;; the inside of it correctly relative to the outside.\n+                   (if (= 0 level)\n+                       0\n+                     (save-excursion\n+                       (backward-up-list)\n+                       (rust-rewind-to-beginning-of-current-level-expr)\n+                       (+ (current-column) rust-indent-offset)))))\n              (cond\n               ;; A function return type is indented to the corresponding function arguments\n               ((looking-at \"->\")\n                (save-excursion\n                  (backward-list)\n                  (or (rust-align-to-expr-after-brace)\n-                     (* rust-indent-offset (+ 1 level)))))\n+                     (+ baseline rust-indent-offset))))\n \n               ;; A closing brace is 1 level unindended\n-              ((looking-at \"}\") (* rust-indent-offset (- level 1)))\n+              ((looking-at \"}\") (- baseline rust-indent-offset))\n \n               ;; Doc comments in /** style with leading * indent to line up the *s\n               ((and (nth 4 (syntax-ppss)) (looking-at \"*\"))\n-               (+ 1 (* rust-indent-offset level)))\n+               (+ 1 baseline))\n \n               ;; If we're in any other token-tree / sexp, then:\n-              ;;  - [ or ( means line up with the opening token\n-              ;;  - { means indent to either nesting-level * rust-indent-offset,\n-              ;;    or one further indent from that if either current line\n-              ;;    begins with 'else', or previous line didn't end in\n-              ;;    semi, comma or brace (other than whitespace and line\n-              ;;    comments) , and wasn't an attribute.  But if we have\n-              ;;    something after the open brace and ending with a comma,\n-              ;;    treat it as fields and align them.  PHEW.\n-              ((> level 0)\n-               (let ((pt (point)))\n-                 (rust-rewind-irrelevant)\n-                 (backward-up-list)\n-                 (or (and (looking-at \"[[({]\")\n-                          (rust-align-to-expr-after-brace))\n-                     (progn\n-                       (goto-char pt)\n-                       (back-to-indentation)\n-                       (if (looking-at \"\\\\<else\\\\>\")\n-                           (* rust-indent-offset (+ 1 level))\n-                         (progn\n-                           (goto-char pt)\n-                           (beginning-of-line)\n-                           (rust-rewind-irrelevant)\n-                           (end-of-line)\n-                           (if (looking-back\n-                                \"[[,;{}(][[:space:]]*\\\\(?://.*\\\\)?\")\n-                               (* rust-indent-offset level)\n-                             (back-to-indentation)\n-                             (if (looking-at \"#\")\n-                                 (* rust-indent-offset level)\n-                               (* rust-indent-offset (+ 1 level))))))))))\n-\n-              ;; Otherwise we're in a column-zero definition\n-              (t 0))))))\n-    (cond\n-     ;; If we're to the left of the indentation, reindent and jump to it.\n-     ((<= (current-column) indent)\n-      (indent-line-to indent))\n-\n-     ;; We're to the right; if it needs indent, do so but save excursion.\n-     ((not (eq (current-indentation) indent))\n-      (save-excursion (indent-line-to indent))))))\n+              (t\n+               (or\n+                ;; If we are inside a pair of braces, with something after the\n+                ;; open brace on the same line and ending with a comma, treat\n+                ;; it as fields and align them.\n+                (when (> level 0)\n+                  (save-excursion\n+                    (rust-rewind-irrelevant)\n+                    (backward-up-list)\n+                    ;; Point is now at the beginning of the containing set of braces\n+                    (rust-align-to-expr-after-brace)))\n+\n+                (progn\n+                  (back-to-indentation)\n+                  ;; Point is now at the beginning of the current line\n+                  (if (or\n+                       ;; If this line begins with \"else\" or \"{\", stay on the\n+                       ;; baseline as well (we are continuing an expression,\n+                       ;; but the \"else\" or \"{\" should align with the beginning\n+                       ;; of the expression it's in.)\n+                       (looking-at \"\\\\<else\\\\>\\\\|{\")\n+                       \n+                       (save-excursion\n+                         (rust-rewind-irrelevant)\n+                         ;; Point is now at the end of the previous ine\n+                         (or\n+                          ;; If we are at the first line, no indentation is needed, so stay at baseline...\n+                          (= 1 (line-number-at-pos (point)))\n+                          ;; ..or if the previous line ends with any of these:\n+                          ;;     { ? : ( , ; [ }\n+                          ;; then we are at the beginning of an expression, so stay on the baseline...\n+                          (looking-back \"[(,:;?[{}]\\\\|[^|]|\")\n+                          ;; or if the previous line is the end of an attribute, stay at the baseline...\n+                          (progn (rust-rewind-to-beginning-of-current-level-expr) (looking-at \"#\")))))\n+                      baseline\n+\n+                    ;; Otherwise, we are continuing the same expression from the previous line,\n+                    ;; so add one additional indent level\n+                    (+ baseline rust-indent-offset))))))))))\n+    (when (not (eq (current-indentation) indent))\n+      ;; If we're at the beginning of the line (before or at the current\n+      ;; indentation), jump with the indentation change.  Otherwise, save the\n+      ;; excursion so that adding the indentations will leave us at the\n+      ;; equivalent position within the line to where we were before.\n+      (if (<= (current-column) (current-indentation))\n+          (indent-line-to indent)\n+        (save-excursion (indent-line-to indent))))))\n \n \n ;; Font-locking definitions and helpers"}]}