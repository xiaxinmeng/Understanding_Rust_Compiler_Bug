{"sha": "0a8bffceb3ba25b12926bbd42ed3d282f573c9a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhOGJmZmNlYjNiYTI1YjEyOTI2YmJkNDJlZDNkMjgyZjU3M2M5YTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-18T03:31:55Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-18T20:09:49Z"}, "message": "Simplify the _rust_main/rust_start interface\n\nrust_start will always call _rust_main with the command line args, and it is\n_rust_main's responsibility to free the args ivec heap. _rust_main will be\ngenerated slightly differently depending on whether main takes an ivec or not:\nif so then it's just passed through to main, otherwise it frees the ivec\ndirectly.", "tree": {"sha": "049632f6bf5475751688f571ee3c7d79eda9769a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/049632f6bf5475751688f571ee3c7d79eda9769a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a8bffceb3ba25b12926bbd42ed3d282f573c9a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a8bffceb3ba25b12926bbd42ed3d282f573c9a0", "html_url": "https://github.com/rust-lang/rust/commit/0a8bffceb3ba25b12926bbd42ed3d282f573c9a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a8bffceb3ba25b12926bbd42ed3d282f573c9a0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1", "html_url": "https://github.com/rust-lang/rust/commit/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1"}], "stats": {"total": 63, "additions": 28, "deletions": 35}, "files": [{"sha": "ebaa225a00d4e798ed699224b61d443c2cd09650", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0a8bffceb3ba25b12926bbd42ed3d282f573c9a0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8bffceb3ba25b12926bbd42ed3d282f573c9a0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0a8bffceb3ba25b12926bbd42ed3d282f573c9a0", "patch": "@@ -6378,6 +6378,8 @@ fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     }\n }\n \n+// Create a _rust_main(args: [str]) function which will be called from the\n+// runtime rust_start function\n fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span,\n                        main_llfn: ValueRef, main_node_type: ty::t) {\n \n@@ -6392,14 +6394,13 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span,\n     };\n \n     let llfn = create_main(ccx, sp, main_llfn, main_takes_ivec);\n-    create_main_type_indicator(ccx, main_takes_ivec);\n     ccx.main_fn = some(llfn);\n \n     fn create_main(ccx: &@crate_ctxt,\n                    sp: &span,\n                    main_llfn: ValueRef,\n                    takes_ivec: bool) -> ValueRef {\n-        let ivecarg = {\n+        let ivecarg_ty: ty::arg = {\n             mode: ty::mo_val,\n             ty: ty::mk_ivec(ccx.tcx, {\n                 ty: ty::mk_str(ccx.tcx),\n@@ -6408,13 +6409,15 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span,\n         };\n         let llfty = type_of_fn(ccx, sp,\n                                ast::proto_fn,\n-                               ~[ivecarg],\n+                               ~[ivecarg_ty],\n                                ty::mk_nil(ccx.tcx),\n                                0u);\n         let llfdecl = decl_fastcall_fn(ccx.llmod, \"_rust_main\", llfty);\n \n         let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, llfdecl);\n+\n         let bcx = new_top_block_ctxt(fcx);\n+        let lltop = bcx.llbb;\n \n         if takes_ivec {\n             let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n@@ -6430,28 +6433,26 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span,\n             let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n             let lltaskarg = llvm::LLVMGetParam(llfdecl, 1u);\n             let llenvarg = llvm::LLVMGetParam(llfdecl, 2u);\n+            let llargvarg = llvm::LLVMGetParam(llfdecl, 3u);\n+\n+            // If the crate's main function doesn't take the args vector then\n+            // we're responsible for freeing it\n+            let llivecptr = alloca(bcx, val_ty(llargvarg));\n+            bcx.build.Store(llargvarg, llivecptr);\n+            bcx = maybe_free_ivec_heap_part(bcx, llivecptr,\n+                                            ty::mk_str(ccx.tcx)).bcx;\n+\n             let args = ~[lloutputarg,\n                          lltaskarg,\n                          llenvarg];\n             bcx.build.FastCall(main_llfn, args);\n         }\n         build_return(bcx);\n \n-        let lltop = bcx.llbb;\n         finish_fn(fcx, lltop);\n \n         ret llfdecl;\n     }\n-\n-    // FIXME: Remove after main takes only ivec\n-    // Sets a global value hinting to the runtime whether main takes\n-    // a vec or an ivec\n-    fn create_main_type_indicator(ccx: &@crate_ctxt, takes_ivec: bool) {\n-        let i = llvm::LLVMAddGlobal(ccx.llmod, T_int(),\n-                                    str::buf(\"_rust_main_is_ivec\"));\n-        llvm::LLVMSetInitializer(i, C_int(takes_ivec as int));\n-        llvm::LLVMSetGlobalConstant(i, True);\n-    }\n }\n \n "}, {"sha": "5f33f89da4c64b201b320f56d13d647ceb657041", "filename": "src/rt/main.ll.in", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a8bffceb3ba25b12926bbd42ed3d282f573c9a0/src%2Frt%2Fmain.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/0a8bffceb3ba25b12926bbd42ed3d282f573c9a0/src%2Frt%2Fmain.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmain.ll.in?ref=0a8bffceb3ba25b12926bbd42ed3d282f573c9a0", "patch": "@@ -14,10 +14,7 @@\n \n @_rust_crate_map_toplevel = external global %0\n \n-; FIXME: Remove after main takes only ivec\n-@_rust_main_is_ivec = external global i32\n-\n-declare i32 @rust_start(i32, i32, i32, i32, i32)\n+declare i32 @rust_start(i32, i32, i32, i32)\n \n declare external fastcc void @_rust_main(i1* nocapture, %task*, %2* nocapture, %ivec)\n \n@@ -29,8 +26,6 @@ define void @_rust_main_wrap(i1* nocapture, %task *, %2* nocapture, %ivec *)\n }\n \n define i32 @\"MAIN\"(i32, i32) {\n-  %is_ivec = load i32 *@_rust_main_is_ivec\n-\n-  %3 = tail call i32 @rust_start(i32 ptrtoint (void (i1*, %task*, %2*, %ivec*)* @_rust_main_wrap to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32), i32 %is_ivec)\n+  %3 = tail call i32 @rust_start(i32 ptrtoint (void (i1*, %task*, %2*, %ivec*)* @_rust_main_wrap to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32))\n   ret i32 %3\n }"}, {"sha": "a34738b84114790f530a2aa2e92082eb5f718c4f", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0a8bffceb3ba25b12926bbd42ed3d282f573c9a0/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0a8bffceb3ba25b12926bbd42ed3d282f573c9a0/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=0a8bffceb3ba25b12926bbd42ed3d282f573c9a0", "patch": "@@ -14,8 +14,7 @@ command_line_args : public kernel_owned<command_line_args>\n \n     command_line_args(rust_task *task,\n                       int sys_argc,\n-                      char **sys_argv,\n-                      bool main_is_ivec)\n+                      char **sys_argv)\n         : kernel(task->kernel),\n           task(task),\n           argc(sys_argc),\n@@ -67,15 +66,13 @@ command_line_args : public kernel_owned<command_line_args>\n         args_ivec->fill = 0;\n         size_t ivec_exterior_sz = sizeof(rust_str *) * argc;\n         args_ivec->alloc = ivec_exterior_sz;\n-        if (main_is_ivec) {\n-            // NB: This is freed by some ivec machinery, probably the drop\n-            // glue in main, so we don't free it ourselves\n-            args_ivec->payload.ptr = (rust_ivec_heap *)\n-                kernel->malloc(ivec_exterior_sz + sizeof(size_t),\n-                               \"command line arg exterior\");\n-            args_ivec->payload.ptr->fill = ivec_exterior_sz;\n-            memcpy(&args_ivec->payload.ptr->data, strs, ivec_exterior_sz);\n-        }\n+        // NB: This is freed by some ivec machinery, probably the drop\n+        // glue in main, so we don't free it ourselves\n+        args_ivec->payload.ptr = (rust_ivec_heap *)\n+            kernel->malloc(ivec_exterior_sz + sizeof(size_t),\n+                           \"command line arg exterior\");\n+        args_ivec->payload.ptr->fill = ivec_exterior_sz;\n+        memcpy(&args_ivec->payload.ptr->data, strs, ivec_exterior_sz);\n     }\n \n     ~command_line_args() {\n@@ -107,7 +104,7 @@ int check_claims = 0;\n \n extern \"C\" CDECL int\n rust_start(uintptr_t main_fn, int argc, char **argv,\n-           void* crate_map, int main_takes_ivec) {\n+           void* crate_map) {\n \n     rust_env *env = load_env();\n \n@@ -122,7 +119,7 @@ rust_start(uintptr_t main_fn, int argc, char **argv,\n     rust_scheduler *sched = root_task->sched;\n     command_line_args *args\n         = new (kernel, \"main command line args\")\n-        command_line_args(root_task, argc, argv, main_takes_ivec);\n+        command_line_args(root_task, argc, argv);\n \n     DLOG(sched, dom, \"startup: %d args in 0x%\" PRIxPTR,\n              args->argc, (uintptr_t)args->args);\n@@ -154,7 +151,7 @@ rust_start(uintptr_t main_fn, int argc, char **argv,\n extern \"C\" CDECL int\n rust_start_ivec(uintptr_t main_fn, int argc, char **argv,\n                 void* crate_map, int main_takes_ivec) {\n-    return rust_start(main_fn, argc, argv, crate_map, main_takes_ivec);\n+    return rust_start(main_fn, argc, argv, crate_map);\n }\n \n "}]}