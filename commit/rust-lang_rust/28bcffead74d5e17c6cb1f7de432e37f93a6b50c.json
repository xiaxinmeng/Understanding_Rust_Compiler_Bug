{"sha": "28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YmNmZmVhZDc0ZDVlMTdjNmNiMWY3ZGU0MzJlMzdmOTNhNmI1MGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-01T20:31:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-01T20:31:29Z"}, "message": "Auto merge of #53815 - F001:if-let-guard, r=petrochenkov\n\nrefactor match guard\n\nThis is the first step to implement RFC 2294: if-let-guard. Tracking issue: https://github.com/rust-lang/rust/issues/51114\n\nThe second step should be introducing another variant `IfLet` in the Guard enum. I separated them into 2 PRs for the convenience of reviewers.\n\nr? @petrochenkov", "tree": {"sha": "1abf601a008600ac3a23c22c1ce003c571dee816", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1abf601a008600ac3a23c22c1ce003c571dee816"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "html_url": "https://github.com/rust-lang/rust/commit/28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f39f218ec33d93e8a1b0ac4282f62ee35e02c18a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f39f218ec33d93e8a1b0ac4282f62ee35e02c18a", "html_url": "https://github.com/rust-lang/rust/commit/f39f218ec33d93e8a1b0ac4282f62ee35e02c18a"}, {"sha": "7a083ca25f14833d704d2efba5ca9b431f6c65ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a083ca25f14833d704d2efba5ca9b431f6c65ad", "html_url": "https://github.com/rust-lang/rust/commit/7a083ca25f14833d704d2efba5ca9b431f6c65ad"}], "stats": {"total": 150, "additions": 115, "deletions": 35}, "files": [{"sha": "1b97480920321d6fafad010285a19ff258e95394", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -488,8 +488,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     // expression to target\n                     let guard_start = self.add_dummy_node(&[pat_exit]);\n                     // Visit the guard expression\n-                    let guard_exit = self.expr(&guard, guard_start);\n-\n+                    let guard_exit = match guard {\n+                        hir::Guard::If(ref e) => self.expr(e, guard_start),\n+                    };\n                     // #47295: We used to have very special case code\n                     // here for when a pair of arms are both formed\n                     // solely from constants, and if so, not add these"}, {"sha": "8129cc18d46c2e08952b0753b8fcd691a90526b1", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -1102,7 +1102,11 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n     walk_list!(visitor, visit_pat, &arm.pats);\n-    walk_list!(visitor, visit_expr, &arm.guard);\n+    if let Some(ref g) = arm.guard {\n+        match g {\n+            Guard::If(ref e) => visitor.visit_expr(e),\n+        }\n+    }\n     visitor.visit_expr(&arm.body);\n     walk_list!(visitor, visit_attribute, &arm.attrs);\n }"}, {"sha": "34b3eb0a8c8bf64d1fd595377f2f028d89dcaf3f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -1054,7 +1054,10 @@ impl<'a> LoweringContext<'a> {\n         hir::Arm {\n             attrs: self.lower_attrs(&arm.attrs),\n             pats: arm.pats.iter().map(|x| self.lower_pat(x)).collect(),\n-            guard: arm.guard.as_ref().map(|ref x| P(self.lower_expr(x))),\n+            guard: match arm.guard {\n+                Some(Guard::If(ref x)) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n+                _ => None,\n+            },\n             body: P(self.lower_expr(&arm.body)),\n         }\n     }"}, {"sha": "1b3103578737190b2c32a3886806940a6022af92", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -1204,10 +1204,15 @@ impl DeclKind {\n pub struct Arm {\n     pub attrs: HirVec<Attribute>,\n     pub pats: HirVec<P<Pat>>,\n-    pub guard: Option<P<Expr>>,\n+    pub guard: Option<Guard>,\n     pub body: P<Expr>,\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum Guard {\n+    If(P<Expr>),\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Field {\n     pub id: NodeId,"}, {"sha": "55357095fb7596f10b6281af5f268493dab500bd", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -1949,10 +1949,14 @@ impl<'a> State<'a> {\n             self.print_pat(&p)?;\n         }\n         self.s.space()?;\n-        if let Some(ref e) = arm.guard {\n-            self.word_space(\"if\")?;\n-            self.print_expr(&e)?;\n-            self.s.space()?;\n+        if let Some(ref g) = arm.guard {\n+            match g {\n+                hir::Guard::If(e) => {\n+                    self.word_space(\"if\")?;\n+                    self.print_expr(&e)?;\n+                    self.s.space()?;\n+                }\n+            }\n         }\n         self.word_space(\"=>\")?;\n "}, {"sha": "3f1899bc54fb4c2e1e34b1c548cb51fcc3726e6b", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -493,6 +493,10 @@ impl_stable_hash_for!(struct hir::Arm {\n     body\n });\n \n+impl_stable_hash_for!(enum hir::Guard {\n+    If(expr),\n+});\n+\n impl_stable_hash_for!(struct hir::Field {\n     id -> _,\n     ident,"}, {"sha": "356992b22146d67b02d63c409b07787c93b46774", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -792,7 +792,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         }\n \n         if let Some(ref guard) = arm.guard {\n-            self.consume_expr(&guard);\n+            match guard {\n+                hir::Guard::If(ref e) => self.consume_expr(e),\n+            }\n         }\n \n         self.consume_expr(&arm.body);"}, {"sha": "c34a0a654e6a9f7c1964b39b3fa0c4e411391010", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -1030,7 +1030,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let body_succ =\n                     self.propagate_through_expr(&arm.body, succ);\n                 let guard_succ =\n-                    self.propagate_through_opt_expr(arm.guard.as_ref().map(|e| &**e), body_succ);\n+                    self.propagate_through_opt_expr(\n+                        arm.guard.as_ref().map(|g|\n+                            match g {\n+                                hir::Guard::If(e) => &**e,\n+                            }),\n+                        body_succ);\n                 // only consider the first pattern; any later patterns must have\n                 // the same bindings, and we also consider the first pattern to be\n                 // the \"authoritative\" set of ids"}, {"sha": "e281cbf94889394198e3e8e5d982b70b43bfab81", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -885,8 +885,10 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n \n-    if let Some(ref expr) = arm.guard {\n-        visitor.terminating_scopes.insert(expr.hir_id.local_id);\n+    if let Some(ref g) = arm.guard {\n+        match g {\n+            hir::Guard::If(ref expr) => visitor.terminating_scopes.insert(expr.hir_id.local_id),\n+        };\n     }\n \n     intravisit::walk_arm(visitor, arm);"}, {"sha": "d3e67ea7b7d7153c6a5008848918007900a5d86f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -453,7 +453,7 @@ pub struct Candidate<'pat, 'tcx:'pat> {\n     bindings: Vec<Binding<'tcx>>,\n \n     // ...and the guard must be evaluated...\n-    guard: Option<ExprRef<'tcx>>,\n+    guard: Option<Guard<'tcx>>,\n \n     // ...and then we branch to arm with this index.\n     arm_index: usize,\n@@ -998,7 +998,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n-            let guard = self.hir.mirror(guard);\n+            let guard = match guard {\n+                Guard::If(e) => self.hir.mirror(e),\n+            };\n             let source_info = self.source_info(guard.span);\n             let cond = unpack!(block = self.as_local_operand(block, guard));\n             if autoref {"}, {"sha": "055f238e5db4ea12f2c03d6a079d7ff2fe70b5ea", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -837,7 +837,10 @@ impl ToBorrowKind for hir::Mutability {\n fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n         patterns: arm.pats.iter().map(|p| cx.pattern_from_hir(p)).collect(),\n-        guard: arm.guard.to_ref(),\n+        guard: match arm.guard {\n+                Some(hir::Guard::If(ref e)) => Some(Guard::If(e.to_ref())),\n+                _ => None,\n+            },\n         body: arm.body.to_ref(),\n         // BUG: fix this\n         lint_level: LintLevel::Inherited,"}, {"sha": "2ddb810f4914817e7640e6bdf92cd1a78750ae67", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -316,11 +316,16 @@ pub struct FruInfo<'tcx> {\n #[derive(Clone, Debug)]\n pub struct Arm<'tcx> {\n     pub patterns: Vec<Pattern<'tcx>>,\n-    pub guard: Option<ExprRef<'tcx>>,\n+    pub guard: Option<Guard<'tcx>>,\n     pub body: ExprRef<'tcx>,\n     pub lint_level: LintLevel,\n }\n \n+#[derive(Clone, Debug)]\n+pub enum Guard<'tcx> {\n+    If(ExprRef<'tcx>),\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum LogicalOp {\n     And,"}, {"sha": "3a518bad8ed7c20aff0b9ee4b90ebad1f97725f6", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -208,7 +208,9 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                     }\n                     (pattern, &**pat)\n                 }).collect(),\n-                arm.guard.as_ref().map(|e| &**e)\n+                arm.guard.as_ref().map(|g| match g {\n+                    hir::Guard::If(ref e) => &**e,\n+                })\n             )).collect();\n \n             // Bail out early if inlining failed.\n@@ -575,12 +577,19 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n /// assign.\n ///\n /// FIXME: this should be done by borrowck.\n-fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n+fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Guard) {\n     let mut checker = MutationChecker {\n         cx,\n     };\n-    ExprUseVisitor::new(&mut checker, cx.tcx, cx.param_env, cx.region_scope_tree, cx.tables, None)\n-        .walk_expr(guard);\n+    match guard {\n+        hir::Guard::If(expr) =>\n+            ExprUseVisitor::new(&mut checker,\n+                                cx.tcx,\n+                                cx.param_env,\n+                                cx.region_scope_tree,\n+                                cx.tables,\n+                                None).walk_expr(expr),\n+    };\n }\n \n struct MutationChecker<'a, 'tcx: 'a> {"}, {"sha": "ea4fba3e1248182af89e6b6b99149195c9045e0e", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -577,7 +577,7 @@ fn check_expr_kind<'a, 'tcx>(\n             for index in hirvec_arm.iter() {\n                 let _ = v.check_expr(&*index.body);\n                 match index.guard {\n-                    Some(ref expr) => {\n+                    Some(hir::Guard::If(ref expr)) => {\n                         let _ = v.check_expr(&expr);\n                     },\n                     None => {},"}, {"sha": "0f6a97423091796dc83d97866b4a8d238c99f4bc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -2701,7 +2701,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         // This has to happen *after* we determine which pat_idents are variants\n         self.check_consistent_bindings(&arm.pats);\n \n-        walk_list!(self, visit_expr, &arm.guard);\n+        match arm.guard {\n+            Some(ast::Guard::If(ref expr)) => self.visit_expr(expr),\n+            _ => {}\n+        }\n         self.visit_expr(&arm.body);\n \n         self.ribs[ValueNS].pop();"}, {"sha": "58665b808d98898869ad71570ff6878063599ed7", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -1663,7 +1663,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n \n     fn visit_arm(&mut self, arm: &'l ast::Arm) {\n         self.process_var_decl_multi(&arm.pats);\n-        walk_list!(self, visit_expr, &arm.guard);\n+        match arm.guard {\n+            Some(ast::Guard::If(ref expr)) => self.visit_expr(expr),\n+            _ => {}\n+        }\n         self.visit_expr(&arm.body);\n     }\n "}, {"sha": "6b5abbfa4a6f75ea00f216596694b489605d3b7c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -663,9 +663,11 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         };\n \n         for (i, (arm, pats_diverge)) in arms.iter().zip(all_arm_pats_diverge).enumerate() {\n-            if let Some(ref e) = arm.guard {\n+            if let Some(ref g) = arm.guard {\n                 self.diverges.set(pats_diverge);\n-                self.check_expr_has_type_or_error(e, tcx.types.bool);\n+                match g {\n+                    hir::Guard::If(e) => self.check_expr_has_type_or_error(e, tcx.types.bool),\n+                };\n             }\n \n             self.diverges.set(pats_diverge);"}, {"sha": "72f1791ef7c0f995d285a3502a9cb4d230820fd8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -857,10 +857,15 @@ pub struct Local {\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n     pub pats: Vec<P<Pat>>,\n-    pub guard: Option<P<Expr>>,\n+    pub guard: Option<Guard>,\n     pub body: P<Expr>,\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum Guard {\n+    If(P<Expr>),\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Field {\n     pub ident: Ident,"}, {"sha": "dff408d233977b559c99dce845735fba927c8956", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -118,6 +118,10 @@ pub trait Folder : Sized {\n         noop_fold_arm(a, self)\n     }\n \n+    fn fold_guard(&mut self, g: Guard) -> Guard {\n+        noop_fold_guard(g, self)\n+    }\n+\n     fn fold_pat(&mut self, p: P<Pat>) -> P<Pat> {\n         noop_fold_pat(p, self)\n     }\n@@ -354,11 +358,17 @@ pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm,\n     Arm {\n         attrs: fold_attrs(attrs, fld),\n         pats: pats.move_map(|x| fld.fold_pat(x)),\n-        guard: guard.map(|x| fld.fold_expr(x)),\n+        guard: guard.map(|x| fld.fold_guard(x)),\n         body: fld.fold_expr(body),\n     }\n }\n \n+pub fn noop_fold_guard<T: Folder>(g: Guard, fld: &mut T) -> Guard {\n+    match g {\n+        Guard::If(e) => Guard::If(fld.fold_expr(e)),\n+    }\n+}\n+\n pub fn noop_fold_ty_binding<T: Folder>(b: TypeBinding, fld: &mut T) -> TypeBinding {\n     TypeBinding {\n         id: fld.new_id(b.id),"}, {"sha": "c741bde7c5f24f7d1b4dee695d908ad3f028c4b4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -12,7 +12,7 @@ use rustc_target::spec::abi::{self, Abi};\n use ast::{AngleBracketedArgs, ParenthesisedArgs, AttrStyle, BareFnTy};\n use ast::{GenericBound, TraitBoundModifier};\n use ast::Unsafety;\n-use ast::{Mod, AnonConst, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n+use ast::{Mod, AnonConst, Arg, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n use ast::Block;\n use ast::{BlockCheckMode, CaptureBy, Movability};\n use ast::{Constness, Crate};\n@@ -3533,7 +3533,7 @@ impl<'a> Parser<'a> {\n         self.eat(&token::BinOp(token::Or));\n         let pats = self.parse_pats()?;\n         let guard = if self.eat_keyword(keywords::If) {\n-            Some(self.parse_expr()?)\n+            Some(Guard::If(self.parse_expr()?))\n         } else {\n             None\n         };"}, {"sha": "85d29a5be89db03b1e8303e55d3f9907f41a503f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -2702,10 +2702,14 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&arm.attrs)?;\n         self.print_pats(&arm.pats)?;\n         self.s.space()?;\n-        if let Some(ref e) = arm.guard {\n-            self.word_space(\"if\")?;\n-            self.print_expr(e)?;\n-            self.s.space()?;\n+        if let Some(ref g) = arm.guard {\n+            match g {\n+                ast::Guard::If(ref e) => {\n+                    self.word_space(\"if\")?;\n+                    self.print_expr(e)?;\n+                    self.s.space()?;\n+                }\n+            }\n         }\n         self.word_space(\"=>\")?;\n "}, {"sha": "77311bf53fd1e84e5c0b1e5f9fc190993e0ed133", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcffead74d5e17c6cb1f7de432e37f93a6b50c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=28bcffead74d5e17c6cb1f7de432e37f93a6b50c", "patch": "@@ -819,7 +819,11 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n \n pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n     walk_list!(visitor, visit_pat, &arm.pats);\n-    walk_list!(visitor, visit_expr, &arm.guard);\n+    if let Some(ref g) = &arm.guard {\n+        match g {\n+            Guard::If(ref e) => visitor.visit_expr(e),\n+        }\n+    }\n     visitor.visit_expr(&arm.body);\n     walk_list!(visitor, visit_attribute, &arm.attrs);\n }"}]}