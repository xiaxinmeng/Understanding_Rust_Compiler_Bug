{"sha": "cbcafd3539d20c2fd9210b378e132b94b50ba6be", "node_id": "C_kwDOAAsO6NoAKGNiY2FmZDM1MzlkMjBjMmZkOTIxMGIzNzhlMTMyYjk0YjUwYmE2YmU", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-12T14:47:15Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-12T14:47:15Z"}, "message": "MIR episode 5", "tree": {"sha": "08a0da01c6b250ad295c2d7dde6335fb33849474", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08a0da01c6b250ad295c2d7dde6335fb33849474"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbcafd3539d20c2fd9210b378e132b94b50ba6be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbcafd3539d20c2fd9210b378e132b94b50ba6be", "html_url": "https://github.com/rust-lang/rust/commit/cbcafd3539d20c2fd9210b378e132b94b50ba6be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbcafd3539d20c2fd9210b378e132b94b50ba6be/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b3387454d7c70ec768114871682ee2946ec88a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b3387454d7c70ec768114871682ee2946ec88a8", "html_url": "https://github.com/rust-lang/rust/commit/9b3387454d7c70ec768114871682ee2946ec88a8"}], "stats": {"total": 1894, "additions": 1532, "deletions": 362}, "files": [{"sha": "d4b4cbe6c7cef9270e71f58bb36d74c5731e35a8", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -165,7 +165,7 @@ impl Body {\n         };\n         let expander = Expander::new(db, file_id, module);\n         let (mut body, source_map) =\n-            Body::new(db, expander, params, body, module.krate, is_async_fn);\n+            Body::new(db, def, expander, params, body, module.krate, is_async_fn);\n         body.shrink_to_fit();\n \n         (Arc::new(body), Arc::new(source_map))\n@@ -189,13 +189,14 @@ impl Body {\n \n     fn new(\n         db: &dyn DefDatabase,\n+        owner: DefWithBodyId,\n         expander: Expander,\n         params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n         body: Option<ast::Expr>,\n         krate: CrateId,\n         is_async_fn: bool,\n     ) -> (Body, BodySourceMap) {\n-        lower::lower(db, expander, params, body, krate, is_async_fn)\n+        lower::lower(db, owner, expander, params, body, krate, is_async_fn)\n     }\n \n     fn shrink_to_fit(&mut self) {"}, {"sha": "e9cb51d5bf8d254f091a012195fc69a850e0440f", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -40,11 +40,12 @@ use crate::{\n     nameres::{DefMap, MacroSubNs},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n-    AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n+    AdtId, BlockId, BlockLoc, DefWithBodyId, ModuleDefId, UnresolvedMacro,\n };\n \n pub(super) fn lower(\n     db: &dyn DefDatabase,\n+    owner: DefWithBodyId,\n     expander: Expander,\n     params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n     body: Option<ast::Expr>,\n@@ -53,6 +54,7 @@ pub(super) fn lower(\n ) -> (Body, BodySourceMap) {\n     ExprCollector {\n         db,\n+        owner,\n         krate,\n         def_map: expander.module.def_map(db),\n         source_map: BodySourceMap::default(),\n@@ -80,6 +82,7 @@ pub(super) fn lower(\n struct ExprCollector<'a> {\n     db: &'a dyn DefDatabase,\n     expander: Expander,\n+    owner: DefWithBodyId,\n     def_map: Arc<DefMap>,\n     ast_id_map: Arc<AstIdMap>,\n     krate: CrateId,\n@@ -269,16 +272,13 @@ impl ExprCollector<'_> {\n                 }\n                 Some(ast::BlockModifier::Const(_)) => {\n                     self.with_label_rib(RibKind::Constant, |this| {\n-                        this.collect_as_a_binding_owner_bad(\n-                            |this| {\n-                                this.collect_block_(e, |id, statements, tail| Expr::Const {\n-                                    id,\n-                                    statements,\n-                                    tail,\n-                                })\n-                            },\n-                            syntax_ptr,\n-                        )\n+                        let (result_expr_id, prev_binding_owner) =\n+                            this.initialize_binding_owner(syntax_ptr);\n+                        let inner_expr = this.collect_block(e);\n+                        let x = this.db.intern_anonymous_const((this.owner, inner_expr));\n+                        this.body.exprs[result_expr_id] = Expr::Const(x);\n+                        this.current_binding_owner = prev_binding_owner;\n+                        result_expr_id\n                     })\n                 }\n                 None => self.collect_block(e),"}, {"sha": "8fe304aa14da97cc3c35f0b45744b72b0351a7f1", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -436,8 +436,8 @@ impl<'a> Printer<'a> {\n             Expr::Async { id: _, statements, tail } => {\n                 self.print_block(Some(\"async \"), statements, tail);\n             }\n-            Expr::Const { id: _, statements, tail } => {\n-                self.print_block(Some(\"const \"), statements, tail);\n+            Expr::Const(id) => {\n+                w!(self, \"const {{ /* {id:?} */ }}\");\n             }\n         }\n     }"}, {"sha": "b81130c0c2493d8401e7832c71fa4ae2f195be70", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -218,9 +218,10 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n             scopes.set_scope(expr, scope);\n             compute_block_scopes(statements, *tail, body, scopes, &mut scope);\n         }\n-        Expr::Unsafe { id, statements, tail }\n-        | Expr::Async { id, statements, tail }\n-        | Expr::Const { id, statements, tail } => {\n+        Expr::Const(_) => {\n+            // FIXME: This is broken.\n+        }\n+        Expr::Unsafe { id, statements, tail } | Expr::Async { id, statements, tail } => {\n             let mut scope = scopes.new_block_scope(*scope, *id, None);\n             // Overwrite the old scope for the block expr, so that every block scope can be found\n             // via the block itself (important for blocks that only contain items, no expressions)."}, {"sha": "c3721a94f674380ca4dcdb5b259275b383dcbc93", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -16,16 +16,17 @@ use crate::{\n         TraitAliasData, TraitData, TypeAliasData,\n     },\n     generics::GenericParams,\n+    hir::ExprId,\n     import_map::ImportMap,\n     item_tree::{AttrOwner, ItemTree},\n     lang_item::{LangItem, LangItemTarget, LangItems},\n     nameres::{diagnostics::DefDiagnostic, DefMap},\n     visibility::{self, Visibility},\n-    AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, ExternBlockId,\n-    ExternBlockLoc, FunctionId, FunctionLoc, GenericDefId, ImplId, ImplLoc, LocalEnumVariantId,\n-    LocalFieldId, Macro2Id, Macro2Loc, MacroRulesId, MacroRulesLoc, ProcMacroId, ProcMacroLoc,\n-    StaticId, StaticLoc, StructId, StructLoc, TraitAliasId, TraitAliasLoc, TraitId, TraitLoc,\n-    TypeAliasId, TypeAliasLoc, UnionId, UnionLoc, VariantId,\n+    AnonymousConstId, AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId,\n+    EnumLoc, ExternBlockId, ExternBlockLoc, FunctionId, FunctionLoc, GenericDefId, ImplId, ImplLoc,\n+    LocalEnumVariantId, LocalFieldId, Macro2Id, Macro2Loc, MacroRulesId, MacroRulesLoc,\n+    ProcMacroId, ProcMacroLoc, StaticId, StaticLoc, StructId, StructLoc, TraitAliasId,\n+    TraitAliasLoc, TraitId, TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc, VariantId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n@@ -60,6 +61,8 @@ pub trait InternDatabase: SourceDatabase {\n     fn intern_proc_macro(&self, loc: ProcMacroLoc) -> ProcMacroId;\n     #[salsa::interned]\n     fn intern_macro_rules(&self, loc: MacroRulesLoc) -> MacroRulesId;\n+    #[salsa::interned]\n+    fn intern_anonymous_const(&self, id: (DefWithBodyId, ExprId)) -> AnonymousConstId;\n }\n \n #[salsa::query_group(DefDatabaseStorage)]"}, {"sha": "f531109cd886c7d7a2b9699acd1f200cfb6a7a2c", "filename": "crates/hir-def/src/hir.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fhir.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -26,7 +26,7 @@ use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n-    BlockId,\n+    AnonymousConstId, BlockId,\n };\n \n pub use syntax::ast::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp};\n@@ -169,11 +169,7 @@ pub enum Expr {\n         statements: Box<[Statement]>,\n         tail: Option<ExprId>,\n     },\n-    Const {\n-        id: Option<BlockId>,\n-        statements: Box<[Statement]>,\n-        tail: Option<ExprId>,\n-    },\n+    Const(AnonymousConstId),\n     Unsafe {\n         id: Option<BlockId>,\n         statements: Box<[Statement]>,\n@@ -355,10 +351,10 @@ impl Expr {\n             Expr::Let { expr, .. } => {\n                 f(*expr);\n             }\n+            Expr::Const(_) => (),\n             Expr::Block { statements, tail, .. }\n             | Expr::Unsafe { statements, tail, .. }\n-            | Expr::Async { statements, tail, .. }\n-            | Expr::Const { statements, tail, .. } => {\n+            | Expr::Async { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {\n                         Statement::Let { initializer, else_branch, .. } => {"}, {"sha": "9cd3dfd6f7c96a4766d0a5bc8d9f88b89c958426", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -59,7 +59,11 @@ mod pretty;\n \n use std::hash::{Hash, Hasher};\n \n-use base_db::{impl_intern_key, salsa, CrateId, ProcMacroKind};\n+use base_db::{\n+    impl_intern_key,\n+    salsa::{self, InternId},\n+    CrateId, ProcMacroKind,\n+};\n use hir_expand::{\n     ast_id_map::FileAstId,\n     attrs::{Attr, AttrId, AttrInput},\n@@ -472,6 +476,46 @@ impl_from!(\n     for ModuleDefId\n );\n \n+// FIXME: make this a DefWithBodyId\n+#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n+pub struct AnonymousConstId(InternId);\n+impl_intern_key!(AnonymousConstId);\n+\n+/// A constant, which might appears as a const item, an annonymous const block in expressions\n+/// or patterns, or as a constant in types with const generics.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum GeneralConstId {\n+    ConstId(ConstId),\n+    AnonymousConstId(AnonymousConstId),\n+}\n+\n+impl_from!(ConstId, AnonymousConstId for GeneralConstId);\n+\n+impl GeneralConstId {\n+    pub fn generic_def(self, db: &dyn db::DefDatabase) -> Option<GenericDefId> {\n+        match self {\n+            GeneralConstId::ConstId(x) => Some(x.into()),\n+            GeneralConstId::AnonymousConstId(x) => {\n+                let (parent, _) = db.lookup_intern_anonymous_const(x);\n+                parent.as_generic_def_id()\n+            }\n+        }\n+    }\n+\n+    pub fn name(self, db: &dyn db::DefDatabase) -> String {\n+        match self {\n+            GeneralConstId::ConstId(const_id) => db\n+                .const_data(const_id)\n+                .name\n+                .as_ref()\n+                .and_then(|x| x.as_str())\n+                .unwrap_or(\"_\")\n+                .to_owned(),\n+            GeneralConstId::AnonymousConstId(id) => format!(\"{{anonymous const {id:?}}}\"),\n+        }\n+    }\n+}\n+\n /// The defs which have a body.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum DefWithBodyId {"}, {"sha": "026750b62fa75f7397d7acca8c907c2ad1498901", "filename": "crates/hir-def/src/pretty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -12,6 +12,9 @@ use crate::{\n };\n \n pub(crate) fn print_path(path: &Path, buf: &mut dyn Write) -> fmt::Result {\n+    if let Path::LangItem(x) = path {\n+        return write!(buf, \"$lang_item::{x:?}\");\n+    }\n     match path.type_anchor() {\n         Some(anchor) => {\n             write!(buf, \"<\")?;"}, {"sha": "d6bad1a48c17a7a1dabf6f1c852d730118050cfc", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -376,6 +376,7 @@ pub mod known {\n         deref,\n         div_assign,\n         div,\n+        drop,\n         fn_mut,\n         fn_once,\n         future_trait,"}, {"sha": "3fb3de5ba8d30660f225eae4504db3129b723545", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -34,6 +34,7 @@ pub trait TyExt {\n     fn as_closure(&self) -> Option<ClosureId>;\n     fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId>;\n     fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)>;\n+    fn as_raw_ptr(&self) -> Option<(&Ty, Mutability)>;\n     fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)>;\n     fn as_generic_def(&self, db: &dyn HirDatabase) -> Option<GenericDefId>;\n \n@@ -146,13 +147,21 @@ impl TyExt for Ty {\n             Some(CallableDefId::StructId(_) | CallableDefId::EnumVariantId(_)) | None => None,\n         }\n     }\n+\n     fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)> {\n         match self.kind(Interner) {\n             TyKind::Ref(mutability, lifetime, ty) => Some((ty, lifetime.clone(), *mutability)),\n             _ => None,\n         }\n     }\n \n+    fn as_raw_ptr(&self) -> Option<(&Ty, Mutability)> {\n+        match self.kind(Interner) {\n+            TyKind::Raw(mutability, ty) => Some((ty, *mutability)),\n+            _ => None,\n+        }\n+    }\n+\n     fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)> {\n         match self.kind(Interner) {\n             TyKind::Ref(mutability, _, ty) => Some((ty, Rawness::Ref, *mutability)),"}, {"sha": "0df2b39bbdc91e9e12082a7efe540bfaa50983f0", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -7,10 +7,11 @@ use hir_def::{\n     path::Path,\n     resolver::{Resolver, ValueNs},\n     type_ref::ConstRef,\n-    DefWithBodyId, EnumVariantId,\n+    EnumVariantId, GeneralConstId, StaticId,\n };\n use la_arena::{Idx, RawIdx};\n use stdx::never;\n+use triomphe::Arc;\n \n use crate::{\n     db::HirDatabase, infer::InferenceContext, layout::layout_of_ty, lower::ParamLoweringMode,\n@@ -158,13 +159,17 @@ pub fn usize_const(db: &dyn HirDatabase, value: Option<u128>, krate: CrateId) ->\n     )\n }\n \n-pub fn try_const_usize(c: &Const) -> Option<u128> {\n+pub fn try_const_usize(db: &dyn HirDatabase, c: &Const) -> Option<u128> {\n     match &c.data(Interner).value {\n         chalk_ir::ConstValue::BoundVar(_) => None,\n         chalk_ir::ConstValue::InferenceVar(_) => None,\n         chalk_ir::ConstValue::Placeholder(_) => None,\n         chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n             ConstScalar::Bytes(x, _) => Some(u128::from_le_bytes(pad16(&x, false))),\n+            ConstScalar::UnevaluatedConst(c, subst) => {\n+                let ec = db.const_eval(*c, subst.clone()).ok()?;\n+                try_const_usize(db, &ec)\n+            }\n             _ => None,\n         },\n     }\n@@ -173,12 +178,20 @@ pub fn try_const_usize(c: &Const) -> Option<u128> {\n pub(crate) fn const_eval_recover(\n     _: &dyn HirDatabase,\n     _: &[String],\n-    _: &DefWithBodyId,\n+    _: &GeneralConstId,\n     _: &Substitution,\n ) -> Result<Const, ConstEvalError> {\n     Err(ConstEvalError::MirLowerError(MirLowerError::Loop))\n }\n \n+pub(crate) fn const_eval_static_recover(\n+    _: &dyn HirDatabase,\n+    _: &[String],\n+    _: &StaticId,\n+) -> Result<Const, ConstEvalError> {\n+    Err(ConstEvalError::MirLowerError(MirLowerError::Loop))\n+}\n+\n pub(crate) fn const_eval_discriminant_recover(\n     _: &dyn HirDatabase,\n     _: &[String],\n@@ -189,11 +202,28 @@ pub(crate) fn const_eval_discriminant_recover(\n \n pub(crate) fn const_eval_query(\n     db: &dyn HirDatabase,\n-    def: DefWithBodyId,\n+    def: GeneralConstId,\n     subst: Substitution,\n ) -> Result<Const, ConstEvalError> {\n-    let body = db.mir_body(def)?;\n-    let c = interpret_mir(db, &body, subst, false)?;\n+    let body = match def {\n+        GeneralConstId::ConstId(c) => db.mir_body(c.into())?,\n+        GeneralConstId::AnonymousConstId(c) => {\n+            let (def, root) = db.lookup_intern_anonymous_const(c);\n+            let body = db.body(def);\n+            let infer = db.infer(def);\n+            Arc::new(lower_to_mir(db, def, &body, &infer, root)?)\n+        }\n+    };\n+    let c = interpret_mir(db, &body, subst, false).0?;\n+    Ok(c)\n+}\n+\n+pub(crate) fn const_eval_static_query(\n+    db: &dyn HirDatabase,\n+    def: StaticId,\n+) -> Result<Const, ConstEvalError> {\n+    let body = db.mir_body(def.into())?;\n+    let c = interpret_mir(db, &body, Substitution::empty(Interner), false).0?;\n     Ok(c)\n }\n \n@@ -216,8 +246,8 @@ pub(crate) fn const_eval_discriminant_variant(\n         return Ok(value);\n     }\n     let mir_body = db.mir_body(def)?;\n-    let c = interpret_mir(db, &mir_body, Substitution::empty(Interner), false)?;\n-    let c = try_const_usize(&c).unwrap() as i128;\n+    let c = interpret_mir(db, &mir_body, Substitution::empty(Interner), false).0?;\n+    let c = try_const_usize(db, &c).unwrap() as i128;\n     Ok(c)\n }\n \n@@ -241,7 +271,7 @@ pub(crate) fn eval_to_const(\n     }\n     let infer = ctx.clone().resolve_all();\n     if let Ok(mir_body) = lower_to_mir(ctx.db, ctx.owner, &ctx.body, &infer, expr) {\n-        if let Ok(result) = interpret_mir(db, &mir_body, Substitution::empty(Interner), true) {\n+        if let Ok(result) = interpret_mir(db, &mir_body, Substitution::empty(Interner), true).0 {\n             return result;\n         }\n     }"}, {"sha": "b4e276ea3406b161b9c9bdf61fea989d2e30b49f", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 109, "deletions": 3, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -158,6 +158,22 @@ fn casts() {\n     );\n }\n \n+#[test]\n+fn raw_pointer_equality() {\n+    check_number(\n+        r#\"\n+        //- minicore: copy, eq\n+        const GOAL: bool = {\n+            let a = 2;\n+            let p1 = a as *const i32;\n+            let p2 = a as *const i32;\n+            p1 == p2\n+        };\n+        \"#,\n+        1,\n+    );\n+}\n+\n #[test]\n fn locals() {\n     check_number(\n@@ -975,6 +991,22 @@ fn pattern_matching_literal() {\n     );\n }\n \n+#[test]\n+fn pattern_matching_slice() {\n+    check_number(\n+        r#\"\n+    //- minicore: slice, index, coerce_unsized, copy\n+    const fn f(x: &[usize]) -> usize {\n+        match x {\n+            [a, b @ .., c, d] => *a + b.len() + *c + *d,\n+        }\n+    }\n+    const GOAL: usize = f(&[10, 20, 3, 15, 1000, 60, 16]);\n+        \"#,\n+        10 + 4 + 60 + 16,\n+    );\n+}\n+\n #[test]\n fn pattern_matching_ergonomics() {\n     check_number(\n@@ -1808,6 +1840,28 @@ fn array_and_index() {\n     const GOAL: usize = [1, 2, 3, 4, 5].len();\"#,\n         5,\n     );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: [u16; 5] = [1, 2, 3, 4, 5];\"#,\n+        1 + (2 << 16) + (3 << 32) + (4 << 48) + (5 << 64),\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: [u16; 5] = [12; 5];\"#,\n+        12 + (12 << 16) + (12 << 32) + (12 << 48) + (12 << 64),\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const LEN: usize = 4;\n+    const GOAL: u16 = {\n+        let x = [7; LEN];\n+        x[2]\n+    }\"#,\n+        7,\n+    );\n }\n \n #[test]\n@@ -1903,7 +1957,7 @@ fn enums() {\n         \"#,\n     );\n     let r = eval_goal(&db, file_id).unwrap();\n-    assert_eq!(try_const_usize(&r), Some(1));\n+    assert_eq!(try_const_usize(&db, &r), Some(1));\n }\n \n #[test]\n@@ -1931,6 +1985,29 @@ fn const_transfer_memory() {\n     );\n }\n \n+#[test]\n+fn anonymous_const_block() {\n+    check_number(\n+        r#\"\n+    extern \"rust-intrinsic\" {\n+        pub fn size_of<T>() -> usize;\n+    }\n+\n+    const fn f<T>() -> usize {\n+        let r = const { size_of::<T>() };\n+        r\n+    }\n+\n+    const GOAL: usize = {\n+        let x = const { 2 + const { 3 } };\n+        let y = f::<i32>();\n+        x + y\n+    };\n+    \"#,\n+        9,\n+    );\n+}\n+\n #[test]\n fn const_impl_assoc() {\n     check_number(\n@@ -1939,9 +2016,9 @@ fn const_impl_assoc() {\n     impl U5 {\n         const VAL: usize = 5;\n     }\n-    const GOAL: usize = U5::VAL;\n+    const GOAL: usize = U5::VAL + <U5>::VAL;\n     \"#,\n-        5,\n+        10,\n     );\n }\n \n@@ -1972,6 +2049,35 @@ fn const_generic_subst_assoc_const_impl() {\n     );\n }\n \n+#[test]\n+fn associated_types() {\n+    check_number(\n+        r#\"\n+    trait Tr {\n+        type Item;\n+        fn get_item(&self) -> Self::Item;\n+    }\n+\n+    struct X(i32);\n+    struct Y(i32);\n+\n+    impl Tr for X {\n+        type Item = Y;\n+        fn get_item(&self) -> Self::Item {\n+            Y(self.0 + 2)\n+        }\n+    }\n+\n+    fn my_get_item<T: Tr>(x: T) -> <T as Tr>::Item {\n+        x.get_item()\n+    }\n+\n+    const GOAL: i32 = my_get_item(X(3)).0;\n+    \"#,\n+        5,\n+    );\n+}\n+\n #[test]\n fn const_trait_assoc() {\n     check_number("}, {"sha": "0dd120e5b9ea17da6f38c52fdc12440b7d4a8dd4", "filename": "crates/hir-ty/src/consteval/tests/intrinsics.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -289,3 +289,31 @@ fn copy() {\n         19,\n     );\n }\n+\n+#[test]\n+fn ctpop() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn ctpop<T: Copy>(x: T) -> T;\n+        }\n+\n+        const GOAL: i64 = ctpop(-29);\n+        \"#,\n+        61,\n+    );\n+}\n+\n+#[test]\n+fn cttz() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn cttz<T: Copy>(x: T) -> T;\n+        }\n+\n+        const GOAL: i64 = cttz(-24);\n+        \"#,\n+        3,\n+    );\n+}"}, {"sha": "dcdeea02aee132967d5a87a08c9b7fe4d36970d0", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -6,8 +6,8 @@ use std::sync;\n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n     db::DefDatabase, hir::ExprId, layout::TargetDataLayout, AdtId, BlockId, ConstParamId,\n-    DefWithBodyId, EnumVariantId, FunctionId, GenericDefId, ImplId, LifetimeParamId, LocalFieldId,\n-    TypeOrConstParamId, VariantId,\n+    DefWithBodyId, EnumVariantId, FunctionId, GeneralConstId, GenericDefId, ImplId,\n+    LifetimeParamId, LocalFieldId, StaticId, TypeOrConstParamId, VariantId,\n };\n use la_arena::ArenaMap;\n use smallvec::SmallVec;\n@@ -60,7 +60,12 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n \n     #[salsa::invoke(crate::consteval::const_eval_query)]\n     #[salsa::cycle(crate::consteval::const_eval_recover)]\n-    fn const_eval(&self, def: DefWithBodyId, subst: Substitution) -> Result<Const, ConstEvalError>;\n+    fn const_eval(&self, def: GeneralConstId, subst: Substitution)\n+        -> Result<Const, ConstEvalError>;\n+\n+    #[salsa::invoke(crate::consteval::const_eval_static_query)]\n+    #[salsa::cycle(crate::consteval::const_eval_static_recover)]\n+    fn const_eval_static(&self, def: StaticId) -> Result<Const, ConstEvalError>;\n \n     #[salsa::invoke(crate::consteval::const_eval_discriminant_variant)]\n     #[salsa::cycle(crate::consteval::const_eval_discriminant_recover)]"}, {"sha": "038c2eafd2ecfe1b02f2de5c5029e1098f8d5912", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -420,13 +420,8 @@ impl HirDisplay for Const {\n             ConstValue::Concrete(c) => match &c.interned {\n                 ConstScalar::Bytes(b, m) => render_const_scalar(f, &b, m, &data.ty),\n                 ConstScalar::UnevaluatedConst(c, parameters) => {\n-                    let const_data = f.db.const_data(*c);\n-                    write!(\n-                        f,\n-                        \"{}\",\n-                        const_data.name.as_ref().and_then(|x| x.as_str()).unwrap_or(\"_\")\n-                    )?;\n-                    hir_fmt_generics(f, parameters, Some((*c).into()))?;\n+                    write!(f, \"{}\", c.name(f.db.upcast()))?;\n+                    hir_fmt_generics(f, parameters, c.generic_def(f.db.upcast()))?;\n                     Ok(())\n                 }\n                 ConstScalar::Unknown => f.write_char('_'),"}, {"sha": "cd8bd10255da86bd4a688c530916b26dce53c376", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -123,9 +123,14 @@ impl HirPlace {\n     fn ty(&self, ctx: &mut InferenceContext<'_>) -> Ty {\n         let mut ty = ctx.table.resolve_completely(ctx.result[self.local].clone());\n         for p in &self.projections {\n-            ty = p.projected_ty(ty, ctx.db, |_, _, _| {\n-                unreachable!(\"Closure field only happens in MIR\");\n-            });\n+            ty = p.projected_ty(\n+                ty,\n+                ctx.db,\n+                |_, _, _| {\n+                    unreachable!(\"Closure field only happens in MIR\");\n+                },\n+                ctx.owner.module(ctx.db.upcast()).krate(),\n+            );\n         }\n         ty.clone()\n     }\n@@ -447,7 +452,6 @@ impl InferenceContext<'_> {\n                 }\n             }\n             Expr::Async { statements, tail, .. }\n-            | Expr::Const { statements, tail, .. }\n             | Expr::Unsafe { statements, tail, .. }\n             | Expr::Block { statements, tail, .. } => {\n                 for s in statements.iter() {\n@@ -605,6 +609,7 @@ impl InferenceContext<'_> {\n             | Expr::Continue { .. }\n             | Expr::Path(_)\n             | Expr::Literal(_)\n+            | Expr::Const(_)\n             | Expr::Underscore => (),\n         }\n     }"}, {"sha": "361f78329e812b8eca4efa124374ca7495a0da5c", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -6,7 +6,7 @@ use std::{\n };\n \n use chalk_ir::{\n-    cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyKind, TyVariableKind,\n+    cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n };\n use hir_def::{\n     generics::TypeOrConstParamData,\n@@ -39,7 +39,7 @@ use crate::{\n     traits::FnTrait,\n     utils::{generics, Generics},\n     Adjust, Adjustment, AdtId, AutoBorrow, Binders, CallableDefId, FnPointer, FnSig, FnSubst,\n-    Interner, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt,\n+    Interner, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n use super::{\n@@ -164,9 +164,10 @@ impl<'a> InferenceContext<'a> {\n             Expr::Unsafe { id, statements, tail } => {\n                 self.infer_block(tgt_expr, *id, statements, *tail, None, expected)\n             }\n-            Expr::Const { id, statements, tail } => {\n+            Expr::Const(id) => {\n                 self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n-                    this.infer_block(tgt_expr, *id, statements, *tail, None, expected)\n+                    let (_, expr) = this.db.lookup_intern_anonymous_const(*id);\n+                    this.infer_expr(expr, expected)\n                 })\n                 .1\n             }"}, {"sha": "7794bd5c39f92c28dee4f36f2926c170dfc62ad7", "filename": "crates/hir-ty/src/infer/mutability.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -42,10 +42,13 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_mut_expr(else_branch, Mutability::Not);\n                 }\n             }\n+            Expr::Const(id) => {\n+                let (_, expr) = self.db.lookup_intern_anonymous_const(*id);\n+                self.infer_mut_expr(expr, Mutability::Not);\n+            }\n             Expr::Let { pat, expr } => self.infer_mut_expr(*expr, self.pat_bound_mutability(*pat)),\n             Expr::Block { id: _, statements, tail, label: _ }\n             | Expr::Async { id: _, statements, tail }\n-            | Expr::Const { id: _, statements, tail }\n             | Expr::Unsafe { id: _, statements, tail } => {\n                 for st in statements.iter() {\n                     match st {"}, {"sha": "80a0d3090125e855db1b64d497a675fe0f32611f", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -379,7 +379,7 @@ impl<'a> InferenceContext<'a> {\n         if let &Some(slice_pat_id) = slice {\n             let rest_pat_ty = match expected.kind(Interner) {\n                 TyKind::Array(_, length) => {\n-                    let len = try_const_usize(length);\n+                    let len = try_const_usize(self.db, length);\n                     let len =\n                         len.and_then(|len| len.checked_sub((prefix.len() + suffix.len()) as u128));\n                     TyKind::Array(elem_ty.clone(), usize_const(self.db, len, self.resolver.krate()))"}, {"sha": "e5038543b68e6ac50a5b1130cb2d664f5b1663a2", "filename": "crates/hir-ty/src/inhabitedness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -82,7 +82,7 @@ impl TypeVisitor<Interner> for UninhabitedFrom<'_> {\n             TyKind::Adt(adt, subst) => self.visit_adt(adt.0, subst),\n             TyKind::Never => BREAK_VISIBLY_UNINHABITED,\n             TyKind::Tuple(..) => ty.super_visit_with(self, outer_binder),\n-            TyKind::Array(item_ty, len) => match try_const_usize(len) {\n+            TyKind::Array(item_ty, len) => match try_const_usize(self.db, len) {\n                 Some(0) | None => CONTINUE_OPAQUELY_INHABITED,\n                 Some(1..) => item_ty.super_visit_with(self, outer_binder),\n             },"}, {"sha": "5c143cfcf94f4b148e6309f1ac0fbe7552c3a089", "filename": "crates/hir-ty/src/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -148,7 +148,7 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n             cx.univariant(dl, &fields, &ReprOptions::default(), kind).ok_or(LayoutError::Unknown)?\n         }\n         TyKind::Array(element, count) => {\n-            let count = try_const_usize(&count).ok_or(LayoutError::UserError(\n+            let count = try_const_usize(db, &count).ok_or(LayoutError::UserError(\n                 \"unevaluated or mistyped const generic parameter\".to_string(),\n             ))? as u64;\n             let element = layout_of_ty(db, element, krate)?;"}, {"sha": "ea5186e9a9c0f8ceaa48ad9ff2d8ba8752add247", "filename": "crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -230,7 +230,8 @@ fn associated_types() {\n         }\n \n         struct Foo<A: Tr>(<A as Tr>::Ty);\n-        struct Goal(Foo<i32>);\n+        struct Bar<A: Tr>(A::Ty);\n+        struct Goal(Foo<i32>, Bar<i32>, <i32 as Tr>::Ty);\n     }\n }\n "}, {"sha": "55803960e1a09278c943bbaf9e7d82ff8d18b0da", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -44,7 +44,7 @@ use chalk_ir::{\n     NoSolution, TyData,\n };\n use either::Either;\n-use hir_def::{hir::ExprId, type_ref::Rawness, ConstId, TypeOrConstParamId};\n+use hir_def::{hir::ExprId, type_ref::Rawness, GeneralConstId, TypeOrConstParamId};\n use hir_expand::name;\n use la_arena::{Arena, Idx};\n use mir::{MirEvalError, VTableMap};\n@@ -180,7 +180,7 @@ pub enum ConstScalar {\n     Bytes(Vec<u8>, MemoryMap),\n     // FIXME: this is a hack to get around chalk not being able to represent unevaluatable\n     // constants\n-    UnevaluatedConst(ConstId, Substitution),\n+    UnevaluatedConst(GeneralConstId, Substitution),\n     /// Case of an unknown value that rustc might know but we don't\n     // FIXME: this is a hack to get around chalk not being able to represent unevaluatable\n     // constants"}, {"sha": "bf1e875858a0f4baf9aa81a8dfea307e533675af", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -699,15 +699,24 @@ pub fn lookup_impl_method(\n     };\n \n     let name = &db.function_data(func).name;\n-    lookup_impl_assoc_item_for_trait_ref(trait_ref, db, env, name)\n+    let Some((impl_fn, impl_subst)) = lookup_impl_assoc_item_for_trait_ref(trait_ref, db, env, name)\n         .and_then(|assoc| {\n             if let (AssocItemId::FunctionId(id), subst) = assoc {\n                 Some((id, subst))\n             } else {\n                 None\n             }\n         })\n-        .unwrap_or((func, fn_subst))\n+    else {\n+        return (func, fn_subst);\n+    };\n+    (\n+        impl_fn,\n+        Substitution::from_iter(\n+            Interner,\n+            fn_subst.iter(Interner).take(fn_params).chain(impl_subst.iter(Interner)),\n+        ),\n+    )\n }\n \n fn lookup_impl_assoc_item_for_trait_ref("}, {"sha": "11c35dfb8a878019438265a4807d75509f632bec", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -3,10 +3,11 @@\n use std::{fmt::Display, iter};\n \n use crate::{\n-    db::HirDatabase, display::HirDisplay, infer::PointerCast, lang_items::is_box, mapping::ToChalk,\n-    CallableDefId, ClosureId, Const, ConstScalar, InferenceResult, Interner, MemoryMap,\n-    Substitution, Ty, TyKind,\n+    consteval::usize_const, db::HirDatabase, display::HirDisplay, infer::PointerCast,\n+    lang_items::is_box, mapping::ToChalk, CallableDefId, ClosureId, Const, ConstScalar,\n+    InferenceResult, Interner, MemoryMap, Substitution, Ty, TyKind,\n };\n+use base_db::CrateId;\n use chalk_ir::Mutability;\n use hir_def::{\n     hir::{BindingId, Expr, ExprId, Ordering, PatId},\n@@ -114,8 +115,8 @@ pub enum ProjectionElem<V, T> {\n     // FIXME: get rid of this, and use FieldId for tuples and closures\n     TupleOrClosureField(usize),\n     Index(V),\n-    ConstantIndex { offset: u64, min_length: u64, from_end: bool },\n-    Subslice { from: u64, to: u64, from_end: bool },\n+    ConstantIndex { offset: u64, from_end: bool },\n+    Subslice { from: u64, to: u64 },\n     //Downcast(Option<Symbol>, VariantIdx),\n     OpaqueCast(T),\n }\n@@ -126,6 +127,7 @@ impl<V, T> ProjectionElem<V, T> {\n         base: Ty,\n         db: &dyn HirDatabase,\n         closure_field: impl FnOnce(ClosureId, &Substitution, usize) -> Ty,\n+        krate: CrateId,\n     ) -> Ty {\n         match self {\n             ProjectionElem::Deref => match &base.data(Interner).kind {\n@@ -163,16 +165,34 @@ impl<V, T> ProjectionElem<V, T> {\n                     return TyKind::Error.intern(Interner);\n                 }\n             },\n-            ProjectionElem::Index(_) => match &base.data(Interner).kind {\n-                TyKind::Array(inner, _) | TyKind::Slice(inner) => inner.clone(),\n+            ProjectionElem::ConstantIndex { .. } | ProjectionElem::Index(_) => {\n+                match &base.data(Interner).kind {\n+                    TyKind::Array(inner, _) | TyKind::Slice(inner) => inner.clone(),\n+                    _ => {\n+                        never!(\"Overloaded index is not a projection\");\n+                        return TyKind::Error.intern(Interner);\n+                    }\n+                }\n+            }\n+            &ProjectionElem::Subslice { from, to } => match &base.data(Interner).kind {\n+                TyKind::Array(inner, c) => {\n+                    let next_c = usize_const(\n+                        db,\n+                        match try_const_usize(db, c) {\n+                            None => None,\n+                            Some(x) => x.checked_sub(u128::from(from + to)),\n+                        },\n+                        krate,\n+                    );\n+                    TyKind::Array(inner.clone(), next_c).intern(Interner)\n+                }\n+                TyKind::Slice(_) => base.clone(),\n                 _ => {\n-                    never!(\"Overloaded index is not a projection\");\n+                    never!(\"Subslice projection should only happen on slice and array\");\n                     return TyKind::Error.intern(Interner);\n                 }\n             },\n-            ProjectionElem::ConstantIndex { .. }\n-            | ProjectionElem::Subslice { .. }\n-            | ProjectionElem::OpaqueCast(_) => {\n+            ProjectionElem::OpaqueCast(_) => {\n                 never!(\"We don't emit these yet\");\n                 return TyKind::Error.intern(Interner);\n             }\n@@ -182,12 +202,24 @@ impl<V, T> ProjectionElem<V, T> {\n \n type PlaceElem = ProjectionElem<LocalId, Ty>;\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Place {\n     pub local: LocalId,\n     pub projection: Vec<PlaceElem>,\n }\n \n+impl Place {\n+    fn is_parent(&self, child: &Place) -> bool {\n+        self.local == child.local && child.projection.starts_with(&self.projection)\n+    }\n+\n+    fn iterate_over_parents(&self) -> impl Iterator<Item = Place> + '_ {\n+        (0..self.projection.len())\n+            .map(|x| &self.projection[0..x])\n+            .map(|x| Place { local: self.local, projection: x.to_vec() })\n+    }\n+}\n+\n impl From<LocalId> for Place {\n     fn from(local: LocalId) -> Self {\n         Self { local, projection: vec![] }\n@@ -941,7 +973,6 @@ pub struct MirBody {\n     pub locals: Arena<Local>,\n     pub start_block: BasicBlockId,\n     pub owner: DefWithBodyId,\n-    pub arg_count: usize,\n     pub binding_locals: ArenaMap<BindingId, LocalId>,\n     pub param_locals: Vec<LocalId>,\n     /// This field stores the closures directly owned by this body. It is used\n@@ -1029,10 +1060,6 @@ impl MirBody {\n     }\n }\n \n-fn const_as_usize(c: &Const) -> usize {\n-    try_const_usize(c).unwrap() as usize\n-}\n-\n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub enum MirSpan {\n     ExprId(ExprId),"}, {"sha": "a6af4e75d45d75a65b545e230395429866ab8ccb", "filename": "crates/hir-ty/src/mir/borrowck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -155,8 +155,10 @@ fn ever_initialized_map(body: &MirBody) -> ArenaMap<BasicBlockId, ArenaMap<Local\n                 }\n                 target.into_iter().chain(cleanup.into_iter()).copied().collect()\n             }\n-            TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n+            TerminatorKind::Drop { target, unwind, place: _ } => {\n+                Some(target).into_iter().chain(unwind.into_iter()).copied().collect()\n+            }\n+            TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::GeneratorDrop"}, {"sha": "b16b77379dea91e7ad7b8dcd4747a156be1967bd", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 371, "deletions": 91, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -5,45 +5,48 @@ use std::{borrow::Cow, collections::HashMap, fmt::Write, iter, ops::Range};\n use base_db::{CrateId, FileId};\n use chalk_ir::{\n     fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable},\n-    DebruijnIndex, Mutability,\n+    DebruijnIndex, Mutability, ProjectionTy,\n };\n use either::Either;\n use hir_def::{\n     builtin_type::BuiltinType,\n+    data::adt::{StructFlags, VariantData},\n     lang_item::{lang_attr, LangItem},\n     layout::{TagEncoding, Variants},\n-    AdtId, DefWithBodyId, EnumVariantId, FunctionId, HasModule, ItemContainerId, Lookup, StaticId,\n-    TypeOrConstParamId, VariantId,\n+    AdtId, DefWithBodyId, EnumVariantId, FunctionId, GeneralConstId, HasModule, ItemContainerId,\n+    Lookup, StaticId, TypeOrConstParamId, VariantId,\n };\n use hir_expand::{name::Name, InFile};\n use intern::Interned;\n use la_arena::ArenaMap;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::{SyntaxNodePtr, TextRange};\n use triomphe::Arc;\n \n use crate::{\n-    consteval::{intern_const_scalar, ConstEvalError},\n+    consteval::{intern_const_scalar, try_const_usize, ConstEvalError},\n     db::HirDatabase,\n     display::{ClosureStyle, HirDisplay},\n     from_placeholder_idx,\n     infer::{normalize, PointerCast},\n     layout::{layout_of_ty, Layout, LayoutError, RustcEnumVariantIdx},\n     mapping::from_chalk,\n     method_resolution::{is_dyn_method, lookup_impl_const, lookup_impl_method},\n-    static_lifetime,\n+    name, static_lifetime,\n     traits::FnTrait,\n     utils::{generics, ClosureSubst, Generics},\n     CallableDefId, ClosureId, Const, ConstScalar, FnDefId, GenericArgData, Interner, MemoryMap,\n     Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind,\n };\n \n use super::{\n-    const_as_usize, return_slot, AggregateKind, BinOp, CastKind, LocalId, MirBody, MirLowerError,\n-    MirSpan, Operand, Place, ProjectionElem, Rvalue, StatementKind, TerminatorKind, UnOp,\n+    return_slot, AggregateKind, BinOp, CastKind, LocalId, MirBody, MirLowerError, MirSpan, Operand,\n+    Place, ProjectionElem, Rvalue, StatementKind, TerminatorKind, UnOp,\n };\n \n mod shim;\n+#[cfg(test)]\n+mod tests;\n \n macro_rules! from_bytes {\n     ($ty:tt, $value:expr) => {\n@@ -87,6 +90,33 @@ impl VTableMap {\n     }\n }\n \n+#[derive(Debug, Default, Clone, PartialEq, Eq)]\n+struct TlsData {\n+    keys: Vec<u128>,\n+}\n+\n+impl TlsData {\n+    fn create_key(&mut self) -> usize {\n+        self.keys.push(0);\n+        self.keys.len() - 1\n+    }\n+\n+    fn get_key(&mut self, key: usize) -> Result<u128> {\n+        let r = self.keys.get(key).ok_or_else(|| {\n+            MirEvalError::UndefinedBehavior(format!(\"Getting invalid tls key {key}\"))\n+        })?;\n+        Ok(*r)\n+    }\n+\n+    fn set_key(&mut self, key: usize, value: u128) -> Result<()> {\n+        let r = self.keys.get_mut(key).ok_or_else(|| {\n+            MirEvalError::UndefinedBehavior(format!(\"Setting invalid tls key {key}\"))\n+        })?;\n+        *r = value;\n+        Ok(())\n+    }\n+}\n+\n pub struct Evaluator<'a> {\n     db: &'a dyn HirDatabase,\n     trait_env: Arc<TraitEnvironment>,\n@@ -99,6 +129,9 @@ pub struct Evaluator<'a> {\n     /// store the type as an interned id in place of function and vtable pointers, and we recover back the type at the\n     /// time of use.\n     vtable_map: VTableMap,\n+    thread_local_storage: TlsData,\n+    stdout: Vec<u8>,\n+    stderr: Vec<u8>,\n     crate_id: CrateId,\n     // FIXME: This is a workaround, see the comment on `interpret_mir`\n     assert_placeholder_ty_is_unused: bool,\n@@ -259,6 +292,7 @@ pub enum MirEvalError {\n     TargetDataLayoutNotAvailable,\n     InvalidVTableId(usize),\n     CoerceUnsizedError(Ty),\n+    LangItemNotFound(LangItem),\n }\n \n impl MirEvalError {\n@@ -350,6 +384,7 @@ impl MirEvalError {\n             | MirEvalError::StackOverflow\n             | MirEvalError::TargetDataLayoutNotAvailable\n             | MirEvalError::CoerceUnsizedError(_)\n+            | MirEvalError::LangItemNotFound(_)\n             | MirEvalError::InvalidVTableId(_) => writeln!(f, \"{:?}\", err)?,\n         }\n         Ok(())\n@@ -362,6 +397,7 @@ impl std::fmt::Debug for MirEvalError {\n             Self::ConstEvalError(arg0, arg1) => {\n                 f.debug_tuple(\"ConstEvalError\").field(arg0).field(arg1).finish()\n             }\n+            Self::LangItemNotFound(arg0) => f.debug_tuple(\"LangItemNotFound\").field(arg0).finish(),\n             Self::LayoutError(arg0, arg1) => {\n                 f.debug_tuple(\"LayoutError\").field(arg0).field(arg1).finish()\n             }\n@@ -405,11 +441,32 @@ impl std::fmt::Debug for MirEvalError {\n \n type Result<T> = std::result::Result<T, MirEvalError>;\n \n+#[derive(Debug, Default)]\n+struct DropFlags {\n+    need_drop: FxHashSet<Place>,\n+}\n+\n+impl DropFlags {\n+    fn add_place(&mut self, p: Place) {\n+        if p.iterate_over_parents().any(|x| self.need_drop.contains(&x)) {\n+            return;\n+        }\n+        self.need_drop.retain(|x| !p.is_parent(x));\n+        self.need_drop.insert(p);\n+    }\n+\n+    fn remove_place(&mut self, p: &Place) -> bool {\n+        // FIXME: replace parents with parts\n+        self.need_drop.remove(p)\n+    }\n+}\n+\n #[derive(Debug)]\n struct Locals<'a> {\n-    ptr: &'a ArenaMap<LocalId, Address>,\n+    ptr: &'a ArenaMap<LocalId, Interval>,\n     body: &'a MirBody,\n     subst: &'a Substitution,\n+    drop_flags: DropFlags,\n }\n \n pub fn interpret_mir(\n@@ -422,18 +479,30 @@ pub fn interpret_mir(\n     // a zero size, hoping that they are all outside of our current body. Even without a fix for #7434, we can\n     // (and probably should) do better here, for example by excluding bindings outside of the target expression.\n     assert_placeholder_ty_is_unused: bool,\n-) -> Result<Const> {\n+) -> (Result<Const>, String, String) {\n     let ty = body.locals[return_slot()].ty.clone();\n     let mut evaluator = Evaluator::new(db, body, assert_placeholder_ty_is_unused);\n-    let ty = evaluator.ty_filler(&ty, &subst, body.owner)?;\n-    let bytes = evaluator.interpret_mir(&body, None.into_iter(), subst.clone())?;\n-    let mut memory_map = evaluator.create_memory_map(\n-        &bytes,\n-        &ty,\n-        &Locals { ptr: &ArenaMap::new(), body: &body, subst: &subst },\n-    )?;\n-    memory_map.vtable = evaluator.vtable_map;\n-    return Ok(intern_const_scalar(ConstScalar::Bytes(bytes, memory_map), ty));\n+    let x: Result<Const> = (|| {\n+        let ty = evaluator.ty_filler(&ty, &subst, body.owner)?;\n+        let bytes = evaluator.interpret_mir(&body, None.into_iter(), subst.clone())?;\n+        let mut memory_map = evaluator.create_memory_map(\n+            &bytes,\n+            &ty,\n+            &Locals {\n+                ptr: &ArenaMap::new(),\n+                body: &body,\n+                subst: &subst,\n+                drop_flags: DropFlags::default(),\n+            },\n+        )?;\n+        memory_map.vtable = evaluator.vtable_map.clone();\n+        return Ok(intern_const_scalar(ConstScalar::Bytes(bytes, memory_map), ty));\n+    })();\n+    (\n+        x,\n+        String::from_utf8_lossy(&evaluator.stdout).into_owned(),\n+        String::from_utf8_lossy(&evaluator.stderr).into_owned(),\n+    )\n }\n \n impl Evaluator<'_> {\n@@ -448,13 +517,16 @@ impl Evaluator<'_> {\n             stack: vec![0],\n             heap: vec![0],\n             vtable_map: VTableMap::default(),\n+            thread_local_storage: TlsData::default(),\n             static_locations: HashMap::default(),\n             db,\n             trait_env,\n             crate_id,\n+            stdout: vec![],\n+            stderr: vec![],\n             assert_placeholder_ty_is_unused,\n             stack_depth_limit: 100,\n-            execution_limit: 100_000,\n+            execution_limit: 1000_000,\n         }\n     }\n \n@@ -485,43 +557,95 @@ impl Evaluator<'_> {\n         &'a self,\n         p: &Place,\n         locals: &'a Locals<'a>,\n-    ) -> Result<(Address, Ty, Option<Interval>)> {\n-        let mut addr = locals.ptr[p.local];\n+    ) -> Result<(Address, Ty, Option<IntervalOrOwned>)> {\n+        let mut addr = locals.ptr[p.local].addr;\n         let mut ty: Ty =\n             self.ty_filler(&locals.body.locals[p.local].ty, locals.subst, locals.body.owner)?;\n-        let mut metadata = None; // locals are always sized\n+        let mut metadata: Option<IntervalOrOwned> = None; // locals are always sized\n         for proj in &p.projection {\n             let prev_ty = ty.clone();\n-            ty = proj.projected_ty(ty, self.db, |c, subst, f| {\n-                let (def, _) = self.db.lookup_intern_closure(c.into());\n-                let infer = self.db.infer(def);\n-                let (captures, _) = infer.closure_info(&c);\n-                let parent_subst = ClosureSubst(subst).parent_subst();\n-                captures\n-                    .get(f)\n-                    .expect(\"broken closure field\")\n-                    .ty\n-                    .clone()\n-                    .substitute(Interner, parent_subst)\n-            });\n+            ty = proj.projected_ty(\n+                ty,\n+                self.db,\n+                |c, subst, f| {\n+                    let (def, _) = self.db.lookup_intern_closure(c.into());\n+                    let infer = self.db.infer(def);\n+                    let (captures, _) = infer.closure_info(&c);\n+                    let parent_subst = ClosureSubst(subst).parent_subst();\n+                    captures\n+                        .get(f)\n+                        .expect(\"broken closure field\")\n+                        .ty\n+                        .clone()\n+                        .substitute(Interner, parent_subst)\n+                },\n+                self.crate_id,\n+            );\n             match proj {\n                 ProjectionElem::Deref => {\n                     metadata = if self.size_align_of(&ty, locals)?.is_none() {\n-                        Some(Interval { addr: addr.offset(self.ptr_size()), size: self.ptr_size() })\n+                        Some(\n+                            Interval { addr: addr.offset(self.ptr_size()), size: self.ptr_size() }\n+                                .into(),\n+                        )\n                     } else {\n                         None\n                     };\n                     let x = from_bytes!(usize, self.read_memory(addr, self.ptr_size())?);\n                     addr = Address::from_usize(x);\n                 }\n                 ProjectionElem::Index(op) => {\n-                    let offset =\n-                        from_bytes!(usize, self.read_memory(locals.ptr[*op], self.ptr_size())?);\n+                    let offset = from_bytes!(\n+                        usize,\n+                        self.read_memory(locals.ptr[*op].addr, self.ptr_size())?\n+                    );\n+                    metadata = None; // Result of index is always sized\n+                    let ty_size =\n+                        self.size_of_sized(&ty, locals, \"array inner type should be sized\")?;\n+                    addr = addr.offset(ty_size * offset);\n+                }\n+                &ProjectionElem::ConstantIndex { from_end, offset } => {\n+                    let offset = if from_end {\n+                        let len = match prev_ty.kind(Interner) {\n+                            TyKind::Array(_, c) => match try_const_usize(self.db, c) {\n+                                Some(x) => x as u64,\n+                                None => {\n+                                    not_supported!(\"indexing array with unknown const from end\")\n+                                }\n+                            },\n+                            TyKind::Slice(_) => match metadata {\n+                                Some(x) => from_bytes!(u64, x.get(self)?),\n+                                None => not_supported!(\"slice place without metadata\"),\n+                            },\n+                            _ => not_supported!(\"bad type for const index\"),\n+                        };\n+                        (len - offset - 1) as usize\n+                    } else {\n+                        offset as usize\n+                    };\n                     metadata = None; // Result of index is always sized\n                     let ty_size =\n                         self.size_of_sized(&ty, locals, \"array inner type should be sized\")?;\n                     addr = addr.offset(ty_size * offset);\n                 }\n+                &ProjectionElem::Subslice { from, to } => {\n+                    let inner_ty = match &ty.data(Interner).kind {\n+                        TyKind::Array(inner, _) | TyKind::Slice(inner) => inner.clone(),\n+                        _ => TyKind::Error.intern(Interner),\n+                    };\n+                    metadata = match metadata {\n+                        Some(x) => {\n+                            let prev_len = from_bytes!(u64, x.get(self)?);\n+                            Some(IntervalOrOwned::Owned(\n+                                (prev_len - from - to).to_le_bytes().to_vec(),\n+                            ))\n+                        }\n+                        None => None,\n+                    };\n+                    let ty_size =\n+                        self.size_of_sized(&inner_ty, locals, \"array inner type should be sized\")?;\n+                    addr = addr.offset(ty_size * (from as usize));\n+                }\n                 &ProjectionElem::TupleOrClosureField(f) => {\n                     let layout = self.layout(&prev_ty)?;\n                     let offset = layout.fields.offset(f).bytes_usize();\n@@ -553,10 +677,6 @@ impl Evaluator<'_> {\n                     // FIXME: support structs with unsized fields\n                     metadata = None;\n                 }\n-                ProjectionElem::ConstantIndex { .. } => {\n-                    not_supported!(\"constant index\")\n-                }\n-                ProjectionElem::Subslice { .. } => not_supported!(\"subslice\"),\n                 ProjectionElem::OpaqueCast(_) => not_supported!(\"opaque cast\"),\n             }\n         }\n@@ -594,7 +714,11 @@ impl Evaluator<'_> {\n         })\n     }\n \n-    fn operand_ty_and_eval(&mut self, o: &Operand, locals: &Locals<'_>) -> Result<IntervalAndTy> {\n+    fn operand_ty_and_eval(\n+        &mut self,\n+        o: &Operand,\n+        locals: &mut Locals<'_>,\n+    ) -> Result<IntervalAndTy> {\n         Ok(IntervalAndTy {\n             interval: self.eval_operand(o, locals)?,\n             ty: self.operand_ty(o, locals)?,\n@@ -613,7 +737,12 @@ impl Evaluator<'_> {\n             return Err(MirEvalError::StackOverflow);\n         }\n         let mut current_block_idx = body.start_block;\n-        let mut locals = Locals { ptr: &ArenaMap::new(), body: &body, subst: &subst };\n+        let mut locals = Locals {\n+            ptr: &ArenaMap::new(),\n+            body: &body,\n+            subst: &subst,\n+            drop_flags: DropFlags::default(),\n+        };\n         let (locals_ptr, stack_size) = {\n             let mut stack_ptr = self.stack.len();\n             let addr = body\n@@ -624,17 +753,18 @@ impl Evaluator<'_> {\n                         self.size_of_sized(&x.ty, &locals, \"no unsized local in extending stack\")?;\n                     let my_ptr = stack_ptr;\n                     stack_ptr += size;\n-                    Ok((id, Stack(my_ptr)))\n+                    Ok((id, Interval { addr: Stack(my_ptr), size }))\n                 })\n                 .collect::<Result<ArenaMap<LocalId, _>>>()?;\n             let stack_size = stack_ptr - self.stack.len();\n             (addr, stack_size)\n         };\n         locals.ptr = &locals_ptr;\n         self.stack.extend(iter::repeat(0).take(stack_size));\n-        let mut remain_args = body.arg_count;\n-        for ((_, addr), value) in locals_ptr.iter().skip(1).zip(args) {\n-            self.write_memory(*addr, &value)?;\n+        let mut remain_args = body.param_locals.len();\n+        for ((l, interval), value) in locals_ptr.iter().skip(1).zip(args) {\n+            locals.drop_flags.add_place(l.into());\n+            interval.write_from_bytes(self, &value)?;\n             if remain_args == 0 {\n                 return Err(MirEvalError::TypeError(\"more arguments provided\"));\n             }\n@@ -654,8 +784,9 @@ impl Evaluator<'_> {\n                 match &statement.kind {\n                     StatementKind::Assign(l, r) => {\n                         let addr = self.place_addr(l, &locals)?;\n-                        let result = self.eval_rvalue(r, &locals)?.to_vec(&self)?;\n+                        let result = self.eval_rvalue(r, &mut locals)?.to_vec(&self)?;\n                         self.write_memory(addr, &result)?;\n+                        locals.drop_flags.add_place(l.clone());\n                     }\n                     StatementKind::Deinit(_) => not_supported!(\"de-init statement\"),\n                     StatementKind::StorageLive(_)\n@@ -678,18 +809,18 @@ impl Evaluator<'_> {\n                     cleanup: _,\n                     from_hir_call: _,\n                 } => {\n-                    let destination = self.place_interval(destination, &locals)?;\n+                    let destination_interval = self.place_interval(destination, &locals)?;\n                     let fn_ty = self.operand_ty(func, &locals)?;\n                     let args = args\n                         .iter()\n-                        .map(|x| self.operand_ty_and_eval(x, &locals))\n+                        .map(|x| self.operand_ty_and_eval(x, &mut locals))\n                         .collect::<Result<Vec<_>>>()?;\n                     match &fn_ty.data(Interner).kind {\n                         TyKind::Function(_) => {\n-                            let bytes = self.eval_operand(func, &locals)?;\n+                            let bytes = self.eval_operand(func, &mut locals)?;\n                             self.exec_fn_pointer(\n                                 bytes,\n-                                destination,\n+                                destination_interval,\n                                 &args,\n                                 &locals,\n                                 terminator.span,\n@@ -699,46 +830,41 @@ impl Evaluator<'_> {\n                             self.exec_fn_def(\n                                 *def,\n                                 generic_args,\n-                                destination,\n+                                destination_interval,\n                                 &args,\n                                 &locals,\n                                 terminator.span,\n                             )?;\n                         }\n                         x => not_supported!(\"unknown function type {x:?}\"),\n                     }\n+                    locals.drop_flags.add_place(destination.clone());\n                     current_block_idx = target.expect(\"broken mir, function without target\");\n                 }\n                 TerminatorKind::SwitchInt { discr, targets } => {\n                     let val = u128::from_le_bytes(pad16(\n-                        self.eval_operand(discr, &locals)?.get(&self)?,\n+                        self.eval_operand(discr, &mut locals)?.get(&self)?,\n                         false,\n                     ));\n                     current_block_idx = targets.target_for_value(val);\n                 }\n                 TerminatorKind::Return => {\n-                    let ty = body.locals[return_slot()].ty.clone();\n                     self.stack_depth_limit += 1;\n-                    return Ok(self\n-                        .read_memory(\n-                            locals.ptr[return_slot()],\n-                            self.size_of_sized(&ty, &locals, \"return type\")?,\n-                        )?\n-                        .to_owned());\n+                    return Ok(locals.ptr[return_slot()].get(self)?.to_vec());\n                 }\n                 TerminatorKind::Unreachable => {\n                     return Err(MirEvalError::UndefinedBehavior(\"unreachable executed\".to_owned()));\n                 }\n+                TerminatorKind::Drop { place, target, unwind: _ } => {\n+                    self.drop_place(place, &mut locals, terminator.span)?;\n+                    current_block_idx = *target;\n+                }\n                 _ => not_supported!(\"unknown terminator\"),\n             }\n         }\n     }\n \n-    fn eval_rvalue<'a>(\n-        &'a mut self,\n-        r: &'a Rvalue,\n-        locals: &'a Locals<'a>,\n-    ) -> Result<IntervalOrOwned> {\n+    fn eval_rvalue(&mut self, r: &Rvalue, locals: &mut Locals<'_>) -> Result<IntervalOrOwned> {\n         use IntervalOrOwned::*;\n         Ok(match r {\n             Rvalue::Use(x) => Borrowed(self.eval_operand(x, locals)?),\n@@ -976,7 +1102,15 @@ impl Evaluator<'_> {\n                     }\n                 }\n             }\n-            Rvalue::Repeat(_, _) => not_supported!(\"evaluating repeat rvalue\"),\n+            Rvalue::Repeat(x, len) => {\n+                let len = match try_const_usize(self.db, len) {\n+                    Some(x) => x as usize,\n+                    None => not_supported!(\"non evaluatable array len in repeat Rvalue\"),\n+                };\n+                let val = self.eval_operand(x, locals)?.get(self)?;\n+                let size = len * val.len();\n+                Owned(val.iter().copied().cycle().take(size).collect())\n+            }\n             Rvalue::ShallowInitBox(_, _) => not_supported!(\"shallow init box\"),\n             Rvalue::ShallowInitBoxWithAlloc(ty) => {\n                 let Some((size, align)) = self.size_align_of(ty, locals)? else {\n@@ -1135,7 +1269,12 @@ impl Evaluator<'_> {\n                     match self.coerce_unsized_look_through_fields(current_ty, for_ptr)? {\n                         ty => match &ty.data(Interner).kind {\n                             TyKind::Array(_, size) => {\n-                                let len = const_as_usize(size);\n+                                let len = match try_const_usize(self.db, size) {\n+                                    None => not_supported!(\n+                                        \"unevaluatble len of array in coerce unsized\"\n+                                    ),\n+                                    Some(x) => x as usize,\n+                                };\n                                 let mut r = Vec::with_capacity(16);\n                                 let addr = addr.get(self)?;\n                                 r.extend(addr.iter().copied());\n@@ -1248,9 +1387,12 @@ impl Evaluator<'_> {\n         Ok(result)\n     }\n \n-    fn eval_operand(&mut self, x: &Operand, locals: &Locals<'_>) -> Result<Interval> {\n+    fn eval_operand(&mut self, x: &Operand, locals: &mut Locals<'_>) -> Result<Interval> {\n         Ok(match x {\n-            Operand::Copy(p) | Operand::Move(p) => self.eval_place(p, locals)?,\n+            Operand::Copy(p) | Operand::Move(p) => {\n+                locals.drop_flags.remove_place(p);\n+                self.eval_place(p, locals)?\n+            }\n             Operand::Static(st) => {\n                 let addr = self.eval_static(*st, locals)?;\n                 Interval::new(addr, self.ptr_size())\n@@ -1311,19 +1453,21 @@ impl Evaluator<'_> {\n                 Interval::new(addr, size)\n             }\n             ConstScalar::UnevaluatedConst(const_id, subst) => {\n-                let subst = self.subst_filler(subst, locals);\n-                let (const_id, subst) = lookup_impl_const(\n-                    self.db,\n-                    self.db.trait_environment_for_body(locals.body.owner),\n-                    *const_id,\n-                    subst,\n-                );\n+                let mut const_id = *const_id;\n+                let mut subst = self.subst_filler(subst, locals);\n+                if let GeneralConstId::ConstId(c) = const_id {\n+                    let (c, s) = lookup_impl_const(\n+                        self.db,\n+                        self.db.trait_environment_for_body(locals.body.owner),\n+                        c,\n+                        subst,\n+                    );\n+                    const_id = GeneralConstId::ConstId(c);\n+                    subst = s;\n+                }\n                 let c = self.db.const_eval(const_id.into(), subst).map_err(|e| {\n-                    let const_data = self.db.const_data(const_id);\n-                    MirEvalError::ConstEvalError(\n-                        const_data.name.as_ref().and_then(|x| x.as_str()).unwrap_or(\"_\").to_owned(),\n-                        Box::new(e),\n-                    )\n+                    let name = const_id.name(self.db.upcast());\n+                    MirEvalError::ConstEvalError(name, Box::new(e))\n                 })?;\n                 if let chalk_ir::ConstValue::Concrete(c) = &c.data(Interner).value {\n                     if let ConstScalar::Bytes(_, _) = &c.interned {\n@@ -1345,6 +1489,9 @@ impl Evaluator<'_> {\n     }\n \n     fn read_memory(&self, addr: Address, size: usize) -> Result<&[u8]> {\n+        if size == 0 {\n+            return Ok(&[]);\n+        }\n         let (mem, pos) = match addr {\n             Stack(x) => (&self.stack, x),\n             Heap(x) => (&self.heap, x),\n@@ -1359,6 +1506,9 @@ impl Evaluator<'_> {\n     }\n \n     fn write_memory(&mut self, addr: Address, r: &[u8]) -> Result<()> {\n+        if r.is_empty() {\n+            return Ok(());\n+        }\n         let (mem, pos) = match addr {\n             Stack(x) => (&mut self.stack, x),\n             Heap(x) => (&mut self.heap, x),\n@@ -1449,14 +1599,24 @@ impl Evaluator<'_> {\n                 outer_binder: DebruijnIndex,\n             ) -> std::result::Result<Ty, Self::Error> {\n                 match ty.kind(Interner) {\n+                    TyKind::AssociatedType(id, subst) => {\n+                        // I don't know exactly if and why this is needed, but it looks like `normalize_ty` likes\n+                        // this kind of associated types.\n+                        Ok(TyKind::Alias(chalk_ir::AliasTy::Projection(ProjectionTy {\n+                            associated_ty_id: *id,\n+                            substitution: subst.clone().try_fold_with(self, outer_binder)?,\n+                        }))\n+                        .intern(Interner))\n+                    }\n                     TyKind::OpaqueType(id, subst) => {\n                         let impl_trait_id = self.db.lookup_intern_impl_trait_id((*id).into());\n+                        let subst = subst.clone().try_fold_with(self.as_dyn(), outer_binder)?;\n                         match impl_trait_id {\n                             crate::ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                                 let infer = self.db.infer(func.into());\n                                 let filler = &mut Filler {\n                                     db: self.db,\n-                                    subst,\n+                                    subst: &subst,\n                                     generics: Some(generics(self.db.upcast(), func.into())),\n                                 };\n                                 filler.try_fold_ty(infer.type_of_rpit[idx].clone(), outer_binder)\n@@ -1791,6 +1951,18 @@ impl Evaluator<'_> {\n         }\n         let (imp, generic_args) =\n             lookup_impl_method(self.db, self.trait_env.clone(), def, generic_args);\n+        self.exec_looked_up_function(generic_args, locals, imp, arg_bytes, span, destination)\n+    }\n+\n+    fn exec_looked_up_function(\n+        &mut self,\n+        generic_args: Substitution,\n+        locals: &Locals<'_>,\n+        imp: FunctionId,\n+        arg_bytes: Vec<Vec<u8>>,\n+        span: MirSpan,\n+        destination: Interval,\n+    ) -> Result<()> {\n         let generic_args = self.subst_filler(&generic_args, &locals);\n         let def = imp.into();\n         let mir_body = self.db.mir_body(def).map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n@@ -1853,13 +2025,12 @@ impl Evaluator<'_> {\n         };\n         let static_data = self.db.static_data(st);\n         let result = if !static_data.is_extern {\n-            let konst =\n-                self.db.const_eval(st.into(), Substitution::empty(Interner)).map_err(|e| {\n-                    MirEvalError::ConstEvalError(\n-                        static_data.name.as_str().unwrap_or(\"_\").to_owned(),\n-                        Box::new(e),\n-                    )\n-                })?;\n+            let konst = self.db.const_eval_static(st).map_err(|e| {\n+                MirEvalError::ConstEvalError(\n+                    static_data.name.as_str().unwrap_or(\"_\").to_owned(),\n+                    Box::new(e),\n+                )\n+            })?;\n             let data = &konst.data(Interner);\n             if let chalk_ir::ConstValue::Concrete(c) = &data.value {\n                 self.allocate_const_in_heap(&c, &data.ty, locals, &konst)?\n@@ -1891,6 +2062,115 @@ impl Evaluator<'_> {\n             }\n         }\n     }\n+\n+    fn drop_place(&mut self, place: &Place, locals: &mut Locals<'_>, span: MirSpan) -> Result<()> {\n+        let (addr, ty, metadata) = self.place_addr_and_ty_and_metadata(place, locals)?;\n+        if !locals.drop_flags.remove_place(place) {\n+            return Ok(());\n+        }\n+        let metadata = match metadata {\n+            Some(x) => x.get(self)?.to_vec(),\n+            None => vec![],\n+        };\n+        self.run_drop_glue_deep(ty, locals, addr, &metadata, span)\n+    }\n+\n+    fn run_drop_glue_deep(\n+        &mut self,\n+        ty: Ty,\n+        locals: &Locals<'_>,\n+        addr: Address,\n+        _metadata: &[u8],\n+        span: MirSpan,\n+    ) -> Result<()> {\n+        let Some(drop_fn) = (|| {\n+            let drop_trait = self.db.lang_item(self.crate_id, LangItem::Drop)?.as_trait()?;\n+            self.db.trait_data(drop_trait).method_by_name(&name![drop])\n+        })() else {\n+            // in some tests we don't have drop trait in minicore, and\n+            // we can ignore drop in them.\n+            return Ok(());\n+        };\n+        let (impl_drop_candidate, subst) = lookup_impl_method(\n+            self.db,\n+            self.trait_env.clone(),\n+            drop_fn,\n+            Substitution::from1(Interner, ty.clone()),\n+        );\n+        if impl_drop_candidate != drop_fn {\n+            self.exec_looked_up_function(\n+                subst,\n+                locals,\n+                impl_drop_candidate,\n+                vec![addr.to_bytes()],\n+                span,\n+                Interval { addr: Address::Invalid(0), size: 0 },\n+            )?;\n+        }\n+        match ty.kind(Interner) {\n+            TyKind::Adt(id, subst) => {\n+                match id.0 {\n+                    AdtId::StructId(s) => {\n+                        let data = self.db.struct_data(s);\n+                        if data.flags.contains(StructFlags::IS_MANUALLY_DROP) {\n+                            return Ok(());\n+                        }\n+                        let layout = self.layout_adt(id.0, subst.clone())?;\n+                        match data.variant_data.as_ref() {\n+                            VariantData::Record(fields) | VariantData::Tuple(fields) => {\n+                                let field_types = self.db.field_types(s.into());\n+                                for (field, _) in fields.iter() {\n+                                    let offset = layout\n+                                        .fields\n+                                        .offset(u32::from(field.into_raw()) as usize)\n+                                        .bytes_usize();\n+                                    let addr = addr.offset(offset);\n+                                    let ty = field_types[field].clone().substitute(Interner, subst);\n+                                    self.run_drop_glue_deep(ty, locals, addr, &[], span)?;\n+                                }\n+                            }\n+                            VariantData::Unit => (),\n+                        }\n+                    }\n+                    AdtId::UnionId(_) => (), // union fields don't need drop\n+                    AdtId::EnumId(_) => (),\n+                }\n+            }\n+            TyKind::AssociatedType(_, _)\n+            | TyKind::Scalar(_)\n+            | TyKind::Tuple(_, _)\n+            | TyKind::Array(_, _)\n+            | TyKind::Slice(_)\n+            | TyKind::Raw(_, _)\n+            | TyKind::Ref(_, _, _)\n+            | TyKind::OpaqueType(_, _)\n+            | TyKind::FnDef(_, _)\n+            | TyKind::Str\n+            | TyKind::Never\n+            | TyKind::Closure(_, _)\n+            | TyKind::Generator(_, _)\n+            | TyKind::GeneratorWitness(_, _)\n+            | TyKind::Foreign(_)\n+            | TyKind::Error\n+            | TyKind::Placeholder(_)\n+            | TyKind::Dyn(_)\n+            | TyKind::Alias(_)\n+            | TyKind::Function(_)\n+            | TyKind::BoundVar(_)\n+            | TyKind::InferenceVar(_, _) => (),\n+        };\n+        Ok(())\n+    }\n+\n+    fn write_to_stdout(&mut self, interval: Interval) -> Result<()> {\n+        self.stdout.extend(interval.get(self)?.to_vec());\n+        Ok(())\n+    }\n+\n+    fn write_to_stderr(&mut self, interval: Interval) -> Result<()> {\n+        self.stderr.extend(interval.get(self)?.to_vec());\n+        Ok(())\n+    }\n }\n \n pub fn pad16(x: &[u8], is_signed: bool) -> [u8; 16] {"}, {"sha": "ac295b58375bdc7cc2c74f2604b448fc7baebb1d", "filename": "crates/hir-ty/src/mir/eval/shim.rs", "status": "modified", "additions": 182, "deletions": 4, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -51,6 +51,24 @@ impl Evaluator<'_> {\n             )?;\n             return Ok(true);\n         }\n+        let is_extern_c = match def.lookup(self.db.upcast()).container {\n+            hir_def::ItemContainerId::ExternBlockId(block) => {\n+                let id = block.lookup(self.db.upcast()).id;\n+                id.item_tree(self.db.upcast())[id.value].abi.as_deref() == Some(\"C\")\n+            }\n+            _ => false,\n+        };\n+        if is_extern_c {\n+            self.exec_extern_c(\n+                function_data.name.as_text().unwrap_or_default().as_str(),\n+                args,\n+                generic_args,\n+                destination,\n+                &locals,\n+                span,\n+            )?;\n+            return Ok(true);\n+        }\n         let alloc_fn = function_data\n             .attrs\n             .iter()\n@@ -72,7 +90,7 @@ impl Evaluator<'_> {\n         if let Some(x) = self.detect_lang_function(def) {\n             let arg_bytes =\n                 args.iter().map(|x| Ok(x.get(&self)?.to_owned())).collect::<Result<Vec<_>>>()?;\n-            let result = self.exec_lang_item(x, &arg_bytes)?;\n+            let result = self.exec_lang_item(x, generic_args, &arg_bytes, locals, span)?;\n             destination.write_from_bytes(self, &result)?;\n             return Ok(true);\n         }\n@@ -118,13 +136,20 @@ impl Evaluator<'_> {\n         use LangItem::*;\n         let candidate = lang_attr(self.db.upcast(), def)?;\n         // We want to execute these functions with special logic\n-        if [PanicFmt, BeginPanic, SliceLen].contains(&candidate) {\n+        if [PanicFmt, BeginPanic, SliceLen, DropInPlace].contains(&candidate) {\n             return Some(candidate);\n         }\n         None\n     }\n \n-    fn exec_lang_item(&self, x: LangItem, args: &[Vec<u8>]) -> Result<Vec<u8>> {\n+    fn exec_lang_item(\n+        &mut self,\n+        x: LangItem,\n+        generic_args: &Substitution,\n+        args: &[Vec<u8>],\n+        locals: &Locals<'_>,\n+        span: MirSpan,\n+    ) -> Result<Vec<u8>> {\n         use LangItem::*;\n         let mut args = args.iter();\n         match x {\n@@ -139,10 +164,114 @@ impl Evaluator<'_> {\n                 let ptr_size = arg.len() / 2;\n                 Ok(arg[ptr_size..].into())\n             }\n+            DropInPlace => {\n+                let ty =\n+                    generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)).ok_or(\n+                        MirEvalError::TypeError(\n+                            \"generic argument of drop_in_place is not provided\",\n+                        ),\n+                    )?;\n+                let arg = args\n+                    .next()\n+                    .ok_or(MirEvalError::TypeError(\"argument of drop_in_place is not provided\"))?;\n+                self.run_drop_glue_deep(\n+                    ty.clone(),\n+                    locals,\n+                    Address::from_bytes(&arg[0..self.ptr_size()])?,\n+                    &arg[self.ptr_size()..],\n+                    span,\n+                )?;\n+                Ok(vec![])\n+            }\n             x => not_supported!(\"Executing lang item {x:?}\"),\n         }\n     }\n \n+    fn exec_extern_c(\n+        &mut self,\n+        as_str: &str,\n+        args: &[IntervalAndTy],\n+        _generic_args: &Substitution,\n+        destination: Interval,\n+        locals: &Locals<'_>,\n+        _span: MirSpan,\n+    ) -> Result<()> {\n+        match as_str {\n+            \"write\" => {\n+                let [fd, ptr, len] = args else {\n+                    return Err(MirEvalError::TypeError(\"libc::write args are not provided\"));\n+                };\n+                let fd = u128::from_le_bytes(pad16(fd.get(self)?, false));\n+                let interval = Interval {\n+                    addr: Address::from_bytes(ptr.get(self)?)?,\n+                    size: from_bytes!(usize, len.get(self)?),\n+                };\n+                match fd {\n+                    1 => {\n+                        self.write_to_stdout(interval)?;\n+                    }\n+                    2 => {\n+                        self.write_to_stderr(interval)?;\n+                    }\n+                    _ => not_supported!(\"write to arbitrary file descriptor\"),\n+                }\n+                Ok(())\n+            }\n+            \"pthread_key_create\" => {\n+                let key = self.thread_local_storage.create_key();\n+                let Some(arg0) = args.get(0) else {\n+                    return Err(MirEvalError::TypeError(\"pthread_key_create arg0 is not provided\"));\n+                };\n+                let arg0_addr = Address::from_bytes(arg0.get(self)?)?;\n+                let key_ty = if let Some((ty, ..)) = arg0.ty.as_reference_or_ptr() {\n+                    ty\n+                } else {\n+                    return Err(MirEvalError::TypeError(\n+                        \"pthread_key_create arg0 is not a pointer\",\n+                    ));\n+                };\n+                let arg0_interval = Interval::new(\n+                    arg0_addr,\n+                    self.size_of_sized(key_ty, locals, \"pthread_key_create key arg\")?,\n+                );\n+                arg0_interval.write_from_bytes(self, &key.to_le_bytes()[0..arg0_interval.size])?;\n+                // return 0 as success\n+                destination.write_from_bytes(self, &0u64.to_le_bytes()[0..destination.size])?;\n+                Ok(())\n+            }\n+            \"pthread_getspecific\" => {\n+                let Some(arg0) = args.get(0) else {\n+                    return Err(MirEvalError::TypeError(\"pthread_getspecific arg0 is not provided\"));\n+                };\n+                let key = from_bytes!(usize, &pad16(arg0.get(self)?, false)[0..8]);\n+                let value = self.thread_local_storage.get_key(key)?;\n+                destination.write_from_bytes(self, &value.to_le_bytes()[0..destination.size])?;\n+                Ok(())\n+            }\n+            \"pthread_setspecific\" => {\n+                let Some(arg0) = args.get(0) else {\n+                    return Err(MirEvalError::TypeError(\"pthread_setspecific arg0 is not provided\"));\n+                };\n+                let key = from_bytes!(usize, &pad16(arg0.get(self)?, false)[0..8]);\n+                let Some(arg1) = args.get(1) else {\n+                    return Err(MirEvalError::TypeError(\"pthread_setspecific arg1 is not provided\"));\n+                };\n+                let value = from_bytes!(u128, pad16(arg1.get(self)?, false));\n+                self.thread_local_storage.set_key(key, value)?;\n+                // return 0 as success\n+                destination.write_from_bytes(self, &0u64.to_le_bytes()[0..destination.size])?;\n+                Ok(())\n+            }\n+            \"pthread_key_delete\" => {\n+                // we ignore this currently\n+                // return 0 as success\n+                destination.write_from_bytes(self, &0u64.to_le_bytes()[0..destination.size])?;\n+                Ok(())\n+            }\n+            _ => not_supported!(\"unknown external function {as_str}\"),\n+        }\n+    }\n+\n     fn exec_intrinsic(\n         &mut self,\n         as_str: &str,\n@@ -288,7 +417,7 @@ impl Evaluator<'_> {\n                 let ans = lhs.get(self)? == rhs.get(self)?;\n                 destination.write_from_bytes(self, &[u8::from(ans)])\n             }\n-            \"wrapping_add\" => {\n+            \"wrapping_add\" | \"unchecked_add\" => {\n                 let [lhs, rhs] = args else {\n                     return Err(MirEvalError::TypeError(\"wrapping_add args are not provided\"));\n                 };\n@@ -297,6 +426,39 @@ impl Evaluator<'_> {\n                 let ans = lhs.wrapping_add(rhs);\n                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n             }\n+            \"wrapping_sub\" | \"unchecked_sub\" | \"ptr_offset_from_unsigned\" | \"ptr_offset_from\" => {\n+                let [lhs, rhs] = args else {\n+                    return Err(MirEvalError::TypeError(\"wrapping_sub args are not provided\"));\n+                };\n+                let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n+                let ans = lhs.wrapping_sub(rhs);\n+                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n+            }\n+            \"unchecked_rem\" => {\n+                // FIXME: signed\n+                let [lhs, rhs] = args else {\n+                    return Err(MirEvalError::TypeError(\"unchecked_rem args are not provided\"));\n+                };\n+                let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n+                let ans = lhs.checked_rem(rhs).ok_or_else(|| {\n+                    MirEvalError::UndefinedBehavior(\"unchecked_rem with bad inputs\".to_owned())\n+                })?;\n+                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n+            }\n+            \"unchecked_div\" | \"exact_div\" => {\n+                // FIXME: signed\n+                let [lhs, rhs] = args else {\n+                    return Err(MirEvalError::TypeError(\"unchecked_div args are not provided\"));\n+                };\n+                let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n+                let ans = lhs.checked_div(rhs).ok_or_else(|| {\n+                    MirEvalError::UndefinedBehavior(\"unchecked_rem with bad inputs\".to_owned())\n+                })?;\n+                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n+            }\n             \"add_with_overflow\" => {\n                 let [lhs, rhs] = args else {\n                     return Err(MirEvalError::TypeError(\"const_eval_select args are not provided\"));\n@@ -373,6 +535,22 @@ impl Evaluator<'_> {\n                 };\n                 destination.write_from_interval(self, arg.interval)\n             }\n+            \"ctpop\" => {\n+                let [arg] = args else {\n+                    return Err(MirEvalError::TypeError(\"likely arg is not provided\"));\n+                };\n+                let result = u128::from_le_bytes(pad16(arg.get(self)?, false)).count_ones();\n+                destination\n+                    .write_from_bytes(self, &(result as u128).to_le_bytes()[0..destination.size])\n+            }\n+            \"cttz\" | \"cttz_nonzero\" => {\n+                let [arg] = args else {\n+                    return Err(MirEvalError::TypeError(\"likely arg is not provided\"));\n+                };\n+                let result = u128::from_le_bytes(pad16(arg.get(self)?, false)).trailing_zeros();\n+                destination\n+                    .write_from_bytes(self, &(result as u128).to_le_bytes()[0..destination.size])\n+            }\n             \"const_eval_select\" => {\n                 let [tuple, const_fn, _] = args else {\n                     return Err(MirEvalError::TypeError(\"const_eval_select args are not provided\"));"}, {"sha": "0685159f1c1b3999bbb00a6648317e204f443c66", "filename": "crates/hir-ty/src/mir/eval/tests.rs", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -0,0 +1,299 @@\n+use base_db::{fixture::WithFixture, FileId};\n+use hir_def::db::DefDatabase;\n+\n+use crate::{db::HirDatabase, test_db::TestDB, Interner, Substitution};\n+\n+use super::{interpret_mir, MirEvalError};\n+\n+fn eval_main(db: &TestDB, file_id: FileId) -> Result<(String, String), MirEvalError> {\n+    let module_id = db.module_for_file(file_id);\n+    let def_map = module_id.def_map(db);\n+    let scope = &def_map[module_id.local_id].scope;\n+    let func_id = scope\n+        .declarations()\n+        .find_map(|x| match x {\n+            hir_def::ModuleDefId::FunctionId(x) => {\n+                if db.function_data(x).name.to_string() == \"main\" {\n+                    Some(x)\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        })\n+        .unwrap();\n+    let body =\n+        db.mir_body(func_id.into()).map_err(|e| MirEvalError::MirLowerError(func_id.into(), e))?;\n+    let (result, stdout, stderr) = interpret_mir(db, &body, Substitution::empty(Interner), false);\n+    result?;\n+    Ok((stdout, stderr))\n+}\n+\n+fn check_pass(ra_fixture: &str) {\n+    check_pass_and_stdio(ra_fixture, \"\", \"\");\n+}\n+\n+fn check_pass_and_stdio(ra_fixture: &str, expected_stdout: &str, expected_stderr: &str) {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let x = eval_main(&db, file_id);\n+    match x {\n+        Err(e) => {\n+            let mut err = String::new();\n+            let span_formatter = |file, range| format!(\"{:?} {:?}\", file, range);\n+            e.pretty_print(&mut err, &db, span_formatter).unwrap();\n+            panic!(\"Error in interpreting: {err}\");\n+        }\n+        Ok((stdout, stderr)) => {\n+            assert_eq!(stdout, expected_stdout);\n+            assert_eq!(stderr, expected_stderr);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn function_with_extern_c_abi() {\n+    check_pass(\n+        r#\"\n+extern \"C\" fn foo(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+\n+fn main() {\n+    let x = foo(2, 3);\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn drop_basic() {\n+    check_pass(\n+        r#\"\n+//- minicore: drop, add\n+\n+struct X<'a>(&'a mut i32);\n+impl<'a> Drop for X<'a> {\n+    fn drop(&mut self) {\n+        *self.0 += 1;\n+    }\n+}\n+\n+struct NestedX<'a> { f1: X<'a>, f2: X<'a> }\n+\n+fn should_not_reach() {\n+    _ // FIXME: replace this function with panic when that works\n+}\n+\n+fn my_drop2(x: X<'_>) {\n+    return;\n+}\n+\n+fn my_drop(x: X<'_>) {\n+    drop(x);\n+}\n+\n+fn main() {\n+    let mut s = 10;\n+    let mut x = X(&mut s);\n+    my_drop(x);\n+    x = X(&mut s);\n+    my_drop2(x);\n+    X(&mut s); // dropped immediately\n+    let x = X(&mut s);\n+    NestedX { f1: x, f2: X(&mut s) };\n+    if s != 15 {\n+        should_not_reach();\n+    }\n+}\n+    \"#,\n+    );\n+}\n+\n+#[test]\n+fn drop_in_place() {\n+    check_pass(\n+        r#\"\n+//- minicore: drop, add, coerce_unsized\n+use core::ptr::drop_in_place;\n+\n+struct X<'a>(&'a mut i32);\n+impl<'a> Drop for X<'a> {\n+    fn drop(&mut self) {\n+        *self.0 += 1;\n+    }\n+}\n+\n+fn should_not_reach() {\n+    _ // FIXME: replace this function with panic when that works\n+}\n+\n+fn main() {\n+    let mut s = 2;\n+    let x = X(&mut s);\n+    drop_in_place(&mut x);\n+    drop(x);\n+    if s != 4 {\n+        should_not_reach();\n+    }\n+    let p: &mut [X] = &mut [X(&mut 2)];\n+    drop_in_place(p);\n+}\n+    \"#,\n+    );\n+}\n+\n+#[test]\n+fn manually_drop() {\n+    check_pass(\n+        r#\"\n+//- minicore: manually_drop\n+use core::mem::ManuallyDrop;\n+\n+struct X;\n+impl Drop for X {\n+    fn drop(&mut self) {\n+        should_not_reach();\n+    }\n+}\n+\n+fn should_not_reach() {\n+    _ // FIXME: replace this function with panic when that works\n+}\n+\n+fn main() {\n+    let x = ManuallyDrop::new(X);\n+}\n+    \"#,\n+    );\n+}\n+\n+#[test]\n+fn generic_impl_for_trait_with_generic_method() {\n+    check_pass(\n+        r#\"\n+//- minicore: drop\n+struct S<T>(T);\n+\n+trait Tr {\n+    fn f<F>(&self, x: F);\n+}\n+\n+impl<T> Tr for S<T> {\n+    fn f<F>(&self, x: F) {\n+    }\n+}\n+\n+fn main() {\n+    let s = S(1u8);\n+    s.f(5i64);\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn index_of_slice_should_preserve_len() {\n+    check_pass(\n+        r#\"\n+//- minicore: index, slice, coerce_unsized\n+\n+struct X;\n+\n+impl core::ops::Index<X> for [i32] {\n+    type Output = i32;\n+\n+    fn index(&self, _: X) -> &i32 {\n+        if self.len() != 3 {\n+            should_not_reach();\n+        }\n+        &self[0]\n+    }\n+}\n+\n+fn should_not_reach() {\n+    _ // FIXME: replace this function with panic when that works\n+}\n+\n+fn main() {\n+    let x: &[i32] = &[1, 2, 3];\n+    &x[X];\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn unix_write_stdout() {\n+    check_pass_and_stdio(\n+        r#\"\n+//- minicore: slice, index, coerce_unsized\n+\n+type pthread_key_t = u32;\n+type c_void = u8;\n+type c_int = i32;\n+\n+extern \"C\" {\n+    pub fn write(fd: i32, buf: *const u8, count: usize) -> usize;\n+}\n+\n+fn main() {\n+    let stdout = b\"stdout\";\n+    let stderr = b\"stderr\";\n+    write(1, &stdout[0], 6);\n+    write(2, &stderr[0], 6);\n+}\n+        \"#,\n+        \"stdout\",\n+        \"stderr\",\n+    );\n+}\n+\n+#[test]\n+fn closure_layout_in_rpit() {\n+    check_pass(\n+        r#\"\n+//- minicore: fn\n+\n+fn f<F: Fn()>(x: F) {\n+    fn g(x: impl Fn()) -> impl FnOnce() {\n+        move || {\n+            x();\n+        }\n+    }\n+    g(x)();\n+}\n+\n+fn main() {\n+    f(|| {});\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn posix_tls() {\n+    check_pass(\n+        r#\"\n+//- minicore: option\n+\n+type pthread_key_t = u32;\n+type c_void = u8;\n+type c_int = i32;\n+\n+extern \"C\" {\n+    pub fn pthread_key_create(\n+        key: *mut pthread_key_t,\n+        dtor: Option<unsafe extern \"C\" fn(*mut c_void)>,\n+    ) -> c_int;\n+    pub fn pthread_key_delete(key: pthread_key_t) -> c_int;\n+    pub fn pthread_getspecific(key: pthread_key_t) -> *mut c_void;\n+    pub fn pthread_setspecific(key: pthread_key_t, value: *const c_void) -> c_int;\n+}\n+\n+fn main() {\n+    let mut key = 2;\n+    pthread_key_create(&mut key, None);\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "a37e5e8168796e878e442ac416846d88cecddf72", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 154, "deletions": 107, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -14,7 +14,8 @@ use hir_def::{\n     lang_item::{LangItem, LangItemTarget},\n     path::Path,\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n-    AdtId, DefWithBodyId, EnumVariantId, HasModule, ItemContainerId, LocalFieldId, TraitId,\n+    AdtId, DefWithBodyId, EnumVariantId, GeneralConstId, HasModule, ItemContainerId, LocalFieldId,\n+    TraitId,\n };\n use hir_expand::name::Name;\n use la_arena::ArenaMap;\n@@ -30,7 +31,6 @@ use crate::{\n     inhabitedness::is_ty_uninhabited_from,\n     layout::{layout_of_ty, LayoutError},\n     mapping::ToChalk,\n-    method_resolution::lookup_impl_const,\n     static_lifetime,\n     utils::{generics, ClosureSubst},\n     Adjust, Adjustment, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n@@ -51,17 +51,22 @@ struct LoopBlocks {\n     place: Place,\n }\n \n+#[derive(Debug, Clone, Default)]\n+struct DropScope {\n+    /// locals, in order of definition (so we should run drop glues in reverse order)\n+    locals: Vec<LocalId>,\n+}\n+\n struct MirLowerCtx<'a> {\n     result: MirBody,\n     owner: DefWithBodyId,\n     current_loop_blocks: Option<LoopBlocks>,\n-    // FIXME: we should resolve labels in HIR lowering and always work with label id here, not\n-    // with raw names.\n     labeled_loop_blocks: FxHashMap<LabelId, LoopBlocks>,\n     discr_temp: Option<Place>,\n     db: &'a dyn HirDatabase,\n     body: &'a Body,\n     infer: &'a InferenceResult,\n+    drop_scopes: Vec<DropScope>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -181,7 +186,6 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             binding_locals,\n             param_locals: vec![],\n             owner,\n-            arg_count: body.params.len(),\n             closures: vec![],\n         };\n         let ctx = MirLowerCtx {\n@@ -193,15 +197,18 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             current_loop_blocks: None,\n             labeled_loop_blocks: Default::default(),\n             discr_temp: None,\n+            drop_scopes: vec![DropScope::default()],\n         };\n         ctx\n     }\n \n-    fn temp(&mut self, ty: Ty) -> Result<LocalId> {\n+    fn temp(&mut self, ty: Ty, current: BasicBlockId, span: MirSpan) -> Result<LocalId> {\n         if matches!(ty.kind(Interner), TyKind::Slice(_) | TyKind::Dyn(_)) {\n             implementation_error!(\"unsized temporaries\");\n         }\n-        Ok(self.result.locals.alloc(Local { ty }))\n+        let l = self.result.locals.alloc(Local { ty });\n+        self.push_storage_live_for_local(l, current, span)?;\n+        Ok(l)\n     }\n \n     fn lower_expr_to_some_operand(\n@@ -234,7 +241,8 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         match adjustments.split_last() {\n             Some((last, rest)) => match &last.kind {\n                 Adjust::NeverToAny => {\n-                    let temp = self.temp(TyKind::Never.intern(Interner))?;\n+                    let temp =\n+                        self.temp(TyKind::Never.intern(Interner), current, MirSpan::Unknown)?;\n                     self.lower_expr_to_place_with_adjust(expr_id, temp.into(), current, rest)\n                 }\n                 Adjust::Deref(_) => {\n@@ -303,45 +311,39 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 Err(MirLowerError::IncompleteExpr)\n             },\n             Expr::Path(p) => {\n-                let unresolved_name = || MirLowerError::unresolved_path(self.db, p);\n-                let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n-                let pr = resolver\n-                    .resolve_path_in_value_ns(self.db.upcast(), p)\n-                    .ok_or_else(unresolved_name)?;\n-                let pr = match pr {\n-                    ResolveValueResult::ValueNs(v) => v,\n-                    ResolveValueResult::Partial(..) => {\n-                        if let Some((assoc, subst)) = self\n-                            .infer\n-                            .assoc_resolutions_for_expr(expr_id)\n-                        {\n-                            match assoc {\n-                                hir_def::AssocItemId::ConstId(c) => {\n-                                    self.lower_const(c, current, place, subst, expr_id.into(), self.expr_ty_without_adjust(expr_id))?;\n-                                    return Ok(Some(current))\n-                                },\n-                                hir_def::AssocItemId::FunctionId(_) => {\n-                                    // FnDefs are zero sized, no action is needed.\n-                                    return Ok(Some(current))\n-                                }\n-                                hir_def::AssocItemId::TypeAliasId(_) => {\n-                                    // FIXME: If it is unreachable, use proper error instead of `not_supported`.\n-                                    not_supported!(\"associated functions and types\")\n-                                },\n-                            }\n-                        } else if let Some(variant) = self\n-                            .infer\n-                            .variant_resolution_for_expr(expr_id)\n-                        {\n-                            match variant {\n-                                VariantId::EnumVariantId(e) => ValueNs::EnumVariantId(e),\n-                                VariantId::StructId(s) => ValueNs::StructId(s),\n-                                VariantId::UnionId(_) => implementation_error!(\"Union variant as path\"),\n-                            }\n-                        } else {\n-                            return Err(unresolved_name());\n+                let pr = if let Some((assoc, subst)) = self\n+                    .infer\n+                    .assoc_resolutions_for_expr(expr_id)\n+                {\n+                    match assoc {\n+                        hir_def::AssocItemId::ConstId(c) => {\n+                            self.lower_const(c.into(), current, place, subst, expr_id.into(), self.expr_ty_without_adjust(expr_id))?;\n+                            return Ok(Some(current))\n+                        },\n+                        hir_def::AssocItemId::FunctionId(_) => {\n+                            // FnDefs are zero sized, no action is needed.\n+                            return Ok(Some(current))\n                         }\n+                        hir_def::AssocItemId::TypeAliasId(_) => {\n+                            // FIXME: If it is unreachable, use proper error instead of `not_supported`.\n+                            not_supported!(\"associated functions and types\")\n+                        },\n                     }\n+                } else if let Some(variant) = self\n+                    .infer\n+                    .variant_resolution_for_expr(expr_id)\n+                {\n+                    match variant {\n+                        VariantId::EnumVariantId(e) => ValueNs::EnumVariantId(e),\n+                        VariantId::StructId(s) => ValueNs::StructId(s),\n+                        VariantId::UnionId(_) => implementation_error!(\"Union variant as path\"),\n+                    }\n+                } else {\n+                    let unresolved_name = || MirLowerError::unresolved_path(self.db, p);\n+                    let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n+                    resolver\n+                        .resolve_path_in_value_ns_fully(self.db.upcast(), p)\n+                        .ok_or_else(unresolved_name)?\n                 };\n                 match pr {\n                     ValueNs::LocalBinding(_) | ValueNs::StaticId(_) => {\n@@ -357,7 +359,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         Ok(Some(current))\n                     }\n                     ValueNs::ConstId(const_id) => {\n-                        self.lower_const(const_id, current, place, Substitution::empty(Interner), expr_id.into(), self.expr_ty_without_adjust(expr_id))?;\n+                        self.lower_const(const_id.into(), current, place, Substitution::empty(Interner), expr_id.into(), self.expr_ty_without_adjust(expr_id))?;\n                         Ok(Some(current))\n                     }\n                     ValueNs::EnumVariantId(variant_id) => {\n@@ -470,9 +472,10 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             Expr::Block { id: _, statements, tail, label } => {\n                 if let Some(label) = label {\n                     self.lower_loop(current, place.clone(), Some(*label), expr_id.into(), |this, begin| {\n-                        if let Some(block) = this.lower_block_to_place(statements, begin, *tail, place, expr_id.into())? {\n+                        if let Some(current) = this.lower_block_to_place(statements, begin, *tail, place, expr_id.into())? {\n                             let end = this.current_loop_end()?;\n-                            this.set_goto(block, end, expr_id.into());\n+                            let current = this.pop_drop_scope(current);\n+                            this.set_goto(current, end, expr_id.into());\n                         }\n                         Ok(())\n                     })\n@@ -481,8 +484,9 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 }\n             }\n             Expr::Loop { body, label } => self.lower_loop(current, place, *label, expr_id.into(), |this, begin| {\n-                if let Some((_, block)) = this.lower_expr_as_place(begin, *body, true)? {\n-                    this.set_goto(block, begin, expr_id.into());\n+                if let Some((_, current)) = this.lower_expr_as_place(begin, *body, true)? {\n+                    let current = this.pop_drop_scope(current);\n+                    this.set_goto(current, begin, expr_id.into());\n                 }\n                 Ok(())\n             }),\n@@ -502,6 +506,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         expr_id.into(),\n                     );\n                     if let Some((_, block)) = this.lower_expr_as_place(after_cond, *body, true)? {\n+                        let block = this.pop_drop_scope(block);\n                         this.set_goto(block, begin, expr_id.into());\n                     }\n                     Ok(())\n@@ -531,9 +536,9 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 let ref_mut_iterator_ty = TyKind::Ref(Mutability::Mut, static_lifetime(), iterator_ty.clone()).intern(Interner);\n                 let item_ty = &self.infer.type_of_pat[pat];\n                 let option_item_ty = TyKind::Adt(chalk_ir::AdtId(option.into()), Substitution::from1(Interner, item_ty.clone())).intern(Interner);\n-                let iterator_place: Place = self.temp(iterator_ty.clone())?.into();\n-                let option_item_place: Place = self.temp(option_item_ty.clone())?.into();\n-                let ref_mut_iterator_place: Place = self.temp(ref_mut_iterator_ty)?.into();\n+                let iterator_place: Place = self.temp(iterator_ty.clone(), current, expr_id.into())?.into();\n+                let option_item_place: Place = self.temp(option_item_ty.clone(), current, expr_id.into())?.into();\n+                let ref_mut_iterator_place: Place = self.temp(ref_mut_iterator_ty, current, expr_id.into())?.into();\n                 let Some(current) = self.lower_call_and_args(into_iter_fn_op, Some(iterable).into_iter(), iterator_place.clone(), current, false, expr_id.into())?\n                 else {\n                     return Ok(None);\n@@ -556,6 +561,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         AdtPatternShape::Tuple { args: &[pat], ellipsis: None },\n                     )?;\n                     if let Some((_, block)) = this.lower_expr_as_place(current, body, true)? {\n+                        let block = this.pop_drop_scope(block);\n                         this.set_goto(block, begin, expr_id.into());\n                     }\n                     Ok(())\n@@ -686,6 +692,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         return Ok(None);\n                     }\n                 }\n+                current = self.drop_until_scope(0, current);\n                 self.set_terminator(current, TerminatorKind::Return, expr_id.into());\n                 Ok(None)\n             }\n@@ -770,7 +777,11 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             Expr::Await { .. } => not_supported!(\"await\"),\n             Expr::Yeet { .. } => not_supported!(\"yeet\"),\n             Expr::Async { .. } => not_supported!(\"async block\"),\n-            Expr::Const { .. } => not_supported!(\"anonymous const block\"),\n+            &Expr::Const(id) => {\n+                let subst = self.placeholder_subst();\n+                self.lower_const(id.into(), current, place, subst, expr_id.into(), self.expr_ty_without_adjust(expr_id))?;\n+                Ok(Some(current))\n+            },\n             Expr::Cast { expr, type_ref: _ } => {\n                 let Some((x, current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n                     return Ok(None);\n@@ -830,11 +841,16 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             },\n             Expr::BinaryOp { lhs, rhs, op } => {\n                 let op = op.ok_or(MirLowerError::IncompleteExpr)?;\n-                let is_builtin = {\n+                let is_builtin = 'b: {\n                     // Without adjust here is a hack. We assume that we know every possible adjustment\n                     // for binary operator, and use without adjust to simplify our conditions.\n                     let lhs_ty = self.expr_ty_without_adjust(*lhs);\n                     let rhs_ty = self.expr_ty_without_adjust(*rhs);\n+                    if matches!(op ,BinaryOp::CmpOp(syntax::ast::CmpOp::Eq { .. })) {\n+                        if lhs_ty.as_raw_ptr().is_some() && rhs_ty.as_raw_ptr().is_some() {\n+                            break 'b true;\n+                        }\n+                    }\n                     let builtin_inequal_impls = matches!(\n                         op,\n                         BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) | BinaryOp::Assignment { op: Some(ArithOp::Shl | ArithOp::Shr) }\n@@ -973,21 +989,18 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                                 ProjectionElem::Deref => ProjectionElem::Deref,\n                                 ProjectionElem::Field(x) => ProjectionElem::Field(x),\n                                 ProjectionElem::TupleOrClosureField(x) => ProjectionElem::TupleOrClosureField(x),\n-                                ProjectionElem::ConstantIndex { offset, min_length, from_end } => ProjectionElem::ConstantIndex { offset, min_length, from_end },\n-                                ProjectionElem::Subslice { from, to, from_end } => ProjectionElem::Subslice { from, to, from_end },\n+                                ProjectionElem::ConstantIndex { offset, from_end } => ProjectionElem::ConstantIndex { offset, from_end },\n+                                ProjectionElem::Subslice { from, to } => ProjectionElem::Subslice { from, to },\n                                 ProjectionElem::OpaqueCast(x) => ProjectionElem::OpaqueCast(x),\n                                 ProjectionElem::Index(x) => match x { },\n                             }\n                         }).collect(),\n                     };\n                     match &capture.kind {\n                         CaptureKind::ByRef(bk) => {\n-                            let placeholder_subst = match self.owner.as_generic_def_id() {\n-                                Some(x) => TyBuilder::placeholder_subst(self.db, x),\n-                                None => Substitution::empty(Interner),\n-                            };\n+                            let placeholder_subst = self.placeholder_subst();\n                             let tmp_ty = capture.ty.clone().substitute(Interner, &placeholder_subst);\n-                            let tmp: Place = self.temp(tmp_ty)?.into();\n+                            let tmp: Place = self.temp(tmp_ty, current, capture.span)?.into();\n                             self.push_assignment(\n                                 current,\n                                 tmp.clone(),\n@@ -1085,6 +1098,14 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         }\n     }\n \n+    fn placeholder_subst(&mut self) -> Substitution {\n+        let placeholder_subst = match self.owner.as_generic_def_id() {\n+            Some(x) => TyBuilder::placeholder_subst(self.db, x),\n+            None => Substitution::empty(Interner),\n+        };\n+        placeholder_subst\n+    }\n+\n     fn push_field_projection(&self, place: &mut Place, expr_id: ExprId) -> Result<()> {\n         if let Expr::Field { expr, name } = &self.body[expr_id] {\n             if let TyKind::Tuple(..) = self.expr_ty_after_adjustments(*expr).kind(Interner) {\n@@ -1146,7 +1167,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n \n     fn lower_const(\n         &mut self,\n-        const_id: hir_def::ConstId,\n+        const_id: GeneralConstId,\n         prev_block: BasicBlockId,\n         place: Place,\n         subst: Substitution,\n@@ -1157,20 +1178,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             // We can't evaluate constant with substitution now, as generics are not monomorphized in lowering.\n             intern_const_scalar(ConstScalar::UnevaluatedConst(const_id, subst), ty)\n         } else {\n-            let (const_id, subst) = lookup_impl_const(\n-                self.db,\n-                self.db.trait_environment_for_body(self.owner),\n-                const_id,\n-                subst,\n-            );\n-            let name = self\n-                .db\n-                .const_data(const_id)\n-                .name\n-                .as_ref()\n-                .and_then(|x| x.as_str())\n-                .unwrap_or(\"_\")\n-                .to_owned();\n+            let name = const_id.name(self.db.upcast());\n             self.db\n                 .const_eval(const_id.into(), subst)\n                 .map_err(|e| MirLowerError::ConstEvalError(name, Box::new(e)))?\n@@ -1313,12 +1321,14 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         self.push_statement(block, StatementKind::Assign(place, rvalue).with_span(span));\n     }\n \n-    fn discr_temp_place(&mut self) -> Place {\n+    fn discr_temp_place(&mut self, current: BasicBlockId) -> Place {\n         match &self.discr_temp {\n             Some(x) => x.clone(),\n             None => {\n-                let tmp: Place =\n-                    self.temp(TyBuilder::discr_ty()).expect(\"discr_ty is never unsized\").into();\n+                let tmp: Place = self\n+                    .temp(TyBuilder::discr_ty(), current, MirSpan::Unknown)\n+                    .expect(\"discr_ty is never unsized\")\n+                    .into();\n                 self.discr_temp = Some(tmp.clone());\n                 tmp\n             }\n@@ -1349,6 +1359,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             None\n         };\n         self.set_goto(prev_block, begin, span);\n+        self.push_drop_scope();\n         f(self, begin)?;\n         let my = mem::replace(&mut self.current_loop_blocks, prev).ok_or(\n             MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\".to_string()),\n@@ -1409,34 +1420,28 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         is_ty_uninhabited_from(&self.infer[expr_id], self.owner.module(self.db.upcast()), self.db)\n     }\n \n-    /// This function push `StorageLive` statement for the binding, and applies changes to add `StorageDead` in\n-    /// the appropriated places.\n+    /// This function push `StorageLive` statement for the binding, and applies changes to add `StorageDead` and\n+    /// `Drop` in the appropriated places.\n     fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) -> Result<()> {\n-        // Current implementation is wrong. It adds no `StorageDead` at the end of scope, and before each break\n-        // and continue. It just add a `StorageDead` before the `StorageLive`, which is not wrong, but unneeded in\n-        // the proper implementation. Due this limitation, implementing a borrow checker on top of this mir will falsely\n-        // allow this:\n-        //\n-        // ```\n-        // let x;\n-        // loop {\n-        //     let y = 2;\n-        //     x = &y;\n-        //     if some_condition {\n-        //         break; // we need to add a StorageDead(y) above this to kill the x borrow\n-        //     }\n-        // }\n-        // use(x)\n-        // ```\n-        // But I think this approach work for mutability analysis, as user can't write code which mutates a binding\n-        // after StorageDead, except loops, which are handled by this hack.\n         let span = self.body.bindings[b]\n             .definitions\n             .first()\n             .copied()\n             .map(MirSpan::PatId)\n             .unwrap_or(MirSpan::Unknown);\n         let l = self.binding_local(b)?;\n+        self.push_storage_live_for_local(l, current, span)\n+    }\n+\n+    fn push_storage_live_for_local(\n+        &mut self,\n+        l: LocalId,\n+        current: BasicBlockId,\n+        span: MirSpan,\n+    ) -> Result<()> {\n+        self.drop_scopes.last_mut().unwrap().locals.push(l);\n+        // FIXME: this storage dead is not neccessary, but since drop scope handling is broken, we need\n+        // it to avoid falso positives in mutability errors\n         self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n         self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n         Ok(())\n@@ -1500,10 +1505,11 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     }\n                 }\n                 hir_def::hir::Statement::Expr { expr, has_semi: _ } => {\n+                    self.push_drop_scope();\n                     let Some((_, c)) = self.lower_expr_as_place(current, *expr, true)? else {\n                         return Ok(None);\n                     };\n-                    current = c;\n+                    current = self.pop_drop_scope(c);\n                 }\n             }\n         }\n@@ -1521,6 +1527,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         let base_param_count = self.result.param_locals.len();\n         self.result.param_locals.extend(params.clone().map(|(x, ty)| {\n             let local_id = self.result.locals.alloc(Local { ty });\n+            self.drop_scopes.last_mut().unwrap().locals.push(local_id);\n             if let Pat::Bind { id, subpat: None } = self.body[x] {\n                 if matches!(\n                     self.body.bindings[id].mode,\n@@ -1590,6 +1597,44 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             }\n         }\n     }\n+\n+    fn drop_until_scope(&mut self, scope_index: usize, mut current: BasicBlockId) -> BasicBlockId {\n+        for scope in self.drop_scopes[scope_index..].to_vec().iter().rev() {\n+            self.emit_drop_and_storage_dead_for_scope(scope, &mut current);\n+        }\n+        current\n+    }\n+\n+    fn push_drop_scope(&mut self) {\n+        self.drop_scopes.push(DropScope::default());\n+    }\n+\n+    fn pop_drop_scope(&mut self, mut current: BasicBlockId) -> BasicBlockId {\n+        let scope = self.drop_scopes.pop().unwrap();\n+        self.emit_drop_and_storage_dead_for_scope(&scope, &mut current);\n+        current\n+    }\n+\n+    fn emit_drop_and_storage_dead_for_scope(\n+        &mut self,\n+        scope: &DropScope,\n+        current: &mut Idx<BasicBlock>,\n+    ) {\n+        for &l in scope.locals.iter().rev() {\n+            if !self.result.locals[l].ty.clone().is_copy(self.db, self.owner) {\n+                let prev = std::mem::replace(current, self.new_basic_block());\n+                self.set_terminator(\n+                    prev,\n+                    TerminatorKind::Drop { place: l.into(), target: *current, unwind: None },\n+                    MirSpan::Unknown,\n+                );\n+            }\n+            self.push_statement(\n+                *current,\n+                StatementKind::StorageDead(l).with_span(MirSpan::Unknown),\n+            );\n+        }\n+    }\n }\n \n fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n@@ -1628,19 +1673,20 @@ pub fn mir_body_for_closure_query(\n     };\n     let (captures, _) = infer.closure_info(&closure);\n     let mut ctx = MirLowerCtx::new(db, owner, &body, &infer);\n-    ctx.result.arg_count = args.len() + 1;\n     // 0 is return local\n     ctx.result.locals.alloc(Local { ty: infer[*root].clone() });\n-    ctx.result.locals.alloc(Local { ty: infer[expr].clone() });\n+    let closure_local = ctx.result.locals.alloc(Local { ty: infer[expr].clone() });\n+    ctx.result.param_locals.push(closure_local);\n     let Some(sig) = ClosureSubst(substs).sig_ty().callable_sig(db) else {\n         implementation_error!(\"closure has not callable sig\");\n     };\n     let current = ctx.lower_params_and_bindings(\n         args.iter().zip(sig.params().iter()).map(|(x, y)| (*x, y.clone())),\n         |_| true,\n     )?;\n-    if let Some(b) = ctx.lower_expr_to_place(*root, return_slot().into(), current)? {\n-        ctx.set_terminator(b, TerminatorKind::Return, (*root).into());\n+    if let Some(current) = ctx.lower_expr_to_place(*root, return_slot().into(), current)? {\n+        let current = ctx.pop_drop_scope(current);\n+        ctx.set_terminator(current, TerminatorKind::Return, (*root).into());\n     }\n     let mut upvar_map: FxHashMap<LocalId, Vec<(&CapturedItem, usize)>> = FxHashMap::default();\n     for (i, capture) in captures.iter().enumerate() {\n@@ -1761,8 +1807,9 @@ pub fn lower_to_mir(\n         }\n         ctx.lower_params_and_bindings([].into_iter(), binding_picker)?\n     };\n-    if let Some(b) = ctx.lower_expr_to_place(root_expr, return_slot().into(), current)? {\n-        ctx.set_terminator(b, TerminatorKind::Return, root_expr.into());\n+    if let Some(current) = ctx.lower_expr_to_place(root_expr, return_slot().into(), current)? {\n+        let current = ctx.pop_drop_scope(current);\n+        ctx.set_terminator(current, TerminatorKind::Return, root_expr.into());\n     }\n     Ok(ctx.result)\n }"}, {"sha": "9515c18bb64287c9c39e6d1690eec577c658542c", "filename": "crates/hir-ty/src/mir/lower/as_place.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -17,7 +17,7 @@ impl MirLowerCtx<'_> {\n         prev_block: BasicBlockId,\n     ) -> Result<Option<(Place, BasicBlockId)>> {\n         let ty = self.expr_ty_without_adjust(expr_id);\n-        let place = self.temp(ty)?;\n+        let place = self.temp(ty, prev_block, expr_id.into())?;\n         let Some(current) = self.lower_expr_to_place_without_adjust(expr_id, place.into(), prev_block)? else {\n             return Ok(None);\n         };\n@@ -34,7 +34,7 @@ impl MirLowerCtx<'_> {\n             .last()\n             .map(|x| x.target.clone())\n             .unwrap_or_else(|| self.expr_ty_without_adjust(expr_id));\n-        let place = self.temp(ty)?;\n+        let place = self.temp(ty, prev_block, expr_id.into())?;\n         let Some(current) = self.lower_expr_to_place_with_adjust(expr_id, place.into(), prev_block, adjustments)? else {\n             return Ok(None);\n         };\n@@ -128,12 +128,8 @@ impl MirLowerCtx<'_> {\n         match &self.body.exprs[expr_id] {\n             Expr::Path(p) => {\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n-                let Some(pr) = resolver.resolve_path_in_value_ns(self.db.upcast(), p) else {\n-                    return Err(MirLowerError::unresolved_path(self.db, p));\n-                };\n-                let pr = match pr {\n-                    ResolveValueResult::ValueNs(v) => v,\n-                    ResolveValueResult::Partial(..) => return try_rvalue(self),\n+                let Some(pr) = resolver.resolve_path_in_value_ns_fully(self.db.upcast(), p) else {\n+                    return try_rvalue(self);\n                 };\n                 match pr {\n                     ValueNs::LocalBinding(pat_id) => {\n@@ -143,7 +139,7 @@ impl MirLowerCtx<'_> {\n                         let ty = self.expr_ty_without_adjust(expr_id);\n                         let ref_ty =\n                             TyKind::Ref(Mutability::Not, static_lifetime(), ty).intern(Interner);\n-                        let mut temp: Place = self.temp(ref_ty)?.into();\n+                        let mut temp: Place = self.temp(ref_ty, current, expr_id.into())?.into();\n                         self.push_assignment(\n                             current,\n                             temp.clone(),\n@@ -252,7 +248,8 @@ impl MirLowerCtx<'_> {\n                 else {\n                     return Ok(None);\n                 };\n-                let l_index = self.temp(self.expr_ty_after_adjustments(*index))?;\n+                let l_index =\n+                    self.temp(self.expr_ty_after_adjustments(*index), current, expr_id.into())?;\n                 let Some(current) = self.lower_expr_to_place(*index, l_index.into(), current)? else {\n                     return Ok(None);\n                 };\n@@ -273,24 +270,20 @@ impl MirLowerCtx<'_> {\n         span: MirSpan,\n         index_fn: (FunctionId, Substitution),\n     ) -> Result<Option<(Place, BasicBlockId)>> {\n-        let (mutability, borrow_kind) = match base_ty.as_reference() {\n-            Some((_, _, mutability)) => {\n-                (mutability, BorrowKind::Mut { allow_two_phase_borrow: false })\n-            }\n-            None => (Mutability::Not, BorrowKind::Shared),\n+        let mutability = match base_ty.as_reference() {\n+            Some((_, _, mutability)) => mutability,\n+            None => Mutability::Not,\n         };\n         let result_ref = TyKind::Ref(mutability, static_lifetime(), result_ty).intern(Interner);\n-        let ref_place: Place = self.temp(base_ty)?.into();\n-        self.push_assignment(current, ref_place.clone(), Rvalue::Ref(borrow_kind, place), span);\n-        let mut result: Place = self.temp(result_ref)?.into();\n+        let mut result: Place = self.temp(result_ref, current, span)?.into();\n         let index_fn_op = Operand::const_zst(\n             TyKind::FnDef(\n                 self.db.intern_callable_def(CallableDefId::FunctionId(index_fn.0)).into(),\n                 index_fn.1,\n             )\n             .intern(Interner),\n         );\n-        let Some(current) = self.lower_call(index_fn_op, vec![Operand::Copy(ref_place), index_operand], result.clone(), current, false, span)? else {\n+        let Some(current) = self.lower_call(index_fn_op, vec![Operand::Copy(place), index_operand], result.clone(), current, false, span)? else {\n             return Ok(None);\n         };\n         result.projection.push(ProjectionElem::Deref);\n@@ -318,7 +311,7 @@ impl MirLowerCtx<'_> {\n         };\n         let ty_ref = TyKind::Ref(chalk_mut, static_lifetime(), source_ty.clone()).intern(Interner);\n         let target_ty_ref = TyKind::Ref(chalk_mut, static_lifetime(), target_ty).intern(Interner);\n-        let ref_place: Place = self.temp(ty_ref)?.into();\n+        let ref_place: Place = self.temp(ty_ref, current, span)?.into();\n         self.push_assignment(current, ref_place.clone(), Rvalue::Ref(borrow_kind, place), span);\n         let deref_trait = self\n             .resolve_lang_item(trait_lang_item)?\n@@ -336,7 +329,7 @@ impl MirLowerCtx<'_> {\n             )\n             .intern(Interner),\n         );\n-        let mut result: Place = self.temp(target_ty_ref)?.into();\n+        let mut result: Place = self.temp(target_ty_ref, current, span)?.into();\n         let Some(current) = self.lower_call(deref_fn_op, vec![Operand::Copy(ref_place)], result.clone(), current, false, span)? else {\n             return Ok(None);\n         };"}, {"sha": "45c245e281bc4913b2251d2045c4e5e8e8b0efd8", "filename": "crates/hir-ty/src/mir/lower/pattern_matching.rs", "status": "modified", "additions": 97, "deletions": 27, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -107,7 +107,57 @@ impl MirLowerCtx<'_> {\n                 )?\n             }\n             Pat::Range { .. } => not_supported!(\"range pattern\"),\n-            Pat::Slice { .. } => not_supported!(\"slice pattern\"),\n+            Pat::Slice { prefix, slice, suffix } => {\n+                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+                for (i, &pat) in prefix.iter().enumerate() {\n+                    let mut next_place = cond_place.clone();\n+                    next_place\n+                        .projection\n+                        .push(ProjectionElem::ConstantIndex { offset: i as u64, from_end: false });\n+                    let cond_ty = self.infer[pat].clone();\n+                    (current, current_else) = self.pattern_match(\n+                        current,\n+                        current_else,\n+                        next_place,\n+                        cond_ty,\n+                        pat,\n+                        binding_mode,\n+                    )?;\n+                }\n+                if let Some(slice) = slice {\n+                    if let Pat::Bind { id, subpat: _ } = self.body[*slice] {\n+                        let mut next_place = cond_place.clone();\n+                        next_place.projection.push(ProjectionElem::Subslice {\n+                            from: prefix.len() as u64,\n+                            to: suffix.len() as u64,\n+                        });\n+                        (current, current_else) = self.pattern_match_binding(\n+                            id,\n+                            &mut binding_mode,\n+                            next_place,\n+                            (*slice).into(),\n+                            current,\n+                            current_else,\n+                        )?;\n+                    }\n+                }\n+                for (i, &pat) in suffix.iter().enumerate() {\n+                    let mut next_place = cond_place.clone();\n+                    next_place\n+                        .projection\n+                        .push(ProjectionElem::ConstantIndex { offset: i as u64, from_end: true });\n+                    let cond_ty = self.infer[pat].clone();\n+                    (current, current_else) = self.pattern_match(\n+                        current,\n+                        current_else,\n+                        next_place,\n+                        cond_ty,\n+                        pat,\n+                        binding_mode,\n+                    )?;\n+                }\n+                (current, current_else)\n+            }\n             Pat::Path(p) => match self.infer.variant_resolution_for_pat(pattern) {\n                 Some(variant) => self.pattern_matching_variant(\n                     cond_ty,\n@@ -128,17 +178,19 @@ impl MirLowerCtx<'_> {\n                     match pr {\n                         ResolveValueResult::ValueNs(v) => match v {\n                             ValueNs::ConstId(c) => {\n-                                let tmp: Place = self.temp(cond_ty.clone())?.into();\n+                                let tmp: Place =\n+                                    self.temp(cond_ty.clone(), current, pattern.into())?.into();\n                                 let span = pattern.into();\n                                 self.lower_const(\n-                                    c,\n+                                    c.into(),\n                                     current,\n                                     tmp.clone(),\n                                     Substitution::empty(Interner),\n                                     span,\n                                     cond_ty.clone(),\n                                 )?;\n-                                let tmp2: Place = self.temp(TyBuilder::bool())?.into();\n+                                let tmp2: Place =\n+                                    self.temp(TyBuilder::bool(), current, pattern.into())?.into();\n                                 self.push_assignment(\n                                     current,\n                                     tmp2.clone(),\n@@ -180,8 +232,6 @@ impl MirLowerCtx<'_> {\n                 _ => not_supported!(\"expression path literal\"),\n             },\n             Pat::Bind { id, subpat } => {\n-                let target_place = self.binding_local(*id)?;\n-                let mode = self.body.bindings[*id].mode;\n                 if let Some(subpat) = subpat {\n                     (current, current_else) = self.pattern_match(\n                         current,\n@@ -192,26 +242,14 @@ impl MirLowerCtx<'_> {\n                         binding_mode,\n                     )?\n                 }\n-                if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n-                    binding_mode = mode;\n-                }\n-                self.push_storage_live(*id, current)?;\n-                self.push_assignment(\n-                    current,\n-                    target_place.into(),\n-                    match binding_mode {\n-                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n-                            Operand::Copy(cond_place).into()\n-                        }\n-                        BindingAnnotation::Ref => Rvalue::Ref(BorrowKind::Shared, cond_place),\n-                        BindingAnnotation::RefMut => Rvalue::Ref(\n-                            BorrowKind::Mut { allow_two_phase_borrow: false },\n-                            cond_place,\n-                        ),\n-                    },\n+                self.pattern_match_binding(\n+                    *id,\n+                    &mut binding_mode,\n+                    cond_place,\n                     pattern.into(),\n-                );\n-                (current, current_else)\n+                    current,\n+                    current_else,\n+                )?\n             }\n             Pat::TupleStruct { path: _, args, ellipsis } => {\n                 let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n@@ -249,6 +287,38 @@ impl MirLowerCtx<'_> {\n         })\n     }\n \n+    fn pattern_match_binding(\n+        &mut self,\n+        id: BindingId,\n+        binding_mode: &mut BindingAnnotation,\n+        cond_place: Place,\n+        span: MirSpan,\n+        current: BasicBlockId,\n+        current_else: Option<BasicBlockId>,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        let target_place = self.binding_local(id)?;\n+        let mode = self.body.bindings[id].mode;\n+        if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n+            *binding_mode = mode;\n+        }\n+        self.push_storage_live(id, current)?;\n+        self.push_assignment(\n+            current,\n+            target_place.into(),\n+            match *binding_mode {\n+                BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n+                    Operand::Copy(cond_place).into()\n+                }\n+                BindingAnnotation::Ref => Rvalue::Ref(BorrowKind::Shared, cond_place),\n+                BindingAnnotation::RefMut => {\n+                    Rvalue::Ref(BorrowKind::Mut { allow_two_phase_borrow: false }, cond_place)\n+                }\n+            },\n+            span,\n+        );\n+        Ok((current, current_else))\n+    }\n+\n     fn pattern_match_const(\n         &mut self,\n         current_else: Option<BasicBlockId>,\n@@ -259,7 +329,7 @@ impl MirLowerCtx<'_> {\n     ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n         let then_target = self.new_basic_block();\n         let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n-        let discr: Place = self.temp(TyBuilder::bool())?.into();\n+        let discr: Place = self.temp(TyBuilder::bool(), current, pattern.into())?.into();\n         self.push_assignment(\n             current,\n             discr.clone(),\n@@ -297,7 +367,7 @@ impl MirLowerCtx<'_> {\n         Ok(match variant {\n             VariantId::EnumVariantId(v) => {\n                 let e = self.const_eval_discriminant(v)? as u128;\n-                let tmp = self.discr_temp_place();\n+                let tmp = self.discr_temp_place(current);\n                 self.push_assignment(\n                     current,\n                     tmp.clone(),"}, {"sha": "f92589ea77cf0a31b8d2abecd29e74cf7ad1639b", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -1812,6 +1812,20 @@ fn main() {\n       //^ [(); 7]\n }\"#,\n     );\n+    check_types(\n+        r#\"\n+trait Foo {\n+    fn x(self);\n+}\n+\n+impl Foo for u8 {\n+    fn x(self) {\n+        let t = [0; 4 + 2];\n+          //^ [i32; 6]\n+    }\n+}\n+    \"#,\n+    );\n }\n \n #[test]\n@@ -2137,6 +2151,7 @@ async fn main() {\n             136..138 '()': ()\n             150..151 'w': i32\n             154..166 'const { 92 }': i32\n+            154..166 'const { 92 }': i32\n             162..164 '92': i32\n             176..177 't': i32\n             180..190 ''a: { 92 }': i32"}, {"sha": "b82e0f3601198805c924c36e7aca4b048a5daf1a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -1857,18 +1857,34 @@ impl Function {\n         self,\n         db: &dyn HirDatabase,\n         span_formatter: impl Fn(FileId, TextRange) -> String,\n-    ) -> Result<(), String> {\n-        let converter = |e: MirEvalError| {\n-            let mut r = String::new();\n-            _ = e.pretty_print(&mut r, db, &span_formatter);\n-            r\n+    ) -> String {\n+        let body = match db.mir_body(self.id.into()) {\n+            Ok(body) => body,\n+            Err(e) => {\n+                let mut r = String::new();\n+                _ = e.pretty_print(&mut r, db, &span_formatter);\n+                return r;\n+            }\n+        };\n+        let (result, stdout, stderr) =\n+            interpret_mir(db, &body, Substitution::empty(Interner), false);\n+        let mut text = match result {\n+            Ok(_) => \"pass\".to_string(),\n+            Err(e) => {\n+                let mut r = String::new();\n+                _ = e.pretty_print(&mut r, db, &span_formatter);\n+                r\n+            }\n         };\n-        let body = db\n-            .mir_body(self.id.into())\n-            .map_err(|e| MirEvalError::MirLowerError(self.id.into(), e))\n-            .map_err(converter)?;\n-        interpret_mir(db, &body, Substitution::empty(Interner), false).map_err(converter)?;\n-        Ok(())\n+        if !stdout.is_empty() {\n+            text += \"\\n--------- stdout ---------\\n\";\n+            text += &stdout;\n+        }\n+        if !stderr.is_empty() {\n+            text += \"\\n--------- stderr ---------\\n\";\n+            text += &stderr;\n+        }\n+        text\n     }\n }\n \n@@ -3665,9 +3681,9 @@ impl Type {\n         }\n     }\n \n-    pub fn as_array(&self, _db: &dyn HirDatabase) -> Option<(Type, usize)> {\n+    pub fn as_array(&self, db: &dyn HirDatabase) -> Option<(Type, usize)> {\n         if let TyKind::Array(ty, len) = &self.ty.kind(Interner) {\n-            try_const_usize(len).map(|x| (self.derived(ty.clone()), x as usize))\n+            try_const_usize(db, len).map(|x| (self.derived(ty.clone()), x as usize))\n         } else {\n             None\n         }"}, {"sha": "cbcbb4b09db488f5e08fb66864c08d96def21598", "filename": "crates/ide/src/interpret_function.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fide%2Fsrc%2Finterpret_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Fide%2Fsrc%2Finterpret_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finterpret_function.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -42,8 +42,5 @@ fn find_and_interpret(db: &RootDatabase, position: FilePosition) -> Option<Strin\n         let path = path.as_deref().unwrap_or(\"<unknown file>\");\n         format!(\"file://{path}#{}:{}\", line_col.line + 1, line_col.col)\n     };\n-    match def.eval(db, span_formatter) {\n-        Ok(_) => Some(\"pass\".to_string()),\n-        Err(e) => Some(e),\n-    }\n+    Some(def.eval(db, span_formatter))\n }"}, {"sha": "07782114cf6eaa828c3523d7b4cd4f30134b37db", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcafd3539d20c2fd9210b378e132b94b50ba6be/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=cbcafd3539d20c2fd9210b378e132b94b50ba6be", "patch": "@@ -324,6 +324,13 @@ pub mod mem {\n         }\n     }\n }\n+\n+pub mod ptr {\n+    #[lang = \"drop_in_place\"]\n+    pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+        unsafe { drop_in_place(to_drop) }\n+    }\n+}\n // endregion:drop\n \n pub mod ops {\n@@ -1075,10 +1082,8 @@ pub mod iter {\n \n // region:panic\n mod panic {\n-    pub macro panic_2021 {\n-        ($($t:tt)+) => (\n-            /* Nothing yet */\n-        ),\n+    pub macro panic_2021($($t:tt)+) {\n+        /* Nothing yet */\n     }\n }\n // endregion:panic\n@@ -1158,8 +1163,8 @@ pub mod prelude {\n             ops::Drop,                          // :drop\n             ops::{Fn, FnMut, FnOnce},           // :fn\n             option::Option::{self, None, Some}, // :option\n-            result::Result::{self, Err, Ok},    // :result\n             panic,                              // :panic\n+            result::Result::{self, Err, Ok},    // :result\n         };\n     }\n "}]}