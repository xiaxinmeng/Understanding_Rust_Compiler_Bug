{"sha": "a29dada983fa8d44f789d3a64408b7ad4f4c3487", "node_id": "C_kwDOAAsO6NoAKGEyOWRhZGE5ODNmYThkNDRmNzg5ZDNhNjQ0MDhiN2FkNGY0YzM0ODc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-13T04:03:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-13T04:03:10Z"}, "message": "Auto merge of #108283 - the8472:remove-splice-into-pipe, r=ChrisDenton\n\ndon't splice from files into pipes in io::copy\n\nThis fixes potential data ordering issue where a write performed after a copy operation could become visible in the copy even though it signaled completion.\n\nI assumed that by not setting `SPLICE_F_MOVE` we would be safe and the kernel would do a copy in kernel space and we could avoid the read-write syscall and copy-to/from-userspace costs. But apparently that flag only makes a difference when splicing from a pipe, but not when splicing into it.\n\nContext: https://lkml.org/lkml/2023/2/9/673", "tree": {"sha": "5a7ad7e72aee96c28151c76b87159595668ec73c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a7ad7e72aee96c28151c76b87159595668ec73c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a29dada983fa8d44f789d3a64408b7ad4f4c3487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a29dada983fa8d44f789d3a64408b7ad4f4c3487", "html_url": "https://github.com/rust-lang/rust/commit/a29dada983fa8d44f789d3a64408b7ad4f4c3487", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a29dada983fa8d44f789d3a64408b7ad4f4c3487/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8fc8192471063c7b72fb2f95f61a9427ab84b86", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8fc8192471063c7b72fb2f95f61a9427ab84b86", "html_url": "https://github.com/rust-lang/rust/commit/d8fc8192471063c7b72fb2f95f61a9427ab84b86"}, {"sha": "171ccb54f06a168f10249b6cbfc22b1cb66ee125", "url": "https://api.github.com/repos/rust-lang/rust/commits/171ccb54f06a168f10249b6cbfc22b1cb66ee125", "html_url": "https://github.com/rust-lang/rust/commit/171ccb54f06a168f10249b6cbfc22b1cb66ee125"}], "stats": {"total": 104, "additions": 88, "deletions": 16}, "files": [{"sha": "16c8e0c0ebfc50f34aa4b1a12e5649b500f1a3d0", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a29dada983fa8d44f789d3a64408b7ad4f4c3487/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29dada983fa8d44f789d3a64408b7ad4f4c3487/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=a29dada983fa8d44f789d3a64408b7ad4f4c3487", "patch": "@@ -17,11 +17,9 @@\n //! Once it has obtained all necessary pieces and brought any wrapper types into a state where they\n //! can be safely bypassed it will attempt to use the `copy_file_range(2)`,\n //! `sendfile(2)` or `splice(2)` syscalls to move data directly between file descriptors.\n-//! Since those syscalls have requirements that cannot be fully checked in advance and\n-//! gathering additional information about file descriptors would require additional syscalls\n-//! anyway it simply attempts to use them one after another (guided by inaccurate hints) to\n-//! figure out which one works and falls back to the generic read-write copy loop if none of them\n-//! does.\n+//! Since those syscalls have requirements that cannot be fully checked in advance it attempts\n+//! to use them one after another (guided by hints) to figure out which one works and\n+//! falls back to the generic read-write copy loop if none of them does.\n //! Once a working syscall is found for a pair of file descriptors it will be called in a loop\n //! until the copy operation is completed.\n //!\n@@ -84,14 +82,10 @@ pub(crate) fn copy_spec<R: Read + ?Sized, W: Write + ?Sized>(\n /// The methods on this type only provide hints, due to `AsRawFd` and `FromRawFd` the inferred\n /// type may be wrong.\n enum FdMeta {\n-    /// We obtained the FD from a type that can contain any type of `FileType` and queried the metadata\n-    /// because it is cheaper than probing all possible syscalls (reader side)\n     Metadata(Metadata),\n     Socket,\n     Pipe,\n-    /// We don't have any metadata, e.g. because the original type was `File` which can represent\n-    /// any `FileType` and we did not query the metadata either since it did not seem beneficial\n-    /// (writer side)\n+    /// We don't have any metadata because the stat syscall failed\n     NoneObtained,\n }\n \n@@ -131,6 +125,39 @@ impl FdMeta {\n     }\n }\n \n+/// Returns true either if changes made to the source after a sendfile/splice call won't become\n+/// visible in the sink or the source has explicitly opted into such behavior (e.g. by splicing\n+/// a file into a pipe, the pipe being the source in this case).\n+///\n+/// This will prevent File -> Pipe and File -> Socket splicing/sendfile optimizations to uphold\n+/// the Read/Write API semantics of io::copy.\n+///\n+/// Note: This is not 100% airtight, the caller can use the RawFd conversion methods to turn a\n+/// regular file into a TcpSocket which will be treated as a socket here without checking.\n+fn safe_kernel_copy(source: &FdMeta, sink: &FdMeta) -> bool {\n+    match (source, sink) {\n+        // Data arriving from a socket is safe because the sender can't modify the socket buffer.\n+        // Data arriving from a pipe is safe(-ish) because either the sender *copied*\n+        // the bytes into the pipe OR explicitly performed an operation that enables zero-copy,\n+        // thus promising not to modify the data later.\n+        (FdMeta::Socket, _) => true,\n+        (FdMeta::Pipe, _) => true,\n+        (FdMeta::Metadata(meta), _)\n+            if meta.file_type().is_fifo() || meta.file_type().is_socket() =>\n+        {\n+            true\n+        }\n+        // Data going into non-pipes/non-sockets is safe because the \"later changes may become visible\" issue\n+        // only happens for pages sitting in send buffers or pipes.\n+        (_, FdMeta::Metadata(meta))\n+            if !meta.file_type().is_fifo() && !meta.file_type().is_socket() =>\n+        {\n+            true\n+        }\n+        _ => false,\n+    }\n+}\n+\n struct CopyParams(FdMeta, Option<RawFd>);\n \n struct Copier<'a, 'b, R: Read + ?Sized, W: Write + ?Sized> {\n@@ -186,7 +213,8 @@ impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n             // So we just try and fallback if needed.\n             // If current file offsets + write sizes overflow it may also fail, we do not try to fix that and instead\n             // fall back to the generic copy loop.\n-            if input_meta.potential_sendfile_source() {\n+            if input_meta.potential_sendfile_source() && safe_kernel_copy(&input_meta, &output_meta)\n+            {\n                 let result = sendfile_splice(SpliceMode::Sendfile, readfd, writefd, max_write);\n                 result.update_take(reader);\n \n@@ -197,7 +225,9 @@ impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n                 }\n             }\n \n-            if input_meta.maybe_fifo() || output_meta.maybe_fifo() {\n+            if (input_meta.maybe_fifo() || output_meta.maybe_fifo())\n+                && safe_kernel_copy(&input_meta, &output_meta)\n+            {\n                 let result = sendfile_splice(SpliceMode::Splice, readfd, writefd, max_write);\n                 result.update_take(reader);\n \n@@ -298,13 +328,13 @@ impl CopyRead for &File {\n \n impl CopyWrite for File {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n     }\n }\n \n impl CopyWrite for &File {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(*self), Some(self.as_raw_fd()))\n     }\n }\n \n@@ -401,13 +431,13 @@ impl CopyRead for StdinLock<'_> {\n \n impl CopyWrite for StdoutLock<'_> {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n     }\n }\n \n impl CopyWrite for StderrLock<'_> {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n     }\n }\n "}, {"sha": "a524270e3fb85bccde2baf0baf82d0725fbf3be5", "filename": "library/std/src/sys/unix/kernel_copy/tests.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a29dada983fa8d44f789d3a64408b7ad4f4c3487/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29dada983fa8d44f789d3a64408b7ad4f4c3487/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs?ref=a29dada983fa8d44f789d3a64408b7ad4f4c3487", "patch": "@@ -83,6 +83,48 @@ fn copies_append_mode_sink() -> Result<()> {\n     Ok(())\n }\n \n+#[test]\n+fn dont_splice_pipes_from_files() -> Result<()> {\n+    // splicing to a pipe and then modifying the source could lead to changes\n+    // becoming visible in an unexpected order.\n+\n+    use crate::io::SeekFrom;\n+    use crate::os::unix::fs::FileExt;\n+    use crate::process::{ChildStdin, ChildStdout};\n+    use crate::sys_common::FromInner;\n+\n+    let (read_end, write_end) = crate::sys::pipe::anon_pipe()?;\n+\n+    let mut read_end = ChildStdout::from_inner(read_end);\n+    let mut write_end = ChildStdin::from_inner(write_end);\n+\n+    let tmp_path = tmpdir();\n+    let file = tmp_path.join(\"to_be_modified\");\n+    let mut file =\n+        crate::fs::OpenOptions::new().create_new(true).read(true).write(true).open(file)?;\n+\n+    const SZ: usize = libc::PIPE_BUF as usize;\n+\n+    // put data in page cache\n+    let mut buf: [u8; SZ] = [0x01; SZ];\n+    file.write_all(&buf).unwrap();\n+\n+    // copy page into pipe\n+    file.seek(SeekFrom::Start(0)).unwrap();\n+    assert!(io::copy(&mut file, &mut write_end).unwrap() == SZ as u64);\n+\n+    // modify file\n+    buf[0] = 0x02;\n+    file.write_at(&buf, 0).unwrap();\n+\n+    // read from pipe\n+    read_end.read_exact(buf.as_mut_slice()).unwrap();\n+\n+    assert_eq!(buf[0], 0x01, \"data in pipe should reflect the original, not later modifications\");\n+\n+    Ok(())\n+}\n+\n #[bench]\n fn bench_file_to_file_copy(b: &mut test::Bencher) {\n     const BYTES: usize = 128 * 1024;"}]}