{"sha": "afb85cfd33a6ef52edf8707aea12d952a64bb84c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYjg1Y2ZkMzNhNmVmNTJlZGY4NzA3YWVhMTJkOTUyYTY0YmI4NGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-13T20:22:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-17T16:41:43Z"}, "message": "rustc: Mostly remove `ExportedSymbols`\n\nThis is a big map that ends up inside of a `CrateContext` during translation for\nall codegen units. This means that any change to the map may end up causing an\nincremental recompilation of a codegen unit! In order to reduce the amount of\ndependencies here between codegen units and the actual input crate this commit\nrefactors dealing with exported symbols and such into various queries.\n\nThe new queries are largely based on existing queries with filled out\nimplementations for the local crate in addition to external crates, but the main\nidea is that while translating codegen untis no unit needs the entire set of\nexported symbols, instead they only need queries about particulare `DefId`\ninstances every now and then.\n\nThe linking stage, however, still generates a full list of all exported symbols\nfrom all crates, but that's going to always happen unconditionally anyway, so no\nnews there!", "tree": {"sha": "4920b67d68c965a7ad02ea688f44ab19c94fac13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4920b67d68c965a7ad02ea688f44ab19c94fac13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afb85cfd33a6ef52edf8707aea12d952a64bb84c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afb85cfd33a6ef52edf8707aea12d952a64bb84c", "html_url": "https://github.com/rust-lang/rust/commit/afb85cfd33a6ef52edf8707aea12d952a64bb84c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afb85cfd33a6ef52edf8707aea12d952a64bb84c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8821affd1523a719ffb9f6537d53f8725ab00592", "url": "https://api.github.com/repos/rust-lang/rust/commits/8821affd1523a719ffb9f6537d53f8725ab00592", "html_url": "https://github.com/rust-lang/rust/commit/8821affd1523a719ffb9f6537d53f8725ab00592"}], "stats": {"total": 546, "additions": 233, "deletions": 313}, "files": [{"sha": "bfbf280d6ddbabb2bc5da06fbeb175c873cdecc1", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -575,7 +575,7 @@ define_dep_nodes!( <'tcx>\n     [] MaybeUnusedExternCrates,\n     [] StabilityIndex,\n     [] AllCrateNums,\n-    [] ExportedSymbols,\n+    [] ExportedSymbols(CrateNum),\n     [] CollectAndPartitionTranslationItems,\n     [] ExportName(DefId),\n     [] ContainsExternIndicator(DefId),"}, {"sha": "bea6ef4dc11ce6d850f93e5e98445794397d1d88", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -366,8 +366,9 @@ pub trait CrateLoader {\n // In order to get this left-to-right dependency ordering, we perform a\n // topological sort of all crates putting the leaves at the right-most\n // positions.\n-pub fn used_crates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)> {\n+pub fn used_crates(tcx: TyCtxt, prefer: LinkagePreference)\n+    -> Vec<(CrateNum, LibSource)>\n+{\n     let mut libs = tcx.crates()\n         .iter()\n         .cloned()"}, {"sha": "230878f8545950c34428c6d650ab1866a3dec9f7", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 7, "deletions": 53, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use util::nodemap::{FxHashMap, NodeSet};\n-use hir::def_id::{DefId, CrateNum};\n-\n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any\n /// kind of crate, including cdylibs which export very few things.\n@@ -22,56 +19,13 @@ pub enum SymbolExportLevel {\n     Rust,\n }\n \n-/// The set of symbols exported from each crate in the crate graph.\n-#[derive(Debug)]\n-pub struct ExportedSymbols {\n-    pub export_threshold: SymbolExportLevel,\n-    exports: FxHashMap<CrateNum, Vec<(String, DefId, SymbolExportLevel)>>,\n-    local_exports: NodeSet,\n-}\n-\n-impl ExportedSymbols {\n-    pub fn new(export_threshold: SymbolExportLevel,\n-               exports: FxHashMap<CrateNum, Vec<(String, DefId, SymbolExportLevel)>>,\n-               local_exports: NodeSet) -> ExportedSymbols {\n-        ExportedSymbols {\n-            export_threshold,\n-            exports,\n-            local_exports,\n-        }\n-    }\n-\n-    pub fn local_exports(&self) -> &NodeSet {\n-        &self.local_exports\n-    }\n-\n-    pub fn exported_symbols(&self, cnum: CrateNum)\n-        -> &[(String, DefId, SymbolExportLevel)]\n-    {\n-        match self.exports.get(&cnum) {\n-            Some(exports) => exports,\n-            None => &[]\n-        }\n-    }\n-\n-    pub fn for_each_exported_symbol<F>(&self, cnum: CrateNum, mut f: F)\n-        where F: FnMut(&str, DefId, SymbolExportLevel)\n-    {\n-        for &(ref name, def_id, export_level) in self.exported_symbols(cnum) {\n-            if is_below_threshold(export_level, self.export_threshold) {\n-                f(&name, def_id, export_level)\n-            }\n+impl SymbolExportLevel {\n+    pub fn is_below_threshold(self, threshold: SymbolExportLevel) -> bool {\n+        if threshold == SymbolExportLevel::Rust {\n+            // We export everything from Rust dylibs\n+            true\n+        } else {\n+            self == SymbolExportLevel::C\n         }\n     }\n }\n-\n-pub fn is_below_threshold(level: SymbolExportLevel,\n-                          threshold: SymbolExportLevel)\n-                          -> bool {\n-    if threshold == SymbolExportLevel::Rust {\n-        // We export everything from Rust dylibs\n-        true\n-    } else {\n-        level == SymbolExportLevel::C\n-    }\n-}"}, {"sha": "fb0cdab0b6a0fa6f3e47e4200412418ce638af8d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -27,7 +27,6 @@ use middle::cstore::EncodedMetadata;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n-use middle::exported_symbols::ExportedSymbols;\n use middle::stability;\n use mir::Mir;\n use mir::transform::Passes;\n@@ -65,7 +64,6 @@ use std::mem;\n use std::ops::Deref;\n use std::iter;\n use std::rc::Rc;\n-use std::sync::Arc;\n use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n@@ -1220,10 +1218,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Rc<Any> {\n         self.cstore.crate_data_as_rc_any(cnum)\n     }\n-\n-    pub fn exported_symbols(self) -> Arc<ExportedSymbols> {\n-        self.exported_symbol_set(LOCAL_CRATE)\n-    }\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {"}, {"sha": "dd6d90503ef1bd0b94f6fc98103f3e318e4b7928", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -23,7 +23,7 @@ use middle::region;\n use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n-use middle::exported_symbols::ExportedSymbols;\n+use middle::exported_symbols::SymbolExportLevel;\n use middle::trans::{TransItem, CodegenUnit};\n use mir;\n use mir::transform::{MirSuite, MirPassIndex};\n@@ -748,9 +748,9 @@ impl<'tcx> QueryDescription for queries::all_crate_nums<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::exported_symbol_set<'tcx> {\n+impl<'tcx> QueryDescription for queries::exported_symbols<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"exported symbol set\")\n+        format!(\"exported_symbols\")\n     }\n }\n \n@@ -1337,7 +1337,7 @@ define_maps! { <'tcx>\n     [] fn lint_levels: lint_levels_node(CrateNum) -> Rc<lint::LintLevelMap>,\n \n     [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n-    [] fn exported_symbol_ids: ExportedSymbolIds(CrateNum) -> Rc<Vec<DefId>>,\n+    [] fn exported_symbol_ids: ExportedSymbolIds(CrateNum) -> Rc<DefIdSet>,\n     [] fn native_libraries: NativeLibraries(CrateNum) -> Rc<Vec<NativeLibrary>>,\n     [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n     [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n@@ -1387,8 +1387,8 @@ define_maps! { <'tcx>\n     [] fn stability_index: stability_index_node(CrateNum) -> Rc<stability::Index<'tcx>>,\n     [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n \n-    [] fn exported_symbol_set: exported_symbol_set_node(CrateNum)\n-        -> Arc<ExportedSymbols>,\n+    [] fn exported_symbols: ExportedSymbols(CrateNum)\n+        -> Arc<Vec<(String, DefId, SymbolExportLevel)>>,\n     [] fn collect_and_partition_translation_items:\n         collect_and_partition_translation_items_node(CrateNum)\n         -> (Arc<FxHashSet<TransItem<'tcx>>>, Vec<Arc<CodegenUnit<'tcx>>>),\n@@ -1508,10 +1508,6 @@ fn all_crate_nums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::AllCrateNums\n }\n \n-fn exported_symbol_set_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::ExportedSymbols\n-}\n-\n fn collect_and_partition_translation_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::CollectAndPartitionTranslationItems\n }"}, {"sha": "1c4f1c6348689146aff5fdb0c4747389d2b57a5a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n+use rustc::util::nodemap::DefIdSet;\n \n use rustc::mir::Mir;\n \n@@ -1017,7 +1018,7 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn get_exported_symbols(&self) -> Vec<DefId> {\n+    pub fn get_exported_symbols(&self) -> DefIdSet {\n         self.exported_symbols\n             .iter()\n             .map(|&index| self.local_def_id(index))"}, {"sha": "239b488fabe0f1b6dc9e1032249ec4043b76096a", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -15,16 +15,15 @@ use std::io::prelude::*;\n use std::io::{self, BufWriter};\n use std::path::{Path, PathBuf};\n \n-use context::SharedCrateContext;\n-\n use back::archive;\n use back::command::Command;\n-use rustc::middle::dependency_format::Linkage;\n-use rustc::middle::exported_symbols::ExportedSymbols;\n+use back::symbol_export;\n use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n-use rustc_back::LinkerFlavor;\n+use rustc::middle::dependency_format::Linkage;\n use rustc::session::Session;\n use rustc::session::config::{self, CrateType, OptLevel, DebugInfoLevel};\n+use rustc::ty::TyCtxt;\n+use rustc_back::LinkerFlavor;\n use serialize::{json, Encoder};\n \n /// For all the linkers we support, and information they might\n@@ -33,19 +32,18 @@ pub struct LinkerInfo {\n     exports: HashMap<CrateType, Vec<String>>,\n }\n \n-impl<'a, 'tcx> LinkerInfo {\n-    pub fn new(scx: &SharedCrateContext<'a, 'tcx>) -> LinkerInfo {\n-        let exports = scx.tcx().exported_symbols();\n+impl LinkerInfo {\n+    pub fn new(tcx: TyCtxt) -> LinkerInfo {\n         LinkerInfo {\n-            exports: scx.sess().crate_types.borrow().iter().map(|&c| {\n-                (c, exported_symbols(scx, &exports, c))\n+            exports: tcx.sess.crate_types.borrow().iter().map(|&c| {\n+                (c, exported_symbols(tcx, c))\n             }).collect(),\n         }\n     }\n \n-    pub fn to_linker(&'a self,\n-                     cmd: Command,\n-                     sess: &'a Session) -> Box<Linker+'a> {\n+    pub fn to_linker<'a>(&'a self,\n+                         cmd: Command,\n+                         sess: &'a Session) -> Box<Linker+'a> {\n         match sess.linker_flavor() {\n             LinkerFlavor::Msvc => {\n                 Box::new(MsvcLinker {\n@@ -734,26 +732,29 @@ impl<'a> Linker for EmLinker<'a> {\n     }\n }\n \n-fn exported_symbols(scx: &SharedCrateContext,\n-                    exported_symbols: &ExportedSymbols,\n-                    crate_type: CrateType)\n-                    -> Vec<String> {\n+fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n     let mut symbols = Vec::new();\n-    exported_symbols.for_each_exported_symbol(LOCAL_CRATE, |name, _, _| {\n-        symbols.push(name.to_owned());\n-    });\n \n-    let formats = scx.sess().dependency_formats.borrow();\n+    let export_threshold = symbol_export::threshold(tcx);\n+    for &(ref name, _, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n+        if level.is_below_threshold(export_threshold) {\n+            symbols.push(name.clone());\n+        }\n+    }\n+\n+    let formats = tcx.sess.dependency_formats.borrow();\n     let deps = formats[&crate_type].iter();\n \n     for (index, dep_format) in deps.enumerate() {\n         let cnum = CrateNum::new(index + 1);\n         // For each dependency that we are linking to statically ...\n         if *dep_format == Linkage::Static {\n             // ... we add its symbol list to our export list.\n-            exported_symbols.for_each_exported_symbol(cnum, |name, _, _| {\n-                symbols.push(name.to_owned());\n-            })\n+            for &(ref name, _, level) in tcx.exported_symbols(cnum).iter() {\n+                if level.is_below_threshold(export_threshold) {\n+                    symbols.push(name.clone());\n+                }\n+            }\n         }\n     }\n "}, {"sha": "aa13e4aa196eecdf74526aa0c54fa2428dc44b71", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -16,7 +16,7 @@ use errors::{FatalError, Handler};\n use llvm;\n use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n-use rustc::middle::exported_symbols;\n+use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::util::common::time;\n use rustc::util::common::path2cstr;\n use rustc::hir::def_id::LOCAL_CRATE;\n@@ -68,8 +68,8 @@ pub fn run(cgcx: &CodegenContext,\n     let export_threshold =\n         symbol_export::crates_export_threshold(&cgcx.crate_types);\n \n-    let symbol_filter = &|&(ref name, _, level): &(String, _, _)| {\n-        if exported_symbols::is_below_threshold(level, export_threshold) {\n+    let symbol_filter = &|&(ref name, _, level): &(String, _, SymbolExportLevel)| {\n+        if level.is_below_threshold(export_threshold) {\n             let mut bytes = Vec::with_capacity(name.len() + 1);\n             bytes.extend(name.bytes());\n             Some(CString::new(bytes).unwrap())\n@@ -78,8 +78,7 @@ pub fn run(cgcx: &CodegenContext,\n         }\n     };\n \n-    let mut symbol_white_list: Vec<CString> = cgcx.exported_symbols\n-        .exported_symbols(LOCAL_CRATE)\n+    let mut symbol_white_list: Vec<CString> = cgcx.exported_symbols[&LOCAL_CRATE]\n         .iter()\n         .filter_map(symbol_filter)\n         .collect();\n@@ -89,9 +88,9 @@ pub fn run(cgcx: &CodegenContext,\n     // module that we've got.\n     for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n         symbol_white_list.extend(\n-            cgcx.exported_symbols.exported_symbols(cnum)\n-                                 .iter()\n-                                 .filter_map(symbol_filter));\n+            cgcx.exported_symbols[&cnum]\n+                .iter()\n+                .filter_map(symbol_filter));\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let bytecodes = archive.iter().filter_map(|child| {"}, {"sha": "844442edbc8721880b25db58d034a501ff05a4ff", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 118, "deletions": 98, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -8,89 +8,140 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n use base;\n use monomorphize::Instance;\n-use rustc::util::nodemap::{FxHashMap, NodeSet};\n+use rustc::hir::def_id::CrateNum;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE, INVALID_CRATE, CRATE_DEF_INDEX};\n+use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config;\n use rustc::ty::TyCtxt;\n+use rustc::ty::maps::Providers;\n+use rustc::util::nodemap::FxHashMap;\n use rustc_allocator::ALLOCATOR_METHODS;\n-use rustc::middle::exported_symbols::{ExportedSymbols, SymbolExportLevel};\n-use rustc::middle::exported_symbols::is_below_threshold;\n \n-pub fn compute<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ExportedSymbols {\n-    let export_threshold = crates_export_threshold(&tcx.sess.crate_types.borrow());\n-    let local_exported_symbols = base::find_exported_symbols(tcx);\n+pub type ExportedSymbols = FxHashMap<\n+    CrateNum,\n+    Arc<Vec<(String, DefId, SymbolExportLevel)>>,\n+>;\n \n-    let mut local_crate: Vec<_> = local_exported_symbols\n-        .iter()\n-        .map(|&node_id| {\n-            tcx.hir.local_def_id(node_id)\n-        })\n-        .map(|def_id| {\n-            let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-            let export_level = export_level(tcx, def_id);\n-            debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n-            (str::to_owned(&name), def_id, export_level)\n-        })\n-        .collect();\n-\n-    let mut local_exports = local_crate\n-        .iter()\n-        .filter_map(|&(_, def_id, level)| {\n-            if is_below_threshold(level, export_threshold) {\n-                tcx.hir.as_local_node_id(def_id)\n-            } else {\n-                None\n-            }\n-        })\n-        .collect::<NodeSet>();\n+pub fn threshold(tcx: TyCtxt) -> SymbolExportLevel {\n+    crates_export_threshold(&tcx.sess.crate_types.borrow())\n+}\n \n-    const INVALID_DEF_ID: DefId = DefId {\n-        krate: INVALID_CRATE,\n-        index: CRATE_DEF_INDEX,\n-    };\n+pub fn metadata_symbol_name(tcx: TyCtxt) -> String {\n+    format!(\"rust_metadata_{}_{}\",\n+            tcx.crate_name(LOCAL_CRATE),\n+            tcx.crate_disambiguator(LOCAL_CRATE))\n+}\n \n-    if let Some(_) = *tcx.sess.entry_fn.borrow() {\n-        local_crate.push((\"main\".to_string(),\n-                          INVALID_DEF_ID,\n-                          SymbolExportLevel::C));\n+fn crate_export_threshold(crate_type: config::CrateType) -> SymbolExportLevel {\n+    match crate_type {\n+        config::CrateTypeExecutable |\n+        config::CrateTypeStaticlib  |\n+        config::CrateTypeProcMacro  |\n+        config::CrateTypeCdylib     => SymbolExportLevel::C,\n+        config::CrateTypeRlib       |\n+        config::CrateTypeDylib      => SymbolExportLevel::Rust,\n     }\n+}\n \n-    if tcx.sess.allocator_kind.get().is_some() {\n-        for method in ALLOCATOR_METHODS {\n-            local_crate.push((format!(\"__rust_{}\", method.name),\n-                              INVALID_DEF_ID,\n-                              SymbolExportLevel::Rust));\n-        }\n+pub fn crates_export_threshold(crate_types: &[config::CrateType])\n+                                      -> SymbolExportLevel {\n+    if crate_types.iter().any(|&crate_type| {\n+        crate_export_threshold(crate_type) == SymbolExportLevel::Rust\n+    }) {\n+        SymbolExportLevel::Rust\n+    } else {\n+        SymbolExportLevel::C\n     }\n+}\n \n-    if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n-        let def_id = tcx.hir.local_def_id(id);\n-        let idx = def_id.index;\n-        let disambiguator = tcx.sess.local_crate_disambiguator();\n-        let registrar = tcx.sess.generate_derive_registrar_symbol(disambiguator, idx);\n-        local_crate.push((registrar, def_id, SymbolExportLevel::C));\n-        local_exports.insert(id);\n-    }\n+pub fn provide_local(providers: &mut Providers) {\n+    providers.exported_symbol_ids = |tcx, cnum| {\n+        let export_threshold = threshold(tcx);\n+        Rc::new(tcx.exported_symbols(cnum)\n+            .iter()\n+            .filter_map(|&(_, id, level)| {\n+                if level.is_below_threshold(export_threshold) {\n+                    Some(id)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect())\n+    };\n \n-    if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n-        local_crate.push((metadata_symbol_name(tcx),\n-                          INVALID_DEF_ID,\n-                          SymbolExportLevel::Rust));\n-    }\n+    providers.is_exported_symbol = |tcx, id| {\n+        // FIXME(#42293) needs red/green to not break a bunch of incremental\n+        // tests\n+        tcx.dep_graph.with_ignore(|| {\n+            tcx.exported_symbol_ids(id.krate).contains(&id)\n+        })\n+    };\n+\n+    providers.exported_symbols = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        let local_exported_symbols = base::find_exported_symbols(tcx);\n+\n+        let mut local_crate: Vec<_> = local_exported_symbols\n+            .iter()\n+            .map(|&node_id| {\n+                tcx.hir.local_def_id(node_id)\n+            })\n+            .map(|def_id| {\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n+                let export_level = export_level(tcx, def_id);\n+                debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n+                (str::to_owned(&name), def_id, export_level)\n+            })\n+            .collect();\n+\n+        const INVALID_DEF_ID: DefId = DefId {\n+            krate: INVALID_CRATE,\n+            index: CRATE_DEF_INDEX,\n+        };\n+\n+        if let Some(_) = *tcx.sess.entry_fn.borrow() {\n+            local_crate.push((\"main\".to_string(),\n+                              INVALID_DEF_ID,\n+                              SymbolExportLevel::C));\n+        }\n \n-    let mut exports = FxHashMap();\n-    exports.insert(LOCAL_CRATE, local_crate);\n+        if tcx.sess.allocator_kind.get().is_some() {\n+            for method in ALLOCATOR_METHODS {\n+                local_crate.push((format!(\"__rust_{}\", method.name),\n+                                  INVALID_DEF_ID,\n+                                  SymbolExportLevel::Rust));\n+            }\n+        }\n \n-    for &cnum in tcx.crates().iter() {\n-        debug_assert!(cnum != LOCAL_CRATE);\n+        if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n+            let def_id = tcx.hir.local_def_id(id);\n+            let idx = def_id.index;\n+            let disambiguator = tcx.sess.local_crate_disambiguator();\n+            let registrar = tcx.sess.generate_derive_registrar_symbol(disambiguator, idx);\n+            local_crate.push((registrar, def_id, SymbolExportLevel::C));\n+        }\n \n+        if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n+            local_crate.push((metadata_symbol_name(tcx),\n+                              INVALID_DEF_ID,\n+                              SymbolExportLevel::Rust));\n+        }\n+        Arc::new(local_crate)\n+    };\n+}\n+\n+pub fn provide_extern(providers: &mut Providers) {\n+    providers.exported_symbols = |tcx, cnum| {\n         // If this crate is a plugin and/or a custom derive crate, then\n         // we're not even going to link those in so we skip those crates.\n         if tcx.plugin_registrar_fn(cnum).is_some() ||\n            tcx.derive_registrar_fn(cnum).is_some() {\n-            continue;\n+            return Arc::new(Vec::new())\n         }\n \n         // Check to see if this crate is a \"special runtime crate\". These\n@@ -131,45 +182,14 @@ pub fn compute<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ExportedSymbols {\n             })\n             .collect();\n \n-        exports.insert(cnum, crate_exports);\n-    }\n-\n-    return ExportedSymbols::new(export_threshold, exports, local_exports);\n-\n-    fn export_level(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n-        if tcx.contains_extern_indicator(sym_def_id) {\n-            SymbolExportLevel::C\n-        } else {\n-            SymbolExportLevel::Rust\n-        }\n-    }\n-}\n-\n-pub fn metadata_symbol_name(tcx: TyCtxt) -> String {\n-    format!(\"rust_metadata_{}_{}\",\n-            tcx.crate_name(LOCAL_CRATE),\n-            tcx.crate_disambiguator(LOCAL_CRATE))\n-}\n-\n-pub fn crate_export_threshold(crate_type: config::CrateType)\n-                                     -> SymbolExportLevel {\n-    match crate_type {\n-        config::CrateTypeExecutable |\n-        config::CrateTypeStaticlib  |\n-        config::CrateTypeProcMacro  |\n-        config::CrateTypeCdylib     => SymbolExportLevel::C,\n-        config::CrateTypeRlib       |\n-        config::CrateTypeDylib      => SymbolExportLevel::Rust,\n-    }\n+        Arc::new(crate_exports)\n+    };\n }\n \n-pub fn crates_export_threshold(crate_types: &[config::CrateType])\n-                                      -> SymbolExportLevel {\n-    if crate_types.iter().any(|&crate_type| {\n-        crate_export_threshold(crate_type) == SymbolExportLevel::Rust\n-    }) {\n-        SymbolExportLevel::Rust\n-    } else {\n+fn export_level(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n+    if tcx.contains_extern_indicator(sym_def_id) {\n         SymbolExportLevel::C\n+    } else {\n+        SymbolExportLevel::Rust\n     }\n }"}, {"sha": "c8925ceb478ce3164708161c381f4b9ebc756c39", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -11,24 +11,27 @@\n use back::lto;\n use back::link::{self, get_linker, remove};\n use back::linker::LinkerInfo;\n-use rustc::middle::exported_symbols::ExportedSymbols;\n+use back::symbol_export::ExportedSymbols;\n use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::{LinkMeta, EncodedMetadata};\n use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Passes, SomePasses,\n                              AllPasses, Sanitizer};\n use rustc::session::Session;\n+use rustc::util::nodemap::FxHashMap;\n use time_graph::{self, TimeGraph};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleSource, ModuleTranslation, CompiledModule, ModuleKind};\n use CrateInfo;\n-use rustc::hir::def_id::CrateNum;\n+use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc::ty::TyCtxt;\n use rustc::util::common::{time, time_depth, set_time_depth, path2cstr, print_time_passes_entry};\n use rustc::util::fs::{link_or_copy, rename_or_copy_remove};\n use errors::{self, Handler, Level, DiagnosticBuilder, FatalError};\n use errors::emitter::{Emitter};\n+use syntax::attr;\n use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n use syntax_pos::symbol::Symbol;\n@@ -667,19 +670,40 @@ fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n     sess.opts.output_types.contains_key(&OutputType::Exe)\n }\n \n-pub fn start_async_translation(sess: &Session,\n+pub fn start_async_translation(tcx: TyCtxt,\n                                crate_output: &OutputFilenames,\n                                time_graph: Option<TimeGraph>,\n-                               crate_name: Symbol,\n                                link: LinkMeta,\n-                               metadata: EncodedMetadata,\n-                               exported_symbols: Arc<ExportedSymbols>,\n-                               no_builtins: bool,\n-                               windows_subsystem: Option<String>,\n-                               linker_info: LinkerInfo,\n-                               crate_info: CrateInfo,\n-                               no_integrated_as: bool)\n+                               metadata: EncodedMetadata)\n                                -> OngoingCrateTranslation {\n+    let sess = tcx.sess;\n+    let crate_name = tcx.crate_name(LOCAL_CRATE);\n+    let no_builtins = attr::contains_name(&tcx.hir.krate().attrs, \"no_builtins\");\n+    let subsystem = attr::first_attr_value_str_by_name(&tcx.hir.krate().attrs,\n+                                                       \"windows_subsystem\");\n+    let windows_subsystem = subsystem.map(|subsystem| {\n+        if subsystem != \"windows\" && subsystem != \"console\" {\n+            tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n+                                     `windows` and `console` are allowed\",\n+                                    subsystem));\n+        }\n+        subsystem.to_string()\n+    });\n+\n+    let no_integrated_as = tcx.sess.opts.cg.no_integrated_as ||\n+        (tcx.sess.target.target.options.no_integrated_as &&\n+         (crate_output.outputs.contains_key(&OutputType::Object) ||\n+          crate_output.outputs.contains_key(&OutputType::Exe)));\n+    let linker_info = LinkerInfo::new(tcx);\n+    let crate_info = CrateInfo::new(tcx);\n+\n+    let mut exported_symbols = FxHashMap();\n+    exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n+    for &cnum in tcx.crates().iter() {\n+        exported_symbols.insert(cnum, tcx.exported_symbols(cnum));\n+    }\n+    let exported_symbols = Arc::new(exported_symbols);\n+\n     let output_types_override = if no_integrated_as {\n         OutputTypes::new(&[(OutputType::Assembly, None)])\n     } else {"}, {"sha": "7941134cc7b07a9152956d175845545b34d494f9", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 12, "deletions": 59, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -30,7 +30,6 @@ use super::ModuleKind;\n \n use assert_module_sources;\n use back::link;\n-use back::linker::LinkerInfo;\n use back::symbol_export;\n use back::write::{self, OngoingCrateTranslation};\n use llvm::{ContextRef, ModuleRef, ValueRef, Vector, get_param};\n@@ -44,10 +43,9 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::dep_graph::AssertDepGraphSafe;\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n-use rustc::middle::exported_symbols::ExportedSymbols;\n use rustc::hir::map as hir_map;\n use rustc::util::common::{time, print_time_passes_entry};\n-use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType};\n+use rustc::session::config::{self, NoDebugInfo, OutputFilenames};\n use rustc::session::Session;\n use rustc_incremental::{self, IncrementalHashesMap};\n use abi;\n@@ -939,11 +937,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> OngoingCrateTranslation {\n     check_for_rustc_errors_attr(tcx);\n \n-    // Be careful with this krate: obviously it gives access to the\n-    // entire contents of the krate. So if you push any subtasks of\n-    // `TransCrate`, you need to be careful to register \"reads\" of the\n-    // particular items that will be processed.\n-    let krate = tcx.hir.krate();\n     let check_overflow = tcx.sess.overflow_checks();\n     let link_meta = link::build_link_meta(&incremental_hashes_map);\n     let exported_symbol_node_ids = find_exported_symbols(tcx);\n@@ -967,31 +960,21 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         kind: ModuleKind::Metadata,\n     };\n \n-    let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n     let time_graph = if tcx.sess.opts.debugging_opts.trans_time_graph {\n         Some(time_graph::TimeGraph::new())\n     } else {\n         None\n     };\n-    let crate_info = CrateInfo::new(tcx);\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n        !tcx.sess.opts.output_types.should_trans() {\n-        let linker_info = LinkerInfo::new(&shared_ccx);\n         let ongoing_translation = write::start_async_translation(\n-            tcx.sess,\n+            tcx,\n             output_filenames,\n             time_graph.clone(),\n-            tcx.crate_name(LOCAL_CRATE),\n             link_meta,\n-            metadata,\n-            shared_ccx.tcx().exported_symbols(),\n-            no_builtins,\n-            None,\n-            linker_info,\n-            crate_info,\n-            false);\n+            metadata);\n \n         ongoing_translation.submit_pre_translated_module_to_llvm(tcx.sess, metadata_module, true);\n \n@@ -1012,36 +995,12 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     assert!(codegen_units.len() <= 1 || !tcx.sess.lto());\n \n-    let linker_info = LinkerInfo::new(&shared_ccx);\n-    let subsystem = attr::first_attr_value_str_by_name(&krate.attrs,\n-                                                       \"windows_subsystem\");\n-    let windows_subsystem = subsystem.map(|subsystem| {\n-        if subsystem != \"windows\" && subsystem != \"console\" {\n-            tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n-                                     `windows` and `console` are allowed\",\n-                                    subsystem));\n-        }\n-        subsystem.to_string()\n-    });\n-\n-    let no_integrated_as = tcx.sess.opts.cg.no_integrated_as ||\n-        (tcx.sess.target.target.options.no_integrated_as &&\n-         (output_filenames.outputs.contains_key(&OutputType::Object) ||\n-          output_filenames.outputs.contains_key(&OutputType::Exe)));\n-\n     let ongoing_translation = write::start_async_translation(\n-        tcx.sess,\n+        tcx,\n         output_filenames,\n         time_graph.clone(),\n-        tcx.crate_name(LOCAL_CRATE),\n         link_meta,\n-        metadata,\n-        tcx.exported_symbols(),\n-        no_builtins,\n-        windows_subsystem,\n-        linker_info,\n-        crate_info,\n-        no_integrated_as);\n+        metadata);\n \n     // Translate an allocator shim, if any\n     //\n@@ -1118,8 +1077,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tcx.dep_graph.with_task(dep_node,\n                                         AssertDepGraphSafe(&shared_ccx),\n                                         AssertDepGraphSafe((cgu,\n-                                                            translation_items.clone(),\n-                                                            tcx.exported_symbols())),\n+                                                            translation_items.clone())),\n                                         module_translation);\n             all_stats.extend(stats);\n \n@@ -1161,13 +1119,12 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     fn module_translation<'a, 'tcx>(\n         scx: AssertDepGraphSafe<&SharedCrateContext<'a, 'tcx>>,\n         args: AssertDepGraphSafe<(Arc<CodegenUnit<'tcx>>,\n-                                  Arc<FxHashSet<TransItem<'tcx>>>,\n-                                  Arc<ExportedSymbols>)>)\n+                                  Arc<FxHashSet<TransItem<'tcx>>>)>)\n         -> (Stats, ModuleTranslation)\n     {\n         // FIXME(#40304): We ought to be using the id as a key and some queries, I think.\n         let AssertDepGraphSafe(scx) = scx;\n-        let AssertDepGraphSafe((cgu, crate_trans_items, exported_symbols)) = args;\n+        let AssertDepGraphSafe((cgu, crate_trans_items)) = args;\n \n         let cgu_name = cgu.name().to_string();\n         let cgu_id = cgu.work_product_id();\n@@ -1207,7 +1164,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Instantiate translation items without filling out definitions yet...\n-        let lcx = LocalCrateContext::new(scx, cgu, crate_trans_items, exported_symbols);\n+        let lcx = LocalCrateContext::new(scx, cgu, crate_trans_items);\n         let module = {\n             let ccx = CrateContext::new(scx, &lcx);\n             let trans_items = ccx.codegen_unit()\n@@ -1400,7 +1357,6 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n     let time_passes = tcx.sess.time_passes();\n-    let exported_symbols = tcx.exported_symbols();\n \n     let collection_mode = match tcx.sess.opts.debugging_opts.print_trans_items {\n         Some(ref s) => {\n@@ -1424,9 +1380,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n \n     let (items, inlining_map) =\n         time(time_passes, \"translation item collection\", || {\n-            collector::collect_crate_translation_items(tcx,\n-                                                       &exported_symbols,\n-                                                       collection_mode)\n+            collector::collect_crate_translation_items(tcx, collection_mode)\n     });\n \n     assert_symbols_are_distinct(tcx, items.iter());\n@@ -1441,8 +1395,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n         partitioning::partition(tcx,\n                                 items.iter().cloned(),\n                                 strategy,\n-                                &inlining_map,\n-                                &exported_symbols)\n+                                &inlining_map)\n             .into_iter()\n             .map(Arc::new)\n             .collect::<Vec<_>>()\n@@ -1510,7 +1463,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n }\n \n impl CrateInfo {\n-    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CrateInfo {\n+    pub fn new(tcx: TyCtxt) -> CrateInfo {\n         let mut info = CrateInfo {\n             panic_runtime: None,\n             compiler_builtins: None,"}, {"sha": "a904aa7ed876af4b6b2d06e35eb8598e559cc38f", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -114,8 +114,8 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n \n             if ccx.crate_trans_items().contains(&TransItem::Fn(instance)) {\n-                if let Some(node_id) = tcx.hir.as_local_node_id(instance_def_id) {\n-                    if !ccx.exported_symbols().local_exports().contains(&node_id) {\n+                if instance_def_id.is_local() {\n+                    if !ccx.tcx().is_exported_symbol(instance_def_id) {\n                         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n                     }\n                 } else {"}, {"sha": "6fa69de74b0a1560b7858706401a63a5da8704f3", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -194,7 +194,6 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n-use rustc::middle::exported_symbols::ExportedSymbols;\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem};\n use rustc::traits;\n use rustc::ty::subst::Substs;\n@@ -294,14 +293,13 @@ impl<'tcx> InliningMap<'tcx> {\n }\n \n pub fn collect_crate_translation_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 exported_symbols: &ExportedSymbols,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FxHashSet<TransItem<'tcx>>,\n                                                      InliningMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n     tcx.dep_graph.with_ignore(|| {\n-        let roots = collect_roots(tcx, exported_symbols, mode);\n+        let roots = collect_roots(tcx, mode);\n \n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FxHashSet();\n@@ -323,7 +321,6 @@ pub fn collect_crate_translation_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           exported_symbols: &ExportedSymbols,\n                            mode: TransItemCollectionMode)\n                            -> Vec<TransItem<'tcx>> {\n     debug!(\"Collecting roots\");\n@@ -333,7 +330,6 @@ fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut visitor = RootCollector {\n             tcx,\n             mode,\n-            exported_symbols,\n             output: &mut roots,\n         };\n \n@@ -865,7 +861,6 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    exported_symbols: &'b ExportedSymbols,\n     mode: TransItemCollectionMode,\n     output: &'b mut Vec<TransItem<'tcx>>,\n }\n@@ -926,8 +921,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 let def_id = tcx.hir.local_def_id(item.id);\n \n                 if (self.mode == TransItemCollectionMode::Eager ||\n-                    !tcx.is_const_fn(def_id) ||\n-                    self.exported_symbols.local_exports().contains(&item.id)) &&\n+                    !tcx.is_const_fn(def_id) || tcx.is_exported_symbol(def_id)) &&\n                    !item_has_type_parameters(tcx, def_id) {\n \n                     debug!(\"RootCollector: ItemFn({})\",\n@@ -953,7 +947,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n \n                 if (self.mode == TransItemCollectionMode::Eager ||\n                     !tcx.is_const_fn(def_id) ||\n-                    self.exported_symbols.local_exports().contains(&ii.id)) &&\n+                    tcx.is_exported_symbol(def_id)) &&\n                    !item_has_type_parameters(tcx, def_id) {\n                     debug!(\"RootCollector: MethodImplItem({})\",\n                            def_id_to_string(tcx, def_id));"}, {"sha": "78ece020d1d6b8a2999c8cb6fb4283811cf07af6", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -130,7 +130,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n                 let g = declare::define_global(ccx, &sym[..], llty).unwrap();\n \n-                if !ccx.exported_symbols().local_exports().contains(&id) {\n+                if !ccx.tcx().is_exported_symbol(def_id) {\n                     unsafe {\n                         llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n                     }"}, {"sha": "62dadce76f0e7a2d964a3f310187dedead053cf6", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -14,7 +14,6 @@ use llvm::{ContextRef, ModuleRef, ValueRef};\n use rustc::dep_graph::{DepGraph, DepGraphSafe};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::middle::exported_symbols::ExportedSymbols;\n use rustc::traits;\n use debuginfo;\n use callee;\n@@ -98,9 +97,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     /// The translation items of the whole crate.\n     crate_trans_items: Arc<FxHashSet<TransItem<'tcx>>>,\n \n-    /// Information about which symbols are exported from the crate.\n-    exported_symbols: Arc<ExportedSymbols>,\n-\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n@@ -354,8 +350,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n     pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n                codegen_unit: Arc<CodegenUnit<'tcx>>,\n-               crate_trans_items: Arc<FxHashSet<TransItem<'tcx>>>,\n-               exported_symbols: Arc<ExportedSymbols>,)\n+               crate_trans_items: Arc<FxHashSet<TransItem<'tcx>>>)\n                -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n@@ -388,7 +383,6 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 stats: Stats::default(),\n                 codegen_unit,\n                 crate_trans_items,\n-                exported_symbols,\n                 instances: RefCell::new(FxHashMap()),\n                 vtables: RefCell::new(FxHashMap()),\n                 const_cstr_cache: RefCell::new(FxHashMap()),\n@@ -499,10 +493,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().crate_trans_items\n     }\n \n-    pub fn exported_symbols(&self) -> &ExportedSymbols {\n-        &self.local().exported_symbols\n-    }\n-\n     pub fn td(&self) -> llvm::TargetDataRef {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }"}, {"sha": "ad4fdfca7261ff294fa46724c1fe6fb7ef8aa57e", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -37,7 +37,8 @@ pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    !cx.exported_symbols().local_exports().contains(&node_id)\n+    let def_id = cx.tcx().hir.local_def_id(node_id);\n+    !cx.tcx().is_exported_symbol(def_id)\n }\n \n #[allow(non_snake_case)]"}, {"sha": "d06c769458a7497588180eb0337f8641908d4fbe", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -69,9 +69,8 @@ pub use metadata::LlvmMetadataLoader;\n pub use llvm_util::{init, target_features, print_version, print_passes, print, enable_llvm_debug};\n \n use std::rc::Rc;\n-use std::sync::Arc;\n \n-use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc::hir::def_id::CrateNum;\n use rustc::middle::cstore::{NativeLibrary, CrateSource, LibSource};\n use rustc::ty::maps::Providers;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n@@ -251,13 +250,11 @@ __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }\n \n pub fn provide_local(providers: &mut Providers) {\n     back::symbol_names::provide(providers);\n+    back::symbol_export::provide_local(providers);\n     base::provide(providers);\n-    providers.exported_symbol_set = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        Arc::new(back::symbol_export::compute(tcx))\n-    };\n }\n \n pub fn provide_extern(providers: &mut Providers) {\n     back::symbol_names::provide(providers);\n+    back::symbol_export::provide_extern(providers);\n }"}, {"sha": "65cf24e8c6e035e95be906240c2cf76834bee53b", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb85cfd33a6ef52edf8707aea12d952a64bb84c/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=afb85cfd33a6ef52edf8707aea12d952a64bb84c", "patch": "@@ -108,7 +108,6 @@ use context::SharedCrateContext;\n use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n-use rustc::middle::exported_symbols::ExportedSymbols;\n use rustc::middle::trans::{Linkage, Visibility};\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n@@ -212,16 +211,14 @@ const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               trans_items: I,\n                               strategy: PartitioningStrategy,\n-                              inlining_map: &InliningMap<'tcx>,\n-                              exported_symbols: &ExportedSymbols)\n+                              inlining_map: &InliningMap<'tcx>)\n                               -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     // In the first step, we place all regular translation items into their\n     // respective 'home' codegen unit. Regular translation items are all\n     // functions and statics defined in the local crate.\n     let mut initial_partitioning = place_root_translation_items(tcx,\n-                                                                exported_symbols,\n                                                                 trans_items);\n \n     debug_dump(tcx, \"INITIAL PARTITIONING:\", initial_partitioning.codegen_units.iter());\n@@ -291,13 +288,10 @@ struct PostInliningPartitioning<'tcx> {\n }\n \n fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                             exported_symbols: &ExportedSymbols,\n                                              trans_items: I)\n                                              -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n-    let exported_symbols = exported_symbols.local_exports();\n-\n     let mut roots = FxHashSet();\n     let mut codegen_units = FxHashMap();\n     let is_incremental_build = tcx.sess.opts.incremental.is_some();\n@@ -330,8 +324,8 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         TransItem::Fn(ref instance) => {\n                             let visibility = match instance.def {\n                                 InstanceDef::Item(def_id) => {\n-                                    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-                                        if exported_symbols.contains(&node_id) {\n+                                    if def_id.is_local() {\n+                                        if tcx.is_exported_symbol(def_id) {\n                                             Visibility::Default\n                                         } else {\n                                             internalization_candidates.insert(trans_item);\n@@ -357,7 +351,8 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         }\n                         TransItem::Static(node_id) |\n                         TransItem::GlobalAsm(node_id) => {\n-                            let visibility = if exported_symbols.contains(&node_id) {\n+                            let def_id = tcx.hir.local_def_id(node_id);\n+                            let visibility = if tcx.is_exported_symbol(def_id) {\n                                 Visibility::Default\n                             } else {\n                                 internalization_candidates.insert(trans_item);"}]}