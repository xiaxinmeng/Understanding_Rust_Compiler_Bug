{"sha": "81550a00d1e8f83bbaef31205e72b27fdb796d35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNTUwYTAwZDFlOGY4M2JiYWVmMzEyMDVlNzJiMjdmZGI3OTZkMzU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-06T06:03:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-06T06:03:05Z"}, "message": "Rollup merge of #66015 - popzxc:refactor-librustc_parser, r=matklad\n\nlibrustc_lexer: Refactor the module\n\nThis PR introduces a refactoring of the `librustc_lexer` in order to improve readability.\n\nAll the changes performed are only cosmetic and do not introduce any changes the lexer logic or performance.\n\nNewly introduced modules `literal`, `token` and `utils` are just copy-pasted from the `lib.rs` and do not contain even cosmetic changes (I decided to do so so it'll be easier to review changes looking only on diff).\n\nr? @petrochenkov\n\ncc @Centril @matklad", "tree": {"sha": "bd7b39fcc7320311a711ebc9400eb1c9d2f0254a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd7b39fcc7320311a711ebc9400eb1c9d2f0254a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81550a00d1e8f83bbaef31205e72b27fdb796d35", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdwmIZCRBK7hj4Ov3rIwAAdHIIABdvaqJmPPd3DnADD6MK6S7r\nOZ4THiUUFycet+58m4zgHSDmzFHkarSlJFGk3oNuLIGHKKvMsCMhyqQ+CVgAZ3eP\nOrXJMTX3+nUOpxoQ/ARox3j0iKgUX3eenzEUIU98n6NJa2xgWxQPQNxKNLI0dgfO\n+gsBARlkLFWml52mvV7W6xdWy+ma75D6sHAk9npCAZ7TocitS/d0k2YNlW2WpXCL\nzX6ugBywc1GKuUzoiH1HRmH+uWV/f0T5puc80wkGPcacjTKlFv02oqkGbCMo3Dzx\nL0+0/2th37schMFGARK5dZMEw5/grZ7Ugmmzk5J6+ZLhz+USeMm/4Pcw1UQdD+M=\n=Bh4e\n-----END PGP SIGNATURE-----\n", "payload": "tree bd7b39fcc7320311a711ebc9400eb1c9d2f0254a\nparent 24af0c94b30271198d6101cdd14c78182f76fd07\nparent 31735b02c95510f2e236ebd773b02e84ee6e1a5b\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1573020185 +0100\ncommitter GitHub <noreply@github.com> 1573020185 +0100\n\nRollup merge of #66015 - popzxc:refactor-librustc_parser, r=matklad\n\nlibrustc_lexer: Refactor the module\n\nThis PR introduces a refactoring of the `librustc_lexer` in order to improve readability.\n\nAll the changes performed are only cosmetic and do not introduce any changes the lexer logic or performance.\n\nNewly introduced modules `literal`, `token` and `utils` are just copy-pasted from the `lib.rs` and do not contain even cosmetic changes (I decided to do so so it'll be easier to review changes looking only on diff).\n\nr? @petrochenkov\n\ncc @Centril @matklad\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81550a00d1e8f83bbaef31205e72b27fdb796d35", "html_url": "https://github.com/rust-lang/rust/commit/81550a00d1e8f83bbaef31205e72b27fdb796d35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81550a00d1e8f83bbaef31205e72b27fdb796d35/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24af0c94b30271198d6101cdd14c78182f76fd07", "url": "https://api.github.com/repos/rust-lang/rust/commits/24af0c94b30271198d6101cdd14c78182f76fd07", "html_url": "https://github.com/rust-lang/rust/commit/24af0c94b30271198d6101cdd14c78182f76fd07"}, {"sha": "31735b02c95510f2e236ebd773b02e84ee6e1a5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/31735b02c95510f2e236ebd773b02e84ee6e1a5b", "html_url": "https://github.com/rust-lang/rust/commit/31735b02c95510f2e236ebd773b02e84ee6e1a5b"}], "stats": {"total": 281, "additions": 159, "deletions": 122}, "files": [{"sha": "ed0911379c4b3ccf79204a7c97706ba531186ace", "filename": "src/librustc_lexer/src/cursor.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81550a00d1e8f83bbaef31205e72b27fdb796d35/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81550a00d1e8f83bbaef31205e72b27fdb796d35/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs?ref=81550a00d1e8f83bbaef31205e72b27fdb796d35", "patch": "@@ -41,10 +41,20 @@ impl<'a> Cursor<'a> {\n     /// If requested position doesn't exist, `EOF_CHAR` is returned.\n     /// However, getting `EOF_CHAR` doesn't always mean actual end of file,\n     /// it should be checked with `is_eof` method.\n-    pub(crate) fn nth_char(&self, n: usize) -> char {\n+    fn nth_char(&self, n: usize) -> char {\n         self.chars().nth(n).unwrap_or(EOF_CHAR)\n     }\n \n+    /// Peeks the next symbol from the input stream without consuming it.\n+    pub(crate) fn first(&self) -> char {\n+        self.nth_char(0)\n+    }\n+\n+    /// Peeks the second symbol from the input stream without consuming it.\n+    pub(crate) fn second(&self) -> char {\n+        self.nth_char(1)\n+    }\n+\n     /// Checks if there is nothing more to consume.\n     pub(crate) fn is_eof(&self) -> bool {\n         self.chars.as_str().is_empty()"}, {"sha": "c50808adec1dd58c50cd21c6b37aac4e73b3b262", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 148, "deletions": 121, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/81550a00d1e8f83bbaef31205e72b27fdb796d35/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81550a00d1e8f83bbaef31205e72b27fdb796d35/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=81550a00d1e8f83bbaef31205e72b27fdb796d35", "patch": "@@ -18,6 +18,8 @@ mod cursor;\n pub mod unescape;\n \n use crate::cursor::{Cursor, EOF_CHAR};\n+use self::TokenKind::*;\n+use self::LiteralKind::*;\n \n /// Parsed token.\n /// It doesn't contain information about data that has been parsed,\n@@ -116,7 +118,6 @@ pub enum TokenKind {\n     /// Unknown token, not expected by the lexer, e.g. \"\u2116\"\n     Unknown,\n }\n-use self::TokenKind::*;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum LiteralKind {\n@@ -137,7 +138,6 @@ pub enum LiteralKind {\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\"\n     RawByteStr { n_hashes: usize, started: bool, terminated: bool },\n }\n-use self::LiteralKind::*;\n \n /// Base of numeric literal encoding according to its prefix.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n@@ -241,14 +241,13 @@ pub fn is_id_continue(c: char) -> bool {\n         || (c > '\\x7f' && unicode_xid::UnicodeXID::is_xid_continue(c))\n }\n \n-\n impl Cursor<'_> {\n     /// Parses a token from the input string.\n     fn advance_token(&mut self) -> Token {\n         let first_char = self.bump().unwrap();\n         let token_kind = match first_char {\n             // Slash, comment or block comment.\n-            '/' => match self.nth_char(0) {\n+            '/' => match self.first() {\n                 '/' => self.line_comment(),\n                 '*' => self.block_comment(),\n                 _ => Slash,\n@@ -257,8 +256,8 @@ impl Cursor<'_> {\n             // Whitespace sequence.\n             c if is_whitespace(c) => self.whitespace(),\n \n-            // Raw string literal or identifier.\n-            'r' => match (self.nth_char(0), self.nth_char(1)) {\n+            // Raw identifier, raw string literal or identifier.\n+            'r' => match (self.first(), self.second()) {\n                 ('#', c1) if is_id_start(c1) => self.raw_ident(),\n                 ('#', _) | ('\"', _) => {\n                     let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n@@ -273,7 +272,7 @@ impl Cursor<'_> {\n             },\n \n             // Byte literal, byte string literal, raw byte string literal or identifier.\n-            'b' => match (self.nth_char(0), self.nth_char(1)) {\n+            'b' => match (self.first(), self.second()) {\n                 ('\\'', _) => {\n                     self.bump();\n                     let terminated = self.single_quoted_string();\n@@ -366,31 +365,23 @@ impl Cursor<'_> {\n     }\n \n     fn line_comment(&mut self) -> TokenKind {\n-        debug_assert!(self.prev() == '/' && self.nth_char(0) == '/');\n+        debug_assert!(self.prev() == '/' && self.first() == '/');\n         self.bump();\n-        loop {\n-            match self.nth_char(0) {\n-                '\\n' => break,\n-                EOF_CHAR if self.is_eof() => break,\n-                _ => {\n-                    self.bump();\n-                }\n-            }\n-        }\n+        self.eat_while(|c| c != '\\n');\n         LineComment\n     }\n \n     fn block_comment(&mut self) -> TokenKind {\n-        debug_assert!(self.prev() == '/' && self.nth_char(0) == '*');\n+        debug_assert!(self.prev() == '/' && self.first() == '*');\n         self.bump();\n         let mut depth = 1usize;\n         while let Some(c) = self.bump() {\n             match c {\n-                '/' if self.nth_char(0) == '*' => {\n+                '/' if self.first() == '*' => {\n                     self.bump();\n                     depth += 1;\n                 }\n-                '*' if self.nth_char(0) == '/' => {\n+                '*' if self.first() == '/' => {\n                     self.bump();\n                     depth -= 1;\n                     if depth == 0 {\n@@ -409,31 +400,27 @@ impl Cursor<'_> {\n \n     fn whitespace(&mut self) -> TokenKind {\n         debug_assert!(is_whitespace(self.prev()));\n-        while is_whitespace(self.nth_char(0)) {\n-            self.bump();\n-        }\n+        self.eat_while(is_whitespace);\n         Whitespace\n     }\n \n     fn raw_ident(&mut self) -> TokenKind {\n         debug_assert!(\n             self.prev() == 'r'\n-                && self.nth_char(0) == '#'\n-                && is_id_start(self.nth_char(1))\n+                && self.first() == '#'\n+                && is_id_start(self.second())\n         );\n+        // Eat \"#\" symbol.\n         self.bump();\n-        self.bump();\n-        while is_id_continue(self.nth_char(0)) {\n-            self.bump();\n-        }\n+        // Eat the identifier part of RawIdent.\n+        self.eat_identifier();\n         RawIdent\n     }\n \n     fn ident(&mut self) -> TokenKind {\n         debug_assert!(is_id_start(self.prev()));\n-        while is_id_continue(self.nth_char(0)) {\n-            self.bump();\n-        }\n+        // Start is already eaten, eat the rest of identifier.\n+        self.eat_while(is_id_continue);\n         Ident\n     }\n \n@@ -442,7 +429,7 @@ impl Cursor<'_> {\n         let mut base = Base::Decimal;\n         if first_digit == '0' {\n             // Attempt to parse encoding base.\n-            let has_digits = match self.nth_char(0) {\n+            let has_digits = match self.first() {\n                 'b' => {\n                     base = Base::Binary;\n                     self.bump();\n@@ -476,23 +463,23 @@ impl Cursor<'_> {\n             self.eat_decimal_digits();\n         };\n \n-        match self.nth_char(0) {\n+        match self.first() {\n             // Don't be greedy if this is actually an\n             // integer literal followed by field/method access or a range pattern\n             // (`0..2` and `12.foo()`)\n-            '.' if self.nth_char(1) != '.'\n-                && !is_id_start(self.nth_char(1)) =>\n+            '.' if self.second() != '.'\n+                && !is_id_start(self.second()) =>\n             {\n                 // might have stuff after the ., and if it does, it needs to start\n                 // with a number\n                 self.bump();\n                 let mut empty_exponent = false;\n-                if self.nth_char(0).is_digit(10) {\n+                if self.first().is_digit(10) {\n                     self.eat_decimal_digits();\n-                    match self.nth_char(0) {\n+                    match self.first() {\n                         'e' | 'E' => {\n                             self.bump();\n-                            empty_exponent = self.float_exponent().is_err()\n+                            empty_exponent = !self.eat_float_exponent();\n                         }\n                         _ => (),\n                     }\n@@ -501,7 +488,7 @@ impl Cursor<'_> {\n             }\n             'e' | 'E' => {\n                 self.bump();\n-                let empty_exponent = self.float_exponent().is_err();\n+                let empty_exponent = !self.eat_float_exponent();\n                 Float { base, empty_exponent }\n             }\n             _ => Int { base, empty_int: false },\n@@ -510,65 +497,76 @@ impl Cursor<'_> {\n \n     fn lifetime_or_char(&mut self) -> TokenKind {\n         debug_assert!(self.prev() == '\\'');\n-        let mut starts_with_number = false;\n-\n-        // Check if the first symbol after '\\'' is a valid identifier\n-        // character or a number (not a digit followed by '\\'').\n-        if (is_id_start(self.nth_char(0))\n-            || self.nth_char(0).is_digit(10) && {\n-                starts_with_number = true;\n-                true\n-            })\n-            && self.nth_char(1) != '\\''\n-        {\n-            self.bump();\n \n-            // Skip the identifier.\n-            while is_id_continue(self.nth_char(0)) {\n-                self.bump();\n-            }\n+        let can_be_a_lifetime = if self.second() == '\\'' {\n+            // It's surely not a lifetime.\n+            false\n+        } else {\n+            // If the first symbol is valid for identifier, it can be a lifetime.\n+            // Also check if it's a number for a better error reporting (so '0 will\n+            // be reported as invalid lifetime and not as unterminated char literal).\n+            is_id_start(self.first()) || self.first().is_digit(10)\n+        };\n \n-            return if self.nth_char(0) == '\\'' {\n-                self.bump();\n-                let kind = Char { terminated: true };\n-                Literal { kind, suffix_start: self.len_consumed() }\n-            } else {\n-                Lifetime { starts_with_number }\n-            };\n+        if !can_be_a_lifetime {\n+            let terminated = self.single_quoted_string();\n+            let suffix_start = self.len_consumed();\n+            if terminated {\n+                self.eat_literal_suffix();\n+            }\n+            let kind = Char { terminated };\n+            return Literal { kind, suffix_start };\n         }\n \n-        // This is not a lifetime (checked above), parse a char literal.\n-        let terminated = self.single_quoted_string();\n-        let suffix_start = self.len_consumed();\n-        if terminated {\n-            self.eat_literal_suffix();\n+        // Either a lifetime or a character literal with\n+        // length greater than 1.\n+\n+        let starts_with_number = self.first().is_digit(10);\n+\n+        // Skip the literal contents.\n+        // First symbol can be a number (which isn't a valid identifier start),\n+        // so skip it without any checks.\n+        self.bump();\n+        self.eat_while(is_id_continue);\n+\n+        // Check if after skipping literal contents we've met a closing\n+        // single quote (which means that user attempted to create a\n+        // string with single quotes).\n+        if self.first() == '\\'' {\n+            self.bump();\n+            let kind = Char { terminated: true };\n+            return Literal { kind, suffix_start: self.len_consumed() };\n         }\n-        let kind = Char { terminated };\n-        return Literal { kind, suffix_start };\n+\n+        return Lifetime { starts_with_number };\n     }\n \n     fn single_quoted_string(&mut self) -> bool {\n         debug_assert!(self.prev() == '\\'');\n-        // Parse `'''` as a single char literal.\n-        if self.nth_char(0) == '\\'' && self.nth_char(1) == '\\'' {\n+        // Check if it's a one-symbol literal.\n+        if self.second() == '\\'' && self.first() != '\\\\' {\n+            self.bump();\n             self.bump();\n+            return true;\n         }\n+\n+        // Literal has more than one symbol.\n+\n         // Parse until either quotes are terminated or error is detected.\n-        let mut first = true;\n         loop {\n-            match self.nth_char(0) {\n-                // Probably beginning of the comment, which we don't want to include\n-                // to the error report.\n-                '/' if !first => break,\n-                // Newline without following '\\'' means unclosed quote, stop parsing.\n-                '\\n' if self.nth_char(1) != '\\'' => break,\n-                // End of file, stop parsing.\n-                EOF_CHAR if self.is_eof() => break,\n+            match self.first() {\n                 // Quotes are terminated, finish parsing.\n                 '\\'' => {\n                     self.bump();\n                     return true;\n                 }\n+                // Probably beginning of the comment, which we don't want to include\n+                // to the error report.\n+                '/' => break,\n+                // Newline without following '\\'' means unclosed quote, stop parsing.\n+                '\\n' if self.second() != '\\'' => break,\n+                // End of file, stop parsing.\n+                EOF_CHAR if self.is_eof() => break,\n                 // Escaped slash is considered one character, so bump twice.\n                 '\\\\' => {\n                     self.bump();\n@@ -579,71 +577,80 @@ impl Cursor<'_> {\n                     self.bump();\n                 }\n             }\n-            first = false;\n         }\n+        // String was not terminated.\n         false\n     }\n \n     /// Eats double-quoted string and returns true\n     /// if string is terminated.\n     fn double_quoted_string(&mut self) -> bool {\n         debug_assert!(self.prev() == '\"');\n-        loop {\n-            match self.nth_char(0) {\n+        while let Some(c) = self.bump() {\n+            match c {\n                 '\"' => {\n-                    self.bump();\n                     return true;\n                 }\n-                EOF_CHAR if self.is_eof() => return false,\n-                '\\\\' if self.nth_char(1) == '\\\\' || self.nth_char(1) == '\"' => {\n+                '\\\\' if self.first() == '\\\\' || self.first() == '\"' => {\n+                    // Bump again to skip escaped character.\n                     self.bump();\n                 }\n                 _ => (),\n             }\n-            self.bump();\n         }\n+        // End of file reached.\n+        false\n     }\n \n     /// Eats the double-quoted string and returns a tuple of\n     /// (amount of the '#' symbols, raw string started, raw string terminated)\n     fn raw_double_quoted_string(&mut self) -> (usize, bool, bool) {\n         debug_assert!(self.prev() == 'r');\n+        let mut started: bool = false;\n+        let mut finished: bool = false;\n+\n         // Count opening '#' symbols.\n-        let n_hashes = {\n-            let mut acc: usize = 0;\n-            loop {\n-                match self.bump() {\n-                    Some('#') => acc += 1,\n-                    Some('\"') => break acc,\n-                    None | Some(_) => return (acc, false, false),\n-                }\n+        let n_hashes = self.eat_while(|c| c == '#');\n+\n+        // Check that string is started.\n+        match self.bump() {\n+            Some('\"') => started = true,\n+            _ => return (n_hashes, started, finished),\n+        }\n+\n+        // Skip the string contents and on each '#' character met, check if this is\n+        // a raw string termination.\n+        while !finished {\n+            self.eat_while(|c| c != '\"');\n+\n+            if self.is_eof() {\n+                return (n_hashes, started, finished);\n             }\n-        };\n \n-        // Skip the string itself and check that amount of closing '#'\n-        // symbols is equal to the amount of opening ones.\n-        loop {\n-            match self.bump() {\n-                Some('\"') => {\n-                    let mut acc = n_hashes;\n-                    while self.nth_char(0) == '#' && acc > 0 {\n-                        self.bump();\n-                        acc -= 1;\n-                    }\n-                    if acc == 0 {\n-                        return (n_hashes, true, true);\n-                    }\n+            // Eat closing double quote.\n+            self.bump();\n+\n+            // Check that amount of closing '#' symbols\n+            // is equal to the amount of opening ones.\n+            let mut hashes_left = n_hashes;\n+            let is_closing_hash = |c| {\n+                if c == '#' && hashes_left != 0 {\n+                    hashes_left -= 1;\n+                    true\n+                } else {\n+                    false\n                 }\n-                Some(_) => (),\n-                None => return (n_hashes, true, false),\n-            }\n+            };\n+            finished = self.eat_while(is_closing_hash) == n_hashes;\n         }\n+\n+        (n_hashes, started, finished)\n     }\n \n     fn eat_decimal_digits(&mut self) -> bool {\n         let mut has_digits = false;\n         loop {\n-            match self.nth_char(0) {\n+            match self.first() {\n                 '_' => {\n                     self.bump();\n                 }\n@@ -660,7 +667,7 @@ impl Cursor<'_> {\n     fn eat_hexadecimal_digits(&mut self) -> bool {\n         let mut has_digits = false;\n         loop {\n-            match self.nth_char(0) {\n+            match self.first() {\n                 '_' => {\n                     self.bump();\n                 }\n@@ -674,23 +681,43 @@ impl Cursor<'_> {\n         has_digits\n     }\n \n-    fn float_exponent(&mut self) -> Result<(), ()> {\n+    /// Eats the float exponent. Returns true if at least one digit was met,\n+    /// and returns false otherwise.\n+    fn eat_float_exponent(&mut self) -> bool {\n         debug_assert!(self.prev() == 'e' || self.prev() == 'E');\n-        if self.nth_char(0) == '-' || self.nth_char(0) == '+' {\n+        if self.first() == '-' || self.first() == '+' {\n             self.bump();\n         }\n-        if self.eat_decimal_digits() { Ok(()) } else { Err(()) }\n+        self.eat_decimal_digits()\n     }\n \n-    // Eats the suffix if it's an identifier.\n+    // Eats the suffix of the literal, e.g. \"_u8\".\n     fn eat_literal_suffix(&mut self) {\n-        if !is_id_start(self.nth_char(0)) {\n+        self.eat_identifier();\n+    }\n+\n+    // Eats the identifier.\n+    fn eat_identifier(&mut self) {\n+        if !is_id_start(self.first()) {\n             return;\n         }\n         self.bump();\n \n-        while is_id_continue(self.nth_char(0)) {\n+        self.eat_while(is_id_continue);\n+    }\n+\n+    /// Eats symbols while predicate returns true or until the end of file is reached.\n+    /// Returns amount of eaten symbols.\n+    fn eat_while<F>(&mut self, mut predicate: F) -> usize\n+    where\n+        F: FnMut(char) -> bool\n+    {\n+        let mut eaten: usize = 0;\n+        while predicate(self.first()) && !self.is_eof() {\n+            eaten += 1;\n             self.bump();\n         }\n+\n+        eaten\n     }\n }"}]}