{"sha": "068517ae66a41052dea2c86c88fc10794304622d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ODUxN2FlNjZhNDEwNTJkZWEyYzg2Yzg4ZmMxMDc5NDMwNDYyMmQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-23T19:38:53Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-23T19:38:53Z"}, "message": "make sure we always have an RNG", "tree": {"sha": "fd050822ee89cb16e837136f15234a4a2f8cfd3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd050822ee89cb16e837136f15234a4a2f8cfd3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/068517ae66a41052dea2c86c88fc10794304622d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/068517ae66a41052dea2c86c88fc10794304622d", "html_url": "https://github.com/rust-lang/rust/commit/068517ae66a41052dea2c86c88fc10794304622d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/068517ae66a41052dea2c86c88fc10794304622d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b269bb07078446c9c153e0f2acaf83bf8f19b935", "url": "https://api.github.com/repos/rust-lang/rust/commits/b269bb07078446c9c153e0f2acaf83bf8f19b935", "html_url": "https://github.com/rust-lang/rust/commit/b269bb07078446c9c153e0f2acaf83bf8f19b935"}], "stats": {"total": 171, "additions": 30, "deletions": 141}, "files": [{"sha": "fbd1f51c9e697972e7ebae7435a9ef25bd2b157d", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/068517ae66a41052dea2c86c88fc10794304622d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/068517ae66a41052dea2c86c88fc10794304622d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=068517ae66a41052dea2c86c88fc10794304622d", "patch": "@@ -262,10 +262,10 @@ With this, you should now have a working development setup!  See\n \n Several `-Z` flags are relevant for Miri:\n \n-* `-Zmiri-seed=<hex>` is a custom `-Z` flag added by Miri.  It enables the\n-  interpreted program to seed an RNG with system entropy.  Miri will keep an RNG\n-  on its own that is seeded with the given seed, and use that to generate the\n-  \"system entropy\" that seeds the RNG(s) in the interpreted program.\n+* `-Zmiri-seed=<hex>` is a custom `-Z` flag added by Miri.  It configures the\n+  seed of the RNG that Miri uses to resolve non-determinism.  This RNG is used\n+  to pick base addresses for allocations, and when the interpreted program\n+  requests system entropy.  The default seed is 0.\n   **NOTE**: This entropy is not good enough for cryptographic use!  Do not\n   generate secret keys in Miri or perform other kinds of cryptographic\n   operations that rely on proper random numbers."}, {"sha": "83307c99f9c59bb7a166aebddc1a449b1a893e17", "filename": "src/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/068517ae66a41052dea2c86c88fc10794304622d/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068517ae66a41052dea2c86c88fc10794304622d/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=068517ae66a41052dea2c86c88fc10794304622d", "patch": "@@ -34,7 +34,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n         Evaluator::new(),\n-        MemoryExtra::new(config.seed.map(StdRng::seed_from_u64), config.validate),\n+        MemoryExtra::new(StdRng::seed_from_u64(config.seed.unwrap_or(0)), config.validate),\n     );\n \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);"}, {"sha": "3857020a71f81fd52828a1853c6dbd1b22803baf", "filename": "src/helpers.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/068517ae66a41052dea2c86c88fc10794304622d/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068517ae66a41052dea2c86c88fc10794304622d/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=068517ae66a41052dea2c86c88fc10794304622d", "patch": "@@ -88,25 +88,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             None => return Ok(()), // zero-sized access\n         };\n \n-        let data = match &mut this.memory_mut().extra.rng {\n-            Some(rng) => {\n-                let mut rng = rng.borrow_mut();\n-                let mut data = vec![0; len];\n-                rng.fill_bytes(&mut data);\n-                data\n-            }\n-            None => {\n-                return err!(Unimplemented(\n-                    \"miri does not support gathering system entropy in deterministic mode!\n-                    Use '-Zmiri-seed=<seed>' to enable random number generation.\n-                    WARNING: Miri does *not* generate cryptographically secure entropy -\n-                    do not use Miri to run any program that needs secure random number generation\".to_owned(),\n-                ));\n-            }\n-        };\n+        let rng = this.memory_mut().extra.rng.get_mut();\n+        let mut data = vec![0; len];\n+        rng.fill_bytes(&mut data);\n+\n         let tcx = &{this.tcx.tcx};\n-        this.memory_mut().get_mut(ptr.alloc_id)?\n-            .write_bytes(tcx, ptr, &data)\n+        this.memory_mut().get_mut(ptr.alloc_id)?.write_bytes(tcx, ptr, &data)\n     }\n \n     /// Visits the memory covered by `place`, sensitive to freezing: the 3rd parameter"}, {"sha": "8fbf7ed76427f4e0a75e258b2e77ef18296bcda5", "filename": "src/intptrcast.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/068517ae66a41052dea2c86c88fc10794304622d/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068517ae66a41052dea2c86c88fc10794304622d/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=068517ae66a41052dea2c86c88fc10794304622d", "patch": "@@ -42,6 +42,10 @@ impl<'mir, 'tcx> GlobalState {\n         int: u64,\n         memory: &Memory<'mir, 'tcx, Evaluator<'tcx>>,\n     ) -> InterpResult<'tcx, Pointer<Tag>> {\n+        if int == 0 {\n+            return err!(InvalidNullPointerUsage);\n+        }\n+\n         let global_state = memory.extra.intptrcast.borrow();\n         \n         match global_state.int_to_ptr_map.binary_search_by_key(&int, |(addr, _)| *addr) {\n@@ -86,7 +90,7 @@ impl<'mir, 'tcx> GlobalState {\n                 // This allocation does not have a base address yet, pick one.\n                 // Leave some space to the previous allocation, to give it some chance to be less aligned.\n                 let slack = {\n-                    let mut rng = memory.extra.rng.as_ref().unwrap().borrow_mut();\n+                    let mut rng = memory.extra.rng.borrow_mut();\n                     // This means that `(global_state.next_base_addr + slack) % 16` is uniformly distributed.\n                     rng.gen_range(0, 16)\n                 };"}, {"sha": "d50afec253e80af009606533c4802195a02e7dd0", "filename": "src/machine.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/068517ae66a41052dea2c86c88fc10794304622d/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068517ae66a41052dea2c86c88fc10794304622d/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=068517ae66a41052dea2c86c88fc10794304622d", "patch": "@@ -57,20 +57,19 @@ pub struct MemoryExtra {\n     pub stacked_borrows: stacked_borrows::MemoryExtra,\n     pub intptrcast: intptrcast::MemoryExtra,\n \n-    /// The random number generator to use if Miri is running in non-deterministic mode and to\n-    /// enable intptrcast\n-    pub(crate) rng: Option<RefCell<StdRng>>,\n+    /// The random number generator used for resolving non-determinism.\n+    pub(crate) rng: RefCell<StdRng>,\n \n     /// Whether to enforce the validity invariant.\n     pub(crate) validate: bool,\n }\n \n impl MemoryExtra {\n-    pub fn new(rng: Option<StdRng>, validate: bool) -> Self {\n+    pub fn new(rng: StdRng, validate: bool) -> Self {\n         MemoryExtra {\n             stacked_borrows: Default::default(),\n             intptrcast: Default::default(),\n-            rng: rng.map(RefCell::new),\n+            rng: RefCell::new(rng),\n             validate,\n         }\n     }\n@@ -353,28 +352,20 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         Ok(ecx.memory().extra.stacked_borrows.borrow_mut().end_call(extra))\n     }\n \n+    #[inline(always)]\n     fn int_to_ptr(\n         memory: &Memory<'mir, 'tcx, Self>,\n         int: u64,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n-        if int == 0 {\n-            err!(InvalidNullPointerUsage)\n-        } else if memory.extra.rng.is_none() {\n-            err!(ReadBytesAsPointer)\n-        } else {\n-           intptrcast::GlobalState::int_to_ptr(int, memory)\n-        }\n+        intptrcast::GlobalState::int_to_ptr(int, memory)\n     }\n \n+    #[inline(always)]\n     fn ptr_to_int(\n         memory: &Memory<'mir, 'tcx, Self>,\n         ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64> {\n-        if memory.extra.rng.is_none() {\n-            err!(ReadPointerAsBytes)\n-        } else {\n-            intptrcast::GlobalState::ptr_to_int(ptr, memory)\n-        }\n+        intptrcast::GlobalState::ptr_to_int(ptr, memory)\n     }\n }\n "}, {"sha": "5eeed5eac635d14e75cd6833bc883466d8271fa3", "filename": "src/operator.rs", "status": "modified", "additions": 7, "deletions": 100, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/068517ae66a41052dea2c86c88fc10794304622d/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068517ae66a41052dea2c86c88fc10794304622d/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=068517ae66a41052dea2c86c88fc10794304622d", "patch": "@@ -56,8 +56,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n \n-        // If intptrcast is enabled, treat everything of integer *type* at integer *value*.\n-        if self.memory().extra.rng.is_some() && left.layout.ty.is_integral() {\n+        // Treat everything of integer *type* at integer *value*.\n+        if left.layout.ty.is_integral() {\n             // This is actually an integer operation, so dispatch back to the core engine.\n             // TODO: Once intptrcast is the default, librustc_mir should never even call us\n             // for integer types.\n@@ -188,104 +188,11 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         right: Scalar<Tag>,\n     ) -> InterpResult<'tcx, bool> {\n         let size = self.pointer_size();\n-        if self.memory().extra.rng.is_some() {\n-            // Just compare the integers.\n-            // TODO: Do we really want to *always* do that, even when comparing two live in-bounds pointers?\n-            let left = self.force_bits(left, size)?;\n-            let right = self.force_bits(right, size)?;\n-            return Ok(left == right);\n-        }\n-        Ok(match (left, right) {\n-            (Scalar::Raw { .. }, Scalar::Raw { .. }) =>\n-                left.to_bits(size)? == right.to_bits(size)?,\n-            (Scalar::Ptr(left), Scalar::Ptr(right)) => {\n-                // Comparison illegal if one of them is out-of-bounds, *unless* they\n-                // are in the same allocation.\n-                if left.alloc_id == right.alloc_id {\n-                    left.offset == right.offset\n-                } else {\n-                    // Make sure both pointers are in-bounds.\n-                    // This accepts one-past-the end. Thus, there is still technically\n-                    // some non-determinism that we do not fully rule out when two\n-                    // allocations sit right next to each other. The C/C++ standards are\n-                    // somewhat fuzzy about this case, so pragmatically speaking I think\n-                    // for now this check is \"good enough\".\n-                    // FIXME: Once we support intptrcast, we could try to fix these holes.\n-                    // Dead allocations in miri cannot overlap with live allocations, but\n-                    // on read hardware this can easily happen. Thus for comparisons we require\n-                    // both pointers to be live.\n-                    if self.pointer_inbounds(left).is_ok() && self.pointer_inbounds(right).is_ok() {\n-                        // Two in-bounds (and hence live) pointers in different allocations are different.\n-                        false\n-                    } else {\n-                        return err!(InvalidPointerMath);\n-                    }\n-                }\n-            }\n-            // Comparing ptr and integer.\n-            (Scalar::Ptr(ptr), Scalar::Raw { data, size }) |\n-            (Scalar::Raw { data, size }, Scalar::Ptr(ptr)) => {\n-                assert_eq!(size as u64, self.pointer_size().bytes());\n-                let bits = data as u64;\n-\n-                // Case I: Comparing real pointers with \"small\" integers.\n-                // Really we should only do this for NULL, but pragmatically speaking on non-bare-metal systems,\n-                // an allocation will never be at the very bottom of the address space.\n-                // Such comparisons can arise when comparing empty slices, which sometimes are \"fake\"\n-                // integer pointers (okay because the slice is empty) and sometimes point into a\n-                // real allocation.\n-                // The most common source of such integer pointers is `NonNull::dangling()`, which\n-                // equals the type's alignment. i128 might have an alignment of 16 bytes, but few types have\n-                // alignment 32 or higher, hence the limit of 32.\n-                // FIXME: Once we support intptrcast, we could try to fix these holes.\n-                if bits < 32 {\n-                    // Test if the pointer can be different from NULL or not.\n-                    // We assume that pointers that are not NULL are also not \"small\".\n-                    if !self.memory().ptr_may_be_null(ptr) {\n-                        return Ok(false);\n-                    }\n-                }\n-\n-                let (alloc_size, alloc_align) = self.memory()\n-                    .get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n-                    .expect(\"alloc info with MaybeDead cannot fail\");\n-\n-                // Case II: Alignment gives it away\n-                if ptr.offset.bytes() % alloc_align.bytes() == 0 {\n-                    // The offset maintains the allocation alignment, so we know `base+offset`\n-                    // is aligned by `alloc_align`.\n-                    // FIXME: We could be even more general, e.g., offset 2 into a 4-aligned\n-                    // allocation cannot equal 3.\n-                    if bits % alloc_align.bytes() != 0 {\n-                        // The integer is *not* aligned. So they cannot be equal.\n-                        return Ok(false);\n-                    }\n-                }\n-                // Case III: The integer is too big, and the allocation goes on a bit\n-                // without wrapping around the address space.\n-                {\n-                    // Compute the highest address at which this allocation could live.\n-                    // Substract one more, because it must be possible to add the size\n-                    // to the base address without overflowing; that is, the very last address\n-                    // of the address space is never dereferencable (but it can be in-bounds, i.e.,\n-                    // one-past-the-end).\n-                    let max_base_addr =\n-                        ((1u128 << self.pointer_size().bits())\n-                         - u128::from(alloc_size.bytes())\n-                         - 1\n-                        ) as u64;\n-                    if let Some(max_addr) = max_base_addr.checked_add(ptr.offset.bytes()) {\n-                        if bits > max_addr {\n-                            // The integer is too big, this cannot possibly be equal.\n-                            return Ok(false)\n-                        }\n-                    }\n-                }\n-\n-                // None of the supported cases.\n-                return err!(InvalidPointerMath);\n-            }\n-        })\n+        // Just compare the integers.\n+        // TODO: Do we really want to *always* do that, even when comparing two live in-bounds pointers?\n+        let left = self.force_bits(left, size)?;\n+        let right = self.force_bits(right, size)?;\n+        Ok(left == right)\n     }\n \n     fn ptr_int_arithmetic("}]}