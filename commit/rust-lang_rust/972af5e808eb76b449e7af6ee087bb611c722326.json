{"sha": "972af5e808eb76b449e7af6ee087bb611c722326", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MmFmNWU4MDhlYjc2YjQ0OWU3YWY2ZWUwODdiYjYxMWM3MjIzMjY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-09T11:05:05Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: rename ppaux' print macro to just p and make its cx input implicit.", "tree": {"sha": "b3e9dc6866502203f0d3881e10acc21b49a4efae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3e9dc6866502203f0d3881e10acc21b49a4efae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/972af5e808eb76b449e7af6ee087bb611c722326", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/972af5e808eb76b449e7af6ee087bb611c722326", "html_url": "https://github.com/rust-lang/rust/commit/972af5e808eb76b449e7af6ee087bb611c722326", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/972af5e808eb76b449e7af6ee087bb611c722326/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "387ea61ec146722daa9fcf5f2658ea5ee2211f0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/387ea61ec146722daa9fcf5f2658ea5ee2211f0c", "html_url": "https://github.com/rust-lang/rust/commit/387ea61ec146722daa9fcf5f2658ea5ee2211f0c"}], "stats": {"total": 366, "additions": 193, "deletions": 173}, "files": [{"sha": "fa0acd1a301f79dfd3768ea6a49582e829c9a1f1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 193, "deletions": 173, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/972af5e808eb76b449e7af6ee087bb611c722326/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972af5e808eb76b449e7af6ee087bb611c722326/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=972af5e808eb76b449e7af6ee087bb611c722326", "patch": "@@ -195,6 +195,7 @@ macro_rules! gen_print_impl {\n         impl<$($x)+, P: PrettyPrinter> Print<'tcx, P> for $target {\n             type Output = fmt::Result;\n             fn print(&$self, $cx: &mut PrintCx<'_, '_, 'tcx, P>) -> fmt::Result {\n+                define_scoped_cx!($cx);\n                 if $cx.is_debug $dbg\n                 else $disp\n             }\n@@ -204,6 +205,7 @@ macro_rules! gen_print_impl {\n         impl<P: PrettyPrinter> Print<'tcx, P> for $target {\n             type Output = fmt::Result;\n             fn print(&$self, $cx: &mut PrintCx<'_, '_, 'tcx, P>) -> fmt::Result {\n+                define_scoped_cx!($cx);\n                 if $cx.is_debug $dbg\n                 else $disp\n             }\n@@ -244,21 +246,29 @@ macro_rules! define_print_multi {\n     };\n }\n macro_rules! print_inner {\n-    ( $cx:expr, write ($($data:expr),+) ) => {\n-        write!($cx.printer, $($data),+)\n+    (write ($($data:expr),+)) => {\n+        write!(scoped_cx!().printer, $($data),+)\n     };\n-    ( $cx:expr, $kind:ident ($data:expr) ) => {\n-        $data.$kind($cx)\n+    ($kind:ident ($data:expr)) => {\n+        $data.$kind(scoped_cx!())\n     };\n }\n-macro_rules! print {\n-    ( $cx:expr, $($kind:ident $data:tt),+ ) => {\n+macro_rules! p {\n+    ($($kind:ident $data:tt),+) => {\n         (|| -> fmt::Result {\n-            $(print_inner!($cx, $kind $data)?;)+\n+            $(print_inner!($kind $data)?;)+\n             Ok(())\n         })()\n     };\n }\n+macro_rules! define_scoped_cx {\n+    ($cx:ident) => {\n+        #[allow(unused_macros)]\n+        macro_rules! scoped_cx {\n+            () => ($cx)\n+        }\n+    };\n+}\n \n impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n     fn fn_sig(\n@@ -267,20 +277,22 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n         c_variadic: bool,\n         output: Ty<'tcx>,\n     ) -> fmt::Result {\n-        print!(self, write(\"(\"))?;\n+        define_scoped_cx!(self);\n+\n+        p!(write(\"(\"))?;\n         let mut inputs = inputs.iter();\n         if let Some(&ty) = inputs.next() {\n-            print!(self, print_display(ty))?;\n+            p!(print_display(ty))?;\n             for &ty in inputs {\n-                print!(self, write(\", \"), print_display(ty))?;\n+                p!(write(\", \"), print_display(ty))?;\n             }\n             if c_variadic {\n-                print!(self, write(\", ...\"))?;\n+                p!(write(\", ...\"))?;\n             }\n         }\n-        print!(self, write(\")\"))?;\n+        p!(write(\")\"))?;\n         if !output.is_unit() {\n-            print!(self, write(\" -> \"), print_display(output))?;\n+            p!(write(\" -> \"), print_display(output))?;\n         }\n \n         Ok(())\n@@ -308,21 +320,28 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n \n         let mut empty = true;\n         let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n+            define_scoped_cx!(cx);\n+\n             if empty {\n                 empty = false;\n-                print!(cx, write(\"{}\", start))\n+                p!(write(\"{}\", start))\n             } else {\n-                print!(cx, write(\"{}\", cont))\n+                p!(write(\"{}\", cont))\n             }\n         };\n \n+        // NOTE(eddyb) this must be below `start_or_continue`'s definition\n+        // as that also has a `define_scoped_cx` and that kind of shadowing\n+        // is disallowed (name resolution thinks `scoped_cx!` is ambiguous).\n+        define_scoped_cx!(self);\n+\n         let old_region_index = self.region_index;\n         let mut region_index = old_region_index;\n         let new_value = self.tcx.replace_late_bound_regions(value, |br| {\n             let _ = start_or_continue(self, \"for<\", \", \");\n             let br = match br {\n                 ty::BrNamed(_, name) => {\n-                    let _ = print!(self, write(\"{}\", name));\n+                    let _ = p!(write(\"{}\", name));\n                     br\n                 }\n                 ty::BrAnon(_) |\n@@ -335,7 +354,7 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n                             break name;\n                         }\n                     };\n-                    let _ = print!(self, write(\"{}\", name));\n+                    let _ = p!(write(\"{}\", name));\n                     ty::BrNamed(self.tcx.hir().local_def_id(CRATE_NODE_ID), name)\n                 }\n             };\n@@ -431,7 +450,7 @@ define_print! {\n \n             for (_, def_id) in auto_traits {\n                 if !first {\n-                    print!(cx, write(\" + \"))?;\n+                    p!(write(\" + \"))?;\n                 }\n                 first = false;\n \n@@ -502,7 +521,8 @@ impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         PrintCx::with(FmtPrinter { fmt: f }, |mut cx| {\n-            print!(cx, write(\"UpvarId({:?};`{}`;{:?})\",\n+            define_scoped_cx!(cx);\n+            p!(write(\"UpvarId({:?};`{}`;{:?})\",\n                 self.var_path.hir_id,\n                 cx.tcx.hir().name_by_hir_id(self.var_path.hir_id),\n                 self.closure_expr_id))\n@@ -520,23 +540,23 @@ impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n define_print! {\n     ('tcx) &'tcx ty::List<Ty<'tcx>>, (self, cx) {\n         display {\n-            print!(cx, write(\"{{\"))?;\n+            p!(write(\"{{\"))?;\n             let mut tys = self.iter();\n             if let Some(&ty) = tys.next() {\n-                print!(cx, print(ty))?;\n+                p!(print(ty))?;\n                 for &ty in tys {\n-                    print!(cx, write(\", \"), print(ty))?;\n+                    p!(write(\", \"), print(ty))?;\n                 }\n             }\n-            print!(cx, write(\"}}\"))\n+            p!(write(\"}}\"))\n         }\n     }\n }\n \n define_print! {\n     ('tcx) ty::TypeAndMut<'tcx>, (self, cx) {\n         display {\n-            print!(cx,\n+            p!(\n                    write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n                    print(self.ty))\n         }\n@@ -562,7 +582,7 @@ define_print! {\n define_print! {\n     ('tcx) ty::adjustment::Adjustment<'tcx>, (self, cx) {\n         debug {\n-            print!(cx, write(\"{:?} -> \", self.kind), print(self.target))\n+            p!(write(\"{:?} -> \", self.kind), print(self.target))\n         }\n     }\n }\n@@ -576,28 +596,28 @@ define_print! {\n \n             if let BrNamed(_, name) = *self {\n                 if name != \"\" && name != \"'_\" {\n-                    return print!(cx, write(\"{}\", name));\n+                    return p!(write(\"{}\", name));\n                 }\n             }\n \n             let highlight = RegionHighlightMode::get();\n             if let Some((region, counter)) = highlight.highlight_bound_region {\n                 if *self == region {\n-                    return print!(cx, write(\"'{}\", counter));\n+                    return p!(write(\"'{}\", counter));\n                 }\n             }\n \n             Ok(())\n         }\n         debug {\n             return match *self {\n-                BrAnon(n) => print!(cx, write(\"BrAnon({:?})\", n)),\n-                BrFresh(n) => print!(cx, write(\"BrFresh({:?})\", n)),\n+                BrAnon(n) => p!(write(\"BrAnon({:?})\", n)),\n+                BrFresh(n) => p!(write(\"BrFresh({:?})\", n)),\n                 BrNamed(did, name) => {\n-                    print!(cx, write(\"BrNamed({:?}:{:?}, {})\",\n+                    p!(write(\"BrNamed({:?}:{:?}, {})\",\n                            did.krate, did.index, name))\n                 }\n-                BrEnv => print!(cx, write(\"BrEnv\")),\n+                BrEnv => p!(write(\"BrEnv\")),\n             };\n         }\n     }\n@@ -638,10 +658,10 @@ define_print! {\n \n             let highlight = RegionHighlightMode::get();\n             if let Some(counter) = highlight.placeholder_highlight(*self) {\n-                return print!(cx, write(\"'{}\", counter));\n+                return p!(write(\"'{}\", counter));\n             }\n \n-            print!(cx, print_display(self.name))\n+            p!(print_display(self.name))\n         }\n     }\n }\n@@ -673,7 +693,7 @@ define_print! {\n \n             // Watch out for region highlights.\n             if let Some(n) = RegionHighlightMode::get().region_highlighted(self) {\n-                return print!(cx, write(\"'{:?}\", n));\n+                return p!(write(\"'{:?}\", n));\n             }\n \n             // These printouts are concise.  They do not contain all the information\n@@ -683,88 +703,88 @@ define_print! {\n             match *self {\n                 ty::ReEarlyBound(ref data) => {\n                     if data.name != \"'_\" {\n-                        print!(cx, write(\"{}\", data.name))\n+                        p!(write(\"{}\", data.name))\n                     } else {\n                         Ok(())\n                     }\n                 }\n                 ty::ReLateBound(_, br) |\n                 ty::ReFree(ty::FreeRegion { bound_region: br, .. }) => {\n-                    print!(cx, print_display(br))\n+                    p!(print_display(br))\n                 }\n                 ty::RePlaceholder(p) => {\n-                    print!(cx, print_display(p))\n+                    p!(print_display(p))\n                 }\n                 ty::ReScope(scope) if cx.identify_regions => {\n                     match scope.data {\n                         region::ScopeData::Node =>\n-                            print!(cx, write(\"'{}s\", scope.item_local_id().as_usize())),\n+                            p!(write(\"'{}s\", scope.item_local_id().as_usize())),\n                         region::ScopeData::CallSite =>\n-                            print!(cx, write(\"'{}cs\", scope.item_local_id().as_usize())),\n+                            p!(write(\"'{}cs\", scope.item_local_id().as_usize())),\n                         region::ScopeData::Arguments =>\n-                            print!(cx, write(\"'{}as\", scope.item_local_id().as_usize())),\n+                            p!(write(\"'{}as\", scope.item_local_id().as_usize())),\n                         region::ScopeData::Destruction =>\n-                            print!(cx, write(\"'{}ds\", scope.item_local_id().as_usize())),\n-                        region::ScopeData::Remainder(first_statement_index) => print!(cx, write(\n+                            p!(write(\"'{}ds\", scope.item_local_id().as_usize())),\n+                        region::ScopeData::Remainder(first_statement_index) => p!(write(\n                             \"'{}_{}rs\",\n                             scope.item_local_id().as_usize(),\n                             first_statement_index.index()\n                         )),\n                     }\n                 }\n                 ty::ReVar(region_vid) if cx.identify_regions => {\n-                    print!(cx, print_debug(region_vid))\n+                    p!(print_debug(region_vid))\n                 }\n                 ty::ReVar(region_vid) => {\n-                    print!(cx, print_display(region_vid))\n+                    p!(print_display(region_vid))\n                 }\n                 ty::ReScope(_) |\n                 ty::ReErased => Ok(()),\n-                ty::ReStatic => print!(cx, write(\"'static\")),\n-                ty::ReEmpty => print!(cx, write(\"'<empty>\")),\n+                ty::ReStatic => p!(write(\"'static\")),\n+                ty::ReEmpty => p!(write(\"'<empty>\")),\n \n                 // The user should never encounter these in unsubstituted form.\n-                ty::ReClosureBound(vid) => print!(cx, write(\"{:?}\", vid)),\n+                ty::ReClosureBound(vid) => p!(write(\"{:?}\", vid)),\n             }\n         }\n         debug {\n             match *self {\n                 ty::ReEarlyBound(ref data) => {\n-                    print!(cx, write(\"ReEarlyBound({}, {})\",\n+                    p!(write(\"ReEarlyBound({}, {})\",\n                            data.index,\n                            data.name))\n                 }\n \n                 ty::ReClosureBound(ref vid) => {\n-                    print!(cx, write(\"ReClosureBound({:?})\",\n+                    p!(write(\"ReClosureBound({:?})\",\n                            vid))\n                 }\n \n                 ty::ReLateBound(binder_id, ref bound_region) => {\n-                    print!(cx, write(\"ReLateBound({:?}, {:?})\",\n+                    p!(write(\"ReLateBound({:?}, {:?})\",\n                            binder_id,\n                            bound_region))\n                 }\n \n-                ty::ReFree(ref fr) => print!(cx, write(\"{:?}\", fr)),\n+                ty::ReFree(ref fr) => p!(write(\"{:?}\", fr)),\n \n                 ty::ReScope(id) => {\n-                    print!(cx, write(\"ReScope({:?})\", id))\n+                    p!(write(\"ReScope({:?})\", id))\n                 }\n \n-                ty::ReStatic => print!(cx, write(\"ReStatic\")),\n+                ty::ReStatic => p!(write(\"ReStatic\")),\n \n                 ty::ReVar(ref vid) => {\n-                    print!(cx, write(\"{:?}\", vid))\n+                    p!(write(\"{:?}\", vid))\n                 }\n \n                 ty::RePlaceholder(placeholder) => {\n-                    print!(cx, write(\"RePlaceholder({:?})\", placeholder))\n+                    p!(write(\"RePlaceholder({:?})\", placeholder))\n                 }\n \n-                ty::ReEmpty => print!(cx, write(\"ReEmpty\")),\n+                ty::ReEmpty => p!(write(\"ReEmpty\")),\n \n-                ty::ReErased => print!(cx, write(\"ReErased\"))\n+                ty::ReErased => p!(write(\"ReErased\"))\n             }\n         }\n     }\n@@ -817,7 +837,7 @@ impl ty::RegionKind {\n define_print! {\n     () ty::FreeRegion, (self, cx) {\n         debug {\n-            print!(cx, write(\"ReFree({:?}, {:?})\", self.scope, self.bound_region))\n+            p!(write(\"ReFree({:?}, {:?})\", self.scope, self.bound_region))\n         }\n     }\n }\n@@ -839,18 +859,18 @@ define_print! {\n     ('tcx) ty::FnSig<'tcx>, (self, cx) {\n         display {\n             if self.unsafety == hir::Unsafety::Unsafe {\n-                print!(cx, write(\"unsafe \"))?;\n+                p!(write(\"unsafe \"))?;\n             }\n \n             if self.abi != Abi::Rust {\n-                print!(cx, write(\"extern {} \", self.abi))?;\n+                p!(write(\"extern {} \", self.abi))?;\n             }\n \n-            print!(cx, write(\"fn\"))?;\n+            p!(write(\"fn\"))?;\n             cx.fn_sig(self.inputs(), self.c_variadic, self.output())\n         }\n         debug {\n-            print!(cx, write(\"({:?}; c_variadic: {})->{:?}\",\n+            p!(write(\"({:?}; c_variadic: {})->{:?}\",\n                 self.inputs(), self.c_variadic, self.output()))\n         }\n     }\n@@ -889,7 +909,7 @@ define_print! {\n \n             let highlight = RegionHighlightMode::get();\n             if let Some(counter) = highlight.region_highlighted(&ty::ReVar(*self)) {\n-                return print!(cx, write(\"'{:?}\", counter));\n+                return p!(write(\"'{:?}\", counter));\n             }\n \n             Ok(())\n@@ -899,10 +919,10 @@ define_print! {\n             // to keep NLL borrowck working even with `-Zverbose`.\n             let highlight = RegionHighlightMode::get();\n             if let Some(counter) = highlight.region_highlighted(&ty::ReVar(*self)) {\n-                return print!(cx, write(\"'{:?}\", counter));\n+                return p!(write(\"'{:?}\", counter));\n             }\n \n-            print!(cx, write(\"'_#{}r\", self.index()))\n+            p!(write(\"'_#{}r\", self.index()))\n         }\n     }\n }\n@@ -932,22 +952,22 @@ define_print! {\n                 return self.print_debug(cx);\n             }\n             match *self {\n-                ty::TyVar(_) => print!(cx, write(\"_\")),\n-                ty::IntVar(_) => print!(cx, write(\"{}\", \"{integer}\")),\n-                ty::FloatVar(_) => print!(cx, write(\"{}\", \"{float}\")),\n-                ty::FreshTy(v) => print!(cx, write(\"FreshTy({})\", v)),\n-                ty::FreshIntTy(v) => print!(cx, write(\"FreshIntTy({})\", v)),\n-                ty::FreshFloatTy(v) => print!(cx, write(\"FreshFloatTy({})\", v))\n+                ty::TyVar(_) => p!(write(\"_\")),\n+                ty::IntVar(_) => p!(write(\"{}\", \"{integer}\")),\n+                ty::FloatVar(_) => p!(write(\"{}\", \"{float}\")),\n+                ty::FreshTy(v) => p!(write(\"FreshTy({})\", v)),\n+                ty::FreshIntTy(v) => p!(write(\"FreshIntTy({})\", v)),\n+                ty::FreshFloatTy(v) => p!(write(\"FreshFloatTy({})\", v))\n             }\n         }\n         debug {\n             match *self {\n-                ty::TyVar(ref v) => print!(cx, write(\"{:?}\", v)),\n-                ty::IntVar(ref v) => print!(cx, write(\"{:?}\", v)),\n-                ty::FloatVar(ref v) => print!(cx, write(\"{:?}\", v)),\n-                ty::FreshTy(v) => print!(cx, write(\"FreshTy({:?})\", v)),\n-                ty::FreshIntTy(v) => print!(cx, write(\"FreshIntTy({:?})\", v)),\n-                ty::FreshFloatTy(v) => print!(cx, write(\"FreshFloatTy({:?})\", v))\n+                ty::TyVar(ref v) => p!(write(\"{:?}\", v)),\n+                ty::IntVar(ref v) => p!(write(\"{:?}\", v)),\n+                ty::FloatVar(ref v) => p!(write(\"{:?}\", v)),\n+                ty::FreshTy(v) => p!(write(\"FreshTy({:?})\", v)),\n+                ty::FreshIntTy(v) => p!(write(\"FreshIntTy({:?})\", v)),\n+                ty::FreshFloatTy(v) => p!(write(\"FreshFloatTy({:?})\", v))\n             }\n         }\n     }\n@@ -1020,68 +1040,68 @@ define_print! {\n     ('tcx) ty::Ty<'tcx>, (self, cx) {\n         display {\n             match self.sty {\n-                Bool => print!(cx, write(\"bool\")),\n-                Char => print!(cx, write(\"char\")),\n-                Int(t) => print!(cx, write(\"{}\", t.ty_to_string())),\n-                Uint(t) => print!(cx, write(\"{}\", t.ty_to_string())),\n-                Float(t) => print!(cx, write(\"{}\", t.ty_to_string())),\n+                Bool => p!(write(\"bool\")),\n+                Char => p!(write(\"char\")),\n+                Int(t) => p!(write(\"{}\", t.ty_to_string())),\n+                Uint(t) => p!(write(\"{}\", t.ty_to_string())),\n+                Float(t) => p!(write(\"{}\", t.ty_to_string())),\n                 RawPtr(ref tm) => {\n-                    print!(cx, write(\"*{} \", match tm.mutbl {\n+                    p!(write(\"*{} \", match tm.mutbl {\n                         hir::MutMutable => \"mut\",\n                         hir::MutImmutable => \"const\",\n                     }))?;\n                     tm.ty.print(cx)\n                 }\n                 Ref(r, ty, mutbl) => {\n-                    print!(cx, write(\"&\"))?;\n+                    p!(write(\"&\"))?;\n                     if r.display_outputs_anything(cx) {\n-                        print!(cx, print_display(r), write(\" \"))?;\n+                        p!(print_display(r), write(\" \"))?;\n                     }\n                     ty::TypeAndMut { ty, mutbl }.print(cx)\n                 }\n-                Never => print!(cx, write(\"!\")),\n+                Never => p!(write(\"!\")),\n                 Tuple(ref tys) => {\n-                    print!(cx, write(\"(\"))?;\n+                    p!(write(\"(\"))?;\n                     let mut tys = tys.iter();\n                     if let Some(&ty) = tys.next() {\n-                        print!(cx, print(ty), write(\",\"))?;\n+                        p!(print(ty), write(\",\"))?;\n                         if let Some(&ty) = tys.next() {\n-                            print!(cx, write(\" \"), print(ty))?;\n+                            p!(write(\" \"), print(ty))?;\n                             for &ty in tys {\n-                                print!(cx, write(\", \"), print(ty))?;\n+                                p!(write(\", \"), print(ty))?;\n                             }\n                         }\n                     }\n-                    print!(cx, write(\")\"))\n+                    p!(write(\")\"))\n                 }\n                 FnDef(def_id, substs) => {\n                     let sig = cx.tcx.fn_sig(def_id).subst(cx.tcx, substs);\n-                    print!(cx, print(sig), write(\" {{\"))?;\n+                    p!(print(sig), write(\" {{\"))?;\n                     let _ = cx.print_def_path(\n                         def_id,\n                         Some(substs),\n                         Namespace::ValueNS,\n                         iter::empty(),\n                     )?;\n-                    print!(cx, write(\"}}\"))\n+                    p!(write(\"}}\"))\n                 }\n                 FnPtr(ref bare_fn) => {\n                     bare_fn.print(cx)\n                 }\n-                Infer(infer_ty) => print!(cx, write(\"{}\", infer_ty)),\n-                Error => print!(cx, write(\"[type error]\")),\n-                Param(ref param_ty) => print!(cx, write(\"{}\", param_ty)),\n+                Infer(infer_ty) => p!(write(\"{}\", infer_ty)),\n+                Error => p!(write(\"[type error]\")),\n+                Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n                 Bound(debruijn, bound_ty) => {\n                     match bound_ty.kind {\n                         ty::BoundTyKind::Anon => {\n                             if debruijn == ty::INNERMOST {\n-                                print!(cx, write(\"^{}\", bound_ty.var.index()))\n+                                p!(write(\"^{}\", bound_ty.var.index()))\n                             } else {\n-                                print!(cx, write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n+                                p!(write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n                             }\n                         }\n \n-                        ty::BoundTyKind::Param(p) => print!(cx, write(\"{}\", p)),\n+                        ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n                     }\n                 }\n                 Adt(def, substs) => {\n@@ -1096,12 +1116,12 @@ define_print! {\n                 Dynamic(data, r) => {\n                     let print_r = r.display_outputs_anything(cx);\n                     if print_r {\n-                        print!(cx, write(\"(\"))?;\n+                        p!(write(\"(\"))?;\n                     }\n-                    print!(cx, write(\"dyn \"))?;\n+                    p!(write(\"dyn \"))?;\n                     data.print(cx)?;\n                     if print_r {\n-                        print!(cx, write(\" + \"), print_display(r), write(\")\"))?;\n+                        p!(write(\" + \"), print_display(r), write(\")\"))?;\n                     }\n                     Ok(())\n                 }\n@@ -1116,30 +1136,30 @@ define_print! {\n                 }\n                 Projection(ref data) => data.print(cx),\n                 UnnormalizedProjection(ref data) => {\n-                    print!(cx, write(\"Unnormalized(\"))?;\n+                    p!(write(\"Unnormalized(\"))?;\n                     data.print(cx)?;\n-                    print!(cx, write(\")\"))\n+                    p!(write(\")\"))\n                 }\n                 Placeholder(placeholder) => {\n-                    print!(cx, write(\"Placeholder({:?})\", placeholder))\n+                    p!(write(\"Placeholder({:?})\", placeholder))\n                 }\n                 Opaque(def_id, substs) => {\n                     if cx.is_verbose {\n-                        return print!(cx, write(\"Opaque({:?}, {:?})\", def_id, substs));\n+                        return p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n                     }\n \n                     let def_key = cx.tcx.def_key(def_id);\n                     if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                        print!(cx, write(\"{}\", name))?;\n+                        p!(write(\"{}\", name))?;\n                         let mut substs = substs.iter();\n                         // FIXME(eddyb) print this with `print_def_path`.\n                         if let Some(first) = substs.next() {\n-                            print!(cx, write(\"::<\"))?;\n-                            print!(cx, write(\"{}\", first))?;\n+                            p!(write(\"::<\"))?;\n+                            p!(write(\"{}\", first))?;\n                             for subst in substs {\n-                                print!(cx, write(\", {}\", subst))?;\n+                                p!(write(\", {}\", subst))?;\n                             }\n-                            print!(cx, write(\">\"))?;\n+                            p!(write(\">\"))?;\n                         }\n                         return Ok(());\n                     }\n@@ -1149,7 +1169,7 @@ define_print! {\n \n                     let mut first = true;\n                     let mut is_sized = false;\n-                    print!(cx, write(\"impl\"))?;\n+                    p!(write(\"impl\"))?;\n                     for predicate in bounds.predicates {\n                         if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n                             // Don't print +Sized, but rather +?Sized if absent.\n@@ -1158,36 +1178,36 @@ define_print! {\n                                 continue;\n                             }\n \n-                            print!(cx,\n+                            p!(\n                                     write(\"{}\", if first { \" \" } else { \"+\" }),\n                                     print(trait_ref))?;\n                             first = false;\n                         }\n                     }\n                     if !is_sized {\n-                        print!(cx, write(\"{}?Sized\", if first { \" \" } else { \"+\" }))?;\n+                        p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }))?;\n                     } else if first {\n-                        print!(cx, write(\" Sized\"))?;\n+                        p!(write(\" Sized\"))?;\n                     }\n                     Ok(())\n                 }\n-                Str => print!(cx, write(\"str\")),\n+                Str => p!(write(\"str\")),\n                 Generator(did, substs, movability) => {\n                     let upvar_tys = substs.upvar_tys(did, cx.tcx);\n                     let witness = substs.witness(did, cx.tcx);\n                     if movability == hir::GeneratorMovability::Movable {\n-                        print!(cx, write(\"[generator\"))?;\n+                        p!(write(\"[generator\"))?;\n                     } else {\n-                        print!(cx, write(\"[static generator\"))?;\n+                        p!(write(\"[static generator\"))?;\n                     }\n \n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n-                        print!(cx, write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)))?;\n+                        p!(write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)))?;\n                         let mut sep = \" \";\n                         cx.tcx.with_freevars(hir_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                                print!(cx,\n+                                p!(\n                                        write(\"{}{}:\",\n                                              sep,\n                                              cx.tcx.hir().name(freevar.var_id())),\n@@ -1199,36 +1219,36 @@ define_print! {\n                     } else {\n                         // cross-crate closure types should only be\n                         // visible in codegen bug reports, I imagine.\n-                        print!(cx, write(\"@{:?}\", did))?;\n+                        p!(write(\"@{:?}\", did))?;\n                         let mut sep = \" \";\n                         for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            print!(cx,\n+                            p!(\n                                    write(\"{}{}:\", sep, index),\n                                    print(upvar_ty))?;\n                             sep = \", \";\n                         }\n                     }\n \n-                    print!(cx, write(\" \"), print(witness), write(\"]\"))\n+                    p!(write(\" \"), print(witness), write(\"]\"))\n                 },\n                 GeneratorWitness(types) => {\n                     cx.in_binder(&types)\n                 }\n                 Closure(did, substs) => {\n                     let upvar_tys = substs.upvar_tys(did, cx.tcx);\n-                    print!(cx, write(\"[closure\"))?;\n+                    p!(write(\"[closure\"))?;\n \n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n                         if cx.tcx.sess.opts.debugging_opts.span_free_formats {\n-                            print!(cx, write(\"@{:?}\", hir_id))?;\n+                            p!(write(\"@{:?}\", hir_id))?;\n                         } else {\n-                            print!(cx, write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)))?;\n+                            p!(write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)))?;\n                         }\n                         let mut sep = \" \";\n                         cx.tcx.with_freevars(hir_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                                print!(cx,\n+                                p!(\n                                        write(\"{}{}:\",\n                                              sep,\n                                              cx.tcx.hir().name(freevar.var_id())),\n@@ -1240,45 +1260,45 @@ define_print! {\n                     } else {\n                         // cross-crate closure types should only be\n                         // visible in codegen bug reports, I imagine.\n-                        print!(cx, write(\"@{:?}\", did))?;\n+                        p!(write(\"@{:?}\", did))?;\n                         let mut sep = \" \";\n                         for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            print!(cx,\n+                            p!(\n                                    write(\"{}{}:\", sep, index),\n                                    print(upvar_ty))?;\n                             sep = \", \";\n                         }\n                     }\n \n                     if cx.is_verbose {\n-                        print!(cx, write(\n+                        p!(write(\n                             \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n                             substs.closure_kind_ty(did, cx.tcx),\n                             substs.closure_sig_ty(did, cx.tcx)\n                         ))?;\n                     }\n \n-                    print!(cx, write(\"]\"))\n+                    p!(write(\"]\"))\n                 },\n                 Array(ty, sz) => {\n-                    print!(cx, write(\"[\"), print(ty), write(\"; \"))?;\n+                    p!(write(\"[\"), print(ty), write(\"; \"))?;\n                     match sz {\n                         ty::LazyConst::Unevaluated(_def_id, _substs) => {\n-                            print!(cx, write(\"_\"))?;\n+                            p!(write(\"_\"))?;\n                         }\n                         ty::LazyConst::Evaluated(c) => {\n                             match c.val {\n-                                ConstValue::Infer(..) => print!(cx, write(\"_\"))?,\n+                                ConstValue::Infer(..) => p!(write(\"_\"))?,\n                                 ConstValue::Param(ParamConst { name, .. }) =>\n-                                    print!(cx, write(\"{}\", name))?,\n-                                _ => print!(cx, write(\"{}\", c.unwrap_usize(cx.tcx)))?,\n+                                    p!(write(\"{}\", name))?,\n+                                _ => p!(write(\"{}\", c.unwrap_usize(cx.tcx)))?,\n                             }\n                         }\n                     }\n-                    print!(cx, write(\"]\"))\n+                    p!(write(\"]\"))\n                 }\n                 Slice(ty) => {\n-                    print!(cx, write(\"[\"), print(ty), write(\"]\"))\n+                    p!(write(\"[\"), print(ty), write(\"]\"))\n                 }\n             }\n         }\n@@ -1292,9 +1312,9 @@ define_print! {\n     ('tcx) ConstValue<'tcx>, (self, cx) {\n         display {\n             match self {\n-                ConstValue::Infer(..) => print!(cx, write(\"_\")),\n-                ConstValue::Param(ParamConst { name, .. }) => print!(cx, write(\"{}\", name)),\n-                _ => print!(cx, write(\"{:?}\", self)),\n+                ConstValue::Infer(..) => p!(write(\"_\")),\n+                ConstValue::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n+                _ => p!(write(\"{:?}\", self)),\n             }\n         }\n     }\n@@ -1303,7 +1323,7 @@ define_print! {\n define_print! {\n     ('tcx) ty::Const<'tcx>, (self, cx) {\n         display {\n-            print!(cx, write(\"{} : {}\", self.val, self.ty))\n+            p!(write(\"{} : {}\", self.val, self.ty))\n         }\n     }\n }\n@@ -1313,8 +1333,8 @@ define_print! {\n         display {\n             match self {\n                 // FIXME(const_generics) this should print at least the type.\n-                ty::LazyConst::Unevaluated(..) => print!(cx, write(\"_ : _\")),\n-                ty::LazyConst::Evaluated(c) => print!(cx, write(\"{}\", c)),\n+                ty::LazyConst::Unevaluated(..) => p!(write(\"_ : _\")),\n+                ty::LazyConst::Evaluated(c) => p!(write(\"{}\", c)),\n             }\n         }\n     }\n@@ -1323,21 +1343,21 @@ define_print! {\n define_print! {\n     () ty::ParamTy, (self, cx) {\n         display {\n-            print!(cx, write(\"{}\", self.name))\n+            p!(write(\"{}\", self.name))\n         }\n         debug {\n-            print!(cx, write(\"{}/#{}\", self.name, self.idx))\n+            p!(write(\"{}/#{}\", self.name, self.idx))\n         }\n     }\n }\n \n define_print! {\n     () ty::ParamConst, (self, cx) {\n         display {\n-            print!(cx, write(\"{}\", self.name))\n+            p!(write(\"{}\", self.name))\n         }\n         debug {\n-            print!(cx, write(\"{}/#{}\", self.name, self.index))\n+            p!(write(\"{}/#{}\", self.name, self.index))\n         }\n     }\n }\n@@ -1350,43 +1370,43 @@ define_print_multi! {\n     ]\n     (self, cx) {\n         display {\n-            print!(cx, print(self.0), write(\" : \"), print(self.1))\n+            p!(print(self.0), write(\" : \"), print(self.1))\n         }\n     }\n }\n \n define_print! {\n     ('tcx) ty::SubtypePredicate<'tcx>, (self, cx) {\n         display {\n-            print!(cx, print(self.a), write(\" <: \"), print(self.b))\n+            p!(print(self.a), write(\" <: \"), print(self.b))\n         }\n     }\n }\n \n define_print! {\n     ('tcx) ty::TraitPredicate<'tcx>, (self, cx) {\n         debug {\n-            print!(cx, write(\"TraitPredicate({:?})\",\n+            p!(write(\"TraitPredicate({:?})\",\n                    self.trait_ref))\n         }\n         display {\n-            print!(cx, print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n+            p!(print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n         }\n     }\n }\n \n define_print! {\n     ('tcx) ty::ProjectionPredicate<'tcx>, (self, cx) {\n         debug {\n-            print!(cx,\n+            p!(\n                    write(\"ProjectionPredicate(\"),\n                    print(self.projection_ty),\n                    write(\", \"),\n                    print(self.ty),\n                    write(\")\"))\n         }\n         display {\n-            print!(cx, print(self.projection_ty), write(\" == \"), print(self.ty))\n+            p!(print(self.projection_ty), write(\" == \"), print(self.ty))\n         }\n     }\n }\n@@ -1409,9 +1429,9 @@ define_print! {\n     () ty::ClosureKind, (self, cx) {\n         display {\n             match *self {\n-                ty::ClosureKind::Fn => print!(cx, write(\"Fn\")),\n-                ty::ClosureKind::FnMut => print!(cx, write(\"FnMut\")),\n-                ty::ClosureKind::FnOnce => print!(cx, write(\"FnOnce\")),\n+                ty::ClosureKind::Fn => p!(write(\"Fn\")),\n+                ty::ClosureKind::FnMut => p!(write(\"FnMut\")),\n+                ty::ClosureKind::FnOnce => p!(write(\"FnOnce\")),\n             }\n         }\n     }\n@@ -1426,36 +1446,36 @@ define_print! {\n                 ty::Predicate::RegionOutlives(ref predicate) => predicate.print(cx),\n                 ty::Predicate::TypeOutlives(ref predicate) => predicate.print(cx),\n                 ty::Predicate::Projection(ref predicate) => predicate.print(cx),\n-                ty::Predicate::WellFormed(ty) => print!(cx, print(ty), write(\" well-formed\")),\n+                ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n                 ty::Predicate::ObjectSafe(trait_def_id) => {\n-                    print!(cx, write(\"the trait `\"))?;\n+                    p!(write(\"the trait `\"))?;\n                     let _ = cx.print_def_path(\n                         trait_def_id,\n                         None,\n                         Namespace::TypeNS,\n                         iter::empty(),\n                     )?;\n-                    print!(cx, write(\"` is object-safe\"))\n+                    p!(write(\"` is object-safe\"))\n                 }\n                 ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n-                    print!(cx, write(\"the closure `\"))?;\n+                    p!(write(\"the closure `\"))?;\n                     let _ = cx.print_def_path(\n                         closure_def_id,\n                         None,\n                         Namespace::ValueNS,\n                         iter::empty(),\n                     )?;\n-                    print!(cx, write(\"` implements the trait `{}`\", kind))\n+                    p!(write(\"` implements the trait `{}`\", kind))\n                 }\n                 ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                    print!(cx, write(\"the constant `\"))?;\n+                    p!(write(\"the constant `\"))?;\n                     let _ = cx.print_def_path(\n                         def_id,\n                         Some(substs),\n                         Namespace::ValueNS,\n                         iter::empty(),\n                     )?;\n-                    print!(cx, write(\"` can be evaluated\"))\n+                    p!(write(\"` can be evaluated\"))\n                 }\n             }\n         }\n@@ -1468,14 +1488,14 @@ define_print! {\n                 ty::Predicate::Projection(ref pair) => pair.print(cx),\n                 ty::Predicate::WellFormed(ty) => ty.print(cx),\n                 ty::Predicate::ObjectSafe(trait_def_id) => {\n-                    print!(cx, write(\"ObjectSafe({:?})\", trait_def_id))\n+                    p!(write(\"ObjectSafe({:?})\", trait_def_id))\n                 }\n                 ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                    print!(cx, write(\"ClosureKind({:?}, {:?}, {:?})\",\n+                    p!(write(\"ClosureKind({:?}, {:?}, {:?})\",\n                         closure_def_id, closure_substs, kind))\n                 }\n                 ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                    print!(cx, write(\"ConstEvaluatable({:?}, {:?})\", def_id, substs))\n+                    p!(write(\"ConstEvaluatable({:?}, {:?})\", def_id, substs))\n                 }\n             }\n         }\n@@ -1486,16 +1506,16 @@ define_print! {\n     ('tcx) Kind<'tcx>, (self, cx) {\n         display {\n             match self.unpack() {\n-                UnpackedKind::Lifetime(lt) => print!(cx, print(lt)),\n-                UnpackedKind::Type(ty) => print!(cx, print(ty)),\n-                UnpackedKind::Const(ct) => print!(cx, print(ct)),\n+                UnpackedKind::Lifetime(lt) => p!(print(lt)),\n+                UnpackedKind::Type(ty) => p!(print(ty)),\n+                UnpackedKind::Const(ct) => p!(print(ct)),\n             }\n         }\n         debug {\n             match self.unpack() {\n-                UnpackedKind::Lifetime(lt) => print!(cx, print(lt)),\n-                UnpackedKind::Type(ty) => print!(cx, print(ty)),\n-                UnpackedKind::Const(ct) => print!(cx, print(ct)),\n+                UnpackedKind::Lifetime(lt) => p!(print(lt)),\n+                UnpackedKind::Type(ty) => p!(print(ty)),\n+                UnpackedKind::Const(ct) => p!(print(ct)),\n             }\n         }\n     }"}]}