{"sha": "3c30ecb706dc32257d1ec6bdcb0c88eb924483dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMzBlY2I3MDZkYzMyMjU3ZDFlYzZiZGNiMGM4OGViOTI0NDgzZGQ=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-09-06T06:13:02Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-09-06T06:19:41Z"}, "message": "Add fractional second support to str{p,f}time\n\nThe ISO 8601 standard does not mandate any specific precision for\nfractional seconds, so this accepts input of any length, ignoring the\npart after the nanoseconds place. It may be more correct to round with\nthe tenths of nanoseconds digit, but then we'd have to deal with\ncarrying the round through the entire Tm struct (e.g. for a time like\nDec 31 11:59.999999999999).\n\n%f is the format specifier that Python's datetime library uses for\n0-padded microseconds so it seemed appropriate here.\n\ncc #2350", "tree": {"sha": "d86421c6b40f9f4e67f35c8d80d4a52ee791459f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d86421c6b40f9f4e67f35c8d80d4a52ee791459f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c30ecb706dc32257d1ec6bdcb0c88eb924483dd", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c30ecb706dc32257d1ec6bdcb0c88eb924483dd", "html_url": "https://github.com/rust-lang/rust/commit/3c30ecb706dc32257d1ec6bdcb0c88eb924483dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c30ecb706dc32257d1ec6bdcb0c88eb924483dd/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a980f28028f4712efbb89017bd23c25183fddbfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a980f28028f4712efbb89017bd23c25183fddbfe", "html_url": "https://github.com/rust-lang/rust/commit/a980f28028f4712efbb89017bd23c25183fddbfe"}], "stats": {"total": 40, "additions": 37, "deletions": 3}, "files": [{"sha": "7515326a0dbb22ad3968ad0e3ad42fbee9169869", "filename": "src/libextra/time.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3c30ecb706dc32257d1ec6bdcb0c88eb924483dd/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c30ecb706dc32257d1ec6bdcb0c88eb924483dd/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=3c30ecb706dc32257d1ec6bdcb0c88eb924483dd", "patch": "@@ -321,6 +321,33 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         Some((value, pos))\n     }\n \n+    fn match_fractional_seconds(ss: &str, pos: uint) -> (i32, uint) {\n+        let len = ss.len();\n+        let mut value = 0_i32;\n+        let mut multiplier = NSEC_PER_SEC / 10;\n+        let mut pos = pos;\n+\n+        loop {\n+            if pos >= len {\n+                break;\n+            }\n+            let range = ss.char_range_at(pos);\n+\n+            match range.ch {\n+                '0' .. '9' => {\n+                    pos = range.next;\n+                    // This will drop digits after the nanoseconds place\n+                    let digit = range.ch as i32 - '0' as i32;\n+                    value += digit * multiplier;\n+                    multiplier /= 10;\n+                }\n+                _ => break\n+            }\n+        }\n+\n+        (value, pos)\n+    }\n+\n     fn match_digits_in_range(ss: &str, pos: uint, digits: uint, ws: bool,\n                              min: i32, max: i32) -> Option<(i32, uint)> {\n         match match_digits(ss, pos, digits, ws) {\n@@ -441,6 +468,11 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n             None => Err(~\"Invalid day of the month\")\n           },\n+          'f' => {\n+            let (val, pos) = match_fractional_seconds(s, pos);\n+            tm.tm_nsec = val;\n+            Ok(pos)\n+          }\n           'F' => {\n             parse_type(s, pos, 'Y', &mut *tm)\n                 .chain(|pos| parse_char(s, pos, '-'))\n@@ -773,6 +805,7 @@ fn do_strftime(format: &str, tm: &Tm) -> ~str {\n           }\n           'd' => fmt!(\"%02d\", tm.tm_mday as int),\n           'e' => fmt!(\"%2d\", tm.tm_mday as int),\n+          'f' => fmt!(\"%09d\", tm.tm_nsec as int),\n           'F' => {\n             fmt!(\"%s-%s-%s\",\n                 parse_type('Y', tm),\n@@ -1011,12 +1044,12 @@ mod tests {\n           Err(_) => ()\n         }\n \n-        let format = \"%a %b %e %T %Y\";\n+        let format = \"%a %b %e %T.%f %Y\";\n         assert_eq!(strptime(\"\", format), Err(~\"Invalid time\"));\n         assert!(strptime(\"Fri Feb 13 15:31:30\", format)\n             == Err(~\"Invalid time\"));\n \n-        match strptime(\"Fri Feb 13 15:31:30 2009\", format) {\n+        match strptime(\"Fri Feb 13 15:31:30.01234 2009\", format) {\n           Err(e) => fail!(e),\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 30_i32);\n@@ -1030,7 +1063,7 @@ mod tests {\n             assert!(tm.tm_isdst == 0_i32);\n             assert!(tm.tm_gmtoff == 0_i32);\n             assert!(tm.tm_zone == ~\"\");\n-            assert!(tm.tm_nsec == 0_i32);\n+            assert!(tm.tm_nsec == 12340000_i32);\n           }\n         }\n \n@@ -1187,6 +1220,7 @@ mod tests {\n         assert_eq!(local.strftime(\"%D\"), ~\"02/13/09\");\n         assert_eq!(local.strftime(\"%d\"), ~\"13\");\n         assert_eq!(local.strftime(\"%e\"), ~\"13\");\n+        assert_eq!(local.strftime(\"%f\"), ~\"000054321\");\n         assert_eq!(local.strftime(\"%F\"), ~\"2009-02-13\");\n         // assert!(local.strftime(\"%G\") == \"2009\");\n         // assert!(local.strftime(\"%g\") == \"09\");"}]}