{"sha": "005c9624bbd1cae81b1e9185743e332e160bb5c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNWM5NjI0YmJkMWNhZTgxYjFlOTE4NTc0M2UzMzJlMTYwYmI1Yzc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-01-29T02:44:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-01-29T21:54:30Z"}, "message": "Remove src/test/bench\n\nI don't believe these test cases have served any purpose in years.\n\nThe shootout benchmarks are now upstreamed. A new benchmark suite\nshould rather be maintained out of tree.", "tree": {"sha": "9f73512d39e8c1182a3e6bc7ddd094e7e6f0d0d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f73512d39e8c1182a3e6bc7ddd094e7e6f0d0d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/005c9624bbd1cae81b1e9185743e332e160bb5c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/005c9624bbd1cae81b1e9185743e332e160bb5c7", "html_url": "https://github.com/rust-lang/rust/commit/005c9624bbd1cae81b1e9185743e332e160bb5c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/005c9624bbd1cae81b1e9185743e332e160bb5c7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f196bcc3b23925854e3d758c03f56c7520e9b99", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f196bcc3b23925854e3d758c03f56c7520e9b99", "html_url": "https://github.com/rust-lang/rust/commit/0f196bcc3b23925854e3d758c03f56c7520e9b99"}], "stats": {"total": 87878, "additions": 4, "deletions": 87874}, "files": [{"sha": "de8802310c17b75e8fcfb7ee98609a0cae34eca4", "filename": "mk/tests.mk", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/005c9624bbd1cae81b1e9185743e332e160bb5c7/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/005c9624bbd1cae81b1e9185743e332e160bb5c7/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=005c9624bbd1cae81b1e9185743e332e160bb5c7", "patch": "@@ -45,7 +45,7 @@ ifdef CHECK_IGNORED\n   TESTARGS += --ignored\n endif\n \n-# Arguments to the cfail/rfail/rpass/bench tests\n+# Arguments to the cfail/rfail/rpass tests\n ifdef CFG_VALGRIND\n   CTEST_RUNTOOL = --runtool \"$(CFG_VALGRIND)\"\n endif\n@@ -306,7 +306,6 @@ check-stage$(1)-T-$(2)-H-$(3)-exec: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-rustdocck-exec \\\n         check-stage$(1)-T-$(2)-H-$(3)-crates-exec \\\n         check-stage$(1)-T-$(2)-H-$(3)-doc-crates-exec \\\n-\tcheck-stage$(1)-T-$(2)-H-$(3)-bench-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-debuginfo-gdb-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-debuginfo-lldb-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-codegen-exec \\\n@@ -344,7 +343,6 @@ check-stage$(1)-T-$(2)-H-$(3)-pretty-exec: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-rpass-full-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-rfail-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-rfail-full-exec \\\n-\tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-bench-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-pretty-exec\n \n endef\n@@ -468,7 +466,6 @@ CFAIL_FULL_RS := $(wildcard $(S)src/test/compile-fail-fulldeps/*.rs)\n RFAIL_RS := $(wildcard $(S)src/test/run-fail/*.rs)\n CFAIL_RS := $(wildcard $(S)src/test/compile-fail/*.rs)\n PFAIL_RS := $(wildcard $(S)src/test/parse-fail/*.rs)\n-BENCH_RS := $(wildcard $(S)src/test/bench/*.rs)\n PRETTY_RS := $(wildcard $(S)src/test/pretty/*.rs)\n DEBUGINFO_GDB_RS := $(wildcard $(S)src/test/debuginfo/*.rs)\n DEBUGINFO_LLDB_RS := $(wildcard $(S)src/test/debuginfo/*.rs)\n@@ -485,7 +482,6 @@ CFAIL_FULL_TESTS := $(CFAIL_FULL_RS)\n RFAIL_TESTS := $(RFAIL_RS)\n CFAIL_TESTS := $(CFAIL_RS)\n PFAIL_TESTS := $(PFAIL_RS)\n-BENCH_TESTS := $(BENCH_RS)\n PRETTY_TESTS := $(PRETTY_RS)\n DEBUGINFO_GDB_TESTS := $(DEBUGINFO_GDB_RS)\n DEBUGINFO_LLDB_TESTS := $(DEBUGINFO_LLDB_RS)\n@@ -533,11 +529,6 @@ CTEST_BUILD_BASE_pfail = parse-fail\n CTEST_MODE_pfail = parse-fail\n CTEST_RUNTOOL_pfail = $(CTEST_RUNTOOL)\n \n-CTEST_SRC_BASE_bench = bench\n-CTEST_BUILD_BASE_bench = bench\n-CTEST_MODE_bench = run-pass\n-CTEST_RUNTOOL_bench = $(CTEST_RUNTOOL)\n-\n CTEST_SRC_BASE_debuginfo-gdb = debuginfo\n CTEST_BUILD_BASE_debuginfo-gdb = debuginfo-gdb\n CTEST_MODE_debuginfo-gdb = debuginfo-gdb\n@@ -612,7 +603,7 @@ TEST_SREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(HBIN$(1)_H_$(3))/compiletest$$(X_$(3)) \\\n \t$$(SREQ$(1)_T_$(2)_H_$(3))\n \n-# Rules for the cfail/rfail/rpass/bench test runner\n+# Rules for the cfail/rfail/rpass test runner\n \n # The tests select when to use debug configuration on their own;\n # remove directive, if present, from CFG_RUSTC_FLAGS (issue #7898).\n@@ -675,7 +666,6 @@ CTEST_DEPS_cfail-full_$(1)-T-$(2)-H-$(3) = $$(CFAIL_FULL_TESTS) $$(CSREQ$(1)_T_$\n CTEST_DEPS_rfail_$(1)-T-$(2)-H-$(3) = $$(RFAIL_TESTS)\n CTEST_DEPS_cfail_$(1)-T-$(2)-H-$(3) = $$(CFAIL_TESTS)\n CTEST_DEPS_pfail_$(1)-T-$(2)-H-$(3) = $$(PFAIL_TESTS)\n-CTEST_DEPS_bench_$(1)-T-$(2)-H-$(3) = $$(BENCH_TESTS)\n CTEST_DEPS_debuginfo-gdb_$(1)-T-$(2)-H-$(3) = $$(DEBUGINFO_GDB_TESTS)\n CTEST_DEPS_debuginfo-lldb_$(1)-T-$(2)-H-$(3) = $$(DEBUGINFO_LLDB_TESTS) \\\n                                                $(S)src/etc/lldb_batchmode.py \\\n@@ -748,7 +738,7 @@ endif\n endef\n \n CTEST_NAMES = rpass rpass-valgrind rpass-full rfail-full cfail-full rfail cfail pfail \\\n-\tbench debuginfo-gdb debuginfo-lldb codegen codegen-units rustdocck\n+\tdebuginfo-gdb debuginfo-lldb codegen codegen-units rustdocck\n \n $(foreach host,$(CFG_HOST), \\\n  $(eval $(foreach target,$(CFG_TARGET), \\\n@@ -757,20 +747,18 @@ $(foreach host,$(CFG_HOST), \\\n    $(eval $(call DEF_RUN_COMPILETEST,$(stage),$(target),$(host),$(name))))))))))\n \n PRETTY_NAMES = pretty-rpass pretty-rpass-valgrind pretty-rpass-full pretty-rfail-full pretty-rfail \\\n-    pretty-bench pretty-pretty\n+    pretty-pretty\n PRETTY_DEPS_pretty-rpass = $(RPASS_TESTS)\n PRETTY_DEPS_pretty-rpass-valgrind = $(RPASS_VALGRIND_TESTS)\n PRETTY_DEPS_pretty-rpass-full = $(RPASS_FULL_TESTS)\n PRETTY_DEPS_pretty-rfail-full = $(RFAIL_FULL_TESTS)\n PRETTY_DEPS_pretty-rfail = $(RFAIL_TESTS)\n-PRETTY_DEPS_pretty-bench = $(BENCH_TESTS)\n PRETTY_DEPS_pretty-pretty = $(PRETTY_TESTS)\n PRETTY_DIRNAME_pretty-rpass = run-pass\n PRETTY_DIRNAME_pretty-rpass-valgrind = run-pass-valgrind\n PRETTY_DIRNAME_pretty-rpass-full = run-pass-fulldeps\n PRETTY_DIRNAME_pretty-rfail-full = run-fail-fulldeps\n PRETTY_DIRNAME_pretty-rfail = run-fail\n-PRETTY_DIRNAME_pretty-bench = bench\n PRETTY_DIRNAME_pretty-pretty = pretty\n \n define DEF_PRETTY_FULLDEPS\n@@ -920,7 +908,6 @@ TEST_GROUPS = \\\n \trfail \\\n \tcfail \\\n \tpfail \\\n-\tbench \\\n \trmake \\\n \trustdocck \\\n \tdebuginfo-gdb \\\n@@ -935,7 +922,6 @@ TEST_GROUPS = \\\n \tpretty-rpass-full \\\n \tpretty-rfail-full \\\n \tpretty-rfail \\\n-\tpretty-bench \\\n \tpretty-pretty \\\n \t$(NULL)\n "}, {"sha": "a72e348c7201865a43c4fa25e9ce3612a271291c", "filename": "src/test/bench/core-map.rs", "status": "removed", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,164 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(std_misc, rand, duration, duration_span)]\n-\n-use std::collections::{BTreeMap, HashMap, HashSet};\n-use std::env;\n-use std::__rand::{Rng, thread_rng};\n-use std::time::Duration;\n-\n-fn timed<F>(label: &str, f: F) where F: FnMut() {\n-    println!(\"  {}: {:?}\", label, Duration::span(f));\n-}\n-\n-trait MutableMap {\n-    fn insert(&mut self, k: usize, v: usize);\n-    fn remove(&mut self, k: &usize) -> bool;\n-    fn find(&self, k: &usize) -> Option<&usize>;\n-}\n-\n-impl MutableMap for BTreeMap<usize, usize> {\n-    fn insert(&mut self, k: usize, v: usize) { self.insert(k, v); }\n-    fn remove(&mut self, k: &usize) -> bool { self.remove(k).is_some() }\n-    fn find(&self, k: &usize) -> Option<&usize> { self.get(k) }\n-}\n-impl MutableMap for HashMap<usize, usize> {\n-    fn insert(&mut self, k: usize, v: usize) { self.insert(k, v); }\n-    fn remove(&mut self, k: &usize) -> bool { self.remove(k).is_some() }\n-    fn find(&self, k: &usize) -> Option<&usize> { self.get(k) }\n-}\n-\n-fn ascending<M: MutableMap>(map: &mut M, n_keys: usize) {\n-    println!(\" Ascending integers:\");\n-\n-    timed(\"insert\", || {\n-        for i in 0..n_keys {\n-            map.insert(i, i + 1);\n-        }\n-    });\n-\n-    timed(\"search\", || {\n-        for i in 0..n_keys {\n-            assert_eq!(map.find(&i).unwrap(), &(i + 1));\n-        }\n-    });\n-\n-    timed(\"remove\", || {\n-        for i in 0..n_keys {\n-            assert!(map.remove(&i));\n-        }\n-    });\n-}\n-\n-fn descending<M: MutableMap>(map: &mut M, n_keys: usize) {\n-    println!(\" Descending integers:\");\n-\n-    timed(\"insert\", || {\n-        for i in (0..n_keys).rev() {\n-            map.insert(i, i + 1);\n-        }\n-    });\n-\n-    timed(\"search\", || {\n-        for i in (0..n_keys).rev() {\n-            assert_eq!(map.find(&i).unwrap(), &(i + 1));\n-        }\n-    });\n-\n-    timed(\"remove\", || {\n-        for i in 0..n_keys {\n-            assert!(map.remove(&i));\n-        }\n-    });\n-}\n-\n-fn vector<M: MutableMap>(map: &mut M, n_keys: usize, dist: &[usize]) {\n-    timed(\"insert\", || {\n-        for i in 0..n_keys {\n-            map.insert(dist[i], i + 1);\n-        }\n-    });\n-\n-    timed(\"search\", || {\n-        for i in 0..n_keys {\n-            assert_eq!(map.find(&dist[i]).unwrap(), &(i + 1));\n-        }\n-    });\n-\n-    timed(\"remove\", || {\n-        for i in 0..n_keys {\n-            assert!(map.remove(&dist[i]));\n-        }\n-    });\n-}\n-\n-fn main() {\n-    let mut args = env::args();\n-    let n_keys = {\n-        if args.len() == 2 {\n-            args.nth(1).unwrap().parse::<usize>().unwrap()\n-        } else {\n-            1000000\n-        }\n-    };\n-\n-    let mut rand = Vec::with_capacity(n_keys);\n-\n-    {\n-        let seed: &[_] = &[1, 1, 1, 1, 1, 1, 1];\n-        let mut rng = thread_rng();\n-        let mut set = HashSet::new();\n-        while set.len() != n_keys {\n-            let next = rng.gen();\n-            if set.insert(next) {\n-                rand.push(next);\n-            }\n-        }\n-    }\n-\n-    println!(\"{} keys\", n_keys);\n-\n-    println!(\"\\nBTreeMap:\");\n-\n-    {\n-        let mut map: BTreeMap<usize,usize> = BTreeMap::new();\n-        ascending(&mut map, n_keys);\n-    }\n-\n-    {\n-        let mut map: BTreeMap<usize,usize> = BTreeMap::new();\n-        descending(&mut map, n_keys);\n-    }\n-\n-    {\n-        println!(\" Random integers:\");\n-        let mut map: BTreeMap<usize,usize> = BTreeMap::new();\n-        vector(&mut map, n_keys, &rand);\n-    }\n-\n-    println!(\"\\nHashMap:\");\n-\n-    {\n-        let mut map: HashMap<usize,usize> = HashMap::new();\n-        ascending(&mut map, n_keys);\n-    }\n-\n-    {\n-        let mut map: HashMap<usize,usize> = HashMap::new();\n-        descending(&mut map, n_keys);\n-    }\n-\n-    {\n-        println!(\" Random integers:\");\n-        let mut map: HashMap<usize,usize> = HashMap::new();\n-        vector(&mut map, n_keys, &rand);\n-    }\n-}"}, {"sha": "28ae990e05a2de508f5a2847d3b7fed986e8d273", "filename": "src/test/bench/core-set.rs", "status": "removed", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,215 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-pretty very bad with line comments\n-\n-#![feature(unboxed_closures, rand, std_misc, collections, duration, duration_span)]\n-#![feature(bitset)]\n-\n-extern crate collections;\n-extern crate rand;\n-\n-use std::collections::BTreeSet;\n-use std::collections::HashSet;\n-use std::hash::Hash;\n-use std::env;\n-use std::time::Duration;\n-\n-struct Results {\n-    sequential_ints: Duration,\n-    random_ints: Duration,\n-    delete_ints: Duration,\n-\n-    sequential_strings: Duration,\n-    random_strings: Duration,\n-    delete_strings: Duration,\n-}\n-\n-fn timed<F>(result: &mut Duration, op: F) where F: FnOnce() {\n-    *result = Duration::span(op);\n-}\n-\n-trait MutableSet<T> {\n-    fn insert(&mut self, k: T);\n-    fn remove(&mut self, k: &T) -> bool;\n-    fn contains(&self, k: &T) -> bool;\n-}\n-\n-impl<T: Hash + Eq> MutableSet<T> for HashSet<T> {\n-    fn insert(&mut self, k: T) { self.insert(k); }\n-    fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n-    fn contains(&self, k: &T) -> bool { self.contains(k) }\n-}\n-impl<T: Ord> MutableSet<T> for BTreeSet<T> {\n-    fn insert(&mut self, k: T) { self.insert(k); }\n-    fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n-    fn contains(&self, k: &T) -> bool { self.contains(k) }\n-}\n-\n-impl Results {\n-    pub fn bench_int<T:MutableSet<usize>,\n-                     R:rand::Rng,\n-                     F:FnMut() -> T>(\n-                     &mut self,\n-                     rng: &mut R,\n-                     num_keys: usize,\n-                     rand_cap: usize,\n-                     mut f: F) {\n-        {\n-            let mut set = f();\n-            timed(&mut self.sequential_ints, || {\n-                for i in 0..num_keys {\n-                    set.insert(i);\n-                }\n-\n-                for i in 0..num_keys {\n-                    assert!(set.contains(&i));\n-                }\n-            })\n-        }\n-\n-        {\n-            let mut set = f();\n-            timed(&mut self.random_ints, || {\n-                for _ in 0..num_keys {\n-                    set.insert(rng.gen::<usize>() % rand_cap);\n-                }\n-            })\n-        }\n-\n-        {\n-            let mut set = f();\n-            for i in 0..num_keys {\n-                set.insert(i);\n-            }\n-\n-            timed(&mut self.delete_ints, || {\n-                for i in 0..num_keys {\n-                    assert!(set.remove(&i));\n-                }\n-            })\n-        }\n-    }\n-\n-    pub fn bench_str<T:MutableSet<String>,\n-                     R:rand::Rng,\n-                     F:FnMut() -> T>(\n-                     &mut self,\n-                     rng: &mut R,\n-                     num_keys: usize,\n-                     mut f: F) {\n-        {\n-            let mut set = f();\n-            timed(&mut self.sequential_strings, || {\n-                for i in 0..num_keys {\n-                    set.insert(i.to_string());\n-                }\n-\n-                for i in 0..num_keys {\n-                    assert!(set.contains(&i.to_string()));\n-                }\n-            })\n-        }\n-\n-        {\n-            let mut set = f();\n-            timed(&mut self.random_strings, || {\n-                for _ in 0..num_keys {\n-                    let s = rng.gen::<usize>().to_string();\n-                    set.insert(s);\n-                }\n-            })\n-        }\n-\n-        {\n-            let mut set = f();\n-            for i in 0..num_keys {\n-                set.insert(i.to_string());\n-            }\n-            timed(&mut self.delete_strings, || {\n-                for i in 0..num_keys {\n-                    assert!(set.remove(&i.to_string()));\n-                }\n-            })\n-        }\n-    }\n-}\n-\n-fn write_header(header: &str) {\n-    println!(\"{}\", header);\n-}\n-\n-fn write_row(label: &str, value: Duration) {\n-    println!(\"{:30} {:?} s\\n\", label, value);\n-}\n-\n-fn write_results(label: &str, results: &Results) {\n-    write_header(label);\n-    write_row(\"sequential_ints\", results.sequential_ints);\n-    write_row(\"random_ints\", results.random_ints);\n-    write_row(\"delete_ints\", results.delete_ints);\n-    write_row(\"sequential_strings\", results.sequential_strings);\n-    write_row(\"random_strings\", results.random_strings);\n-    write_row(\"delete_strings\", results.delete_strings);\n-}\n-\n-fn empty_results() -> Results {\n-    Results {\n-        sequential_ints: Duration::new(0, 0),\n-        random_ints: Duration::new(0, 0),\n-        delete_ints: Duration::new(0, 0),\n-\n-        sequential_strings: Duration::new(0, 0),\n-        random_strings: Duration::new(0, 0),\n-        delete_strings: Duration::new(0, 0),\n-    }\n-}\n-\n-fn main() {\n-    let mut args = env::args();\n-    let num_keys = {\n-        if args.len() == 2 {\n-            args.nth(1).unwrap().parse::<usize>().unwrap()\n-        } else {\n-            100 // woefully inadequate for any real measurement\n-        }\n-    };\n-\n-    let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    let max = 200000;\n-\n-    {\n-        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n-        let mut results = empty_results();\n-        results.bench_int(&mut rng, num_keys, max, || {\n-            let s: HashSet<usize> = HashSet::new();\n-            s\n-        });\n-        results.bench_str(&mut rng, num_keys, || {\n-            let s: HashSet<String> = HashSet::new();\n-            s\n-        });\n-        write_results(\"collections::HashSet\", &results);\n-    }\n-\n-    {\n-        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n-        let mut results = empty_results();\n-        results.bench_int(&mut rng, num_keys, max, || {\n-            let s: BTreeSet<usize> = BTreeSet::new();\n-            s\n-        });\n-        results.bench_str(&mut rng, num_keys, || {\n-            let s: BTreeSet<String> = BTreeSet::new();\n-            s\n-        });\n-        write_results(\"collections::BTreeSet\", &results);\n-    }\n-}"}, {"sha": "26fb3630487f26d1e5c3d7c90702d0626e4fc523", "filename": "src/test/bench/core-std.rs", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,140 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Microbenchmarks for various functions in std and extra\n-\n-#![feature(rand, vec_push_all, duration, duration_span)]\n-\n-use std::mem::swap;\n-use std::env;\n-use std::__rand::{thread_rng, Rng};\n-use std::str;\n-use std::time::Duration;\n-\n-fn main() {\n-    let argv: Vec<String> = env::args().collect();\n-\n-    macro_rules! bench {\n-        ($id:ident) =>\n-            (maybe_run_test(&argv,\n-                            stringify!($id).to_string(),\n-                            $id))\n-    }\n-\n-    bench!(shift_push);\n-    bench!(vec_plus);\n-    bench!(vec_append);\n-    bench!(vec_push_all);\n-    bench!(is_utf8_ascii);\n-    bench!(is_utf8_multibyte);\n-}\n-\n-fn maybe_run_test<F>(argv: &[String], name: String, test: F) where F: FnOnce() {\n-    let mut run_test = false;\n-\n-    if env::var_os(\"RUST_BENCH\").is_some() {\n-        run_test = true\n-    } else if !argv.is_empty() {\n-        run_test = argv.iter().any(|x| x == &\"all\".to_string()) || argv.iter().any(|x| x == &name)\n-    }\n-\n-    if !run_test {\n-        return\n-    }\n-\n-    let dur = Duration::span(test);\n-\n-    println!(\"{}:\\t\\t{:?}\", name, dur);\n-}\n-\n-fn shift_push() {\n-    let mut v1 = vec![1; 30000];\n-    let mut v2 = Vec::new();\n-\n-    while !v1.is_empty() {\n-        v2.push(v1.remove(0));\n-    }\n-}\n-\n-fn vec_plus() {\n-    let mut r = thread_rng();\n-\n-    let mut v = Vec::new();\n-    let mut i = 0;\n-    while i < 1500 {\n-        let rv = vec![i; r.gen_range(0, i + 1)];\n-        if r.gen() {\n-            v.extend(rv);\n-        } else {\n-            let mut rv = rv.clone();\n-            rv.push_all(&v);\n-            v = rv;\n-        }\n-        i += 1;\n-    }\n-}\n-\n-fn vec_append() {\n-    let mut r = thread_rng();\n-\n-    let mut v = Vec::new();\n-    let mut i = 0;\n-    while i < 1500 {\n-        let rv = vec![i; r.gen_range(0, i + 1)];\n-        if r.gen() {\n-            let mut t = v.clone();\n-            t.push_all(&rv);\n-            v = t;\n-        }\n-        else {\n-            let mut t = rv.clone();\n-            t.push_all(&v);\n-            v = t;\n-        }\n-        i += 1;\n-    }\n-}\n-\n-fn vec_push_all() {\n-    let mut r = thread_rng();\n-\n-    let mut v = Vec::new();\n-    for i in 0..1500 {\n-        let mut rv = vec![i; r.gen_range(0, i + 1)];\n-        if r.gen() {\n-            v.push_all(&rv);\n-        }\n-        else {\n-            swap(&mut v, &mut rv);\n-            v.push_all(&rv);\n-        }\n-    }\n-}\n-\n-fn is_utf8_ascii() {\n-    let mut v : Vec<u8> = Vec::new();\n-    for _ in 0..20000 {\n-        v.push('b' as u8);\n-        if str::from_utf8(&v).is_err() {\n-            panic!(\"from_utf8 panicked\");\n-        }\n-    }\n-}\n-\n-fn is_utf8_multibyte() {\n-    let s = \"b\u00a2\u20ac\ud852\udf62\";\n-    let mut v : Vec<u8> = Vec::new();\n-    for _ in 0..5000 {\n-        v.push_all(s.as_bytes());\n-        if str::from_utf8(&v).is_err() {\n-            panic!(\"from_utf8 panicked\");\n-        }\n-    }\n-}"}, {"sha": "287958f43fb8deee3a67f735b7ce081313136ebd", "filename": "src/test/bench/core-uint-to-str.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::env;\n-\n-fn main() {\n-    let args = env::args();\n-    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"10000000\".to_string())\n-    } else if args.len() <= 1 {\n-        vec!(\"\".to_string(), \"100000\".to_string())\n-    } else {\n-        args.collect()\n-    };\n-\n-    let n = args[1].parse().unwrap();\n-\n-    for i in 0..n {\n-        let x = i.to_string();\n-        println!(\"{}\", x);\n-    }\n-}"}, {"sha": "b210f5ac26ae0ea97b79e8f14dbb189d0b42d55c", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,109 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// A port of the simplistic benchmark from\n-//\n-//    http://github.com/PaulKeeble/ScalaVErlangAgents\n-//\n-// I *think* it's the same, more or less.\n-\n-// This version uses pipes with a shared send endpoint. It should have\n-// different scalability characteristics compared to the select\n-// version.\n-\n-#![feature(duration, duration_span)]\n-\n-use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::env;\n-use std::thread;\n-use std::time::Duration;\n-\n-fn move_out<T>(_x: T) {}\n-\n-enum request {\n-    get_count,\n-    bytes(usize),\n-    stop\n-}\n-\n-fn server(requests: &Receiver<request>, responses: &Sender<usize>) {\n-    let mut count = 0;\n-    let mut done = false;\n-    while !done {\n-        match requests.recv() {\n-          Ok(request::get_count) => { responses.send(count.clone()).unwrap(); }\n-          Ok(request::bytes(b)) => {\n-            //println!(\"server: received {} bytes\", b);\n-            count += b;\n-          }\n-          Err(..) => { done = true; }\n-          _ => { }\n-        }\n-    }\n-    responses.send(count).unwrap();\n-    //println!(\"server exiting\");\n-}\n-\n-fn run(args: &[String]) {\n-    let (to_parent, from_child) = channel();\n-    let (to_child, from_parent) = channel();\n-\n-    let size = args[1].parse::<usize>().unwrap();\n-    let workers = args[2].parse::<usize>().unwrap();\n-    let num_bytes = 100;\n-    let mut result = None;\n-    let mut p = Some((to_child, to_parent, from_parent));\n-    let dur = Duration::span(|| {\n-        let (to_child, to_parent, from_parent) = p.take().unwrap();\n-        let mut worker_results = Vec::new();\n-        for _ in 0..workers {\n-            let to_child = to_child.clone();\n-            worker_results.push(thread::spawn(move|| {\n-                for _ in 0..size / workers {\n-                    //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n-                    to_child.send(request::bytes(num_bytes)).unwrap();\n-                }\n-                //println!(\"worker {} exiting\", i);\n-            }));\n-        }\n-        thread::spawn(move|| {\n-            server(&from_parent, &to_parent);\n-        });\n-\n-        for r in worker_results {\n-            let _ = r.join();\n-        }\n-\n-        //println!(\"sending stop message\");\n-        to_child.send(request::stop).unwrap();\n-        move_out(to_child);\n-        result = Some(from_child.recv().unwrap());\n-    });\n-    let result = result.unwrap();\n-    print!(\"Count is {}\\n\", result);\n-    print!(\"Test took {:?}\\n\", dur);\n-    let thruput = ((size / workers * workers) as f64) / (dur.as_secs() as f64);\n-    print!(\"Throughput={} per sec\\n\", thruput);\n-    assert_eq!(result, num_bytes * size);\n-}\n-\n-fn main() {\n-    let args = env::args();\n-    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"1000000\".to_string(), \"10000\".to_string())\n-    } else if args.len() <= 1 {\n-        vec!(\"\".to_string(), \"10000\".to_string(), \"4\".to_string())\n-    } else {\n-        args.map(|x| x.to_string()).collect()\n-    };\n-\n-    println!(\"{:?}\", args);\n-    run(&args);\n-}"}, {"sha": "056905f1ef691b24e44e32f691ff55792baf5f3a", "filename": "src/test/bench/msgsend-pipes.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,116 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// A port of the simplistic benchmark from\n-//\n-//    http://github.com/PaulKeeble/ScalaVErlangAgents\n-//\n-// I *think* it's the same, more or less.\n-\n-#![feature(duration, duration_span)]\n-\n-use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::env;\n-use std::thread;\n-use std::time::Duration;\n-\n-enum request {\n-    get_count,\n-    bytes(usize),\n-    stop\n-}\n-\n-fn server(requests: &Receiver<request>, responses: &Sender<usize>) {\n-    let mut count: usize = 0;\n-    let mut done = false;\n-    while !done {\n-        match requests.recv() {\n-          Ok(request::get_count) => { responses.send(count.clone()); }\n-          Ok(request::bytes(b)) => {\n-            //println!(\"server: received {} bytes\", b);\n-            count += b;\n-          }\n-          Err(..) => { done = true; }\n-          _ => { }\n-        }\n-    }\n-    responses.send(count).unwrap();\n-    //println!(\"server exiting\");\n-}\n-\n-fn run(args: &[String]) {\n-    let (to_parent, from_child) = channel();\n-\n-    let size = args[1].parse::<usize>().unwrap();\n-    let workers = args[2].parse::<usize>().unwrap();\n-    let num_bytes = 100;\n-    let mut result = None;\n-    let mut to_parent = Some(to_parent);\n-    let dur = Duration::span(|| {\n-        let to_parent = to_parent.take().unwrap();\n-        let mut worker_results = Vec::new();\n-        let from_parent = if workers == 1 {\n-            let (to_child, from_parent) = channel();\n-            worker_results.push(thread::spawn(move|| {\n-                for _ in 0..size / workers {\n-                    //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n-                    to_child.send(request::bytes(num_bytes));\n-                }\n-                //println!(\"worker {} exiting\", i);\n-            }));\n-            from_parent\n-        } else {\n-            let (to_child, from_parent) = channel();\n-            for _ in 0..workers {\n-                let to_child = to_child.clone();\n-                worker_results.push(thread::spawn(move|| {\n-                    for _ in 0..size / workers {\n-                        //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n-                        to_child.send(request::bytes(num_bytes));\n-                    }\n-                    //println!(\"worker {} exiting\", i);\n-                }));\n-            }\n-            from_parent\n-        };\n-        thread::spawn(move|| {\n-            server(&from_parent, &to_parent);\n-        });\n-\n-        for r in worker_results {\n-            let _ = r.join();\n-        }\n-\n-        //println!(\"sending stop message\");\n-        //to_child.send(stop);\n-        //move_out(to_child);\n-        result = Some(from_child.recv().unwrap());\n-    });\n-    let result = result.unwrap();\n-    print!(\"Count is {}\\n\", result);\n-    print!(\"Test took {:?}\\n\", dur);\n-    let thruput = ((size / workers * workers) as f64) / (dur.as_secs() as f64);\n-    print!(\"Throughput={} per sec\\n\", thruput);\n-    assert_eq!(result, num_bytes * size);\n-}\n-\n-fn main() {\n-    let args = env::args();\n-    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"1000000\".to_string(), \"8\".to_string())\n-    } else if args.len() <= 1 {\n-        vec!(\"\".to_string(), \"10000\".to_string(), \"4\".to_string())\n-    } else {\n-        args.map(|x| x.to_string()).collect()\n-    };\n-\n-    println!(\"{:?}\", args);\n-    run(&args);\n-}"}, {"sha": "843f49d8f0534a900559c7d94dfab1a17f4db347", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,116 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This test creates a bunch of threads that simultaneously send to each\n-// other in a ring. The messages should all be basically\n-// independent.\n-// This is like msgsend-ring-pipes but adapted to use Arcs.\n-\n-// This also serves as a pipes test, because Arcs are implemented with pipes.\n-\n-// no-pretty-expanded FIXME #15189\n-\n-#![feature(duration_span)]\n-\n-use std::env;\n-use std::sync::{Arc, Mutex, Condvar};\n-use std::time::Duration;\n-use std::thread;\n-\n-// A poor man's pipe.\n-type pipe = Arc<(Mutex<Vec<usize>>, Condvar)>;\n-\n-fn send(p: &pipe, msg: usize) {\n-    let &(ref lock, ref cond) = &**p;\n-    let mut arr = lock.lock().unwrap();\n-    arr.push(msg);\n-    cond.notify_one();\n-}\n-fn recv(p: &pipe) -> usize {\n-    let &(ref lock, ref cond) = &**p;\n-    let mut arr = lock.lock().unwrap();\n-    while arr.is_empty() {\n-        arr = cond.wait(arr).unwrap();\n-    }\n-    arr.pop().unwrap()\n-}\n-\n-fn init() -> (pipe,pipe) {\n-    let m = Arc::new((Mutex::new(Vec::new()), Condvar::new()));\n-    ((&m).clone(), m)\n-}\n-\n-\n-fn thread_ring(i: usize, count: usize, num_chan: pipe, num_port: pipe) {\n-    let mut num_chan = Some(num_chan);\n-    let mut num_port = Some(num_port);\n-    // Send/Receive lots of messages.\n-    for j in 0..count {\n-        //println!(\"thread %?, iter %?\", i, j);\n-        let num_chan2 = num_chan.take().unwrap();\n-        let num_port2 = num_port.take().unwrap();\n-        send(&num_chan2, i * j);\n-        num_chan = Some(num_chan2);\n-        let _n = recv(&num_port2);\n-        //log(error, _n);\n-        num_port = Some(num_port2);\n-    };\n-}\n-\n-fn main() {\n-    let args = env::args();\n-    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"100\".to_string(), \"10000\".to_string())\n-    } else if args.len() <= 1 {\n-        vec!(\"\".to_string(), \"10\".to_string(), \"100\".to_string())\n-    } else {\n-        args.collect()\n-    };\n-\n-    let num_tasks = args[1].parse::<usize>().unwrap();\n-    let msg_per_task = args[2].parse::<usize>().unwrap();\n-\n-    let (num_chan, num_port) = init();\n-\n-    let mut p = Some((num_chan, num_port));\n-    let dur = Duration::span(|| {\n-        let (mut num_chan, num_port) = p.take().unwrap();\n-\n-        // create the ring\n-        let mut futures = Vec::new();\n-\n-        for i in 1..num_tasks {\n-            //println!(\"spawning %?\", i);\n-            let (new_chan, num_port) = init();\n-            let num_chan_2 = num_chan.clone();\n-            let new_future = thread::spawn(move|| {\n-                thread_ring(i, msg_per_task, num_chan_2, num_port)\n-            });\n-            futures.push(new_future);\n-            num_chan = new_chan;\n-        };\n-\n-        // do our iteration\n-        thread_ring(0, msg_per_task, num_chan, num_port);\n-\n-        // synchronize\n-        for f in futures {\n-            f.join().unwrap()\n-        }\n-    });\n-\n-    // all done, report stats.\n-    let num_msgs = num_tasks * msg_per_task;\n-    let rate = (num_msgs as f64) / (dur.as_secs() as f64);\n-\n-    println!(\"Sent {} messages in {:?}\", num_msgs, dur);\n-    println!(\"  {} messages / second\", rate);\n-    println!(\"  {} \u03bcs / message\", 1000000. / rate);\n-}"}, {"sha": "81a6fb8ff6debbe064207a60c21b646d9973d258", "filename": "src/test/bench/noise.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,123 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Multi-language Perlin noise benchmark.\n-// See https://github.com/nsf/pnoise for timings and alternative implementations.\n-\n-#![feature(rand, core)]\n-\n-use std::f32::consts::PI;\n-use std::__rand::{Rng, thread_rng};\n-\n-#[derive(Copy, Clone)]\n-struct Vec2 {\n-    x: f32,\n-    y: f32,\n-}\n-\n-fn lerp(a: f32, b: f32, v: f32) -> f32 { a * (1.0 - v) + b * v }\n-\n-fn smooth(v: f32) -> f32 { v * v * (3.0 - 2.0 * v) }\n-\n-fn random_gradient<R: Rng>(r: &mut R) -> Vec2 {\n-    let v = PI * 2.0 * r.gen::<f32>();\n-    Vec2 { x: v.cos(), y: v.sin() }\n-}\n-\n-fn gradient(orig: Vec2, grad: Vec2, p: Vec2) -> f32 {\n-    (p.x - orig.x) * grad.x + (p.y - orig.y) * grad.y\n-}\n-\n-struct Noise2DContext {\n-    rgradients: [Vec2; 256],\n-    permutations: [i32; 256],\n-}\n-\n-impl Noise2DContext {\n-    fn new() -> Noise2DContext {\n-        let mut rng = thread_rng();\n-\n-        let mut rgradients = [Vec2 { x: 0.0, y: 0.0 }; 256];\n-        for x in &mut rgradients[..] {\n-            *x = random_gradient(&mut rng);\n-        }\n-\n-        let mut permutations = [0; 256];\n-        for (i, x) in permutations.iter_mut().enumerate() {\n-            *x = i as i32;\n-        }\n-        rng.shuffle(&mut permutations);\n-\n-        Noise2DContext { rgradients: rgradients, permutations: permutations }\n-    }\n-\n-    fn get_gradient(&self, x: i32, y: i32) -> Vec2 {\n-        let idx = self.permutations[(x & 255) as usize] +\n-                    self.permutations[(y & 255) as usize];\n-        self.rgradients[(idx & 255) as usize]\n-    }\n-\n-    fn get_gradients(&self, x: f32, y: f32) -> ([Vec2; 4], [Vec2; 4]) {\n-        let x0f = x.floor();\n-        let y0f = y.floor();\n-        let x1f = x0f + 1.0;\n-        let y1f = y0f + 1.0;\n-\n-        let x0 = x0f as i32;\n-        let y0 = y0f as i32;\n-        let x1 = x0 + 1;\n-        let y1 = y0 + 1;\n-\n-        ([self.get_gradient(x0, y0), self.get_gradient(x1, y0),\n-          self.get_gradient(x0, y1), self.get_gradient(x1, y1)],\n-         [Vec2 { x: x0f, y: y0f }, Vec2 { x: x1f, y: y0f },\n-          Vec2 { x: x0f, y: y1f }, Vec2 { x: x1f, y: y1f }])\n-    }\n-\n-    fn get(&self, x: f32, y: f32) -> f32 {\n-        let p = Vec2 {x: x, y: y};\n-        let (gradients, origins) = self.get_gradients(x, y);\n-\n-        let v0 = gradient(origins[0], gradients[0], p);\n-        let v1 = gradient(origins[1], gradients[1], p);\n-        let v2 = gradient(origins[2], gradients[2], p);\n-        let v3 = gradient(origins[3], gradients[3], p);\n-\n-        let fx = smooth(x - origins[0].x);\n-        let vx0 = lerp(v0, v1, fx);\n-        let vx1 = lerp(v2, v3, fx);\n-        let fy = smooth(y - origins[0].y);\n-\n-        lerp(vx0, vx1, fy)\n-    }\n-}\n-\n-fn main() {\n-    let symbols = [' ', '\u2591', '\u2592', '\u2593', '\u2588', '\u2588'];\n-    let mut pixels = Box::new([0f32; 256*256]);\n-    let n2d = Box::new(Noise2DContext::new());\n-\n-    for _ in 0..100 {\n-        for y in 0..256 {\n-            for x in 0..256 {\n-                let v = n2d.get(x as f32 * 0.1, y as f32 * 0.1);\n-                pixels[y*256+x] = v * 0.5 + 0.5;\n-            }\n-        }\n-    }\n-\n-    for y in 0..256 {\n-        for x in 0..256 {\n-            let idx = (pixels[y*256+x] / 0.2) as usize;\n-            print!(\"{}\", symbols[idx]);\n-        }\n-        print!(\"\\n\");\n-    }\n-}"}, {"sha": "9be13101aa8a1d108d30de13c6c704eec1665d69", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::sync::mpsc::channel;\n-use std::env;\n-use std::thread;\n-\n-// This is a simple bench that creates M pairs of threads. These\n-// threads ping-pong back and forth over a pair of streams. This is a\n-// canonical message-passing benchmark as it heavily strains message\n-// passing and almost nothing else.\n-\n-fn ping_pong_bench(n: usize, m: usize) {\n-\n-    // Create pairs of threads that pingpong back and forth.\n-    fn run_pair(n: usize) {\n-        // Create a channel: A->B\n-        let (atx, arx) = channel();\n-        // Create a channel: B->A\n-        let (btx, brx) = channel();\n-\n-        let guard_a = thread::spawn(move|| {\n-            let (tx, rx) = (atx, brx);\n-            for _ in 0..n {\n-                tx.send(()).unwrap();\n-                rx.recv().unwrap();\n-            }\n-        });\n-\n-        let guard_b = thread::spawn(move|| {\n-            let (tx, rx) = (btx, arx);\n-            for _ in 0..n {\n-                rx.recv().unwrap();\n-                tx.send(()).unwrap();\n-            }\n-        });\n-\n-        guard_a.join().ok();\n-        guard_b.join().ok();\n-    }\n-\n-    for _ in 0..m {\n-        run_pair(n)\n-    }\n-}\n-\n-\n-\n-fn main() {\n-    let mut args = env::args();\n-    let (n, m) = if args.len() == 3 {\n-        let n = args.nth(1).unwrap().parse::<usize>().unwrap();\n-        let m = args.next().unwrap().parse::<usize>().unwrap();\n-        (n, m)\n-    } else {\n-        (10000, 4)\n-    };\n-\n-    ping_pong_bench(n, m);\n-\n-}"}, {"sha": "2c5c0ea27c7603b02d1e2020177014b80b9aebe2", "filename": "src/test/bench/rt-parfib.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::sync::mpsc::channel;\n-use std::env;\n-use std::thread;\n-\n-// A simple implementation of parfib. One subtree is found in a new\n-// thread and communicated over a oneshot pipe, the other is found\n-// locally. There is no sequential-mode threshold.\n-\n-fn parfib(n: u64) -> u64 {\n-    if n == 0 || n == 1 {\n-        return 1;\n-    }\n-\n-    let (tx, rx) = channel();\n-    thread::spawn(move|| {\n-        tx.send(parfib(n-1)).unwrap();\n-    });\n-    let m2 = parfib(n-2);\n-    return rx.recv().unwrap() + m2;\n-}\n-\n-fn main() {\n-    let mut args = env::args();\n-    let n = if args.len() == 2 {\n-        args.nth(1).unwrap().parse::<u64>().unwrap()\n-    } else {\n-        10\n-    };\n-\n-    parfib(n);\n-\n-}"}, {"sha": "d07aa8850aa8306c4ca22d200db5d3a385a3d7e2", "filename": "src/test/bench/shootout-ackermann.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::env;\n-\n-fn ack(m: i64, n: i64) -> i64 {\n-    if m == 0 {\n-        return n + 1\n-    } else {\n-        if n == 0 {\n-            return ack(m - 1, 1);\n-        } else {\n-            return ack(m - 1, ack(m, n - 1));\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let mut args = env::args();\n-    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"12\".to_string())\n-    } else if args.len() <= 1 {\n-        vec!(\"\".to_string(), \"8\".to_string())\n-    } else {\n-        args.collect()\n-    };\n-    let n = args[1].parse().unwrap();\n-    println!(\"Ack(3,{}): {}\\n\", n, ack(3, n));\n-}"}, {"sha": "c576eea3602cb6b95669ac88c29ba6564d4f92c2", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,122 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2012-2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-#![feature(rustc_private, core, step_by)]\n-\n-extern crate arena;\n-\n-use std::thread;\n-use arena::TypedArena;\n-\n-struct Tree<'a> {\n-    l: Option<&'a Tree<'a>>,\n-    r: Option<&'a Tree<'a>>,\n-    i: i32\n-}\n-\n-fn item_check(t: &Option<&Tree>) -> i32 {\n-    match *t {\n-        None => 0,\n-        Some(&Tree { ref l, ref r, i }) => i + item_check(l) - item_check(r)\n-    }\n-}\n-\n-fn bottom_up_tree<'r>(arena: &'r TypedArena<Tree<'r>>, item: i32, depth: i32)\n-                  -> Option<&'r Tree<'r>> {\n-    if depth > 0 {\n-        let t: &Tree<'r> = arena.alloc(Tree {\n-            l: bottom_up_tree(arena, 2 * item - 1, depth - 1),\n-            r: bottom_up_tree(arena, 2 * item, depth - 1),\n-            i: item\n-        });\n-        Some(t)\n-    } else {\n-        None\n-    }\n-}\n-\n-fn inner(depth: i32, iterations: i32) -> String {\n-    let mut chk = 0;\n-    for i in 1 .. iterations + 1 {\n-        let arena = TypedArena::new();\n-        let a = bottom_up_tree(&arena, i, depth);\n-        let b = bottom_up_tree(&arena, -i, depth);\n-        chk += item_check(&a) + item_check(&b);\n-    }\n-    format!(\"{}\\t trees of depth {}\\t check: {}\",\n-            iterations * 2, depth, chk)\n-}\n-\n-fn main() {\n-    let mut args = std::env::args();\n-    let n = if std::env::var_os(\"RUST_BENCH\").is_some() {\n-        17\n-    } else if args.len() <= 1 {\n-        8\n-    } else {\n-        args.nth(1).unwrap().parse().unwrap()\n-    };\n-    let min_depth = 4;\n-    let max_depth = if min_depth + 2 > n {min_depth + 2} else {n};\n-\n-    {\n-        let arena = TypedArena::new();\n-        let depth = max_depth + 1;\n-        let tree = bottom_up_tree(&arena, 0, depth);\n-\n-        println!(\"stretch tree of depth {}\\t check: {}\",\n-                 depth, item_check(&tree));\n-    }\n-\n-    let long_lived_arena = TypedArena::new();\n-    let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n-\n-    let messages = (min_depth..max_depth + 1).step_by(2).map(|depth| {\n-        let iterations = 2i32.pow((max_depth - depth + min_depth) as u32);\n-        thread::spawn(move || inner(depth, iterations))\n-    }).collect::<Vec<_>>();\n-\n-    for message in messages {\n-        println!(\"{}\", message.join().unwrap());\n-    }\n-\n-    println!(\"long lived tree of depth {}\\t check: {}\",\n-             max_depth, item_check(&long_lived_tree));\n-}"}, {"sha": "72f3464cdb72d165d101cc5460845ac6bfda880d", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,246 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2012-2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-// no-pretty-expanded\n-\n-use self::Color::{Red, Yellow, Blue};\n-use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::fmt;\n-use std::thread;\n-\n-fn print_complements() {\n-    let all = [Blue, Red, Yellow];\n-    for aa in &all {\n-        for bb in &all {\n-            println!(\"{:?} + {:?} -> {:?}\", *aa, *bb, transform(*aa, *bb));\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-enum Color {\n-    Red,\n-    Yellow,\n-    Blue,\n-}\n-\n-impl fmt::Debug for Color {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let str = match *self {\n-            Red => \"red\",\n-            Yellow => \"yellow\",\n-            Blue => \"blue\",\n-        };\n-        write!(f, \"{}\", str)\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-struct CreatureInfo {\n-    name: usize,\n-    color: Color\n-}\n-\n-fn show_color_list(set: Vec<Color>) -> String {\n-    let mut out = String::new();\n-    for col in &set {\n-        out.push(' ');\n-        out.push_str(&format!(\"{:?}\", col));\n-    }\n-    out\n-}\n-\n-fn show_digit(nn: usize) -> &'static str {\n-    match nn {\n-        0 => {\" zero\"}\n-        1 => {\" one\"}\n-        2 => {\" two\"}\n-        3 => {\" three\"}\n-        4 => {\" four\"}\n-        5 => {\" five\"}\n-        6 => {\" six\"}\n-        7 => {\" seven\"}\n-        8 => {\" eight\"}\n-        9 => {\" nine\"}\n-        _ => {panic!(\"expected digits from 0 to 9...\")}\n-    }\n-}\n-\n-struct Number(usize);\n-impl fmt::Debug for Number {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let mut out = vec![];\n-        let Number(mut num) = *self;\n-        if num == 0 { out.push(show_digit(0)) };\n-\n-        while num != 0 {\n-            let dig = num % 10;\n-            num = num / 10;\n-            let s = show_digit(dig);\n-            out.push(s);\n-        }\n-\n-        for s in out.iter().rev() {\n-            try!(write!(f, \"{}\", s))\n-        }\n-        Ok(())\n-    }\n-}\n-\n-fn transform(aa: Color, bb: Color) -> Color {\n-    match (aa, bb) {\n-        (Red,    Red   ) => { Red    }\n-        (Red,    Yellow) => { Blue   }\n-        (Red,    Blue  ) => { Yellow }\n-        (Yellow, Red   ) => { Blue   }\n-        (Yellow, Yellow) => { Yellow }\n-        (Yellow, Blue  ) => { Red    }\n-        (Blue,   Red   ) => { Yellow }\n-        (Blue,   Yellow) => { Red    }\n-        (Blue,   Blue  ) => { Blue   }\n-    }\n-}\n-\n-fn creature(\n-    name: usize,\n-    mut color: Color,\n-    from_rendezvous: Receiver<CreatureInfo>,\n-    to_rendezvous: Sender<CreatureInfo>,\n-    to_rendezvous_log: Sender<String>\n-) {\n-    let mut creatures_met = 0;\n-    let mut evil_clones_met = 0;\n-    let mut rendezvous = from_rendezvous.iter();\n-\n-    loop {\n-        // ask for a pairing\n-        to_rendezvous.send(CreatureInfo {name: name, color: color}).unwrap();\n-\n-        // log and change, or quit\n-        match rendezvous.next() {\n-            Some(other_creature) => {\n-                color = transform(color, other_creature.color);\n-\n-                // track some statistics\n-                creatures_met += 1;\n-                if other_creature.name == name {\n-                   evil_clones_met += 1;\n-                }\n-            }\n-            None => break\n-        }\n-    }\n-    // log creatures met and evil clones of self\n-    let report = format!(\"{}{:?}\", creatures_met, Number(evil_clones_met));\n-    to_rendezvous_log.send(report).unwrap();\n-}\n-\n-fn rendezvous(nn: usize, set: Vec<Color>) {\n-    // these ports will allow us to hear from the creatures\n-    let (to_rendezvous, from_creatures) = channel::<CreatureInfo>();\n-\n-    // these channels will be passed to the creatures so they can talk to us\n-    let (to_rendezvous_log, from_creatures_log) = channel::<String>();\n-\n-    // these channels will allow us to talk to each creature by 'name'/index\n-    let to_creature: Vec<Sender<CreatureInfo>> =\n-        set.iter().enumerate().map(|(ii, &col)| {\n-            // create each creature as a listener with a port, and\n-            // give us a channel to talk to each\n-            let to_rendezvous = to_rendezvous.clone();\n-            let to_rendezvous_log = to_rendezvous_log.clone();\n-            let (to_creature, from_rendezvous) = channel();\n-            thread::spawn(move|| {\n-                creature(ii,\n-                         col,\n-                         from_rendezvous,\n-                         to_rendezvous,\n-                         to_rendezvous_log);\n-            });\n-            to_creature\n-        }).collect();\n-\n-    let mut creatures_met = 0;\n-\n-    // set up meetings...\n-    for _ in 0..nn {\n-        let fst_creature = from_creatures.recv().unwrap();\n-        let snd_creature = from_creatures.recv().unwrap();\n-\n-        creatures_met += 2;\n-\n-        to_creature[fst_creature.name].send(snd_creature).unwrap();\n-        to_creature[snd_creature.name].send(fst_creature).unwrap();\n-    }\n-\n-    // tell each creature to stop\n-    drop(to_creature);\n-\n-    // print each color in the set\n-    println!(\"{}\", show_color_list(set));\n-\n-    // print each creature's stats\n-    drop(to_rendezvous_log);\n-    for rep in from_creatures_log.iter() {\n-        println!(\"{}\", rep);\n-    }\n-\n-    // print the total number of creatures met\n-    println!(\"{:?}\\n\", Number(creatures_met));\n-}\n-\n-fn main() {\n-    let nn = if std::env::var_os(\"RUST_BENCH\").is_some() {\n-        200000\n-    } else {\n-        std::env::args()\n-                       .nth(1)\n-                       .and_then(|arg| arg.parse().ok())\n-                       .unwrap_or(600)\n-    };\n-\n-    print_complements();\n-    println!(\"\");\n-\n-    rendezvous(nn, vec!(Blue, Red, Yellow));\n-\n-    rendezvous(nn,\n-        vec!(Blue, Red, Yellow, Red, Yellow, Blue, Red, Yellow, Red, Blue));\n-}"}, {"sha": "3bc1782bd0c9e0ecf5e7bcb95f8ebb77f8dc37fc", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,192 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-#![feature(step_by)]\n-\n-use std::{cmp, mem};\n-use std::thread;\n-\n-fn rotate(x: &mut [i32]) {\n-    let mut prev = x[0];\n-    for place in x.iter_mut().rev() {\n-        prev = mem::replace(place, prev)\n-    }\n-}\n-\n-fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n-    for i in 1..perm.len() {\n-        rotate(&mut perm[..i + 1]);\n-        let count_i = &mut count[i];\n-        if *count_i >= i as i32 {\n-            *count_i = 0;\n-        } else {\n-            *count_i += 1;\n-            break\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-struct P {\n-    p: [i32; 16],\n-}\n-\n-#[derive(Copy, Clone)]\n-struct Perm {\n-    cnt: [i32; 16],\n-    fact: [u32; 16],\n-    n: u32,\n-    permcount: u32,\n-    perm: P,\n-}\n-\n-impl Perm {\n-    fn new(n: u32) -> Perm {\n-        let mut fact = [1; 16];\n-        for i in 1..n as usize + 1 {\n-            fact[i] = fact[i - 1] * i as u32;\n-        }\n-        Perm {\n-            cnt: [0; 16],\n-            fact: fact,\n-            n: n,\n-            permcount: 0,\n-            perm: P { p: [0; 16 ] }\n-        }\n-    }\n-\n-    fn get(&mut self, mut idx: i32) -> P {\n-        let mut pp = [0; 16];\n-        self.permcount = idx as u32;\n-        for (i, place) in self.perm.p.iter_mut().enumerate() {\n-            *place = i as i32 + 1;\n-        }\n-\n-        for i in (1..self.n as usize).rev() {\n-            let d = idx / self.fact[i] as i32;\n-            self.cnt[i] = d;\n-            idx %= self.fact[i] as i32;\n-            for (place, val) in pp.iter_mut().zip(&self.perm.p[..i+1]) {\n-                *place = (*val) as u8\n-            }\n-\n-            let d = d as usize;\n-            for j in 0..i + 1 {\n-                self.perm.p[j] = if j + d <= i {pp[j + d]} else {pp[j+d-i-1]} as i32;\n-            }\n-        }\n-\n-        self.perm\n-    }\n-\n-    fn count(&self) -> u32 { self.permcount }\n-    fn max(&self) -> u32 { self.fact[self.n as usize] }\n-\n-    fn next(&mut self) -> P {\n-        next_permutation(&mut self.perm.p, &mut self.cnt);\n-        self.permcount += 1;\n-\n-        self.perm\n-    }\n-}\n-\n-\n-fn reverse(tperm: &mut [i32], k: usize) {\n-    tperm[..k].reverse()\n-}\n-\n-fn work(mut perm: Perm, n: usize, max: usize) -> (i32, i32) {\n-    let mut checksum = 0;\n-    let mut maxflips = 0;\n-\n-    let mut p = perm.get(n as i32);\n-\n-    while perm.count() < max as u32 {\n-        let mut flips = 0;\n-\n-        while p.p[0] != 1 {\n-            let k = p.p[0] as usize;\n-            reverse(&mut p.p, k);\n-            flips += 1;\n-        }\n-\n-        checksum += if perm.count() % 2 == 0 {flips} else {-flips};\n-        maxflips = cmp::max(maxflips, flips);\n-\n-        p = perm.next();\n-    }\n-\n-    (checksum, maxflips)\n-}\n-\n-fn fannkuch(n: i32) -> (i32, i32) {\n-    let perm = Perm::new(n as u32);\n-\n-    let N = 4;\n-    let mut futures = vec![];\n-    let k = perm.max() / N;\n-\n-    for (_, j) in (0..N).zip((0..).step_by(k)) {\n-        let max = cmp::min(j+k, perm.max());\n-\n-        futures.push(thread::spawn(move|| {\n-            work(perm, j as usize, max as usize)\n-        }))\n-    }\n-\n-    let mut checksum = 0;\n-    let mut maxflips = 0;\n-    for fut in futures {\n-        let (cs, mf) = fut.join().unwrap();\n-        checksum += cs;\n-        maxflips = cmp::max(maxflips, mf);\n-    }\n-    (checksum, maxflips)\n-}\n-\n-fn main() {\n-    let n = std::env::args()\n-        .nth(1)\n-        .and_then(|arg| arg.parse().ok())\n-        .unwrap_or(2);\n-\n-    let (checksum, maxflips) = fannkuch(n);\n-    println!(\"{}\\nPfannkuchen({}) = {}\", checksum, n, maxflips);\n-}"}, {"sha": "6d64c50b826b58c9cfc8f616b9f426af1b13a7b0", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "removed", "additions": 0, "deletions": 376, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,376 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2013-2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-use std::cmp::min;\n-use std::io::{self, Write};\n-use std::sync::{Arc, Mutex};\n-use std::thread;\n-\n-\n-const LINE_LEN: usize = 60;\n-\n-const BLOCK_LINES: usize = 512;\n-const BLOCK_THOROUGHPUT: usize = LINE_LEN * BLOCK_LINES;\n-const BLOCK_LEN: usize = BLOCK_THOROUGHPUT + BLOCK_LINES;\n-\n-const STDIN_BUF: usize = (LINE_LEN + 1) * 1024;\n-const LOOKUP_SIZE: usize = 4 * 1024;\n-const LOOKUP_SCALE: f32 = (LOOKUP_SIZE - 1) as f32;\n-\n-const ALU: &'static [u8] =\n-    b\"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\\\n-      GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\\\n-      CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\\\n-      ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\\\n-      GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\\\n-      AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\\\n-      AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n-\n-const IUB: &'static [(u8, f32)] =\n-    &[(b'a', 0.27), (b'c', 0.12), (b'g', 0.12),\n-      (b't', 0.27), (b'B', 0.02), (b'D', 0.02),\n-      (b'H', 0.02), (b'K', 0.02), (b'M', 0.02),\n-      (b'N', 0.02), (b'R', 0.02), (b'S', 0.02),\n-      (b'V', 0.02), (b'W', 0.02), (b'Y', 0.02)];\n-\n-const HOMOSAPIENS: &'static [(u8, f32)] =\n-    &[(b'a', 0.3029549426680),\n-      (b'c', 0.1979883004921),\n-      (b'g', 0.1975473066391),\n-      (b't', 0.3015094502008)];\n-\n-// We need a specific Rng,\n-// so implement this manually\n-\n-const MODULUS: u32 = 139968;\n-const MULTIPLIER: u32 = 3877;\n-const ADDITIVE: u32 = 29573;\n-\n-// Why doesn't rust already have this?\n-// Algorithm directly taken from Wikipedia\n-fn powmod(mut base: u64, mut exponent: u32, modulus: u64) -> u64 {\n-    let mut ret = 1;\n-    base %= modulus;\n-\n-    while exponent > 0 {\n-        if exponent & 1 == 1 {\n-           ret *= base;\n-           ret %= modulus;\n-        }\n-        exponent >>= 1;\n-        base *= base;\n-        base %= modulus;\n-    }\n-\n-    ret\n-}\n-\n-// Just a typical LCRNG\n-pub struct Rng {\n-    last: u32\n-}\n-\n-impl Rng {\n-    pub fn new() -> Rng {\n-        Rng { last: 42 }\n-    }\n-\n-    pub fn max_value() -> u32 {\n-        MODULUS - 1\n-    }\n-\n-    pub fn normalize(p: f32) -> u32 {\n-        (p * MODULUS as f32).floor() as u32\n-    }\n-\n-    pub fn gen(&mut self) -> u32 {\n-        self.last = (self.last * MULTIPLIER + ADDITIVE) % MODULUS;\n-        self.last\n-    }\n-\n-    // This allows us to fast-forward the RNG,\n-    // allowing us to run it in parallel.\n-    pub fn future(&self, n: u32) -> Rng {\n-        let a = MULTIPLIER as u64;\n-        let b = ADDITIVE as u64;\n-        let m = MODULUS as u64;\n-\n-        //                          (a^n - 1) mod (a-1) m\n-        // x_k = ((a^n x_0 mod m) + --------------------- b) mod m\n-        //                                   a - 1\n-        //\n-        // Since (a - 1) divides (a^n - 1) mod (a-1) m,\n-        // the subtraction does not overflow and thus can be non-modular.\n-        //\n-        let new_seed =\n-            (powmod(a, n, m) * self.last as u64) % m +\n-            (powmod(a, n, (a-1) * m) - 1) / (a-1) * b;\n-\n-        Rng { last: (new_seed % m) as u32 }\n-    }\n-}\n-\n-\n-// This will end up keeping track of threads, like\n-// in the other multithreaded Rust version, in\n-// order to keep writes in order.\n-//\n-// This is stolen from another multithreaded Rust\n-// implementation, although that implementation\n-// was not able to parallelize the RNG itself.\n-struct BlockSubmitter<W: io::Write> {\n-    writer: W,\n-    pub waiting_on: usize,\n-}\n-\n-impl<W: io::Write> BlockSubmitter<W> {\n-    fn submit(&mut self, data: &[u8], block_num: usize) -> Option<io::Result<()>> {\n-        if block_num == self.waiting_on {\n-            self.waiting_on += 1;\n-            Some(self.submit_async(data))\n-        }\n-        else {\n-            None\n-        }\n-    }\n-\n-    fn submit_async(&mut self, data: &[u8]) -> io::Result<()> {\n-        self.writer.write_all(data)\n-    }\n-}\n-\n-\n-// For repeating strings as output\n-fn fasta_static<W: io::Write>(\n-    writer: &mut W,\n-    header: &[u8],\n-    data: &[u8],\n-    mut n: usize\n-) -> io::Result<()>\n-{\n-    // The aim here is to print a short(ish) string cyclically\n-    // with line breaks as appropriate.\n-    //\n-    // The secret technique is to repeat the string such that\n-    // any wanted line is a single offset in the string.\n-    //\n-    // This technique is stolen from the Haskell version.\n-\n-    try!(writer.write_all(header));\n-\n-    // Maximum offset is data.len(),\n-    // Maximum read len is LINE_LEN\n-    let stream = data.iter().cloned().cycle();\n-    let mut extended: Vec<u8> = stream.take(data.len() + LINE_LEN + 1).collect();\n-\n-    let mut offset = 0;\n-    while n > 0 {\n-        let write_len = min(LINE_LEN, n);\n-        let end = offset + write_len;\n-        n -= write_len;\n-\n-        let tmp = extended[end];\n-        extended[end] = b'\\n';\n-        try!(writer.write_all(&extended[offset..end + 1]));\n-        extended[end] = tmp;\n-\n-        offset = end;\n-        offset %= data.len();\n-    }\n-\n-    Ok(())\n-}\n-\n-\n-// For RNG streams as output\n-fn fasta<W: io::Write + Send + 'static>(\n-    submitter: &Arc<Mutex<BlockSubmitter<W>>>,\n-    header: &[u8],\n-    table: &'static [(u8, f32)],\n-    rng: &mut Rng,\n-    n: usize\n-) -> io::Result<()>\n-{\n-    // Here the lookup table is part of the algorithm and needs the\n-    // original probabilities (scaled with the LOOKUP_SCALE), because\n-    // Isaac says so :-)\n-    fn sum_and_scale(a: &'static [(u8, f32)]) -> Vec<(u8, f32)> {\n-        let mut p = 0f32;\n-        let mut result: Vec<(u8, f32)> = a.iter().map(|e| {\n-            p += e.1;\n-            (e.0, p * LOOKUP_SCALE)\n-        }).collect();\n-        let result_len = result.len();\n-        result[result_len - 1].1 = LOOKUP_SCALE;\n-        result\n-    }\n-\n-    fn make_lookup(a: &[(u8, f32)]) -> [(u8, f32); LOOKUP_SIZE] {\n-        let mut lookup = [(0, 0f32); LOOKUP_SIZE];\n-        let mut j = 0;\n-        for (i, slot) in lookup.iter_mut().enumerate() {\n-            while a[j].1 < (i as f32) {\n-                j += 1;\n-            }\n-            *slot = a[j];\n-        }\n-        lookup\n-    }\n-\n-    {\n-        try!(submitter.lock().unwrap().submit_async(header));\n-    }\n-\n-    let lookup_table = Arc::new(make_lookup(&sum_and_scale(table)));\n-\n-    let thread_count = 4;\n-    let mut threads = Vec::new();\n-    for block_num in (0..thread_count) {\n-        let offset = BLOCK_THOROUGHPUT * block_num;\n-\n-        let local_submitter = submitter.clone();\n-        let local_lookup_table = lookup_table.clone();\n-        let local_rng = rng.future(offset as u32);\n-\n-        threads.push(thread::spawn(move || {\n-            gen_block(\n-                local_submitter,\n-                local_lookup_table,\n-                local_rng,\n-                n.saturating_sub(offset),\n-                block_num,\n-                thread_count\n-            )\n-        }));\n-    }\n-\n-    for thread in threads {\n-        try!(thread.join().unwrap());\n-    }\n-\n-    *rng = rng.future(n as u32);\n-\n-    Ok(())\n-}\n-\n-// A very optimized writer.\n-// I have a feeling a simpler version wouldn't slow\n-// things down too much, though, since the RNG\n-// is the really heavy hitter.\n-fn gen_block<W: io::Write>(\n-    submitter: Arc<Mutex<BlockSubmitter<W>>>,\n-    lookup_table: Arc<[(u8, f32)]>,\n-    mut rng: Rng,\n-    mut length: usize,\n-    mut block_num: usize,\n-    block_stride: usize,\n-) -> io::Result<()>\n-{\n-    // Include newlines in block\n-    length += length / LINE_LEN;\n-    let block: &mut [u8] = &mut [b'\\n'; BLOCK_LEN];\n-\n-    while length > 0 {\n-        {\n-            let gen_into = &mut block[..min(length, BLOCK_LEN)];\n-\n-            // Write random numbers, skipping newlines\n-            for (i, byte) in gen_into.iter_mut().enumerate() {\n-                if (i + 1) % (LINE_LEN + 1) != 0 {\n-                    let p = rng.gen() as f32 * (LOOKUP_SCALE / MODULUS as f32);\n-                    *byte = lookup_table[p as usize..LOOKUP_SIZE].iter().find(\n-                        |le| le.1 >= p).unwrap().0;\n-                }\n-            }\n-        }\n-\n-        let write_out = {\n-            if length >= BLOCK_LEN               { &mut *block }\n-            else if length % (LINE_LEN + 1) == 0 { &mut block[..length] }\n-            else                                 { &mut block[..length + 1] }\n-        };\n-\n-        *write_out.last_mut().unwrap() = b'\\n';\n-        loop {\n-            // Make sure to release lock before calling `yield_now`\n-            let res = { submitter.lock().unwrap().submit(write_out, block_num) };\n-\n-            match res {\n-                Some(result) => { try!(result); break; }\n-                None => std::thread::yield_now()\n-            }\n-        }\n-        block_num += block_stride;\n-        rng = rng.future((BLOCK_THOROUGHPUT * (block_stride - 1)) as u32);\n-        length = length.saturating_sub(BLOCK_LEN * (block_stride - 1));\n-\n-        length = length.saturating_sub(BLOCK_LEN);\n-    }\n-\n-    Ok(())\n-}\n-\n-fn run<W: io::Write + Send + 'static>(writer: W) -> io::Result<()> {\n-    let n = std::env::args_os().nth(1)\n-        .and_then(|s| s.into_string().ok())\n-        .and_then(|n| n.parse().ok())\n-        .unwrap_or(1000);\n-\n-    let rng = &mut Rng::new();\n-\n-    // Use automatic buffering for the static version...\n-    let mut writer = io::BufWriter::with_capacity(STDIN_BUF, writer);\n-    try!(fasta_static(&mut writer, b\">ONE Homo sapiens alu\\n\", ALU, n * 2));\n-\n-    // ...but the dynamic version does its own buffering already\n-    let writer = try!(writer.into_inner());\n-    let submitter = Arc::new(Mutex::new(BlockSubmitter { writer: writer, waiting_on: 0 }));\n-\n-    { submitter.lock().unwrap().waiting_on = 0; }\n-    try!(fasta(&submitter, b\">TWO IUB ambiguity codes\\n\", &IUB, rng, n * 3));\n-    { submitter.lock().unwrap().waiting_on = 0; }\n-    try!(fasta(&submitter, b\">THREE Homo sapiens frequency\\n\", &HOMOSAPIENS, rng, n * 5));\n-\n-    Ok(())\n-}\n-\n-fn main() {\n-    run(io::stdout()).unwrap()\n-}"}, {"sha": "a5731f150c6d024c6ef78cc3daccd02521e1c9b3", "filename": "src/test/bench/shootout-fasta.rs", "status": "removed", "additions": 0, "deletions": 370, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,370 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2012-2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-use std::cmp::min;\n-use std::io::{self, Write};\n-use std::sync::{Arc, Mutex};\n-use std::thread;\n-\n-\n-const LINE_LEN: usize = 60;\n-\n-const BLOCK_LINES: usize = 512;\n-const BLOCK_THOROUGHPUT: usize = LINE_LEN * BLOCK_LINES;\n-const BLOCK_LEN: usize = BLOCK_THOROUGHPUT + BLOCK_LINES;\n-\n-const STDIN_BUF: usize = (LINE_LEN + 1) * 1024;\n-\n-\n-const ALU: &'static [u8] =\n-    b\"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\\\n-      GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\\\n-      CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\\\n-      ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\\\n-      GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\\\n-      AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\\\n-      AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n-\n-const IUB: &'static [(u8, f32)] =\n-    &[(b'a', 0.27), (b'c', 0.12), (b'g', 0.12),\n-      (b't', 0.27), (b'B', 0.02), (b'D', 0.02),\n-      (b'H', 0.02), (b'K', 0.02), (b'M', 0.02),\n-      (b'N', 0.02), (b'R', 0.02), (b'S', 0.02),\n-      (b'V', 0.02), (b'W', 0.02), (b'Y', 0.02)];\n-\n-const HOMOSAPIENS: &'static [(u8, f32)] =\n-    &[(b'a', 0.3029549426680),\n-      (b'c', 0.1979883004921),\n-      (b'g', 0.1975473066391),\n-      (b't', 0.3015094502008)];\n-\n-\n-// We need a specific Rng,\n-// so implement this manually\n-const MODULUS: u32 = 139968;\n-const MULTIPLIER: u32 = 3877;\n-const ADDITIVE: u32 = 29573;\n-\n-// Why doesn't rust already have this?\n-// Algorithm directly taken from Wikipedia\n-fn powmod(mut base: u64, mut exponent: u32, modulus: u64) -> u64 {\n-    let mut ret = 1;\n-    base %= modulus;\n-\n-    while exponent > 0 {\n-        if exponent & 1 == 1 {\n-           ret *= base;\n-           ret %= modulus;\n-        }\n-        exponent >>= 1;\n-        base *= base;\n-        base %= modulus;\n-    }\n-\n-    ret\n-}\n-\n-// Just a typical LCRNG\n-pub struct Rng {\n-    last: u32\n-}\n-\n-impl Rng {\n-    pub fn new() -> Rng {\n-        Rng { last: 42 }\n-    }\n-\n-    pub fn max_value() -> u32 {\n-        MODULUS - 1\n-    }\n-\n-    pub fn normalize(p: f32) -> u32 {\n-        (p * MODULUS as f32).floor() as u32\n-    }\n-\n-    pub fn gen(&mut self) -> u32 {\n-        self.last = (self.last * MULTIPLIER + ADDITIVE) % MODULUS;\n-        self.last\n-    }\n-\n-    // This allows us to fast-forward the RNG,\n-    // allowing us to run it in parallel.\n-    pub fn future(&self, n: u32) -> Rng {\n-        let a = MULTIPLIER as u64;\n-        let b = ADDITIVE as u64;\n-        let m = MODULUS as u64;\n-\n-        //                          (a^n - 1) mod (a-1) m\n-        // x_k = ((a^n x_0 mod m) + --------------------- b) mod m\n-        //                                   a - 1\n-        //\n-        // Since (a - 1) divides (a^n - 1) mod (a-1) m,\n-        // the subtraction does not overflow and thus can be non-modular.\n-        //\n-        let new_seed =\n-            (powmod(a, n, m) * self.last as u64) % m +\n-            (powmod(a, n, (a-1) * m) - 1) / (a-1) * b;\n-\n-        Rng { last: (new_seed % m) as u32 }\n-    }\n-}\n-\n-\n-// This will end up keeping track of threads, like\n-// in the other multithreaded Rust version, in\n-// order to keep writes in order.\n-//\n-// This is stolen from another multithreaded Rust\n-// implementation, although that implementation\n-// was not able to parallelize the RNG itself.\n-struct BlockSubmitter<W: io::Write> {\n-    writer: W,\n-    pub waiting_on: usize,\n-}\n-\n-impl<W: io::Write> BlockSubmitter<W> {\n-    fn submit(&mut self, data: &[u8], block_num: usize) -> Option<io::Result<()>> {\n-        if block_num == self.waiting_on {\n-            self.waiting_on += 1;\n-            Some(self.submit_async(data))\n-        }\n-        else {\n-            None\n-        }\n-    }\n-\n-    fn submit_async(&mut self, data: &[u8]) -> io::Result<()> {\n-        self.writer.write_all(data)\n-    }\n-}\n-\n-\n-// For repeating strings as output\n-fn fasta_static<W: io::Write>(\n-    writer: &mut W,\n-    header: &[u8],\n-    data: &[u8],\n-    mut n: usize\n-) -> io::Result<()>\n-{\n-    // The aim here is to print a short(ish) string cyclically\n-    // with line breaks as appropriate.\n-    //\n-    // The secret technique is to repeat the string such that\n-    // any wanted line is a single offset in the string.\n-    //\n-    // This technique is stolen from the Haskell version.\n-\n-    try!(writer.write_all(header));\n-\n-    // Maximum offset is data.len(),\n-    // Maximum read len is LINE_LEN\n-    let stream = data.iter().cloned().cycle();\n-    let mut extended: Vec<u8> = stream.take(data.len() + LINE_LEN + 1).collect();\n-\n-    let mut offset = 0;\n-    while n > 0 {\n-        let write_len = min(LINE_LEN, n);\n-        let end = offset + write_len;\n-        n -= write_len;\n-\n-        let tmp = extended[end];\n-        extended[end] = b'\\n';\n-        try!(writer.write_all(&extended[offset..end + 1]));\n-        extended[end] = tmp;\n-\n-        offset = end;\n-        offset %= data.len();\n-    }\n-\n-    Ok(())\n-}\n-\n-\n-// For RNG streams as output\n-fn fasta<W: io::Write + Send + 'static>(\n-    submitter: &Arc<Mutex<BlockSubmitter<W>>>,\n-    header: &[u8],\n-    table: &[(u8, f32)],\n-    rng: &mut Rng,\n-    n: usize\n-) -> io::Result<()>\n-{\n-    // There's another secret technique in use here:\n-    // we generate a lookup table to cache search of the\n-    // aa buffer.\n-    //\n-    // The secret technique used is stolen from Haskell's\n-    // implementation, and is the main secret to the Haskell\n-    // implementation's  speed.\n-    fn gen_lookup_table(aa: &[(u8, f32)]) -> Vec<u8> {\n-        let mut table = Vec::with_capacity(Rng::max_value() as usize + 1);\n-\n-        let mut cumulative_prob = 0.0;\n-        let mut cumulative_norm = 0;\n-\n-        for &(byte, prob) in aa {\n-            let last_norm = cumulative_norm;\n-            cumulative_prob += prob;\n-            cumulative_norm = min(Rng::max_value(), Rng::normalize(cumulative_prob)) + 1;\n-\n-            table.extend((0..cumulative_norm - last_norm).map(|_| byte));\n-        }\n-\n-        table\n-    }\n-\n-    {\n-        try!(submitter.lock().unwrap().submit_async(header));\n-    }\n-\n-    let lookup_table = Arc::new(gen_lookup_table(table));\n-\n-    let thread_count = 4; // avoid external dependency\n-    let mut threads = Vec::new();\n-    for block_num in (0..thread_count) {\n-        let offset = BLOCK_THOROUGHPUT * block_num;\n-\n-        let local_submitter = submitter.clone();\n-        let local_lookup_table = lookup_table.clone();\n-        let local_rng = rng.future(offset as u32);\n-\n-        threads.push(thread::spawn(move || {\n-            gen_block(\n-                local_submitter,\n-                local_lookup_table,\n-                local_rng,\n-                n.saturating_sub(offset),\n-                block_num,\n-                thread_count\n-            )\n-        }));\n-    }\n-\n-    for thread in threads {\n-        try!(thread.join().unwrap());\n-    }\n-\n-    *rng = rng.future(n as u32);\n-\n-    Ok(())\n-}\n-\n-// A very optimized writer.\n-// I have a feeling a simpler version wouldn't slow\n-// things down too much, though, since the RNG\n-// is the really heavy hitter.\n-fn gen_block<W: io::Write>(\n-    submitter: Arc<Mutex<BlockSubmitter<W>>>,\n-    lookup_table: Arc<Vec<u8>>,\n-    mut rng: Rng,\n-    mut length: usize,\n-    mut block_num: usize,\n-    block_stride: usize,\n-) -> io::Result<()>\n-{\n-    // Include newlines in block\n-    length += length / LINE_LEN;\n-    let block: &mut [u8] = &mut [b'\\n'; BLOCK_LEN];\n-\n-    while length > 0 {\n-        {\n-            let gen_into = &mut block[..min(length, BLOCK_LEN)];\n-\n-            // Write random numbers, skipping newlines\n-            for (i, byte) in gen_into.iter_mut().enumerate() {\n-                if (i + 1) % (LINE_LEN + 1) != 0 {\n-                    *byte = lookup_table[rng.gen() as usize];\n-                }\n-            }\n-        }\n-\n-        let write_out = {\n-            if length >= BLOCK_LEN               { &mut *block }\n-            else if length % (LINE_LEN + 1) == 0 { &mut block[..length] }\n-            else                                 { &mut block[..length + 1] }\n-        };\n-\n-        *write_out.last_mut().unwrap() = b'\\n';\n-        loop {\n-            match submitter.lock().unwrap().submit(write_out, block_num) {\n-                Some(result) => { try!(result); break; }\n-                None => std::thread::yield_now()\n-            }\n-        }\n-        block_num += block_stride;\n-        rng = rng.future((BLOCK_THOROUGHPUT * (block_stride - 1)) as u32);\n-        length = length.saturating_sub(BLOCK_LEN * (block_stride - 1));\n-\n-        length = length.saturating_sub(BLOCK_LEN);\n-    }\n-\n-    Ok(())\n-}\n-\n-\n-fn run<W: io::Write + Send + 'static>(writer: W) -> io::Result<()> {\n-    let n = std::env::args_os().nth(1)\n-        .and_then(|s| s.into_string().ok())\n-        .and_then(|n| n.parse().ok())\n-        .unwrap_or(1000);\n-\n-    let rng = &mut Rng::new();\n-\n-    // Use automatic buffering for the static version...\n-    let mut writer = io::BufWriter::with_capacity(STDIN_BUF, writer);\n-    try!(fasta_static(&mut writer, b\">ONE Homo sapiens alu\\n\", ALU, n * 2));\n-\n-    // ...but the dynamic version does its own buffering already\n-    let writer = try!(writer.into_inner());\n-    let submitter = Arc::new(Mutex::new(BlockSubmitter { writer: writer, waiting_on: 0 }));\n-\n-    { submitter.lock().unwrap().waiting_on = 0; }\n-    try!(fasta(&submitter, b\">TWO IUB ambiguity codes\\n\", &IUB, rng, n * 3));\n-    { submitter.lock().unwrap().waiting_on = 0; }\n-    try!(fasta(&submitter, b\">THREE Homo sapiens frequency\\n\", &HOMOSAPIENS, rng, n * 5));\n-\n-    Ok(())\n-}\n-\n-\n-fn main() {\n-    run(io::stdout()).unwrap()\n-}"}, {"sha": "6f9c775609af5ee6a3fd03d484140fb9753420fc", "filename": "src/test/bench/shootout-fibo.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::env;\n-\n-fn fib(n: i64) -> i64 {\n-    if n < 2 {\n-        return 1;\n-    } else {\n-        return fib(n - 1) + fib(n - 2);\n-    }\n-}\n-\n-fn main() {\n-    let args = env::args();\n-    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"40\".to_string())\n-    } else if args.len() <= 1 {\n-        vec!(\"\".to_string(), \"30\".to_string())\n-    } else {\n-        args.collect()\n-    };\n-    let n = args[1].parse().unwrap();\n-    println!(\"{}\\n\", fib(n));\n-}"}, {"sha": "b4e5ca201492a0d3600c5ee0f0cd65b3cfae0588", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "removed", "additions": 0, "deletions": 224, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,224 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-android: FIXME(#10393) hangs without output\n-// ignore-pretty very bad with line comments\n-\n-// multi threading k-nucleotide\n-\n-use std::ascii::AsciiExt;\n-use std::cmp::Ordering::{self, Less, Greater, Equal};\n-use std::collections::HashMap;\n-use std::mem::replace;\n-use std::env;\n-use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::thread;\n-use std::io;\n-use std::io::prelude::*;\n-\n-fn f64_cmp(x: f64, y: f64) -> Ordering {\n-    // arbitrarily decide that NaNs are larger than everything.\n-    if y.is_nan() {\n-        Less\n-    } else if x.is_nan() {\n-        Greater\n-    } else if x < y {\n-        Less\n-    } else if x == y {\n-        Equal\n-    } else {\n-        Greater\n-    }\n-}\n-\n-// given a map, print a sorted version of it\n-fn sort_and_fmt(mm: &HashMap<Vec<u8> , usize>, total: usize) -> String {\n-   fn pct(xx: usize, yy: usize) -> f64 {\n-      return (xx as f64) * 100.0 / (yy as f64);\n-   }\n-\n-   // sort by key, then by value\n-   fn sort_kv(mut orig: Vec<(Vec<u8> ,f64)> ) -> Vec<(Vec<u8> ,f64)> {\n-        orig.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n-        orig.sort_by(|&(_, a), &(_, b)| f64_cmp(b, a));\n-        orig\n-   }\n-\n-   let mut pairs = Vec::new();\n-\n-   // map -> [(k,%)]\n-   for (key, &val) in mm {\n-      pairs.push(((*key).clone(), pct(val, total)));\n-   }\n-\n-   let pairs_sorted = sort_kv(pairs);\n-\n-   let mut buffer = String::new();\n-   for &(ref k, v) in &pairs_sorted {\n-       buffer.push_str(&format!(\"{:?} {:0.3}\\n\",\n-                                k.to_ascii_uppercase(),\n-                                v));\n-   }\n-\n-   return buffer\n-}\n-\n-// given a map, search for the frequency of a pattern\n-fn find(mm: &HashMap<Vec<u8> , usize>, key: String) -> usize {\n-   let key = key.to_ascii_lowercase();\n-   match mm.get(key.as_bytes()) {\n-      None => 0,\n-      Some(&num) => num,\n-   }\n-}\n-\n-// given a map, increment the counter for a key\n-fn update_freq(mm: &mut HashMap<Vec<u8> , usize>, key: &[u8]) {\n-    let key = key.to_vec();\n-    let newval = match mm.remove(&key) {\n-        Some(v) => v + 1,\n-        None => 1\n-    };\n-    mm.insert(key, newval);\n-}\n-\n-// given a Vec<u8>, for each window call a function\n-// i.e., for \"hello\" and windows of size four,\n-// run it(\"hell\") and it(\"ello\"), then return \"llo\"\n-fn windows_with_carry<F>(bb: &[u8], nn: usize, mut it: F) -> Vec<u8> where\n-    F: FnMut(&[u8]),\n-{\n-   let mut ii = 0;\n-\n-   let len = bb.len();\n-   while ii < len - (nn - 1) {\n-      it(&bb[ii..ii+nn]);\n-      ii += 1;\n-   }\n-\n-   return bb[len - (nn - 1)..len].to_vec();\n-}\n-\n-fn make_sequence_processor(sz: usize,\n-                           from_parent: &Receiver<Vec<u8>>,\n-                           to_parent: &Sender<String>) {\n-   let mut freqs: HashMap<Vec<u8>, usize> = HashMap::new();\n-   let mut carry = Vec::new();\n-   let mut total: usize = 0;\n-\n-   let mut line: Vec<u8>;\n-\n-   loop {\n-\n-       line = from_parent.recv().unwrap();\n-       if line == Vec::new() { break; }\n-\n-       carry.extend(line);\n-       carry = windows_with_carry(&carry, sz, |window| {\n-           update_freq(&mut freqs, window);\n-           total += 1;\n-       });\n-   }\n-\n-   let buffer = match sz {\n-       1 => { sort_and_fmt(&freqs, total) }\n-       2 => { sort_and_fmt(&freqs, total) }\n-       3 => { format!(\"{}\\t{}\", find(&freqs, \"GGT\".to_string()), \"GGT\") }\n-       4 => { format!(\"{}\\t{}\", find(&freqs, \"GGTA\".to_string()), \"GGTA\") }\n-       6 => { format!(\"{}\\t{}\", find(&freqs, \"GGTATT\".to_string()), \"GGTATT\") }\n-      12 => { format!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATT\".to_string()), \"GGTATTTTAATT\") }\n-      18 => { format!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATTTATAGT\".to_string()),\n-                       \"GGTATTTTAATTTATAGT\") }\n-       _ => { \"\".to_string() }\n-   };\n-\n-    to_parent.send(buffer).unwrap();\n-}\n-\n-// given a FASTA file on stdin, process sequence THREE\n-fn main() {\n-    let input = io::stdin();\n-    let rdr = if env::var_os(\"RUST_BENCH\").is_some() {\n-        let foo: &[u8] = include_bytes!(\"shootout-k-nucleotide.data\");\n-        Box::new(foo) as Box<BufRead>\n-    } else {\n-        Box::new(input.lock()) as Box<BufRead>\n-    };\n-\n-    // initialize each sequence sorter\n-    let sizes: Vec<usize> = vec!(1,2,3,4,6,12,18);\n-    let mut streams = (0..sizes.len()).map(|_| {\n-        Some(channel::<String>())\n-    }).collect::<Vec<_>>();\n-    let mut from_child = Vec::new();\n-    let to_child  = sizes.iter().zip(&mut streams).map(|(sz, stream_ref)| {\n-        let sz = *sz;\n-        let stream = replace(stream_ref, None);\n-        let (to_parent_, from_child_) = stream.unwrap();\n-\n-        from_child.push(from_child_);\n-\n-        let (to_child, from_parent) = channel();\n-\n-        thread::spawn(move|| {\n-            make_sequence_processor(sz, &from_parent, &to_parent_);\n-        });\n-\n-        to_child\n-    }).collect::<Vec<Sender<Vec<u8>>>>();\n-\n-\n-   // latch stores true after we've started\n-   // reading the sequence of interest\n-   let mut proc_mode = false;\n-\n-   for line in rdr.lines() {\n-       let line = line.unwrap().trim().to_string();\n-\n-       if line.is_empty() { continue; }\n-\n-       match (line.as_bytes()[0] as char, proc_mode) {\n-\n-           // start processing if this is the one\n-           ('>', false) => {\n-               match line[1..].find(\"THREE\") {\n-                   Some(_) => { proc_mode = true; }\n-                   None    => { }\n-               }\n-           }\n-\n-           // break our processing\n-           ('>', true) => { break; }\n-\n-           // process the sequence for k-mers\n-           (_, true) => {\n-               let line_bytes = line.as_bytes();\n-\n-               for (ii, _sz) in sizes.iter().enumerate() {\n-                   let lb = line_bytes.to_vec();\n-                   to_child[ii].send(lb).unwrap();\n-               }\n-           }\n-\n-           // whatever\n-           _ => { }\n-       }\n-   }\n-\n-   // finish...\n-   for (ii, _sz) in sizes.iter().enumerate() {\n-       to_child[ii].send(Vec::new()).unwrap();\n-   }\n-\n-   // now fetch and print result messages\n-   for (ii, _sz) in sizes.iter().enumerate() {\n-       println!(\"{:?}\", from_child[ii].recv().unwrap());\n-   }\n-}"}, {"sha": "9ba8f4861d2f97b655229469dd57deb792995881", "filename": "src/test/bench/shootout-k-nucleotide.data", "status": "removed", "additions": 0, "deletions": 83337, "changes": 83337, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.data", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.data?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99"}, {"sha": "175ab5badb639099986b3ddab861ea1c05db94be", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "removed", "additions": 0, "deletions": 324, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,324 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-// ignore-android: FIXME(#10393) hangs without output\n-\n-use std::ascii::AsciiExt;\n-use std::env;\n-use std::fs::File;\n-use std::io::prelude::*;\n-use std::io;\n-use std::slice;\n-use std::sync::Arc;\n-use std::thread;\n-\n-static TABLE: [u8;4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n-static TABLE_SIZE: usize = 2 << 16;\n-\n-static OCCURRENCES: [&'static str;5] = [\n-    \"GGT\",\n-    \"GGTA\",\n-    \"GGTATT\",\n-    \"GGTATTTTAATT\",\n-    \"GGTATTTTAATTTATAGT\",\n-];\n-\n-// Code implementation\n-\n-#[derive(Copy, Clone, PartialEq, PartialOrd, Ord, Eq)]\n-struct Code(u64);\n-\n-impl Code {\n-    fn hash(&self) -> u64 {\n-        let Code(ret) = *self;\n-        return ret;\n-    }\n-\n-    fn push_char(&self, c: u8) -> Code {\n-        Code((self.hash() << 2) + (pack_symbol(c) as u64))\n-    }\n-\n-    fn rotate(&self, c: u8, frame: usize) -> Code {\n-        Code(self.push_char(c).hash() & ((1 << (2 * frame)) - 1))\n-    }\n-\n-    fn pack(string: &str) -> Code {\n-        string.bytes().fold(Code(0), |a, b| a.push_char(b))\n-    }\n-\n-    fn unpack(&self, frame: usize) -> String {\n-        let mut key = self.hash();\n-        let mut result = Vec::new();\n-        for _ in 0..frame {\n-            result.push(unpack_symbol((key as u8) & 3));\n-            key >>= 2;\n-        }\n-\n-        result.reverse();\n-        String::from_utf8(result).unwrap()\n-    }\n-}\n-\n-// Hash table implementation\n-\n-trait TableCallback {\n-    fn f(&self, entry: &mut Entry);\n-}\n-\n-struct BumpCallback;\n-\n-impl TableCallback for BumpCallback {\n-    fn f(&self, entry: &mut Entry) {\n-        entry.count += 1;\n-    }\n-}\n-\n-struct PrintCallback(&'static str);\n-\n-impl TableCallback for PrintCallback {\n-    fn f(&self, entry: &mut Entry) {\n-        let PrintCallback(s) = *self;\n-        println!(\"{}\\t{}\", entry.count, s);\n-    }\n-}\n-\n-struct Entry {\n-    code: Code,\n-    count: usize,\n-    next: Option<Box<Entry>>,\n-}\n-\n-struct Table {\n-    items: Vec<Option<Box<Entry>>>\n-}\n-\n-struct Items<'a> {\n-    cur: Option<&'a Entry>,\n-    items: slice::Iter<'a, Option<Box<Entry>>>,\n-}\n-\n-impl Table {\n-    fn new() -> Table {\n-        Table {\n-            items: (0..TABLE_SIZE).map(|_| None).collect()\n-        }\n-    }\n-\n-    fn search_remainder<C:TableCallback>(item: &mut Entry, key: Code, c: C) {\n-        match item.next {\n-            None => {\n-                let mut entry = Box::new(Entry {\n-                    code: key,\n-                    count: 0,\n-                    next: None,\n-                });\n-                c.f(&mut *entry);\n-                item.next = Some(entry);\n-            }\n-            Some(ref mut entry) => {\n-                if entry.code == key {\n-                    c.f(&mut **entry);\n-                    return;\n-                }\n-\n-                Table::search_remainder(&mut **entry, key, c)\n-            }\n-        }\n-    }\n-\n-    fn lookup<C:TableCallback>(&mut self, key: Code, c: C) {\n-        let index = key.hash() % (TABLE_SIZE as u64);\n-\n-        {\n-            if self.items[index as usize].is_none() {\n-                let mut entry = Box::new(Entry {\n-                    code: key,\n-                    count: 0,\n-                    next: None,\n-                });\n-                c.f(&mut *entry);\n-                self.items[index as usize] = Some(entry);\n-                return;\n-            }\n-        }\n-\n-        {\n-            let entry = self.items[index as usize].as_mut().unwrap();\n-            if entry.code == key {\n-                c.f(&mut **entry);\n-                return;\n-            }\n-\n-            Table::search_remainder(&mut **entry, key, c)\n-        }\n-    }\n-\n-    fn iter(&self) -> Items {\n-        Items { cur: None, items: self.items.iter() }\n-    }\n-}\n-\n-impl<'a> Iterator for Items<'a> {\n-    type Item = &'a Entry;\n-\n-    fn next(&mut self) -> Option<&'a Entry> {\n-        let ret = match self.cur {\n-            None => {\n-                let i;\n-                loop {\n-                    match self.items.next() {\n-                        None => return None,\n-                        Some(&None) => {}\n-                        Some(&Some(ref a)) => { i = &**a; break }\n-                    }\n-                }\n-                self.cur = Some(&*i);\n-                &*i\n-            }\n-            Some(c) => c\n-        };\n-        match ret.next {\n-            None => { self.cur = None; }\n-            Some(ref next) => { self.cur = Some(&**next); }\n-        }\n-        return Some(ret);\n-    }\n-}\n-\n-// Main program\n-\n-fn pack_symbol(c: u8) -> u8 {\n-    match c as char {\n-        'A' => 0,\n-        'C' => 1,\n-        'G' => 2,\n-        'T' => 3,\n-        _ => panic!(\"{}\", c as char),\n-    }\n-}\n-\n-fn unpack_symbol(c: u8) -> u8 {\n-    TABLE[c as usize]\n-}\n-\n-fn generate_frequencies(mut input: &[u8], frame: usize) -> Table {\n-    let mut frequencies = Table::new();\n-    if input.len() < frame { return frequencies; }\n-    let mut code = Code(0);\n-\n-    // Pull first frame.\n-    for _ in 0..frame {\n-        code = code.push_char(input[0]);\n-        input = &input[1..];\n-    }\n-    frequencies.lookup(code, BumpCallback);\n-\n-    while !input.is_empty() && input[0] != ('>' as u8) {\n-        code = code.rotate(input[0], frame);\n-        frequencies.lookup(code, BumpCallback);\n-        input = &input[1..];\n-    }\n-    frequencies\n-}\n-\n-fn print_frequencies(frequencies: &Table, frame: usize) {\n-    let mut vector = Vec::new();\n-    for entry in frequencies.iter() {\n-        vector.push((entry.count, entry.code));\n-    }\n-    vector.sort();\n-\n-    let mut total_count = 0;\n-    for &(count, _) in &vector {\n-        total_count += count;\n-    }\n-\n-    for &(count, key) in vector.iter().rev() {\n-        println!(\"{} {:.3}\",\n-                 key.unpack(frame),\n-                 (count as f32 * 100.0) / (total_count as f32));\n-    }\n-    println!(\"\");\n-}\n-\n-fn print_occurrences(frequencies: &mut Table, occurrence: &'static str) {\n-    frequencies.lookup(Code::pack(occurrence), PrintCallback(occurrence))\n-}\n-\n-fn get_sequence<R: BufRead>(r: &mut R, key: &str) -> Vec<u8> {\n-    let mut res = Vec::<u8>::new();\n-    for l in r.lines().map(|l| l.unwrap())\n-        .skip_while(|l| key != &l[..key.len()]).skip(1)\n-    {\n-        res.extend(l.trim().as_bytes());\n-    }\n-    for s in &mut res {\n-        *s = s.to_ascii_uppercase();\n-    }\n-    return res\n-}\n-\n-fn main() {\n-    let input = if env::var_os(\"RUST_BENCH\").is_some() {\n-        let f = File::open(\"shootout-k-nucleotide.data\").unwrap();\n-        get_sequence(&mut io::BufReader::new(f), \">THREE\")\n-    } else {\n-        let stdin = io::stdin();\n-        let mut stdin = stdin.lock();\n-        get_sequence(&mut stdin, \">THREE\")\n-    };\n-    let input = Arc::new(input);\n-\n-    let nb_freqs: Vec<_> = (1..3).map(|i| {\n-        let input = input.clone();\n-        (i, thread::spawn(move|| generate_frequencies(&input, i)))\n-    }).collect();\n-    let occ_freqs: Vec<_> = OCCURRENCES.iter().map(|&occ| {\n-        let input = input.clone();\n-        thread::spawn(move|| generate_frequencies(&input, occ.len()))\n-    }).collect();\n-\n-    for (i, freq) in nb_freqs {\n-        print_frequencies(&freq.join().unwrap(), i);\n-    }\n-    for (&occ, freq) in OCCURRENCES.iter().zip(occ_freqs) {\n-        print_occurrences(&mut freq.join().unwrap(), occ);\n-    }\n-}"}, {"sha": "331d83b535a0cfae57b51d03fea9e8bac61462c7", "filename": "src/test/bench/shootout-meteor.rs", "status": "removed", "additions": 0, "deletions": 343, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,343 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2013-2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-// no-pretty-expanded FIXME #15189\n-\n-#![feature(iter_cmp)]\n-\n-use std::sync::Arc;\n-use std::sync::mpsc::channel;\n-use std::thread;\n-\n-//\n-// Utilities.\n-//\n-\n-// returns an infinite iterator of repeated applications of f to x,\n-// i.e. [x, f(x), f(f(x)), ...], as haskell iterate function.\n-fn iterate<T, F>(x: T, f: F) -> Iterate<T, F> where F: FnMut(&T) -> T {\n-    Iterate {f: f, next: x}\n-}\n-struct Iterate<T, F> where F: FnMut(&T) -> T {\n-    f: F,\n-    next: T\n-}\n-impl<T, F> Iterator for Iterate<T, F> where F: FnMut(&T) -> T {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        let mut res = (self.f)(&self.next);\n-        std::mem::swap(&mut res, &mut self.next);\n-        Some(res)\n-    }\n-}\n-\n-// a linked list using borrowed next.\n-enum List<'a, T:'a> {\n-    Nil,\n-    Cons(T, &'a List<'a, T>)\n-}\n-struct ListIterator<'a, T:'a> {\n-    cur: &'a List<'a, T>\n-}\n-impl<'a, T> List<'a, T> {\n-    fn iter(&'a self) -> ListIterator<'a, T> {\n-        ListIterator{cur: self}\n-    }\n-}\n-impl<'a, T> Iterator for ListIterator<'a, T> {\n-    type Item = &'a T;\n-\n-    fn next(&mut self) -> Option<&'a T> {\n-        match *self.cur {\n-            List::Nil => None,\n-            List::Cons(ref elt, next) => {\n-                self.cur = next;\n-                Some(elt)\n-            }\n-        }\n-    }\n-}\n-\n-//\n-// preprocess\n-//\n-\n-// Takes a pieces p on the form [(y1, x1), (y2, x2), ...] and returns\n-// every possible transformations (the 6 rotations with their\n-// corresponding mirrored piece), with, as minimum coordinates, (0,\n-// 0).  If all is false, only generate half of the possibilities (used\n-// to break the symmetry of the board).\n-fn transform(piece: Vec<(i32, i32)> , all: bool) -> Vec<Vec<(i32, i32)>> {\n-    let mut res: Vec<Vec<(i32, i32)>> =\n-        // rotations\n-        iterate(piece, |rot| rot.iter().map(|&(y, x)| (x + y, -y)).collect())\n-        .take(if all {6} else {3})\n-        // mirror\n-        .flat_map(|cur_piece| {\n-            iterate(cur_piece, |mir| mir.iter().map(|&(y, x)| (x, y)).collect())\n-            .take(2)\n-        }).collect();\n-\n-    // translating to (0, 0) as minimum coordinates.\n-    for cur_piece in &mut res {\n-        let (dy, dx) = *cur_piece.iter().min_by(|e| *e).unwrap();\n-        for &mut (ref mut y, ref mut x) in cur_piece {\n-            *y -= dy; *x -= dx;\n-        }\n-    }\n-\n-    res\n-}\n-\n-// A mask is a piece somewhere on the board.  It is represented as a\n-// u64: for i in the first 50 bits, m[i] = 1 if the cell at (i/5, i%5)\n-// is occupied.  m[50 + id] = 1 if the identifier of the piece is id.\n-\n-// Takes a piece with minimum coordinate (0, 0) (as generated by\n-// transform).  Returns the corresponding mask if p translated by (dy,\n-// dx) is on the board.\n-fn mask(dy: i32, dx: i32, id: usize, p: &Vec<(i32, i32)>) -> Option<u64> {\n-    let mut m = 1 << (50 + id);\n-    for &(y, x) in p {\n-        let x = x + dx + (y + (dy % 2)) / 2;\n-        if x < 0 || x > 4 {return None;}\n-        let y = y + dy;\n-        if y < 0 || y > 9 {return None;}\n-        m |= 1 << (y * 5 + x) as usize;\n-    }\n-    Some(m)\n-}\n-\n-// Makes every possible masks.  masks[i][id] correspond to every\n-// possible masks for piece with identifier id with minimum coordinate\n-// (i/5, i%5).\n-fn make_masks() -> Vec<Vec<Vec<u64> > > {\n-    let pieces = vec!(\n-        vec!((0,0),(0,1),(0,2),(0,3),(1,3)),\n-        vec!((0,0),(0,2),(0,3),(1,0),(1,1)),\n-        vec!((0,0),(0,1),(0,2),(1,2),(2,1)),\n-        vec!((0,0),(0,1),(0,2),(1,1),(2,1)),\n-        vec!((0,0),(0,2),(1,0),(1,1),(2,1)),\n-        vec!((0,0),(0,1),(0,2),(1,1),(1,2)),\n-        vec!((0,0),(0,1),(1,1),(1,2),(2,1)),\n-        vec!((0,0),(0,1),(0,2),(1,0),(1,2)),\n-        vec!((0,0),(0,1),(0,2),(1,2),(1,3)),\n-        vec!((0,0),(0,1),(0,2),(0,3),(1,2)));\n-\n-    // To break the central symmetry of the problem, every\n-    // transformation must be taken except for one piece (piece 3\n-    // here).\n-    let transforms: Vec<Vec<Vec<(i32, i32)>>> =\n-        pieces.into_iter().enumerate()\n-        .map(|(id, p)| transform(p, id != 3))\n-        .collect();\n-\n-    (0..50).map(|yx| {\n-        transforms.iter().enumerate().map(|(id, t)| {\n-            t.iter().filter_map(|p| mask(yx / 5, yx % 5, id, p)).collect()\n-        }).collect()\n-    }).collect()\n-}\n-\n-// Check if all coordinates can be covered by an unused piece and that\n-// all unused piece can be placed on the board.\n-fn is_board_unfeasible(board: u64, masks: &Vec<Vec<Vec<u64>>>) -> bool {\n-    let mut coverable = board;\n-    for (i, masks_at) in masks.iter().enumerate() {\n-        if board & 1 << i != 0 { continue; }\n-        for (cur_id, pos_masks) in masks_at.iter().enumerate() {\n-            if board & 1 << (50 + cur_id) != 0 { continue; }\n-            for &cur_m in pos_masks {\n-                if cur_m & board != 0 { continue; }\n-                coverable |= cur_m;\n-                // if every coordinates can be covered and every\n-                // piece can be used.\n-                if coverable == (1 << 60) - 1 { return false; }\n-            }\n-        }\n-        if coverable & 1 << i == 0 { return true; }\n-    }\n-    true\n-}\n-\n-// Filter the masks that we can prove to result to unfeasible board.\n-fn filter_masks(masks: &mut Vec<Vec<Vec<u64>>>) {\n-    for i in 0..masks.len() {\n-        for j in 0..(*masks)[i].len() {\n-            masks[i][j] =\n-                (*masks)[i][j].iter().cloned()\n-                .filter(|&m| !is_board_unfeasible(m, masks))\n-                .collect();\n-        }\n-    }\n-}\n-\n-// Gets the identifier of a mask.\n-fn get_id(m: u64) -> u8 {\n-    for id in 0..10 {\n-        if m & (1 << (id + 50) as usize) != 0 {return id;}\n-    }\n-    panic!(\"{:016x} does not have a valid identifier\", m);\n-}\n-\n-// Converts a list of mask to a Vec<u8>.\n-fn to_vec(raw_sol: &List<u64>) -> Vec<u8> {\n-    let mut sol = vec![b'.'; 50];\n-    for &m in raw_sol.iter() {\n-        let id = '0' as u8 + get_id(m);\n-        for i in 0..50 {\n-            if m & 1 << i != 0 {\n-                sol[i] = id;\n-            }\n-        }\n-    }\n-    sol\n-}\n-\n-// Prints a solution in Vec<u8> form.\n-fn print_sol(sol: &Vec<u8>) {\n-    for (i, c) in sol.iter().enumerate() {\n-        if (i) % 5 == 0 { println!(\"\"); }\n-        if (i + 5) % 10 == 0 { print!(\" \"); }\n-        print!(\"{} \", *c as char);\n-    }\n-    println!(\"\");\n-}\n-\n-// The data managed during the search\n-struct Data {\n-    // Number of solution found.\n-    nb: isize,\n-    // Lexicographically minimal solution found.\n-    min: Vec<u8>,\n-    // Lexicographically maximal solution found.\n-    max: Vec<u8>\n-}\n-impl Data {\n-    fn new() -> Data {\n-        Data {nb: 0, min: vec!(), max: vec!()}\n-    }\n-    fn reduce_from(&mut self, other: Data) {\n-        self.nb += other.nb;\n-        let Data { min: min, max: max, ..} = other;\n-        if min < self.min { self.min = min; }\n-        if max > self.max { self.max = max; }\n-    }\n-}\n-\n-// Records a new found solution.  Returns false if the search must be\n-// stopped.\n-fn handle_sol(raw_sol: &List<u64>, data: &mut Data) {\n-    // because we break the symmetry, 2 solutions correspond to a call\n-    // to this method: the normal solution, and the same solution in\n-    // reverse order, i.e. the board rotated by half a turn.\n-    data.nb += 2;\n-    let sol1 = to_vec(raw_sol);\n-    let sol2: Vec<u8> = sol1.iter().rev().cloned().collect();\n-\n-    if data.nb == 2 {\n-        data.min = sol1.clone();\n-        data.max = sol1.clone();\n-    }\n-\n-    if sol1 < data.min {data.min = sol1;}\n-    else if sol1 > data.max {data.max = sol1;}\n-    if sol2 < data.min {data.min = sol2;}\n-    else if sol2 > data.max {data.max = sol2;}\n-}\n-\n-fn search(\n-    masks: &Vec<Vec<Vec<u64>>>,\n-    board: u64,\n-    mut i: usize,\n-    cur: List<u64>,\n-    data: &mut Data)\n-{\n-    // Search for the lesser empty coordinate.\n-    while board & (1 << i)  != 0 && i < 50 {i += 1;}\n-    // the board is full: a solution is found.\n-    if i >= 50 {return handle_sol(&cur, data);}\n-    let masks_at = &masks[i];\n-\n-    // for every unused piece\n-    for id in (0..10).filter(|&id| board & (1 << (id + 50)) == 0) {\n-        // for each mask that fits on the board\n-        for m in masks_at[id].iter().filter(|&m| board & *m == 0) {\n-            // This check is too costly.\n-            //if is_board_unfeasible(board | m, masks) {continue;}\n-            search(masks, board | *m, i + 1, List::Cons(*m, &cur), data);\n-        }\n-    }\n-}\n-\n-fn par_search(masks: Vec<Vec<Vec<u64>>>) -> Data {\n-    let masks = Arc::new(masks);\n-    let (tx, rx) = channel();\n-\n-    // launching the search in parallel on every masks at minimum\n-    // coordinate (0,0)\n-    for m in (*masks)[0].iter().flat_map(|masks_pos| masks_pos) {\n-        let masks = masks.clone();\n-        let tx = tx.clone();\n-        let m = *m;\n-        thread::spawn(move|| {\n-            let mut data = Data::new();\n-            search(&*masks, m, 1, List::Cons(m, &List::Nil), &mut data);\n-            tx.send(data).unwrap();\n-        });\n-    }\n-\n-    // collecting the results\n-    drop(tx);\n-    let mut data = rx.recv().unwrap();\n-    for d in rx.iter() { data.reduce_from(d); }\n-    data\n-}\n-\n-fn main () {\n-    let mut masks = make_masks();\n-    filter_masks(&mut masks);\n-    let data = par_search(masks);\n-    println!(\"{} solutions found\", data.nb);\n-    print_sol(&data.min);\n-    print_sol(&data.max);\n-    println!(\"\");\n-}"}, {"sha": "1a9ea8bff08b3ea99d5f6244bbde5a8614d61ec6", "filename": "src/test/bench/shootout-nbody.rs", "status": "removed", "additions": 0, "deletions": 244, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,244 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2011-2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-use std::mem;\n-use std::ops::{Add, Sub, Mul};\n-\n-const PI: f64 = 3.141592653589793;\n-const SOLAR_MASS: f64 = 4.0 * PI * PI;\n-const YEAR: f64 = 365.24;\n-const N_BODIES: usize = 5;\n-const N_PAIRS: usize = N_BODIES * (N_BODIES - 1) / 2;\n-\n-const BODIES: [Planet; N_BODIES] = [\n-    // Sun\n-    Planet {\n-        pos: Vec3(0.0, 0.0, 0.0),\n-        vel: Vec3(0.0, 0.0, 0.0),\n-        mass: SOLAR_MASS,\n-    },\n-    // Jupiter\n-    Planet {\n-        pos: Vec3(4.84143144246472090e+00,\n-                  -1.16032004402742839e+00,\n-                  -1.03622044471123109e-01),\n-        vel: Vec3(1.66007664274403694e-03 * YEAR,\n-                  7.69901118419740425e-03 * YEAR,\n-                  -6.90460016972063023e-05 * YEAR),\n-        mass: 9.54791938424326609e-04 * SOLAR_MASS,\n-    },\n-    // Saturn\n-    Planet {\n-        pos: Vec3(8.34336671824457987e+00,\n-                  4.12479856412430479e+00,\n-                  -4.03523417114321381e-01),\n-        vel: Vec3(-2.76742510726862411e-03 * YEAR,\n-                  4.99852801234917238e-03 * YEAR,\n-                  2.30417297573763929e-05 * YEAR),\n-        mass: 2.85885980666130812e-04 * SOLAR_MASS,\n-    },\n-    // Uranus\n-    Planet {\n-        pos: Vec3(1.28943695621391310e+01,\n-                  -1.51111514016986312e+01,\n-                  -2.23307578892655734e-01),\n-        vel: Vec3(2.96460137564761618e-03 * YEAR,\n-                  2.37847173959480950e-03 * YEAR,\n-                  -2.96589568540237556e-05 * YEAR),\n-        mass: 4.36624404335156298e-05 * SOLAR_MASS,\n-    },\n-    // Neptune\n-    Planet {\n-        pos: Vec3(1.53796971148509165e+01,\n-                  -2.59193146099879641e+01,\n-                  1.79258772950371181e-01),\n-        vel: Vec3(2.68067772490389322e-03 * YEAR,\n-                  1.62824170038242295e-03 * YEAR,\n-                  -9.51592254519715870e-05 * YEAR),\n-        mass: 5.15138902046611451e-05 * SOLAR_MASS,\n-    },\n-];\n-\n-/// A 3d Vector type with oveloaded operators to improve readability.\n-#[derive(Clone, Copy)]\n-struct Vec3(pub f64, pub f64, pub f64);\n-\n-impl Vec3 {\n-    fn zero() -> Self { Vec3(0.0, 0.0, 0.0) }\n-\n-    fn norm(&self) -> f64 { self.squared_norm().sqrt() }\n-\n-    fn squared_norm(&self) -> f64 {\n-        self.0 * self.0 + self.1 * self.1 + self.2 * self.2\n-    }\n-}\n-\n-impl Add for Vec3 {\n-    type Output = Self;\n-    fn add(self, rhs: Self) -> Self {\n-        Vec3(self.0 + rhs.0, self.1 + rhs.1, self.2 + rhs.2)\n-    }\n-}\n-\n-impl Sub for Vec3 {\n-    type Output = Self;\n-    fn sub(self, rhs: Self) -> Self {\n-        Vec3(self.0 - rhs.0, self.1 - rhs.1, self.2 - rhs.2)\n-    }\n-}\n-\n-impl Mul<f64> for Vec3 {\n-    type Output = Self;\n-    fn mul(self, rhs: f64) -> Self {\n-        Vec3(self.0 * rhs, self.1 * rhs, self.2 * rhs)\n-    }\n-}\n-\n-#[derive(Clone, Copy)]\n-struct Planet {\n-    pos: Vec3,\n-    vel: Vec3,\n-    mass: f64,\n-}\n-\n-/// Computes all pairwise position differences between the planets.\n-fn pairwise_diffs(bodies: &[Planet; N_BODIES], diff: &mut [Vec3; N_PAIRS]) {\n-    let mut bodies = bodies.iter();\n-    let mut diff = diff.iter_mut();\n-    while let Some(bi) = bodies.next() {\n-        for bj in bodies.clone() {\n-            *diff.next().unwrap() = bi.pos - bj.pos;\n-        }\n-    }\n-}\n-\n-/// Computes the magnitude of the force between each pair of planets.\n-fn magnitudes(diff: &[Vec3; N_PAIRS], dt: f64, mag: &mut [f64; N_PAIRS]) {\n-    for (mag, diff) in mag.iter_mut().zip(diff.iter()) {\n-        let d2 = diff.squared_norm();\n-        *mag = dt / (d2 * d2.sqrt());\n-    }\n-}\n-\n-/// Updates the velocities of the planets by computing their gravitational\n-/// accelerations and performing one step of Euler integration.\n-fn update_velocities(bodies: &mut [Planet; N_BODIES], dt: f64,\n-                     diff: &mut [Vec3; N_PAIRS], mag: &mut [f64; N_PAIRS]) {\n-    pairwise_diffs(bodies, diff);\n-    magnitudes(&diff, dt, mag);\n-\n-    let mut bodies = &mut bodies[..];\n-    let mut mag = mag.iter();\n-    let mut diff = diff.iter();\n-    while let Some(bi) = shift_mut_ref(&mut bodies) {\n-        for bj in bodies.iter_mut() {\n-            let diff = *diff.next().unwrap();\n-            let mag = *mag.next().unwrap();\n-            bi.vel = bi.vel - diff * (bj.mass * mag);\n-            bj.vel = bj.vel + diff * (bi.mass * mag);\n-        }\n-    }\n-}\n-\n-/// Advances the solar system by one timestep by first updating the\n-/// velocities and then integrating the positions using the updated velocities.\n-///\n-/// Note: the `diff` & `mag` arrays are effectively scratch space. They're\n-/// provided as arguments to avoid re-zeroing them every time `advance` is\n-/// called.\n-fn advance(mut bodies: &mut [Planet; N_BODIES], dt: f64,\n-           diff: &mut [Vec3; N_PAIRS], mag: &mut [f64; N_PAIRS]) {\n-    update_velocities(bodies, dt, diff, mag);\n-    for body in bodies.iter_mut() {\n-        body.pos = body.pos + body.vel * dt;\n-    }\n-}\n-\n-/// Computes the total energy of the solar system.\n-fn energy(bodies: &[Planet; N_BODIES]) -> f64 {\n-    let mut e = 0.0;\n-    let mut bodies = bodies.iter();\n-    while let Some(bi) = bodies.next() {\n-        e += bi.vel.squared_norm() * bi.mass / 2.0\n-           - bi.mass * bodies.clone()\n-                             .map(|bj| bj.mass / (bi.pos - bj.pos).norm())\n-                             .fold(0.0, |a, b| a + b);\n-    }\n-    e\n-}\n-\n-/// Offsets the sun's velocity to make the overall momentum of the system zero.\n-fn offset_momentum(bodies: &mut [Planet; N_BODIES]) {\n-    let p = bodies.iter().fold(Vec3::zero(), |v, b| v + b.vel * b.mass);\n-    bodies[0].vel = p * (-1.0 / bodies[0].mass);\n-}\n-\n-fn main() {\n-    let n = if std::env::var_os(\"RUST_BENCH\").is_some() {\n-        5000000\n-    } else {\n-        std::env::args().nth(1)\n-            .and_then(|arg| arg.parse().ok())\n-            .unwrap_or(1000)\n-    };\n-    let mut bodies = BODIES;\n-    let mut diff = [Vec3::zero(); N_PAIRS];\n-    let mut mag = [0.0f64; N_PAIRS];\n-\n-    offset_momentum(&mut bodies);\n-    println!(\"{:.9}\", energy(&bodies));\n-\n-    for _ in 0..n {\n-        advance(&mut bodies, 0.01, &mut diff, &mut mag);\n-    }\n-\n-    println!(\"{:.9}\", energy(&bodies));\n-}\n-\n-/// Pop a mutable reference off the head of a slice, mutating the slice to no\n-/// longer contain the mutable reference. This is a safe operation because the\n-/// two mutable borrows are entirely disjoint.\n-fn shift_mut_ref<'a, T>(r: &mut &'a mut [T]) -> Option<&'a mut T> {\n-    let res = mem::replace(r, &mut []);\n-    if res.is_empty() { return None }\n-    let (a, b) = res.split_at_mut(1);\n-    *r = b;\n-    Some(&mut a[0])\n-}"}, {"sha": "b7553dc7c7043141ba6f514f70adfbfeb89072c7", "filename": "src/test/bench/shootout-pfib.rs", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,121 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-/*\n-  A parallel version of fibonacci numbers.\n-\n-  This version is meant mostly as a way of stressing and benchmarking\n-  the task system. It supports a lot of old command-line arguments to\n-  control how it runs.\n-\n-*/\n-\n-#![feature(duration, duration_span, rustc_private)]\n-\n-extern crate getopts;\n-\n-use std::sync::mpsc::{channel, Sender};\n-use std::env;\n-use std::result::Result::{Ok, Err};\n-use std::thread;\n-use std::time::Duration;\n-\n-fn fib(n: isize) -> isize {\n-    fn pfib(tx: &Sender<isize>, n: isize) {\n-        if n == 0 {\n-            tx.send(0).unwrap();\n-        } else if n <= 2 {\n-            tx.send(1).unwrap();\n-        } else {\n-            let (tx1, rx) = channel();\n-            let tx2 = tx1.clone();\n-            thread::spawn(move|| pfib(&tx2, n - 1));\n-            let tx2 = tx1.clone();\n-            thread::spawn(move|| pfib(&tx2, n - 2));\n-            tx.send(rx.recv().unwrap() + rx.recv().unwrap());\n-        }\n-    }\n-\n-    let (tx, rx) = channel();\n-    thread::spawn(move|| pfib(&tx, n) );\n-    rx.recv().unwrap()\n-}\n-\n-struct Config {\n-    stress: bool\n-}\n-\n-fn parse_opts(argv: Vec<String> ) -> Config {\n-    let opts = vec!(getopts::optflag(\"\", \"stress\", \"\"));\n-\n-    let argv = argv.iter().map(|x| x.to_string()).collect::<Vec<_>>();\n-    let opt_args = &argv[1..argv.len()];\n-\n-    match getopts::getopts(opt_args, &opts) {\n-      Ok(ref m) => {\n-          return Config {stress: m.opt_present(\"stress\")}\n-      }\n-      Err(_) => { panic!(); }\n-    }\n-}\n-\n-fn stress_task(id: isize) {\n-    let mut i = 0;\n-    loop {\n-        let n = 15;\n-        assert_eq!(fib(n), fib(n));\n-        i += 1;\n-        println!(\"{}: Completed {} iterations\", id, i);\n-    }\n-}\n-\n-fn stress(num_tasks: isize) {\n-    let mut results = Vec::new();\n-    for i in 0..num_tasks {\n-        results.push(thread::spawn(move|| {\n-            stress_task(i);\n-        }));\n-    }\n-    for r in results {\n-        let _ = r.join();\n-    }\n-}\n-\n-fn main() {\n-    let args = env::args();\n-    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"20\".to_string())\n-    } else if args.len() <= 1 {\n-        vec!(\"\".to_string(), \"8\".to_string())\n-    } else {\n-        args.map(|x| x.to_string()).collect()\n-    };\n-\n-    let opts = parse_opts(args.clone());\n-\n-    if opts.stress {\n-        stress(2);\n-    } else {\n-        let max = args[1].parse::<isize>().unwrap();\n-\n-        let num_trials = 10;\n-\n-        for n in 1..max + 1 {\n-            for _ in 0..num_trials {\n-                let mut fibn = None;\n-                let dur = Duration::span(|| fibn = Some(fib(n)));\n-                let fibn = fibn.unwrap();\n-\n-                println!(\"{}\\t{}\\t{:?}\", n, fibn, dur);\n-            }\n-        }\n-    }\n-}"}, {"sha": "3a0d182ab122164cc24d0ae599f3a8727810fadd", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,213 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2013-2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-// ignore-android: FIXME(#10393) hangs without output\n-\n-#![feature(libc)]\n-\n-extern crate libc;\n-\n-use std::io;\n-use std::io::prelude::*;\n-use std::ptr::copy;\n-use std::thread;\n-\n-struct Tables {\n-    table8: Box<[u8; 1 << 8]>,\n-    table16: Box<[u16; 1 << 16]>,\n-}\n-\n-impl Tables {\n-    fn new() -> Tables {\n-        let mut table8 = Box::new([0;1 << 8]);\n-        for (i, v) in table8.iter_mut().enumerate() {\n-            *v = Tables::computed_cpl8(i as u8);\n-        }\n-        let mut table16 = Box::new([0;1 << 16]);\n-        for (i, v) in table16.iter_mut().enumerate() {\n-            *v = (table8[i & 255] as u16) << 8 |\n-                 table8[i >> 8]  as u16;\n-        }\n-        Tables { table8: table8, table16: table16 }\n-    }\n-\n-    fn computed_cpl8(c: u8) -> u8 {\n-        match c {\n-            b'A' | b'a' => b'T',\n-            b'C' | b'c' => b'G',\n-            b'G' | b'g' => b'C',\n-            b'T' | b't' => b'A',\n-            b'U' | b'u' => b'A',\n-            b'M' | b'm' => b'K',\n-            b'R' | b'r' => b'Y',\n-            b'W' | b'w' => b'W',\n-            b'S' | b's' => b'S',\n-            b'Y' | b'y' => b'R',\n-            b'K' | b'k' => b'M',\n-            b'V' | b'v' => b'B',\n-            b'H' | b'h' => b'D',\n-            b'D' | b'd' => b'H',\n-            b'B' | b'b' => b'V',\n-            b'N' | b'n' => b'N',\n-            i => i,\n-        }\n-    }\n-\n-    /// Retrieves the complement for `i`.\n-    fn cpl8(&self, i: u8) -> u8 {\n-        self.table8[i as usize]\n-    }\n-\n-    /// Retrieves the complement for `i`.\n-    fn cpl16(&self, i: u16) -> u16 {\n-        self.table16[i as usize]\n-    }\n-}\n-\n-/// Finds the first position at which `b` occurs in `s`.\n-fn memchr(h: &[u8], n: u8) -> Option<usize> {\n-    use libc::{c_void, c_int, size_t};\n-    let res = unsafe {\n-        libc::memchr(h.as_ptr() as *const c_void, n as c_int, h.len() as size_t)\n-    };\n-    if res.is_null() {\n-        None\n-    } else {\n-        Some(res as usize - h.as_ptr() as usize)\n-    }\n-}\n-\n-/// A mutable iterator over DNA sequences\n-struct MutDnaSeqs<'a> { s: &'a mut [u8] }\n-fn mut_dna_seqs<'a>(s: &'a mut [u8]) -> MutDnaSeqs<'a> {\n-    MutDnaSeqs { s: s }\n-}\n-impl<'a> Iterator for MutDnaSeqs<'a> {\n-    type Item = &'a mut [u8];\n-\n-    fn next(&mut self) -> Option<&'a mut [u8]> {\n-        let tmp = std::mem::replace(&mut self.s, &mut []);\n-        let tmp = match memchr(tmp, b'\\n') {\n-            Some(i) => &mut tmp[i + 1..],\n-            None => return None,\n-        };\n-        let (seq, tmp) = match memchr(tmp, b'>') {\n-            Some(i) => tmp.split_at_mut(i),\n-            None => {\n-                let len = tmp.len();\n-                tmp.split_at_mut(len)\n-            }\n-        };\n-        self.s = tmp;\n-        Some(seq)\n-    }\n-}\n-\n-/// Length of a normal line without the terminating \\n.\n-const LINE_LEN: usize = 60;\n-\n-/// Compute the reverse complement.\n-fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n-    let len = seq.len();\n-    let seq = &mut seq[..len - 1]; // Drop the last newline\n-    let len = seq.len();\n-    let off = LINE_LEN - len % (LINE_LEN + 1);\n-    let mut i = LINE_LEN;\n-    while i < len {\n-        unsafe {\n-            copy(seq.as_ptr().offset((i - off) as isize),\n-                 seq.as_mut_ptr().offset((i - off + 1) as isize), off);\n-            *seq.get_unchecked_mut(i - off) = b'\\n';\n-        }\n-        i += LINE_LEN + 1;\n-    }\n-\n-    let div = len / 4;\n-    let rem = len % 4;\n-    unsafe {\n-        let mut left = seq.as_mut_ptr() as *mut u16;\n-        // This is slow if len % 2 != 0 but still faster than bytewise operations.\n-        let mut right = seq.as_mut_ptr().offset(len as isize - 2) as *mut u16;\n-        let end = left.offset(div as isize);\n-        while left != end {\n-            let tmp = tables.cpl16(*left);\n-            *left = tables.cpl16(*right);\n-            *right = tmp;\n-            left = left.offset(1);\n-            right = right.offset(-1);\n-        }\n-\n-        let end = end as *mut u8;\n-        match rem {\n-            1 => *end = tables.cpl8(*end),\n-            2 => {\n-                let tmp = tables.cpl8(*end);\n-                *end = tables.cpl8(*end.offset(1));\n-                *end.offset(1) = tmp;\n-            },\n-            3 => {\n-                *end.offset(1) = tables.cpl8(*end.offset(1));\n-                let tmp = tables.cpl8(*end);\n-                *end = tables.cpl8(*end.offset(2));\n-                *end.offset(2) = tmp;\n-            },\n-            _ => { },\n-        }\n-    }\n-}\n-\n-/// Executes a closure in parallel over the given iterator over mutable slice.\n-/// The closure `f` is run in parallel with an element of `iter`.\n-// FIXME: replace with thread::scoped when it exists again\n-fn parallel<I: Iterator, F>(iter: I, ref f: F)\n-        where I::Item: Send,\n-              F: Fn(I::Item) + Sync, {\n-    iter.map(|x| {\n-        f(x)\n-    }).collect::<Vec<_>>();\n-}\n-\n-fn main() {\n-    let mut data = Vec::with_capacity(1024 * 1024);\n-    io::stdin().read_to_end(&mut data).unwrap();\n-    let tables = &Tables::new();\n-    parallel(mut_dna_seqs(&mut data), |seq| reverse_complement(seq, tables));\n-    io::stdout().write_all(&data).unwrap();\n-}"}, {"sha": "2653e758a487d256666700f2f7993bc63136902b", "filename": "src/test/bench/shootout-threadring.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,78 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2012-2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::thread;\n-\n-fn start(n_tasks: i32, token: i32) {\n-    let (tx, mut rx) = channel();\n-    tx.send(token).unwrap();\n-    let mut guards = Vec::with_capacity(n_tasks as usize);\n-    for i in 2 .. n_tasks + 1 {\n-        let (tx, next_rx) = channel();\n-        let cur_rx = std::mem::replace(&mut rx, next_rx);\n-        guards.push(thread::spawn(move|| roundtrip(i, tx, cur_rx)));\n-    }\n-    let guard = thread::spawn(move|| roundtrip(1, tx, rx));\n-}\n-\n-fn roundtrip(id: i32, tx: Sender<i32>, rx: Receiver<i32>) {\n-    for token in rx.iter() {\n-        if token == 1 {\n-            println!(\"{}\", id);\n-            break;\n-        }\n-        tx.send(token - 1).unwrap();\n-    }\n-}\n-\n-fn main() {\n-    let mut args = std::env::args();\n-    let token = if std::env::var_os(\"RUST_BENCH\").is_some() {\n-        2000000\n-    } else {\n-        args.nth(1).and_then(|arg| arg.parse().ok()).unwrap_or(1000)\n-    };\n-    let n_tasks = args.next()\n-                      .and_then(|arg| arg.parse().ok())\n-                      .unwrap_or(503);\n-\n-    start(n_tasks, token);\n-}"}, {"sha": "bcadfd74493dc18a411bf6eb30f26e7e40480c24", "filename": "src/test/bench/sudoku.rs", "status": "removed", "additions": 0, "deletions": 282, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,282 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-pretty very bad with line comments\n-\n-#![feature(box_syntax, core)]\n-#![allow(non_snake_case)]\n-\n-use std::io::prelude::*;\n-use std::io;\n-use std::env;\n-\n-// Computes a single solution to a given 9x9 sudoku\n-//\n-// Call with \"-\" to read input sudoku from stdin\n-//\n-// The expected line-based format is:\n-//\n-// 9,9\n-// <row>,<column>,<color>\n-// ...\n-//\n-// Row and column are 0-based (i.e. <= 8) and color is 1-based (>=1,<=9).\n-// A color of 0 indicates an empty field.\n-//\n-// If called without arguments, sudoku solves a built-in example sudoku\n-//\n-\n-// internal type of sudoku grids\n-type grid = Vec<Vec<u8>>;\n-\n-struct Sudoku {\n-    grid: grid\n-}\n-\n-impl Sudoku {\n-    pub fn new(g: grid) -> Sudoku {\n-        return Sudoku { grid: g }\n-    }\n-\n-    pub fn from_vec(vec: &[[u8;9];9]) -> Sudoku {\n-        let g = (0..9).map(|i| {\n-            (0..9).map(|j| { vec[i][j] }).collect()\n-        }).collect();\n-        return Sudoku::new(g)\n-    }\n-\n-    pub fn read(reader: &mut BufRead) -> Sudoku {\n-        /* assert first line is exactly \"9,9\" */\n-        let mut s = String::new();\n-        reader.read_line(&mut s).unwrap();\n-        assert_eq!(s, \"9,9\\n\");\n-\n-        let mut g = vec![vec![0, 0, 0, 0, 0, 0, 0, 0, 0]; 10];\n-        for line in reader.lines() {\n-            let line = line.unwrap();\n-            let comps: Vec<&str> = line\n-                                       .trim()\n-                                       .split(',')\n-                                       .collect();\n-\n-            if comps.len() == 3 {\n-                let row = comps[0].parse::<u8>().unwrap();\n-                let col = comps[1].parse::<u8>().unwrap();\n-                g[row as usize][col as usize] = comps[2].parse().unwrap();\n-            }\n-            else {\n-                panic!(\"Invalid sudoku file\");\n-            }\n-        }\n-        return Sudoku::new(g)\n-    }\n-\n-    pub fn write(&self, writer: &mut Write) {\n-        for row in 0u8..9u8 {\n-            write!(writer, \"{}\", self.grid[row as usize][0]);\n-            for col in 1u8..9u8 {\n-                write!(writer, \" {}\", self.grid[row as usize][col as usize]);\n-            }\n-            write!(writer, \"\\n\");\n-         }\n-    }\n-\n-    // solve sudoku grid\n-    pub fn solve(&mut self) {\n-        let mut work: Vec<(u8, u8)> = Vec::new(); /* queue of uncolored fields */\n-        for row in 0..9 {\n-            for col in 0..9 {\n-                let color = self.grid[row as usize][col as usize];\n-                if color == 0 {\n-                    work.push((row, col));\n-                }\n-            }\n-        }\n-\n-        let mut ptr = 0;\n-        let end = work.len();\n-        while ptr < end {\n-            let (row, col) = work[ptr];\n-            // is there another color to try?\n-            let the_color = self.grid[row as usize][col as usize] +\n-                                (1 as u8);\n-            if self.next_color(row, col, the_color) {\n-                //  yes: advance work list\n-                ptr = ptr + 1;\n-            } else {\n-                // no: redo this field aft recoloring pred; unless there is none\n-                if ptr == 0 { panic!(\"No solution found for this sudoku\"); }\n-                ptr = ptr - 1;\n-            }\n-        }\n-    }\n-\n-    fn next_color(&mut self, row: u8, col: u8, start_color: u8) -> bool {\n-        if start_color < 10 {\n-            // colors not yet used\n-            let mut avail: Box<_> = box Colors::new(start_color);\n-\n-            // drop colors already in use in neighbourhood\n-            self.drop_colors(&mut *avail, row, col);\n-\n-            // find first remaining color that is available\n-            let next = avail.next();\n-            self.grid[row as usize][col as usize] = next;\n-            return 0 != next;\n-        }\n-        self.grid[row as usize][col as usize] = 0;\n-        return false;\n-    }\n-\n-    // find colors available in neighbourhood of (row, col)\n-    fn drop_colors(&mut self, avail: &mut Colors, row: u8, col: u8) {\n-        for idx in 0..9 {\n-            /* check same column fields */\n-            avail.remove(self.grid[idx as usize][col as usize]);\n-            /* check same row fields */\n-            avail.remove(self.grid[row as usize][idx as usize]);\n-        }\n-\n-        // check same block fields\n-        let row0 = (row / 3) * 3;\n-        let col0 = (col / 3) * 3;\n-        for alt_row in row0..row0 + 3 {\n-            for alt_col in col0..col0 + 3 {\n-                avail.remove(self.grid[alt_row as usize][alt_col as usize]);\n-            }\n-        }\n-    }\n-}\n-\n-// Stores available colors as simple bitfield, bit 0 is always unset\n-struct Colors(u16);\n-\n-static HEADS: u16 = (1 << 10) - 1; /* bits 9..0 */\n-\n-impl Colors {\n-    fn new(start_color: u8) -> Colors {\n-        // Sets bits 9..start_color\n-        let tails = !0 << start_color as usize;\n-        return Colors(HEADS & tails);\n-    }\n-\n-    fn next(&self) -> u8 {\n-        let Colors(c) = *self;\n-        let val = c & HEADS;\n-        if 0 == val {\n-            return 0;\n-        } else {\n-            return val.trailing_zeros() as u8\n-        }\n-    }\n-\n-    fn remove(&mut self, color: u8) {\n-        if color != 0 {\n-            let Colors(val) = *self;\n-            let mask = !(1 << color as usize);\n-            *self    = Colors(val & mask);\n-        }\n-    }\n-}\n-\n-static DEFAULT_SUDOKU: [[u8;9];9] = [\n-         /* 0    1    2    3    4    5    6    7    8    */\n-  /* 0 */  [0, 4, 0, 6, 0, 0, 0, 3, 2],\n-  /* 1 */  [0, 0, 8, 0, 2, 0, 0, 0, 0],\n-  /* 2 */  [7, 0, 0, 8, 0, 0, 0, 0, 0],\n-  /* 3 */  [0, 0, 0, 5, 0, 0, 0, 0, 0],\n-  /* 4 */  [0, 5, 0, 0, 0, 3, 6, 0, 0],\n-  /* 5 */  [6, 8, 0, 0, 0, 0, 0, 9, 0],\n-  /* 6 */  [0, 9, 5, 0, 0, 6, 0, 7, 0],\n-  /* 7 */  [0, 0, 0, 0, 4, 0, 0, 6, 0],\n-  /* 8 */  [4, 0, 0, 0, 0, 7, 2, 0, 3]\n-];\n-\n-#[cfg(test)]\n-static DEFAULT_SOLUTION: [[u8;9];9] = [\n-         /* 0    1    2    3    4    5    6    7    8    */\n-  /* 0 */  [1, 4, 9, 6, 7, 5, 8, 3, 2],\n-  /* 1 */  [5, 3, 8, 1, 2, 9, 7, 4, 6],\n-  /* 2 */  [7, 2, 6, 8, 3, 4, 1, 5, 9],\n-  /* 3 */  [9, 1, 4, 5, 6, 8, 3, 2, 7],\n-  /* 4 */  [2, 5, 7, 4, 9, 3, 6, 1, 8],\n-  /* 5 */  [6, 8, 3, 7, 1, 2, 5, 9, 4],\n-  /* 6 */  [3, 9, 5, 2, 8, 6, 4, 7, 1],\n-  /* 7 */  [8, 7, 2, 3, 4, 1, 9, 6, 5],\n-  /* 8 */  [4, 6, 1, 9, 5, 7, 2, 8, 3]\n-];\n-\n-#[test]\n-fn colors_new_works() {\n-    assert_eq!(*Colors::new(1), 1022);\n-    assert_eq!(*Colors::new(2), 1020);\n-    assert_eq!(*Colors::new(3), 1016);\n-    assert_eq!(*Colors::new(4), 1008);\n-    assert_eq!(*Colors::new(5), 992);\n-    assert_eq!(*Colors::new(6), 960);\n-    assert_eq!(*Colors::new(7), 896);\n-    assert_eq!(*Colors::new(8), 768);\n-    assert_eq!(*Colors::new(9), 512);\n-}\n-\n-#[test]\n-fn colors_next_works() {\n-    assert_eq!(Colors(0).next(), 0);\n-    assert_eq!(Colors(2).next(), 1);\n-    assert_eq!(Colors(4).next(), 2);\n-    assert_eq!(Colors(8).next(), 3);\n-    assert_eq!(Colors(16).next(), 4);\n-    assert_eq!(Colors(32).next(), 5);\n-    assert_eq!(Colors(64).next(), 6);\n-    assert_eq!(Colors(128).next(), 7);\n-    assert_eq!(Colors(256).next(), 8);\n-    assert_eq!(Colors(512).next(), 9);\n-    assert_eq!(Colors(1024).next(), 0);\n-}\n-\n-#[test]\n-fn colors_remove_works() {\n-    // GIVEN\n-    let mut colors = Colors::new(1);\n-\n-    // WHEN\n-    colors.remove(1);\n-\n-    // THEN\n-    assert_eq!(colors.next(), 2);\n-}\n-\n-#[test]\n-fn check_DEFAULT_SUDOKU_solution() {\n-    // GIVEN\n-    let mut sudoku = Sudoku::from_vec(&DEFAULT_SUDOKU);\n-    let solution   = Sudoku::from_vec(&DEFAULT_SOLUTION);\n-\n-    // WHEN\n-    sudoku.solve();\n-\n-    // THEN\n-    assert!(sudoku.equal(&solution));\n-}\n-\n-fn main() {\n-    let args = env::args();\n-    let use_default = args.len() == 1;\n-    let mut sudoku = if use_default {\n-        Sudoku::from_vec(&DEFAULT_SUDOKU)\n-    } else {\n-        let stdin = io::stdin();\n-        let mut locked = stdin.lock();\n-        Sudoku::read(&mut locked)\n-    };\n-    sudoku.solve();\n-    let out = io::stdout();\n-    sudoku.write(&mut out.lock());\n-}"}, {"sha": "5f34d0f630149529a6ec2dc5b9697fbcc391345a", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,94 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(box_syntax, duration, duration_span, vec_push_all)]\n-\n-use std::env;\n-use std::thread;\n-use std::time::Duration;\n-\n-#[derive(Clone)]\n-enum List<T> {\n-    Nil, Cons(T, Box<List<T>>)\n-}\n-\n-fn main() {\n-    let (repeat, depth) = if env::var_os(\"RUST_BENCH\").is_some() {\n-        (50, 1000)\n-    } else {\n-        (10, 10)\n-    };\n-\n-    run(repeat, depth);\n-}\n-\n-fn run(repeat: isize, depth: isize) {\n-    for _ in 0..repeat {\n-        let dur = Duration::span(|| {\n-            let _ = thread::spawn(move|| {\n-                recurse_or_panic(depth, None)\n-            }).join();\n-        });\n-        println!(\"iter: {:?}\", dur);\n-    }\n-}\n-\n-type nillist = List<()>;\n-\n-// Filled with things that have to be unwound\n-\n-struct State {\n-    unique: Box<nillist>,\n-    vec: Vec<Box<nillist>>,\n-    res: r\n-}\n-\n-struct r {\n-  _l: Box<nillist>,\n-}\n-\n-impl Drop for r {\n-    fn drop(&mut self) {}\n-}\n-\n-fn r(l: Box<nillist>) -> r {\n-    r {\n-        _l: l\n-    }\n-}\n-\n-fn recurse_or_panic(depth: isize, st: Option<State>) {\n-    if depth == 0 {\n-        panic!();\n-    } else {\n-        let depth = depth - 1;\n-\n-        let st = match st {\n-            None => {\n-                State {\n-                    unique: box List::Nil,\n-                    vec: vec!(box List::Nil),\n-                    res: r(box List::Nil)\n-                }\n-            }\n-            Some(st) => {\n-                let mut v = st.vec.clone();\n-                v.push_all(&[box List::Cons((), st.vec.last().unwrap().clone())]);\n-                State {\n-                    unique: box List::Cons((), box *st.unique),\n-                    vec: v,\n-                    res: r(box List::Cons((), st.res._l.clone())),\n-                }\n-            }\n-        };\n-\n-        recurse_or_panic(depth, Some(st));\n-    }\n-}"}, {"sha": "6e3db3d01960eabeb8642cb4230d439900030ea9", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,55 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test performance of a thread \"spawn ladder\", in which children thread have\n-// many ancestor threadgroups, but with only a few such groups alive at a time.\n-// Each child thread has to enlist as a descendant in each of its ancestor\n-// groups, but that shouldn't have to happen for already-dead groups.\n-//\n-// The filename is a song reference; google it in quotes.\n-\n-// ignore-pretty very bad with line comments\n-\n-use std::sync::mpsc::{channel, Sender};\n-use std::env;\n-use std::thread;\n-\n-fn child_generation(gens_left: usize, tx: Sender<()>) {\n-    // This used to be O(n^2) in the number of generations that ever existed.\n-    // With this code, only as many generations are alive at a time as threads\n-    // alive at a time,\n-    thread::spawn(move|| {\n-        if gens_left & 1 == 1 {\n-            thread::yield_now(); // shake things up a bit\n-        }\n-        if gens_left > 0 {\n-            child_generation(gens_left - 1, tx); // recurse\n-        } else {\n-            tx.send(()).unwrap()\n-        }\n-    });\n-}\n-\n-fn main() {\n-    let args = env::args();\n-    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"100000\".to_string())\n-    } else if args.len() <= 1 {\n-        vec!(\"\".to_string(), \"100\".to_string())\n-    } else {\n-        args.collect()\n-    };\n-\n-    let (tx, rx) = channel();\n-    child_generation(args[1].parse().unwrap(), tx);\n-    if rx.recv().is_err() {\n-        panic!(\"it happened when we slumbered\");\n-    }\n-}"}, {"sha": "b5aa8e8d791d22003eb1bc1d695bf172e3e228c7", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f196bcc3b23925854e3d758c03f56c7520e9b99/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=0f196bcc3b23925854e3d758c03f56c7520e9b99", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::env;\n-use std::thread;\n-\n-fn f(n: usize) {\n-    let mut i = 0;\n-    while i < n {\n-        let _ = thread::spawn(move|| g()).join();\n-        i += 1;\n-    }\n-}\n-\n-fn g() { }\n-\n-fn main() {\n-    let args = env::args();\n-    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"400\".to_string())\n-    } else if args.len() <= 1 {\n-        vec!(\"\".to_string(), \"10\".to_string())\n-    } else {\n-        args.collect()\n-    };\n-    let n = args[1].parse().unwrap();\n-    let mut i = 0;\n-    while i < n { thread::spawn(move|| f(n) ); i += 1; }\n-}"}]}