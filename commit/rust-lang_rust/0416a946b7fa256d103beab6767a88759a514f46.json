{"sha": "0416a946b7fa256d103beab6767a88759a514f46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MTZhOTQ2YjdmYTI1NmQxMDNiZWFiNjc2N2E4ODc1OWE1MTRmNDY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-02T21:14:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-06T00:47:51Z"}, "message": "give user control of whether we use inline hint or inline always\n\nsupply inline hints for resource ctors/dtors", "tree": {"sha": "30d0764401d4e444cc70371184851974821b0c1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30d0764401d4e444cc70371184851974821b0c1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0416a946b7fa256d103beab6767a88759a514f46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0416a946b7fa256d103beab6767a88759a514f46", "html_url": "https://github.com/rust-lang/rust/commit/0416a946b7fa256d103beab6767a88759a514f46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0416a946b7fa256d103beab6767a88759a514f46/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc2ebfc1051380adf2832b2f81ae711abe3ef664", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc2ebfc1051380adf2832b2f81ae711abe3ef664", "html_url": "https://github.com/rust-lang/rust/commit/cc2ebfc1051380adf2832b2f81ae711abe3ef664"}], "stats": {"total": 90, "additions": 77, "deletions": 13}, "files": [{"sha": "4f4fecbe40957fb8867b6d4858f551a3b4764e49", "filename": "src/rustc/front/attr.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0416a946b7fa256d103beab6767a88759a514f46/src%2Frustc%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0416a946b7fa256d103beab6767a88759a514f46/src%2Frustc%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fattr.rs?ref=0416a946b7fa256d103beab6767a88759a514f46", "patch": "@@ -7,7 +7,8 @@ import driver::session::session;\n export attr_meta;\n export attr_metas;\n export find_linkage_metas;\n-export should_inline;\n+export inline_attr;\n+export find_inline_attr;\n export find_attrs_by_name;\n export attrs_contains_name;\n export find_meta_items_by_name;\n@@ -44,9 +45,28 @@ fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n     ret metas;\n }\n \n+enum inline_attr {\n+    ia_none,\n+    ia_hint,\n+    ia_always\n+}\n+\n // True if something like #[inline] is found in the list of attrs.\n-fn should_inline(attrs: [ast::attribute]) -> bool {\n-    attr::attrs_contains_name(attrs, \"inline\")\n+fn find_inline_attr(attrs: [ast::attribute]) -> inline_attr {\n+    // TODO---validate the usage of #[inline] and #[inline(always)]\n+    vec::foldl(ia_none, attrs) {|ia,attr|\n+        alt attr.node.value.node {\n+          ast::meta_word(\"inline\") { ia_hint }\n+          ast::meta_list(\"inline\", items) {\n+            if !vec::is_empty(find_meta_items_by_name(items, \"always\")) {\n+                ia_always\n+            } else {\n+                ia_hint\n+            }\n+          }\n+          _ { ia }\n+        }\n+    }\n }\n \n // Search a list of attributes and return only those with a specific name"}, {"sha": "cee46b2b05412279f944b765186879f67576ffa8", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0416a946b7fa256d103beab6767a88759a514f46/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0416a946b7fa256d103beab6767a88759a514f46/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=0416a946b7fa256d103beab6767a88759a514f46", "patch": "@@ -320,6 +320,14 @@ fn purity_fn_family(p: purity) -> char {\n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         &index: [entry<int>], path: ast_map::path) {\n+\n+    fn should_inline(attrs: [attribute]) -> bool {\n+        alt attr::find_inline_attr(attrs) {\n+          attr::ia_none { false }\n+          attr::ia_hint | attr::ia_always { true }\n+        }\n+    }\n+\n     let tcx = ecx.ccx.tcx;\n     alt item.node {\n       item_const(_, _) {\n@@ -339,7 +347,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        if attr::should_inline(item.attrs) {\n+        if should_inline(item.attrs) {\n             astencode::encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n         }\n         ebml_w.end_tag();\n@@ -442,7 +450,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_name(ebml_w, m.ident);\n             encode_symbol(ecx, ebml_w, m.id);\n             encode_path(ebml_w, impl_path, ast_map::path_name(m.ident));\n-            if attr::should_inline(m.attrs) {\n+            if should_inline(m.attrs) {\n                 astencode::encode_inlined_item(\n                     ecx, ebml_w, impl_path,\n                     ii_method(local_def(item.id), m));"}, {"sha": "b950ac03e49f7aa8e62a2128022b7fb1916beead", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0416a946b7fa256d103beab6767a88759a514f46/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0416a946b7fa256d103beab6767a88759a514f46/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=0416a946b7fa256d103beab6767a88759a514f46", "patch": "@@ -24,7 +24,7 @@ fn path_to_str(p: path) -> str {\n enum ast_node {\n     node_item(@item, @path),\n     node_native_item(@native_item, @path),\n-    node_method(@method, def_id, @path),\n+    node_method(@method, def_id /* impl did */, @path /* path to the impl */),\n     node_variant(variant, def_id, @path),\n     node_expr(@expr),\n     // Locals are numbered, because the alias analysis needs to know in which\n@@ -59,7 +59,8 @@ fn map_crate(c: crate) -> map {\n }\n \n // Used for items loaded from external crate that are being inlined into this\n-// crate:\n+// crate.  The `path` should be the path to the item but should not include\n+// the item itself.\n fn map_decoded_item(map: map, path: path, ii: inlined_item) {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n@@ -71,6 +72,18 @@ fn map_decoded_item(map: map, path: path, ii: inlined_item) {\n               mutable path: path,\n               mutable local_id: 0u};\n     let v = mk_ast_map_visitor();\n+\n+    // methods get added to the AST map when their impl is visited.  Since we\n+    // don't decode and instantiate the impl, but just the method, we have to\n+    // add it to the table now:\n+    alt ii {\n+      ii_item(i) { /* fallthrough */ }\n+      ii_method(impl_did, m) {\n+        map_method(impl_did, @vec::init(path), m, cx);\n+      }\n+    }\n+\n+    // visit the item / method contents and add those to the map:\n     ii.accept(cx, v);\n }\n \n@@ -105,16 +118,24 @@ fn map_arm(arm: arm, cx: ctx, v: vt) {\n     visit::visit_arm(arm, cx, v);\n }\n \n+fn map_method(impl_did: def_id, impl_path: @path,\n+              m: @method, cx: ctx) {\n+    cx.map.insert(m.id, node_method(m, impl_did, impl_path));\n+}\n+\n fn map_item(i: @item, cx: ctx, v: vt) {\n-    cx.map.insert(i.id, node_item(i, @cx.path));\n+    let item_path = @cx.path;\n+    cx.map.insert(i.id, node_item(i, item_path));\n     alt i.node {\n       item_impl(_, _, _, ms) {\n-        let implid = ast_util::local_def(i.id);\n-        for m in ms { cx.map.insert(m.id, node_method(m, implid, @cx.path)); }\n+        let impl_did = ast_util::local_def(i.id);\n+        for m in ms {\n+            map_method(impl_did, item_path, m, cx);\n+        }\n       }\n       item_res(_, _, _, dtor_id, ctor_id) {\n         cx.map.insert(ctor_id, node_res_ctor(i));\n-        cx.map.insert(dtor_id, node_item(i, @cx.path));\n+        cx.map.insert(dtor_id, node_item(i, item_path));\n       }\n       item_enum(vs, _) {\n         for v in vs {"}, {"sha": "c0e9847aba3e9ecd7ddc2a453fc85c5842f7e969", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0416a946b7fa256d103beab6767a88759a514f46/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0416a946b7fa256d103beab6767a88759a514f46/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0416a946b7fa256d103beab6767a88759a514f46", "patch": "@@ -654,8 +654,18 @@ fn set_inline_hint(f: ValueRef) {\n fn set_inline_hint_if_appr(ccx: crate_ctxt,\n                            attrs: [ast::attribute],\n                            id: ast::node_id) {\n-    if attr::should_inline(attrs) {\n-        set_inline_hint(ccx.item_ids.get(id));\n+    alt attr::find_inline_attr(attrs) {\n+      attr::ia_hint {\n+        #debug[\"Setting inline mode for %s to 'hint'\",\n+               ty::item_path_str(ccx.tcx, ast_util::local_def(id))];\n+        set_inline_hint(ccx.item_ids.get(id))\n+      }\n+      attr::ia_always {\n+        #debug[\"Setting inline mode for %s to 'always'\",\n+               ty::item_path_str(ccx.tcx, ast_util::local_def(id))];\n+        set_always_inline(ccx.item_ids.get(id))\n+      }\n+      attr::ia_none { /* fallthrough */ }\n     }\n }\n \n@@ -4724,13 +4734,18 @@ fn collect_item(ccx: crate_ctxt, abi: @mutable option<ast::native_abi>,\n       }\n       ast::item_res(_, tps, _, dtor_id, ctor_id) {\n         register_fn(ccx, i.span, my_path, \"res_ctor\", tps, ctor_id);\n+\n         // Note that the destructor is associated with the item's id, not\n         // the dtor_id. This is a bit counter-intuitive, but simplifies\n         // ty_res, which would have to carry around two def_ids otherwise\n         // -- one to identify the type, and one to find the dtor symbol.\n         let t = ty::node_id_to_type(ccx.tcx, dtor_id);\n         register_fn_full(ccx, i.span, my_path + [path_name(\"dtor\")],\n                          \"res_dtor\", param_bounds(ccx, tps), i.id, t);\n+\n+        // give hints that resource ctors/dtors ought to be inlined\n+        set_inline_hint(ccx.item_ids.get(ctor_id));\n+        set_inline_hint(ccx.item_ids.get(i.id));\n       }\n       ast::item_enum(variants, tps) {\n         for variant in variants {"}]}