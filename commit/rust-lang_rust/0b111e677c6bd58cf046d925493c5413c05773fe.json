{"sha": "0b111e677c6bd58cf046d925493c5413c05773fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMTExZTY3N2M2YmQ1OGNmMDQ2ZDkyNTQ5M2M1NDEzYzA1NzczZmU=", "commit": {"author": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-03-08T08:29:35Z"}, "committer": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-03-16T06:52:15Z"}, "message": "change &self to self and fix lifetime annotations", "tree": {"sha": "18681a91a9a6355c01b935a6b7f083baf8867646", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18681a91a9a6355c01b935a6b7f083baf8867646"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b111e677c6bd58cf046d925493c5413c05773fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b111e677c6bd58cf046d925493c5413c05773fe", "html_url": "https://github.com/rust-lang/rust/commit/0b111e677c6bd58cf046d925493c5413c05773fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b111e677c6bd58cf046d925493c5413c05773fe/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7170b0412d1baa4e30cb31d1ea326617021f086", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7170b0412d1baa4e30cb31d1ea326617021f086", "html_url": "https://github.com/rust-lang/rust/commit/a7170b0412d1baa4e30cb31d1ea326617021f086"}], "stats": {"total": 206, "additions": 119, "deletions": 87}, "files": [{"sha": "93d6247eeae47733af3b4f8833bbb248ceda400c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0b111e677c6bd58cf046d925493c5413c05773fe/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b111e677c6bd58cf046d925493c5413c05773fe/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=0b111e677c6bd58cf046d925493c5413c05773fe", "patch": "@@ -253,28 +253,28 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     used_mut_nodes: RefCell<FxHashSet<HirId>>,\n }\n \n-impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n-    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                         sp: S,\n-                                                         msg: &str,\n-                                                         code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'a>\n+impl<'a, 'b, 'tcx: 'b> BorrowckErrors<'a> for &'a BorrowckCtxt<'b, 'tcx> {\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n+                                                     sp: S,\n+                                                     msg: &str,\n+                                                     code: DiagnosticId)\n+                                                     -> DiagnosticBuilder<'a>\n     {\n         self.tcx.sess.struct_span_err_with_code(sp, msg, code)\n     }\n \n-    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n-                                               sp: S,\n-                                               msg: &str)\n-                                               -> DiagnosticBuilder<'a>\n+    fn struct_span_err<S: Into<MultiSpan>>(self,\n+                                           sp: S,\n+                                           msg: &str)\n+                                           -> DiagnosticBuilder<'a>\n     {\n         self.tcx.sess.struct_span_err(sp, msg)\n     }\n \n-    fn cancel_if_wrong_origin<'a>(&'a self,\n-                                mut diag: DiagnosticBuilder<'a>,\n-                                o: Origin)\n-                                -> DiagnosticBuilder<'a>\n+    fn cancel_if_wrong_origin(self,\n+                              mut diag: DiagnosticBuilder<'a>,\n+                              o: Origin)\n+                              -> DiagnosticBuilder<'a>\n     {\n         if !o.should_emit_errors(self.tcx.borrowck_mode()) {\n             self.tcx.sess.diagnostic().cancel(&mut diag);"}, {"sha": "48575584530c94150bfa76a8cece5f8f0d32761f", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 105, "deletions": 73, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/0b111e677c6bd58cf046d925493c5413c05773fe/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b111e677c6bd58cf046d925493c5413c05773fe/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=0b111e677c6bd58cf046d925493c5413c05773fe", "patch": "@@ -52,44 +52,49 @@ impl Origin {\n     }\n }\n \n-pub trait BorrowckErrors {\n-    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+pub trait BorrowckErrors<'cx> {\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n                                                          sp: S,\n                                                          msg: &str,\n                                                          code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'a>;\n+                                                         -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy;\n \n-    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n+    fn struct_span_err<S: Into<MultiSpan>>(self,\n                                                sp: S,\n                                                msg: &str)\n-                                               -> DiagnosticBuilder<'a>;\n+                                               -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy;\n \n     /// Cancels the given error if we shouldn't emit errors for a given\n     /// origin in the current mode.\n     ///\n     /// Always make sure that the error gets passed through this function\n     /// before you return it.\n-    fn cancel_if_wrong_origin<'a>(&'a self,\n-                                diag: DiagnosticBuilder<'a>,\n+    fn cancel_if_wrong_origin(self,\n+                                diag: DiagnosticBuilder<'cx>,\n                                 o: Origin)\n-                                -> DiagnosticBuilder<'a>;\n+                                -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy;\n \n-    fn cannot_move_when_borrowed(&self, span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder<'_>\n+    fn cannot_move_when_borrowed(self, span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let err = struct_span_err!(self, span, E0505,\n                                    \"cannot move out of `{}` because it is borrowed{OGN}\",\n                                    desc, OGN=o);\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_use_when_mutably_borrowed(&self,\n+    fn cannot_use_when_mutably_borrowed(self,\n                                         span: Span,\n                                         desc: &str,\n                                         borrow_span: Span,\n                                         borrow_desc: &str,\n                                         o: Origin)\n-                                        -> DiagnosticBuilder<'_>\n+                                        -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self, span, E0503,\n                          \"cannot use `{}` because it was mutably borrowed{OGN}\",\n@@ -101,28 +106,30 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_uninitialized_variable(&self,\n+    fn cannot_act_on_uninitialized_variable(self,\n                                             span: Span,\n                                             verb: &str,\n                                             desc: &str,\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let err = struct_span_err!(self, span, E0381,\n                                    \"{} of possibly uninitialized variable: `{}`{OGN}\",\n                                    verb, desc, OGN=o);\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_mutably_borrow_multiply(&self,\n+    fn cannot_mutably_borrow_multiply(self,\n                                       new_loan_span: Span,\n                                       desc: &str,\n                                       opt_via: &str,\n                                       old_loan_span: Span,\n                                       old_opt_via: &str,\n                                       old_load_end_span: Option<Span>,\n                                       o: Origin)\n-                                      -> DiagnosticBuilder\n+                                      -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0499,\n                          \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n@@ -148,13 +155,14 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_uniquely_borrow_by_two_closures(&self,\n+    fn cannot_uniquely_borrow_by_two_closures(self,\n                                               new_loan_span: Span,\n                                               desc: &str,\n                                               old_loan_span: Span,\n                                               old_load_end_span: Option<Span>,\n                                               o: Origin)\n-                                              -> DiagnosticBuilder\n+                                              -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0524,\n                          \"two closures require unique access to `{}` at the same time{OGN}\",\n@@ -173,7 +181,7 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_uniquely_borrow_by_one_closure(&self,\n+    fn cannot_uniquely_borrow_by_one_closure(self,\n                                              new_loan_span: Span,\n                                              desc_new: &str,\n                                              opt_via: &str,\n@@ -182,7 +190,8 @@ pub trait BorrowckErrors {\n                                              old_opt_via: &str,\n                                              previous_end_span: Option<Span>,\n                                              o: Origin)\n-                                             -> DiagnosticBuilder\n+                                             -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0500,\n                          \"closure requires unique access to `{}` but {} is already borrowed{}{OGN}\",\n@@ -197,7 +206,7 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reborrow_already_uniquely_borrowed(&self,\n+    fn cannot_reborrow_already_uniquely_borrowed(self,\n                                                  new_loan_span: Span,\n                                                  desc_new: &str,\n                                                  opt_via: &str,\n@@ -206,7 +215,8 @@ pub trait BorrowckErrors {\n                                                  old_opt_via: &str,\n                                                  previous_end_span: Option<Span>,\n                                                  o: Origin)\n-                                                 -> DiagnosticBuilder\n+                                                 -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0501,\n                          \"cannot borrow `{}`{} as {} because previous closure \\\n@@ -222,7 +232,7 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reborrow_already_borrowed(&self,\n+    fn cannot_reborrow_already_borrowed(self,\n                                         span: Span,\n                                         desc_new: &str,\n                                         msg_new: &str,\n@@ -233,7 +243,8 @@ pub trait BorrowckErrors {\n                                         msg_old: &str,\n                                         old_load_end_span: Option<Span>,\n                                         o: Origin)\n-                                        -> DiagnosticBuilder\n+                                        -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self, span, E0502,\n                          \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n@@ -246,8 +257,9 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_to_borrowed(&self, span: Span, borrow_span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder\n+    fn cannot_assign_to_borrowed(self, span: Span, borrow_span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self, span, E0506,\n                          \"cannot assign to `{}` because it is borrowed{OGN}\",\n@@ -259,8 +271,9 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_into_closure(&self, span: Span, desc: &str, o: Origin)\n-                                -> DiagnosticBuilder\n+    fn cannot_move_into_closure(self, span: Span, desc: &str, o: Origin)\n+                                -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let err = struct_span_err!(self, span, E0504,\n                                    \"cannot move `{}` into closure because it is borrowed{OGN}\",\n@@ -269,8 +282,9 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reassign_immutable(&self, span: Span, desc: &str, is_arg: bool, o: Origin)\n-                                 -> DiagnosticBuilder\n+    fn cannot_reassign_immutable(self, span: Span, desc: &str, is_arg: bool, o: Origin)\n+                                 -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let msg = if is_arg {\n             \"to immutable argument\"\n@@ -284,22 +298,25 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign(&self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder\n+    fn cannot_assign(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let err = struct_span_err!(self, span, E0594,\n                                   \"cannot assign to {}{OGN}\",\n                                   desc, OGN=o);\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_static(&self, span: Span, desc: &str, o: Origin)\n-                            -> DiagnosticBuilder\n+    fn cannot_assign_static(self, span: Span, desc: &str, o: Origin)\n+                            -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         self.cannot_assign(span, &format!(\"immutable static item `{}`\", desc), o)\n     }\n \n-    fn cannot_move_out_of(&self, move_from_span: Span, move_from_desc: &str, o: Origin)\n-                          -> DiagnosticBuilder\n+    fn cannot_move_out_of(self, move_from_span: Span, move_from_desc: &str, o: Origin)\n+                          -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self, move_from_span, E0507,\n                                        \"cannot move out of {}{OGN}\",\n@@ -311,12 +328,13 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_out_of_interior_noncopy(&self,\n+    fn cannot_move_out_of_interior_noncopy(self,\n                                            move_from_span: Span,\n                                            ty: ty::Ty,\n                                            is_index: bool,\n                                            o: Origin)\n-                                           -> DiagnosticBuilder\n+                                           -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let type_name = match (&ty.sty, is_index) {\n             (&ty::TyArray(_, _), true) => \"array\",\n@@ -332,11 +350,12 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_out_of_interior_of_drop(&self,\n+    fn cannot_move_out_of_interior_of_drop(self,\n                                            move_from_span: Span,\n                                            container_ty: ty::Ty,\n                                            o: Origin)\n-                                           -> DiagnosticBuilder\n+                                           -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self, move_from_span, E0509,\n                                        \"cannot move out of type `{}`, \\\n@@ -347,13 +366,14 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_moved_value(&self,\n+    fn cannot_act_on_moved_value(self,\n                                  use_span: Span,\n                                  verb: &str,\n                                  optional_adverb_for_moved: &str,\n                                  moved_path: &str,\n                                  o: Origin)\n-                                 -> DiagnosticBuilder\n+                                 -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let err = struct_span_err!(self, use_span, E0382,\n                                    \"{} of {}moved value: `{}`{OGN}\",\n@@ -362,11 +382,12 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_partially_reinit_an_uninit_struct(&self,\n+    fn cannot_partially_reinit_an_uninit_struct(self,\n                                                 span: Span,\n                                                 uninit_path: &str,\n                                                 o: Origin)\n-                                                -> DiagnosticBuilder\n+                                                -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let err = struct_span_err!(self,\n                                    span,\n@@ -377,35 +398,38 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn closure_cannot_assign_to_borrowed(&self,\n+    fn closure_cannot_assign_to_borrowed(self,\n                                          span: Span,\n                                          descr: &str,\n                                          o: Origin)\n-                                         -> DiagnosticBuilder\n+                                         -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}{OGN}\",\n                                    descr, OGN=o);\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_path_as_mutable(&self,\n+    fn cannot_borrow_path_as_mutable(self,\n                                      span: Span,\n                                      path: &str,\n                                      o: Origin)\n-                                     -> DiagnosticBuilder\n+                                     -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{OGN}\",\n                                    path, OGN=o);\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_across_generator_yield(&self,\n+    fn cannot_borrow_across_generator_yield(self,\n                                             span: Span,\n                                             yield_span: Span,\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self,\n                                        span,\n@@ -417,23 +441,25 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn path_does_not_live_long_enough(&self,\n+    fn path_does_not_live_long_enough(self,\n                                       span: Span,\n                                       path: &str,\n                                       o: Origin)\n-                                      -> DiagnosticBuilder\n+                                      -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let err = struct_span_err!(self, span, E0597, \"{} does not live long enough{OGN}\",\n                                    path, OGN=o);\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn lifetime_too_short_for_reborrow(&self,\n+    fn lifetime_too_short_for_reborrow(self,\n                                        span: Span,\n                                        path: &str,\n                                        o: Origin)\n-                                       -> DiagnosticBuilder\n+                                       -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let err = struct_span_err!(self, span, E0598,\n                                    \"lifetime of {} is too short to guarantee \\\n@@ -443,12 +469,13 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_capture_in_sharable_fn(&self,\n+    fn cannot_act_on_capture_in_sharable_fn(self,\n                                             span: Span,\n                                             bad_thing: &str,\n                                             help: (Span, &str),\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let (help_span, help_msg) = help;\n         let mut err = struct_span_err!(self, span, E0387,\n@@ -459,11 +486,12 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_into_immutable_reference(&self,\n+    fn cannot_assign_into_immutable_reference(self,\n                                               span: Span,\n                                               bad_thing: &str,\n                                               o: Origin)\n-                                              -> DiagnosticBuilder\n+                                              -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference{OGN}\",\n                                        bad_thing, OGN=o);\n@@ -472,12 +500,13 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_capture_in_long_lived_closure(&self,\n+    fn cannot_capture_in_long_lived_closure(self,\n                                             closure_span: Span,\n                                             borrowed_path: &str,\n                                             capture_span: Span,\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         let mut err = struct_span_err!(self, closure_span, E0373,\n                                        \"closure may outlive the current function, \\\n@@ -491,28 +520,31 @@ pub trait BorrowckErrors {\n     }\n }\n \n-impl<'b, 'gcx, 'tcx> BorrowckErrors for TyCtxt<'b, 'gcx, 'tcx> {\n-    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                         sp: S,\n-                                                         msg: &str,\n-                                                         code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'a>\n+impl<'cx, 'gcx, 'tcx> BorrowckErrors<'cx> for TyCtxt<'cx, 'gcx, 'tcx> {\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n+                                                     sp: S,\n+                                                     msg: &str,\n+                                                     code: DiagnosticId)\n+                                                     -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         self.sess.struct_span_err_with_code(sp, msg, code)\n     }\n \n-    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n-                                               sp: S,\n-                                               msg: &str)\n-                                               -> DiagnosticBuilder<'a>\n+    fn struct_span_err<S: Into<MultiSpan>>(self,\n+                                           sp: S,\n+                                           msg: &str)\n+                                           -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         self.sess.struct_span_err(sp, msg)\n     }\n \n-    fn cancel_if_wrong_origin<'a>(&'a self,\n-                                mut diag: DiagnosticBuilder<'a>,\n-                                o: Origin)\n-                                -> DiagnosticBuilder<'a>\n+    fn cancel_if_wrong_origin(self,\n+                              mut diag: DiagnosticBuilder<'cx>,\n+                              o: Origin)\n+                              -> DiagnosticBuilder<'cx>\n+        where Self: Sized + Copy\n     {\n         if !o.should_emit_errors(self.borrowck_mode()) {\n             self.sess.diagnostic().cancel(&mut diag);"}]}