{"sha": "a39d4fc68472ed7a512a7de93f422d7697d92e06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzOWQ0ZmM2ODQ3MmVkN2E1MTJhN2RlOTNmNDIyZDc2OTdkOTJlMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-07T15:25:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-07T15:25:09Z"}, "message": "Auto merge of #25013 - pnkfelix:span_to_lines-oflo, r=huonw\n\nGuard against overflow in `codemap::span_to_lines`.\r\n\r\n(Revised/expanded version of PR #24976)\r\n\r\nMake `span_to_lines` to return a `Result`.\r\n\r\nIn `diagnostic`, catch `Err` from `span_to_lines` and print `\"(unprintable span)\"` instead.\r\n\r\n----\r\n\r\nThere a number of recent issues that report the bug here.  See e.g. #24761 and #24954.\r\n\r\nThis change *might* fix them. However, that is *not* its main goal. The main goals are:\r\n\r\n 1. Make it possible for callers to recover from an error here, and\r\n\r\n 2. Insert a more conservative check, in that we are also checking that the files match up.\r\n\r\n----\r\n\r\nAs a drive-by, fix #24997 , which was causing my attempts to `make check-stage1` on an `--enable-debug` build to fail.", "tree": {"sha": "fa4c4c0162d793699b5bae9bf7f8dc4ee5eafd40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa4c4c0162d793699b5bae9bf7f8dc4ee5eafd40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a39d4fc68472ed7a512a7de93f422d7697d92e06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a39d4fc68472ed7a512a7de93f422d7697d92e06", "html_url": "https://github.com/rust-lang/rust/commit/a39d4fc68472ed7a512a7de93f422d7697d92e06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a39d4fc68472ed7a512a7de93f422d7697d92e06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05d5fcaa5ba0c385e1dc97037c89fae437634fc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/05d5fcaa5ba0c385e1dc97037c89fae437634fc3", "html_url": "https://github.com/rust-lang/rust/commit/05d5fcaa5ba0c385e1dc97037c89fae437634fc3"}, {"sha": "939e4c9ea9e63b4da1033d66a72a044279036e6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/939e4c9ea9e63b4da1033d66a72a044279036e6f", "html_url": "https://github.com/rust-lang/rust/commit/939e4c9ea9e63b4da1033d66a72a044279036e6f"}], "stats": {"total": 83, "additions": 69, "deletions": 14}, "files": [{"sha": "56dee3034870c426b735a18435c40555b995bed1", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a39d4fc68472ed7a512a7de93f422d7697d92e06/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39d4fc68472ed7a512a7de93f422d7697d92e06/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=a39d4fc68472ed7a512a7de93f422d7697d92e06", "patch": "@@ -631,8 +631,14 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n }\n \n \n-// Use macro to be generic over const/mut\n-macro_rules! slice_offset {\n+// Use macros to be generic over const/mut\n+//\n+// They require non-negative `$by` because otherwise the expression\n+// `(ptr as usize + $by)` would interpret `-1` as `usize::MAX` (and\n+// thus trigger a panic when overflow checks are on).\n+\n+// Use this to do `$ptr + $by`, where `$by` is non-negative.\n+macro_rules! slice_add_offset {\n     ($ptr:expr, $by:expr) => {{\n         let ptr = $ptr;\n         if size_from_ptr(ptr) == 0 {\n@@ -643,6 +649,18 @@ macro_rules! slice_offset {\n     }};\n }\n \n+// Use this to do `$ptr - $by`, where `$by` is non-negative.\n+macro_rules! slice_sub_offset {\n+    ($ptr:expr, $by:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            transmute(ptr as usize - $by)\n+        } else {\n+            ptr.offset(-$by)\n+        }\n+    }};\n+}\n+\n macro_rules! slice_ref {\n     ($ptr:expr) => {{\n         let ptr = $ptr;\n@@ -672,7 +690,7 @@ macro_rules! iterator {\n                         None\n                     } else {\n                         let old = self.ptr;\n-                        self.ptr = slice_offset!(self.ptr, 1);\n+                        self.ptr = slice_add_offset!(self.ptr, 1);\n                         Some(slice_ref!(old))\n                     }\n                 }\n@@ -714,7 +732,7 @@ macro_rules! iterator {\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        self.end = slice_offset!(self.end, -1);\n+                        self.end = slice_sub_offset!(self.end, 1);\n                         Some(slice_ref!(self.end))\n                     }\n                 }\n@@ -776,7 +794,7 @@ impl<'a, T> Iter<'a, T> {\n     fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n         match self.as_slice().get(n) {\n             Some(elem_ref) => unsafe {\n-                self.ptr = slice_offset!(elem_ref as *const _, 1);\n+                self.ptr = slice_add_offset!(elem_ref as *const _, 1);\n                 Some(slice_ref!(elem_ref))\n             },\n             None => {\n@@ -849,7 +867,7 @@ impl<'a, T> IterMut<'a, T> {\n     fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n         match make_mut_slice!(T => &'a mut [T]: self.ptr, self.end).get_mut(n) {\n             Some(elem_ref) => unsafe {\n-                self.ptr = slice_offset!(elem_ref as *mut _, 1);\n+                self.ptr = slice_add_offset!(elem_ref as *mut _, 1);\n                 Some(slice_ref!(elem_ref))\n             },\n             None => {"}, {"sha": "348bf6f51bb7c5a90ce4498b4916458741121c1d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a39d4fc68472ed7a512a7de93f422d7697d92e06/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39d4fc68472ed7a512a7de93f422d7697d92e06/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a39d4fc68472ed7a512a7de93f422d7697d92e06", "patch": "@@ -663,9 +663,22 @@ impl CodeMap {\n         self.lookup_char_pos(sp.lo).file.name.to_string()\n     }\n \n-    pub fn span_to_lines(&self, sp: Span) -> FileLines {\n+    pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n+        if sp.lo > sp.hi {\n+            return Err(SpanLinesError::IllFormedSpan(sp));\n+        }\n+\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n+\n+        if lo.file.start_pos != hi.file.start_pos {\n+            return Err(SpanLinesError::DistinctSources(DistinctSources {\n+                begin: (lo.file.name.clone(), lo.file.start_pos),\n+                end: (hi.file.name.clone(), hi.file.start_pos),\n+            }));\n+        }\n+        assert!(hi.line >= lo.line);\n+\n         let mut lines = Vec::with_capacity(hi.line - lo.line + 1);\n \n         // The span starts partway through the first line,\n@@ -689,7 +702,7 @@ impl CodeMap {\n                               start_col: start_col,\n                               end_col: hi.col });\n \n-        FileLines {file: lo.file, lines: lines}\n+        Ok(FileLines {file: lo.file, lines: lines})\n     }\n \n     pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n@@ -914,9 +927,17 @@ impl CodeMap {\n }\n \n // _____________________________________________________________________________\n-// SpanSnippetError, DistinctSources, MalformedCodemapPositions\n+// SpanLinesError, SpanSnippetError, DistinctSources, MalformedCodemapPositions\n //\n \n+pub type FileLinesResult = Result<FileLines, SpanLinesError>;\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum SpanLinesError {\n+    IllFormedSpan(Span),\n+    DistinctSources(DistinctSources),\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum SpanSnippetError {\n     IllFormedSpan(Span),\n@@ -1082,7 +1103,7 @@ mod tests {\n         // Test span_to_lines for a span ending at the end of filemap\n         let cm = init_code_map();\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n-        let file_lines = cm.span_to_lines(span);\n+        let file_lines = cm.span_to_lines(span).unwrap();\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n         assert_eq!(file_lines.lines.len(), 1);\n@@ -1127,7 +1148,7 @@ mod tests {\n         assert_eq!(&cm.span_to_snippet(span).unwrap(), \"BB\\nCCC\\nDDDDD\");\n \n         // check that span_to_lines gives us the complete result with the lines/cols we expected\n-        let lines = cm.span_to_lines(span);\n+        let lines = cm.span_to_lines(span).unwrap();\n         let expected = vec![\n             LineInfo { line_index: 1, start_col: CharPos(4), end_col: CharPos(6) },\n             LineInfo { line_index: 2, start_col: CharPos(0), end_col: CharPos(3) },"}, {"sha": "aa649b4d99ac5fa291a393435b4da3227202f5a5", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a39d4fc68472ed7a512a7de93f422d7697d92e06/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39d4fc68472ed7a512a7de93f422d7697d92e06/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=a39d4fc68472ed7a512a7de93f422d7697d92e06", "patch": "@@ -522,7 +522,7 @@ fn highlight_suggestion(err: &mut EmitterWriter,\n                         suggestion: &str)\n                         -> io::Result<()>\n {\n-    let lines = cm.span_to_lines(sp);\n+    let lines = cm.span_to_lines(sp).unwrap();\n     assert!(!lines.lines.is_empty());\n \n     // To build up the result, we want to take the snippet from the first\n@@ -567,9 +567,17 @@ fn highlight_lines(err: &mut EmitterWriter,\n                    cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: codemap::FileLines)\n+                   lines: codemap::FileLinesResult)\n                    -> io::Result<()>\n {\n+    let lines = match lines {\n+        Ok(lines) => lines,\n+        Err(_) => {\n+            try!(write!(&mut err.dst, \"(internal compiler error: unprintable span)\\n\"));\n+            return Ok(());\n+        }\n+    };\n+\n     let fm = &*lines.file;\n \n     let line_strings: Option<Vec<&str>> =\n@@ -690,8 +698,16 @@ fn end_highlight_lines(w: &mut EmitterWriter,\n                           cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n-                          lines: codemap::FileLines)\n+                          lines: codemap::FileLinesResult)\n                           -> io::Result<()> {\n+    let lines = match lines {\n+        Ok(lines) => lines,\n+        Err(_) => {\n+            try!(write!(&mut w.dst, \"(internal compiler error: unprintable span)\\n\"));\n+            return Ok(());\n+        }\n+    };\n+\n     let fm = &*lines.file;\n \n     let lines = &lines.lines[..];"}]}