{"sha": "e4e7aa28566d062514a7a1f5534d76b9d82f524a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZTdhYTI4NTY2ZDA2MjUxNGE3YTFmNTUzNGQ3NmI5ZDgyZjUyNGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-16T16:38:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-16T16:38:51Z"}, "message": "Auto merge of #21744 - eddyb:rvalue-promotion, r=nikomatsakis\n\nThis includes everything necessary for promoting borrows of constant rvalues to `'static`.\r\nThat is, `&expr` will have the type `&'static T` if `const T: &'static T = &expr;` is valid.\r\nThere is a small exception, dereferences of raw pointers, as they misbehave.\r\nThey still \"work\" in constants as I didn't want to break legitimate uses (are there any?).\r\n\r\nThe qualification done here can be expanded to allow simple CTFE via `const fn`.", "tree": {"sha": "55a2ef204f3faf8da57c84317fd2ca3e9bae80f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55a2ef204f3faf8da57c84317fd2ca3e9bae80f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4e7aa28566d062514a7a1f5534d76b9d82f524a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4e7aa28566d062514a7a1f5534d76b9d82f524a", "html_url": "https://github.com/rust-lang/rust/commit/e4e7aa28566d062514a7a1f5534d76b9d82f524a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4e7aa28566d062514a7a1f5534d76b9d82f524a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5db290bf6df986a6acd5ce993f278c18e55ca37", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5db290bf6df986a6acd5ce993f278c18e55ca37", "html_url": "https://github.com/rust-lang/rust/commit/c5db290bf6df986a6acd5ce993f278c18e55ca37"}, {"sha": "b49f5281c2125eec67a9c671dae3ba6fb271611a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b49f5281c2125eec67a9c671dae3ba6fb271611a", "html_url": "https://github.com/rust-lang/rust/commit/b49f5281c2125eec67a9c671dae3ba6fb271611a"}], "stats": {"total": 3546, "additions": 1898, "deletions": 1648}, "files": [{"sha": "f4d3e975b75b9e25d187a4fe64e8c86a1608c9eb", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -134,7 +134,11 @@ pub trait Reseeder<R> {\n /// Reseed an RNG using a `Default` instance. This reseeds by\n /// replacing the RNG with the result of a `Default::default` call.\n #[derive(Copy)]\n-pub struct ReseedWithDefault;\n+pub struct ReseedWithDefault { __hack: [u8; 0] }\n+// FIXME(#21721) used to be an unit struct but that can cause\n+// certain LLVM versions to abort during optimizations.\n+#[allow(non_upper_case_globals)]\n+pub const ReseedWithDefault: ReseedWithDefault = ReseedWithDefault { __hack: [] };\n \n impl<R: Rng + Default> Reseeder<R> for ReseedWithDefault {\n     fn reseed(&mut self, rng: &mut R) {"}, {"sha": "133bef30e4083afba1d8d9f2c7f09895e28b3770", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -59,6 +59,7 @@ register_diagnostics! {\n     E0010,\n     E0011,\n     E0012,\n+    E0013,\n     E0014,\n     E0015,\n     E0016,"}, {"sha": "abf70813d36e783d3d25193c2b9f2e27874f65f1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -90,7 +90,6 @@ pub mod middle {\n     pub mod check_loop;\n     pub mod check_match;\n     pub mod check_rvalues;\n-    pub mod check_static;\n     pub mod const_eval;\n     pub mod dataflow;\n     pub mod dead;"}, {"sha": "08db053d3f4ac8498b5f969010c65050699e55f1", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -199,7 +199,7 @@ impl LintPass for TypeLimits {\n                             if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n                             else { false }\n                         } else {\n-                            match eval_const_expr_partial(cx.tcx, &**r) {\n+                            match eval_const_expr_partial(cx.tcx, &**r, Some(cx.tcx.types.uint)) {\n                                 Ok(const_int(shift)) => { shift as u64 >= bits },\n                                 Ok(const_uint(shift)) => { shift >= bits },\n                                 _ => { false }"}, {"sha": "4930eddb35a53213ebad184791eebf6c9b4d8713", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -12,7 +12,6 @@\n \n pub use self::astencode_tag::*;\n \n-use std::mem;\n use back::svh::Svh;\n \n // EBML enum definitions and utils shared by the encoder and decoder\n@@ -113,7 +112,7 @@ pub const tag_items_data_item_reexport_def_id: uint = 0x39;\n pub const tag_items_data_item_reexport_name: uint = 0x3a;\n \n // used to encode crate_ctxt side tables\n-#[derive(Copy, PartialEq)]\n+#[derive(Copy, PartialEq, FromPrimitive)]\n #[repr(uint)]\n pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_ast = 0x40,\n@@ -144,17 +143,7 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_upvar_capture_map = 0x56,\n     tag_table_capture_modes = 0x57,\n     tag_table_object_cast_map = 0x58,\n-}\n-\n-static first_astencode_tag: uint = tag_ast as uint;\n-static last_astencode_tag: uint = tag_table_object_cast_map as uint;\n-impl astencode_tag {\n-    pub fn from_uint(value : uint) -> Option<astencode_tag> {\n-        let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;\n-        if !is_a_tag { None } else {\n-            Some(unsafe { mem::transmute::<uint, astencode_tag>(value) })\n-        }\n-    }\n+    tag_table_const_qualif = 0x59,\n }\n \n pub const tag_item_trait_item_sort: uint = 0x60;"}, {"sha": "c3302debdfaff0e545e9aea32bc210159b75ea0e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -23,6 +23,7 @@ use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n+use middle::check_const::ConstQualif;\n use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n@@ -38,6 +39,7 @@ use syntax::ptr::P;\n use syntax;\n \n use std::old_io::Seek;\n+use std::num::FromPrimitive;\n use std::rc::Rc;\n \n use rbml::io::SeekableMemWriter;\n@@ -1305,6 +1307,15 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             })\n         })\n     }\n+\n+    for &qualif in tcx.const_qualif_map.borrow().get(&id).iter() {\n+        rbml_w.tag(c::tag_table_const_qualif, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                qualif.encode(rbml_w).unwrap()\n+            })\n+        })\n+    }\n }\n \n trait doc_decoder_helpers {\n@@ -1836,8 +1847,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n         debug!(\">> Side table document with tag 0x{:x} \\\n                 found for id {} (orig {})\",\n                tag, id, id0);\n-\n-        match c::astencode_tag::from_uint(tag) {\n+        let decoded_tag: Option<c::astencode_tag> = FromPrimitive::from_uint(tag);\n+        match decoded_tag {\n             None => {\n                 dcx.tcx.sess.bug(\n                     &format!(\"unknown tag found in side tables: {:x}\",\n@@ -1919,6 +1930,10 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         dcx.tcx.closure_kinds.borrow_mut().insert(ast_util::local_def(id),\n                                                                   closure_kind);\n                     }\n+                    c::tag_table_const_qualif => {\n+                        let qualif: ConstQualif = Decodable::decode(val_dsr).unwrap();\n+                        dcx.tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n+                    }\n                     _ => {\n                         dcx.tcx.sess.bug(\n                             &format!(\"unknown tag found in side tables: {:x}\","}, {"sha": "41d425cd2f6652c54c579f30672dfb4dbf2b734a", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 629, "deletions": 87, "changes": 716, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,91 +8,414 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Verifies that the types and values of const and static items\n+// are safe. The rules enforced by this module are:\n+//\n+// - For each *mutable* static item, it checks that its **type**:\n+//     - doesn't have a destructor\n+//     - doesn't own an owned pointer\n+//\n+// - For each *immutable* static item, it checks that its **value**:\n+//       - doesn't own owned, managed pointers\n+//       - doesn't contain a struct literal or a call to an enum variant / struct constructor where\n+//           - the type of the struct/enum has a dtor\n+//\n+// Rules Enforced Elsewhere:\n+// - It's not possible to take the address of a static item with unsafe interior. This is enforced\n+// by borrowck::gather_loans\n \n-use middle::def::*;\n-use middle::ty;\n+use middle::const_eval;\n+use middle::def;\n+use middle::expr_use_visitor as euv;\n+use middle::infer;\n+use middle::mem_categorization as mc;\n+use middle::traits;\n+use middle::ty::{self, Ty};\n+use util::nodemap::NodeMap;\n use util::ppaux;\n \n use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::print::pprust;\n use syntax::visit::{self, Visitor};\n \n+use std::collections::hash_map::Entry;\n+\n+// Const qualification, from partial to completely promotable.\n+bitflags! {\n+    #[derive(RustcEncodable, RustcDecodable)]\n+    flags ConstQualif: u8 {\n+        // Const rvalue which can be placed behind a reference.\n+        const PURE_CONST          = 0b000000,\n+        // Inner mutability (can not be placed behind a reference) or behind\n+        // &mut in a non-global expression. Can be copied from static memory.\n+        const MUTABLE_MEM         = 0b000001,\n+        // Constant value with a type that implements Drop. Can be copied\n+        // from static memory, similar to MUTABLE_MEM.\n+        const NEEDS_DROP          = 0b000010,\n+        // Even if the value can be placed in static memory, copying it from\n+        // there is more expensive than in-place instantiation, and/or it may\n+        // be too large. This applies to [T; N] and everything containing it.\n+        // N.B.: references need to clear this flag to not end up on the stack.\n+        const PREFER_IN_PLACE     = 0b000100,\n+        // May use more than 0 bytes of memory, doesn't impact the constness\n+        // directly, but is not allowed to be borrowed mutably in a constant.\n+        const NON_ZERO_SIZED      = 0b001000,\n+        // Actually borrowed, has to always be in static memory. Does not\n+        // propagate, and requires the expression to behave like a 'static\n+        // lvalue. The set of expressions with this flag is the minimum\n+        // that have to be promoted.\n+        const HAS_STATIC_BORROWS  = 0b010000,\n+        // Invalid const for miscellaneous reasons (e.g. not implemented).\n+        const NOT_CONST           = 0b100000,\n+\n+        // Borrowing the expression won't produce &'static T if any of these\n+        // bits are set, though the value could be copied from static memory\n+        // if `NOT_CONST` isn't set.\n+        const NON_STATIC_BORROWS = MUTABLE_MEM.bits | NEEDS_DROP.bits | NOT_CONST.bits\n+    }\n+}\n+\n+#[derive(Copy, Eq, PartialEq)]\n+enum Mode {\n+    Const,\n+    Static,\n+    StaticMut,\n+\n+    // An expression that occurs outside of any constant context\n+    // (i.e. `const`, `static`, array lengths, etc.). The value\n+    // can be variable at runtime, but will be promotable to\n+    // static memory if we can prove it is actually constant.\n+    Var,\n+}\n+\n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    in_const: bool\n+    mode: Mode,\n+    qualif: ConstQualif,\n+    rvalue_borrows: NodeMap<ast::Mutability>\n }\n \n impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n-    fn with_const<F>(&mut self, in_const: bool, f: F) where\n-        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n+    fn with_mode<F, R>(&mut self, mode: Mode, f: F) -> R where\n+        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>) -> R,\n     {\n-        let was_const = self.in_const;\n-        self.in_const = in_const;\n-        f(self);\n-        self.in_const = was_const;\n+        let (old_mode, old_qualif) = (self.mode, self.qualif);\n+        self.mode = mode;\n+        self.qualif = PURE_CONST;\n+        let r = f(self);\n+        self.mode = old_mode;\n+        self.qualif = old_qualif;\n+        r\n     }\n-    fn inside_const<F>(&mut self, f: F) where\n-        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n+\n+    fn with_euv<'b, F, R>(&'b mut self, item_id: Option<ast::NodeId>, f: F) -> R where\n+        F: for<'t> FnOnce(&mut euv::ExprUseVisitor<'b, 't, 'tcx,\n+                                    ty::ParameterEnvironment<'a, 'tcx>>) -> R,\n     {\n-        self.with_const(true, f);\n+        let param_env = match item_id {\n+            Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n+            None => ty::empty_parameter_environment(self.tcx)\n+        };\n+        f(&mut euv::ExprUseVisitor::new(self, &param_env))\n+    }\n+\n+    fn global_expr(&mut self, mode: Mode, expr: &ast::Expr) -> ConstQualif {\n+        assert!(mode != Mode::Var);\n+        match self.tcx.const_qualif_map.borrow_mut().entry(expr.id) {\n+            Entry::Occupied(entry) => return *entry.get(),\n+            Entry::Vacant(entry) => {\n+                // Prevent infinite recursion on re-entry.\n+                entry.insert(PURE_CONST);\n+            }\n+        }\n+        self.with_mode(mode, |this| {\n+            this.with_euv(None, |euv| euv.consume_expr(expr));\n+            this.visit_expr(expr);\n+            this.qualif\n+        })\n+    }\n+\n+    fn add_qualif(&mut self, qualif: ConstQualif) {\n+        self.qualif = self.qualif | qualif;\n+    }\n+\n+    fn record_borrow(&mut self, id: ast::NodeId, mutbl: ast::Mutability) {\n+        match self.rvalue_borrows.entry(id) {\n+            Entry::Occupied(mut entry) => {\n+                // Merge the two borrows, taking the most demanding\n+                // one, mutability-wise.\n+                if mutbl == ast::MutMutable {\n+                    entry.insert(mutbl);\n+                }\n+            }\n+            Entry::Vacant(entry) => {\n+                entry.insert(mutbl);\n+            }\n+        }\n+    }\n+\n+    fn msg(&self) -> &'static str {\n+        match self.mode {\n+            Mode::Const => \"constant\",\n+            Mode::StaticMut | Mode::Static => \"static\",\n+            Mode::Var => unreachable!(),\n+        }\n+    }\n+\n+    fn check_static_mut_type(&self, e: &ast::Expr) {\n+        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n+        let tcontents = ty::type_contents(self.tcx, node_ty);\n+\n+        let suffix = if tcontents.has_dtor() {\n+            \"destructors\"\n+        } else if tcontents.owns_owned() {\n+            \"owned pointers\"\n+        } else {\n+            return\n+        };\n+\n+        self.tcx.sess.span_err(e.span, &format!(\"mutable statics are not allowed \\\n+                                                 to have {}\", suffix)[]);\n+    }\n+\n+    fn check_static_type(&self, e: &ast::Expr) {\n+        let ty = ty::node_id_to_type(self.tcx, e.id);\n+        let infcx = infer::new_infer_ctxt(self.tcx);\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n+        fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n+        let env = ty::empty_parameter_environment(self.tcx);\n+        match fulfill_cx.select_all_or_error(&infcx, &env) {\n+            Ok(()) => { },\n+            Err(ref errors) => {\n+                traits::report_fulfillment_errors(&infcx, errors);\n+            }\n+        }\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n+        debug!(\"visit_item(item={})\", pprust::item_to_string(i));\n         match i.node {\n-            ast::ItemStatic(_, _, ref ex) |\n-            ast::ItemConst(_, ref ex) => {\n-                self.inside_const(|v| v.visit_expr(&**ex));\n+            ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n+                self.check_static_type(&**expr);\n+                self.global_expr(Mode::Static, &**expr);\n+            }\n+            ast::ItemStatic(_, ast::MutMutable, ref expr) => {\n+                self.check_static_mut_type(&**expr);\n+                self.global_expr(Mode::StaticMut, &**expr);\n+            }\n+            ast::ItemConst(_, ref expr) => {\n+                self.global_expr(Mode::Const, &**expr);\n             }\n             ast::ItemEnum(ref enum_definition, _) => {\n-                self.inside_const(|v| {\n-                    for var in &enum_definition.variants {\n-                        if let Some(ref ex) = var.node.disr_expr {\n-                            v.visit_expr(&**ex);\n-                        }\n+                for var in &enum_definition.variants {\n+                    if let Some(ref ex) = var.node.disr_expr {\n+                        self.global_expr(Mode::Const, &**ex);\n                     }\n-                });\n+                }\n+            }\n+            _ => {\n+                self.with_mode(Mode::Var, |v| visit::walk_item(v, i));\n             }\n-            _ => self.with_const(false, |v| visit::walk_item(v, i))\n         }\n     }\n+\n+    fn visit_fn(&mut self,\n+                fk: visit::FnKind<'v>,\n+                fd: &'v ast::FnDecl,\n+                b: &'v ast::Block,\n+                s: Span,\n+                fn_id: ast::NodeId) {\n+        assert!(self.mode == Mode::Var);\n+        self.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, b));\n+        visit::walk_fn(self, fk, fd, b, s);\n+    }\n+\n     fn visit_pat(&mut self, p: &ast::Pat) {\n-        let is_const = match p.node {\n-            ast::PatLit(_) | ast::PatRange(..) => true,\n-            _ => false\n-        };\n-        self.with_const(is_const, |v| visit::walk_pat(v, p))\n+        match p.node {\n+            ast::PatLit(ref lit) => {\n+                self.global_expr(Mode::Const, &**lit);\n+            }\n+            ast::PatRange(ref start, ref end) => {\n+                self.global_expr(Mode::Const, &**start);\n+                self.global_expr(Mode::Const, &**end);\n+            }\n+            _ => visit::walk_pat(self, p)\n+        }\n     }\n+\n     fn visit_expr(&mut self, ex: &ast::Expr) {\n-        if self.in_const {\n-            check_expr(self, ex);\n+        let mut outer = self.qualif;\n+        self.qualif = PURE_CONST;\n+\n+        let node_ty = ty::node_id_to_type(self.tcx, ex.id);\n+        check_expr(self, ex, node_ty);\n+\n+        // Special-case some expressions to avoid certain flags bubbling up.\n+        match ex.node {\n+            ast::ExprCall(ref callee, ref args) => {\n+                for arg in args.iter() {\n+                    self.visit_expr(&**arg)\n+                }\n+\n+                let inner = self.qualif;\n+                self.visit_expr(&**callee);\n+                // The callee's size doesn't count in the call.\n+                let added = self.qualif - inner;\n+                self.qualif = inner | (added - NON_ZERO_SIZED);\n+            }\n+            ast::ExprRepeat(ref element, _) => {\n+                self.visit_expr(&**element);\n+                // The count is checked elsewhere (typeck).\n+                let count = match node_ty.sty {\n+                    ty::ty_vec(_, Some(n)) => n,\n+                    _ => unreachable!()\n+                };\n+                // [element; 0] is always zero-sized.\n+                if count == 0 {\n+                    self.qualif = self.qualif - (NON_ZERO_SIZED | PREFER_IN_PLACE);\n+                }\n+            }\n+            ast::ExprMatch(ref discr, ref arms, _) => {\n+                // Compute the most demanding borrow from all the arms'\n+                // patterns and set that on the discriminator.\n+                let mut borrow = None;\n+                for pat in arms.iter().flat_map(|arm| arm.pats.iter()) {\n+                    let pat_borrow = self.rvalue_borrows.remove(&pat.id);\n+                    match (borrow, pat_borrow) {\n+                        (None, _) | (_, Some(ast::MutMutable)) => {\n+                            borrow = pat_borrow;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                if let Some(mutbl) = borrow {\n+                    self.record_borrow(discr.id, mutbl);\n+                }\n+                visit::walk_expr(self, ex);\n+            }\n+            // Division by zero and overflow checking.\n+            ast::ExprBinary(op, _, _) => {\n+                visit::walk_expr(self, ex);\n+                let div_or_rem = op.node == ast::BiDiv || op.node == ast::BiRem;\n+                match node_ty.sty {\n+                    ty::ty_uint(_) | ty::ty_int(_) if div_or_rem => {\n+                        if !self.qualif.intersects(NOT_CONST) {\n+                            match const_eval::eval_const_expr_partial(self.tcx, ex, None) {\n+                                Ok(_) => {}\n+                                Err(msg) => {\n+                                    span_err!(self.tcx.sess, ex.span, E0020,\n+                                              \"{} in a constant expression\", msg)\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => visit::walk_expr(self, ex)\n+        }\n+\n+        // Handle borrows on (or inside the autorefs of) this expression.\n+        match self.rvalue_borrows.remove(&ex.id) {\n+            Some(ast::MutImmutable) => {\n+                // Constants cannot be borrowed if they contain interior mutability as\n+                // it means that our \"silent insertion of statics\" could change\n+                // initializer values (very bad).\n+                // If the type doesn't have interior mutability, then `MUTABLE_MEM` has\n+                // propagated from another error, so erroring again would be just noise.\n+                let tc = ty::type_contents(self.tcx, node_ty);\n+                if self.qualif.intersects(MUTABLE_MEM) && tc.interior_unsafe() {\n+                    outer = outer | NOT_CONST;\n+                    if self.mode != Mode::Var {\n+                        self.tcx.sess.span_err(ex.span,\n+                            \"cannot borrow a constant which contains \\\n+                             interior mutability, create a static instead\");\n+                    }\n+                }\n+                // If the reference has to be 'static, avoid in-place initialization\n+                // as that will end up pointing to the stack instead.\n+                if !self.qualif.intersects(NON_STATIC_BORROWS) {\n+                    self.qualif = self.qualif - PREFER_IN_PLACE;\n+                    self.add_qualif(HAS_STATIC_BORROWS);\n+                }\n+            }\n+            Some(ast::MutMutable) => {\n+                // `&mut expr` means expr could be mutated, unless it's zero-sized.\n+                if self.qualif.intersects(NON_ZERO_SIZED) {\n+                    if self.mode == Mode::Var {\n+                        outer = outer | NOT_CONST;\n+                        self.add_qualif(MUTABLE_MEM);\n+                    } else {\n+                        span_err!(self.tcx.sess, ex.span, E0017,\n+                            \"references in {}s may only refer \\\n+                             to immutable values\", self.msg())\n+                    }\n+                }\n+                if !self.qualif.intersects(NON_STATIC_BORROWS) {\n+                    self.add_qualif(HAS_STATIC_BORROWS);\n+                }\n+            }\n+            None => {}\n         }\n-        visit::walk_expr(self, ex);\n+        self.tcx.const_qualif_map.borrow_mut().insert(ex.id, self.qualif);\n+        // Don't propagate certain flags.\n+        self.qualif = outer | (self.qualif - HAS_STATIC_BORROWS);\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt) {\n-    visit::walk_crate(&mut CheckCrateVisitor { tcx: tcx, in_const: false },\n-                      tcx.map.krate());\n-    tcx.sess.abort_if_errors();\n-}\n+/// This function is used to enforce the constraints on\n+/// const/static items. It walks through the *value*\n+/// of the item walking down the expression and evaluating\n+/// every nested expression. If the expression is not part\n+/// of a const/static item, it is qualified for promotion\n+/// instead of producing errors.\n+fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n+                        e: &ast::Expr, node_ty: Ty<'tcx>) {\n+    match node_ty.sty {\n+        ty::ty_struct(did, _) |\n+        ty::ty_enum(did, _) if ty::has_dtor(v.tcx, did) => {\n+            v.add_qualif(NEEDS_DROP);\n+            if v.mode != Mode::Var {\n+                v.tcx.sess.span_err(e.span,\n+                                    &format!(\"{}s are not allowed to have destructors\",\n+                                             v.msg())[]);\n+            }\n+        }\n+        _ => {}\n+    }\n \n-fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n+    let method_call = ty::MethodCall::expr(e.id);\n     match e.node {\n-        ast::ExprUnary(ast::UnDeref, _) => {}\n+        ast::ExprUnary(..) |\n+        ast::ExprBinary(..) |\n+        ast::ExprIndex(..) if v.tcx.method_map.borrow().contains_key(&method_call) => {\n+            v.add_qualif(NOT_CONST);\n+            if v.mode != Mode::Var {\n+                span_err!(v.tcx.sess, e.span, E0011,\n+                            \"user-defined operators are not allowed in {}s\", v.msg());\n+            }\n+        }\n+        ast::ExprBox(..) |\n         ast::ExprUnary(ast::UnUniq, _) => {\n-            span_err!(v.tcx.sess, e.span, E0010,\n-                      \"cannot do allocations in constant expressions\");\n+            v.add_qualif(NOT_CONST);\n+            if v.mode != Mode::Var {\n+                span_err!(v.tcx.sess, e.span, E0010,\n+                          \"allocations are not allowed in {}s\", v.msg());\n+            }\n         }\n-        ast::ExprBinary(..) | ast::ExprUnary(..) => {\n-            let method_call = ty::MethodCall::expr(e.id);\n-            if v.tcx.method_map.borrow().contains_key(&method_call) {\n-                span_err!(v.tcx.sess, e.span, E0011,\n-                          \"user-defined operators are not allowed in constant \\\n-                           expressions\");\n+        ast::ExprUnary(ast::UnDeref, ref ptr) => {\n+            match ty::node_id_to_type(v.tcx, ptr.id).sty {\n+                ty::ty_ptr(_) => {\n+                    // This shouldn't be allowed in constants at all.\n+                    v.add_qualif(NOT_CONST);\n+                }\n+                _ => {}\n             }\n         }\n-        ast::ExprLit(_) => {}\n         ast::ExprCast(ref from, _) => {\n             let toty = ty::expr_ty(v.tcx, e);\n             let fromty = ty::expr_ty(v.tcx, &**from);\n@@ -101,47 +424,110 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n                 ty::type_is_unsafe_ptr(toty) ||\n                 (ty::type_is_bare_fn(toty) && ty::type_is_bare_fn_item(fromty));\n             if !is_legal_cast {\n-                span_err!(v.tcx.sess, e.span, E0012,\n-                          \"can not cast to `{}` in a constant expression\",\n-                          ppaux::ty_to_string(v.tcx, toty));\n+                v.add_qualif(NOT_CONST);\n+                if v.mode != Mode::Var {\n+                    span_err!(v.tcx.sess, e.span, E0012,\n+                              \"can not cast to `{}` in {}s\",\n+                              ppaux::ty_to_string(v.tcx, toty), v.msg());\n+                }\n             }\n             if ty::type_is_unsafe_ptr(fromty) && ty::type_is_numeric(toty) {\n-                span_err!(v.tcx.sess, e.span, E0018,\n-                          \"can not cast a pointer to an integer in a constant \\\n-                           expression\");\n+                v.add_qualif(NOT_CONST);\n+                if v.mode != Mode::Var {\n+                    span_err!(v.tcx.sess, e.span, E0018,\n+                              \"can not cast a pointer to an integer in {}s\", v.msg());\n+                }\n             }\n         }\n         ast::ExprPath(_) | ast::ExprQPath(_) => {\n-            match v.tcx.def_map.borrow()[e.id] {\n-                DefStatic(..) | DefConst(..) |\n-                DefFn(..) | DefStaticMethod(..) | DefMethod(..) |\n-                DefStruct(_) | DefVariant(_, _, _) => {}\n-\n+            let def = v.tcx.def_map.borrow().get(&e.id).cloned();\n+            match def {\n+                Some(def::DefVariant(_, _, _)) => {\n+                    // Count the discriminator or function pointer.\n+                    v.add_qualif(NON_ZERO_SIZED);\n+                }\n+                Some(def::DefStruct(_)) => {\n+                    if let ty::ty_bare_fn(..) = node_ty.sty {\n+                        // Count the function pointer.\n+                        v.add_qualif(NON_ZERO_SIZED);\n+                    }\n+                }\n+                Some(def::DefFn(..)) |\n+                Some(def::DefStaticMethod(..)) | Some(def::DefMethod(..)) => {\n+                    // Count the function pointer.\n+                    v.add_qualif(NON_ZERO_SIZED);\n+                }\n+                Some(def::DefStatic(..)) => {\n+                    match v.mode {\n+                        Mode::Static | Mode::StaticMut => {}\n+                        Mode::Const => {\n+                            span_err!(v.tcx.sess, e.span, E0013,\n+                                \"constants cannot refer to other statics, \\\n+                                 insert an intermediate constant instead\");\n+                        }\n+                        Mode::Var => v.add_qualif(NOT_CONST)\n+                    }\n+                }\n+                Some(def::DefConst(did)) => {\n+                    if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did) {\n+                        let inner = v.global_expr(Mode::Const, expr);\n+                        v.add_qualif(inner);\n+                    } else {\n+                        v.tcx.sess.span_bug(e.span, \"DefConst doesn't point \\\n+                                                     to an ItemConst\");\n+                    }\n+                }\n                 def => {\n-                    debug!(\"(checking const) found bad def: {:?}\", def);\n-                    span_err!(v.tcx.sess, e.span, E0014,\n-                              \"paths in constants may only refer to constants \\\n-                               or functions\");\n+                    v.add_qualif(NOT_CONST);\n+                    if v.mode != Mode::Var {\n+                        debug!(\"(checking const) found bad def: {:?}\", def);\n+                        span_err!(v.tcx.sess, e.span, E0014,\n+                                  \"paths in {}s may only refer to constants \\\n+                                   or functions\", v.msg());\n+                    }\n                 }\n             }\n         }\n         ast::ExprCall(ref callee, _) => {\n-            match v.tcx.def_map.borrow()[callee.id] {\n-                DefStruct(..) | DefVariant(..) => {}    // OK.\n+            let mut callee = &**callee;\n+            loop {\n+                callee = match callee.node {\n+                    ast::ExprParen(ref inner) => &**inner,\n+                    ast::ExprBlock(ref block) => match block.expr {\n+                        Some(ref tail) => &**tail,\n+                        None => break\n+                    },\n+                    _ => break\n+                };\n+            }\n+            let def = v.tcx.def_map.borrow().get(&callee.id).cloned();\n+            match def {\n+                Some(def::DefStruct(..)) => {}\n+                Some(def::DefVariant(..)) => {\n+                    // Count the discriminator.\n+                    v.add_qualif(NON_ZERO_SIZED);\n+                }\n                 _ => {\n-                    span_err!(v.tcx.sess, e.span, E0015,\n-                              \"function calls in constants are limited to \\\n-                               struct and enum constructors\");\n+                    v.add_qualif(NOT_CONST);\n+                    if v.mode != Mode::Var {\n+                        span_err!(v.tcx.sess, e.span, E0015,\n+                                  \"function calls in {}s are limited to \\\n+                                   struct and enum constructors\", v.msg());\n+                    }\n                 }\n             }\n         }\n         ast::ExprBlock(ref block) => {\n             // Check all statements in the block\n-            for stmt in &block.stmts {\n-                let block_span_err = |span|\n+            let mut block_span_err = |span| {\n+                v.add_qualif(NOT_CONST);\n+                if v.mode != Mode::Var {\n                     span_err!(v.tcx.sess, span, E0016,\n-                              \"blocks in constants are limited to items and \\\n-                               tail expressions\");\n+                              \"blocks in {}s are limited to items and \\\n+                               tail expressions\", v.msg());\n+                }\n+            };\n+            for stmt in &block.stmts {\n                 match stmt.node {\n                     ast::StmtDecl(ref decl, _) => {\n                         match decl.node {\n@@ -160,28 +546,184 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n                 }\n             }\n         }\n-        ast::ExprVec(_) |\n-        ast::ExprAddrOf(ast::MutImmutable, _) |\n-        ast::ExprParen(..) |\n+        ast::ExprStruct(..) => {\n+            let did = v.tcx.def_map.borrow().get(&e.id).map(|def| def.def_id());\n+            if did == v.tcx.lang_items.unsafe_cell_type() {\n+                v.add_qualif(MUTABLE_MEM);\n+            }\n+        }\n+\n+        ast::ExprLit(_) |\n+        ast::ExprAddrOf(..) => {\n+            v.add_qualif(NON_ZERO_SIZED);\n+        }\n+\n+        ast::ExprRepeat(..) => {\n+            v.add_qualif(PREFER_IN_PLACE);\n+        }\n+\n+        ast::ExprClosure(..) => {\n+            // Paths in constant constexts cannot refer to local variables,\n+            // as there are none, and thus closures can't have upvars there.\n+            if ty::with_freevars(v.tcx, e.id, |fv| !fv.is_empty()) {\n+                assert!(v.mode == Mode::Var,\n+                        \"global closures can't capture anything\");\n+                v.add_qualif(NOT_CONST);\n+            }\n+        }\n+\n+        ast::ExprUnary(..) |\n+        ast::ExprBinary(..) |\n+        ast::ExprIndex(..) |\n         ast::ExprField(..) |\n         ast::ExprTupField(..) |\n-        ast::ExprIndex(..) |\n-        ast::ExprTup(..) |\n-        ast::ExprRepeat(..) |\n-        ast::ExprStruct(..) => {}\n+        ast::ExprVec(_) |\n+        ast::ExprParen(..) |\n+        ast::ExprTup(..) => {}\n+\n+        // Conditional control flow (possible to implement).\n+        ast::ExprMatch(..) |\n+        ast::ExprIf(..) |\n+        ast::ExprIfLet(..) |\n+\n+        // Loops (not very meaningful in constants).\n+        ast::ExprWhile(..) |\n+        ast::ExprWhileLet(..) |\n+        ast::ExprForLoop(..) |\n+        ast::ExprLoop(..) |\n+\n+        // More control flow (also not very meaningful).\n+        ast::ExprBreak(_) |\n+        ast::ExprAgain(_) |\n+        ast::ExprRet(_) |\n+\n+        // Miscellaneous expressions that could be implemented.\n+        ast::ExprRange(..) |\n+\n+        // Various other expressions.\n+        ast::ExprMethodCall(..) |\n+        ast::ExprAssign(..) |\n+        ast::ExprAssignOp(..) |\n+        ast::ExprInlineAsm(_) |\n+        ast::ExprMac(_) => {\n+            v.add_qualif(NOT_CONST);\n+            if v.mode != Mode::Var {\n+                span_err!(v.tcx.sess, e.span, E0019,\n+                          \"{} contains unimplemented expression type\", v.msg());\n+            }\n+        }\n+    }\n+}\n+\n+pub fn check_crate(tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut CheckCrateVisitor {\n+        tcx: tcx,\n+        mode: Mode::Var,\n+        qualif: NOT_CONST,\n+        rvalue_borrows: NodeMap()\n+    }, tcx.map.krate());\n \n-        ast::ExprAddrOf(_, ref inner) => {\n-            match inner.node {\n-                // Mutable slices are allowed.\n-                ast::ExprVec(_) => {}\n-                _ => span_err!(v.tcx.sess, e.span, E0017,\n-                               \"references in constants may only refer \\\n-                                to immutable values\")\n+    tcx.sess.abort_if_errors();\n+}\n+\n+impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n+    fn consume(&mut self,\n+               _consume_id: ast::NodeId,\n+               consume_span: Span,\n+               cmt: mc::cmt,\n+               _mode: euv::ConsumeMode) {\n+        let mut cur = &cmt;\n+        loop {\n+            match cur.cat {\n+                mc::cat_static_item => {\n+                    if self.mode != Mode::Var {\n+                        // statics cannot be consumed by value at any time, that would imply\n+                        // that they're an initializer (what a const is for) or kept in sync\n+                        // over time (not feasible), so deny it outright.\n+                        self.tcx.sess.span_err(consume_span,\n+                            \"cannot refer to other statics by value, use the \\\n+                             address-of operator or a constant instead\");\n+                    }\n+                    break;\n+                }\n+                mc::cat_deref(ref cmt, _, _) |\n+                mc::cat_downcast(ref cmt, _) |\n+                mc::cat_interior(ref cmt, _) => cur = cmt,\n \n+                mc::cat_rvalue(..) |\n+                mc::cat_upvar(..) |\n+                mc::cat_local(..) => break\n             }\n         }\n+    }\n+    fn borrow(&mut self,\n+              borrow_id: ast::NodeId,\n+              borrow_span: Span,\n+              cmt: mc::cmt<'tcx>,\n+              _loan_region: ty::Region,\n+              bk: ty::BorrowKind,\n+              loan_cause: euv::LoanCause) {\n+        let mut cur = &cmt;\n+        let mut is_interior = false;\n+        loop {\n+            match cur.cat {\n+                mc::cat_rvalue(..) => {\n+                    if loan_cause == euv::MatchDiscriminant {\n+                        // Ignore the dummy immutable borrow created by EUV.\n+                        break;\n+                    }\n+                    let mutbl = bk.to_mutbl_lossy();\n+                    if mutbl == ast::MutMutable && self.mode == Mode::StaticMut {\n+                        // Mutable slices are the only `&mut` allowed in globals,\n+                        // but only in `static mut`, nowhere else.\n+                        match cmt.ty.sty {\n+                            ty::ty_vec(_, _) => break,\n+                            _ => {}\n+                        }\n+                    }\n+                    self.record_borrow(borrow_id, mutbl);\n+                    break;\n+                }\n+                mc::cat_static_item => {\n+                    if is_interior && self.mode != Mode::Var {\n+                        // Borrowed statics can specifically *only* have their address taken,\n+                        // not any number of other borrows such as borrowing fields, reading\n+                        // elements of an array, etc.\n+                        self.tcx.sess.span_err(borrow_span,\n+                            \"cannot refer to the interior of another \\\n+                             static, use a constant instead\");\n+                    }\n+                    break;\n+                }\n+                mc::cat_deref(ref cmt, _, _) |\n+                mc::cat_downcast(ref cmt, _) |\n+                mc::cat_interior(ref cmt, _) => {\n+                    is_interior = true;\n+                    cur = cmt;\n+                }\n \n-        _ => span_err!(v.tcx.sess, e.span, E0019,\n-                       \"constant contains unimplemented expression type\")\n+                mc::cat_upvar(..) |\n+                mc::cat_local(..) => break\n+            }\n+        }\n     }\n+\n+    fn decl_without_init(&mut self,\n+                         _id: ast::NodeId,\n+                         _span: Span) {}\n+    fn mutate(&mut self,\n+              _assignment_id: ast::NodeId,\n+              _assignment_span: Span,\n+              _assignee_cmt: mc::cmt,\n+              _mode: euv::MutateMode) {}\n+\n+    fn matched_pat(&mut self,\n+                   _: &ast::Pat,\n+                   _: mc::cmt,\n+                   _: euv::MatchMode) {}\n+\n+    fn consume_pat(&mut self,\n+                   _consume_pat: &ast::Pat,\n+                   _cmt: mc::cmt,\n+                   _mode: euv::ConsumeMode) {}\n }"}, {"sha": "03456f8529028a36a8527a3f00cc3a5e8e99548a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -23,6 +23,7 @@ use middle::mem_categorization::cmt;\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n+use std::cmp::Ordering;\n use std::fmt;\n use std::iter::{range_inclusive, AdditiveIterator, FromIterator, repeat};\n use std::num::Float;\n@@ -821,7 +822,9 @@ fn range_covered_by_constructor(ctor: &Constructor,\n     let cmp_from = compare_const_vals(c_from, from);\n     let cmp_to = compare_const_vals(c_to, to);\n     match (cmp_from, cmp_to) {\n-        (Some(val1), Some(val2)) => Some(val1 >= 0 && val2 <= 0),\n+        (Some(cmp_from), Some(cmp_to)) => {\n+            Some(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n+        }\n         _ => None\n     }\n }"}, {"sha": "9d3180864f283cf8cb7620487c27e5fdcab46055", "filename": "src/librustc/middle/check_static.rs", "status": "removed", "additions": 0, "deletions": 341, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -1,341 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Verifies that the types and values of static items\n-// are safe. The rules enforced by this module are:\n-//\n-// - For each *mutable* static item, it checks that its **type**:\n-//     - doesn't have a destructor\n-//     - doesn't own an owned pointer\n-//\n-// - For each *immutable* static item, it checks that its **value**:\n-//       - doesn't own owned, managed pointers\n-//       - doesn't contain a struct literal or a call to an enum variant / struct constructor where\n-//           - the type of the struct/enum has a dtor\n-//\n-// Rules Enforced Elsewhere:\n-// - It's not possible to take the address of a static item with unsafe interior. This is enforced\n-// by borrowck::gather_loans\n-use self::Mode::*;\n-\n-use middle::ty;\n-use middle::def;\n-use middle::infer;\n-use middle::traits;\n-use middle::mem_categorization as mc;\n-use middle::expr_use_visitor as euv;\n-use util::nodemap::NodeSet;\n-\n-use syntax::ast;\n-use syntax::print::pprust;\n-use syntax::visit::Visitor;\n-use syntax::codemap::Span;\n-use syntax::visit;\n-\n-#[derive(Copy, Eq, PartialEq)]\n-enum Mode {\n-    InConstant,\n-    InStatic,\n-    InStaticMut,\n-    InNothing,\n-}\n-\n-struct CheckStaticVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n-    mode: Mode,\n-    checker: &'a mut GlobalChecker,\n-}\n-\n-struct GlobalVisitor<'a,'b,'tcx:'a+'b>(\n-    euv::ExprUseVisitor<'a,'b,'tcx,ty::ParameterEnvironment<'b,'tcx>>);\n-struct GlobalChecker {\n-    static_consumptions: NodeSet,\n-    const_borrows: NodeSet,\n-    static_interior_borrows: NodeSet,\n-    static_local_borrows: NodeSet,\n-}\n-\n-pub fn check_crate(tcx: &ty::ctxt) {\n-    let mut checker = GlobalChecker {\n-        static_consumptions: NodeSet(),\n-        const_borrows: NodeSet(),\n-        static_interior_borrows: NodeSet(),\n-        static_local_borrows: NodeSet(),\n-    };\n-    {\n-        let param_env = ty::empty_parameter_environment(tcx);\n-        let visitor = euv::ExprUseVisitor::new(&mut checker, &param_env);\n-        visit::walk_crate(&mut GlobalVisitor(visitor), tcx.map.krate());\n-    }\n-    visit::walk_crate(&mut CheckStaticVisitor {\n-        tcx: tcx,\n-        mode: InNothing,\n-        checker: &mut checker,\n-    }, tcx.map.krate());\n-}\n-\n-impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n-    fn with_mode<F>(&mut self, mode: Mode, f: F) where\n-        F: FnOnce(&mut CheckStaticVisitor<'a, 'tcx>),\n-    {\n-        let old = self.mode;\n-        self.mode = mode;\n-        f(self);\n-        self.mode = old;\n-    }\n-\n-    fn msg(&self) -> &'static str {\n-        match self.mode {\n-            InConstant => \"constants\",\n-            InStaticMut | InStatic => \"statics\",\n-            InNothing => unreachable!(),\n-        }\n-    }\n-\n-    fn check_static_mut_type(&self, e: &ast::Expr) {\n-        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n-        let tcontents = ty::type_contents(self.tcx, node_ty);\n-\n-        let suffix = if tcontents.has_dtor() {\n-            \"destructors\"\n-        } else if tcontents.owns_owned() {\n-            \"owned pointers\"\n-        } else {\n-            return\n-        };\n-\n-        self.tcx.sess.span_err(e.span, &format!(\"mutable statics are not allowed \\\n-                                                to have {}\", suffix)[]);\n-    }\n-\n-    fn check_static_type(&self, e: &ast::Expr) {\n-        let ty = ty::node_id_to_type(self.tcx, e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx);\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-        let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n-        fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        let env = ty::empty_parameter_environment(self.tcx);\n-        match fulfill_cx.select_all_or_error(&infcx, &env) {\n-            Ok(()) => { },\n-            Err(ref errors) => {\n-                traits::report_fulfillment_errors(&infcx, errors);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n-        debug!(\"visit_item(item={})\", pprust::item_to_string(i));\n-        match i.node {\n-            ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n-                self.check_static_type(&**expr);\n-                self.with_mode(InStatic, |v| v.visit_expr(&**expr));\n-            }\n-            ast::ItemStatic(_, ast::MutMutable, ref expr) => {\n-                self.check_static_mut_type(&**expr);\n-                self.with_mode(InStaticMut, |v| v.visit_expr(&**expr));\n-            }\n-            ast::ItemConst(_, ref expr) => {\n-                self.with_mode(InConstant, |v| v.visit_expr(&**expr));\n-            }\n-            _ => {\n-                self.with_mode(InNothing, |v| visit::walk_item(v, i));\n-            }\n-        }\n-    }\n-\n-    /// This method is used to enforce the constraints on\n-    /// immutable static items. It walks through the *value*\n-    /// of the item walking down the expression and evaluating\n-    /// every nested expression. if the expression is not part\n-    /// of a static item, this method does nothing but walking\n-    /// down through it.\n-    fn visit_expr(&mut self, e: &ast::Expr) {\n-        if self.mode == InNothing {\n-            return visit::walk_expr(self, e);\n-        }\n-\n-        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n-\n-        match node_ty.sty {\n-            ty::ty_struct(did, _) |\n-            ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n-                self.tcx.sess.span_err(e.span,\n-                                       &format!(\"{} are not allowed to have \\\n-                                                destructors\", self.msg())[])\n-            }\n-            _ => {}\n-        }\n-\n-        // statics cannot be consumed by value at any time, that would imply\n-        // that they're an initializer (what a const is for) or kept in sync\n-        // over time (not feasible), so deny it outright.\n-        if self.checker.static_consumptions.remove(&e.id) {\n-            self.tcx.sess.span_err(e.span, \"cannot refer to other statics by \\\n-                                            value, use the address-of operator \\\n-                                            or a constant instead\");\n-        }\n-\n-        // Borrowed statics can specifically *only* have their address taken,\n-        // not any number of other borrows such as borrowing fields, reading\n-        // elements of an array, etc.\n-        if self.checker.static_interior_borrows.remove(&e.id) {\n-            self.tcx.sess.span_err(e.span, \"cannot refer to the interior of \\\n-                                            another static, use a constant \\\n-                                            instead\");\n-        }\n-\n-        // constants cannot be borrowed if they contain interior mutability as\n-        // it means that our \"silent insertion of statics\" could change\n-        // initializer values (very bad).\n-        if self.checker.const_borrows.remove(&e.id) {\n-            let node_ty = ty::node_id_to_type(self.tcx, e.id);\n-            let tcontents = ty::type_contents(self.tcx, node_ty);\n-            if tcontents.interior_unsafe() {\n-                self.tcx.sess.span_err(e.span, \"cannot borrow a constant which \\\n-                                                contains interior mutability, \\\n-                                                create a static instead\");\n-            }\n-        }\n-\n-        // local variables in a block expression in a static context (i.e. being\n-        // assigned to a static variable) cannot be borrowed.\n-        if self.checker.static_local_borrows.remove(&e.id) {\n-            self.tcx.sess.span_err(e.span, \"cannot borrow a local variable inside \\\n-                                            a static block, define a separate static \\\n-                                            instead\");\n-        }\n-\n-        match e.node {\n-            ast::ExprAddrOf(ast::MutMutable, _) => {\n-                if self.mode != InStaticMut {\n-                    span_err!(self.tcx.sess, e.span, E0020,\n-                              \"{} are not allowed to have mutable references\",\n-                              self.msg());\n-                }\n-            },\n-            ast::ExprBox(..) |\n-            ast::ExprUnary(ast::UnUniq, _) => {\n-                span_err!(self.tcx.sess, e.span, E0022,\n-                          \"{} are not allowed to have custom pointers\",\n-                          self.msg());\n-            }\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n-                match ty::resolve_expr(self.tcx, e) {\n-                    def::DefStatic(..) if self.mode == InConstant => {\n-                        let msg = \"constants cannot refer to other statics, \\\n-                                   insert an intermediate constant \\\n-                                   instead\";\n-                        self.tcx.sess.span_err(e.span, &msg[]);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-        visit::walk_expr(self, e);\n-    }\n-}\n-\n-impl<'a,'b,'t,'v> Visitor<'v> for GlobalVisitor<'a,'b,'t> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemConst(_, ref e) |\n-            ast::ItemStatic(_, _, ref e) => {\n-                let GlobalVisitor(ref mut v) = *self;\n-                v.consume_expr(&**e);\n-            }\n-            _ => {}\n-        }\n-        visit::walk_item(self, item);\n-    }\n-}\n-\n-impl<'tcx> euv::Delegate<'tcx> for GlobalChecker {\n-    fn consume(&mut self,\n-               consume_id: ast::NodeId,\n-               _consume_span: Span,\n-               cmt: mc::cmt,\n-               _mode: euv::ConsumeMode) {\n-        let mut cur = &cmt;\n-        loop {\n-            match cur.cat {\n-                mc::cat_static_item => {\n-                    self.static_consumptions.insert(consume_id);\n-                    break\n-                }\n-                mc::cat_deref(ref cmt, _, _) |\n-                mc::cat_downcast(ref cmt, _) |\n-                mc::cat_interior(ref cmt, _) => cur = cmt,\n-\n-                mc::cat_rvalue(..) |\n-                mc::cat_upvar(..) |\n-                mc::cat_local(..) => break,\n-            }\n-        }\n-    }\n-    fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n-              _borrow_span: Span,\n-              cmt: mc::cmt,\n-              _loan_region: ty::Region,\n-              _bk: ty::BorrowKind,\n-              _loan_cause: euv::LoanCause) {\n-        let mut cur = &cmt;\n-        let mut is_interior = false;\n-        loop {\n-            match cur.cat {\n-                mc::cat_rvalue(..) => {\n-                    self.const_borrows.insert(borrow_id);\n-                    break\n-                }\n-                mc::cat_static_item => {\n-                    if is_interior {\n-                        self.static_interior_borrows.insert(borrow_id);\n-                    }\n-                    break\n-                }\n-                mc::cat_deref(ref cmt, _, _) |\n-                mc::cat_interior(ref cmt, _) => {\n-                    is_interior = true;\n-                    cur = cmt;\n-                }\n-\n-                mc::cat_downcast(..) |\n-                mc::cat_upvar(..) => unreachable!(),\n-\n-                mc::cat_local(..) => {\n-                    self.static_local_borrows.insert(borrow_id);\n-                    break\n-                }\n-            }\n-        }\n-    }\n-\n-    fn decl_without_init(&mut self,\n-                         _id: ast::NodeId,\n-                         _span: Span) {}\n-    fn mutate(&mut self,\n-              _assignment_id: ast::NodeId,\n-              _assignment_span: Span,\n-              _assignee_cmt: mc::cmt,\n-              _mode: euv::MutateMode) {}\n-\n-    fn matched_pat(&mut self,\n-                   _: &ast::Pat,\n-                   _: mc::cmt,\n-                   _: euv::MatchMode) {}\n-\n-    fn consume_pat(&mut self,\n-                   _consume_pat: &ast::Pat,\n-                   _cmt: mc::cmt,\n-                   _mode: euv::ConsumeMode) {}\n-}"}, {"sha": "3d03cd946c48fadf517ca238ab75d540e63dd313", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 177, "deletions": 247, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -12,80 +12,24 @@\n #![allow(unsigned_negation)]\n \n pub use self::const_val::*;\n-pub use self::constness::*;\n \n use metadata::csearch;\n use middle::{astencode, def};\n use middle::pat_util::def_to_path;\n-use middle::ty::{self};\n+use middle::ty::{self, Ty};\n use middle::astconv_util::{ast_ty_to_prim_ty};\n-use util::nodemap::DefIdMap;\n \n use syntax::ast::{self, Expr};\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n-use syntax::visit::{self, Visitor};\n use syntax::{ast_map, ast_util, codemap};\n \n+use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n+use std::{i8, i16, i32, i64};\n use std::rc::Rc;\n \n-//\n-// This pass classifies expressions by their constant-ness.\n-//\n-// Constant-ness comes in 3 flavours:\n-//\n-//   - Integer-constants: can be evaluated by the frontend all the way down\n-//     to their actual value. They are used in a few places (enum\n-//     discriminants, switch arms) and are a subset of\n-//     general-constants. They cover all the integer and integer-ish\n-//     literals (nil, bool, int, uint, char, iNN, uNN) and all integer\n-//     operators and copies applied to them.\n-//\n-//   - General-constants: can be evaluated by LLVM but not necessarily by\n-//     the frontend; usually due to reliance on target-specific stuff such\n-//     as \"where in memory the value goes\" or \"what floating point mode the\n-//     target uses\". This _includes_ integer-constants, plus the following\n-//     constructors:\n-//\n-//        fixed-size vectors and strings: [] and \"\"/_\n-//        vector and string slices: &[] and &\"\"\n-//        tuples: (,)\n-//        enums: foo(...)\n-//        floating point literals and operators\n-//        & and * pointers\n-//        copies of general constants\n-//\n-//        (in theory, probably not at first: if/match on integer-const\n-//         conditions / discriminants)\n-//\n-//   - Non-constants: everything else.\n-//\n-\n-#[derive(Copy)]\n-pub enum constness {\n-    integral_const,\n-    general_const,\n-    non_const\n-}\n-\n-type constness_cache = DefIdMap<constness>;\n-\n-pub fn join(a: constness, b: constness) -> constness {\n-    match (a, b) {\n-      (integral_const, integral_const) => integral_const,\n-      (integral_const, general_const)\n-      | (general_const, integral_const)\n-      | (general_const, general_const) => general_const,\n-      _ => non_const\n-    }\n-}\n-\n-pub fn join_all<It: Iterator<Item=constness>>(cs: It) -> constness {\n-    cs.fold(integral_const, |a, b| join(a, b))\n-}\n-\n fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n     let opt_def = tcx.def_map.borrow().get(&e.id).cloned();\n     match opt_def {\n@@ -186,113 +130,6 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n     }\n }\n \n-struct ConstEvalVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n-    ccache: constness_cache,\n-}\n-\n-impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n-    fn classify(&mut self, e: &Expr) -> constness {\n-        let did = ast_util::local_def(e.id);\n-        match self.ccache.get(&did) {\n-            Some(&x) => return x,\n-            None => {}\n-        }\n-        let cn = match e.node {\n-            ast::ExprLit(ref lit) => {\n-                match lit.node {\n-                    ast::LitStr(..) | ast::LitFloat(..) => general_const,\n-                    _ => integral_const\n-                }\n-            }\n-\n-            ast::ExprUnary(_, ref inner) | ast::ExprParen(ref inner) =>\n-                self.classify(&**inner),\n-\n-            ast::ExprBinary(_, ref a, ref b) =>\n-                join(self.classify(&**a), self.classify(&**b)),\n-\n-            ast::ExprTup(ref es) |\n-            ast::ExprVec(ref es) =>\n-                join_all(es.iter().map(|e| self.classify(&**e))),\n-\n-            ast::ExprStruct(_, ref fs, None) => {\n-                let cs = fs.iter().map(|f| self.classify(&*f.expr));\n-                join_all(cs)\n-            }\n-\n-            ast::ExprCast(ref base, _) => {\n-                let ty = ty::expr_ty(self.tcx, e);\n-                let base = self.classify(&**base);\n-                if ty::type_is_integral(ty) {\n-                    join(integral_const, base)\n-                } else if ty::type_is_fp(ty) {\n-                    join(general_const, base)\n-                } else {\n-                    non_const\n-                }\n-            }\n-\n-            ast::ExprField(ref base, _) => self.classify(&**base),\n-\n-            ast::ExprTupField(ref base, _) => self.classify(&**base),\n-\n-            ast::ExprIndex(ref base, ref idx) =>\n-                join(self.classify(&**base), self.classify(&**idx)),\n-\n-            ast::ExprAddrOf(ast::MutImmutable, ref base) =>\n-                self.classify(&**base),\n-\n-            // FIXME: (#3728) we can probably do something CCI-ish\n-            // surrounding nonlocal constants. But we don't yet.\n-            ast::ExprPath(_) | ast::ExprQPath(_) => self.lookup_constness(e),\n-\n-            ast::ExprRepeat(..) => general_const,\n-\n-            ast::ExprBlock(ref block) => {\n-                match block.expr {\n-                    Some(ref e) => self.classify(&**e),\n-                    None => integral_const\n-                }\n-            }\n-\n-            _ => non_const\n-        };\n-        self.ccache.insert(did, cn);\n-        cn\n-    }\n-\n-    fn lookup_constness(&self, e: &Expr) -> constness {\n-        match lookup_const(self.tcx, e) {\n-            Some(rhs) => {\n-                let ty = ty::expr_ty(self.tcx, &*rhs);\n-                if ty::type_is_integral(ty) {\n-                    integral_const\n-                } else {\n-                    general_const\n-                }\n-            }\n-            None => non_const\n-        }\n-    }\n-\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for ConstEvalVisitor<'a, 'tcx> {\n-    fn visit_expr_post(&mut self, e: &Expr) {\n-        self.classify(e);\n-    }\n-}\n-\n-pub fn process_crate(tcx: &ty::ctxt) {\n-    visit::walk_crate(&mut ConstEvalVisitor {\n-        tcx: tcx,\n-        ccache: DefIdMap(),\n-    }, tcx.map.krate());\n-    tcx.sess.abort_if_errors();\n-}\n-\n-\n // FIXME (#33): this doesn't handle big integer/float literals correctly\n // (nor does the rest of our literal handling).\n #[derive(Clone, PartialEq)]\n@@ -370,17 +207,23 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n-    match eval_const_expr_partial(tcx, e) {\n+    match eval_const_expr_partial(tcx, e, None) {\n         Ok(r) => r,\n         Err(s) => tcx.sess.span_fatal(e.span, &s[])\n     }\n }\n \n-pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, String> {\n+pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                     e: &Expr,\n+                                     ty_hint: Option<Ty<'tcx>>)\n+                                     -> Result<const_val, String> {\n     fn fromb(b: bool) -> Result<const_val, String> { Ok(const_int(b as i64)) }\n+\n+    let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n+\n     match e.node {\n       ast::ExprUnary(ast::UnNeg, ref inner) => {\n-        match eval_const_expr_partial(tcx, &**inner) {\n+        match eval_const_expr_partial(tcx, &**inner, ety) {\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n@@ -390,16 +233,20 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n         }\n       }\n       ast::ExprUnary(ast::UnNot, ref inner) => {\n-        match eval_const_expr_partial(tcx, &**inner) {\n+        match eval_const_expr_partial(tcx, &**inner, ety) {\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n           _ => Err(\"not on float or string\".to_string())\n         }\n       }\n       ast::ExprBinary(op, ref a, ref b) => {\n-        match (eval_const_expr_partial(tcx, &**a),\n-               eval_const_expr_partial(tcx, &**b)) {\n+        let b_ty = match op.node {\n+            ast::BiShl | ast::BiShr => Some(tcx.types.uint),\n+            _ => ety\n+        };\n+        match (eval_const_expr_partial(tcx, &**a, ety),\n+               eval_const_expr_partial(tcx, &**b, b_ty)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {\n             match op.node {\n               ast::BiAdd => Ok(const_float(a + b)),\n@@ -417,19 +264,46 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n             }\n           }\n           (Ok(const_int(a)), Ok(const_int(b))) => {\n+            let is_a_min_value = |&:| {\n+                let int_ty = match ty::expr_ty_opt(tcx, e).map(|ty| &ty.sty) {\n+                    Some(&ty::ty_int(int_ty)) => int_ty,\n+                    _ => return false\n+                };\n+                let int_ty = if let ast::TyIs(_) = int_ty {\n+                    tcx.sess.target.int_type\n+                } else {\n+                    int_ty\n+                };\n+                match int_ty {\n+                    ast::TyI8 => (a as i8) == i8::MIN,\n+                    ast::TyI16 =>  (a as i16) == i16::MIN,\n+                    ast::TyI32 =>  (a as i32) == i32::MIN,\n+                    ast::TyI64 =>  (a as i64) == i64::MIN,\n+                    ast::TyIs(_) => unreachable!()\n+                }\n+            };\n             match op.node {\n               ast::BiAdd => Ok(const_int(a + b)),\n               ast::BiSub => Ok(const_int(a - b)),\n               ast::BiMul => Ok(const_int(a * b)),\n-              ast::BiDiv if b == 0 => {\n-                  Err(\"attempted to divide by zero\".to_string())\n+              ast::BiDiv => {\n+                  if b == 0 {\n+                      Err(\"attempted to divide by zero\".to_string())\n+                  } else if b == -1 && is_a_min_value() {\n+                      Err(\"attempted to divide with overflow\".to_string())\n+                  } else {\n+                      Ok(const_int(a / b))\n+                  }\n               }\n-              ast::BiDiv => Ok(const_int(a / b)),\n-              ast::BiRem if b == 0 => {\n-                  Err(\"attempted remainder with a divisor of \\\n-                       zero\".to_string())\n+              ast::BiRem => {\n+                  if b == 0 {\n+                      Err(\"attempted remainder with a divisor of zero\".to_string())\n+                  } else if b == -1 && is_a_min_value() {\n+                      Err(\"attempted remainder with overflow\".to_string())\n+                  } else {\n+                      Ok(const_int(a % b))\n+                  }\n               }\n-              ast::BiRem => Ok(const_int(a % b)),\n               ast::BiAnd | ast::BiBitAnd => Ok(const_int(a & b)),\n               ast::BiOr | ast::BiBitOr => Ok(const_int(a | b)),\n               ast::BiBitXor => Ok(const_int(a ^ b)),\n@@ -504,63 +378,53 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n         // This tends to get called w/o the type actually having been\n         // populated in the ctxt, which was causing things to blow up\n         // (#5900). Fall back to doing a limited lookup to get past it.\n-        let ety = ty::expr_ty_opt(tcx, e)\n-                .or_else(|| ast_ty_to_prim_ty(tcx, &**target_ty))\n+        let ety = ety.or_else(|| ast_ty_to_prim_ty(tcx, &**target_ty))\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n                 });\n-\n-        macro_rules! define_casts {\n-            ($val:ident, {\n-                $($ty_pat:pat => (\n-                    $intermediate_ty:ty,\n-                    $const_type:ident,\n-                    $target_ty:ty\n-                )),*\n-            }) => (match ety.sty {\n-                $($ty_pat => {\n-                    match $val {\n-                        const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n-                        const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n-                        const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n-                        const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n-                        _ => Err(concat!(\n-                            \"can't cast this type to \", stringify!($const_type)\n-                        ).to_string())\n-                    }\n-                },)*\n-                _ => Err(\"can't cast this type\".to_string())\n-            })\n-        }\n-\n-        eval_const_expr_partial(tcx, &**base)\n-            .and_then(|val| define_casts!(val, {\n-                ty::ty_int(ast::TyIs(_)) => (int, const_int, i64),\n-                ty::ty_int(ast::TyI8) => (i8, const_int, i64),\n-                ty::ty_int(ast::TyI16) => (i16, const_int, i64),\n-                ty::ty_int(ast::TyI32) => (i32, const_int, i64),\n-                ty::ty_int(ast::TyI64) => (i64, const_int, i64),\n-                ty::ty_uint(ast::TyUs(_)) => (uint, const_uint, u64),\n-                ty::ty_uint(ast::TyU8) => (u8, const_uint, u64),\n-                ty::ty_uint(ast::TyU16) => (u16, const_uint, u64),\n-                ty::ty_uint(ast::TyU32) => (u32, const_uint, u64),\n-                ty::ty_uint(ast::TyU64) => (u64, const_uint, u64),\n-                ty::ty_float(ast::TyF32) => (f32, const_float, f64),\n-                ty::ty_float(ast::TyF64) => (f64, const_float, f64)\n-            }))\n+        // Prefer known type to noop, but always have a type hint.\n+        let base_hint = ty::expr_ty_opt(tcx, &**base).unwrap_or(ety);\n+        let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n+        cast_const(val, ety)\n       }\n       ast::ExprPath(_) | ast::ExprQPath(_) => {\n-          match lookup_const(tcx, e) {\n-              Some(actual_e) => eval_const_expr_partial(tcx, &*actual_e),\n-              None => Err(\"non-constant path in constant expr\".to_string())\n-          }\n+          let opt_def = tcx.def_map.borrow().get(&e.id).cloned();\n+          let (const_expr, const_ty) = match opt_def {\n+              Some(def::DefConst(def_id)) => {\n+                  if ast_util::is_local(def_id) {\n+                      match tcx.map.find(def_id.node) {\n+                          Some(ast_map::NodeItem(it)) => match it.node {\n+                              ast::ItemConst(ref ty, ref expr) => {\n+                                  (Some(&**expr), Some(&**ty))\n+                              }\n+                              _ => (None, None)\n+                          },\n+                          _ => (None, None)\n+                      }\n+                  } else {\n+                      (lookup_const_by_id(tcx, def_id), None)\n+                  }\n+              }\n+              Some(def::DefVariant(enum_def, variant_def, _)) => {\n+                  (lookup_variant_by_id(tcx, enum_def, variant_def), None)\n+              }\n+              _ => (None, None)\n+          };\n+          let const_expr = match const_expr {\n+              Some(actual_e) => actual_e,\n+              None => return Err(\"non-constant path in constant expr\".to_string())\n+          };\n+          let ety = ety.or_else(|| const_ty.and_then(|ty| ast_ty_to_prim_ty(tcx, ty)));\n+          eval_const_expr_partial(tcx, const_expr, ety)\n+      }\n+      ast::ExprLit(ref lit) => {\n+          Ok(lit_to_const(&**lit, ety))\n       }\n-      ast::ExprLit(ref lit) => Ok(lit_to_const(&**lit)),\n-      ast::ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e),\n+      ast::ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e, ety),\n       ast::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => eval_const_expr_partial(tcx, &**expr),\n+            Some(ref expr) => eval_const_expr_partial(tcx, &**expr, ety),\n             None => Ok(const_int(0i64))\n         }\n       }\n@@ -569,7 +433,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n         if let Some(&ast::ExprTup(ref fields)) = lookup_const(tcx, &**base).map(|s| &s.node) {\n             // Check that the given index is within bounds and evaluate its value\n             if fields.len() > index.node {\n-                return eval_const_expr_partial(tcx, &*fields[index.node])\n+                return eval_const_expr_partial(tcx, &*fields[index.node], None)\n             } else {\n                 return Err(\"tuple index out of bounds\".to_string())\n             }\n@@ -584,7 +448,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n             // Check that the given field exists and evaluate it\n             if let Some(f) = fields.iter().find(|f|\n                                            f.ident.node.as_str() == field_name.node.as_str()) {\n-                return eval_const_expr_partial(tcx, &*f.expr)\n+                return eval_const_expr_partial(tcx, &*f.expr, None)\n             } else {\n                 return Err(\"nonexistent struct field\".to_string())\n             }\n@@ -596,16 +460,58 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n     }\n }\n \n-pub fn lit_to_const(lit: &ast::Lit) -> const_val {\n+fn cast_const(val: const_val, ty: Ty) -> Result<const_val, String> {\n+    macro_rules! define_casts {\n+        ($($ty_pat:pat => (\n+            $intermediate_ty:ty,\n+            $const_type:ident,\n+            $target_ty:ty\n+        )),*) => (match ty.sty {\n+            $($ty_pat => {\n+                match val {\n+                    const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n+                    const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n+                    const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n+                    const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n+                    _ => Err(concat!(\"can't cast this type to \",\n+                                     stringify!($const_type)).to_string())\n+                }\n+            },)*\n+            _ => Err(\"can't cast this type\".to_string())\n+        })\n+    }\n+\n+    define_casts!{\n+        ty::ty_int(ast::TyIs(_)) => (int, const_int, i64),\n+        ty::ty_int(ast::TyI8) => (i8, const_int, i64),\n+        ty::ty_int(ast::TyI16) => (i16, const_int, i64),\n+        ty::ty_int(ast::TyI32) => (i32, const_int, i64),\n+        ty::ty_int(ast::TyI64) => (i64, const_int, i64),\n+        ty::ty_uint(ast::TyUs(_)) => (uint, const_uint, u64),\n+        ty::ty_uint(ast::TyU8) => (u8, const_uint, u64),\n+        ty::ty_uint(ast::TyU16) => (u16, const_uint, u64),\n+        ty::ty_uint(ast::TyU32) => (u32, const_uint, u64),\n+        ty::ty_uint(ast::TyU64) => (u64, const_uint, u64),\n+        ty::ty_float(ast::TyF32) => (f32, const_float, f64),\n+        ty::ty_float(ast::TyF64) => (f64, const_float, f64)\n+    }\n+}\n+\n+fn lit_to_const(lit: &ast::Lit, ty_hint: Option<Ty>) -> const_val {\n     match lit.node {\n         ast::LitStr(ref s, _) => const_str((*s).clone()),\n         ast::LitBinary(ref data) => {\n             const_binary(Rc::new(data.iter().map(|x| *x).collect()))\n         }\n         ast::LitByte(n) => const_uint(n as u64),\n         ast::LitChar(n) => const_uint(n as u64),\n-        ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) |\n-        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => const_int(n as i64),\n+        ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) => const_int(n as i64),\n+        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => {\n+            match ty_hint.map(|ty| &ty.sty) {\n+                Some(&ty::ty_uint(_)) => const_uint(n),\n+                _ => const_int(n as i64)\n+            }\n+        }\n         ast::LitInt(n, ast::SignedIntLit(_, ast::Minus)) |\n         ast::LitInt(n, ast::UnsuffixedIntLit(ast::Minus)) => const_int(-(n as i64)),\n         ast::LitInt(n, ast::UnsignedIntLit(_)) => const_uint(n),\n@@ -617,21 +523,45 @@ pub fn lit_to_const(lit: &ast::Lit) -> const_val {\n     }\n }\n \n-fn compare_vals<T: PartialOrd>(a: T, b: T) -> Option<int> {\n-    Some(if a == b { 0 } else if a < b { -1 } else { 1 })\n-}\n-pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n-    match (a, b) {\n-        (&const_int(a), &const_int(b)) => compare_vals(a, b),\n-        (&const_uint(a), &const_uint(b)) => compare_vals(a, b),\n-        (&const_float(a), &const_float(b)) => compare_vals(a, b),\n-        (&const_str(ref a), &const_str(ref b)) => compare_vals(a, b),\n-        (&const_bool(a), &const_bool(b)) => compare_vals(a, b),\n-        (&const_binary(ref a), &const_binary(ref b)) => compare_vals(a, b),\n-        _ => None\n-    }\n+pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<Ordering> {\n+    Some(match (a, b) {\n+        (&const_int(a), &const_int(b)) => a.cmp(&b),\n+        (&const_uint(a), &const_uint(b)) => a.cmp(&b),\n+        (&const_float(a), &const_float(b)) => {\n+            // This is pretty bad but it is the existing behavior.\n+            if a == b {\n+                Ordering::Equal\n+            } else if a < b {\n+                Ordering::Less\n+            } else {\n+                Ordering::Greater\n+            }\n+        }\n+        (&const_str(ref a), &const_str(ref b)) => a.cmp(b),\n+        (&const_bool(a), &const_bool(b)) => a.cmp(&b),\n+        (&const_binary(ref a), &const_binary(ref b)) => a.cmp(b),\n+        _ => return None\n+    })\n }\n \n-pub fn compare_lit_exprs(tcx: &ty::ctxt, a: &Expr, b: &Expr) -> Option<int> {\n-    compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n+pub fn compare_lit_exprs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                               a: &Expr,\n+                               b: &Expr,\n+                               ty_hint: Option<Ty<'tcx>>)\n+                               -> Option<Ordering> {\n+    let a = match eval_const_expr_partial(tcx, a, ty_hint) {\n+        Ok(a) => a,\n+        Err(s) => {\n+            tcx.sess.span_err(a.span, &s[]);\n+            return None;\n+        }\n+    };\n+    let b = match eval_const_expr_partial(tcx, b, ty_hint) {\n+        Ok(b) => b,\n+        Err(s) => {\n+            tcx.sess.span_err(b.span, &s[]);\n+            return None;\n+        }\n+    };\n+    compare_const_vals(&a, &b)\n }"}, {"sha": "72454046eb94515315f3d637f5c0fb29aeab187d", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -1435,7 +1435,6 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::MiscVariable(_) => \"\".to_string(),\n             infer::PatternRegion(_) => \" for pattern\".to_string(),\n             infer::AddrOfRegion(_) => \" for borrow expression\".to_string(),\n-            infer::AddrOfSlice(_) => \" for slice expression\".to_string(),\n             infer::Autoref(_) => \" for autoref\".to_string(),\n             infer::Coercion(_) => \" for automatic coercion\".to_string(),\n             infer::LateBoundRegion(_, br, infer::FnCall) => {"}, {"sha": "00e377d65fea7830d9820e1e055ff348e0d07404", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -247,9 +247,6 @@ pub enum RegionVariableOrigin<'tcx> {\n     // Regions created by `&` operator\n     AddrOfRegion(Span),\n \n-    // Regions created by `&[...]` literal\n-    AddrOfSlice(Span),\n-\n     // Regions created as part of an autoref of a method receiver\n     Autoref(Span),\n \n@@ -1273,7 +1270,6 @@ impl<'tcx> RegionVariableOrigin<'tcx> {\n             MiscVariable(a) => a,\n             PatternRegion(a) => a,\n             AddrOfRegion(a) => a,\n-            AddrOfSlice(a) => a,\n             Autoref(a) => a,\n             Coercion(ref a) => a.span(),\n             EarlyBoundRegion(a, _) => a,\n@@ -1296,7 +1292,6 @@ impl<'tcx> Repr<'tcx> for RegionVariableOrigin<'tcx> {\n             AddrOfRegion(a) => {\n                 format!(\"AddrOfRegion({})\", a.repr(tcx))\n             }\n-            AddrOfSlice(a) => format!(\"AddrOfSlice({})\", a.repr(tcx)),\n             Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n             Coercion(ref a) => format!(\"Coercion({})\", a.repr(tcx)),\n             EarlyBoundRegion(a, b) => {"}, {"sha": "6c295142c9f326d485a817ad646d4baacbc69d87", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -71,6 +71,7 @@ pub use self::Note::*;\n pub use self::deref_kind::*;\n pub use self::categorization::*;\n \n+use middle::check_const;\n use middle::def;\n use middle::region;\n use middle::ty::{self, Ty};\n@@ -808,17 +809,29 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n                            -> cmt<'tcx> {\n-        match self.typer.temporary_scope(id) {\n-            Some(scope) => {\n-                match expr_ty.sty {\n-                    ty::ty_vec(_, Some(0)) => self.cat_rvalue(id, span, ty::ReStatic, expr_ty),\n-                    _ => self.cat_rvalue(id, span, ty::ReScope(scope), expr_ty)\n-                }\n+        let qualif = self.tcx().const_qualif_map.borrow().get(&id).cloned()\n+                               .unwrap_or(check_const::NOT_CONST);\n+\n+        // Only promote `[T; 0]` before an RFC for rvalue promotions\n+        // is accepted.\n+        let qualif = match expr_ty.sty {\n+            ty::ty_vec(_, Some(0)) => qualif,\n+            _ => check_const::NOT_CONST\n+        };\n+\n+        let re = match qualif & check_const::NON_STATIC_BORROWS {\n+            check_const::PURE_CONST => {\n+                // Constant rvalues get promoted to 'static.\n+                ty::ReStatic\n             }\n-            None => {\n-                self.cat_rvalue(id, span, ty::ReStatic, expr_ty)\n+            _ => {\n+                match self.typer.temporary_scope(id) {\n+                    Some(scope) => ty::ReScope(scope),\n+                    None => ty::ReStatic\n+                }\n             }\n-        }\n+        };\n+        self.cat_rvalue(id, span, re, expr_ty)\n     }\n \n     pub fn cat_rvalue(&self,"}, {"sha": "fe5c81bf2c0b3ecb5f75ced54f1ebfc6cfdf699b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -44,6 +44,7 @@ use session::Session;\n use lint;\n use metadata::csearch;\n use middle;\n+use middle::check_const;\n use middle::const_eval;\n use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n@@ -838,6 +839,9 @@ pub struct ctxt<'tcx> {\n \n     /// Caches whether traits are object safe\n     pub object_safety_cache: RefCell<DefIdMap<bool>>,\n+\n+    /// Maps Expr NodeId's to their constant qualification.\n+    pub const_qualif_map: RefCell<NodeMap<check_const::ConstQualif>>,\n }\n \n // Flags that we track on types. These flags are propagated upwards\n@@ -2472,6 +2476,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n         object_safety_cache: RefCell::new(DefIdMap()),\n+        const_qualif_map: RefCell::new(NodeMap()),\n    }\n }\n \n@@ -5350,26 +5355,25 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                     None => INITIAL_DISCRIMINANT_VALUE\n                                 };\n \n-                                match variant.node.disr_expr {\n-                                    Some(ref e) =>\n-                                        match const_eval::eval_const_expr_partial(cx, &**e) {\n-                                            Ok(const_eval::const_int(val)) => {\n-                                                discriminant = val as Disr\n-                                            }\n-                                            Ok(const_eval::const_uint(val)) => {\n-                                                discriminant = val as Disr\n-                                            }\n-                                            Ok(_) => {\n-                                                span_err!(cx.sess, e.span, E0304,\n-                                                            \"expected signed integer constant\");\n-                                            }\n-                                            Err(ref err) => {\n-                                                span_err!(cx.sess, e.span, E0305,\n-                                                            \"expected constant: {}\",\n-                                                                    *err);\n-                                            }\n-                                        },\n-                                    None => {}\n+                                if let Some(ref e) = variant.node.disr_expr {\n+                                    // Preserve all values, and prefer signed.\n+                                    let ty = Some(cx.types.i64);\n+                                    match const_eval::eval_const_expr_partial(cx, &**e, ty) {\n+                                        Ok(const_eval::const_int(val)) => {\n+                                            discriminant = val as Disr;\n+                                        }\n+                                        Ok(const_eval::const_uint(val)) => {\n+                                            discriminant = val as Disr;\n+                                        }\n+                                        Ok(_) => {\n+                                            span_err!(cx.sess, e.span, E0304,\n+                                                      \"expected signed integer constant\");\n+                                        }\n+                                        Err(err) => {\n+                                            span_err!(cx.sess, e.span, E0305,\n+                                                      \"expected constant: {}\", err);\n+                                        }\n+                                    }\n                                 };\n \n                                 last_discriminant = Some(discriminant);\n@@ -5822,7 +5826,7 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n \n // Returns the repeat count for a repeating vector expression.\n pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n-    match const_eval::eval_const_expr_partial(tcx, count_expr) {\n+    match const_eval::eval_const_expr_partial(tcx, count_expr, Some(tcx.types.uint)) {\n         Ok(val) => {\n             let found = match val {\n                 const_eval::const_uint(count) => return count as uint,"}, {"sha": "c3e205e050fb7eb045d0f579a0485e93fa8e2797", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -611,13 +611,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     // passes are timed inside typeck\n     typeck::check_crate(&ty_cx, trait_map);\n \n-    time(time_passes, \"check static items\", (), |_|\n-         middle::check_static::check_crate(&ty_cx));\n-\n-    // These next two const passes can probably be merged\n-    time(time_passes, \"const marking\", (), |_|\n-         middle::const_eval::process_crate(&ty_cx));\n-\n     time(time_passes, \"const checking\", (), |_|\n          middle::check_const::check_crate(&ty_cx));\n "}, {"sha": "e73b626e6efdcf579c368a6bd66cfcfe745a30e6", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -881,6 +881,7 @@ extern {\n \n \n     /* Operations on global variables */\n+    pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n     pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n                          -> ValueRef;\n     pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,"}, {"sha": "5ece5e59299a07bf8fb0b963b3d691f2264295bb", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -219,6 +219,7 @@ use util::nodemap::FnvHashMap;\n use util::ppaux::{Repr, vec_map_to_string};\n \n use std;\n+use std::cmp::Ordering;\n use std::iter::AdditiveIterator;\n use std::rc::Rc;\n use syntax::ast;\n@@ -232,10 +233,8 @@ struct ConstantExpr<'a>(&'a ast::Expr);\n \n impl<'a> ConstantExpr<'a> {\n     fn eq(self, other: ConstantExpr<'a>, tcx: &ty::ctxt) -> bool {\n-        let ConstantExpr(expr) = self;\n-        let ConstantExpr(other_expr) = other;\n-        match const_eval::compare_lit_exprs(tcx, expr, other_expr) {\n-            Some(val1) => val1 == 0,\n+        match const_eval::compare_lit_exprs(tcx, self.0, other.0, None) {\n+            Some(result) => result == Ordering::Equal,\n             None => panic!(\"compare_list_exprs: type mismatch\"),\n         }\n     }\n@@ -279,14 +278,14 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n         match *self {\n             ConstantValue(ConstantExpr(lit_expr), _) => {\n                 let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n-                let (llval, _) = consts::const_expr(ccx, &*lit_expr);\n+                let (llval, _) = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n-                let (l1, _) = consts::const_expr(ccx, &**l1);\n-                let (l2, _) = consts::const_expr(ccx, &**l2);\n+                let (l1, _) = consts::const_expr(ccx, &**l1, bcx.fcx.param_substs);\n+                let (l2, _) = consts::const_expr(ccx, &**l2, bcx.fcx.param_substs);\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n             Variant(disr_val, ref repr, _, _) => {\n@@ -833,8 +832,8 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n     let _icx = push_ctxt(\"compare_values\");\n     if ty::type_is_scalar(rhs_t) {\n-        let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq, debug_loc);\n-        return Result::new(rs.bcx, rs.val);\n+        let cmp = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq, debug_loc);\n+        return Result::new(cx, cmp);\n     }\n \n     match rhs_t.sty {\n@@ -1164,29 +1163,16 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                             }\n                             RangeResult(Result { val: vbegin, .. },\n                                         Result { bcx, val: vend }) => {\n-                                let Result { bcx, val: llge } =\n-                                    compare_scalar_types(bcx,\n-                                                         test_val,\n-                                                         vbegin,\n-                                                         t,\n-                                                         ast::BiGe,\n-                                                         debug_loc);\n-                                let Result { bcx, val: llle } =\n-                                    compare_scalar_types(bcx,\n-                                                         test_val,\n-                                                         vend,\n-                                                         t,\n-                                                         ast::BiLe,\n-                                                         debug_loc);\n-                                Result::new(bcx, And(bcx, llge, llle, debug_loc))\n+                                let llge = compare_scalar_types(bcx, test_val, vbegin,\n+                                                                t, ast::BiGe, debug_loc);\n+                                let llle = compare_scalar_types(bcx, test_val, vend,\n+                                                                t, ast::BiLe, debug_loc);\n+                                Result::new(bcx, And(bcx, llge, llle, DebugLoc::None))\n                             }\n                             LowerBound(Result { bcx, val }) => {\n-                                compare_scalar_types(bcx,\n-                                                     test_val,\n-                                                     val,\n-                                                     t,\n-                                                     ast::BiGe,\n-                                                     debug_loc)\n+                                Result::new(bcx, compare_scalar_types(bcx, test_val,\n+                                                                      val, t, ast::BiGe,\n+                                                                      debug_loc))\n                             }\n                         }\n                     };"}, {"sha": "ddd720f1e84a8600313b9856dd04a8398c5b7660", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -323,7 +323,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 mk_struct(cx, &ftys[], false, t)\n             }).collect();\n \n-            ensure_enum_fits_in_address_space(cx, ity, &fields[], t);\n+            ensure_enum_fits_in_address_space(cx, &fields[], t);\n \n             General(ity, fields, dtor)\n         }\n@@ -582,20 +582,14 @@ fn ensure_struct_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n fn union_size_and_align(sts: &[Struct]) -> (machine::llsize, machine::llalign) {\n     let size = sts.iter().map(|st| st.size).max().unwrap();\n-    let most_aligned = sts.iter().max_by(|st| st.align).unwrap();\n-    (size, most_aligned.align)\n+    let align = sts.iter().map(|st| st.align).max().unwrap();\n+    (roundup(size, align), align)\n }\n \n fn ensure_enum_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                               discr: IntType,\n                                                fields: &[Struct],\n                                                scapegoat: Ty<'tcx>) {\n-    let discr_size = machine::llsize_of_alloc(ccx, ll_inttype(ccx, discr));\n-    let (field_size, field_align) = union_size_and_align(fields);\n-\n-    // field_align < 1<<32, discr_size <= 8, field_size < OBJ_SIZE_BOUND <= 1<<61\n-    // so the sum is less than 1<<62 (and can't overflow).\n-    let total_size = roundup(discr_size, field_align) + field_size;\n+    let (total_size, _) = union_size_and_align(fields);\n \n     if total_size >= ccx.obj_size_bound() {\n         ccx.report_overbig_object(scapegoat);\n@@ -667,9 +661,11 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // FIXME #10604: this breaks when vector types are present.\n             let (size, align) = union_size_and_align(&sts[]);\n             let align_s = align as u64;\n+            assert_eq!(size % align_s, 0);\n+            let align_units = size / align_s - 1;\n+\n             let discr_ty = ll_inttype(cx, ity);\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n-            let align_units = (size + align_s - 1) / align_s - 1;\n             let fill_ty = match align_s {\n                 1 => Type::array(&Type::i8(cx), align_units),\n                 2 => Type::array(&Type::i16(cx), align_units),\n@@ -1049,7 +1045,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n         }\n         General(ity, ref cases, _) => {\n             let case = &cases[discr as uint];\n-            let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n+            let (max_sz, _) = union_size_and_align(&cases[]);\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let mut f = vec![lldiscr];\n             f.push_all(vals);"}, {"sha": "7f7b5cd800660abd835bd50e5b458d674cbab961", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 116, "deletions": 141, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -26,7 +26,6 @@\n #![allow(non_camel_case_types)]\n \n pub use self::ValueOrigin::*;\n-pub use self::scalar_type::*;\n \n use super::CrateTranslation;\n use super::ModuleTranslation;\n@@ -40,7 +39,6 @@ use metadata::{csearch, encoder, loader};\n use middle::astencode;\n use middle::cfg;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n-use middle::subst;\n use middle::weak_lang_items;\n use middle::subst::{Subst, Substs};\n use middle::ty::{self, Ty, ClosureTyper};\n@@ -498,7 +496,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               did: ast::DefId,\n                               t: Ty<'tcx>,\n                               parent_id: ast::DefId,\n-                              substs: &subst::Substs<'tcx>)\n+                              substs: &Substs<'tcx>)\n                               -> ValueRef {\n     let _icx = push_ctxt(\"trans_res_dtor\");\n     let did = inline::maybe_instantiate_inline(ccx, did);\n@@ -507,9 +505,9 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         assert_eq!(did.krate, ast::LOCAL_CRATE);\n \n         // Since we're in trans we don't care for any region parameters\n-        let substs = subst::Substs::erased(substs.types.clone());\n+        let substs = ccx.tcx().mk_substs(Substs::erased(substs.types.clone()));\n \n-        let (val, _, _) = monomorphize::monomorphic_fn(ccx, did, &substs, None);\n+        let (val, _, _) = monomorphize::monomorphic_fn(ccx, did, substs, None);\n \n         val\n     } else if did.krate == ast::LOCAL_CRATE {\n@@ -532,137 +530,100 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-// Used only for creating scalar comparison glue.\n-#[derive(Copy)]\n-pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n+pub fn bin_op_to_icmp_predicate(ccx: &CrateContext, op: ast::BinOp_, signed: bool)\n+                                -> llvm::IntPredicate {\n+    match op {\n+        ast::BiEq => llvm::IntEQ,\n+        ast::BiNe => llvm::IntNE,\n+        ast::BiLt => if signed { llvm::IntSLT } else { llvm::IntULT },\n+        ast::BiLe => if signed { llvm::IntSLE } else { llvm::IntULE },\n+        ast::BiGt => if signed { llvm::IntSGT } else { llvm::IntUGT },\n+        ast::BiGe => if signed { llvm::IntSGE } else { llvm::IntUGE },\n+        op => {\n+            ccx.sess().bug(&format!(\"comparison_op_to_icmp_predicate: expected \\\n+                                     comparison operator, found {:?}\", op)[]);\n+        }\n+    }\n+}\n+\n+pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: ast::BinOp_)\n+                                -> llvm::RealPredicate {\n+    match op {\n+        ast::BiEq => llvm::RealOEQ,\n+        ast::BiNe => llvm::RealUNE,\n+        ast::BiLt => llvm::RealOLT,\n+        ast::BiLe => llvm::RealOLE,\n+        ast::BiGt => llvm::RealOGT,\n+        ast::BiGe => llvm::RealOGE,\n+        op => {\n+            ccx.sess().bug(&format!(\"comparison_op_to_fcmp_predicate: expected \\\n+                                     comparison operator, found {:?}\", op)[]);\n+        }\n+    }\n+}\n \n-pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         lhs: ValueRef,\n                                         rhs: ValueRef,\n                                         t: Ty<'tcx>,\n                                         op: ast::BinOp_,\n                                         debug_loc: DebugLoc)\n-                                        -> Result<'blk, 'tcx> {\n-    let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op, debug_loc));\n-\n+                                        -> ValueRef {\n     match t.sty {\n-        ty::ty_tup(ref tys) if tys.is_empty() => f(nil_type),\n-        ty::ty_bool | ty::ty_uint(_) | ty::ty_char => f(unsigned_int),\n-        ty::ty_ptr(mt) if common::type_is_sized(cx.tcx(), mt.ty) => f(unsigned_int),\n-        ty::ty_int(_) => f(signed_int),\n-        ty::ty_float(_) => f(floating_point),\n-            // Should never get here, because t is scalar.\n-        _ => cx.sess().bug(\"non-scalar type passed to compare_scalar_types\")\n-    }\n-}\n-\n-\n-// A helper function to do the actual comparison of scalar values.\n-pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                         lhs: ValueRef,\n-                                         rhs: ValueRef,\n-                                         nt: scalar_type,\n-                                         op: ast::BinOp_,\n-                                         debug_loc: DebugLoc)\n-                                         -> ValueRef {\n-    let _icx = push_ctxt(\"compare_scalar_values\");\n-    fn die(cx: Block) -> ! {\n-        cx.sess().bug(\"compare_scalar_values: must be a comparison operator\");\n-    }\n-    match nt {\n-      nil_type => {\n-        // We don't need to do actual comparisons for nil.\n-        // () == () holds but () < () does not.\n-        match op {\n-          ast::BiEq | ast::BiLe | ast::BiGe => return C_bool(cx.ccx(), true),\n-          ast::BiNe | ast::BiLt | ast::BiGt => return C_bool(cx.ccx(), false),\n-          // refinements would be nice\n-          _ => die(cx)\n+        ty::ty_tup(ref tys) if tys.is_empty() => {\n+            // We don't need to do actual comparisons for nil.\n+            // () == () holds but () < () does not.\n+            match op {\n+                ast::BiEq | ast::BiLe | ast::BiGe => return C_bool(bcx.ccx(), true),\n+                ast::BiNe | ast::BiLt | ast::BiGt => return C_bool(bcx.ccx(), false),\n+                // refinements would be nice\n+                _ => bcx.sess().bug(\"compare_scalar_types: must be a comparison operator\")\n+            }\n         }\n-      }\n-      floating_point => {\n-        let cmp = match op {\n-          ast::BiEq => llvm::RealOEQ,\n-          ast::BiNe => llvm::RealUNE,\n-          ast::BiLt => llvm::RealOLT,\n-          ast::BiLe => llvm::RealOLE,\n-          ast::BiGt => llvm::RealOGT,\n-          ast::BiGe => llvm::RealOGE,\n-          _ => die(cx)\n-        };\n-        return FCmp(cx, cmp, lhs, rhs, debug_loc);\n-      }\n-      signed_int => {\n-        let cmp = match op {\n-          ast::BiEq => llvm::IntEQ,\n-          ast::BiNe => llvm::IntNE,\n-          ast::BiLt => llvm::IntSLT,\n-          ast::BiLe => llvm::IntSLE,\n-          ast::BiGt => llvm::IntSGT,\n-          ast::BiGe => llvm::IntSGE,\n-          _ => die(cx)\n-        };\n-        return ICmp(cx, cmp, lhs, rhs, debug_loc);\n-      }\n-      unsigned_int => {\n-        let cmp = match op {\n-          ast::BiEq => llvm::IntEQ,\n-          ast::BiNe => llvm::IntNE,\n-          ast::BiLt => llvm::IntULT,\n-          ast::BiLe => llvm::IntULE,\n-          ast::BiGt => llvm::IntUGT,\n-          ast::BiGe => llvm::IntUGE,\n-          _ => die(cx)\n-        };\n-        return ICmp(cx, cmp, lhs, rhs, debug_loc);\n-      }\n+        ty::ty_bool | ty::ty_uint(_) | ty::ty_char => {\n+            ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, false), lhs, rhs, debug_loc)\n+        }\n+        ty::ty_ptr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n+            ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, false), lhs, rhs, debug_loc)\n+        }\n+        ty::ty_int(_) => {\n+            ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, true), lhs, rhs, debug_loc)\n+        }\n+        ty::ty_float(_) => {\n+            FCmp(bcx, bin_op_to_fcmp_predicate(bcx.ccx(), op), lhs, rhs, debug_loc)\n+        }\n+        // Should never get here, because t is scalar.\n+        _ => bcx.sess().bug(\"non-scalar type passed to compare_scalar_types\")\n     }\n }\n \n-pub fn compare_simd_types<'blk, 'tcx>(\n-                    cx: Block<'blk, 'tcx>,\n-                    lhs: ValueRef,\n-                    rhs: ValueRef,\n-                    t: Ty<'tcx>,\n-                    size: uint,\n-                    op: ast::BinOp_,\n-                    debug_loc: DebugLoc)\n-                    -> ValueRef {\n-    let cmp = match t.sty {\n+pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      lhs: ValueRef,\n+                                      rhs: ValueRef,\n+                                      t: Ty<'tcx>,\n+                                      op: ast::BinOp_,\n+                                      debug_loc: DebugLoc)\n+                                      -> ValueRef {\n+    let signed = match t.sty {\n         ty::ty_float(_) => {\n             // The comparison operators for floating point vectors are challenging.\n             // LLVM outputs a `< size x i1 >`, but if we perform a sign extension\n             // then bitcast to a floating point vector, the result will be `-NaN`\n             // for each truth value. Because of this they are unsupported.\n-            cx.sess().bug(\"compare_simd_types: comparison operators \\\n-                           not supported for floating point SIMD types\")\n-        },\n-        ty::ty_uint(_) => match op {\n-            ast::BiEq => llvm::IntEQ,\n-            ast::BiNe => llvm::IntNE,\n-            ast::BiLt => llvm::IntULT,\n-            ast::BiLe => llvm::IntULE,\n-            ast::BiGt => llvm::IntUGT,\n-            ast::BiGe => llvm::IntUGE,\n-            _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n-        },\n-        ty::ty_int(_) => match op {\n-            ast::BiEq => llvm::IntEQ,\n-            ast::BiNe => llvm::IntNE,\n-            ast::BiLt => llvm::IntSLT,\n-            ast::BiLe => llvm::IntSLE,\n-            ast::BiGt => llvm::IntSGT,\n-            ast::BiGe => llvm::IntSGE,\n-            _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n+            bcx.sess().bug(\"compare_simd_types: comparison operators \\\n+                            not supported for floating point SIMD types\")\n         },\n-        _ => cx.sess().bug(\"compare_simd_types: invalid SIMD type\"),\n+        ty::ty_uint(_) => false,\n+        ty::ty_int(_) => true,\n+        _ => bcx.sess().bug(\"compare_simd_types: invalid SIMD type\"),\n     };\n-    let return_ty = Type::vector(&type_of(cx.ccx(), t), size as u64);\n+\n+    let cmp = bin_op_to_icmp_predicate(bcx.ccx(), op, signed);\n     // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n     // to get the correctly sized type. This will compile to a single instruction\n     // once the IR is converted to assembly if the SIMD instruction is supported\n     // by the target architecture.\n-    SExt(cx, ICmp(cx, cmp, lhs, rhs, debug_loc), return_ty)\n+    SExt(bcx, ICmp(bcx, cmp, lhs, rhs, debug_loc), val_ty(lhs))\n }\n \n // Iterates through the elements of a structural type.\n@@ -679,7 +640,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                    repr: &adt::Repr<'tcx>,\n                                    av: ValueRef,\n                                    variant: &ty::VariantInfo<'tcx>,\n-                                   substs: &subst::Substs<'tcx>,\n+                                   substs: &Substs<'tcx>,\n                                    f: &mut F)\n                                    -> Block<'blk, 'tcx> where\n         F: FnMut(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n@@ -1034,21 +995,39 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                            ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n     if type_is_zero_size(cx.ccx(), t) {\n         C_undef(type_of::type_of(cx.ccx(), t))\n-    } else if ty::type_is_bool(t) {\n-        Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, llvm::False), Type::i1(cx.ccx()))\n     } else if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n         // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n         // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n         // and we have to convert it\n         Load(cx, BitCast(cx, ptr, type_of::arg_type_of(cx.ccx(), t).ptr_to()))\n-    } else if ty::type_is_region_ptr(t) || ty::type_is_unique(t) {\n-        LoadNonNull(cx, ptr)\n-    } else if ty::type_is_char(t) {\n-        // a char is a Unicode codepoint, and so takes values from 0\n-        // to 0x10FFFF inclusive only.\n-        LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n     } else {\n-        Load(cx, ptr)\n+        unsafe {\n+            let global = llvm::LLVMIsAGlobalVariable(ptr);\n+            if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n+                let val = llvm::LLVMGetInitializer(global);\n+                if !val.is_null() {\n+                    // This could go into its own function, for DRY.\n+                    // (something like \"pre-store packing/post-load unpacking\")\n+                    if ty::type_is_bool(t) {\n+                        return Trunc(cx, val, Type::i1(cx.ccx()));\n+                    } else {\n+                        return val;\n+                    }\n+                }\n+            }\n+        }\n+        if ty::type_is_bool(t) {\n+            Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, llvm::False), Type::i1(cx.ccx()))\n+        } else if ty::type_is_char(t) {\n+            // a char is a Unicode codepoint, and so takes values from 0\n+            // to 0x10FFFF inclusive only.\n+            LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n+        } else if (ty::type_is_region_ptr(t) || ty::type_is_unique(t))\n+                  && !common::type_is_fat_ptr(cx.tcx(), t) {\n+            LoadNonNull(cx, ptr)\n+        } else {\n+            Load(cx, ptr)\n+        }\n     }\n }\n \n@@ -1064,7 +1043,7 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n         Store(cx, v, BitCast(cx, dst, type_of::arg_type_of(cx.ccx(), t).ptr_to()));\n     } else {\n         Store(cx, v, dst);\n-    };\n+    }\n }\n \n pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &ast::Local)\n@@ -1162,7 +1141,7 @@ pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let llalign = type_of::align_of(ccx, t);\n         call_memcpy(bcx, dst, src, llsz, llalign as u32);\n     } else {\n-        store_ty(bcx, Load(bcx, src), dst, t);\n+        store_ty(bcx, load_ty(bcx, src, t), dst, t);\n     }\n }\n \n@@ -1425,7 +1404,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                              id: ast::NodeId,\n                              has_env: bool,\n                              output_type: ty::FnOutput<'tcx>,\n-                             param_substs: &'a Substs<'tcx>,\n+                             param_substs: &'tcx Substs<'tcx>,\n                              sp: Option<Span>,\n                              block_arena: &'a TypedArena<common::BlockS<'a, 'tcx>>)\n                              -> FunctionContext<'a, 'tcx> {\n@@ -1793,7 +1772,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    decl: &ast::FnDecl,\n                                    body: &ast::Block,\n                                    llfndecl: ValueRef,\n-                                   param_substs: &Substs<'tcx>,\n+                                   param_substs: &'tcx Substs<'tcx>,\n                                    fn_ast_id: ast::NodeId,\n                                    _attributes: &[ast::Attribute],\n                                    output_type: ty::FnOutput<'tcx>,\n@@ -1942,7 +1921,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           decl: &ast::FnDecl,\n                           body: &ast::Block,\n                           llfndecl: ValueRef,\n-                          param_substs: &Substs<'tcx>,\n+                          param_substs: &'tcx Substs<'tcx>,\n                           id: ast::NodeId,\n                           attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n@@ -1968,7 +1947,7 @@ pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     variant: &ast::Variant,\n                                     _args: &[ast::VariantArg],\n                                     disr: ty::Disr,\n-                                    param_substs: &Substs<'tcx>,\n+                                    param_substs: &'tcx Substs<'tcx>,\n                                     llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n \n@@ -2049,7 +2028,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     _fields: &[ast::StructField],\n                                     ctor_id: ast::NodeId,\n-                                    param_substs: &Substs<'tcx>,\n+                                    param_substs: &'tcx Substs<'tcx>,\n                                     llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_tuple_struct\");\n \n@@ -2064,7 +2043,7 @@ pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                      ctor_id: ast::NodeId,\n                                                      disr: ty::Disr,\n-                                                     param_substs: &Substs<'tcx>,\n+                                                     param_substs: &'tcx Substs<'tcx>,\n                                                      llfndecl: ValueRef) {\n     let ctor_ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n@@ -2302,21 +2281,22 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n             // translated everywhere it's needed.\n             for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n                 let llfn = get_item_val(ccx, item.id);\n+                let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n                 if abi != Rust {\n                     foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                             &**decl,\n                                                             &**body,\n                                                             &item.attrs[],\n                                                             llfn,\n-                                                            &Substs::trans_empty(),\n+                                                            empty_substs,\n                                                             item.id,\n                                                             None);\n                 } else {\n                     trans_fn(ccx,\n                              &**decl,\n                              &**body,\n                              llfn,\n-                             &Substs::trans_empty(),\n+                             empty_substs,\n                              item.id,\n                              &item.attrs[]);\n                 }\n@@ -2792,7 +2772,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n-                    let (v, ty) = consts::const_expr(ccx, &**expr);\n+                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+                    let (v, ty) = consts::const_expr(ccx, &**expr, empty_substs);\n                     ccx.static_values().borrow_mut().insert(id, v);\n                     unsafe {\n                         // boolean SSA values are i1, but they have to be stored in i8 slots,\n@@ -2820,12 +2801,6 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     }\n                 }\n \n-                ast::ItemConst(_, ref expr) => {\n-                    let (v, _) = consts::const_expr(ccx, &**expr);\n-                    ccx.const_values().borrow_mut().insert(id, v);\n-                    v\n-                }\n-\n                 ast::ItemFn(_, _, abi, _, _) => {\n                     let sym = sym();\n                     let llfn = if abi == Rust {"}, {"sha": "bda8b8938b76cb623b023a1afe7c3db7a7b0be0c", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -226,7 +226,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               def_id: ast::DefId,\n                               node: ExprOrMethodCall,\n-                              param_substs: &subst::Substs<'tcx>)\n+                              param_substs: &'tcx subst::Substs<'tcx>)\n                               -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n@@ -326,15 +326,15 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                               &function_name[]);\n \n     //\n-    let empty_substs = Substs::trans_empty();\n+    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx,\n                       llfn,\n                       ast::DUMMY_NODE_ID,\n                       false,\n                       sig.output,\n-                      &empty_substs,\n+                      empty_substs,\n                       None,\n                       &block_arena);\n     let mut bcx = init_function(&fcx, false, sig.output);\n@@ -386,7 +386,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     ccx: &CrateContext<'a, 'tcx>,\n     def_id: ast::DefId,\n     node: ExprOrMethodCall,\n-    param_substs: &subst::Substs<'tcx>,\n+    param_substs: &'tcx subst::Substs<'tcx>,\n     substs: subst::Substs<'tcx>)\n     -> Datum<'tcx, Rvalue>\n {\n@@ -416,7 +416,9 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n     let (is_default, def_id, substs) = match ty::provided_source(tcx, def_id) {\n-        None => (false, def_id, substs),\n+        None => {\n+            (false, def_id, tcx.mk_substs(substs))\n+        }\n         Some(source_id) => {\n             // There are two relevant substitutions when compiling\n             // default methods. First, there is the substitution for\n@@ -444,7 +446,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n                         .erase_regions();\n \n                     // And compose them\n-                    let new_substs = first_subst.subst(tcx, &substs);\n+                    let new_substs = tcx.mk_substs(first_subst.subst(tcx, &substs));\n \n                     debug!(\"trans_fn_with_vtables - default method: \\\n                             substs = {}, trait_subst = {}, \\\n@@ -463,7 +465,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     };\n \n     // If this is a closure, redirect to it.\n-    match closure::get_or_create_declaration_if_closure(ccx, def_id, &substs) {\n+    match closure::get_or_create_declaration_if_closure(ccx, def_id, substs) {\n         None => {}\n         Some(llfn) => return llfn,\n     }\n@@ -505,7 +507,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n         };\n \n         let (val, fn_ty, must_cast) =\n-            monomorphize::monomorphic_fn(ccx, def_id, &substs, opt_ref_id);\n+            monomorphize::monomorphic_fn(ccx, def_id, substs, opt_ref_id);\n         if must_cast && node != ExprId(0) {\n             // Monotype of the REFERENCE to the function (type params\n             // are subst'd)"}, {"sha": "f92df999e6049a3da4c189da516a2cbe925c98d4", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use back::link::mangle_internal_name_by_path_and_seq;\n+use llvm::ValueRef;\n use middle::mem_categorization::Typer;\n use trans::adt;\n use trans::base::*;\n@@ -137,7 +138,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n     // duplicate declarations\n     let function_type = erase_regions(ccx.tcx(), &function_type);\n     let params = match function_type.sty {\n-        ty::ty_closure(_, _, ref substs) => substs.types.clone(),\n+        ty::ty_closure(_, _, substs) => &substs.types,\n         _ => unreachable!()\n     };\n     let mono_id = MonoId {\n@@ -171,41 +172,51 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n     Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n }\n \n-pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                      decl: &ast::FnDecl,\n-                                      body: &ast::Block,\n-                                      id: ast::NodeId,\n-                                      dest: expr::Dest)\n-                                      -> Block<'blk, 'tcx>\n+pub enum Dest<'a, 'tcx: 'a> {\n+    SaveIn(Block<'a, 'tcx>, ValueRef),\n+    Ignore(&'a CrateContext<'a, 'tcx>)\n+}\n+\n+pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n+                                    decl: &ast::FnDecl,\n+                                    body: &ast::Block,\n+                                    id: ast::NodeId,\n+                                    param_substs: &'tcx Substs<'tcx>)\n+                                    -> Option<Block<'a, 'tcx>>\n {\n+    let ccx = match dest {\n+        Dest::SaveIn(bcx, _) => bcx.ccx(),\n+        Dest::Ignore(ccx) => ccx\n+    };\n+    let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"closure::trans_closure\");\n \n     debug!(\"trans_closure()\");\n \n     let closure_id = ast_util::local_def(id);\n     let llfn = get_or_create_declaration_if_closure(\n-        bcx.ccx(),\n+        ccx,\n         closure_id,\n-        bcx.fcx.param_substs).unwrap();\n+        param_substs).unwrap();\n \n     // Get the type of this closure. Use the current `param_substs` as\n     // the closure substitutions. This makes sense because the closure\n     // takes the same set of type arguments as the enclosing fn, and\n     // this function (`trans_closure`) is invoked at the point\n     // of the closure expression.\n-    let typer = NormalizingClosureTyper::new(bcx.tcx());\n-    let function_type = typer.closure_type(closure_id, bcx.fcx.param_substs);\n+    let typer = NormalizingClosureTyper::new(tcx);\n+    let function_type = typer.closure_type(closure_id, param_substs);\n \n     let freevars: Vec<ty::Freevar> =\n-        ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n+        ty::with_freevars(tcx, id, |fv| fv.iter().map(|&fv| fv).collect());\n \n-    let sig = ty::erase_late_bound_regions(bcx.tcx(), &function_type.sig);\n+    let sig = ty::erase_late_bound_regions(tcx, &function_type.sig);\n \n-    trans_closure(bcx.ccx(),\n+    trans_closure(ccx,\n                   decl,\n                   body,\n                   llfn.val,\n-                  bcx.fcx.param_substs,\n+                  param_substs,\n                   id,\n                   &[],\n                   sig.output,\n@@ -215,15 +226,15 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size closure (in which case dest will be `Ignore`) and\n     // we must still generate the closure body.\n-    let dest_addr = match dest {\n-        expr::SaveIn(p) => p,\n-        expr::Ignore => {\n+    let (mut bcx, dest_addr) = match dest {\n+        Dest::SaveIn(bcx, p) => (bcx, p),\n+        Dest::Ignore(_) => {\n             debug!(\"trans_closure() ignoring result\");\n-            return bcx\n+            return None;\n         }\n     };\n \n-    let repr = adt::represent_type(bcx.ccx(), node_id_type(bcx, id));\n+    let repr = adt::represent_type(ccx, node_id_type(bcx, id));\n \n     // Create the closure.\n     for (i, freevar) in freevars.iter().enumerate() {\n@@ -235,8 +246,7 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                    i);\n         let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n                                      closure_expr_id: id };\n-        let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n-        match upvar_capture {\n+        match tcx.upvar_capture(upvar_id).unwrap() {\n             ty::UpvarCapture::ByValue => {\n                 bcx = datum.store_to(bcx, upvar_slot_dest);\n             }\n@@ -247,6 +257,6 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     }\n     adt::trans_set_discr(bcx, &*repr, dest_addr, 0);\n \n-    bcx\n+    Some(bcx)\n }\n "}, {"sha": "d658003702dcaabbb90924dd1e326774dbad7a8e", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -410,7 +410,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n-    pub param_substs: &'a Substs<'tcx>,\n+    pub param_substs: &'tcx Substs<'tcx>,\n \n     // The source span and nesting context where this function comes from, for\n     // error reporting and symbol generation.\n@@ -858,25 +858,6 @@ pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n }\n \n-pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n-    unsafe {\n-        let len = data.len();\n-        let lldata = C_bytes(cx, data);\n-\n-        let gsym = token::gensym(\"binary\");\n-        let name = format!(\"binary{}\", gsym.usize());\n-        let name = CString::from_vec(name.into_bytes());\n-        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n-                                    name.as_ptr());\n-        llvm::LLVMSetInitializer(g, lldata);\n-        llvm::LLVMSetGlobalConstant(g, True);\n-        llvm::SetLinkage(g, llvm::InternalLinkage);\n-\n-        let cs = consts::ptrcast(g, Type::i8p(cx));\n-        C_struct(cx, &[cs, C_uint(cx, len)], false)\n-    }\n-}\n-\n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n     C_struct_in_context(cx.llcx(), elts, packed)\n }\n@@ -901,6 +882,12 @@ pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     }\n }\n \n+pub fn C_vector(elts: &[ValueRef]) -> ValueRef {\n+    unsafe {\n+        return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n+    }\n+}\n+\n pub fn C_bytes(cx: &CrateContext, bytes: &[u8]) -> ValueRef {\n     C_bytes_in_context(cx.llcx(), bytes)\n }"}, {"sha": "86f5589556a78c86805cbb95693b823d4a3e50f4", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 317, "deletions": 238, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -11,13 +11,13 @@\n \n use back::abi;\n use llvm;\n-use llvm::{ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True, False};\n-use llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n-           RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n-use middle::{const_eval, def};\n-use trans::{adt, consts, debuginfo, expr, inline, machine};\n+use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n+use llvm::{InternalLinkage, ValueRef, Bool, True};\n+use middle::{check_const, const_eval, def};\n+use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::*;\n+use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n use middle::subst::Substs;\n@@ -74,7 +74,16 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         }\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        ast::LitBinary(ref data) => C_binary_slice(cx, &data[]),\n+        ast::LitBinary(ref data) => {\n+            let g = addr_of(cx, C_bytes(cx, &data[]), \"binary\", e.id);\n+            let base = ptrcast(g, Type::i8p(cx));\n+            let prev_const = cx.const_unsized().borrow_mut()\n+                               .insert(base, g);\n+            assert!(prev_const.is_none() || prev_const == Some(g));\n+            assert_eq!(abi::FAT_PTR_ADDR, 0);\n+            assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+            C_struct(cx, &[base, C_uint(cx, data.len())], false)\n+        }\n     }\n }\n \n@@ -84,36 +93,41 @@ pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n     }\n }\n \n-fn const_vec(cx: &CrateContext, e: &ast::Expr,\n-             es: &[P<ast::Expr>]) -> (ValueRef, Type) {\n-    let vec_ty = ty::expr_ty(cx.tcx(), e);\n-    let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of(cx, unit_ty);\n-    let vs = es.iter().map(|e| const_expr(cx, &**e).0)\n-                      .collect::<Vec<_>>();\n-    // If the vector contains enums, an LLVM array won't work.\n-    let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-        C_struct(cx, &vs[], false)\n-    } else {\n-        C_array(llunitty, &vs[])\n-    };\n-    (v, llunitty)\n-}\n-\n-pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) -> ValueRef {\n+fn addr_of_mut(ccx: &CrateContext,\n+               cv: ValueRef,\n+               kind: &str,\n+               id: ast::NodeId)\n+               -> ValueRef {\n     unsafe {\n-        let gv = llvm::LLVMAddGlobal(cx.llmod(), val_ty(cv).to_ref(),\n-                                     \"const\\0\".as_ptr() as *const _);\n+        let name = format!(\"{}{}\\0\", kind, id);\n+        let gv = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(cv).to_ref(),\n+                                     name.as_ptr() as *const _);\n         llvm::LLVMSetInitializer(gv, cv);\n-        llvm::LLVMSetGlobalConstant(gv,\n-                                    if mutbl == ast::MutImmutable {True} else {False});\n-        SetLinkage(gv, PrivateLinkage);\n+        SetLinkage(gv, InternalLinkage);\n+        SetUnnamedAddr(gv, true);\n         gv\n     }\n }\n \n+pub fn addr_of(ccx: &CrateContext,\n+               cv: ValueRef,\n+               kind: &str,\n+               id: ast::NodeId)\n+               -> ValueRef {\n+    match ccx.const_globals().borrow().get(&cv) {\n+        Some(&gv) => return gv,\n+        None => {}\n+    }\n+    let gv = addr_of_mut(ccx, cv, kind, id);\n+    unsafe {\n+        llvm::LLVMSetGlobalConstant(gv, True);\n+    }\n+    ccx.const_globals().borrow_mut().insert(cv, gv);\n+    gv\n+}\n+\n fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n-    let v = match cx.const_globals().borrow().get(&(v as int)) {\n+    let v = match cx.const_unsized().borrow().get(&v) {\n         Some(&v) => v,\n         None => v\n     };\n@@ -122,155 +136,209 @@ fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_newtype<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef, t: Ty<'tcx>)\n-    -> ValueRef {\n-    let repr = adt::represent_type(cx, t);\n-    adt::const_get_field(cx, &*repr, v, 0, 0)\n-}\n-\n-fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n-                         t: Ty<'tcx>, explicit: bool)\n+fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                         v: ValueRef,\n+                         ty: Ty<'tcx>)\n                          -> (ValueRef, Ty<'tcx>) {\n-    match ty::deref(t, explicit) {\n-        Some(ref mt) => {\n-            match t.sty {\n-                ty::ty_ptr(mt) | ty::ty_rptr(_, mt) => {\n-                    if type_is_sized(cx.tcx(), mt.ty) {\n-                        (const_deref_ptr(cx, v), mt.ty)\n-                    } else {\n-                        // Derefing a fat pointer does not change the representation,\n-                        // just the type to ty_open.\n-                        (v, ty::mk_open(cx.tcx(), mt.ty))\n-                    }\n-                }\n-                ty::ty_enum(..) | ty::ty_struct(..) => {\n-                    assert!(mt.mutbl != ast::MutMutable);\n-                    (const_deref_newtype(cx, v, t), mt.ty)\n-                }\n-                _ => {\n-                    cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n-                                          ty_to_string(cx.tcx(), t))[])\n-                }\n+    match ty::deref(ty, true) {\n+        Some(mt) => {\n+            if type_is_sized(cx.tcx(), mt.ty) {\n+                (const_deref_ptr(cx, v), mt.ty)\n+            } else {\n+                // Derefing a fat pointer does not change the representation,\n+                // just the type to ty_open.\n+                (v, ty::mk_open(cx.tcx(), mt.ty))\n             }\n         }\n         None => {\n-            cx.sess().bug(&format!(\"cannot dereference const of type {}\",\n-                                  ty_to_string(cx.tcx(), t))[])\n+            cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n+                                   ty_to_string(cx.tcx(), ty))[])\n         }\n     }\n }\n \n-pub fn get_const_val(cx: &CrateContext,\n-                     mut def_id: ast::DefId) -> ValueRef {\n-    let contains_key = cx.const_values().borrow().contains_key(&def_id.node);\n-    if !ast_util::is_local(def_id) || !contains_key {\n-        if !ast_util::is_local(def_id) {\n-            def_id = inline::maybe_instantiate_inline(cx, def_id);\n-        }\n+pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                def_id: ast::DefId,\n+                                ref_expr: &ast::Expr)\n+                                -> &'tcx ast::Expr {\n+    let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n+\n+    if def_id.krate != ast::LOCAL_CRATE {\n+        ccx.sess().span_bug(ref_expr.span,\n+                            \"cross crate constant could not be inlined\");\n+    }\n+\n+    let item = ccx.tcx().map.expect_item(def_id.node);\n+    if let ast::ItemConst(_, ref expr) = item.node {\n+        &**expr\n+    } else {\n+        ccx.sess().span_bug(ref_expr.span,\n+                            &format!(\"get_const_val given non-constant item {}\",\n+                                     item.repr(ccx.tcx()))[]);\n+    }\n+}\n \n-        if let ast::ItemConst(..) = cx.tcx().map.expect_item(def_id.node).node {\n-            base::get_item_val(cx, def_id.node);\n+fn get_const_val(ccx: &CrateContext,\n+                 def_id: ast::DefId,\n+                 ref_expr: &ast::Expr) -> ValueRef {\n+    let expr = get_const_expr(ccx, def_id, ref_expr);\n+    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+    get_const_expr_as_global(ccx, expr, check_const::PURE_CONST, empty_substs)\n+}\n+\n+pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                          expr: &ast::Expr,\n+                                          qualif: check_const::ConstQualif,\n+                                          param_substs: &'tcx Substs<'tcx>)\n+                                          -> ValueRef {\n+    // Special-case constants to cache a common global for all uses.\n+    match expr.node {\n+        ast::ExprPath(_) => {\n+            let def = ccx.tcx().def_map.borrow()[expr.id];\n+            match def {\n+                def::DefConst(def_id) => {\n+                    if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n+                        return get_const_val(ccx, def_id, expr);\n+                    }\n+                }\n+                _ => {}\n+            }\n         }\n+        _ => {}\n+    }\n+\n+    let key = (expr.id, param_substs);\n+    match ccx.const_values().borrow().get(&key) {\n+        Some(&val) => return val,\n+        None => {}\n     }\n+    let val = if qualif.intersects(check_const::NON_STATIC_BORROWS) {\n+        // Avoid autorefs as they would create global instead of stack\n+        // references, even when only the latter are correct.\n+        let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n+                                                  &ty::expr_ty(ccx.tcx(), expr));\n+        const_expr_unadjusted(ccx, expr, ty, param_substs)\n+    } else {\n+        const_expr(ccx, expr, param_substs).0\n+    };\n \n-    cx.const_values().borrow()[def_id.node].clone()\n+    // boolean SSA values are i1, but they have to be stored in i8 slots,\n+    // otherwise some LLVM optimization passes don't work as expected\n+    let val = unsafe {\n+        if llvm::LLVMTypeOf(val) == Type::i1(ccx).to_ref() {\n+            llvm::LLVMConstZExt(val, Type::i8(ccx).to_ref())\n+        } else {\n+            val\n+        }\n+    };\n+\n+    let lvalue = addr_of(ccx, val, \"const\", expr.id);\n+    ccx.const_values().borrow_mut().insert(key, lvalue);\n+    lvalue\n }\n \n-pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n+pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                            e: &ast::Expr,\n+                            param_substs: &'tcx Substs<'tcx>)\n                             -> (ValueRef, Ty<'tcx>) {\n-    let llconst = const_expr_unadjusted(cx, e);\n+    let ety = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n+                                               &ty::expr_ty(cx.tcx(), e));\n+    let llconst = const_expr_unadjusted(cx, e, ety, param_substs);\n     let mut llconst = llconst;\n-    let ety = ty::expr_ty(cx.tcx(), e);\n-    let mut ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n+    let mut ety_adjusted = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n+                                                            &ty::expr_ty_adjusted(cx.tcx(), e));\n     let opt_adj = cx.tcx().adjustments.borrow().get(&e.id).cloned();\n     match opt_adj {\n-        None => { }\n-        Some(adj) => {\n-            match adj {\n-               ty::AdjustReifyFnPointer(_def_id) => {\n-                    // FIXME(#19925) once fn item types are\n-                    // zero-sized, we'll need to do something here\n+        Some(ty::AdjustReifyFnPointer(_def_id)) => {\n+            // FIXME(#19925) once fn item types are\n+            // zero-sized, we'll need to do something here\n+        }\n+        Some(ty::AdjustDerefRef(adj)) => {\n+            let mut ty = ety;\n+            // Save the last autoderef in case we can avoid it.\n+            if adj.autoderefs > 0 {\n+                for _ in 0..adj.autoderefs-1 {\n+                    let (dv, dt) = const_deref(cx, llconst, ty);\n+                    llconst = dv;\n+                    ty = dt;\n                 }\n-                ty::AdjustDerefRef(ref adj) => {\n-                    let mut ty = ety;\n-                    // Save the last autoderef in case we can avoid it.\n-                    if adj.autoderefs > 0 {\n-                        for _ in 0..adj.autoderefs-1 {\n-                            let (dv, dt) = const_deref(cx, llconst, ty, false);\n-                            llconst = dv;\n-                            ty = dt;\n-                        }\n-                    }\n+            }\n \n-                    match adj.autoref {\n-                        None => {\n-                            let (dv, dt) = const_deref(cx, llconst, ty, false);\n-                            llconst = dv;\n+            let second_autoref = match adj.autoref {\n+                None => {\n+                    let (dv, dt) = const_deref(cx, llconst, ty);\n+                    llconst = dv;\n \n-                            // If we derefed a fat pointer then we will have an\n-                            // open type here. So we need to update the type with\n-                            // the one returned from const_deref.\n-                            ety_adjusted = dt;\n-                        }\n-                        Some(ref autoref) => {\n-                            match *autoref {\n-                                ty::AutoUnsafe(_, None) |\n-                                ty::AutoPtr(ty::ReStatic, _, None) => {\n-                                    // Don't copy data to do a deref+ref\n-                                    // (i.e., skip the last auto-deref).\n-                                    if adj.autoderefs == 0 {\n-                                        llconst = const_addr_of(cx, llconst, ast::MutImmutable);\n-                                    }\n-                                }\n-                                ty::AutoPtr(ty::ReStatic, _, Some(box ty::AutoUnsize(..))) => {\n-                                    if adj.autoderefs > 0 {\n-                                        // Seeing as we are deref'ing here and take a reference\n-                                        // again to make the pointer part of the far pointer below,\n-                                        // we just skip the whole thing. We still need the type\n-                                        // though. This works even if we don't need to deref\n-                                        // because of byref semantics. Note that this is not just\n-                                        // an optimisation, it is necessary for mutable vectors to\n-                                        // work properly.\n-                                        let (_, dt) = const_deref(cx, llconst, ty, false);\n-                                        ty = dt;\n-                                    } else {\n-                                        llconst = const_addr_of(cx, llconst, ast::MutImmutable)\n-                                    }\n-\n-                                    match ty.sty {\n-                                        ty::ty_vec(unit_ty, Some(len)) => {\n-                                            let llunitty = type_of::type_of(cx, unit_ty);\n-                                            let llptr = ptrcast(llconst, llunitty.ptr_to());\n-                                            let prev_const = cx.const_globals().borrow_mut()\n-                                                             .insert(llptr as int, llconst);\n-                                            assert!(prev_const.is_none() ||\n-                                                    prev_const == Some(llconst));\n-                                            assert_eq!(abi::FAT_PTR_ADDR, 0);\n-                                            assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-                                            llconst = C_struct(cx, &[\n-                                                llptr,\n-                                                C_uint(cx, len)\n-                                            ], false);\n-                                        }\n-                                        _ => cx.sess().span_bug(e.span,\n-                                            &format!(\"unimplemented type in const unsize: {}\",\n-                                                    ty_to_string(cx.tcx(), ty))[])\n-                                    }\n-                                }\n-                                _ => {\n-                                    cx.sess()\n-                                      .span_bug(e.span,\n-                                                &format!(\"unimplemented const \\\n-                                                         autoref {:?}\",\n-                                                        autoref)[])\n+                    // If we derefed a fat pointer then we will have an\n+                    // open type here. So we need to update the type with\n+                    // the one returned from const_deref.\n+                    ety_adjusted = dt;\n+                    None\n+                }\n+                Some(ty::AutoUnsafe(_, opt_autoref)) |\n+                Some(ty::AutoPtr(_, _, opt_autoref)) => {\n+                    if adj.autoderefs == 0 {\n+                        // Don't copy data to do a deref+ref\n+                        // (i.e., skip the last auto-deref).\n+                        llconst = addr_of(cx, llconst, \"autoref\", e.id);\n+                    } else {\n+                        // Seeing as we are deref'ing here and take a reference\n+                        // again to make the pointer part of the far pointer below,\n+                        // we just skip the whole thing. We still need the type\n+                        // though. This works even if we don't need to deref\n+                        // because of byref semantics. Note that this is not just\n+                        // an optimisation, it is necessary for mutable vectors to\n+                        // work properly.\n+                        ty = match ty::deref(ty, true) {\n+                            Some(mt) => {\n+                                if type_is_sized(cx.tcx(), mt.ty) {\n+                                    mt.ty\n+                                } else {\n+                                    // Derefing a fat pointer does not change the representation,\n+                                    // just the type to ty_open.\n+                                    ty::mk_open(cx.tcx(), mt.ty)\n                                 }\n                             }\n+                            None => {\n+                                cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n+                                                       ty_to_string(cx.tcx(), ty))[])\n+                            }\n                         }\n                     }\n+                    opt_autoref\n+                }\n+                Some(autoref) => {\n+                    cx.sess().span_bug(e.span,\n+                        &format!(\"unimplemented const first autoref {:?}\", autoref)[])\n+                }\n+            };\n+            match second_autoref {\n+                None => {}\n+                Some(box ty::AutoUnsafe(_, None)) |\n+                Some(box ty::AutoPtr(_, _, None)) => {\n+                    llconst = addr_of(cx, llconst, \"autoref\", e.id);\n+                }\n+                Some(box ty::AutoUnsize(ref k)) => {\n+                    let unsized_ty = ty::unsize_ty(cx.tcx(), ty, k, e.span);\n+                    let info = expr::unsized_info(cx, k, e.id, ty, param_substs,\n+                        |t| ty::mk_imm_rptr(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), t));\n+\n+                    let base = ptrcast(llconst, type_of::type_of(cx, unsized_ty).ptr_to());\n+                    let prev_const = cx.const_unsized().borrow_mut()\n+                                       .insert(base, llconst);\n+                    assert!(prev_const.is_none() || prev_const == Some(llconst));\n+                    assert_eq!(abi::FAT_PTR_ADDR, 0);\n+                    assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+                    llconst = C_struct(cx, &[base, info], false);\n+                }\n+                Some(autoref) => {\n+                    cx.sess().span_bug(e.span,\n+                        &format!(\"unimplemented const second autoref {:?}\", autoref)[])\n                 }\n             }\n         }\n-    }\n+        None => {}\n+    };\n \n     let llty = type_of::sizing_type_of(cx, ety_adjusted);\n     let csize = machine::llsize_of_alloc(cx, val_ty(llconst));\n@@ -282,36 +350,42 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n         cx.sess().bug(&format!(\"const {} of type {} has size {} instead of {}\",\n-                         e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n+                         e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety_adjusted),\n                          csize, tsize)[]);\n     }\n     (llconst, ety_adjusted)\n }\n \n-// the bool returned is whether this expression can be inlined into other crates\n-// if it's assigned to a static.\n-fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n+fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                   e: &ast::Expr,\n+                                   ety: Ty<'tcx>,\n+                                   param_substs: &'tcx Substs<'tcx>) -> ValueRef {\n     let map_list = |exprs: &[P<ast::Expr>]| {\n-        exprs.iter().map(|e| const_expr(cx, &**e).0)\n+        exprs.iter().map(|e| const_expr(cx, &**e, param_substs).0)\n              .fold(Vec::new(), |mut l, val| { l.push(val); l })\n     };\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n           ast::ExprLit(ref lit) => {\n-              consts::const_lit(cx, e, &**lit)\n+              const_lit(cx, e, &**lit)\n           }\n           ast::ExprBinary(b, ref e1, ref e2) => {\n-            let (te1, _) = const_expr(cx, &**e1);\n-            let (te2, _) = const_expr(cx, &**e2);\n+            /* Neither type is bottom, and we expect them to be unified\n+             * already, so the following is safe. */\n+            let (te1, ty) = const_expr(cx, &**e1, param_substs);\n+            let is_simd = ty::type_is_simd(cx.tcx(), ty);\n+            let intype = if is_simd {\n+                ty::simd_type(cx.tcx(), ty)\n+            } else {\n+                ty\n+            };\n+            let is_float = ty::type_is_fp(intype);\n+            let signed = ty::type_is_signed(intype);\n \n+            let (te2, _) = const_expr(cx, &**e2, param_substs);\n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n-            /* Neither type is bottom, and we expect them to be unified\n-             * already, so the following is safe. */\n-            let ty = ty::expr_ty(cx.tcx(), &**e1);\n-            let is_float = ty::type_is_fp(ty);\n-            let signed = ty::type_is_signed(ty);\n             return match b.node {\n               ast::BiAdd   => {\n                 if is_float { llvm::LLVMConstFAdd(te1, te2) }\n@@ -345,52 +419,30 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                 if signed { llvm::LLVMConstAShr(te1, te2) }\n                 else      { llvm::LLVMConstLShr(te1, te2) }\n               }\n-              ast::BiEq     => {\n-                  if is_float { ConstFCmp(RealOEQ, te1, te2) }\n-                  else        { ConstICmp(IntEQ, te1, te2)   }\n-              },\n-              ast::BiLt     => {\n-                  if is_float { ConstFCmp(RealOLT, te1, te2) }\n-                  else        {\n-                      if signed { ConstICmp(IntSLT, te1, te2) }\n-                      else      { ConstICmp(IntULT, te1, te2) }\n-                  }\n-              },\n-              ast::BiLe     => {\n-                  if is_float { ConstFCmp(RealOLE, te1, te2) }\n-                  else        {\n-                      if signed { ConstICmp(IntSLE, te1, te2) }\n-                      else      { ConstICmp(IntULE, te1, te2) }\n-                  }\n-              },\n-              ast::BiNe     => {\n-                  if is_float { ConstFCmp(RealONE, te1, te2) }\n-                  else        { ConstICmp(IntNE, te1, te2) }\n-              },\n-              ast::BiGe     => {\n-                  if is_float { ConstFCmp(RealOGE, te1, te2) }\n-                  else        {\n-                      if signed { ConstICmp(IntSGE, te1, te2) }\n-                      else      { ConstICmp(IntUGE, te1, te2) }\n-                  }\n-              },\n-              ast::BiGt     => {\n-                  if is_float { ConstFCmp(RealOGT, te1, te2) }\n-                  else        {\n-                      if signed { ConstICmp(IntSGT, te1, te2) }\n-                      else      { ConstICmp(IntUGT, te1, te2) }\n+              ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGt | ast::BiGe => {\n+                  if is_float {\n+                      let cmp = base::bin_op_to_fcmp_predicate(cx, b.node);\n+                      ConstFCmp(cmp, te1, te2)\n+                  } else {\n+                      let cmp = base::bin_op_to_icmp_predicate(cx, b.node, signed);\n+                      let bool_val = ConstICmp(cmp, te1, te2);\n+                      if is_simd {\n+                          // LLVM outputs an `< size x i1 >`, so we need to perform\n+                          // a sign extension to get the correctly sized type.\n+                          llvm::LLVMConstIntCast(bool_val, val_ty(te1).to_ref(), True)\n+                      } else {\n+                          bool_val\n+                      }\n                   }\n-              },\n+              }\n             }\n           },\n           ast::ExprUnary(u, ref e) => {\n-            let (te, _) = const_expr(cx, &**e);\n-            let ty = ty::expr_ty(cx.tcx(), &**e);\n+            let (te, ty) = const_expr(cx, &**e, param_substs);\n             let is_float = ty::type_is_fp(ty);\n             return match u {\n               ast::UnUniq | ast::UnDeref => {\n-                let (dv, _dt) = const_deref(cx, te, ty, true);\n-                dv\n+                const_deref(cx, te, ty).0\n               }\n               ast::UnNot    => llvm::LLVMConstNot(te),\n               ast::UnNeg    => {\n@@ -400,23 +452,23 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             }\n           }\n           ast::ExprField(ref base, field) => {\n-              let (bv, bt) = const_expr(cx, &**base);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n                   adt::const_get_field(cx, &*brepr, bv, discr, ix)\n               })\n           }\n           ast::ExprTupField(ref base, idx) => {\n-              let (bv, bt) = const_expr(cx, &**base);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, _| {\n                   adt::const_get_field(cx, &*brepr, bv, discr, idx.node)\n               })\n           }\n \n           ast::ExprIndex(ref base, ref index) => {\n-              let (bv, bt) = const_expr(cx, &**base);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs);\n               let iv = match const_eval::eval_const_expr(cx.tcx(), &**index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n@@ -470,9 +522,11 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n               const_get_elt(cx, arr, &[iv as c_uint])\n           }\n           ast::ExprCast(ref base, _) => {\n-            let ety = ty::expr_ty(cx.tcx(), e);\n             let llty = type_of::type_of(cx, ety);\n-            let (v, basety) = const_expr(cx, &**base);\n+            let (v, basety) = const_expr(cx, &**base, param_substs);\n+            if expr::cast_is_noop(basety, ety) {\n+                return v;\n+            }\n             return match (expr::cast_type_kind(cx.tcx(), basety),\n                            expr::cast_type_kind(cx.tcx(), ety)) {\n \n@@ -523,49 +577,56 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n               }\n             }\n           }\n-          ast::ExprAddrOf(mutbl, ref sub) => {\n+          ast::ExprAddrOf(ast::MutImmutable, ref sub) => {\n               // If this is the address of some static, then we need to return\n               // the actual address of the static itself (short circuit the rest\n               // of const eval).\n               let mut cur = sub;\n               loop {\n                   match cur.node {\n                       ast::ExprParen(ref sub) => cur = sub,\n+                      ast::ExprBlock(ref blk) => {\n+                        if let Some(ref sub) = blk.expr {\n+                            cur = sub;\n+                        } else {\n+                            break;\n+                        }\n+                      }\n                       _ => break,\n                   }\n               }\n               let opt_def = cx.tcx().def_map.borrow().get(&cur.id).cloned();\n               if let Some(def::DefStatic(def_id, _)) = opt_def {\n-                  let ty = ty::expr_ty(cx.tcx(), e);\n-                  return get_static_val(cx, def_id, ty);\n+                  return get_static_val(cx, def_id, ety);\n               }\n \n               // If this isn't the address of a static, then keep going through\n               // normal constant evaluation.\n-              let (e, _) = const_expr(cx, &**sub);\n-              const_addr_of(cx, e, mutbl)\n+              let (v, _) = const_expr(cx, &**sub, param_substs);\n+              addr_of(cx, v, \"ref\", e.id)\n+          }\n+          ast::ExprAddrOf(ast::MutMutable, ref sub) => {\n+              let (v, _) = const_expr(cx, &**sub, param_substs);\n+              addr_of_mut(cx, v, \"ref_mut_slice\", e.id)\n           }\n           ast::ExprTup(ref es) => {\n-              let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n               let vals = map_list(&es[]);\n               adt::trans_const(cx, &*repr, 0, &vals[])\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n-              let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n-              let tcx = cx.tcx();\n \n               let base_val = match *base_opt {\n-                Some(ref base) => Some(const_expr(cx, &**base)),\n+                Some(ref base) => Some(const_expr(cx, &**base, param_substs)),\n                 None => None\n               };\n \n-              expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n+              expr::with_field_tys(cx.tcx(), ety, Some(e.id), |discr, field_tys| {\n                   let cs = field_tys.iter().enumerate()\n                                     .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.name == f.ident.node.name) {\n-                          Some(ref f) => const_expr(cx, &*f.expr).0,\n+                          Some(ref f) => const_expr(cx, &*f.expr, param_substs).0,\n                           None => {\n                               match base_val {\n                                   Some((bv, _)) => {\n@@ -580,23 +641,36 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                           }\n                       }\n                   }).collect::<Vec<_>>();\n-                  adt::trans_const(cx, &*repr, discr, &cs[])\n+                  if ty::type_is_simd(cx.tcx(), ety) {\n+                      C_vector(&cs[])\n+                  } else {\n+                      adt::trans_const(cx, &*repr, discr, &cs[])\n+                  }\n               })\n           }\n           ast::ExprVec(ref es) => {\n-            const_vec(cx, e, es).0\n+            let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n+            let llunitty = type_of::type_of(cx, unit_ty);\n+            let vs = es.iter().map(|e| const_expr(cx, &**e, param_substs).0)\n+                              .collect::<Vec<_>>();\n+            // If the vector contains enums, an LLVM array won't work.\n+            if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n+                C_struct(cx, &vs[], false)\n+            } else {\n+                C_array(llunitty, &vs[])\n+            }\n           }\n           ast::ExprRepeat(ref elem, ref count) => {\n-            let vec_ty = ty::expr_ty(cx.tcx(), e);\n-            let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n+            let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = match const_eval::eval_const_expr(cx.tcx(), &**count) {\n                 const_eval::const_int(i)  => i as uint,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs: Vec<_> = repeat(const_expr(cx, &**elem).0).take(n).collect();\n-            if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n+            let unit_val = const_expr(cx, &**elem, param_substs).0;\n+            let vs: Vec<_> = repeat(unit_val).take(n).collect();\n+            if val_ty(unit_val) != llunitty {\n                 C_struct(cx, &vs[], false)\n             } else {\n                 C_array(llunitty, &vs[])\n@@ -606,30 +680,28 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             let def = cx.tcx().def_map.borrow()[e.id];\n             match def {\n                 def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) => {\n-                    expr::trans_def_fn_unadjusted(cx, e, def, &Substs::trans_empty()).val\n+                    expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n                 def::DefConst(def_id) => {\n-                    get_const_val(cx, def_id)\n+                    const_deref_ptr(cx, get_const_val(cx, def_id, e))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n                     if vinfo.args.len() > 0 {\n                         // N-ary variant.\n-                        expr::trans_def_fn_unadjusted(cx, e, def, &Substs::trans_empty()).val\n+                        expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                     } else {\n                         // Nullary variant.\n-                        let ety = ty::expr_ty(cx.tcx(), e);\n                         let repr = adt::represent_type(cx, ety);\n                         adt::trans_const(cx, &*repr, vinfo.disr_val, &[])\n                     }\n                 }\n                 def::DefStruct(_) => {\n-                    let ety = ty::expr_ty(cx.tcx(), e);\n                     if let ty::ty_bare_fn(..) = ety.sty {\n                         // Tuple struct.\n-                        expr::trans_def_fn_unadjusted(cx, e, def, &Substs::trans_empty()).val\n+                        expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                     } else {\n                         // Unit struct.\n                         C_null(type_of::type_of(cx, ety))\n@@ -643,20 +715,21 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n           }\n           ast::ExprCall(ref callee, ref args) => {\n               let opt_def = cx.tcx().def_map.borrow().get(&callee.id).cloned();\n+              let arg_vals = map_list(&args[]);\n               match opt_def {\n                   Some(def::DefStruct(_)) => {\n-                      let ety = ty::expr_ty(cx.tcx(), e);\n-                      let repr = adt::represent_type(cx, ety);\n-                      let arg_vals = map_list(&args[]);\n-                      adt::trans_const(cx, &*repr, 0, &arg_vals[])\n+                      if ty::type_is_simd(cx.tcx(), ety) {\n+                          C_vector(&arg_vals[])\n+                      } else {\n+                          let repr = adt::represent_type(cx, ety);\n+                          adt::trans_const(cx, &*repr, 0, &arg_vals[])\n+                      }\n                   }\n                   Some(def::DefVariant(enum_did, variant_did, _)) => {\n-                      let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n                                                            variant_did);\n-                      let arg_vals = map_list(&args[]);\n                       adt::trans_const(cx,\n                                        &*repr,\n                                        vinfo.disr_val,\n@@ -665,13 +738,19 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(ref e) => const_expr(cx, &**e).0,\n+          ast::ExprParen(ref e) => const_expr(cx, &**e, param_substs).0,\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => const_expr(cx, &**expr).0,\n+                Some(ref expr) => const_expr(cx, &**expr, param_substs).0,\n                 None => C_nil(cx)\n             }\n           }\n+          ast::ExprClosure(_, ref decl, ref body) => {\n+            closure::trans_closure_expr(closure::Dest::Ignore(cx),\n+                                        &**decl, &**body, e.id,\n+                                        param_substs);\n+            C_null(type_of::type_of(cx, ety))\n+          }\n           _ => cx.sess().span_bug(e.span,\n                   \"bad constant expression type in consts::const_expr\")\n         };"}, {"sha": "96506291b5aae65e22e4db7c30f60f2abeb3c8e4", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -22,6 +22,7 @@ use trans::common::{ExternMap,tydesc_info,BuilderRef_res};\n use trans::debuginfo;\n use trans::monomorphize::MonoId;\n use trans::type_::{Type, TypeNames};\n+use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use session::config::NoDebugInfo;\n use session::Session;\n@@ -105,17 +106,20 @@ pub struct LocalCrateContext<'tcx> {\n     const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n-    /// Key is an int, cast from a ValueRef holding a *T,\n+    /// Key is a ValueRef holding a *T,\n     /// Val is a ValueRef holding a *[T].\n     ///\n     /// Needed because LLVM loses pointer->pointee association\n     /// when we ptrcast, and we have to ptrcast during translation\n-    /// of a [T] const because we form a slice, a [*T,int] pair, not\n-    /// a pointer to an LLVM array type.\n-    const_globals: RefCell<FnvHashMap<int, ValueRef>>,\n+    /// of a [T] const because we form a slice, a (*T,usize) pair, not\n+    /// a pointer to an LLVM array type. Similar for trait objects.\n+    const_unsized: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n+\n+    /// Cache of emitted const globals (value -> global)\n+    const_globals: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n \n     /// Cache of emitted const values\n-    const_values: RefCell<NodeMap<ValueRef>>,\n+    const_values: RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n \n     /// Cache of emitted static values\n     static_values: RefCell<NodeMap<ValueRef>>,\n@@ -400,8 +404,9 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 monomorphizing: RefCell::new(DefIdMap()),\n                 vtables: RefCell::new(FnvHashMap()),\n                 const_cstr_cache: RefCell::new(FnvHashMap()),\n+                const_unsized: RefCell::new(FnvHashMap()),\n                 const_globals: RefCell::new(FnvHashMap()),\n-                const_values: RefCell::new(NodeMap()),\n+                const_values: RefCell::new(FnvHashMap()),\n                 static_values: RefCell::new(NodeMap()),\n                 extern_const_values: RefCell::new(DefIdMap()),\n                 impl_method_cache: RefCell::new(FnvHashMap()),\n@@ -615,11 +620,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.const_cstr_cache\n     }\n \n-    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FnvHashMap<int, ValueRef>> {\n+    pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n+        &self.local.const_unsized\n+    }\n+\n+    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n         &self.local.const_globals\n     }\n \n-    pub fn const_values<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n+    pub fn const_values<'a>(&'a self) -> &'a RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n+                                                                ValueRef>> {\n         &self.local.const_values\n     }\n "}, {"sha": "ea5eef48257d3bc89dce546803215306a78e5850", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -372,7 +372,8 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = C_str_slice(ccx, filename);\n     let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n-    let expr_file_line = consts::const_addr_of(ccx, expr_file_line_const, ast::MutImmutable);\n+    let expr_file_line = consts::addr_of(ccx, expr_file_line_const,\n+                                         \"panic_loc\", call_info.id);\n     let args = vec!(expr_file_line);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n@@ -400,7 +401,8 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = C_str_slice(ccx,  filename);\n     let line = C_uint(ccx, loc.line);\n     let file_line_const = C_struct(ccx, &[filename, line], false);\n-    let file_line = consts::const_addr_of(ccx, file_line_const, ast::MutImmutable);\n+    let file_line = consts::addr_of(ccx, file_line_const,\n+                                    \"panic_bounds_check_loc\", call_info.id);\n     let args = vec!(file_line, index, len);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,"}, {"sha": "480679f43cb767567481f4593343aeddae89cc28", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 223, "deletions": 210, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -54,6 +54,7 @@ use self::lazy_binop_ty::*;\n \n use back::abi;\n use llvm::{self, ValueRef};\n+use middle::check_const;\n use middle::def;\n use middle::mem_categorization::Typer;\n use middle::subst::{self, Substs};\n@@ -68,7 +69,6 @@ use trans::glue;\n use trans::machine;\n use trans::meth;\n use trans::monomorphize;\n-use trans::inline;\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{struct_fields, tup_fields};\n@@ -84,8 +84,9 @@ use trans::type_::Type;\n use syntax::{ast, ast_util, codemap};\n use syntax::ptr::P;\n use syntax::parse::token;\n-use std::rc::Rc;\n use std::iter::repeat;\n+use std::mem;\n+use std::rc::Rc;\n \n // Destinations\n \n@@ -115,11 +116,56 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;\n \n+    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+\n     if bcx.tcx().adjustments.borrow().contains_key(&expr.id) {\n         // use trans, which may be less efficient but\n         // which will perform the adjustments:\n         let datum = unpack_datum!(bcx, trans(bcx, expr));\n-        return datum.store_to_dest(bcx, dest, expr.id)\n+        return datum.store_to_dest(bcx, dest, expr.id);\n+    }\n+\n+    let qualif = bcx.tcx().const_qualif_map.borrow()[expr.id];\n+    if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n+        if !qualif.intersects(check_const::PREFER_IN_PLACE) {\n+            if let SaveIn(lldest) = dest {\n+                let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n+                                                            bcx.fcx.param_substs);\n+                // Cast pointer to destination, because constants\n+                // have different types.\n+                let lldest = PointerCast(bcx, lldest, val_ty(global));\n+                memcpy_ty(bcx, lldest, global, expr_ty_adjusted(bcx, expr));\n+            }\n+            // Don't do anything in the Ignore case, consts don't need drop.\n+            return bcx;\n+        } else {\n+            // The only way we're going to see a `const` at this point is if\n+            // it prefers in-place instantiation, likely because it contains\n+            // `[x; N]` somewhere within.\n+            match expr.node {\n+                ast::ExprPath(_) | ast::ExprQPath(_) => {\n+                    match bcx.def(expr.id) {\n+                        def::DefConst(did) => {\n+                            let expr = consts::get_const_expr(bcx.ccx(), did, expr);\n+                            // Temporarily get cleanup scopes out of the way,\n+                            // as they require sub-expressions to be contained\n+                            // inside the current AST scope.\n+                            // These should record no cleanups anyways, `const`\n+                            // can't have destructors.\n+                            let scopes = mem::replace(&mut *bcx.fcx.scopes.borrow_mut(),\n+                                                      vec![]);\n+                            bcx = trans_into(bcx, expr, dest);\n+                            let scopes = mem::replace(&mut *bcx.fcx.scopes.borrow_mut(),\n+                                                      scopes);\n+                            assert!(scopes.is_empty());\n+                            return bcx;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n     }\n \n     debug!(\"trans_into() expr={}\", expr.repr(bcx.tcx()));\n@@ -130,7 +176,6 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                                           false);\n     bcx.fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n \n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n     let kind = ty::expr_kind(bcx.tcx(), expr);\n     bcx = match kind {\n         ty::LvalueExpr | ty::RvalueDatumExpr => {\n@@ -157,14 +202,70 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n+    let qualif = bcx.tcx().const_qualif_map.borrow()[expr.id];\n+    let adjusted_global = !qualif.intersects(check_const::NON_STATIC_BORROWS);\n+    let global = if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n+        let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n+                                                      bcx.fcx.param_substs);\n+\n+        if qualif.intersects(check_const::HAS_STATIC_BORROWS) {\n+            // Is borrowed as 'static, must return lvalue.\n+\n+            // Cast pointer to global, because constants have different types.\n+            let const_ty = expr_ty_adjusted(bcx, expr);\n+            let llty = type_of::type_of(bcx.ccx(), const_ty);\n+            let global = PointerCast(bcx, global, llty.ptr_to());\n+            let datum = Datum::new(global, const_ty, Lvalue);\n+            return DatumBlock::new(bcx, datum.to_expr_datum());\n+        }\n+\n+        // Otherwise, keep around and perform adjustments, if needed.\n+        let const_ty = if adjusted_global {\n+            expr_ty_adjusted(bcx, expr)\n+        } else {\n+            expr_ty(bcx, expr)\n+        };\n+\n+        // This could use a better heuristic.\n+        Some(if type_is_immediate(bcx.ccx(), const_ty) {\n+            // Cast pointer to global, because constants have different types.\n+            let llty = type_of::type_of(bcx.ccx(), const_ty);\n+            let global = PointerCast(bcx, global, llty.ptr_to());\n+            // Maybe just get the value directly, instead of loading it?\n+            immediate_rvalue(load_ty(bcx, global, const_ty), const_ty)\n+        } else {\n+            let llty = type_of::type_of(bcx.ccx(), const_ty);\n+            // HACK(eddyb) get around issues with lifetime intrinsics.\n+            let scratch = alloca_no_lifetime(bcx, llty, \"const\");\n+            let lldest = if !ty::type_is_structural(const_ty) {\n+                // Cast pointer to slot, because constants have different types.\n+                PointerCast(bcx, scratch, val_ty(global))\n+            } else {\n+                // In this case, memcpy_ty calls llvm.memcpy after casting both\n+                // source and destination to i8*, so we don't need any casts.\n+                scratch\n+            };\n+            memcpy_ty(bcx, lldest, global, const_ty);\n+            Datum::new(scratch, const_ty, Rvalue::new(ByRef))\n+        })\n+    } else {\n+        None\n+    };\n \n     let cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(),\n                                                                           expr.id,\n                                                                           expr.span,\n                                                                           false);\n     fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n-    let datum = unpack_datum!(bcx, trans_unadjusted(bcx, expr));\n-    let datum = unpack_datum!(bcx, apply_adjustments(bcx, expr, datum));\n+    let datum = match global {\n+        Some(rvalue) => rvalue.to_expr_datum(),\n+        None => unpack_datum!(bcx, trans_unadjusted(bcx, expr))\n+    };\n+    let datum = if adjusted_global {\n+        datum // trans::consts already performed adjustments.\n+    } else {\n+        unpack_datum!(bcx, apply_adjustments(bcx, expr, datum))\n+    };\n     bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, expr.id);\n     return DatumBlock::new(bcx, datum);\n }\n@@ -177,6 +278,54 @@ pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n     GEPi(bcx, fat_ptr, &[0, abi::FAT_PTR_ADDR])\n }\n \n+// Retrieve the information we are losing (making dynamic) in an unsizing\n+// adjustment.\n+// When making a dtor, we need to do different things depending on the\n+// ownership of the object.. mk_ty is a function for turning `unadjusted_ty`\n+// into a type to be destructed. If we want to end up with a Box pointer,\n+// then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n+// borrowed reference then it should be T -> &T.\n+pub fn unsized_info<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n+                                 kind: &ty::UnsizeKind<'tcx>,\n+                                 id: ast::NodeId,\n+                                 unadjusted_ty: Ty<'tcx>,\n+                                 param_substs: &'tcx subst::Substs<'tcx>,\n+                                 mk_ty: F) -> ValueRef where\n+    F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n+{\n+    // FIXME(#19596) workaround: `|t| t` causes monomorphization recursion\n+    fn identity<T>(t: T) -> T { t }\n+\n+    debug!(\"unsized_info(kind={:?}, id={}, unadjusted_ty={})\",\n+           kind, id, unadjusted_ty.repr(ccx.tcx()));\n+    match kind {\n+        &ty::UnsizeLength(len) => C_uint(ccx, len),\n+        &ty::UnsizeStruct(box ref k, tp_index) => match unadjusted_ty.sty {\n+            ty::ty_struct(_, ref substs) => {\n+                let ty_substs = substs.types.get_slice(subst::TypeSpace);\n+                // The dtor for a field treats it like a value, so mk_ty\n+                // should just be the identity function.\n+                unsized_info(ccx, k, id, ty_substs[tp_index], param_substs, identity)\n+            }\n+            _ => ccx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n+                                         unadjusted_ty.repr(ccx.tcx()))[])\n+        },\n+        &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n+            // Note that we preserve binding levels here:\n+            let substs = principal.0.substs.with_self_ty(unadjusted_ty).erase_regions();\n+            let substs = ccx.tcx().mk_substs(substs);\n+            let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: principal.def_id(),\n+                                                             substs: substs }));\n+            let trait_ref = monomorphize::apply_param_substs(ccx.tcx(),\n+                                                             param_substs,\n+                                                             &trait_ref);\n+            let box_ty = mk_ty(unadjusted_ty);\n+            consts::ptrcast(meth::get_vtable(ccx, box_ty, trait_ref, param_substs),\n+                            Type::vtable_ptr(ccx))\n+        }\n+    }\n+}\n+\n /// Helper for trans that apply adjustments from `expr` to `datum`, which should be the unadjusted\n /// translation of `expr`.\n fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -262,13 +411,17 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let datum = match autoref {\n             &AutoPtr(_, _, ref a) | &AutoUnsafe(_, ref a) => {\n                 debug!(\"  AutoPtr\");\n-                match a {\n-                    &Some(box ref a) => {\n-                        datum = unpack_datum!(bcx, apply_autoref(a, bcx, expr, datum));\n-                    }\n-                    &None => {}\n+                if let &Some(box ref a) = a {\n+                    datum = unpack_datum!(bcx, apply_autoref(a, bcx, expr, datum));\n+                }\n+                if !type_is_sized(bcx.tcx(), datum.ty) {\n+                    // Arrange cleanup\n+                    let lval = unpack_datum!(bcx,\n+                        datum.to_lvalue_datum(bcx, \"ref_fat_ptr\", expr.id));\n+                    unpack_datum!(bcx, ref_fat_ptr(bcx, lval))\n+                } else {\n+                    unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n                 }\n-                unpack_datum!(bcx, ref_ptr(bcx, expr, datum))\n             }\n             &ty::AutoUnsize(ref k) => {\n                 debug!(\"  AutoUnsize\");\n@@ -288,139 +441,35 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         DatumBlock::new(bcx, datum)\n     }\n \n-    fn ref_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                           expr: &ast::Expr,\n-                           datum: Datum<'tcx, Expr>)\n-                           -> DatumBlock<'blk, 'tcx, Expr> {\n-        debug!(\"ref_ptr(expr={}, datum={})\",\n-               expr.repr(bcx.tcx()),\n-               datum.to_string(bcx.ccx()));\n-\n-        if !type_is_sized(bcx.tcx(), datum.ty) {\n-            debug!(\"Taking address of unsized type {}\",\n-                   bcx.ty_to_string(datum.ty));\n-            ref_fat_ptr(bcx, expr, datum)\n-        } else {\n-            debug!(\"Taking address of sized type {}\",\n-                   bcx.ty_to_string(datum.ty));\n-            auto_ref(bcx, datum, expr)\n-        }\n-    }\n-\n-    // Retrieve the information we are losing (making dynamic) in an unsizing\n-    // adjustment.\n-    // When making a dtor, we need to do different things depending on the\n-    // ownership of the object.. mk_ty is a function for turning `unadjusted_ty`\n-    // into a type to be destructed. If we want to end up with a Box pointer,\n-    // then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n-    // borrowed reference then it should be T -> &T.\n-    fn unsized_info<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                   kind: &ty::UnsizeKind<'tcx>,\n-                                   id: ast::NodeId,\n-                                   unadjusted_ty: Ty<'tcx>,\n-                                   mk_ty: F) -> ValueRef where\n-        F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n-    {\n-        // FIXME(#19596) workaround: `|t| t` causes monomorphization recursion\n-        fn identity<T>(t: T) -> T { t }\n-\n-        debug!(\"unsized_info(kind={:?}, id={}, unadjusted_ty={})\",\n-               kind, id, unadjusted_ty.repr(bcx.tcx()));\n-        match kind {\n-            &ty::UnsizeLength(len) => C_uint(bcx.ccx(), len),\n-            &ty::UnsizeStruct(box ref k, tp_index) => match unadjusted_ty.sty {\n-                ty::ty_struct(_, ref substs) => {\n-                    let ty_substs = substs.types.get_slice(subst::TypeSpace);\n-                    // The dtor for a field treats it like a value, so mk_ty\n-                    // should just be the identity function.\n-                    unsized_info(bcx, k, id, ty_substs[tp_index], identity)\n-                }\n-                _ => bcx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n-                                          bcx.ty_to_string(unadjusted_ty))[])\n-            },\n-            &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n-                // Note that we preserve binding levels here:\n-                let substs = principal.0.substs.with_self_ty(unadjusted_ty).erase_regions();\n-                let substs = bcx.tcx().mk_substs(substs);\n-                let trait_ref =\n-                    ty::Binder(Rc::new(ty::TraitRef { def_id: principal.def_id(),\n-                                                      substs: substs }));\n-                let trait_ref = bcx.monomorphize(&trait_ref);\n-                let box_ty = mk_ty(unadjusted_ty);\n-                PointerCast(bcx,\n-                            meth::get_vtable(bcx, box_ty, trait_ref),\n-                            Type::vtable_ptr(bcx.ccx()))\n-            }\n-        }\n-    }\n-\n     fn unsize_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                expr: &ast::Expr,\n                                datum: Datum<'tcx, Expr>,\n                                k: &ty::UnsizeKind<'tcx>)\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n+        let mut bcx = bcx;\n         let tcx = bcx.tcx();\n         let datum_ty = datum.ty;\n         let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n         debug!(\"unsized_ty={}\", unsized_ty.repr(bcx.tcx()));\n         let dest_ty = ty::mk_open(tcx, unsized_ty);\n         debug!(\"dest_ty={}\", unsized_ty.repr(bcx.tcx()));\n-        // Closures for extracting and manipulating the data and payload parts of\n-        // the fat pointer.\n-        let info = |bcx, _val| unsized_info(bcx,\n-                                              k,\n-                                              expr.id,\n-                                              datum_ty,\n-                                              |t| ty::mk_rptr(tcx,\n-                                                              tcx.mk_region(ty::ReStatic),\n-                                                              ty::mt{\n-                                                                  ty: t,\n-                                                                  mutbl: ast::MutImmutable\n-                                                              }));\n-        match *k {\n-            ty::UnsizeStruct(..) =>\n-                into_fat_ptr(bcx, expr, datum, dest_ty, |bcx, val| {\n-                    PointerCast(bcx, val, type_of::type_of(bcx.ccx(), unsized_ty).ptr_to())\n-                }, info),\n-            ty::UnsizeLength(..) =>\n-                into_fat_ptr(bcx, expr, datum, dest_ty, |bcx, val| {\n-                    GEPi(bcx, val, &[0, 0])\n-                }, info),\n-            ty::UnsizeVtable(..) =>\n-                into_fat_ptr(bcx, expr, datum, dest_ty, |_bcx, val| {\n-                    PointerCast(bcx, val, Type::i8p(bcx.ccx()))\n-                }, info),\n-        }\n-    }\n \n-    fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               expr: &ast::Expr,\n-                               datum: Datum<'tcx, Expr>)\n-                               -> DatumBlock<'blk, 'tcx, Expr> {\n-        let tcx = bcx.tcx();\n-        let dest_ty = ty::close_type(tcx, datum.ty);\n-        let base = |bcx, val| Load(bcx, get_dataptr(bcx, val));\n-        let len = |bcx, val| Load(bcx, get_len(bcx, val));\n-        into_fat_ptr(bcx, expr, datum, dest_ty, base, len)\n-    }\n-\n-    fn into_fat_ptr<'blk, 'tcx, F, G>(bcx: Block<'blk, 'tcx>,\n-                                      expr: &ast::Expr,\n-                                      datum: Datum<'tcx, Expr>,\n-                                      dest_ty: Ty<'tcx>,\n-                                      base: F,\n-                                      info: G)\n-                                      -> DatumBlock<'blk, 'tcx, Expr> where\n-        F: FnOnce(Block<'blk, 'tcx>, ValueRef) -> ValueRef,\n-        G: FnOnce(Block<'blk, 'tcx>, ValueRef) -> ValueRef,\n-    {\n-        let mut bcx = bcx;\n+        let info = unsized_info(bcx.ccx(), k, expr.id, datum_ty, bcx.fcx.param_substs,\n+                                |t| ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), t));\n \n         // Arrange cleanup\n         let lval = unpack_datum!(bcx,\n                                  datum.to_lvalue_datum(bcx, \"into_fat_ptr\", expr.id));\n-        let base = base(bcx, lval.val);\n-        let info = info(bcx, lval.val);\n+        // Compute the base pointer. This doesn't change the pointer value,\n+        // but merely its type.\n+        let base = match *k {\n+            ty::UnsizeStruct(..) | ty::UnsizeVtable(..) => {\n+                PointerCast(bcx, lval.val, type_of::type_of(bcx.ccx(), unsized_ty).ptr_to())\n+            }\n+            ty::UnsizeLength(..) => {\n+                GEPi(bcx, lval.val, &[0u, 0u])\n+            }\n+        };\n \n         let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n         Store(bcx, base, get_dataptr(bcx, scratch.val));\n@@ -490,7 +539,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let base = PointerCast(bcx, get_dataptr(bcx, scratch.val), llbox_ty.ptr_to());\n         bcx = datum.store_to(bcx, base);\n \n-        let info = unsized_info(bcx, k, expr.id, unboxed_ty, |t| ty::mk_uniq(tcx, t));\n+        let info = unsized_info(bcx.ccx(), k, expr.id, unboxed_ty, bcx.fcx.param_substs,\n+                                |t| ty::mk_uniq(tcx, t));\n         Store(bcx, info, get_len(bcx, scratch.val));\n \n         DatumBlock::new(bcx, scratch.to_expr_datum())\n@@ -847,53 +897,25 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             //     pointer to that.\n             let const_ty = expr_ty(bcx, ref_expr);\n \n-            fn get_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, did: ast::DefId,\n-                                   const_ty: Ty<'tcx>) -> ValueRef {\n-                // For external constants, we don't inline.\n-                if did.krate == ast::LOCAL_CRATE {\n-                    // Case 1.\n-\n-                    // The LLVM global has the type of its initializer,\n-                    // which may not be equal to the enum's type for\n-                    // non-C-like enums.\n-                    let val = base::get_item_val(bcx.ccx(), did.node);\n-                    let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n-                    PointerCast(bcx, val, pty)\n-                } else {\n-                    // Case 2.\n-                    base::get_extern_const(bcx.ccx(), did, const_ty)\n-                }\n-            }\n-            let val = get_val(bcx, did, const_ty);\n+            // For external constants, we don't inline.\n+            let val = if did.krate == ast::LOCAL_CRATE {\n+                // Case 1.\n+\n+                // The LLVM global has the type of its initializer,\n+                // which may not be equal to the enum's type for\n+                // non-C-like enums.\n+                let val = base::get_item_val(bcx.ccx(), did.node);\n+                let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n+                PointerCast(bcx, val, pty)\n+            } else {\n+                // Case 2.\n+                base::get_extern_const(bcx.ccx(), did, const_ty)\n+            };\n             DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr))\n         }\n-        def::DefConst(did) => {\n-            // First, inline any external constants into the local crate so we\n-            // can be sure to get the LLVM value corresponding to it.\n-            let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-            if did.krate != ast::LOCAL_CRATE {\n-                bcx.tcx().sess.span_bug(ref_expr.span,\n-                                        \"cross crate constant could not \\\n-                                         be inlined\");\n-            }\n-            let val = base::get_item_val(bcx.ccx(), did.node);\n-\n-            // Next, we need to crate a ByRef rvalue datum to return. We can't\n-            // use the normal .to_ref_datum() function because the type of\n-            // `val` is not actually the same as `const_ty`.\n-            //\n-            // To get around this, we make a custom alloca slot with the\n-            // appropriate type (const_ty), and then we cast it to a pointer of\n-            // typeof(val), store the value, and then hand this slot over to\n-            // the datum infrastructure.\n-            let const_ty = expr_ty(bcx, ref_expr);\n-            let llty = type_of::type_of(bcx.ccx(), const_ty);\n-            let slot = alloca(bcx, llty, \"const\");\n-            let pty = Type::from_ref(unsafe { llvm::LLVMTypeOf(val) }).ptr_to();\n-            Store(bcx, val, PointerCast(bcx, slot, pty));\n-\n-            let datum = Datum::new(slot, const_ty, Rvalue::new(ByRef));\n-            DatumBlock::new(bcx, datum.to_expr_datum())\n+        def::DefConst(_) => {\n+            bcx.sess().span_bug(ref_expr.span,\n+                \"constant expression should not reach expr::trans_def\")\n         }\n         _ => {\n             DatumBlock::new(bcx, trans_local_var(bcx, def).to_expr_datum())\n@@ -1119,7 +1141,12 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             tvec::trans_fixed_vstore(bcx, expr, dest)\n         }\n         ast::ExprClosure(_, ref decl, ref body) => {\n-            closure::trans_closure_expr(bcx, &**decl, &**body, expr.id, dest)\n+            let dest = match dest {\n+                SaveIn(lldest) => closure::Dest::SaveIn(bcx, lldest),\n+                Ignore => closure::Dest::Ignore(bcx.ccx())\n+            };\n+            closure::trans_closure_expr(dest, &**decl, &**body, expr.id, bcx.fcx.param_substs)\n+                .unwrap_or(bcx)\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {\n@@ -1247,7 +1274,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                          ref_expr: &ast::Expr,\n                                          def: def::Def,\n-                                         param_substs: &subst::Substs<'tcx>)\n+                                         param_substs: &'tcx subst::Substs<'tcx>)\n                                          -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n@@ -1641,6 +1668,16 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n }\n \n+fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           lval: Datum<'tcx, Lvalue>)\n+                           -> DatumBlock<'blk, 'tcx, Expr> {\n+    let dest_ty = ty::close_type(bcx.tcx(), lval.ty);\n+    let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n+    memcpy_ty(bcx, scratch.val, lval.val, scratch.ty);\n+\n+    DatumBlock::new(bcx, scratch.to_expr_datum())\n+}\n+\n fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              expr: &ast::Expr,\n                              subexpr: &ast::Expr)\n@@ -1651,18 +1688,7 @@ fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match sub_datum.ty.sty {\n         ty::ty_open(_) => {\n             // Opened DST value, close to a fat pointer\n-            debug!(\"Closing fat pointer {}\", bcx.ty_to_string(sub_datum.ty));\n-\n-            let scratch = rvalue_scratch_datum(bcx,\n-                                               ty::close_type(bcx.tcx(), sub_datum.ty),\n-                                               \"fat_addr_of\");\n-            let base = Load(bcx, get_dataptr(bcx, sub_datum.val));\n-            Store(bcx, base, get_dataptr(bcx, scratch.val));\n-\n-            let len = Load(bcx, get_len(bcx, sub_datum.val));\n-            Store(bcx, len, get_len(bcx, scratch.val));\n-\n-            DatumBlock::new(bcx, scratch.to_expr_datum())\n+            ref_fat_ptr(bcx, sub_datum)\n         }\n         _ => {\n             // Sized value, ref to a thin pointer\n@@ -1687,9 +1713,10 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let tcx = bcx.tcx();\n     let is_simd = ty::type_is_simd(tcx, lhs_t);\n-    let intype = {\n-        if is_simd { ty::simd_type(tcx, lhs_t) }\n-        else { lhs_t }\n+    let intype = if is_simd {\n+        ty::simd_type(tcx, lhs_t)\n+    } else {\n+        lhs_t\n     };\n     let is_float = ty::type_is_fp(intype);\n     let is_signed = ty::type_is_signed(intype);\n@@ -1766,24 +1793,10 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n-        if ty::type_is_scalar(rhs_t) {\n-            unpack_result!(bcx,\n-                           base::compare_scalar_types(bcx,\n-                                                      lhs,\n-                                                      rhs,\n-                                                      rhs_t,\n-                                                      op.node,\n-                                                      binop_debug_loc))\n-        } else if is_simd {\n-            base::compare_simd_types(bcx,\n-                                     lhs,\n-                                     rhs,\n-                                     intype,\n-                                     ty::simd_size(tcx, lhs_t),\n-                                     op.node,\n-                                     binop_debug_loc)\n+        if is_simd {\n+            base::compare_simd_types(bcx, lhs, rhs, intype, op.node, binop_debug_loc)\n         } else {\n-            bcx.tcx().sess.span_bug(binop_expr.span, \"comparison operator unsupported for type\")\n+            base::compare_scalar_types(bcx, lhs, rhs, intype, op.node, binop_debug_loc)\n         }\n       }\n       _ => {\n@@ -1997,7 +2010,7 @@ pub fn cast_type_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> cast_kind {\n     }\n }\n \n-fn cast_is_noop<'tcx>(t_in: Ty<'tcx>, t_out: Ty<'tcx>) -> bool {\n+pub fn cast_is_noop<'tcx>(t_in: Ty<'tcx>, t_out: Ty<'tcx>) -> bool {\n     match (ty::deref(t_in, true), ty::deref(t_out, true)) {\n         (Some(ty::mt{ ty: t_in, .. }), Some(ty::mt{ ty: t_out, .. })) => {\n             t_in == t_out"}, {"sha": "8f0e4e647b5b3d1c8cceb646416d418b027ec037", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -557,7 +557,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                 body: &ast::Block,\n                                                 attrs: &[ast::Attribute],\n                                                 llwrapfn: ValueRef,\n-                                                param_substs: &Substs<'tcx>,\n+                                                param_substs: &'tcx Substs<'tcx>,\n                                                 id: ast::NodeId,\n                                                 hash: Option<&str>) {\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n@@ -577,7 +577,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fn build_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                decl: &ast::FnDecl,\n                                body: &ast::Block,\n-                               param_substs: &Substs<'tcx>,\n+                               param_substs: &'tcx Substs<'tcx>,\n                                attrs: &[ast::Attribute],\n                                id: ast::NodeId,\n                                hash: Option<&str>)"}, {"sha": "af90e1ec5c5dd47cb85ee6c152386f2c4eb06bea", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -558,12 +558,12 @@ fn make_generic_glue<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n     let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx(), t));\n     let _s = StatRecorder::new(ccx, glue_name);\n \n-    let empty_param_substs = Substs::trans_empty();\n+    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n                       ty::FnConverging(ty::mk_nil(ccx.tcx())),\n-                      &empty_param_substs, None, &arena);\n+                      empty_substs, None, &arena);\n \n     let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n "}, {"sha": "56fda20e0e8dcdc79d666da21b94e4f10247fc32", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -159,13 +159,14 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                     let unparameterized = impl_tpt.generics.types.is_empty() &&\n                             mth.pe_generics().ty_params.is_empty();\n \n+                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n                     if unparameterized {\n                         let llfn = get_item_val(ccx, mth.id);\n                         trans_fn(ccx,\n                                  &*mth.pe_fn_decl(),\n                                  &*mth.pe_body(),\n                                  llfn,\n-                                 &Substs::trans_empty(),\n+                                 empty_substs,\n                                  mth.id,\n                                  &[]);\n                         // Use InternalLinkage so LLVM can optimize more"}, {"sha": "1d5d24a64036dd6d69760ae564c7ce8dc6595f49", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 46, "deletions": 69, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -11,7 +11,7 @@\n use arena::TypedArena;\n use back::abi;\n use back::link;\n-use llvm::{self, ValueRef, get_param};\n+use llvm::{ValueRef, get_param};\n use metadata::csearch;\n use middle::subst::Substs;\n use middle::subst::VecPerParamSpace;\n@@ -23,6 +23,7 @@ use trans::callee::*;\n use trans::callee;\n use trans::cleanup;\n use trans::common::*;\n+use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n use trans::expr::{SaveIn, Ignore};\n@@ -36,7 +37,6 @@ use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use util::ppaux::Repr;\n \n-use std::ffi::CString;\n use std::rc::Rc;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n@@ -82,11 +82,12 @@ pub fn trans_impl(ccx: &CrateContext,\n                     let trans_everywhere = attr::requests_inline(&method.attrs[]);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n+                        let empty_substs = tcx.mk_substs(Substs::trans_empty());\n                         trans_fn(ccx,\n                                  method.pe_fn_decl(),\n                                  method.pe_body(),\n                                  llfn,\n-                                 &Substs::trans_empty(),\n+                                 empty_substs,\n                                  method.id,\n                                  &[]);\n                         update_linkage(ccx,\n@@ -174,7 +175,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                             method_id: ast::DefId,\n                                             trait_id: ast::DefId,\n                                             expr_id: ast::NodeId,\n-                                            param_substs: &subst::Substs<'tcx>)\n+                                            param_substs: &'tcx subst::Substs<'tcx>)\n                                             -> Datum<'tcx, Rvalue>\n {\n     let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n@@ -599,15 +600,15 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n \n-    let empty_substs = Substs::trans_empty();\n+    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx,\n                       llfn,\n                       ast::DUMMY_NODE_ID,\n                       false,\n                       sig.output,\n-                      &empty_substs,\n+                      empty_substs,\n                       None,\n                       &block_arena);\n     let mut bcx = init_function(&fcx, false, sig.output);\n@@ -689,19 +690,19 @@ pub fn trans_object_shim<'a, 'tcx>(\n /// `trait_ref` would map `T:Trait`, but `box_ty` would be\n /// `Foo<T>`. This `box_ty` is primarily used to encode the destructor.\n /// This will hopefully change now that DST is underway.\n-pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              box_ty: Ty<'tcx>,\n-                              trait_ref: ty::PolyTraitRef<'tcx>)\n-                              -> ValueRef\n+pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                            box_ty: Ty<'tcx>,\n+                            trait_ref: ty::PolyTraitRef<'tcx>,\n+                            param_substs: &'tcx subst::Substs<'tcx>)\n+                            -> ValueRef\n {\n-    debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n-           box_ty.repr(bcx.tcx()),\n-           trait_ref.repr(bcx.tcx()));\n-\n-    let tcx = bcx.tcx();\n-    let ccx = bcx.ccx();\n+    let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n+    debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n+           box_ty.repr(tcx),\n+           trait_ref.repr(tcx));\n+\n     // Check the cache.\n     let cache_key = (box_ty, trait_ref.clone());\n     match ccx.vtables().borrow().get(&cache_key) {\n@@ -711,9 +712,7 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Not in the cache. Build it.\n     let methods = traits::supertraits(tcx, trait_ref.clone()).flat_map(|trait_ref| {\n-        let vtable = fulfill_obligation(bcx.ccx(),\n-                                        DUMMY_SP,\n-                                        trait_ref.clone());\n+        let vtable = fulfill_obligation(ccx, DUMMY_SP, trait_ref.clone());\n         match vtable {\n             traits::VtableBuiltin(_) => {\n                 Vec::new().into_iter()\n@@ -723,83 +722,61 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     impl_def_id: id,\n                     substs,\n                     nested: _ }) => {\n-                emit_vtable_methods(bcx, id, substs).into_iter()\n+                emit_vtable_methods(ccx, id, substs, param_substs).into_iter()\n             }\n             traits::VtableClosure(closure_def_id, substs) => {\n                 let llfn = trans_fn_ref_with_substs(\n-                    bcx.ccx(),\n+                    ccx,\n                     closure_def_id,\n                     ExprId(0),\n-                    bcx.fcx.param_substs,\n-                    substs.clone()).val;\n+                    param_substs,\n+                    substs).val;\n \n-                (vec!(llfn)).into_iter()\n+                vec![llfn].into_iter()\n             }\n             traits::VtableFnPointer(bare_fn_ty) => {\n-                let llfn = vec![trans_fn_pointer_shim(bcx.ccx(), bare_fn_ty)];\n-                llfn.into_iter()\n+                vec![trans_fn_pointer_shim(ccx, bare_fn_ty)].into_iter()\n             }\n             traits::VtableObject(ref data) => {\n                 // this would imply that the Self type being erased is\n                 // an object type; this cannot happen because we\n                 // cannot cast an unsized type into a trait object\n-                bcx.sess().bug(\n+                tcx.sess.bug(\n                     &format!(\"cannot get vtable for an object type: {}\",\n-                             data.repr(bcx.tcx())));\n+                            data.repr(tcx)));\n             }\n             traits::VtableParam(..) => {\n-                bcx.sess().bug(\n+                tcx.sess.bug(\n                     &format!(\"resolved vtable for {} to bad vtable {} in trans\",\n-                            trait_ref.repr(bcx.tcx()),\n-                            vtable.repr(bcx.tcx()))[]);\n+                            trait_ref.repr(tcx),\n+                            vtable.repr(tcx))[]);\n             }\n         }\n     });\n \n     let size_ty = sizing_type_of(ccx, trait_ref.self_ty());\n     let size = machine::llsize_of_alloc(ccx, size_ty);\n-    let ll_size = C_uint(ccx, size);\n     let align = align_of(ccx, trait_ref.self_ty());\n-    let ll_align = C_uint(ccx, align);\n \n-    // Generate a destructor for the vtable.\n-    let drop_glue = glue::get_drop_glue(ccx, box_ty);\n-    let vtable = make_vtable(ccx, drop_glue, ll_size, ll_align, methods);\n+    let components: Vec<_> = vec![\n+        // Generate a destructor for the vtable.\n+        glue::get_drop_glue(ccx, box_ty),\n+        C_uint(ccx, size),\n+        C_uint(ccx, align)\n+    ].into_iter().chain(methods).collect();\n+\n+    let vtable = consts::addr_of(ccx, C_struct(ccx, &components, false),\n+                                 \"vtable\", trait_ref.def_id().node);\n \n     ccx.vtables().borrow_mut().insert(cache_key, vtable);\n     vtable\n }\n \n-/// Helper function to declare and initialize the vtable.\n-pub fn make_vtable<I: Iterator<Item=ValueRef>>(ccx: &CrateContext,\n-                                          drop_glue: ValueRef,\n-                                          size: ValueRef,\n-                                          align: ValueRef,\n-                                          ptrs: I)\n-                                          -> ValueRef {\n-    let _icx = push_ctxt(\"meth::make_vtable\");\n-\n-    let head = vec![drop_glue, size, align];\n-    let components: Vec<_> = head.into_iter().chain(ptrs).collect();\n-\n-    unsafe {\n-        let tbl = C_struct(ccx, &components[], false);\n-        let sym = token::gensym(\"vtable\");\n-        let buf = CString::from_vec(format!(\"vtable{}\", sym.usize()).into_bytes());\n-        let vt_gvar = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(),\n-                                          buf.as_ptr());\n-        llvm::LLVMSetInitializer(vt_gvar, tbl);\n-        llvm::LLVMSetGlobalConstant(vt_gvar, llvm::True);\n-        llvm::SetLinkage(vt_gvar, llvm::InternalLinkage);\n-        vt_gvar\n-    }\n-}\n-\n-fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   impl_id: ast::DefId,\n-                                   substs: subst::Substs<'tcx>)\n-                                   -> Vec<ValueRef> {\n-    let ccx = bcx.ccx();\n+fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                 impl_id: ast::DefId,\n+                                 substs: subst::Substs<'tcx>,\n+                                 param_substs: &'tcx subst::Substs<'tcx>)\n+                                 -> Vec<ValueRef> {\n     let tcx = ccx.tcx();\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n@@ -808,7 +785,7 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       make a vtable for a type impl!\")\n     };\n \n-    ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trt_id);\n+    ty::populate_implementations_for_trait_if_necessary(tcx, trt_id);\n \n     let trait_item_def_ids = ty::trait_item_def_ids(tcx, trt_id);\n     trait_item_def_ids.iter().flat_map(|method_def_id| {\n@@ -835,7 +812,7 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         ccx,\n                         m_id,\n                         ExprId(0),\n-                        bcx.fcx.param_substs,\n+                        param_substs,\n                         substs.clone()).val;\n \n                     // currently, at least, by-value self is not object safe\n@@ -882,7 +859,7 @@ pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n-    let vtable = get_vtable(bcx, datum_ty, trait_ref);\n+    let vtable = get_vtable(bcx.ccx(), datum_ty, trait_ref, bcx.fcx.param_substs);\n     let llvtabledest = GEPi(bcx, lldest, &[0, abi::FAT_PTR_EXTRA]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n     Store(bcx, vtable, llvtabledest);"}, {"sha": "30797344da810889e235e2f761ae876a60c3d795", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -36,7 +36,7 @@ use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: ast::DefId,\n-                                psubsts: &subst::Substs<'tcx>,\n+                                psubsts: &'tcx subst::Substs<'tcx>,\n                                 ref_id: Option<ast::NodeId>)\n     -> (ValueRef, Ty<'tcx>, bool) {\n     debug!(\"monomorphic_fn(\\\n@@ -55,7 +55,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let hash_id = MonoId {\n         def: fn_id,\n-        params: psubsts.types.clone()\n+        params: &psubsts.types\n     };\n \n     let item_ty = ty::lookup_item_type(ccx.tcx(), fn_id).ty;\n@@ -289,7 +289,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct MonoId<'tcx> {\n     pub def: ast::DefId,\n-    pub params: subst::VecPerParamSpace<Ty<'tcx>>\n+    pub params: &'tcx subst::VecPerParamSpace<Ty<'tcx>>\n }\n \n /// Monomorphizes a type from the AST by first applying the in-scope"}, {"sha": "8f10865ae32bc4f19e4bae7b6599c87060ba950f", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -309,8 +309,6 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     |set_bcx, lleltptr, _| {\n                                                         elem.shallow_copy(set_bcx, lleltptr)\n                                                     });\n-\n-                            elem.add_clean_if_rvalue(bcx, element.id);\n                             bcx\n                         }\n                     }"}, {"sha": "68054c79f274eefa877e792f153cabc474d34832", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -1183,7 +1183,7 @@ pub fn ast_ty_to_ty<'tcx>(\n                 qpath_to_ty(this, rscope, ast_ty, &**qpath)\n             }\n             ast::TyFixedLengthVec(ref ty, ref e) => {\n-                match const_eval::eval_const_expr_partial(tcx, &**e) {\n+                match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.uint)) {\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>"}, {"sha": "81868f3695c28dafea22137a4a7edda229cb7603", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -8,19 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::const_eval;\n use middle::def;\n use middle::infer;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n use middle::subst::{Substs};\n use middle::ty::{self, Ty};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n-use check::{instantiate_path, structurally_resolved_type, valid_range_bounds};\n+use check::{instantiate_path, structurally_resolved_type};\n use require_same_types;\n use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n-use std::cmp;\n+use std::cmp::{self, Ordering};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::ast;\n use syntax::ast_util;\n@@ -79,16 +80,17 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 lhs_eq_rhs && (ty::type_is_numeric(lhs_ty) || ty::type_is_char(lhs_ty));\n \n             if numeric_or_char {\n-                match valid_range_bounds(fcx.ccx, &**begin, &**end) {\n-                    Some(false) => {\n+                match const_eval::compare_lit_exprs(tcx, &**begin, &**end, Some(lhs_ty)) {\n+                    Some(Ordering::Less) |\n+                    Some(Ordering::Equal) => {}\n+                    Some(Ordering::Greater) => {\n                         span_err!(tcx.sess, begin.span, E0030,\n                             \"lower range bound must be less than upper\");\n-                    },\n+                    }\n                     None => {\n                         span_err!(tcx.sess, begin.span, E0031,\n                             \"mismatched types in range\");\n-                    },\n-                    Some(true) => {}\n+                    }\n                 }\n             } else {\n                 span_err!(tcx.sess, begin.span, E0029,"}, {"sha": "1c15e295ad934dbfd9769da829e9f455455838e4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -2499,16 +2499,6 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn valid_range_bounds(ccx: &CrateCtxt,\n-                          from: &ast::Expr,\n-                          to: &ast::Expr)\n-                       -> Option<bool> {\n-    match const_eval::compare_lit_exprs(ccx.tcx, from, to) {\n-        Some(val) => Some(val <= 0),\n-        None => None\n-    }\n-}\n-\n pub fn check_expr_has_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      expr: &'tcx ast::Expr,\n                                      expected: Ty<'tcx>) {\n@@ -3596,24 +3586,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             // Finally, borrowck is charged with guaranteeing that the\n             // value whose address was taken can actually be made to live\n             // as long as it needs to live.\n-            match oprnd.node {\n-                // String literals are already, implicitly converted to slices.\n-                //ast::ExprLit(lit) if ast_util::lit_is_str(lit) => fcx.expr_ty(oprnd),\n-                // Empty slices live in static memory.\n-                ast::ExprVec(ref elements) if elements.len() == 0 => {\n-                    // Note: we do not assign a lifetime of\n-                    // static. This is because the resulting type\n-                    // `&'static [T]` would require that T outlives\n-                    // `'static`!\n-                    let region = fcx.infcx().next_region_var(\n-                        infer::AddrOfSlice(expr.span));\n-                    ty::mk_rptr(tcx, tcx.mk_region(region), tm)\n-                }\n-                _ => {\n-                    let region = fcx.infcx().next_region_var(infer::AddrOfRegion(expr.span));\n-                    ty::mk_rptr(tcx, tcx.mk_region(region), tm)\n-                }\n-            }\n+            let region = fcx.infcx().next_region_var(infer::AddrOfRegion(expr.span));\n+            ty::mk_rptr(tcx, tcx.mk_region(region), tm)\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n@@ -4550,7 +4524,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                     // that the expression is in a form that eval_const_expr can\n                     // handle, so we may still get an internal compiler error\n \n-                    match const_eval::eval_const_expr_partial(ccx.tcx, &**e) {\n+                    match const_eval::eval_const_expr_partial(ccx.tcx, &**e, Some(declty)) {\n                         Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n                         Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {"}, {"sha": "c45efe5f54b2cc9ed4d1a54a177b7139990bd221", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -40,7 +40,9 @@ fn run(repeat: int, depth: int) {\n     }\n }\n \n-type nillist = List<()>;\n+// FIXME(#21721) used to be `List<()>` but that can cause\n+// certain LLVM versions to abort during optimizations.\n+type nillist = List<[u8; 0]>;\n \n // Filled with things that have to be unwound\n \n@@ -81,11 +83,11 @@ fn recurse_or_panic(depth: int, st: Option<State>) {\n             }\n             Some(st) => {\n                 let mut v = st.vec.clone();\n-                v.push_all(&[box List::Cons((), st.vec.last().unwrap().clone())]);\n+                v.push_all(&[box List::Cons([], st.vec.last().unwrap().clone())]);\n                 State {\n-                    unique: box List::Cons((), box *st.unique),\n+                    unique: box List::Cons([], box *st.unique),\n                     vec: v,\n-                    res: r(box List::Cons((), st.res._l.clone())),\n+                    res: r(box List::Cons([], st.res._l.clone())),\n                 }\n             }\n         };"}, {"sha": "1804b9e04c2c90eee2fa06afa026a2b5b005f6a5", "filename": "src/test/compile-fail/check-static-immutable-mut-slices.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -11,6 +11,6 @@\n // Checks that immutable static items can't have mutable slices\n \n static TEST: &'static mut [isize] = &mut [];\n-//~^ ERROR statics are not allowed to have mutable references\n+//~^ ERROR references in statics may only refer to immutable values\n \n pub fn main() { }"}, {"sha": "0180bccbca40bcfd752fc17c855814554a583196", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -99,7 +99,7 @@ static STATIC10: UnsafeStruct = UnsafeStruct;\n struct MyOwned;\n \n static STATIC11: Box<MyOwned> = box MyOwned;\n-//~^ ERROR statics are not allowed to have custom pointers\n+//~^ ERROR allocations are not allowed in statics\n \n // The following examples test that mutable structs are just forbidden\n // to have types with destructors\n@@ -117,26 +117,27 @@ static mut STATIC14: SafeStruct = SafeStruct {\n //~^ ERROR mutable statics are not allowed to have destructors\n     field1: SafeEnum::Variant1,\n     field2: SafeEnum::Variant4(\"str\".to_string())\n+//~^ ERROR static contains unimplemented expression type\n };\n \n static STATIC15: &'static [Box<MyOwned>] = &[\n-    box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n-    box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n+    box MyOwned, //~ ERROR allocations are not allowed in statics\n+    box MyOwned, //~ ERROR allocations are not allowed in statics\n ];\n \n static STATIC16: (&'static Box<MyOwned>, &'static Box<MyOwned>) = (\n-    &box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n-    &box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n+    &box MyOwned, //~ ERROR allocations are not allowed in statics\n+    &box MyOwned, //~ ERROR allocations are not allowed in statics\n );\n \n static mut STATIC17: SafeEnum = SafeEnum::Variant1;\n //~^ ERROR mutable statics are not allowed to have destructors\n \n static STATIC19: Box<isize> =\n     box 3;\n-//~^ ERROR statics are not allowed to have custom pointers\n+//~^ ERROR allocations are not allowed in statics\n \n pub fn main() {\n     let y = { static x: Box<isize> = box 3; x };\n-    //~^ ERROR statics are not allowed to have custom pointers\n+    //~^ ERROR allocations are not allowed in statics\n }"}, {"sha": "f66c68541b1849a7468cb481d12ba20be0d3a9d0", "filename": "src/test/compile-fail/const-block-non-item-statement.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -8,18 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static A: usize = { 1us; 2 };\n+const A: usize = { 1us; 2 };\n //~^ ERROR: blocks in constants are limited to items and tail expressions\n \n-static B: usize = { { } 2 };\n+const B: usize = { { } 2 };\n //~^ ERROR: blocks in constants are limited to items and tail expressions\n \n macro_rules! foo {\n     () => (()) //~ ERROR: blocks in constants are limited to items and tail expressions\n }\n-static C: usize = { foo!(); 2 };\n+const C: usize = { foo!(); 2 };\n \n-static D: usize = { let x = 4us; 2 };\n+const D: usize = { let x = 4us; 2 };\n //~^ ERROR: blocks in constants are limited to items and tail expressions\n \n pub fn main() {"}, {"sha": "6d2cfcab04e36aa757cf40418f7127e917453590", "filename": "src/test/compile-fail/issue-16538.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -20,6 +20,7 @@ mod Y {\n \n static foo: *const Y::X = Y::foo(Y::x as *const Y::X);\n //~^ ERROR cannot refer to other statics by value\n-//~| ERROR: the trait `core::marker::Sync` is not implemented for the type\n+//~| ERROR the trait `core::marker::Sync` is not implemented for the type\n+//~| ERROR function calls in statics are limited to struct and enum constructors\n \n fn main() {}"}, {"sha": "d6f70ae1e57416498d181cd251d4f80fb423e79b", "filename": "src/test/compile-fail/issue-17458.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n static X: usize = 0 as *const usize as usize;\n-//~^ ERROR: can not cast a pointer to an integer in a constant expression\n+//~^ ERROR: can not cast a pointer to an integer in statics\n \n fn main() {\n     assert_eq!(X, 0);"}, {"sha": "2347d3f3d5c0a66f675d1fa00792aa392db9bff8", "filename": "src/test/compile-fail/issue-17718-const-bad-values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n const C1: &'static mut [usize] = &mut [];\n-//~^ ERROR: constants are not allowed to have mutable references\n+//~^ ERROR: references in constants may only refer to immutable values\n \n static mut S: usize = 3;\n const C2: &'static mut usize = &mut S;\n //~^ ERROR: constants cannot refer to other statics\n-//~^^ ERROR: are not allowed to have mutable references\n+//~^^ ERROR: references in constants may only refer to immutable values\n \n fn main() {}\n "}, {"sha": "c5370879cc2db1b955f4af66f6a66a0d5f5e656e", "filename": "src/test/compile-fail/issue-18118.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -9,9 +9,10 @@\n // except according to those terms.\n \n pub fn main() {\n-    static z: &'static isize = {\n+    const z: &'static isize = {\n         let p = 3;\n+        //~^ ERROR blocks in constants are limited to items and tail expressions\n         &p\n-//~^ ERROR cannot borrow a local variable inside a static block, define a separate static instead\n+        //~^ ERROR paths in constants may only refer to constants or functions\n     };\n }"}, {"sha": "c2bd810abad2537858a7a202cc1fed87fff22b73", "filename": "src/test/compile-fail/issue-6977.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fcompile-fail%2Fissue-6977.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fcompile-fail%2Fissue-6977.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6977.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Trying to create a fixed-length vector with a negative size\n-\n-fn main() {\n-      let _x = [0; -1]; //~ ERROR found negative integer\n-}"}, {"sha": "6a36b2f84bfc901e9992bba0905422cf4be94f0d", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -14,8 +14,9 @@ use std::cell::RefCell;\n \n // Regression test for issue 7364\n static boxed: Box<RefCell<isize>> = box RefCell::new(0);\n-//~^ ERROR statics are not allowed to have custom pointers\n-//~| ERROR: the trait `core::marker::Sync` is not implemented for the type\n-//~| ERROR: the trait `core::marker::Sync` is not implemented for the type\n+//~^ ERROR allocations are not allowed in statics\n+//~| ERROR the trait `core::marker::Sync` is not implemented for the type\n+//~| ERROR the trait `core::marker::Sync` is not implemented for the type\n+//~| ERROR function calls in statics are limited to struct and enum constructors\n \n fn main() { }"}, {"sha": "01bed69fb1de9e23cc3f05ee9172be050c161d95", "filename": "src/test/compile-fail/issue-8460-const.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{int, i8, i16, i32, i64};\n+use std::thread::Thread;\n+\n+fn main() {\n+    assert!(Thread::scoped(move|| int::MIN / -1).join().is_err());\n+    //~^ ERROR attempted to divide with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i8::MIN / -1).join().is_err());\n+    //~^ ERROR attempted to divide with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i16::MIN / -1).join().is_err());\n+    //~^ ERROR attempted to divide with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i32::MIN / -1).join().is_err());\n+    //~^ ERROR attempted to divide with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i64::MIN / -1).join().is_err());\n+    //~^ ERROR attempted to divide with overflow in a constant expression\n+    assert!(Thread::scoped(move|| 1is / 0).join().is_err());\n+    //~^ ERROR attempted to divide by zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i8 / 0).join().is_err());\n+    //~^ ERROR attempted to divide by zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i16 / 0).join().is_err());\n+    //~^ ERROR attempted to divide by zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i32 / 0).join().is_err());\n+    //~^ ERROR attempted to divide by zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i64 / 0).join().is_err());\n+    //~^ ERROR attempted to divide by zero in a constant expression\n+    assert!(Thread::scoped(move|| int::MIN % -1).join().is_err());\n+    //~^ ERROR attempted remainder with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i8::MIN % -1).join().is_err());\n+    //~^ ERROR attempted remainder with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i16::MIN % -1).join().is_err());\n+    //~^ ERROR attempted remainder with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i32::MIN % -1).join().is_err());\n+    //~^ ERROR attempted remainder with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i64::MIN % -1).join().is_err());\n+    //~^ ERROR attempted remainder with overflow in a constant expression\n+    assert!(Thread::scoped(move|| 1is % 0).join().is_err());\n+    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i8 % 0).join().is_err());\n+    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i16 % 0).join().is_err());\n+    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i32 % 0).join().is_err());\n+    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i64 % 0).join().is_err());\n+    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+}"}, {"sha": "d730add00b7f03c2a936e760762d552d0cd790a8", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -41,8 +41,18 @@ fn main() {\n     //~| expected usize\n     //~| found &-ptr\n     //~| ERROR expected positive integer for repeat count, found string\n-    let f = [0; -4];\n-    //~^ ERROR expected positive integer for repeat count, found negative integer\n-    let f = [0us; -1];\n-    //~^ ERROR expected positive integer for repeat count, found negative integer\n+    let f = [0; -4is];\n+    //~^ ERROR mismatched types\n+    //~| expected `usize`\n+    //~| found `isize`\n+    //~| expected usize\n+    //~| found isize\n+    //~| ERROR expected positive integer for repeat count, found negative integer\n+    let f = [0us; -1is];\n+    //~^ ERROR mismatched types\n+    //~| expected `usize`\n+    //~| found `isize`\n+    //~| expected usize\n+    //~| found isize\n+    //~| ERROR expected positive integer for repeat count, found negative integer\n }"}, {"sha": "08148328edcf30d7fe87ff7bccf5ee0a7b55afc6", "filename": "src/test/compile-fail/static-mut-not-constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -11,7 +11,7 @@\n #![feature(box_syntax)]\n \n static mut a: Box<isize> = box 3;\n-//~^ ERROR statics are not allowed to have custom pointers\n+//~^ ERROR allocations are not allowed in statics\n //~^^ ERROR mutable statics are not allowed to have owned pointers\n \n fn main() {}"}, {"sha": "7a957564587f9b7a7ea84d3a8532da718eb99a2e", "filename": "src/test/compile-fail/static-vec-repeat-not-constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fstatic-vec-repeat-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fcompile-fail%2Fstatic-vec-repeat-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-vec-repeat-not-constant.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -11,6 +11,6 @@\n fn foo() -> isize { 23 }\n \n static a: [isize; 2] = [foo(); 2];\n-//~^ ERROR: function calls in constants are limited to struct and enum constructors\n+//~^ ERROR: function calls in statics are limited to struct and enum constructors\n \n fn main() {}"}, {"sha": "91e78c820e6ff059b2a0b562f0dbb9de88ec00c8", "filename": "src/test/debuginfo/basic-types-globals-metadata.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -47,26 +47,26 @@\n #![allow(dead_code)]\n #![omit_gdb_pretty_printer_section]\n \n-\n-static B: bool = false;\n-static I: int = -1;\n-static C: char = 'a';\n-static I8: i8 = 68;\n-static I16: i16 = -16;\n-static I32: i32 = -32;\n-static I64: i64 = -64;\n-static U: uint = 1;\n-static U8: u8 = 100;\n-static U16: u16 = 16;\n-static U32: u32 = 32;\n-static U64: u64 = 64;\n-static F32: f32 = 2.5;\n-static F64: f64 = 3.5;\n+// N.B. These are `mut` only so they don't constant fold away.\n+static mut B: bool = false;\n+static mut I: int = -1;\n+static mut C: char = 'a';\n+static mut I8: i8 = 68;\n+static mut I16: i16 = -16;\n+static mut I32: i32 = -32;\n+static mut I64: i64 = -64;\n+static mut U: uint = 1;\n+static mut U8: u8 = 100;\n+static mut U16: u16 = 16;\n+static mut U32: u32 = 32;\n+static mut U64: u64 = 64;\n+static mut F32: f32 = 2.5;\n+static mut F64: f64 = 3.5;\n \n fn main() {\n     _zzz(); // #break\n \n-    let a = (B, I, C, I8, I16, I32, I64, U, U8, U16, U32, U64, F32, F64);\n+    let a = unsafe { (B, I, C, I8, I16, I32, I64, U, U8, U16, U32, U64, F32, F64) };\n }\n \n fn _zzz() {()}"}, {"sha": "d37b0f60d3da0e58bbfcec0e70ae8e3707462ac0", "filename": "src/test/debuginfo/basic-types-globals.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -52,25 +52,26 @@\n #![allow(unused_variables)]\n #![omit_gdb_pretty_printer_section]\n \n-static B: bool = false;\n-static I: int = -1;\n-static C: char = 'a';\n-static I8: i8 = 68;\n-static I16: i16 = -16;\n-static I32: i32 = -32;\n-static I64: i64 = -64;\n-static U: uint = 1;\n-static U8: u8 = 100;\n-static U16: u16 = 16;\n-static U32: u32 = 32;\n-static U64: u64 = 64;\n-static F32: f32 = 2.5;\n-static F64: f64 = 3.5;\n+// N.B. These are `mut` only so they don't constant fold away.\n+static mut B: bool = false;\n+static mut I: int = -1;\n+static mut C: char = 'a';\n+static mut I8: i8 = 68;\n+static mut I16: i16 = -16;\n+static mut I32: i32 = -32;\n+static mut I64: i64 = -64;\n+static mut U: uint = 1;\n+static mut U8: u8 = 100;\n+static mut U16: u16 = 16;\n+static mut U32: u32 = 32;\n+static mut U64: u64 = 64;\n+static mut F32: f32 = 2.5;\n+static mut F64: f64 = 3.5;\n \n fn main() {\n     _zzz(); // #break\n \n-    let a = (B, I, C, I8, I16, I32, I64, U, U8, U16, U32, U64, F32, F64);\n+    let a = unsafe { (B, I, C, I8, I16, I32, I64, U, U8, U16, U32, U64, F32, F64) };\n }\n \n fn _zzz() {()}"}, {"sha": "50dc63b1debb515bc324cebe0d725b57d8b53461", "filename": "src/test/run-make/issue-7349/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Frun-make%2Fissue-7349%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Frun-make%2Fissue-7349%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-7349%2FMakefile?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -7,5 +7,5 @@\n \n all:\n \t$(RUSTC) foo.rs --emit=llvm-ir\n-\t[ \"$$(grep -c 8675309 \"$(TMPDIR)/foo.ll\")\" -eq \"1\" ]\n-\t[ \"$$(grep -c 11235813 \"$(TMPDIR)/foo.ll\")\" -eq \"1\" ]\n+\t[ \"$$(grep -c 'ret i32 8675309' \"$(TMPDIR)/foo.ll\")\" -eq \"1\" ]\n+\t[ \"$$(grep -c 'ret i32 11235813' \"$(TMPDIR)/foo.ll\")\" -eq \"1\" ]"}, {"sha": "3a2ced80ef41ed86657c865aa349a0efc6642394", "filename": "src/test/run-make/issue-7349/foo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Frun-make%2Fissue-7349%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Frun-make%2Fissue-7349%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-7349%2Ffoo.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -10,14 +10,14 @@\n \n fn outer<T>() {\n     #[allow(dead_code)]\n-    fn inner() -> uint {\n+    fn inner() -> u32 {\n         8675309\n     }\n }\n \n extern \"C\" fn outer_foreign<T>() {\n     #[allow(dead_code)]\n-    fn inner() -> uint {\n+    fn inner() -> u32 {\n         11235813\n     }\n }"}, {"sha": "5377d9a62b91a48be06ee049fcb8e89f74244de9", "filename": "src/test/run-pass/const-adt-align-mismatch.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Frun-pass%2Fconst-adt-align-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Frun-pass%2Fconst-adt-align-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-adt-align-mismatch.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+#[derive(PartialEq, Show)]\n+enum Foo {\n+    A(u32),\n+    Bar([u16; 4]),\n+    C\n+}\n+\n+// NOTE(eddyb) Don't make this a const, needs to be a static\n+// so it is always instantiated as a LLVM constant value.\n+static FOO: Foo = Foo::C;\n+\n+fn main() {\n+    assert_eq!(FOO, Foo::C);\n+    assert_eq!(mem::size_of::<Foo>(), 12);\n+    assert_eq!(mem::min_align_of::<Foo>(), 4);\n+}"}, {"sha": "ce5a0aa96e3d308493653125406e769e10e8bce1", "filename": "src/test/run-pass/issue-17216.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Frun-pass%2Fissue-17216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Frun-pass%2Fissue-17216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17216.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -25,7 +25,9 @@ fn main() {\n     let mut dropped = false;\n     {\n         let leak = Leak { dropped: &mut dropped };\n-        for ((), leaked) in Some(((),leak)).into_iter() {}\n+        // FIXME(#21721) \"hack\" used to be () but that can cause\n+        // certain LLVM versions to abort during optimizations.\n+        for (_, leaked) in Some((\"hack\", leak)).into_iter() {}\n     }\n \n     assert!(dropped);"}, {"sha": "4b9ed44c7cd7a93754e5a9cc8874fb69e9d8f769", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e7aa28566d062514a7a1f5534d76b9d82f524a/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=e4e7aa28566d062514a7a1f5534d76b9d82f524a", "patch": "@@ -8,28 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{int, i8, i16, i32, i64};\n+use std::num::Int;\n use std::thread::Thread;\n \n+// Avoid using constants, which would trigger compile-time errors.\n+fn min_val<T: Int>() -> T { Int::min_value() }\n+fn zero<T: Int>() -> T { Int::zero() }\n+\n fn main() {\n-    assert!(Thread::scoped(move|| int::MIN / -1).join().is_err());\n-    assert!(Thread::scoped(move|| i8::MIN / -1).join().is_err());\n-    assert!(Thread::scoped(move|| i16::MIN / -1).join().is_err());\n-    assert!(Thread::scoped(move|| i32::MIN / -1).join().is_err());\n-    assert!(Thread::scoped(move|| i64::MIN / -1).join().is_err());\n-    assert!(Thread::scoped(move|| 1 / 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i8 / 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i16 / 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i32 / 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i64 / 0).join().is_err());\n-    assert!(Thread::scoped(move|| int::MIN % -1).join().is_err());\n-    assert!(Thread::scoped(move|| i8::MIN % -1).join().is_err());\n-    assert!(Thread::scoped(move|| i16::MIN % -1).join().is_err());\n-    assert!(Thread::scoped(move|| i32::MIN % -1).join().is_err());\n-    assert!(Thread::scoped(move|| i64::MIN % -1).join().is_err());\n-    assert!(Thread::scoped(move|| 1 % 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i8 % 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i16 % 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i32 % 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i64 % 0).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<isize>() / -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i8>() / -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i16>() / -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i32>() / -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i64>() / -1).join().is_err());\n+    assert!(Thread::scoped(move|| 1is / zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i8 / zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i16 / zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i32 / zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i64 / zero()).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<isize>() % -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i8>() % -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i16>() % -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i32>() % -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i64>() % -1).join().is_err());\n+    assert!(Thread::scoped(move|| 1is % zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i8 % zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i16 % zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i32 % zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i64 % zero()).join().is_err());\n }"}]}