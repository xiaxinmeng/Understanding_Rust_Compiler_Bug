{"sha": "3f306db3dbe390f43c7dfa8e17630747723e39e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMzA2ZGIzZGJlMzkwZjQzYzdkZmE4ZTE3NjMwNzQ3NzIzZTM5ZTM=", "commit": {"author": {"name": "Pavel Krajcevski", "email": "Krajcevski@gmail.com", "date": "2018-10-28T16:16:46Z"}, "committer": {"name": "Pavel Krajcevski", "email": "Krajcevski@gmail.com", "date": "2019-03-11T17:31:21Z"}, "message": "Add initial implementation of 'sort_at_index' for slices -- analog to C++'s std::nth_element (a.k.a. quickselect)\n\nAdd some more notes to the documentation:\n\n- Mention that the median can be found if we used `len() / 2`.\n- Mention that this function is usually called \"kth element\" in other libraries.\n\nAddress some comments in PR:\n\n- Change wording on some of the documentation\n- Change recursive function into a loop\n\nUpdate name to `partition_at_index` and add convenience return values.\n\nAddress reviewer comments:\n\n- Don't swap on each iteration when searching for min/max element.\n- Add some docs about when we panic.\n- Test that the sum of the lengths of the output matches the length of the input.\n- Style fix for for-loop.\n\nAddress more reviewer comments\n\nFix Rng stuff for test\n\nFix doc test build\n\nDon't run the partition_at_index test on wasm targets\n\nMiri does not support entropy for test partition_at_index", "tree": {"sha": "153f0ef69c239041acf7180349ce4b007a503689", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/153f0ef69c239041acf7180349ce4b007a503689"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f306db3dbe390f43c7dfa8e17630747723e39e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f306db3dbe390f43c7dfa8e17630747723e39e3", "html_url": "https://github.com/rust-lang/rust/commit/3f306db3dbe390f43c7dfa8e17630747723e39e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f306db3dbe390f43c7dfa8e17630747723e39e3/comments", "author": {"login": "Mokosha", "id": 885364, "node_id": "MDQ6VXNlcjg4NTM2NA==", "avatar_url": "https://avatars.githubusercontent.com/u/885364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mokosha", "html_url": "https://github.com/Mokosha", "followers_url": "https://api.github.com/users/Mokosha/followers", "following_url": "https://api.github.com/users/Mokosha/following{/other_user}", "gists_url": "https://api.github.com/users/Mokosha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mokosha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mokosha/subscriptions", "organizations_url": "https://api.github.com/users/Mokosha/orgs", "repos_url": "https://api.github.com/users/Mokosha/repos", "events_url": "https://api.github.com/users/Mokosha/events{/privacy}", "received_events_url": "https://api.github.com/users/Mokosha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mokosha", "id": 885364, "node_id": "MDQ6VXNlcjg4NTM2NA==", "avatar_url": "https://avatars.githubusercontent.com/u/885364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mokosha", "html_url": "https://github.com/Mokosha", "followers_url": "https://api.github.com/users/Mokosha/followers", "following_url": "https://api.github.com/users/Mokosha/following{/other_user}", "gists_url": "https://api.github.com/users/Mokosha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mokosha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mokosha/subscriptions", "organizations_url": "https://api.github.com/users/Mokosha/orgs", "repos_url": "https://api.github.com/users/Mokosha/repos", "events_url": "https://api.github.com/users/Mokosha/events{/privacy}", "received_events_url": "https://api.github.com/users/Mokosha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "html_url": "https://github.com/rust-lang/rust/commit/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e"}], "stats": {"total": 355, "additions": 355, "deletions": 0}, "files": [{"sha": "8228e27f014d7596d6a0aeb6c0a5599f01c9fe74", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/3f306db3dbe390f43c7dfa8e17630747723e39e3/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f306db3dbe390f43c7dfa8e17630747723e39e3/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=3f306db3dbe390f43c7dfa8e17630747723e39e3", "patch": "@@ -1585,6 +1585,153 @@ impl<T> [T] {\n         sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n+    /// Reorder the slice such that the element at `index` is at its final sorted position.\n+    ///\n+    /// This reordering has the additional property that any value at position `i < index` will be\n+    /// less than or equal to any value at a position `j > index`. Additionally, this reordering is\n+    /// unstable (i.e. any number of equal elements may end up at position `index`), in-place\n+    /// (i.e. does not allocate), and `O(n)` worst-case. This function is also/ known as \"kth\n+    /// element\" in other libraries. It returns a triplet of the following values: all elements less\n+    /// than the one at the given index, the value at the given index, and all elements greater than\n+    /// the one at the given index.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n+    /// used for [`sort_unstable`].\n+    ///\n+    /// [`sort_unstable`]: #method.sort_unstable\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_at_index)]\n+    ///\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// // Find the median\n+    /// v.partition_at_index(2);\n+    ///\n+    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n+    /// // about the specified index.\n+    /// assert!(v == [-3, -5, 1, 2, 4] ||\n+    ///         v == [-5, -3, 1, 2, 4] ||\n+    ///         v == [-3, -5, 1, 4, 2] ||\n+    ///         v == [-5, -3, 1, 4, 2]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n+    #[inline]\n+    pub fn partition_at_index(&mut self, index: usize) -> (&mut [T], &mut T, &mut [T])\n+        where T: Ord\n+    {\n+        let mut f = |a: &T, b: &T| a.lt(b);\n+        sort::partition_at_index(self, index, &mut f)\n+    }\n+\n+    /// Reorder the slice with a comparator function such that the element at `index` is at its\n+    /// final sorted position.\n+    ///\n+    /// This reordering has the additional property that any value at position `i < index` will be\n+    /// less than or equal to any value at a position `j > index` using the comparator function.\n+    /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n+    /// position `index`), in-place (i.e. does not allocate), and `O(n)` worst-case. This function\n+    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n+    /// values: all elements less than the one at the given index, the value at the given index,\n+    /// and all elements greater than the one at the given index, using the provided comparator\n+    /// function.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n+    /// used for [`sort_unstable`].\n+    ///\n+    /// [`sort_unstable`]: #method.sort_unstable\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_at_index)]\n+    ///\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// // Find the median as if the slice were sorted in descending order.\n+    /// v.partition_at_index_by(2, |a, b| b.cmp(a));\n+    ///\n+    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n+    /// // about the specified index.\n+    /// assert!(v == [2, 4, 1, -5, -3] ||\n+    ///         v == [2, 4, 1, -3, -5] ||\n+    ///         v == [4, 2, 1, -5, -3] ||\n+    ///         v == [4, 2, 1, -3, -5]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n+    #[inline]\n+    pub fn partition_at_index_by<F>(&mut self, index: usize, mut compare: F)\n+                                    -> (&mut [T], &mut T, &mut [T])\n+        where F: FnMut(&T, &T) -> Ordering\n+    {\n+        let mut f = |a: &T, b: &T| compare(a, b) == Less;\n+        sort::partition_at_index(self, index, &mut f)\n+    }\n+\n+    /// Reorder the slice with a key extraction function such that the element at `index` is at its\n+    /// final sorted position.\n+    ///\n+    /// This reordering has the additional property that any value at position `i < index` will be\n+    /// less than or equal to any value at a position `j > index` using the key extraction function.\n+    /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n+    /// position `index`), in-place (i.e. does not allocate), and `O(n)` worst-case. This function\n+    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n+    /// values: all elements less than the one at the given index, the value at the given index, and\n+    /// all elements greater than the one at the given index, using the provided key extraction\n+    /// function.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n+    /// used for [`sort_unstable`].\n+    ///\n+    /// [`sort_unstable`]: #method.sort_unstable\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_at_index)]\n+    ///\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// // Return the median as if the array were sorted according to absolute value.\n+    /// v.partition_at_index_by_key(2, |a| a.abs());\n+    ///\n+    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n+    /// // about the specified index.\n+    /// assert!(v == [1, 2, -3, 4, -5] ||\n+    ///         v == [1, 2, -3, -5, 4] ||\n+    ///         v == [2, 1, -3, 4, -5] ||\n+    ///         v == [2, 1, -3, -5, 4]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n+    #[inline]\n+    pub fn partition_at_index_by_key<K, F>(&mut self, index: usize, mut f: F)\n+                                           -> (&mut [T], &mut T, &mut [T])\n+        where F: FnMut(&T) -> K, K: Ord\n+    {\n+        let mut g = |a: &T, b: &T| f(a).lt(&f(b));\n+        sort::partition_at_index(self, index, &mut g)\n+    }\n+\n     /// Moves all consecutive repeated elements to the end of the slice according to the\n     /// [`PartialEq`] trait implementation.\n     ///"}, {"sha": "68f1fb4b526adf902069592e1b57dab09730d612", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3f306db3dbe390f43c7dfa8e17630747723e39e3/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f306db3dbe390f43c7dfa8e17630747723e39e3/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=3f306db3dbe390f43c7dfa8e17630747723e39e3", "patch": "@@ -691,3 +691,92 @@ pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n \n     recurse(v, &mut is_less, None, limit);\n }\n+\n+fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_less: &mut F\n+                                    , mut pred: Option<&'a T>) where F: FnMut(&T, &T) -> bool\n+{\n+    loop {\n+        // For slices of up to this length it's probably faster to simply sort them.\n+        const MAX_INSERTION: usize = 10;\n+        if v.len() <= MAX_INSERTION {\n+            insertion_sort(v, is_less);\n+            return;\n+        }\n+\n+        // Choose a pivot\n+        let (pivot, _) = choose_pivot(v, is_less);\n+\n+        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n+        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n+        // This case is usually hit when the slice contains many duplicate elements.\n+        if let Some(p) = pred {\n+            if !is_less(p, &v[pivot]) {\n+                let mid = partition_equal(v, pivot, is_less);\n+\n+                // If we've passed our index, then we're good.\n+                if mid > index {\n+                    return;\n+                }\n+\n+                // Otherwise, continue sorting elements greater than the pivot.\n+                v = &mut v[mid..];\n+                index = index - mid;\n+                pred = None;\n+                continue;\n+            }\n+        }\n+\n+        let (mid, _) = partition(v, pivot, is_less);\n+\n+        // Split the slice into `left`, `pivot`, and `right`.\n+        let (left, right) = {v}.split_at_mut(mid);\n+        let (pivot, right) = right.split_at_mut(1);\n+        let pivot = &pivot[0];\n+\n+        if mid < index {\n+            v = right;\n+            index = index - mid - 1;\n+            pred = Some(pivot);\n+        } else if mid > index {\n+            v = left;\n+        } else {\n+            // If mid == index, then we're done, since partition() guaranteed that all elements\n+            // after mid are greater than or equal to mid.\n+            return;\n+        }\n+    }\n+}\n+\n+pub fn partition_at_index<T, F>(v: &mut [T], index: usize, mut is_less: F)\n+                                -> (&mut [T], &mut T, &mut [T]) where F: FnMut(&T, &T) -> bool\n+{\n+    use cmp::Ordering::Less;\n+    use cmp::Ordering::Greater;\n+\n+    if index >= v.len() {\n+        panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n+    }\n+\n+    if mem::size_of::<T>() == 0 {\n+        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n+    } else if index == v.len() - 1 {\n+        // Find max element and place it in the last position of the array. We're free to use\n+        // `unwrap()` here because we know v must not be empty.\n+        let (max_index, _) = v.iter().enumerate().max_by(\n+            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        v.swap(max_index, index);\n+    } else if index == 0 {\n+        // Find min element and place it in the first position of the array. We're free to use\n+        // `unwrap()` here because we know v must not be empty.\n+        let (min_index, _) = v.iter().enumerate().min_by(\n+            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        v.swap(min_index, index);\n+    } else {\n+        partition_at_index_loop(v, index, &mut is_less, None);\n+    }\n+\n+    let (left, right) = v.split_at_mut(index);\n+    let (pivot, right) = right.split_at_mut(1);\n+    let pivot = &mut pivot[0];\n+    (left, pivot, right)\n+}"}, {"sha": "467747904b2c8ca4aaebfad73542a21a2fe8908d", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f306db3dbe390f43c7dfa8e17630747723e39e3/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f306db3dbe390f43c7dfa8e17630747723e39e3/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=3f306db3dbe390f43c7dfa8e17630747723e39e3", "patch": "@@ -21,6 +21,7 @@\n #![feature(refcell_replace_swap)]\n #![feature(slice_patterns)]\n #![feature(sort_internals)]\n+#![feature(slice_partition_at_index)]\n #![feature(specialization)]\n #![feature(step_trait)]\n #![feature(str_internals)]"}, {"sha": "b02966e94b8ce767339dbe391a87bc49361829b8", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/3f306db3dbe390f43c7dfa8e17630747723e39e3/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f306db3dbe390f43c7dfa8e17630747723e39e3/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=3f306db3dbe390f43c7dfa8e17630747723e39e3", "patch": "@@ -1084,6 +1084,124 @@ fn sort_unstable() {\n     assert!(v == [0xDEADBEEF]);\n }\n \n+#[test]\n+#[cfg(not(target_arch = \"wasm32\"))]\n+#[cfg(not(miri))] // Miri does not support entropy\n+fn partition_at_index() {\n+    use core::cmp::Ordering::{Equal, Greater, Less};\n+    use rand::rngs::SmallRng;\n+    use rand::seq::SliceRandom;\n+    use rand::{FromEntropy, Rng};\n+\n+    let mut rng = SmallRng::from_entropy();\n+\n+    for len in (2..21).chain(500..501) {\n+        let mut orig = vec![0; len];\n+\n+        for &modulus in &[5, 10, 1000] {\n+            for _ in 0..10 {\n+                for i in 0..len {\n+                    orig[i] = rng.gen::<i32>() % modulus;\n+                }\n+\n+                let v_sorted = {\n+                    let mut v = orig.clone();\n+                    v.sort();\n+                    v\n+                };\n+\n+                // Sort in default order.\n+                for pivot in 0..len {\n+                    let mut v = orig.clone();\n+                    v.partition_at_index(pivot);\n+\n+                    assert_eq!(v_sorted[pivot], v[pivot]);\n+                    for i in 0..pivot {\n+                        for j in pivot..len {\n+                            assert!(v[i] <= v[j]);\n+                        }\n+                    }\n+                }\n+\n+                // Sort in ascending order.\n+                for pivot in 0..len {\n+                    let mut v = orig.clone();\n+                    let (left, pivot, right) = v.partition_at_index_by(pivot, |a, b| a.cmp(b));\n+\n+                    assert_eq!(left.len() + right.len(), len - 1);\n+\n+                    for l in left {\n+                        assert!(l <= pivot);\n+                        for r in right.iter_mut() {\n+                            assert!(l <= r);\n+                            assert!(pivot <= r);\n+                        }\n+                    }\n+                }\n+\n+                // Sort in descending order.\n+                let sort_descending_comparator = |a: &i32, b: &i32| b.cmp(a);\n+                let v_sorted_descending = {\n+                    let mut v = orig.clone();\n+                    v.sort_by(sort_descending_comparator);\n+                    v\n+                };\n+\n+                for pivot in 0..len {\n+                    let mut v = orig.clone();\n+                    v.partition_at_index_by(pivot, sort_descending_comparator);\n+\n+                    assert_eq!(v_sorted_descending[pivot], v[pivot]);\n+                    for i in 0..pivot {\n+                        for j in pivot..len {\n+                            assert!(v[j] <= v[i]);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Sort at index using a completely random comparison function.\n+    // This will reorder the elements *somehow*, but won't panic.\n+    let mut v = [0; 500];\n+    for i in 0..v.len() {\n+        v[i] = i as i32;\n+    }\n+\n+    for pivot in 0..v.len() {\n+        v.partition_at_index_by(pivot, |_, _| *[Less, Equal, Greater].choose(&mut rng).unwrap());\n+        v.sort();\n+        for i in 0..v.len() {\n+            assert_eq!(v[i], i as i32);\n+        }\n+    }\n+\n+    // Should not panic.\n+    [(); 10].partition_at_index(0);\n+    [(); 10].partition_at_index(5);\n+    [(); 10].partition_at_index(9);\n+    [(); 100].partition_at_index(0);\n+    [(); 100].partition_at_index(50);\n+    [(); 100].partition_at_index(99);\n+\n+    let mut v = [0xDEADBEEFu64];\n+    v.partition_at_index(0);\n+    assert!(v == [0xDEADBEEF]);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"index 0 greater than length of slice\")]\n+fn partition_at_index_zero_length() {\n+    [0i32; 0].partition_at_index(0);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"index 20 greater than length of slice\")]\n+fn partition_at_index_past_length() {\n+    [0i32; 10].partition_at_index(20);\n+}\n+\n pub mod memchr {\n     use core::slice::memchr::{memchr, memrchr};\n "}]}