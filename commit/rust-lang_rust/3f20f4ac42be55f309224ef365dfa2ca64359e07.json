{"sha": "3f20f4ac42be55f309224ef365dfa2ca64359e07", "node_id": "C_kwDOAAsO6NoAKDNmMjBmNGFjNDJiZTU1ZjMwOTIyNGVmMzY1ZGZhMmNhNjQzNTllMDc", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-11-18T22:52:49Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-11-23T21:03:51Z"}, "message": "effective visibility: Satisfy borrow checker to use resolver lazily from a closure", "tree": {"sha": "92db5edce2086f35428f85d5218f38d87e8d7510", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92db5edce2086f35428f85d5218f38d87e8d7510"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f20f4ac42be55f309224ef365dfa2ca64359e07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f20f4ac42be55f309224ef365dfa2ca64359e07", "html_url": "https://github.com/rust-lang/rust/commit/3f20f4ac42be55f309224ef365dfa2ca64359e07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f20f4ac42be55f309224ef365dfa2ca64359e07/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "url": "https://api.github.com/repos/rust-lang/rust/commits/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "html_url": "https://github.com/rust-lang/rust/commit/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231"}], "stats": {"total": 69, "additions": 46, "deletions": 23}, "files": [{"sha": "decd213763d9c860a39f6862b294e388b60c7c3e", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3f20f4ac42be55f309224ef365dfa2ca64359e07/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f20f4ac42be55f309224ef365dfa2ca64359e07/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=3f20f4ac42be55f309224ef365dfa2ca64359e07", "patch": "@@ -142,13 +142,13 @@ impl EffectiveVisibilities {\n     pub fn set_public_at_level(\n         &mut self,\n         id: LocalDefId,\n-        default_vis: impl FnOnce() -> Visibility,\n+        lazy_private_vis: impl FnOnce() -> Visibility,\n         level: Level,\n     ) {\n         let mut effective_vis = self\n             .effective_vis(id)\n             .copied()\n-            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis()));\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(lazy_private_vis()));\n         for l in Level::all_levels() {\n             if l <= level {\n                 *effective_vis.at_level_mut(l) = Visibility::Public;\n@@ -206,6 +206,11 @@ impl EffectiveVisibilities {\n     }\n }\n \n+pub trait IntoDefIdTree {\n+    type Tree: DefIdTree;\n+    fn tree(self) -> Self::Tree;\n+}\n+\n impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n     pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n         self.map.iter()\n@@ -217,21 +222,26 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n \n     // `parent_id` is not necessarily a parent in source code tree,\n     // it is the node from which the maximum effective visibility is inherited.\n-    pub fn update(\n+    pub fn update<T: IntoDefIdTree>(\n         &mut self,\n         id: Id,\n         nominal_vis: Visibility,\n-        default_vis: Visibility,\n+        lazy_private_vis: impl FnOnce(T) -> (Visibility, T),\n         inherited_eff_vis: Option<EffectiveVisibility>,\n         level: Level,\n-        tree: impl DefIdTree,\n+        mut into_tree: T,\n     ) -> bool {\n         let mut changed = false;\n-        let mut current_effective_vis = self\n-            .map\n-            .get(&id)\n-            .copied()\n-            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis));\n+        let mut current_effective_vis = match self.map.get(&id).copied() {\n+            Some(eff_vis) => eff_vis,\n+            None => {\n+                let private_vis;\n+                (private_vis, into_tree) = lazy_private_vis(into_tree);\n+                EffectiveVisibility::from_vis(private_vis)\n+            }\n+        };\n+        let tree = into_tree.tree();\n+\n         if let Some(inherited_effective_vis) = inherited_eff_vis {\n             let mut inherited_effective_vis_at_prev_level =\n                 *inherited_effective_vis.at_level(level);"}, {"sha": "57fb1fa938935fdd98ff0875afad33f94cf361df", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3f20f4ac42be55f309224ef365dfa2ca64359e07/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f20f4ac42be55f309224ef365dfa2ca64359e07/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=3f20f4ac42be55f309224ef365dfa2ca64359e07", "patch": "@@ -7,7 +7,8 @@ use rustc_ast::EnumDef;\n use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n-use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility, Level};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility};\n+use rustc_middle::middle::privacy::{IntoDefIdTree, Level};\n use rustc_middle::ty::Visibility;\n \n type ImportId<'a> = Interned<'a, NameBinding<'a>>;\n@@ -29,20 +30,35 @@ impl ParentId<'_> {\n \n pub struct EffectiveVisibilitiesVisitor<'r, 'a> {\n     r: &'r mut Resolver<'a>,\n+    def_effective_visibilities: EffectiveVisibilities,\n     /// While walking import chains we need to track effective visibilities per-binding, and def id\n     /// keys in `Resolver::effective_visibilities` are not enough for that, because multiple\n     /// bindings can correspond to a single def id in imports. So we keep a separate table.\n     import_effective_visibilities: EffectiveVisibilities<ImportId<'a>>,\n     changed: bool,\n }\n \n+impl Resolver<'_> {\n+    fn nearest_normal_mod(&mut self, def_id: LocalDefId) -> LocalDefId {\n+        self.get_nearest_non_block_module(def_id.to_def_id()).nearest_parent_mod().expect_local()\n+    }\n+}\n+\n+impl<'a, 'b> IntoDefIdTree for &'b mut Resolver<'a> {\n+    type Tree = &'b Resolver<'a>;\n+    fn tree(self) -> Self::Tree {\n+        self\n+    }\n+}\n+\n impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n     /// Fills the `Resolver::effective_visibilities` table with public & exported items\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n     /// need access to a TyCtxt for that.\n     pub fn compute_effective_visibilities<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n         let mut visitor = EffectiveVisibilitiesVisitor {\n             r,\n+            def_effective_visibilities: Default::default(),\n             import_effective_visibilities: Default::default(),\n             changed: false,\n         };\n@@ -54,6 +70,7 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n             visitor.changed = false;\n             visit::walk_crate(&mut visitor, krate);\n         }\n+        visitor.r.effective_visibilities = visitor.def_effective_visibilities;\n \n         // Update visibilities for import def ids. These are not used during the\n         // `EffectiveVisibilitiesVisitor` pass, because we have more detailed binding-based\n@@ -90,10 +107,6 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n         info!(\"resolve::effective_visibilities: {:#?}\", r.effective_visibilities);\n     }\n \n-    fn nearest_normal_mod(&mut self, def_id: LocalDefId) -> LocalDefId {\n-        self.r.get_nearest_non_block_module(def_id.to_def_id()).nearest_parent_mod().expect_local()\n-    }\n-\n     /// Update effective visibilities of bindings in the given module,\n     /// including their whole reexport chains.\n     fn set_bindings_effective_visibilities(&mut self, module_id: LocalDefId) {\n@@ -124,7 +137,7 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n \n     fn effective_vis(&self, parent_id: ParentId<'a>) -> Option<EffectiveVisibility> {\n         match parent_id {\n-            ParentId::Def(def_id) => self.r.effective_visibilities.effective_vis(def_id),\n+            ParentId::Def(def_id) => self.def_effective_visibilities.effective_vis(def_id),\n             ParentId::Import(binding) => self.import_effective_visibilities.effective_vis(binding),\n         }\n         .copied()\n@@ -150,7 +163,7 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n         let default_vis = Visibility::Restricted(\n             import\n                 .id()\n-                .map(|id| self.nearest_normal_mod(self.r.local_def_id(id)))\n+                .map(|id| self.r.nearest_normal_mod(self.r.local_def_id(id)))\n                 .unwrap_or(CRATE_DEF_ID),\n         );\n         if self.is_noop_update(parent_id, nominal_vis, default_vis) {\n@@ -159,25 +172,25 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n         self.changed |= self.import_effective_visibilities.update(\n             binding,\n             nominal_vis,\n-            default_vis,\n+            |r| (default_vis, r),\n             self.effective_vis(parent_id),\n             parent_id.level(),\n-            ResolverTree(&self.r.definitions, &self.r.crate_loader),\n+            &mut *self.r,\n         );\n     }\n \n     fn update_def(&mut self, def_id: LocalDefId, nominal_vis: Visibility, parent_id: ParentId<'a>) {\n-        let default_vis = Visibility::Restricted(self.nearest_normal_mod(def_id));\n+        let default_vis = Visibility::Restricted(self.r.nearest_normal_mod(def_id));\n         if self.is_noop_update(parent_id, nominal_vis, default_vis) {\n             return;\n         }\n-        self.changed |= self.r.effective_visibilities.update(\n+        self.changed |= self.def_effective_visibilities.update(\n             def_id,\n             nominal_vis,\n-            if def_id == CRATE_DEF_ID { Visibility::Public } else { default_vis },\n+            |r| (if def_id == CRATE_DEF_ID { Visibility::Public } else { default_vis }, r),\n             self.effective_vis(parent_id),\n             parent_id.level(),\n-            ResolverTree(&self.r.definitions, &self.r.crate_loader),\n+            &mut *self.r,\n         );\n     }\n "}]}