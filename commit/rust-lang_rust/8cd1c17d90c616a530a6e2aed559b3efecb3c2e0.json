{"sha": "8cd1c17d90c616a530a6e2aed559b3efecb3c2e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZDFjMTdkOTBjNjE2YTUzMGE2ZTJhZWQ1NTliM2VmZWNiM2MyZTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-03-12T01:30:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-03-14T21:56:49Z"}, "message": "rustbuild: Refactor stage arguments away\n\nThe facet of a stage is rarely relevant when running a tool or building\nsomething, it's all a question of what stage the *compiler* is built in. We've\nalready got a nice handy `Compiler` structure to carry this information, so\nlet's use it!\n\nThis refactors the signature of the `Build::cargo` function two ways:\n\n1. The `stage` argument is removed, this was just duplicated with the `compiler`\n   argument's stage field.\n2. The `target` argument is now required. This was a bug where if the `--target`\n   flag isn't passed then the snapshot stage0 compiler is always used, so we\n   won't pick up any changes.\n\nMuch of the other changes in this commit are just propagating these decisions\noutwards. For example many of the `Step` variants no longer have a stage\nargument as they're baked into the compiler.", "tree": {"sha": "aac4cb9717b0d70dde5139d2ea162a1e685070dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aac4cb9717b0d70dde5139d2ea162a1e685070dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0", "html_url": "https://github.com/rust-lang/rust/commit/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a917e050d62e0b5a66c0d392992cc5e1d4b1e5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a917e050d62e0b5a66c0d392992cc5e1d4b1e5d", "html_url": "https://github.com/rust-lang/rust/commit/4a917e050d62e0b5a66c0d392992cc5e1d4b1e5d"}], "stats": {"total": 246, "additions": 110, "deletions": 136}, "files": [{"sha": "95555aa3796889143df1ef07f87ecec4172064a2", "filename": "src/bootstrap/build/compile.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcompile.rs?ref=8cd1c17d90c616a530a6e2aed559b3efecb3c2e0", "patch": "@@ -23,26 +23,23 @@ use build::{Build, Compiler, Mode};\n /// This will build the standard library for a particular stage of the build\n /// using the `compiler` targeting the `target` architecture. The artifacts\n /// created will also be linked into the sysroot directory.\n-pub fn std<'a>(build: &'a Build, stage: u32, target: &str,\n-               compiler: &Compiler<'a>) {\n-    let host = compiler.host;\n-    println!(\"Building stage{} std artifacts ({} -> {})\", stage,\n-             host, target);\n+pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n+    println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+             compiler.host, target);\n \n     // Move compiler-rt into place as it'll be required by the compiler when\n     // building the standard library to link the dylib of libstd\n-    let libdir = build.sysroot_libdir(stage, &host, target);\n+    let libdir = build.sysroot_libdir(compiler, target);\n     let _ = fs::remove_dir_all(&libdir);\n     t!(fs::create_dir_all(&libdir));\n     t!(fs::hard_link(&build.compiler_rt_built.borrow()[target],\n                      libdir.join(staticlib(\"compiler-rt\", target))));\n \n     build_startup_objects(build, target, &libdir);\n \n-    let out_dir = build.cargo_out(stage, &host, Mode::Libstd, target);\n+    let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n     build.clear_if_dirty(&out_dir, &build.compiler_path(compiler));\n-    let mut cargo = build.cargo(stage, compiler, Mode::Libstd, Some(target),\n-                                \"build\");\n+    let mut cargo = build.cargo(compiler, Mode::Libstd, target, \"build\");\n     cargo.arg(\"--features\").arg(build.std_features())\n          .arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"));\n@@ -59,20 +56,20 @@ pub fn std<'a>(build: &'a Build, stage: u32, target: &str,\n     }\n \n     build.run(&mut cargo);\n-    std_link(build, stage, target, compiler, host);\n+    std_link(build, target, compiler, compiler.host);\n }\n \n /// Link all libstd rlibs/dylibs into the sysroot location.\n ///\n /// Links those artifacts generated in the given `stage` for `target` produced\n /// by `compiler` into `host`'s sysroot.\n pub fn std_link(build: &Build,\n-                stage: u32,\n                 target: &str,\n                 compiler: &Compiler,\n                 host: &str) {\n-    let libdir = build.sysroot_libdir(stage, host, target);\n-    let out_dir = build.cargo_out(stage, compiler.host, Mode::Libstd, target);\n+    let target_compiler = Compiler::new(compiler.stage, host);\n+    let libdir = build.sysroot_libdir(&target_compiler, target);\n+    let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n \n     // If we're linking one compiler host's output into another, then we weren't\n     // called from the `std` method above. In that case we clean out what's\n@@ -85,7 +82,8 @@ pub fn std_link(build: &Build,\n     }\n     add_to_sysroot(&out_dir, &libdir);\n \n-    if target.contains(\"musl\") && (target.contains(\"x86_64\") || target.contains(\"i686\")) {\n+    if target.contains(\"musl\") &&\n+       (target.contains(\"x86_64\") || target.contains(\"i686\")) {\n         copy_third_party_objects(build, target, &libdir);\n     }\n }\n@@ -130,17 +128,14 @@ fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n /// This will build the compiler for a particular stage of the build using\n /// the `compiler` targeting the `target` architecture. The artifacts\n /// created will also be linked into the sysroot directory.\n-pub fn rustc<'a>(build: &'a Build, stage: u32, target: &str,\n-                 compiler: &Compiler<'a>) {\n-    let host = compiler.host;\n-    println!(\"Building stage{} compiler artifacts ({} -> {})\", stage,\n-             host, target);\n+pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n+    println!(\"Building stage{} compiler artifacts ({} -> {})\",\n+             compiler.stage, compiler.host, target);\n \n-    let out_dir = build.cargo_out(stage, &host, Mode::Librustc, target);\n-    build.clear_if_dirty(&out_dir, &libstd_shim(build, stage, &host, target));\n+    let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n+    build.clear_if_dirty(&out_dir, &libstd_shim(build, compiler, target));\n \n-    let mut cargo = build.cargo(stage, compiler, Mode::Librustc, Some(target),\n-                                \"build\");\n+    let mut cargo = build.cargo(compiler, Mode::Librustc, target, \"build\");\n     cargo.arg(\"--features\").arg(build.rustc_features())\n          .arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/Cargo.toml\"));\n@@ -184,27 +179,27 @@ pub fn rustc<'a>(build: &'a Build, stage: u32, target: &str,\n     }\n     build.run(&mut cargo);\n \n-    rustc_link(build, stage, target, compiler, compiler.host);\n+    rustc_link(build, target, compiler, compiler.host);\n }\n \n /// Link all librustc rlibs/dylibs into the sysroot location.\n ///\n /// Links those artifacts generated in the given `stage` for `target` produced\n /// by `compiler` into `host`'s sysroot.\n pub fn rustc_link(build: &Build,\n-                  stage: u32,\n                   target: &str,\n                   compiler: &Compiler,\n                   host: &str) {\n-    let libdir = build.sysroot_libdir(stage, host, target);\n-    let out_dir = build.cargo_out(stage, compiler.host, Mode::Librustc, target);\n+    let target_compiler = Compiler::new(compiler.stage, host);\n+    let libdir = build.sysroot_libdir(&target_compiler, target);\n+    let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n     add_to_sysroot(&out_dir, &libdir);\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-fn libstd_shim(build: &Build, stage: u32, host: &str, target: &str) -> PathBuf {\n-    build.cargo_out(stage, host, Mode::Libstd, target).join(\"libstd_shim.rlib\")\n+fn libstd_shim(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Libstd, target).join(\"libstd_shim.rlib\")\n }\n \n fn compiler_file(compiler: &Path, file: &str) -> String {\n@@ -219,25 +214,29 @@ fn compiler_file(compiler: &Path, file: &str) -> String {\n /// compiler.\n pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n     assert!(stage > 0, \"the stage0 compiler isn't assembled, it's downloaded\");\n+    // The compiler that we're assembling\n+    let target_compiler = Compiler::new(stage, host);\n+\n+    // The compiler that compiled the compiler we're assembling\n+    let build_compiler = Compiler::new(stage - 1, &build.config.build);\n \n     // Clear out old files\n-    let sysroot = build.sysroot(stage, host);\n+    let sysroot = build.sysroot(&target_compiler);\n     let _ = fs::remove_dir_all(&sysroot);\n     t!(fs::create_dir_all(&sysroot));\n \n     // Link in all dylibs to the libdir\n     let sysroot_libdir = sysroot.join(libdir(host));\n     t!(fs::create_dir_all(&sysroot_libdir));\n-    let src_libdir = build.sysroot_libdir(stage - 1, &build.config.build, host);\n+    let src_libdir = build.sysroot_libdir(&build_compiler, host);\n     for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n         let filename = f.file_name().into_string().unwrap();\n         if is_dylib(&filename) {\n             t!(fs::hard_link(&f.path(), sysroot_libdir.join(&filename)));\n         }\n     }\n \n-    let out_dir = build.cargo_out(stage - 1, &build.config.build,\n-                                  Mode::Librustc, host);\n+    let out_dir = build.cargo_out(&build_compiler, Mode::Librustc, host);\n \n     // Link the compiler binary itself into place\n     let rustc = out_dir.join(exe(\"rustc\", host));\n@@ -315,7 +314,7 @@ pub fn tool(build: &Build, stage: u32, host: &str, tool: &str) {\n     // let out_dir = build.cargo_out(stage, &host, Mode::Librustc, target);\n     // build.clear_if_dirty(&out_dir, &libstd_shim(build, stage, &host, target));\n \n-    let mut cargo = build.cargo(stage, &compiler, Mode::Tool, None, \"build\");\n+    let mut cargo = build.cargo(&compiler, Mode::Tool, host, \"build\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(format!(\"src/tools/{}/Cargo.toml\", tool)));\n     build.run(&mut cargo);"}, {"sha": "d8b02dce222cd0312eb3f9d1469cf2cf3d6344f0", "filename": "src/bootstrap/build/doc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Fbootstrap%2Fbuild%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Fbootstrap%2Fbuild%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fdoc.rs?ref=8cd1c17d90c616a530a6e2aed559b3efecb3c2e0", "patch": "@@ -81,6 +81,7 @@ pub fn standalone(build: &Build, stage: u32, host: &str, out: &Path) {\n         }\n \n         let mut cmd = Command::new(&rustdoc);\n+        build.add_rustc_lib_path(&compiler, &mut cmd);\n         cmd.arg(\"--html-after-content\").arg(&footer)\n            .arg(\"--html-before-content\").arg(&version_info)\n            .arg(\"--html-in-header\").arg(&favicon)\n@@ -107,14 +108,13 @@ pub fn standalone(build: &Build, stage: u32, host: &str, out: &Path) {\n pub fn std(build: &Build, stage: u32, host: &str, out: &Path) {\n     println!(\"Documenting stage{} std ({})\", stage, host);\n     let compiler = Compiler::new(stage, host);\n-    let out_dir = build.stage_out(stage, host, Mode::Libstd)\n+    let out_dir = build.stage_out(&compiler, Mode::Libstd)\n                        .join(host).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n \n     build.clear_if_dirty(&out_dir, &rustdoc);\n \n-    let mut cargo = build.cargo(stage, &compiler, Mode::Libstd, Some(host),\n-                                \"doc\");\n+    let mut cargo = build.cargo(&compiler, Mode::Libstd, host, \"doc\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"))\n          .arg(\"--features\").arg(build.std_features());\n@@ -125,14 +125,13 @@ pub fn std(build: &Build, stage: u32, host: &str, out: &Path) {\n pub fn rustc(build: &Build, stage: u32, host: &str, out: &Path) {\n     println!(\"Documenting stage{} compiler ({})\", stage, host);\n     let compiler = Compiler::new(stage, host);\n-    let out_dir = build.stage_out(stage, host, Mode::Librustc)\n+    let out_dir = build.stage_out(&compiler, Mode::Librustc)\n                        .join(host).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n     if !up_to_date(&rustdoc, &out_dir.join(\"rustc/index.html\")) {\n         t!(fs::remove_dir_all(&out_dir));\n     }\n-    let mut cargo = build.cargo(stage, &compiler, Mode::Librustc, Some(host),\n-                                \"doc\");\n+    let mut cargo = build.cargo(&compiler, Mode::Librustc, host, \"doc\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/Cargo.toml\"))\n          .arg(\"--features\").arg(build.rustc_features());"}, {"sha": "39bd74c78ff2a9dfb85f82fbc34bd1bec9961e4a", "filename": "src/bootstrap/build/mod.rs", "status": "modified", "additions": 52, "deletions": 71, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=8cd1c17d90c616a530a6e2aed559b3efecb3c2e0", "patch": "@@ -152,19 +152,17 @@ impl Build {\n                 CompilerRt { _dummy } => {\n                     native::compiler_rt(self, target.target);\n                 }\n-                Libstd { stage, compiler } => {\n-                    compile::std(self, stage, target.target, &compiler);\n+                Libstd { compiler } => {\n+                    compile::std(self, target.target, &compiler);\n                 }\n-                Librustc { stage, compiler } => {\n-                    compile::rustc(self, stage, target.target, &compiler);\n+                Librustc { compiler } => {\n+                    compile::rustc(self, target.target, &compiler);\n                 }\n-                LibstdLink { stage, compiler, host } => {\n-                    compile::std_link(self, stage, target.target,\n-                                      &compiler, host);\n+                LibstdLink { compiler, host } => {\n+                    compile::std_link(self, target.target, &compiler, host);\n                 }\n-                LibrustcLink { stage, compiler, host } => {\n-                    compile::rustc_link(self, stage, target.target,\n-                                        &compiler, host);\n+                LibrustcLink { compiler, host } => {\n+                    compile::rustc_link(self, target.target, &compiler, host);\n                 }\n                 Rustc { stage: 0 } => {\n                     // nothing to do...\n@@ -261,58 +259,52 @@ impl Build {\n     /// This will create a `Command` that represents a pending execution of\n     /// Cargo for the specified stage, whether or not the standard library is\n     /// being built, and using the specified compiler targeting `target`.\n-    // FIXME: aren't stage/compiler duplicated?\n     fn cargo(&self,\n-             stage: u32,\n              compiler: &Compiler,\n              mode: Mode,\n-             target: Option<&str>,\n+             target: &str,\n              cmd: &str) -> Command {\n         let mut cargo = Command::new(&self.cargo);\n-        let host = compiler.host;\n-        let out_dir = self.stage_out(stage, host, mode);\n+        let out_dir = self.stage_out(compiler, mode);\n         cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n              .arg(cmd)\n-             .arg(\"-j\").arg(self.jobs().to_string());\n+             .arg(\"-j\").arg(self.jobs().to_string())\n+             .arg(\"--target\").arg(target);\n \n         // Customize the compiler we're running. Specify the compiler to cargo\n         // as our shim and then pass it some various options used to configure\n         // how the actual compiler itself is called.\n         cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n              .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n-             .env(\"RUSTC_STAGE\", self.stage_arg(stage, compiler).to_string())\n+             .env(\"RUSTC_STAGE\", compiler.stage.to_string())\n              .env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n              .env(\"RUSTC_CODEGEN_UNITS\",\n                   self.config.rust_codegen_units.to_string())\n              .env(\"RUSTC_DEBUG_ASSERTIONS\",\n                   self.config.rust_debug_assertions.to_string())\n              .env(\"RUSTC_SNAPSHOT\", &self.rustc)\n-             .env(\"RUSTC_SYSROOT\", self.sysroot(stage, host))\n+             .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n              .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir())\n              .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n              .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n-             .env(\"RUSTDOC_REAL\", self.rustdoc(compiler));\n-\n-        if let Some(target) = target {\n-             cargo.env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n-             cargo.arg(\"--target\").arg(target);\n-\n-            // Specify some various options for build scripts used throughout\n-            // the build.\n-            //\n-            // FIXME: the guard against msvc shouldn't need to be here\n-            if !target.contains(\"msvc\") {\n-                cargo.env(format!(\"CC_{}\", target), self.cc(target))\n-                     .env(format!(\"AR_{}\", target), self.ar(target))\n-                     .env(format!(\"CFLAGS_{}\", target), self.cflags(target));\n-            }\n-\n-            // Environment variables *required* needed throughout the build\n-            //\n-            // FIXME: should update code to not require this env vars\n-            cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n+             .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n+             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n+\n+        // Specify some various options for build scripts used throughout\n+        // the build.\n+        //\n+        // FIXME: the guard against msvc shouldn't need to be here\n+        if !target.contains(\"msvc\") {\n+            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n+                 .env(format!(\"AR_{}\", target), self.ar(target))\n+                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target));\n         }\n \n+        // Environment variables *required* needed throughout the build\n+        //\n+        // FIXME: should update code to not require this env vars\n+        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n+\n         if self.config.verbose || self.flags.verbose {\n             cargo.arg(\"-v\");\n         }\n@@ -328,50 +320,37 @@ impl Build {\n         if compiler.is_snapshot(self) {\n             self.rustc.clone()\n         } else {\n-            self.sysroot(compiler.stage, compiler.host).join(\"bin\")\n-                .join(exe(\"rustc\", compiler.host))\n+            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", compiler.host))\n         }\n     }\n \n     /// Get the specified tool built by the specified compiler\n     fn tool(&self, compiler: &Compiler, tool: &str) -> PathBuf {\n-        self.stage_out(compiler.stage, compiler.host, Mode::Tool)\n-            .join(self.cargo_dir())\n+        self.cargo_out(compiler, Mode::Tool, compiler.host)\n             .join(exe(tool, compiler.host))\n     }\n \n     /// Get the `rustdoc` executable next to the specified compiler\n     fn rustdoc(&self, compiler: &Compiler) -> PathBuf {\n-        let root = if compiler.is_snapshot(self) {\n-            let mut rustdoc = self.rustc.clone();\n-            rustdoc.pop();\n-            rustdoc\n-        } else {\n-            let (stage, host) = (compiler.stage, compiler.host);\n-            self.cargo_out(stage - 1, host, Mode::Librustc, host)\n-        };\n-        root.join(exe(\"rustdoc\", compiler.host))\n+        let mut rustdoc = self.compiler_path(compiler);\n+        rustdoc.pop();\n+        rustdoc.push(exe(\"rustdoc\", compiler.host));\n+        return rustdoc\n     }\n \n     /// Get a `Command` which is ready to run `tool` in `stage` built for\n     /// `host`.\n-    #[allow(dead_code)] // this will be used soon\n     fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n         let mut cmd = Command::new(self.tool(&compiler, tool));\n         let host = compiler.host;\n-        let stage = compiler.stage;\n         let paths = vec![\n-            self.cargo_out(stage, host, Mode::Libstd, host).join(\"deps\"),\n-            self.cargo_out(stage, host, Mode::Librustc, host).join(\"deps\"),\n+            self.cargo_out(compiler, Mode::Libstd, host).join(\"deps\"),\n+            self.cargo_out(compiler, Mode::Librustc, host).join(\"deps\"),\n         ];\n         add_lib_path(paths, &mut cmd);\n         return cmd\n     }\n \n-    fn stage_arg(&self, stage: u32, compiler: &Compiler) -> u32 {\n-        if stage == 0 && compiler.host != self.config.build {1} else {stage}\n-    }\n-\n     /// Get the space-separated set of activated features for the standard\n     /// library.\n     fn std_features(&self) -> String {\n@@ -400,37 +379,40 @@ impl Build {\n         if self.config.rust_optimize {\"release\"} else {\"debug\"}\n     }\n \n-    fn sysroot(&self, stage: u32, host: &str) -> PathBuf {\n-        if stage == 0 {\n-            self.stage_out(stage, host, Mode::Librustc)\n+    fn sysroot(&self, compiler: &Compiler) -> PathBuf {\n+        if compiler.stage == 0 {\n+            self.out.join(compiler.host).join(\"stage0-sysroot\")\n         } else {\n-            self.out.join(host).join(format!(\"stage{}\", stage))\n+            self.out.join(compiler.host).join(format!(\"stage{}\", compiler.stage))\n         }\n     }\n \n-    fn sysroot_libdir(&self, stage: u32, host: &str, target: &str) -> PathBuf {\n-        self.sysroot(stage, host).join(\"lib\").join(\"rustlib\")\n+    fn sysroot_libdir(&self, compiler: &Compiler, target: &str) -> PathBuf {\n+        self.sysroot(compiler).join(\"lib\").join(\"rustlib\")\n             .join(target).join(\"lib\")\n     }\n \n     /// Returns the root directory for all output generated in a particular\n     /// stage when running with a particular host compiler.\n     ///\n     /// The mode indicates what the root directory is for.\n-    fn stage_out(&self, stage: u32, host: &str, mode: Mode) -> PathBuf {\n+    fn stage_out(&self, compiler: &Compiler, mode: Mode) -> PathBuf {\n         let suffix = match mode {\n             Mode::Libstd => \"-std\",\n             _ => \"-rustc\",\n         };\n-        self.out.join(host).join(format!(\"stage{}{}\", stage, suffix))\n+        self.out.join(compiler.host)\n+                .join(format!(\"stage{}{}\", compiler.stage, suffix))\n     }\n \n     /// Returns the root output directory for all Cargo output in a given stage,\n     /// running a particular comipler, wehther or not we're building the\n     /// standard library, and targeting the specified architecture.\n-    fn cargo_out(&self, stage: u32, host: &str, mode: Mode,\n+    fn cargo_out(&self,\n+                 compiler: &Compiler,\n+                 mode: Mode,\n                  target: &str) -> PathBuf {\n-        self.stage_out(stage, host, mode).join(target).join(self.cargo_dir())\n+        self.stage_out(compiler, mode).join(target).join(self.cargo_dir())\n     }\n \n     /// Root output directory for LLVM compiled for `target`\n@@ -456,8 +438,7 @@ impl Build {\n         if compiler.is_snapshot(self) {\n             self.rustc_snapshot_libdir()\n         } else {\n-            self.sysroot(compiler.stage, compiler.host)\n-                .join(libdir(compiler.host))\n+            self.sysroot(compiler).join(libdir(compiler.host))\n         }\n     }\n "}, {"sha": "dfac074e3cd75ea1cab2cf34e6e8780a86fc72f1", "filename": "src/bootstrap/build/step.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Fbootstrap%2Fbuild%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Fbootstrap%2Fbuild%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fstep.rs?ref=8cd1c17d90c616a530a6e2aed559b3efecb3c2e0", "patch": "@@ -29,18 +29,16 @@ macro_rules! targets {\n             // and one for the compiler itself. These are parameterized over the\n             // stage output they're going to be placed in along with the\n             // compiler which is producing the copy of libstd or librustc\n-            (libstd, Libstd { stage: u32, compiler: Compiler<'a> }),\n-            (librustc, Librustc { stage: u32, compiler: Compiler<'a> }),\n+            (libstd, Libstd { compiler: Compiler<'a> }),\n+            (librustc, Librustc { compiler: Compiler<'a> }),\n \n             // Links the standard library/librustc produced by the compiler\n             // provided into the host's directory also provided.\n             (libstd_link, LibstdLink {\n-                stage: u32,\n                 compiler: Compiler<'a>,\n                 host: &'a str\n             }),\n             (librustc_link, LibrustcLink {\n-                stage: u32,\n                 compiler: Compiler<'a>,\n                 host: &'a str\n             }),\n@@ -144,10 +142,9 @@ fn top_level(build: &Build) -> Vec<Step> {\n             }\n             let host = t.target(host);\n             if host.target == build.config.build {\n-                targets.push(host.librustc(stage, host.compiler(stage)));\n+                targets.push(host.librustc(host.compiler(stage)));\n             } else {\n-                targets.push(host.librustc_link(stage, t.compiler(stage),\n-                                                host.target));\n+                targets.push(host.librustc_link(t.compiler(stage), host.target));\n             }\n             for target in build.config.target.iter() {\n                 if !build.flags.target.contains(target) {\n@@ -156,11 +153,10 @@ fn top_level(build: &Build) -> Vec<Step> {\n \n                 if host.target == build.config.build {\n                     targets.push(host.target(target)\n-                                     .libstd(stage, host.compiler(stage)));\n+                                     .libstd(host.compiler(stage)));\n                 } else {\n                     targets.push(host.target(target)\n-                                     .libstd_link(stage, t.compiler(stage),\n-                                                  host.target));\n+                                     .libstd_link(t.compiler(stage), host.target));\n                 }\n             }\n         }\n@@ -238,29 +234,29 @@ impl<'a> Step<'a> {\n             }\n             Source::Rustc { stage } => {\n                 let compiler = Compiler::new(stage - 1, &build.config.build);\n-                vec![self.librustc(stage - 1, compiler)]\n+                vec![self.librustc(compiler)]\n             }\n-            Source::Librustc { stage, compiler } => {\n-                vec![self.libstd(stage, compiler), self.llvm(())]\n+            Source::Librustc { compiler } => {\n+                vec![self.libstd(compiler), self.llvm(())]\n             }\n-            Source::Libstd { stage: _, compiler } => {\n+            Source::Libstd { compiler } => {\n                 vec![self.compiler_rt(()),\n                      self.rustc(compiler.stage).target(compiler.host)]\n             }\n-            Source::LibrustcLink { stage, compiler, host } => {\n-                vec![self.librustc(stage, compiler),\n-                     self.libstd_link(stage, compiler, host)]\n+            Source::LibrustcLink { compiler, host } => {\n+                vec![self.librustc(compiler),\n+                     self.libstd_link(compiler, host)]\n             }\n-            Source::LibstdLink { stage, compiler, host } => {\n-                vec![self.libstd(stage, compiler),\n-                     self.target(host).rustc(stage)]\n+            Source::LibstdLink { compiler, host } => {\n+                vec![self.libstd(compiler),\n+                     self.target(host).rustc(compiler.stage)]\n             }\n             Source::CompilerRt { _dummy } => {\n                 vec![self.llvm(()).target(&build.config.build)]\n             }\n             Source::Llvm { _dummy } => Vec::new(),\n             Source::DocStd { stage } => {\n-                vec![self.libstd(stage, self.compiler(stage))]\n+                vec![self.libstd(self.compiler(stage))]\n             }\n             Source::DocBook { stage } |\n             Source::DocNomicon { stage } |\n@@ -290,11 +286,11 @@ impl<'a> Step<'a> {\n             }\n \n             Source::ToolLinkchecker { stage } => {\n-                vec![self.libstd(stage, self.compiler(stage))]\n+                vec![self.libstd(self.compiler(stage))]\n             }\n             Source::ToolErrorIndex { stage } |\n             Source::ToolRustbook { stage } => {\n-                vec![self.librustc(stage, self.compiler(stage))]\n+                vec![self.librustc(self.compiler(stage))]\n             }\n         }\n     }"}, {"sha": "778380d935c8d31fc08f2afe087c37cf7cd50398", "filename": "src/nightlies.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Fnightlies.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Fnightlies.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnightlies.txt?ref=8cd1c17d90c616a530a6e2aed559b3efecb3c2e0", "patch": "@@ -1,2 +1,2 @@\n rustc: 2016-02-17\n-cargo: 2016-01-21\n+cargo: 2016-03-11"}, {"sha": "0e7537a9cbd04b37b53c226cd4c2d7830084f13d", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8cd1c17d90c616a530a6e2aed559b3efecb3c2e0/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=8cd1c17d90c616a530a6e2aed559b3efecb3c2e0", "patch": "@@ -349,7 +349,6 @@ name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n  \"getopts 0.0.0\",\n- \"serialize 0.0.0\",\n  \"term 0.0.0\",\n ]\n "}]}