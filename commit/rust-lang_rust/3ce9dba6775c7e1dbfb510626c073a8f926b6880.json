{"sha": "3ce9dba6775c7e1dbfb510626c073a8f926b6880", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZTlkYmE2Nzc1YzdlMWRiZmI1MTA2MjZjMDczYThmOTI2YjY4ODA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-02T22:33:27Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-10T06:46:18Z"}, "message": "std: Use the new `for` protocol", "tree": {"sha": "b4c89fe29979a959c75f783ebe766d0cd6734254", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4c89fe29979a959c75f783ebe766d0cd6734254"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ce9dba6775c7e1dbfb510626c073a8f926b6880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ce9dba6775c7e1dbfb510626c073a8f926b6880", "html_url": "https://github.com/rust-lang/rust/commit/3ce9dba6775c7e1dbfb510626c073a8f926b6880", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ce9dba6775c7e1dbfb510626c073a8f926b6880/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28256052a4b141350dc0fe4e2e5357137bb49706", "url": "https://api.github.com/repos/rust-lang/rust/commits/28256052a4b141350dc0fe4e2e5357137bb49706", "html_url": "https://github.com/rust-lang/rust/commit/28256052a4b141350dc0fe4e2e5357137bb49706"}], "stats": {"total": 484, "additions": 433, "deletions": 51}, "files": [{"sha": "09f86f30d320fcd2de908a92f5bf7c2276083dbb", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 63, "deletions": 31, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=3ce9dba6775c7e1dbfb510626c073a8f926b6880", "patch": "@@ -143,14 +143,20 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) {\n         for uint::range(0, self.storage.len()) |i| {\n             let mut w = self.storage[i];\n             let b = op(&mut w);\n             self.storage[i] = w;\n             if !b { break; }\n         }\n-     }\n+    }\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n+        uint::range(0, self.storage.len(), |i| op(&mut self.storage[i]))\n+    }\n \n     #[inline(always)]\n     fn invert(&mut self) { for self.each_storage |w| { *w = !*w } }\n@@ -193,6 +199,7 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n@@ -203,6 +210,19 @@ pub impl BigBitv {\n         }\n     }\n \n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n+        let len = b.storage.len();\n+        for uint::iterate(0, len) |i| {\n+            let mask = big_mask(nbits, i);\n+            if mask & self.storage[i] != mask & b.storage[i] {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n }\n \n enum BitvVariant { Big(~BigBitv), Small(~SmallBitv) }\n@@ -387,13 +407,24 @@ pub impl Bitv {\n     }\n \n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(bool) -> bool) {\n         let mut i = 0;\n         while i < self.nbits {\n             if !f(self.get(i)) { break; }\n             i += 1;\n         }\n     }\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(bool) -> bool) -> bool {\n+        let mut i = 0;\n+        while i < self.nbits {\n+            if !f(self.get(i)) { return false; }\n+            i += 1;\n+        }\n+        return true;\n+    }\n \n     /// Returns true if all bits are 0\n     fn is_false(&self) -> bool {\n@@ -488,13 +519,18 @@ pub impl Bitv {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn ones(&self, f: &fn(uint) -> bool) {\n         for uint::range(0, self.nbits) |i| {\n             if self.get(i) {\n                 if !f(i) { break }\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn ones(&self, f: &fn(uint) -> bool) -> bool {\n+        uint::range(0, self.nbits, |i| !self.get(i) || f(i))\n+    }\n \n }\n \n@@ -661,18 +697,21 @@ pub impl BitvSet {\n     }\n }\n \n+#[cfg(not(stage0))]\n impl BaseIter<uint> for BitvSet {\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n \n-    fn each(&self, blk: &fn(v: &uint) -> bool) {\n+    fn each(&self, blk: &fn(v: &uint) -> bool) -> bool {\n         for self.bitv.storage.eachi |i, &w| {\n             if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n-                return;\n+                return false;\n             }\n         }\n+        return true;\n     }\n }\n \n+#[cfg(not(stage0))]\n impl cmp::Eq for BitvSet {\n     fn eq(&self, other: &BitvSet) -> bool {\n         if self.size != other.size {\n@@ -706,6 +745,7 @@ impl Mutable for BitvSet {\n     }\n }\n \n+#[cfg(not(stage0))]\n impl Set<uint> for BitvSet {\n     fn contains(&self, value: &uint) -> bool {\n         *value < self.bitv.storage.len() * uint::bits && self.bitv.get(*value)\n@@ -773,64 +813,55 @@ impl Set<uint> for BitvSet {\n         other.is_subset(self)\n     }\n \n-    fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n+    fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n-                return;\n+                return false;\n             }\n         }\n         /* everything we have that they don't also shows up */\n         self.each_outlier(other, |mine, i, w|\n             !mine || iterate_bits(i, w, |b| f(&b))\n-        );\n+        )\n     }\n \n     fn symmetric_difference(&self, other: &BitvSet,\n-                                 f: &fn(&uint) -> bool) {\n+                            f: &fn(&uint) -> bool) -> bool {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n-                return;\n+                return false;\n             }\n         }\n-        self.each_outlier(other, |_, i, w|\n-            iterate_bits(i, w, |b| f(&b))\n-        );\n+        self.each_outlier(other, |_, i, w| iterate_bits(i, w, |b| f(&b)))\n     }\n \n-    fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n-        for self.each_common(other) |i, w1, w2| {\n-            if !iterate_bits(i, w1 & w2, |b| f(&b)) {\n-                return;\n-            }\n-        }\n+    fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+        self.each_common(other, |i, w1, w2| iterate_bits(i, w1 & w2, |b| f(&b)))\n     }\n \n-    fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n+    fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n-                return;\n+                return false;\n             }\n         }\n-        self.each_outlier(other, |_, i, w|\n-            iterate_bits(i, w, |b| f(&b))\n-        );\n+        self.each_outlier(other, |_, i, w| iterate_bits(i, w, |b| f(&b)))\n     }\n }\n \n+#[cfg(not(stage0))]\n priv impl BitvSet {\n     /// Visits each of the words that the two bit vectors (self and other)\n     /// both have in common. The three yielded arguments are (bit location,\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     fn each_common(&self, other: &BitvSet,\n-                        f: &fn(uint, uint, uint) -> bool) {\n+                   f: &fn(uint, uint, uint) -> bool) -> bool {\n         let min = uint::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n-        for self.bitv.storage.slice(0, min).eachi |i, &w| {\n-            if !f(i * uint::bits, w, other.bitv.storage[i]) {\n-                return;\n-            }\n-        }\n+        self.bitv.storage.slice(0, min).eachi(|i, &w| {\n+            f(i * uint::bits, w, other.bitv.storage[i])\n+        })\n     }\n \n     /// Visits each word in self or other that extends beyond the other. This\n@@ -841,22 +872,23 @@ priv impl BitvSet {\n     /// is true if the word comes from 'self', and false if it comes from\n     /// 'other'.\n     fn each_outlier(&self, other: &BitvSet,\n-                         f: &fn(bool, uint, uint) -> bool) {\n+                    f: &fn(bool, uint, uint) -> bool) -> bool {\n         let len1 = self.bitv.storage.len();\n         let len2 = other.bitv.storage.len();\n         let min = uint::min(len1, len2);\n \n         /* only one of these loops will execute and that's the point */\n         for self.bitv.storage.slice(min, len1).eachi |i, &w| {\n             if !f(true, (i + min) * uint::bits, w) {\n-                return;\n+                return false;\n             }\n         }\n         for other.bitv.storage.slice(min, len2).eachi |i, &w| {\n             if !f(false, (i + min) * uint::bits, w) {\n-                return;\n+                return false;\n             }\n         }\n+        return true;\n     }\n }\n "}, {"sha": "4eb359e48a84d518f4ea4b40443a1586f438a93e", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=3ce9dba6775c7e1dbfb510626c073a8f926b6880", "patch": "@@ -63,15 +63,25 @@ pub impl<T> Deque<T> {\n     }\n \n     /// Iterate over the elements in the deque\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&T) -> bool) {\n         self.eachi(|_i, e| f(e))\n     }\n+    /// Iterate over the elements in the deque\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(&T) -> bool) -> bool {\n+        self.eachi(|_i, e| f(e))\n+    }\n \n     /// Iterate over the elements in the deque by index\n+    #[cfg(stage0)]\n     fn eachi(&self, f: &fn(uint, &T) -> bool) {\n-        for uint::range(0, self.nelts) |i| {\n-            if !f(i, self.get(i as int)) { return; }\n-        }\n+        uint::range(0, self.nelts, |i| f(i, self.get(i as int)))\n+    }\n+    /// Iterate over the elements in the deque by index\n+    #[cfg(not(stage0))]\n+    fn eachi(&self, f: &fn(uint, &T) -> bool) -> bool {\n+        uint::range(0, self.nelts, |i| f(i, self.get(i as int)))\n     }\n \n     /// Remove and return the first element in the deque"}, {"sha": "93740f31b9b275bede541ec355f01c0196efea34", "filename": "src/libstd/dlist.rs", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdlist.rs?ref=3ce9dba6775c7e1dbfb510626c073a8f926b6880", "patch": "@@ -492,12 +492,13 @@ pub impl<T:Copy> DList<T> {\n \n impl<T> BaseIter<T> for @mut DList<T> {\n     /**\n-    * Iterates through the current contents.\n-    *\n-    * Attempts to access this dlist during iteration are allowed (to\n-    * allow for e.g. breadth-first search with in-place enqueues), but\n-    * removing the current node is forbidden.\n-    */\n+     * Iterates through the current contents.\n+     *\n+     * Attempts to access this dlist during iteration are allowed (to\n+     * allow for e.g. breadth-first search with in-place enqueues), but\n+     * removing the current node is forbidden.\n+     */\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(v: &T) -> bool) {\n         let mut link = self.peek_n();\n         while link.is_some() {\n@@ -525,6 +526,42 @@ impl<T> BaseIter<T> for @mut DList<T> {\n             link = nobe.next_link();\n         }\n     }\n+    /**\n+     * Iterates through the current contents.\n+     *\n+     * Attempts to access this dlist during iteration are allowed (to\n+     * allow for e.g. breadth-first search with in-place enqueues), but\n+     * removing the current node is forbidden.\n+     */\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(v: &T) -> bool) -> bool {\n+        let mut link = self.peek_n();\n+        while link.is_some() {\n+            let nobe = link.get();\n+            assert!(nobe.linked);\n+\n+            {\n+                let frozen_nobe = &*nobe;\n+                if !f(&frozen_nobe.data) { return false; }\n+            }\n+\n+            // Check (weakly) that the user didn't do a remove.\n+            if self.size == 0 {\n+                fail!(\"The dlist became empty during iteration??\")\n+            }\n+            if !nobe.linked ||\n+                (!((nobe.prev.is_some()\n+                    || managed::mut_ptr_eq(self.hd.expect(~\"headless dlist?\"),\n+                                           nobe))\n+                   && (nobe.next.is_some()\n+                    || managed::mut_ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n+                                           nobe)))) {\n+                fail!(\"Removing a dlist node during iteration is forbidden!\")\n+            }\n+            link = nobe.next_link();\n+        }\n+        return true;\n+    }\n \n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }"}, {"sha": "13ef377fabeb26be6c5a93b78a051f61613c3895", "filename": "src/libstd/list.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=3ce9dba6775c7e1dbfb510626c073a8f926b6880", "patch": "@@ -140,6 +140,7 @@ pub fn iter<T>(l: @List<T>, f: &fn(&T)) {\n }\n \n /// Iterate over a list\n+#[cfg(stage0)]\n pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n     let mut cur = l;\n     loop {\n@@ -152,9 +153,24 @@ pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n         }\n     }\n }\n+/// Iterate over a list\n+#[cfg(not(stage0))]\n+pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) -> bool {\n+    let mut cur = l;\n+    loop {\n+        cur = match *cur {\n+          Cons(ref hd, tl) => {\n+            if !f(hd) { return false; }\n+            tl\n+          }\n+          Nil => { return true; }\n+        }\n+    }\n+}\n \n impl<T> MutList<T> {\n     /// Iterate over a mutable list\n+    #[cfg(stage0)]\n     pub fn each(@mut self, f: &fn(&mut T) -> bool) {\n         let mut cur = self;\n         loop {\n@@ -170,6 +186,24 @@ impl<T> MutList<T> {\n             }\n         }\n     }\n+    /// Iterate over a mutable list\n+    #[cfg(not(stage0))]\n+    pub fn each(@mut self, f: &fn(&mut T) -> bool) -> bool {\n+        let mut cur = self;\n+        loop {\n+            let borrowed = &mut *cur;\n+            cur = match *borrowed {\n+                MutCons(ref mut hd, tl) => {\n+                    if !f(hd) {\n+                        return false;\n+                    }\n+                    tl\n+                }\n+                MutNil => break\n+            }\n+        }\n+        return true;\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "e7cf710cf67978e381a06edeb96f6be98302df5a", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=3ce9dba6775c7e1dbfb510626c073a8f926b6880", "patch": "@@ -703,11 +703,18 @@ impl ToStr for Url {\n     }\n }\n \n+#[cfg(stage0)]\n impl IterBytes for Url {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_str().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for Url {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_str().iter_bytes(lsb0, f)\n+    }\n+}\n \n // Put a few tests outside of the 'test' module so they can test the internal\n // functions and those functions don't need 'pub'"}, {"sha": "bdb93142472fbc583d56039915a73a08eb604b19", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=3ce9dba6775c7e1dbfb510626c073a8f926b6880", "patch": "@@ -28,7 +28,14 @@ impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n     /// Visit all values in the underlying vector.\n     ///\n     /// The values are **not** visited in order.\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&T) -> bool) { self.data.each(f) }\n+    /// Visit all values in the underlying vector.\n+    ///\n+    /// The values are **not** visited in order.\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(&T) -> bool) -> bool { self.data.each(f) }\n+\n     fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n }\n "}, {"sha": "afc1d0fe65fcb2dfc8f1a88034816fa23cc136bb", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=3ce9dba6775c7e1dbfb510626c073a8f926b6880", "patch": "@@ -51,6 +51,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Visit all key-value pairs in order\n+    #[cfg(stage0)]\n     fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n@@ -60,25 +61,62 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         }\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) -> bool {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref elt) => if !it(&i, elt) { return false; },\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n+\n     /// Visit all keys in order\n+    #[cfg(stage0)]\n     fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n         self.each(|k, _| blk(k))\n     }\n+    #[cfg(not(stage0))]\n+    /// Visit all keys in order\n+    fn each_key(&self, blk: &fn(key: &uint) -> bool) -> bool {\n+        self.each(|k, _| blk(k))\n+    }\n \n     /// Visit all values in order\n+    #[cfg(stage0)]\n     fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n \n+    /// Visit all values in order\n+    #[cfg(not(stage0))]\n+    fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) -> bool {\n+        self.each(|_, v| blk(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n+    #[cfg(stage0)]\n     fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n-              Some(ref mut elt) => if !it(&i, elt) { break },\n+              Some(ref mut elt) => if !it(&i, elt) { return; },\n               None => ()\n             }\n         }\n     }\n+    /// Iterate over the map and mutate the contained values\n+    #[cfg(not(stage0))]\n+    fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) -> bool {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref mut elt) => if !it(&i, elt) { return false; },\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n \n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n@@ -149,6 +187,7 @@ pub impl<V> SmallIntMap<V> {\n     fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n     /// Visit all key-value pairs in reverse order\n+    #[cfg(stage0)]\n     fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n@@ -158,6 +197,18 @@ pub impl<V> SmallIntMap<V> {\n         }\n     }\n \n+    /// Visit all key-value pairs in reverse order\n+    #[cfg(not(stage0))]\n+    fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n+        for uint::range_rev(self.v.len(), 0) |i| {\n+            match self.v[i - 1] {\n+              Some(ref elt) => if !it(i - 1, elt) { return false; },\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n+\n     fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }"}, {"sha": "d68b08dc4750d2ef41ca4de5c0de79152660caf5", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 206, "deletions": 10, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=3ce9dba6775c7e1dbfb510626c073a8f926b6880", "patch": "@@ -105,24 +105,48 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Visit all key-value pairs in order\n+    #[cfg(stage0)]\n     fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) {\n+        each(&self.root, f);\n+    }\n+    /// Visit all key-value pairs in order\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n         each(&self.root, f)\n     }\n \n     /// Visit all keys in order\n+    #[cfg(stage0)]\n     fn each_key(&self, f: &fn(&K) -> bool) {\n         self.each(|k, _| f(k))\n     }\n+    /// Visit all keys in order\n+    #[cfg(not(stage0))]\n+    fn each_key(&self, f: &fn(&K) -> bool) -> bool {\n+        self.each(|k, _| f(k))\n+    }\n \n     /// Visit all values in order\n+    #[cfg(stage0)]\n     fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) {\n         self.each(|_, v| f(v))\n     }\n+    /// Visit all values in order\n+    #[cfg(not(stage0))]\n+    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool {\n+        self.each(|_, v| f(v))\n+    }\n \n     /// Iterate over the map and mutate the contained values\n+    #[cfg(stage0)]\n     fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) {\n         mutate_values(&mut self.root, f);\n     }\n+    /// Iterate over the map and mutate the contained values\n+    #[cfg(not(stage0))]\n+    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool {\n+        mutate_values(&mut self.root, f)\n+    }\n \n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n@@ -177,6 +201,7 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n }\n \n+#[cfg(stage0)]\n pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n@@ -202,6 +227,32 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root}\n     }\n }\n+#[cfg(not(stage0))]\n+pub impl<K: TotalOrd, V> TreeMap<K, V> {\n+    /// Create an empty TreeMap\n+    fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n+\n+    /// Visit all key-value pairs in reverse order\n+    fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n+        each_reverse(&self.root, f)\n+    }\n+\n+    /// Visit all keys in reverse order\n+    fn each_key_reverse(&self, f: &fn(&K) -> bool) -> bool {\n+        self.each_reverse(|k, _| f(k))\n+    }\n+\n+    /// Visit all values in reverse order\n+    fn each_value_reverse(&self, f: &fn(&V) -> bool) -> bool {\n+        self.each_reverse(|_, v| f(v))\n+    }\n+\n+    /// Get a lazy iterator over the key-value pairs in the map.\n+    /// Requires that it be frozen (immutable).\n+    fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n+        TreeMapIterator{stack: ~[], node: &self.root}\n+    }\n+}\n \n /// Lazy forward iterator over a map\n pub struct TreeMapIterator<'self, K, V> {\n@@ -246,17 +297,29 @@ pub struct TreeSet<T> {\n impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n+    /// Visit all values in order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each_reverse(&self, f: &fn(&T) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n+    /// Visit all values in reverse order\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n+        self.map.each_key_reverse(f)\n+    }\n }\n \n impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n@@ -361,6 +424,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the difference\n+    #[cfg(stage0)]\n     fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -389,8 +453,38 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n             }\n         }\n     }\n+    /// Visit the values (in-order) representing the difference\n+    #[cfg(not(stage0))]\n+    fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+\n+        let mut a = x.next();\n+        let mut b = y.next();\n+\n+        while a.is_some() {\n+            if b.is_none() {\n+                return f(a.unwrap()) && x.advance(f);\n+            }\n+\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            let cmp = a1.cmp(b1);\n+\n+            if cmp == Less {\n+                if !f(a1) { return false; }\n+                a = x.next();\n+            } else {\n+                if cmp == Equal { a = x.next() }\n+                b = y.next();\n+            }\n+        }\n+        return true;\n+    }\n \n     /// Visit the values (in-order) representing the symmetric difference\n+    #[cfg(stage0)]\n     fn symmetric_difference(&self, other: &TreeSet<T>,\n                                  f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n@@ -427,8 +521,43 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n             if f(b1) { y.next() } else { None }\n         }\n     }\n+    /// Visit the values (in-order) representing the symmetric difference\n+    #[cfg(not(stage0))]\n+    fn symmetric_difference(&self, other: &TreeSet<T>,\n+                            f: &fn(&T) -> bool) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+\n+        let mut a = x.next();\n+        let mut b = y.next();\n+\n+        while a.is_some() {\n+            if b.is_none() {\n+                return f(a.unwrap()) && x.advance(f);\n+            }\n+\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            let cmp = a1.cmp(b1);\n+\n+            if cmp == Less {\n+                if !f(a1) { return false; }\n+                a = x.next();\n+            } else {\n+                if cmp == Greater {\n+                    if !f(b1) { return false; }\n+                } else {\n+                    a = x.next();\n+                }\n+                b = y.next();\n+            }\n+        }\n+        return b.each(|&x| f(x)) && y.advance(f);\n+    }\n \n     /// Visit the values (in-order) representing the intersection\n+    #[cfg(stage0)]\n     fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -452,8 +581,35 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n             }\n         }\n     }\n+    /// Visit the values (in-order) representing the intersection\n+    #[cfg(not(stage0))]\n+    fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+\n+        let mut a = x.next();\n+        let mut b = y.next();\n+\n+        while a.is_some() && b.is_some() {\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            let cmp = a1.cmp(b1);\n+\n+            if cmp == Less {\n+                a = x.next();\n+            } else {\n+                if cmp == Equal {\n+                    if !f(a1) { return false }\n+                }\n+                b = y.next();\n+            }\n+        }\n+        return true;\n+    }\n \n     /// Visit the values (in-order) representing the union\n+    #[cfg(stage0)]\n     fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -488,6 +644,38 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n             if f(b1) { y.next() } else { None }\n         }\n     }\n+    /// Visit the values (in-order) representing the union\n+    #[cfg(not(stage0))]\n+    fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+\n+        let mut a = x.next();\n+        let mut b = y.next();\n+\n+        while a.is_some() {\n+            if b.is_none() {\n+                return f(a.unwrap()) && x.advance(f);\n+            }\n+\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            let cmp = a1.cmp(b1);\n+\n+            if cmp == Greater {\n+                if !f(b1) { return false; }\n+                b = y.next();\n+            } else {\n+                if !f(a1) { return false; }\n+                if cmp == Equal {\n+                    b = y.next();\n+                }\n+                a = x.next();\n+            }\n+        }\n+        return a.each(|&x| f(x)) && y.advance(f);\n+    }\n }\n \n pub impl <T: TotalOrd> TreeSet<T> {\n@@ -525,20 +713,28 @@ pub impl<K: TotalOrd, V> TreeNode<K, V> {\n     }\n }\n \n+#[cfg(stage0)]\n+fn each<'r, K: TotalOrd, V>(_: &'r Option<~TreeNode<K, V>>,\n+                            _: &fn(&'r K, &'r V) -> bool) -> bool {\n+    fail!(~\"don't use me in stage0!\")\n+}\n+#[cfg(not(stage0))]\n fn each<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n-                            f: &fn(&'r K, &'r V) -> bool) {\n-    for node.each |x| {\n-        each(&x.left, f);\n-        if f(&x.key, &x.value) { each(&x.right, f) }\n-    }\n+                            f: &fn(&'r K, &'r V) -> bool) -> bool {\n+    node.each(|x| each(&x.left, f) && f(&x.key, &x.value) &&\n+                  each(&x.right, f))\n }\n \n+#[cfg(stage0)]\n+fn each_reverse<'r, K: TotalOrd, V>(_: &'r Option<~TreeNode<K, V>>,\n+                                    _: &fn(&'r K, &'r V) -> bool) -> bool {\n+    fail!(~\"don't use me in stage0!\")\n+}\n+#[cfg(not(stage0))]\n fn each_reverse<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n-                                    f: &fn(&'r K, &'r V) -> bool) {\n-    for node.each |x| {\n-        each_reverse(&x.right, f);\n-        if f(&x.key, &x.value) { each_reverse(&x.left, f) }\n-    }\n+                                    f: &fn(&'r K, &'r V) -> bool) -> bool {\n+    node.each(|x| each_reverse(&x.right, f) && f(&x.key, &x.value) &&\n+                  each_reverse(&x.left, f))\n }\n \n fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,"}, {"sha": "9b0a6cb6226c191050151e6c4556801d52ce14dc", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce9dba6775c7e1dbfb510626c073a8f926b6880/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=3ce9dba6775c7e1dbfb510626c073a8f926b6880", "patch": "@@ -99,6 +99,7 @@ struct WorkKey {\n     name: ~str\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for WorkKey {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n@@ -108,6 +109,13 @@ impl to_bytes::IterBytes for WorkKey {\n         self.name.iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for WorkKey {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.kind.iter_bytes(lsb0, f) && self.name.iter_bytes(lsb0, f)\n+    }\n+}\n \n impl cmp::Ord for WorkKey {\n     fn lt(&self, other: &WorkKey) -> bool {"}]}