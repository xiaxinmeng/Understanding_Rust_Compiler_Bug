{"sha": "42ea15be0a55ae7624a21f00818c2fcdf0d21e59", "node_id": "C_kwDOAAsO6NoAKDQyZWExNWJlMGE1NWFlNzYyNGEyMWYwMDgxOGMyZmNkZjBkMjFlNTk", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2021-09-30T02:33:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-30T02:33:34Z"}, "message": "Rollup merge of #87428 - GuillaumeGomez:union-highlighting, r=notriddle\n\nFix union keyword highlighting in rustdoc HTML sources\n\nI followed this logic: if I find an ident \"union\", I check if it followed by another ident or not. If it's the case, then I consider this is a keyword because it's declaring a union type.\n\nTo do so I created a new Iterator which allows to peek the next items without moving the current iterator position.\n\nThis is part of https://github.com/rust-lang/rust/issues/85016. If the fix makes sense, I'll extend it to other weak keywords (the issue only mentions they exist but https://doc.rust-lang.org/nightly/reference/keywords.html#weak-keywords only talks about `dyn` and `'static` so not sure if there is anything else to be done?).\n\ncc `@notriddle` (you're one of the last ones who worked on this part of rustdoc so here you go :wink: )\nr? `@jyn514`", "tree": {"sha": "4002240ed47788c1efdaab7c82376e8099998c32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4002240ed47788c1efdaab7c82376e8099998c32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42ea15be0a55ae7624a21f00818c2fcdf0d21e59", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhVSH+CRBK7hj4Ov3rIwAAS7kIAF2QMiPw2Zt44DpwUT3lNRTQ\np+4Zi6mDr07uQcRjl4zHyddKt8SW7cwHrLKfhxsaQCtNYF3kj0aMJIK4fUYW0/8k\nG/Mmnx1mz1RsZwtw60acEWCwJtHjgZuLuH9rOaagG+bsHn3YYOlxdzRwv/bxlFWh\n6JWt0c6rKeSUwTOohuq5hhO0ethXiHwQO7NIj5+iw9KbObrv2Px413jfVTw1L91L\nbgbG5qTBUkGZIC7dhnrMmzx0UWIT7zw3Sb7QPcobmhVOPAUNXalWHjf73+p1dNvz\nqhKBl/267gS45n3I2NlDWiISiReK/qUfVaJkG5uU/Zp+xlb17YCQLsplN2/gIeg=\n=YEeg\n-----END PGP SIGNATURE-----\n", "payload": "tree 4002240ed47788c1efdaab7c82376e8099998c32\nparent 24a789b666f2c36d443cde48b5baef04e5b3c76d\nparent ee3811671b8f4b7e6d1498a408182e2586d22613\nauthor Eric Huss <eric@huss.org> 1632969214 -0700\ncommitter GitHub <noreply@github.com> 1632969214 -0700\n\nRollup merge of #87428 - GuillaumeGomez:union-highlighting, r=notriddle\n\nFix union keyword highlighting in rustdoc HTML sources\n\nI followed this logic: if I find an ident \"union\", I check if it followed by another ident or not. If it's the case, then I consider this is a keyword because it's declaring a union type.\n\nTo do so I created a new Iterator which allows to peek the next items without moving the current iterator position.\n\nThis is part of https://github.com/rust-lang/rust/issues/85016. If the fix makes sense, I'll extend it to other weak keywords (the issue only mentions they exist but https://doc.rust-lang.org/nightly/reference/keywords.html#weak-keywords only talks about `dyn` and `'static` so not sure if there is anything else to be done?).\n\ncc `@notriddle` (you're one of the last ones who worked on this part of rustdoc so here you go :wink: )\nr? `@jyn514`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42ea15be0a55ae7624a21f00818c2fcdf0d21e59", "html_url": "https://github.com/rust-lang/rust/commit/42ea15be0a55ae7624a21f00818c2fcdf0d21e59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42ea15be0a55ae7624a21f00818c2fcdf0d21e59/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24a789b666f2c36d443cde48b5baef04e5b3c76d", "url": "https://api.github.com/repos/rust-lang/rust/commits/24a789b666f2c36d443cde48b5baef04e5b3c76d", "html_url": "https://github.com/rust-lang/rust/commit/24a789b666f2c36d443cde48b5baef04e5b3c76d"}, {"sha": "ee3811671b8f4b7e6d1498a408182e2586d22613", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee3811671b8f4b7e6d1498a408182e2586d22613", "html_url": "https://github.com/rust-lang/rust/commit/ee3811671b8f4b7e6d1498a408182e2586d22613"}], "stats": {"total": 96, "additions": 91, "deletions": 5}, "files": [{"sha": "43d1b8f794c3060ea0e9bc68c989539bd545288f", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/42ea15be0a55ae7624a21f00818c2fcdf0d21e59/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ea15be0a55ae7624a21f00818c2fcdf0d21e59/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=42ea15be0a55ae7624a21f00818c2fcdf0d21e59", "patch": "@@ -9,8 +9,8 @@ use crate::clean::PrimitiveType;\n use crate::html::escape::Escape;\n use crate::html::render::Context;\n \n+use std::collections::VecDeque;\n use std::fmt::{Display, Write};\n-use std::iter::Peekable;\n \n use rustc_lexer::{LiteralKind, TokenKind};\n use rustc_span::edition::Edition;\n@@ -201,10 +201,57 @@ fn get_real_ident_class(text: &str, edition: Edition, allow_path_keywords: bool)\n     })\n }\n \n+/// This iterator comes from the same idea than \"Peekable\" except that it allows to \"peek\" more than\n+/// just the next item by using `peek_next`. The `peek` method always returns the next item after\n+/// the current one whereas `peek_next` will return the next item after the last one peeked.\n+///\n+/// You can use both `peek` and `peek_next` at the same time without problem.\n+struct PeekIter<'a> {\n+    stored: VecDeque<(TokenKind, &'a str)>,\n+    /// This position is reinitialized when using `next`. It is used in `peek_next`.\n+    peek_pos: usize,\n+    iter: TokenIter<'a>,\n+}\n+\n+impl PeekIter<'a> {\n+    fn new(iter: TokenIter<'a>) -> Self {\n+        Self { stored: VecDeque::new(), peek_pos: 0, iter }\n+    }\n+    /// Returns the next item after the current one. It doesn't interfer with `peek_next` output.\n+    fn peek(&mut self) -> Option<&(TokenKind, &'a str)> {\n+        if self.stored.is_empty() {\n+            if let Some(next) = self.iter.next() {\n+                self.stored.push_back(next);\n+            }\n+        }\n+        self.stored.front()\n+    }\n+    /// Returns the next item after the last one peeked. It doesn't interfer with `peek` output.\n+    fn peek_next(&mut self) -> Option<&(TokenKind, &'a str)> {\n+        self.peek_pos += 1;\n+        if self.peek_pos - 1 < self.stored.len() {\n+            self.stored.get(self.peek_pos - 1)\n+        } else if let Some(next) = self.iter.next() {\n+            self.stored.push_back(next);\n+            self.stored.back()\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl Iterator for PeekIter<'a> {\n+    type Item = (TokenKind, &'a str);\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.peek_pos = 0;\n+        if let Some(first) = self.stored.pop_front() { Some(first) } else { self.iter.next() }\n+    }\n+}\n+\n /// Processes program tokens, classifying strings of text by highlighting\n /// category (`Class`).\n struct Classifier<'a> {\n-    tokens: Peekable<TokenIter<'a>>,\n+    tokens: PeekIter<'a>,\n     in_attribute: bool,\n     in_macro: bool,\n     in_macro_nonterminal: bool,\n@@ -218,7 +265,7 @@ impl<'a> Classifier<'a> {\n     /// Takes as argument the source code to HTML-ify, the rust edition to use and the source code\n     /// file span which will be used later on by the `span_correspondance_map`.\n     fn new(src: &str, edition: Edition, file_span: Span) -> Classifier<'_> {\n-        let tokens = TokenIter { src }.peekable();\n+        let tokens = PeekIter::new(TokenIter { src });\n         Classifier {\n             tokens,\n             in_attribute: false,\n@@ -369,7 +416,7 @@ impl<'a> Classifier<'a> {\n             // Assume that '&' or '*' is the reference or dereference operator\n             // or a reference or pointer type. Unless, of course, it looks like\n             // a logical and or a multiplication operator: `&&` or `* `.\n-            TokenKind::Star => match lookahead {\n+            TokenKind::Star => match self.peek() {\n                 Some(TokenKind::Whitespace) => Class::Op,\n                 _ => Class::RefKeyWord,\n             },\n@@ -480,6 +527,9 @@ impl<'a> Classifier<'a> {\n                 None => match text {\n                     \"Option\" | \"Result\" => Class::PreludeTy,\n                     \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n+                    // \"union\" is a weak keyword and is only considered as a keyword when declaring\n+                    // a union type.\n+                    \"union\" if self.check_if_is_union_keyword() => Class::KeyWord,\n                     _ if self.in_macro_nonterminal => {\n                         self.in_macro_nonterminal = false;\n                         Class::MacroNonTerminal\n@@ -500,7 +550,17 @@ impl<'a> Classifier<'a> {\n     }\n \n     fn peek(&mut self) -> Option<TokenKind> {\n-        self.tokens.peek().map(|(toke_kind, _text)| *toke_kind)\n+        self.tokens.peek().map(|(token_kind, _text)| *token_kind)\n+    }\n+\n+    fn check_if_is_union_keyword(&mut self) -> bool {\n+        while let Some(kind) = self.tokens.peek_next().map(|(token_kind, _text)| token_kind) {\n+            if *kind == TokenKind::Whitespace {\n+                continue;\n+            }\n+            return *kind == TokenKind::Ident;\n+        }\n+        false\n     }\n }\n "}, {"sha": "c0acf31a05d08ff7e6536efb43fb63b114076b65", "filename": "src/librustdoc/html/highlight/fixtures/union.html", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42ea15be0a55ae7624a21f00818c2fcdf0d21e59/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Funion.html", "raw_url": "https://github.com/rust-lang/rust/raw/42ea15be0a55ae7624a21f00818c2fcdf0d21e59/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Funion.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Funion.html?ref=42ea15be0a55ae7624a21f00818c2fcdf0d21e59", "patch": "@@ -0,0 +1,8 @@\n+<span class=\"kw\">union</span> <span class=\"ident\">Foo</span> {\n+    <span class=\"ident\">i</span>: <span class=\"ident\">i8</span>,\n+    <span class=\"ident\">u</span>: <span class=\"ident\">i8</span>,\n+}\n+\n+<span class=\"kw\">fn</span> <span class=\"ident\">main</span>() {\n+    <span class=\"kw\">let</span> <span class=\"ident\">union</span> <span class=\"op\">=</span> <span class=\"number\">0</span>;\n+}"}, {"sha": "269ee115d3f8f6ebc2b1e648c632e543ab2c383b", "filename": "src/librustdoc/html/highlight/fixtures/union.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42ea15be0a55ae7624a21f00818c2fcdf0d21e59/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Funion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ea15be0a55ae7624a21f00818c2fcdf0d21e59/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Funion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Funion.rs?ref=42ea15be0a55ae7624a21f00818c2fcdf0d21e59", "patch": "@@ -0,0 +1,8 @@\n+union Foo {\n+    i: i8,\n+    u: i8,\n+}\n+\n+fn main() {\n+    let union = 0;\n+}"}, {"sha": "450bbfea1ea863143504f6f0a9ec91b77b5cee80", "filename": "src/librustdoc/html/highlight/tests.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42ea15be0a55ae7624a21f00818c2fcdf0d21e59/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ea15be0a55ae7624a21f00818c2fcdf0d21e59/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs?ref=42ea15be0a55ae7624a21f00818c2fcdf0d21e59", "patch": "@@ -54,3 +54,13 @@ let y = Self::whatever;\";\n         expect_file![\"fixtures/highlight.html\"].assert_eq(&html.into_inner());\n     });\n }\n+\n+#[test]\n+fn test_union_highlighting() {\n+    create_default_session_globals_then(|| {\n+        let src = include_str!(\"fixtures/union.rs\");\n+        let mut html = Buffer::new();\n+        write_code(&mut html, src, Edition::Edition2018, None);\n+        expect_file![\"fixtures/union.html\"].assert_eq(&html.into_inner());\n+    });\n+}"}]}