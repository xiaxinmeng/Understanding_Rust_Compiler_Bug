{"sha": "1f897d1c6eaa7f0251bb47a5d2d1894cd8e82d54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmODk3ZDFjNmVhYTdmMDI1MWJiNDdhNWQyZDE4OTRjZDhlODJkNTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-13T11:37:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-13T11:37:32Z"}, "message": "Merge #3120\n\n3120: Support trait auto import r=matklad a=SomeoneToIgnore\n\nUnfortunately, for real cases it does not work as spectacular as in the tests.\r\n\r\nThe main reason for that is type inference:\r\n* The callee type [here](https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_hir_ty/src/method_resolution.rs#L369) is unknown for many cases\r\n* The trait solution [here](https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_hir_ty/src/method_resolution.rs#L399) is also often ambiguous\r\n\r\nThat results in trait candidates being rejected, and some real cases not supported.\r\nExample: no imports for `String::from_str(\"test\")`\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "87c4f024bfd4308e4ab6a7068102808efec888b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87c4f024bfd4308e4ab6a7068102808efec888b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f897d1c6eaa7f0251bb47a5d2d1894cd8e82d54", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeRTT8CRBK7hj4Ov3rIwAAdHIIAKtL1o0f2EUr06tA0NRr2xp4\nA0BJRDzP6QCgablFzyNHGNXj7GSrRHB57QFpu+Q0UQh/9pURDWioX++Gz7Vef1gH\nZRJlJrN9qA/oZ95dxnLumqGN3b8Lv5//6QSp36JPl6A2UgyLnEhjLbxf8NAWb068\nvuxStwYUMU7HUWeci0t0W+iSIqNF6BGNIhg1nV4PI73OrLEqTkzamTkYxqEwFOKc\nA1Yu+mBYh0kBFFTt+qJmcR5l+pinQCkEyElqhZp7EhlsigAqY/OWzEmTKN9VBilF\nSgx9ESRUE3Br7F02KM0jSObHVqRB2xZhaBs09BbhTwbmdHViGicL9f/ShLjfXKc=\n=BjBx\n-----END PGP SIGNATURE-----\n", "payload": "tree 87c4f024bfd4308e4ab6a7068102808efec888b6\nparent 6f2cab1368dafc5663bb591a45062280a94a4ef9\nparent e4f4cd77a07918529cd274f3299a020cbc884974\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1581593852 +0000\ncommitter GitHub <noreply@github.com> 1581593852 +0000\n\nMerge #3120\n\n3120: Support trait auto import r=matklad a=SomeoneToIgnore\n\nUnfortunately, for real cases it does not work as spectacular as in the tests.\r\n\r\nThe main reason for that is type inference:\r\n* The callee type [here](https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_hir_ty/src/method_resolution.rs#L369) is unknown for many cases\r\n* The trait solution [here](https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_hir_ty/src/method_resolution.rs#L399) is also often ambiguous\r\n\r\nThat results in trait candidates being rejected, and some real cases not supported.\r\nExample: no imports for `String::from_str(\"test\")`\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f897d1c6eaa7f0251bb47a5d2d1894cd8e82d54", "html_url": "https://github.com/rust-lang/rust/commit/1f897d1c6eaa7f0251bb47a5d2d1894cd8e82d54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f897d1c6eaa7f0251bb47a5d2d1894cd8e82d54/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f2cab1368dafc5663bb591a45062280a94a4ef9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f2cab1368dafc5663bb591a45062280a94a4ef9", "html_url": "https://github.com/rust-lang/rust/commit/6f2cab1368dafc5663bb591a45062280a94a4ef9"}, {"sha": "e4f4cd77a07918529cd274f3299a020cbc884974", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f4cd77a07918529cd274f3299a020cbc884974", "html_url": "https://github.com/rust-lang/rust/commit/e4f4cd77a07918529cd274f3299a020cbc884974"}], "stats": {"total": 590, "additions": 545, "deletions": 45}, "files": [{"sha": "c4aea2a06703bb956d2d6c1aed19b1c1b64f0732", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 544, "deletions": 44, "changes": 588, "blob_url": "https://github.com/rust-lang/rust/blob/1f897d1c6eaa7f0251bb47a5d2d1894cd8e82d54/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f897d1c6eaa7f0251bb47a5d2d1894cd8e82d54/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=1f897d1c6eaa7f0251bb47a5d2d1894cd8e82d54", "patch": "@@ -1,10 +1,18 @@\n-use ra_ide_db::imports_locator::ImportsLocator;\n-use ra_syntax::ast::{self, AstNode};\n-\n use crate::{\n     assist_ctx::{Assist, AssistCtx},\n     insert_use_statement, AssistId,\n };\n+use hir::{\n+    db::HirDatabase, AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution,\n+    SourceAnalyzer, Trait, Type,\n+};\n+use ra_ide_db::{imports_locator::ImportsLocator, RootDatabase};\n+use ra_prof::profile;\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    SyntaxNode,\n+};\n+use rustc_hash::FxHashSet;\n use std::collections::BTreeSet;\n \n // Assist: auto_import\n@@ -27,52 +35,24 @@ use std::collections::BTreeSet;\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n-    let path_under_caret: ast::Path = ctx.find_node_at_offset()?;\n-    if path_under_caret.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n-        return None;\n-    }\n-\n-    let module = path_under_caret.syntax().ancestors().find_map(ast::Module::cast);\n-    let position = match module.and_then(|it| it.item_list()) {\n-        Some(item_list) => item_list.syntax().clone(),\n-        None => {\n-            let current_file =\n-                path_under_caret.syntax().ancestors().find_map(ast::SourceFile::cast)?;\n-            current_file.syntax().clone()\n-        }\n-    };\n-    let source_analyzer = ctx.source_analyzer(&position, None);\n-    let module_with_name_to_import = source_analyzer.module()?;\n-\n-    let name_ref_to_import =\n-        path_under_caret.syntax().descendants().find_map(ast::NameRef::cast)?;\n-    if source_analyzer\n-        .resolve_path(ctx.db, &name_ref_to_import.syntax().ancestors().find_map(ast::Path::cast)?)\n-        .is_some()\n-    {\n-        return None;\n-    }\n-\n-    let name_to_import = name_ref_to_import.syntax().to_string();\n-    let proposed_imports = ImportsLocator::new(ctx.db)\n-        .find_imports(&name_to_import)\n-        .into_iter()\n-        .filter_map(|module_def| module_with_name_to_import.find_use_path(ctx.db, module_def))\n-        .filter(|use_path| !use_path.segments.is_empty())\n-        .take(20)\n-        .collect::<BTreeSet<_>>();\n-\n+    let auto_import_assets = AutoImportAssets::new(&ctx)?;\n+    let proposed_imports = auto_import_assets.search_for_imports(ctx.db);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n-    let mut group = ctx.add_assist_group(format!(\"Import {}\", name_to_import));\n+    let assist_group_name = if proposed_imports.len() == 1 {\n+        format!(\"Import `{}`\", proposed_imports.iter().next().unwrap())\n+    } else {\n+        auto_import_assets.get_import_group_message()\n+    };\n+    let mut group = ctx.add_assist_group(assist_group_name);\n     for import in proposed_imports {\n         group.add_assist(AssistId(\"auto_import\"), format!(\"Import `{}`\", &import), |edit| {\n-            edit.target(path_under_caret.syntax().text_range());\n+            edit.target(auto_import_assets.syntax_under_caret.text_range());\n             insert_use_statement(\n-                &position,\n-                path_under_caret.syntax(),\n+                &auto_import_assets.syntax_under_caret,\n+                &auto_import_assets.syntax_under_caret,\n                 &import,\n                 edit.text_edit_builder(),\n             );\n@@ -81,11 +61,232 @@ pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n     group.finish()\n }\n \n+struct AutoImportAssets {\n+    import_candidate: ImportCandidate,\n+    module_with_name_to_import: Module,\n+    syntax_under_caret: SyntaxNode,\n+}\n+\n+impl AutoImportAssets {\n+    fn new(ctx: &AssistCtx) -> Option<Self> {\n+        if let Some(path_under_caret) = ctx.find_node_at_offset::<ast::Path>() {\n+            Self::for_regular_path(path_under_caret, &ctx)\n+        } else {\n+            Self::for_method_call(ctx.find_node_at_offset()?, &ctx)\n+        }\n+    }\n+\n+    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistCtx) -> Option<Self> {\n+        let syntax_under_caret = method_call.syntax().to_owned();\n+        let source_analyzer = ctx.source_analyzer(&syntax_under_caret, None);\n+        let module_with_name_to_import = source_analyzer.module()?;\n+        Some(Self {\n+            import_candidate: ImportCandidate::for_method_call(\n+                &method_call,\n+                &source_analyzer,\n+                ctx.db,\n+            )?,\n+            module_with_name_to_import,\n+            syntax_under_caret,\n+        })\n+    }\n+\n+    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistCtx) -> Option<Self> {\n+        let syntax_under_caret = path_under_caret.syntax().to_owned();\n+        if syntax_under_caret.ancestors().find_map(ast::UseItem::cast).is_some() {\n+            return None;\n+        }\n+\n+        let source_analyzer = ctx.source_analyzer(&syntax_under_caret, None);\n+        let module_with_name_to_import = source_analyzer.module()?;\n+        Some(Self {\n+            import_candidate: ImportCandidate::for_regular_path(\n+                &path_under_caret,\n+                &source_analyzer,\n+                ctx.db,\n+            )?,\n+            module_with_name_to_import,\n+            syntax_under_caret,\n+        })\n+    }\n+\n+    fn get_search_query(&self) -> &str {\n+        match &self.import_candidate {\n+            ImportCandidate::UnqualifiedName(name) => name,\n+            ImportCandidate::QualifierStart(qualifier_start) => qualifier_start,\n+            ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => trait_assoc_item_name,\n+            ImportCandidate::TraitMethod(_, trait_method_name) => trait_method_name,\n+        }\n+    }\n+\n+    fn get_import_group_message(&self) -> String {\n+        match &self.import_candidate {\n+            ImportCandidate::UnqualifiedName(name) => format!(\"Import {}\", name),\n+            ImportCandidate::QualifierStart(qualifier_start) => {\n+                format!(\"Import {}\", qualifier_start)\n+            }\n+            ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => {\n+                format!(\"Import a trait for item {}\", trait_assoc_item_name)\n+            }\n+            ImportCandidate::TraitMethod(_, trait_method_name) => {\n+                format!(\"Import a trait for method {}\", trait_method_name)\n+            }\n+        }\n+    }\n+\n+    fn search_for_imports(&self, db: &RootDatabase) -> BTreeSet<ModPath> {\n+        let _p = profile(\"auto_import::search_for_imports\");\n+        let current_crate = self.module_with_name_to_import.krate();\n+        ImportsLocator::new(db)\n+            .find_imports(&self.get_search_query())\n+            .into_iter()\n+            .filter_map(|module_def| match &self.import_candidate {\n+                ImportCandidate::TraitAssocItem(assoc_item_type, _) => {\n+                    let located_assoc_item = match module_def {\n+                        ModuleDef::Function(located_function) => located_function\n+                            .as_assoc_item(db)\n+                            .map(|assoc| assoc.container(db))\n+                            .and_then(Self::assoc_to_trait),\n+                        ModuleDef::Const(located_const) => located_const\n+                            .as_assoc_item(db)\n+                            .map(|assoc| assoc.container(db))\n+                            .and_then(Self::assoc_to_trait),\n+                        _ => None,\n+                    }?;\n+\n+                    let mut trait_candidates = FxHashSet::default();\n+                    trait_candidates.insert(located_assoc_item.into());\n+\n+                    assoc_item_type\n+                        .iterate_path_candidates(\n+                            db,\n+                            current_crate,\n+                            &trait_candidates,\n+                            None,\n+                            |_, assoc| Self::assoc_to_trait(assoc.container(db)),\n+                        )\n+                        .map(ModuleDef::from)\n+                }\n+                ImportCandidate::TraitMethod(function_callee, _) => {\n+                    let located_assoc_item =\n+                        if let ModuleDef::Function(located_function) = module_def {\n+                            located_function\n+                                .as_assoc_item(db)\n+                                .map(|assoc| assoc.container(db))\n+                                .and_then(Self::assoc_to_trait)\n+                        } else {\n+                            None\n+                        }?;\n+\n+                    let mut trait_candidates = FxHashSet::default();\n+                    trait_candidates.insert(located_assoc_item.into());\n+\n+                    function_callee\n+                        .iterate_method_candidates(\n+                            db,\n+                            current_crate,\n+                            &trait_candidates,\n+                            None,\n+                            |_, function| {\n+                                Self::assoc_to_trait(function.as_assoc_item(db)?.container(db))\n+                            },\n+                        )\n+                        .map(ModuleDef::from)\n+                }\n+                _ => Some(module_def),\n+            })\n+            .filter_map(|module_def| self.module_with_name_to_import.find_use_path(db, module_def))\n+            .filter(|use_path| !use_path.segments.is_empty())\n+            .take(20)\n+            .collect::<BTreeSet<_>>()\n+    }\n+\n+    fn assoc_to_trait(assoc: AssocItemContainer) -> Option<Trait> {\n+        if let AssocItemContainer::Trait(extracted_trait) = assoc {\n+            Some(extracted_trait)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum ImportCandidate {\n+    /// Simple name like 'HashMap'\n+    UnqualifiedName(String),\n+    /// First part of the qualified name.\n+    /// For 'std::collections::HashMap', that will be 'std'.\n+    QualifierStart(String),\n+    /// A trait associated function (with no self parameter) or associated constant.\n+    /// For 'test_mod::TestEnum::test_function', `Type` is the `test_mod::TestEnum` expression type\n+    /// and `String` is the `test_function`\n+    TraitAssocItem(Type, String),\n+    /// A trait method with self parameter.\n+    /// For 'test_enum.test_method()', `Type` is the `test_enum` expression type\n+    /// and `String` is the `test_method`\n+    TraitMethod(Type, String),\n+}\n+\n+impl ImportCandidate {\n+    fn for_method_call(\n+        method_call: &ast::MethodCallExpr,\n+        source_analyzer: &SourceAnalyzer,\n+        db: &impl HirDatabase,\n+    ) -> Option<Self> {\n+        if source_analyzer.resolve_method_call(method_call).is_some() {\n+            return None;\n+        }\n+        Some(Self::TraitMethod(\n+            source_analyzer.type_of(db, &method_call.expr()?)?,\n+            method_call.name_ref()?.syntax().to_string(),\n+        ))\n+    }\n+\n+    fn for_regular_path(\n+        path_under_caret: &ast::Path,\n+        source_analyzer: &SourceAnalyzer,\n+        db: &impl HirDatabase,\n+    ) -> Option<Self> {\n+        if source_analyzer.resolve_path(db, path_under_caret).is_some() {\n+            return None;\n+        }\n+\n+        let segment = path_under_caret.segment()?;\n+        if let Some(qualifier) = path_under_caret.qualifier() {\n+            let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n+            let qualifier_start_path =\n+                qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n+            if let Some(qualifier_start_resolution) =\n+                source_analyzer.resolve_path(db, &qualifier_start_path)\n+            {\n+                let qualifier_resolution = if qualifier_start_path == qualifier {\n+                    qualifier_start_resolution\n+                } else {\n+                    source_analyzer.resolve_path(db, &qualifier)?\n+                };\n+                if let PathResolution::Def(ModuleDef::Adt(assoc_item_path)) = qualifier_resolution {\n+                    Some(ImportCandidate::TraitAssocItem(\n+                        assoc_item_path.ty(db),\n+                        segment.syntax().to_string(),\n+                    ))\n+                } else {\n+                    None\n+                }\n+            } else {\n+                Some(ImportCandidate::QualifierStart(qualifier_start.syntax().to_string()))\n+            }\n+        } else {\n+            Some(ImportCandidate::UnqualifiedName(\n+                segment.syntax().descendants().find_map(ast::NameRef::cast)?.syntax().to_string(),\n+            ))\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n-\n     use super::*;\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     #[test]\n     fn applicable_when_found_an_import() {\n@@ -290,4 +491,303 @@ mod tests {\n             \",\n         );\n     }\n+\n+    #[test]\n+    fn not_applicable_for_imported_function() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            pub mod test_mod {\n+                pub fn test_function() {}\n+            }\n+\n+            use test_mod::test_function;\n+            fn main() {\n+                test_function<|>\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn associated_struct_function() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    pub fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                TestStruct::test_function<|>\n+            }\n+            \",\n+            r\"\n+            use test_mod::TestStruct;\n+\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    pub fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                TestStruct::test_function<|>\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn associated_struct_const() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+            r\"\n+            use test_mod::TestStruct;\n+\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn associated_trait_function() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::test_function<|>\n+            }\n+            \",\n+            r\"\n+            use test_mod::TestTrait;\n+\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::test_function<|>\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_trait_for_function() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub trait TestTrait2 {\n+                    fn test_function();\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+                impl TestTrait2 for TestEnum {\n+                    fn test_function() {}\n+                }\n+                impl TestTrait for TestEnum {\n+                    fn test_function() {}\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                test_mod::TestEnum::test_function<|>;\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_trait_const() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+            r\"\n+            use test_mod::TestTrait;\n+\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_trait_for_const() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub trait TestTrait2 {\n+                    const TEST_CONST: f64;\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+                impl TestTrait2 for TestEnum {\n+                    const TEST_CONST: f64 = 42.0;\n+                }\n+                impl TestTrait for TestEnum {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                test_mod::TestEnum::TEST_CONST<|>;\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn trait_method() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            \",\n+            r\"\n+            use test_mod::TestTrait;\n+\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_trait_for_method() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub trait TestTrait2 {\n+                    fn test_method(&self);\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+                impl TestTrait2 for TestEnum {\n+                    fn test_method(&self) {}\n+                }\n+                impl TestTrait for TestEnum {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                let one = test_mod::TestEnum::One;\n+                one.test<|>_method();\n+            }\n+            \",\n+        )\n+    }\n }"}, {"sha": "a56b8ab0426110e43fda4071115f05c3070396a5", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f897d1c6eaa7f0251bb47a5d2d1894cd8e82d54/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f897d1c6eaa7f0251bb47a5d2d1894cd8e82d54/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=1f897d1c6eaa7f0251bb47a5d2d1894cd8e82d54", "patch": "@@ -818,7 +818,7 @@ impl TypeParam {\n     }\n }\n \n-// FIXME: rename to `ImplBlock`\n+// FIXME: rename from `ImplBlock` to `Impl`\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ImplBlock {\n     pub(crate) id: ImplId,"}]}