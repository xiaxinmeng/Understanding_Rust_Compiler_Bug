{"sha": "3bcd4fe6fa137287df34bed19eed5851f44aa703", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiY2Q0ZmU2ZmExMzcyODdkZjM0YmVkMTllZWQ1ODUxZjQ0YWE3MDM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-02T11:37:17Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-03T13:07:35Z"}, "message": "Start on in-crate monomorphizing\n\nAdds a --monomorpize flag to rustc to turn it on. You probably don't\nwant to use it yet, since it's broken in a whole bunch of ways, but it\nsuccessfully monomorphizes simple generic functions called from within\nthe crate.\n\nIssue #1736", "tree": {"sha": "eb6acd4c1c50c6bbd7af1cf5b889bafaffac3f85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb6acd4c1c50c6bbd7af1cf5b889bafaffac3f85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bcd4fe6fa137287df34bed19eed5851f44aa703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bcd4fe6fa137287df34bed19eed5851f44aa703", "html_url": "https://github.com/rust-lang/rust/commit/3bcd4fe6fa137287df34bed19eed5851f44aa703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bcd4fe6fa137287df34bed19eed5851f44aa703/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a02f332602e504573977c3419ce0f239d954f5ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/a02f332602e504573977c3419ce0f239d954f5ec", "html_url": "https://github.com/rust-lang/rust/commit/a02f332602e504573977c3419ce0f239d954f5ec"}], "stats": {"total": 294, "additions": 169, "deletions": 125}, "files": [{"sha": "f03e8d2c16c914407f53de5562b7a2332f71fc0d", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -357,6 +357,7 @@ fn build_session_options(match: getopts::match,\n     if opt_present(match, \"no-lint-ctypes\") {\n         lint_opts += [(lint::ctypes, false)];\n     }\n+    let monomorphize = opt_present(match, \"monomorphize\");\n \n     let output_type =\n         if parse_only || no_trans {\n@@ -434,6 +435,7 @@ fn build_session_options(match: getopts::match,\n           parse_only: parse_only,\n           no_trans: no_trans,\n           no_asm_comments: no_asm_comments,\n+          monomorphize: monomorphize,\n           warn_unused_imports: warn_unused_imports};\n     ret sopts;\n }\n@@ -493,6 +495,7 @@ fn opts() -> [getopts::opt] {\n          optflag(\"time-passes\"), optflag(\"time-llvm-passes\"),\n          optflag(\"no-verify\"),\n          optflag(\"no-lint-ctypes\"),\n+         optflag(\"monomorphize\"),\n          optmulti(\"cfg\"), optflag(\"test\"),\n          optflag(\"lib\"), optflag(\"bin\"), optflag(\"static\"), optflag(\"gc\"),\n          optflag(\"no-asm-comments\"),"}, {"sha": "36991e4e108d30942af7794b0eb74f20b6e91801", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -47,6 +47,7 @@ type options =\n      parse_only: bool,\n      no_trans: bool,\n      no_asm_comments: bool,\n+     monomorphize: bool,\n      warn_unused_imports: bool};\n \n type crate_metadata = {name: str, data: [u8]};"}, {"sha": "b2a5605a7a93f061c32f355b97a1982fbf2a1f8f", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -668,7 +668,7 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n      });\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n                                        local.span.lo);\n-    let ty = base::node_id_type(cx, local.node.id);\n+    let ty = node_id_type(bcx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty);\n     let filemd = create_file(cx, loc.filename);\n     let context = alt bcx.parent {\n@@ -717,7 +717,7 @@ fn create_arg(bcx: @block_ctxt, arg: ast::arg, sp: span)\n     };*/\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n                                        sp.lo);\n-    let ty = base::node_id_type(cx, arg.id);\n+    let ty = node_id_type(bcx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty);\n     let filemd = create_file(cx, loc.filename);\n     let context = create_function(bcx.fcx);"}, {"sha": "310717937e9ca5bf0cdb405b6c5e3dd6bdc14d87", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -692,7 +692,7 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms_: [ast::arm],\n     }\n \n     let exit_map = [];\n-    let t = base::node_id_type(cx.fcx.ccx, expr.id);\n+    let t = node_id_type(cx, expr.id);\n     let vr = base::spill_if_immediate(er.bcx, er.val, t);\n     compile_submatch(vr.bcx, match, [vr.val],\n                      bind mk_fail(alt_cx, expr.span, fail_cx), exit_map);\n@@ -725,7 +725,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n     alt normalize_pat(bcx_tcx(bcx), pat).node {\n       ast::pat_ident(_,inner) {\n         if make_copy || ccx.copy_map.contains_key(pat.id) {\n-            let ty = ty::node_id_to_type(ccx.tcx, pat.id);\n+            let ty = node_id_type(bcx, pat.id);\n             // FIXME: Could constrain pat_bind to make this\n             // check unnecessary.\n             check (type_has_static_size(ccx, ty));\n@@ -753,7 +753,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_rec(fields, _) {\n-        let rec_ty = ty::node_id_to_type(ccx.tcx, pat.id);\n+        let rec_ty = node_id_type(bcx, pat.id);\n         let rec_fields = ty::get_fields(ccx.tcx, rec_ty);\n         for f: ast::field_pat in fields {\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n@@ -764,7 +764,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_tup(elems) {\n-        let tup_ty = ty::node_id_to_type(ccx.tcx, pat.id);\n+        let tup_ty = node_id_type(bcx, pat.id);\n         let i = 0u;\n         for elem in elems {\n             // how to get rid of this check?"}, {"sha": "c8d5815f8dc40882338f7d88efbea12e77c05da7", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 110, "deletions": 93, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -112,9 +112,6 @@ fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n // Given a function type and a count of ty params, construct an llvm type\n fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t,\n                       param_bounds: [ty::param_bounds]) -> TypeRef {\n-    // FIXME: Check should be unnecessary, b/c it's implied\n-    // by returns_non_ty_var(t). Make that a postcondition\n-    // (see Issue #586)\n     let ret_ty = ty::ty_fn_ret(cx.tcx, fty);\n     ret type_of_fn(cx, ty::ty_fn_args(cx.tcx, fty),\n                    ret_ty, param_bounds);\n@@ -371,13 +368,6 @@ fn umin(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n     ret Select(cx, cond, a, b);\n }\n \n-fn align_to(cx: @block_ctxt, off: ValueRef, align: ValueRef) -> ValueRef {\n-    let mask = Sub(cx, align, C_int(bcx_ccx(cx), 1));\n-    let bumped = Add(cx, off, mask);\n-    ret And(cx, bumped, Not(cx, mask));\n-}\n-\n-\n // Returns the real size of the given type for the current target.\n fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n@@ -2008,12 +1998,6 @@ fn trans_lit(cx: @block_ctxt, lit: ast::lit, dest: dest) -> @block_ctxt {\n     }\n }\n \n-\n-// Converts an annotation to a type\n-fn node_id_type(cx: @crate_ctxt, id: ast::node_id) -> ty::t {\n-    ret ty::node_id_to_type(cx.tcx, id);\n-}\n-\n fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n                un_expr: @ast::expr, dest: dest) -> @block_ctxt {\n     // Check for user-defined method call\n@@ -2029,7 +2013,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n     }\n \n     if dest == ignore { ret trans_expr(bcx, e, ignore); }\n-    let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n+    let e_ty = expr_ty(bcx, e);\n     alt op {\n       ast::not {\n         let {bcx, val} = trans_temp_expr(bcx, e);\n@@ -2155,15 +2139,15 @@ fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n fn trans_assign_op(bcx: @block_ctxt, ex: @ast::expr, op: ast::binop,\n                    dst: @ast::expr, src: @ast::expr) -> @block_ctxt {\n     let tcx = bcx_tcx(bcx);\n-    let t = ty::expr_ty(tcx, src);\n+    let t = expr_ty(bcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n     assert (lhs_res.kind == owned);\n \n     // A user-defined operator method\n     alt bcx_ccx(bcx).method_map.find(ex.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n-        let fty = ty::node_id_to_type(bcx_tcx(bcx), callee_id);\n+        let fty = ty::node_id_to_type(tcx, callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n             // FIXME provide the already-computed address, not the expr\n             impl::trans_method_callee(bcx, callee_id, dst, origin)\n@@ -2309,8 +2293,8 @@ fn trans_binary(bcx: @block_ctxt, op: ast::binop, lhs: @ast::expr,\n         let lhs_res = trans_temp_expr(bcx, lhs);\n         let rhs_res = trans_temp_expr(lhs_res.bcx, rhs);\n         ret trans_eager_binop(rhs_res.bcx, op, lhs_res.val,\n-                              ty::expr_ty(bcx_tcx(bcx), lhs), rhs_res.val,\n-                              ty::expr_ty(bcx_tcx(bcx), rhs), dest);\n+                              expr_ty(bcx, lhs), rhs_res.val,\n+                              expr_ty(bcx, rhs), dest);\n       }\n     }\n }\n@@ -2438,7 +2422,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n     }\n     let ccx = bcx_ccx(cx);\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n-    let seq_ty = ty::expr_ty(bcx_tcx(cx), seq);\n+    let seq_ty = expr_ty(cx, seq);\n     let {bcx: bcx, val: seq} = trans_temp_expr(cx, seq);\n     let seq = PointerCast(bcx, seq, T_ptr(ccx.opaque_vec_type));\n     let fill = tvec::get_fill(bcx, seq);\n@@ -2538,10 +2522,52 @@ fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n                          type_of_ty_param_bounds_and_ty(ccx, tpt));\n }\n \n+fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n+                  dicts: option<typeck::dict_res>) -> ValueRef {\n+    let hash_id = @{def: fn_id, substs: substs, dicts: alt dicts {\n+      some(os) { vec::map(*os, {|o| impl::dict_id(ccx.tcx, o)}) }\n+      none { [] }\n+    }};\n+    alt ccx.monomorphized.find(hash_id) {\n+      some(val) { ret val; }\n+      none {}\n+    }\n+    let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n+    let mono_ty = ty::substitute_type_params(ccx.tcx, substs, tpt.ty);\n+    let (item, pt) = alt ccx.tcx.items.get(fn_id.node) {\n+      ast_map::node_item(i, p) { (i, p) } _ { fail; }\n+    };\n+    let pt = *pt + [path_name(item.ident)];\n+    let result = alt item.node {\n+      ast::item_fn(decl, _, body) {\n+        let llfty = type_of_fn_from_ty(ccx, mono_ty, []);\n+        let s = mangle_exported_name(ccx, pt, mono_ty);\n+        let lldecl = decl_cdecl_fn(ccx.llmod, s, llfty);\n+        trans_fn(ccx, pt, decl, body, lldecl, no_self, [],\n+                 some(substs), fn_id.node);\n+        lldecl\n+      }\n+      _ { fail \"FIXME[mono] handle other constructs\"; }\n+    };\n+    ccx.monomorphized.insert(hash_id, result);\n+    result\n+}\n+\n fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n     -> lval_maybe_callee {\n     let ccx = bcx_ccx(bcx);\n+    let tys = ty::node_id_to_type_params(ccx.tcx, id);\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n+    if ccx.sess.opts.monomorphize && vec::len(tys) > 0u &&\n+       fn_id.crate == ast::local_crate &&\n+       !vec::any(tys, {|t| ty::type_contains_params(ccx.tcx, t)}) &&\n+       vec::all(*tpt.bounds, {|bs| vec::all(*bs, {|b|\n+           alt b { ty::bound_iface(_) { false } _ { true } }\n+       })}) {\n+        let dicts = ccx.dict_map.find(id);\n+        ret {bcx: bcx, val: monomorphic_fn(ccx, fn_id, tys, dicts),\n+             kind: owned, env: null_env, generic: none};\n+    }\n     let val = if fn_id.crate == ast::local_crate {\n         // Internal reference.\n         assert (ccx.item_ids.contains_key(fn_id.node));\n@@ -2550,9 +2576,8 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n         // External reference.\n         trans_external_path(bcx, fn_id, tpt)\n     };\n-    let tys = ty::node_id_to_type_params(ccx.tcx, id);\n     let gen = none, bcx = bcx;\n-    if vec::len(tys) != 0u {\n+    if vec::len(tys) > 0u {\n         let tydescs = [], tis = [];\n         for t in tys {\n             // TODO: Doesn't always escape.\n@@ -2640,7 +2665,7 @@ fn trans_var(cx: @block_ctxt, def: ast::def, id: ast::node_id)\n             ret lval_static_fn(cx, vid, id);\n         } else {\n             // Nullary variant.\n-            let enum_ty = node_id_type(ccx, id);\n+            let enum_ty = ty::node_id_to_type(ccx.tcx, id);\n             let alloc_result = alloc_ty(cx, enum_ty);\n             let llenumblob = alloc_result.val;\n             let llenumty = type_of_enum(ccx, tid, enum_ty);\n@@ -2673,7 +2698,7 @@ fn trans_var(cx: @block_ctxt, def: ast::def, id: ast::node_id)\n fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n                    field: ast::ident) -> lval_result {\n     let {bcx, val} = trans_temp_expr(bcx, base);\n-    let {bcx, val, ty} = autoderef(bcx, val, ty::expr_ty(bcx_tcx(bcx), base));\n+    let {bcx, val, ty} = autoderef(bcx, val, expr_ty(bcx, base));\n     let fields = alt ty::struct(bcx_tcx(bcx), ty) {\n             ty::ty_rec(fs) { fs }\n             // Constraint?\n@@ -2689,7 +2714,7 @@ fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n \n fn trans_index(cx: @block_ctxt, ex: @ast::expr, base: @ast::expr,\n                idx: @ast::expr) -> lval_result {\n-    let base_ty = ty::expr_ty(bcx_tcx(cx), base);\n+    let base_ty = expr_ty(cx, base);\n     let exp = trans_temp_expr(cx, base);\n     let lv = autoderef(exp.bcx, exp.val, base_ty);\n     let ix = trans_temp_expr(lv.bcx, idx);\n@@ -2707,7 +2732,7 @@ fn trans_index(cx: @block_ctxt, ex: @ast::expr, base: @ast::expr,\n         ix_val = Trunc(bcx, ix.val, ccx.int_type);\n     } else { ix_val = ix.val; }\n \n-    let unit_ty = node_id_type(bcx_ccx(cx), ex.id);\n+    let unit_ty = node_id_type(cx, ex.id);\n     let unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n     maybe_name_value(bcx_ccx(cx), unit_sz.val, \"unit_sz\");\n@@ -2771,7 +2796,7 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n     alt e.node {\n       ast::expr_path(_) {\n         let v = trans_path(cx, e.id);\n-        ret lval_maybe_callee_to_lval(v, ty::expr_ty(bcx_tcx(cx), e));\n+        ret lval_maybe_callee_to_lval(v, expr_ty(cx, e));\n       }\n       ast::expr_field(base, ident, _) {\n         ret trans_rec_field(cx, base, ident);\n@@ -2782,7 +2807,7 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n       ast::expr_unary(ast::deref, base) {\n         let ccx = bcx_ccx(cx);\n         let sub = trans_temp_expr(cx, base);\n-        let t = ty::expr_ty(ccx.tcx, base);\n+        let t = expr_ty(cx, base);\n         let val =\n             alt ty::struct(ccx.tcx, t) {\n               ty::ty_box(_) {\n@@ -2792,7 +2817,7 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n                 GEPi(sub.bcx, sub.val, [0, 1])\n               }\n               ty::ty_enum(_, _) {\n-                let ety = ty::expr_ty(ccx.tcx, e);\n+                let ety = expr_ty(cx, e);\n                 let ellty =\n                     if check type_has_static_size(ccx, ety) {\n                         T_ptr(type_of(ccx, ety))\n@@ -2808,12 +2833,6 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n             };\n         ret lval_owned(sub.bcx, val);\n       }\n-      // This is a by-ref returning call. Regular calls are not lval\n-      ast::expr_call(f, args, _) {\n-        let cell = empty_dest_cell();\n-        let bcx = trans_call(cx, f, args, e.id, by_val(cell));\n-        ret lval_owned(bcx, *cell);\n-      }\n       _ { bcx_ccx(cx).sess.span_bug(e.span, \"non-lval in trans_lval\"); }\n     }\n }\n@@ -2878,14 +2897,14 @@ fn float_cast(bcx: @block_ctxt, lldsttype: TypeRef, llsrctype: TypeRef,\n fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n               dest: dest) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n-    let t_out = node_id_type(ccx, id);\n-    alt ty::struct(ccx.tcx, t_out) {\n+    let t_out = node_id_type(cx, id);\n+    alt ty::struct(bcx_tcx(cx), t_out) {\n       ty::ty_iface(_, _) { ret impl::trans_cast(cx, e, id, dest); }\n       _ {}\n     }\n     let e_res = trans_temp_expr(cx, e);\n     let ll_t_in = val_ty(e_res.val);\n-    let t_in = ty::expr_ty(ccx.tcx, e);\n+    let t_in = expr_ty(cx, e);\n     // Check should be avoidable because it's a cast.\n     // FIXME: Constrain types so as to avoid this check.\n     check (type_has_static_size(ccx, t_out));\n@@ -2957,7 +2976,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n                   &to_revoke: [{v: ValueRef, t: ty::t}], e: @ast::expr) ->\n    result {\n     let ccx = bcx_ccx(cx);\n-    let e_ty = ty::expr_ty(ccx.tcx, e);\n+    let e_ty = expr_ty(cx, e);\n     let is_bot = ty::type_is_bot(ccx.tcx, e_ty);\n     let lv = trans_temp_lval(cx, e);\n     let bcx = lv.bcx;\n@@ -3134,7 +3153,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n               args: [@ast::expr], id: ast::node_id, dest: dest)\n     -> @block_ctxt {\n-    trans_call_inner(in_cx, ty::expr_ty(bcx_tcx(in_cx), f),\n+    trans_call_inner(in_cx, expr_ty(in_cx, f),\n                      {|cx| trans_callee(cx, f)}, args, id, dest)\n }\n \n@@ -3329,7 +3348,7 @@ fn trans_landing_pad(bcx: @block_ctxt,\n \n fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n-    let t = node_id_type(bcx.fcx.ccx, id);\n+    let t = node_id_type(bcx, id);\n     let bcx = bcx;\n     let addr = alt dest {\n       ignore {\n@@ -3342,7 +3361,7 @@ fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n     let temp_cleanups = [], i = 0;\n     for e in elts {\n         let dst = GEP_tup_like_1(bcx, t, addr, [0, i]);\n-        let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n+        let e_ty = expr_ty(bcx, e);\n         bcx = trans_expr_save_in(dst.bcx, e, dst.val);\n         add_clean_temp_mem(bcx, dst.val, e_ty);\n         temp_cleanups += [dst.val];\n@@ -3355,7 +3374,7 @@ fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n              base: option<@ast::expr>, id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n-    let t = node_id_type(bcx_ccx(bcx), id);\n+    let t = node_id_type(bcx, id);\n     let bcx = bcx;\n     let addr = alt dest {\n       ignore {\n@@ -3409,7 +3428,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n // that nil or bot expressions get ignore rather than save_in as destination.\n fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n     -> @block_ctxt {\n-    let tcx = bcx_tcx(bcx), t = ty::expr_ty(tcx, e);\n+    let tcx = bcx_tcx(bcx), t = expr_ty(bcx, e);\n     let do_ignore = ty::type_is_bot(tcx, t) || ty::type_is_nil(tcx, t);\n     ret trans_expr(bcx, e, if do_ignore { ignore } else { save_in(dest) });\n }\n@@ -3425,7 +3444,7 @@ fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n         ret trans_lval(bcx, e);\n     } else {\n         let tcx = bcx_tcx(bcx);\n-        let ty = ty::expr_ty(tcx, e);\n+        let ty = expr_ty(bcx, e);\n         if ty::type_is_nil(tcx, ty) || ty::type_is_bot(tcx, ty) {\n             bcx = trans_expr(bcx, e, ignore);\n             ret {bcx: bcx, val: C_nil(), kind: temporary};\n@@ -3448,7 +3467,7 @@ fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n     let {bcx, val, kind} = trans_temp_lval(bcx, e);\n     if kind == owned {\n-        val = load_if_immediate(bcx, val, ty::expr_ty(bcx_tcx(bcx), e));\n+        val = load_if_immediate(bcx, val, expr_ty(bcx, e));\n     }\n     ret {bcx: bcx, val: val};\n }\n@@ -3503,10 +3522,10 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n             bcx, proto, decl, body, e.span, e.id, *cap_clause, dest);\n       }\n       ast::expr_fn_block(decl, body) {\n-        alt ty::struct(tcx, ty::expr_ty(tcx, e)) {\n+        alt ty::struct(tcx, expr_ty(bcx, e)) {\n           ty::ty_fn({proto, _}) {\n             #debug(\"translating fn_block %s with type %s\",\n-                   expr_to_str(e), ty_to_str(tcx, ty::expr_ty(tcx, e)));\n+                   expr_to_str(e), ty_to_str(tcx, expr_ty(bcx, e)));\n             let cap_clause = { copies: [], moves: [] };\n             ret closure::trans_expr_fn(\n                 bcx, proto, decl, body, e.span, e.id, cap_clause, dest);\n@@ -3618,7 +3637,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n         assert kind == owned;\n         ret store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n-                            ty::expr_ty(bcx_tcx(bcx), src),\n+                            expr_ty(bcx, src),\n                             bcx_ccx(bcx).last_uses.contains_key(src.id));\n       }\n       ast::expr_move(dst, src) {\n@@ -3628,14 +3647,14 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n         assert kind == owned;\n         ret move_val(bcx, DROP_EXISTING, addr, src_r,\n-                     ty::expr_ty(bcx_tcx(bcx), src));\n+                     expr_ty(bcx, src));\n       }\n       ast::expr_swap(dst, src) {\n         assert dest == ignore;\n         let lhs_res = trans_lval(bcx, dst);\n         assert lhs_res.kind == owned;\n         let rhs_res = trans_lval(lhs_res.bcx, src);\n-        let t = ty::expr_ty(tcx, src);\n+        let t = expr_ty(bcx, src);\n         let {bcx: bcx, val: tmp_alloc} = alloc_ty(rhs_res.bcx, t);\n         // Swap through a temporary.\n         bcx = move_val(bcx, INIT, tmp_alloc, lhs_res, t);\n@@ -3656,7 +3675,7 @@ fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     let lv = trans_lval(bcx, e), ccx = bcx_ccx(bcx);\n     let {bcx, val, kind} = lv;\n     let last_use = kind == owned && ccx.last_uses.contains_key(e.id);\n-    let ty = ty::expr_ty(ccx.tcx, e);\n+    let ty = expr_ty(bcx, e);\n     alt dest {\n       by_val(cell) {\n         if kind == temporary {\n@@ -3719,7 +3738,7 @@ fn load_if_immediate(cx: @block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n \n fn trans_log(lvl: @ast::expr, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n     let ccx = bcx_ccx(cx), tcx = ccx.tcx;\n-    if ty::type_is_bot(tcx, ty::expr_ty(tcx, lvl)) {\n+    if ty::type_is_bot(tcx, expr_ty(cx, lvl)) {\n        ret trans_expr(cx, lvl, ignore);\n     }\n \n@@ -3754,7 +3773,7 @@ fn trans_log(lvl: @ast::expr, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n \n     CondBr(level_res.bcx, test, log_cx.llbb, after_cx.llbb);\n     let sub = trans_temp_expr(log_cx, e);\n-    let e_ty = ty::expr_ty(bcx_tcx(cx), e);\n+    let e_ty = expr_ty(cx, e);\n     let log_bcx = sub.bcx;\n \n     let ti = none::<@tydesc_info>;\n@@ -3793,7 +3812,7 @@ fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option<span>,\n       some(expr) {\n         let tcx = bcx_tcx(bcx);\n         let expr_res = trans_temp_expr(bcx, expr);\n-        let e_ty = ty::expr_ty(tcx, expr);\n+        let e_ty = expr_ty(bcx, expr);\n         bcx = expr_res.bcx;\n \n         if ty::type_is_str(tcx, e_ty) {\n@@ -3916,7 +3935,7 @@ fn trans_be(cx: @block_ctxt, e: @ast::expr) : ast_util::is_call_expr(e) ->\n }\n \n fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n-    let ty = node_id_type(bcx_ccx(bcx), local.node.id);\n+    let ty = node_id_type(bcx, local.node.id);\n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       some(local_mem(v)) { v }\n       some(_) { bcx_tcx(bcx).sess.span_bug(local.span,\n@@ -4214,7 +4233,7 @@ fn alloc_ty(cx: @block_ctxt, t: ty::t) -> result {\n }\n \n fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n-    let t = node_id_type(bcx_ccx(cx), local.node.id);\n+    let t = node_id_type(cx, local.node.id);\n     let p = normalize_pat(bcx_tcx(cx), local.node.pat);\n     let is_simple = alt p.node {\n       ast::pat_ident(_, none) { true } _ { false }\n@@ -4258,7 +4277,7 @@ fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n     }\n     alt b.node.expr {\n       some(e) {\n-        let bt = ty::type_is_bot(bcx_tcx(bcx), ty::expr_ty(bcx_tcx(bcx), e));\n+        let bt = ty::type_is_bot(bcx_tcx(bcx), expr_ty(bcx, e));\n         debuginfo::update_source_pos(bcx, e.span);\n         bcx = trans_expr(bcx, e, if bt { ignore } else { dest });\n       }\n@@ -4302,6 +4321,7 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - trans_args\n fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n                     llfndecl: ValueRef, id: ast::node_id,\n+                    param_substs: option<[ty::t]>,\n                     sp: option<span>) -> @fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     ret @{llfn: llfndecl,\n@@ -4321,14 +4341,15 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n           mutable lltyparams: [],\n           derived_tydescs: ty::new_ty_hash(),\n           id: id,\n+          param_substs: param_substs,\n           span: sp,\n           path: path,\n           ccx: ccx};\n }\n \n fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n                sp: option<span>) -> @fn_ctxt {\n-    ret new_fn_ctxt_w_id(ccx, path, llfndecl, -1, sp);\n+    ret new_fn_ctxt_w_id(ccx, path, llfndecl, -1, none, sp);\n }\n \n // NB: must keep 4 fns in sync:\n@@ -4457,18 +4478,20 @@ enum self_arg { impl_self(ty::t), no_self, }\n fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg, ty_params: [ast::ty_param],\n+                 param_substs: option<[ty::t]>,\n                  id: ast::node_id, maybe_load_env: fn(@fn_ctxt)) {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n-    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, some(body.span));\n+    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, param_substs,\n+                               some(body.span));\n     create_llargs_for_fn_args(fcx, ty_self, decl.inputs, ty_params);\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n     let bcx = new_top_block_ctxt(fcx, some(body.span));\n     let lltop = bcx.llbb;\n-    let block_ty = node_id_type(ccx, body.node.id);\n+    let block_ty = node_id_type(bcx, body.node.id);\n \n     let arg_tys = arg_tys_of_fn(fcx.ccx, id);\n     bcx = copy_args_to_allocas(fcx, bcx, decl.inputs, arg_tys);\n@@ -4487,8 +4510,6 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n         bcx = trans_block_dps(bcx, body, save_in(fcx.llretptr));\n     }\n \n-    // FIXME: until LLVM has a unit type, we are moving around\n-    // C_nil values rather than their void type.\n     if !bcx.unreachable { build_return(bcx); }\n     // Insert the mandatory first few basic blocks before lltop.\n     finish_fn(fcx, lltop);\n@@ -4498,19 +4519,17 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n // function.\n fn trans_fn(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n             body: ast::blk, llfndecl: ValueRef, ty_self: self_arg,\n-            ty_params: [ast::ty_param], id: ast::node_id) {\n+            ty_params: [ast::ty_param], param_substs: option<[ty::t]>,\n+            id: ast::node_id) {\n     let do_time = ccx.sess.opts.stats;\n-    let start = if do_time {\n-                    time::get_time()\n-                } else {\n-                    {sec: 0u32, usec: 0u32}\n-                };\n-    let fcx = option::none;\n-    trans_closure(ccx, path, decl, body, llfndecl, ty_self, ty_params, id,\n-                  {|new_fcx| fcx = option::some(new_fcx);});\n-    if ccx.sess.opts.extra_debuginfo {\n-        debuginfo::create_function(option::get(fcx));\n-    }\n+    let start = if do_time { time::get_time() }\n+                else { {sec: 0u32, usec: 0u32} };\n+    trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n+                  ty_params, param_substs, id, {|fcx|\n+        if ccx.sess.opts.extra_debuginfo {\n+            debuginfo::create_function(fcx);\n+        }\n+    });\n     if do_time {\n         let end = time::get_time();\n         log_fn_time(ccx, path_str(path), start, end);\n@@ -4521,7 +4540,7 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n                   ctor_id: ast::node_id, ty_params: [ast::ty_param]) {\n     // Create a function for the constructor\n     let llctor_decl = ccx.item_ids.get(ctor_id);\n-    let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id, none);\n+    let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id, none, none);\n     let ret_t = ty::ret_ty_of_fn(ccx.tcx, ctor_id);\n     create_llargs_for_fn_args(fcx, no_self, dtor.inputs, ty_params);\n     let bcx = new_top_block_ctxt(fcx, none);\n@@ -4579,7 +4598,8 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n                             \"unbound variant id in trans_enum_variant\");\n       }\n     }\n-    let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id, none);\n+    let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id, none,\n+                               none);\n     create_llargs_for_fn_args(fcx, no_self, fn_args, ty_params);\n     let ty_param_substs = [], i = 0u;\n     for tp: ast::ty_param in ty_params {\n@@ -4639,7 +4659,7 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         let te2 = trans_const_expr(cx, e2);\n         /* Neither type is bottom, and we expect them to be unified already,\n          * so the following is safe. */\n-        let ty = ty::expr_ty(ccx_tcx(cx), e1);\n+        let ty = ty::expr_ty(cx.tcx, e1);\n         let is_float = ty::type_is_fp(ccx_tcx(cx), ty);\n         let signed = ty::type_is_signed(ccx_tcx(cx), ty);\n         ret alt b {\n@@ -4683,7 +4703,7 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n       }\n       ast::expr_unary(u, e) {\n         let te = trans_const_expr(cx, e);\n-        let ty = ty::expr_ty(ccx_tcx(cx), e);\n+        let ty = ty::expr_ty(cx.tcx, e);\n         let is_float = ty::type_is_fp(ccx_tcx(cx), ty);\n         ret alt u {\n           ast::box(_)  |\n@@ -4904,7 +4924,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         alt ccx.item_ids.find(item.id) {\n           some(llfndecl) {\n             trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n-                     llfndecl, no_self, tps, item.id);\n+                     llfndecl, no_self, tps, none, item.id);\n           }\n           _ {\n             ccx.sess.span_fatal(item.span,\n@@ -4922,7 +4942,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         alt ccx.item_ids.find(item.id) {\n           some(lldtor_decl) {\n             trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n-                     lldtor_decl, no_self, tps, dtor_id);\n+                     lldtor_decl, no_self, tps, none, dtor_id);\n           }\n           _ {\n             ccx.sess.span_fatal(item.span, \"unbound dtor in trans_item\");\n@@ -4972,8 +4992,7 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n fn register_fn(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n                ty_params: [ast::ty_param], node_id: ast::node_id) {\n     // FIXME: pull this out\n-    let t = node_id_type(ccx, node_id);\n-    check returns_non_ty_var(ccx, t);\n+    let t = ty::node_id_to_type(ccx.tcx, node_id);\n     register_fn_full(ccx, sp, path, flav, ty_params, node_id, t);\n }\n \n@@ -4983,8 +5002,7 @@ fn param_bounds(ccx: @crate_ctxt, tp: ast::ty_param) -> ty::param_bounds {\n \n fn register_fn_full(ccx: @crate_ctxt, sp: span, path: path, _flav: str,\n                     tps: [ast::ty_param], node_id: ast::node_id,\n-                    node_type: ty::t)\n-    : returns_non_ty_var(ccx, node_type) {\n+                    node_type: ty::t) {\n     let llfty = type_of_fn_from_ty(ccx, node_type,\n                                    vec::map(tps, {|p| param_bounds(ccx, p)}));\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n@@ -5147,7 +5165,7 @@ fn collect_native_item(ccx: @crate_ctxt,\n     alt i.node {\n       ast::native_item_fn(_, tps) {\n         let id = i.id;\n-        let node_type = node_id_type(ccx, id);\n+        let node_type = ty::node_id_to_type(ccx.tcx, id);\n         let fn_abi =\n             alt attr::get_meta_item_value_str_by_name(i.attrs, \"abi\") {\n             option::none {\n@@ -5203,9 +5221,8 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option<ast::native_abi>,\n     let my_path = item_path(ccx, i);\n     alt i.node {\n       ast::item_const(_, _) {\n-        let typ = node_id_type(ccx, i.id);\n-        let s = mangle_exported_name(ccx, my_path,\n-                                     node_id_type(ccx, i.id));\n+        let typ = ty::node_id_to_type(ccx.tcx, i.id);\n+        let s = mangle_exported_name(ccx, my_path, typ);\n         // FIXME: Could follow from a constraint on types of const\n         // items\n         let g = str::as_buf(s, {|buf|\n@@ -5240,9 +5257,8 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option<ast::native_abi>,\n         // the dtor_id. This is a bit counter-intuitive, but simplifies\n         // ty_res, which would have to carry around two def_ids otherwise\n         // -- one to identify the type, and one to find the dtor symbol.\n-        let t = node_id_type(ccx, dtor_id);\n+        let t = ty::node_id_to_type(ccx.tcx, dtor_id);\n         // FIXME: how to get rid of this check?\n-        check returns_non_ty_var(ccx, t);\n         register_fn_full(ccx, i.span, my_path + [path_name(\"dtor\")],\n                          \"res_dtor\", tps, i.id, t);\n       }\n@@ -5534,6 +5550,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           consts: new_int_hash::<ValueRef>(),\n           tydescs: ty::new_ty_hash(),\n           dicts: map::mk_hashmap(hash_dict_id, {|a, b| a == b}),\n+          monomorphized: map::mk_hashmap(hash_mono_id, {|a, b| a == b}),\n           module_data: new_str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),\n           names: new_namegen(),"}, {"sha": "43d8c675b22c56118596f1cecbb5e2dcb06b868f", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -89,7 +89,7 @@ import ast_map::{path, path_mod, path_name};\n \n enum environment_value {\n     // Evaluate expr and store result in env (used for bind).\n-    env_expr(@ast::expr),\n+    env_expr(@ast::expr, ty::t),\n \n     // Copy the value from this llvm ValueRef into the environment.\n     env_copy(ValueRef, ty::t, lval_kind),\n@@ -103,7 +103,7 @@ enum environment_value {\n \n fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> str {\n     alt ev {\n-      env_expr(ex) { expr_to_str(ex) }\n+      env_expr(ex, _) { expr_to_str(ex) }\n       env_copy(v, t, lk) { #fmt(\"copy(%s,%s)\", val_str(ccx.tn, v),\n                                 ty_to_str(ccx.tcx, t)) }\n       env_move(v, t, lk) { #fmt(\"move(%s,%s)\", val_str(ccx.tn, v),\n@@ -151,7 +151,7 @@ fn mk_closure_tys(tcx: ty::ctxt,\n             env_copy(_, t, _) { t }\n             env_move(_, t, _) { t }\n             env_ref(_, t, _) { t }\n-            env_expr(e) { ty::expr_ty(tcx, e) }\n+            env_expr(_, t) { t }\n         }];\n     }\n     let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n@@ -316,7 +316,7 @@ fn store_environment(\n         bcx = bound_data.bcx;\n         let bound_data = bound_data.val;\n         alt bv {\n-          env_expr(e) {\n+          env_expr(e, _) {\n             bcx = base::trans_expr_save_in(bcx, e, bound_data);\n             add_clean_temp_mem(bcx, bound_data, bound_tys[i]);\n             temp_cleanups += [bound_data];\n@@ -457,7 +457,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n                  dest: dest) -> @block_ctxt {\n     if dest == ignore { ret bcx; }\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n-    let fty = node_id_type(ccx, id);\n+    let fty = node_id_type(bcx, id);\n     let llfnty = type_of_fn_from_ty(ccx, fty, []);\n     let sub_path = bcx.fcx.path + [path_name(\"anon\")];\n     let s = mangle_internal_name_by_path(ccx, sub_path);\n@@ -468,7 +468,8 @@ fn trans_expr_fn(bcx: @block_ctxt,\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n         let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck);\n-        trans_closure(ccx, sub_path, decl, body, llfn, no_self, [], id, {|fcx|\n+        trans_closure(ccx, sub_path, decl, body, llfn, no_self, [],\n+                      bcx.fcx.param_substs, id, {|fcx|\n             load_environment(bcx, fcx, cdata_ty, cap_vars, ck);\n         });\n         llbox\n@@ -479,10 +480,9 @@ fn trans_expr_fn(bcx: @block_ctxt,\n       ast::proto_box { trans_closure_env(ty::ck_box) }\n       ast::proto_uniq { trans_closure_env(ty::ck_uniq) }\n       ast::proto_bare {\n-        let closure = C_null(T_opaque_box_ptr(ccx));\n-        trans_closure(ccx, sub_path, decl, body, llfn, no_self, [], id,\n-                      {|_fcx|});\n-        closure\n+        trans_closure(ccx, sub_path, decl, body, llfn, no_self, [], none,\n+                      id, {|_fcx|});\n+        C_null(T_opaque_box_ptr(ccx))\n       }\n     };\n     fill_fn_pair(bcx, get_dest_addr(dest), llfn, closure);\n@@ -492,7 +492,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n fn trans_bind(cx: @block_ctxt, f: @ast::expr, args: [option<@ast::expr>],\n               id: ast::node_id, dest: dest) -> @block_ctxt {\n     let f_res = trans_callee(cx, f);\n-    ret trans_bind_1(cx, ty::expr_ty(bcx_tcx(cx), f), f_res, args,\n+    ret trans_bind_1(cx, expr_ty(cx, f), f_res, args,\n                      ty::node_id_to_type(bcx_tcx(cx), id), dest);\n }\n \n@@ -567,7 +567,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     // Actually construct the closure\n     let {llbox, cdata_ty, bcx} = store_environment(\n         bcx, vec::map(lltydescs, {|d| {desc: d, dicts: none}}),\n-        env_vals + vec::map(bound, {|x| env_expr(x)}),\n+        env_vals + vec::map(bound, {|x| env_expr(x, expr_ty(bcx, x))}),\n         ty::ck_box);\n \n     // Make thunk"}, {"sha": "6078d874ed11204974099ad397930c7aa67ea4db", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -99,6 +99,7 @@ type crate_ctxt =\n      consts: hashmap<ast::node_id, ValueRef>,\n      tydescs: hashmap<ty::t, @tydesc_info>,\n      dicts: hashmap<dict_id, ValueRef>,\n+     monomorphized: hashmap<mono_id, ValueRef>,\n      module_data: hashmap<str, ValueRef>,\n      lltypes: hashmap<ty::t, TypeRef>,\n      names: namegen,\n@@ -235,6 +236,7 @@ type fn_ctxt =\n      mutable lltyparams: [fn_ty_param],\n      derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n      id: ast::node_id,\n+     param_substs: option<[ty::t]>,\n      span: option<span>,\n      path: path,\n      ccx: @crate_ctxt};\n@@ -917,6 +919,16 @@ fn hash_dict_id(&&dp: dict_id) -> uint {\n     h\n }\n \n+// Used to identify cached monomorphized functions\n+// FIXME[mono] don't count different boxes as different types\n+type mono_id = @{def: ast::def_id, substs: [ty::t], dicts: [dict_id]};\n+fn hash_mono_id(&&mi: mono_id) -> uint {\n+    let h = syntax::ast_util::hash_def_id(mi.def);\n+    for ty in mi.substs { h = (h << 2u) + ty; }\n+    for dict in mi.dicts { h = (h << 2u) + hash_dict_id(dict); }\n+    h\n+}\n+\n fn umax(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     ret build::Select(cx, cond, b, a);\n@@ -945,6 +957,18 @@ fn path_str(p: path) -> str {\n     r\n }\n \n+fn node_id_type(bcx: @block_ctxt, id: ast::node_id) -> ty::t {\n+    let tcx = bcx_tcx(bcx);\n+    let t = ty::node_id_to_type(tcx, id);\n+    alt bcx.fcx.param_substs {\n+      some(s) { ty::substitute_type_params(tcx, s, t) }\n+      _ { t }\n+    }\n+}\n+fn expr_ty(bcx: @block_ctxt, ex: @ast::expr) -> ty::t {\n+    node_id_type(bcx, ex.id)\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "a0bc1a582fac73f2e53ce56c9e55e57c3602976d", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -51,7 +51,7 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n           some(llfn) {\n             trans_fn(ccx, sub_path + [path_name(m.ident)], m.decl, m.body,\n                      llfn, impl_self(ty::node_id_to_type(ccx.tcx, id)),\n-                     tps + m.tps, m.id);\n+                     tps + m.tps, none, m.id);\n           }\n           _ {\n             ccx.tcx.sess.bug(\"Unbound id in trans_impl\");\n@@ -62,7 +62,7 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n \n fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n     let tz = [], tr = [];\n-    let basety = ty::expr_ty(bcx_tcx(bcx), base);\n+    let basety = expr_ty(bcx, base);\n     let {bcx, val} = trans_arg_expr(bcx, {mode: ast::by_ref, ty: basety},\n                                     T_ptr(type_of_or_i8(bcx, basety)), tz,\n                                     tr, base);\n@@ -153,7 +153,7 @@ fn trans_iface_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n     // FIXME[impl] I doubt this is alignment-safe\n     let self = PointerCast(bcx, GEPi(bcx, box_body, [0, 2]),\n                            T_opaque_cbox_ptr(bcx_ccx(bcx)));\n-    let iface_id = alt ty::struct(tcx, ty::expr_ty(tcx, base)) {\n+    let iface_id = alt ty::struct(tcx, expr_ty(bcx, base)) {\n         ty::ty_iface(did, _) { did }\n         // precondition\n         _ { bcx_tcx(bcx).sess.span_bug(base.span, \"base has non-iface type \\\n@@ -442,7 +442,7 @@ fn get_dict_ptrs(bcx: @block_ctxt, origin: typeck::dict_origin)\n fn trans_cast(bcx: @block_ctxt, val: @ast::expr, id: ast::node_id, dest: dest)\n     -> @block_ctxt {\n     let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n-    let val_ty = ty::expr_ty(tcx, val);\n+    let val_ty = expr_ty(bcx, val);\n     let {bcx, val: dict} = get_dict(bcx, ccx.dict_map.get(id)[0]);\n     let body_ty = ty::mk_tup(tcx, [ty::mk_type(tcx), ty::mk_type(tcx),\n                                    val_ty]);"}, {"sha": "a5da4c2cc75c51a3882d1eef3006bc97071c3923", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -6,7 +6,7 @@ import lib::llvm::{ValueRef, TypeRef};\n import back::abi;\n import base::{call_memmove, trans_shared_malloc, type_of_or_i8,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n-               node_id_type, new_sub_block_ctxt, do_spill_noroot,\n+               new_sub_block_ctxt, do_spill_noroot,\n                dest};\n import shape::{llsize_of, size_of};\n import build::*;\n@@ -106,7 +106,7 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n         }\n         ret bcx;\n     }\n-    let vec_ty = node_id_type(bcx_ccx(bcx), id);\n+    let vec_ty = node_id_type(bcx, id);\n     let {bcx: bcx,\n          val: vptr,\n          llunitsz: llunitsz,"}, {"sha": "ffcebe60ddbd92e1a65ade81d72fea2d4fbf29dc", "filename": "src/comp/middle/trans/uniq.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -5,7 +5,6 @@ import build::*;\n import base::{\n     trans_shared_malloc,\n     type_of_inner,\n-    node_id_type,\n     INIT,\n     trans_shared_free,\n     drop_ty,\n@@ -24,7 +23,7 @@ pure fn type_is_unique_box(bcx: @block_ctxt, ty: ty::t) -> bool {\n \n fn trans_uniq(bcx: @block_ctxt, contents: @ast::expr,\n               node_id: ast::node_id, dest: dest) -> @block_ctxt {\n-    let uniq_ty = node_id_type(bcx_ccx(bcx), node_id);\n+    let uniq_ty = node_id_type(bcx, node_id);\n     check type_is_unique_box(bcx, uniq_ty);\n     let {bcx, val: llptr} = alloc_uniq(bcx, uniq_ty);\n     add_clean_free(bcx, llptr, true);"}, {"sha": "96ef2d60bc57e0609f520f79b97edd157c58b989", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -2581,15 +2581,12 @@ fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n-    if did.crate == ast::local_crate {\n-        // The item is in this crate. The caller should have added it to the\n-        // type cache already; we simply return it.\n-\n-        ret cx.tcache.get(did);\n-    }\n     alt cx.tcache.find(did) {\n       some(tpt) { ret tpt; }\n       none {\n+        // The item is in this crate. The caller should have added it to the\n+        // type cache already\n+        assert did.crate != ast::local_crate;\n         let tyt = csearch::get_type(cx, did);\n         cx.tcache.insert(did, tyt);\n         ret tyt;"}, {"sha": "439bfd81dc73c4098454aca7fb9cd9bed7b80898", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcd4fe6fa137287df34bed19eed5851f44aa703/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=3bcd4fe6fa137287df34bed19eed5851f44aa703", "patch": "@@ -62,6 +62,8 @@ fn build_ctxt(sess: session::session, ast: @ast::crate) -> ctxt {\n     }\n }\n \n+// FIXME: this whole structure should not be duplicated here. makes it\n+// painful to add or remove options.\n fn build_session() -> session::session {\n     let sopts: @session::options = @{\n         crate_type: session::lib_crate,\n@@ -84,6 +86,7 @@ fn build_session() -> session::session {\n         parse_only: false,\n         no_trans: false,\n         no_asm_comments: false,\n+        monomorphize: false,\n         warn_unused_imports: false\n     };\n     driver::build_session(sopts, \".\", diagnostic::emit)"}]}