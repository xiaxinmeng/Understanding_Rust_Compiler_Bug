{"sha": "7faed3d87ca4f20b2da41cf5410598b48438c04b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYWVkM2Q4N2NhNGYyMGIyZGE0MWNmNTQxMDU5OGI0ODQzOGMwNGI=", "commit": {"author": {"name": "David Rajchenbach-Teller", "email": "dteller@mozilla.com", "date": "2011-10-12T08:24:43Z"}, "committer": {"name": "David Rajchenbach-Teller", "email": "dteller@mozilla.com", "date": "2011-10-12T08:56:05Z"}, "message": "[Fix] float.rs: str_to_float reimplemented", "tree": {"sha": "8f688eb3955aaa44e149ca4c58e44c89145be2fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f688eb3955aaa44e149ca4c58e44c89145be2fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7faed3d87ca4f20b2da41cf5410598b48438c04b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7faed3d87ca4f20b2da41cf5410598b48438c04b", "html_url": "https://github.com/rust-lang/rust/commit/7faed3d87ca4f20b2da41cf5410598b48438c04b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7faed3d87ca4f20b2da41cf5410598b48438c04b/comments", "author": {"login": "Yoric", "id": 10190, "node_id": "MDQ6VXNlcjEwMTkw", "avatar_url": "https://avatars.githubusercontent.com/u/10190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Yoric", "html_url": "https://github.com/Yoric", "followers_url": "https://api.github.com/users/Yoric/followers", "following_url": "https://api.github.com/users/Yoric/following{/other_user}", "gists_url": "https://api.github.com/users/Yoric/gists{/gist_id}", "starred_url": "https://api.github.com/users/Yoric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Yoric/subscriptions", "organizations_url": "https://api.github.com/users/Yoric/orgs", "repos_url": "https://api.github.com/users/Yoric/repos", "events_url": "https://api.github.com/users/Yoric/events{/privacy}", "received_events_url": "https://api.github.com/users/Yoric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Yoric", "id": 10190, "node_id": "MDQ6VXNlcjEwMTkw", "avatar_url": "https://avatars.githubusercontent.com/u/10190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Yoric", "html_url": "https://github.com/Yoric", "followers_url": "https://api.github.com/users/Yoric/followers", "following_url": "https://api.github.com/users/Yoric/following{/other_user}", "gists_url": "https://api.github.com/users/Yoric/gists{/gist_id}", "starred_url": "https://api.github.com/users/Yoric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Yoric/subscriptions", "organizations_url": "https://api.github.com/users/Yoric/orgs", "repos_url": "https://api.github.com/users/Yoric/repos", "events_url": "https://api.github.com/users/Yoric/events{/privacy}", "received_events_url": "https://api.github.com/users/Yoric/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3219c40e18c20a0dbd41b106e1b05e3696bf4c85", "url": "https://api.github.com/repos/rust-lang/rust/commits/3219c40e18c20a0dbd41b106e1b05e3696bf4c85", "html_url": "https://github.com/rust-lang/rust/commit/3219c40e18c20a0dbd41b106e1b05e3696bf4c85"}], "stats": {"total": 191, "additions": 177, "deletions": 14}, "files": [{"sha": "e961c34e66082abc0f4a1ae80b37fabcb374045c", "filename": "src/lib/float.rs", "status": "modified", "additions": 177, "deletions": 14, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/7faed3d87ca4f20b2da41cf5410598b48438c04b/src%2Flib%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7faed3d87ca4f20b2da41cf5410598b48438c04b/src%2Flib%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffloat.rs?ref=7faed3d87ca4f20b2da41cf5410598b48438c04b", "patch": "@@ -1,3 +1,7 @@\n+/**\n+ * String conversions\n+ */\n+\n fn float_to_str(num: float, digits: uint) -> str {\n     let accum = if num < 0.0 { num = -num; \"-\" } else { \"\" };\n     let trunc = num as uint;\n@@ -15,21 +19,180 @@ fn float_to_str(num: float, digits: uint) -> str {\n     ret accum;\n }\n \n+/**\n+ * Convert a string to a float\n+ *\n+ * This function accepts strings such as\n+ * * \"3.14\"\n+ * * \"+3.14\", equivalent to \"3.14\"\n+ * * \"-3.14\"\n+ * * \"2.5E10\", or equivalently, \"2.5e10\"\n+ * * \"2.5E-10\"\n+ * * \"\", or, equivalently, \".\" (understood as 0)\n+ * * \"5.\"\n+ * * \".5\", or, equivalently,  \"0.5\"\n+ *\n+ * @param num A string, possibly empty.\n+ * @return [NaN] if the string did not represent a valid number.\n+ * @return Otherwise, the floating-point number represented [num].\n+ */\n fn str_to_float(num: str) -> float {\n-    let digits = str::split(num, '.' as u8);\n-    let total = int::from_str(digits[0]) as float;\n-\n-    fn dec_val(c: char) -> int { ret (c as int) - ('0' as int); }\n-\n-    let right = digits[1];\n-    let len = str::char_len(digits[1]);\n-    let i = 1u;\n-    while (i < len) {\n-        total += dec_val(str::pop_char(right)) as float /\n-                 (int::pow(10, i) as float);\n-        i += 1u;\n-    }\n-    ret total;\n+   let pos = 0u;                  //Current byte position in the string.\n+                                  //Used to walk the string in O(n).\n+   let len = str::byte_len(num);  //Length of the string, in bytes.\n+\n+   if len == 0u { ret 0.; }\n+   let total = 0f;                //Accumulated result\n+   let c     = 'z';               //Latest char.\n+\n+   //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n+   let neg = false;               //Sign of the result\n+   alt str::char_at(num, 0u) {\n+      '-' {\n+          neg = true;\n+          pos = 1u;\n+      }\n+      '+' {\n+          pos = 1u;\n+      }\n+      _ {}\n+   }\n+\n+   //Examine the following chars until '.', 'e', 'E'\n+   while(pos < len) {\n+       let char_range = str::char_range_at(num, pos);\n+       c   = char_range.ch;\n+       pos = char_range.next;\n+       alt c {\n+          '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9'  {\n+           total = total * 10f;\n+           total += ((c as int) - ('0' as int)) as float;\n+         }\n+         _ {\n+           break;\n+         }\n+       }\n+   }\n+\n+   if c == '.' {//Examine decimal part\n+      let decimal = 1.f;\n+      while(pos < len) {\n+         let char_range = str::char_range_at(num, pos);\n+         c = char_range.ch;\n+         pos = char_range.next;\n+         alt c {\n+            '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9'  {\n+                 decimal /= 10.f;\n+                 total += (((c as int) - ('0' as int)) as float)*decimal;\n+             }\n+             _ {\n+                 break;\n+             }\n+         }\n+      }\n+   }\n+\n+   if (c == 'e') | (c == 'E') {//Examine exponent\n+      let exponent = 0u;\n+      let neg_exponent = false;\n+      if(pos < len) {\n+          let char_range = str::char_range_at(num, pos);\n+          c   = char_range.ch;\n+          alt c  {\n+             '+' {\n+                pos = char_range.next;\n+             }\n+             '-' {\n+                pos = char_range.next;\n+                neg_exponent = true;\n+             }\n+             _ {}\n+          }\n+          while(pos < len) {\n+             let char_range = str::char_range_at(num, pos);\n+             c = char_range.ch;\n+             pos = char_range.next;\n+             alt c {\n+                 '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9' {\n+                     exponent *= 10u;\n+                     exponent += ((c as uint) - ('0' as uint));\n+                 }\n+                 _ {\n+                     break;\n+                 }\n+             }\n+          }\n+          let multiplier = pow_uint_to_uint_as_float(10u, exponent);\n+              //Note: not [int::pow], otherwise, we'll quickly\n+              //end up with a nice overflow\n+          if neg_exponent {\n+             total = total / multiplier;\n+          } else {\n+             total = total * multiplier;\n+          }\n+      }\n+   }\n+\n+   if(pos < len) {\n+     ret NaN();\n+   } else {\n+     if(neg) {\n+        total *= -1f;\n+     }\n+     ret total;\n+   }\n+}\n+\n+/**\n+ * Arithmetics\n+ */\n+\n+/**\n+ * Compute the exponentiation of an integer by another integer as a float.\n+ *\n+ *\n+ * @param x The base.\n+ * @param pow The exponent.\n+ * @return [NaN] of both [x] and [pow] are [0u], otherwise [x^pow].\n+ */\n+fn pow_uint_to_uint_as_float(x: uint, pow: uint) -> float {\n+   if x == 0u {\n+      if pow == 0u {\n+        ret NaN();\n+      }\n+       ret 0.;\n+   }\n+   let my_pow     = pow;\n+   let total      = 1f;\n+   let multiplier = x as float;\n+   while (my_pow > 0u) {\n+     if my_pow % 2u == 1u {\n+       total = total * multiplier;\n+     }\n+     my_pow     /= 2u;\n+     multiplier *= multiplier;\n+   }\n+   ret total;\n+}\n+\n+\n+/**\n+ * Constants\n+ */\n+\n+//TODO: Once this is possible, replace the body of these functions\n+//by an actual constant.\n+\n+fn NaN() -> float {\n+   ret 0./0.;\n+}\n+\n+fn infinity() -> float {\n+   ret 1./0.;\n+}\n+\n+fn neg_infinity() -> float {\n+   ret -1./0.;\n }\n \n //"}]}