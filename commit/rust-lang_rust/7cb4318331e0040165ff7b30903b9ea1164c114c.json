{"sha": "7cb4318331e0040165ff7b30903b9ea1164c114c", "node_id": "C_kwDOAAsO6NoAKDdjYjQzMTgzMzFlMDA0MDE2NWZmN2IzMDkwM2I5ZWExMTY0YzExNGM", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-04-14T12:02:40Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-04-14T12:02:40Z"}, "message": "Fix explicit deref problems in closure capture", "tree": {"sha": "c69bfe4c30def8438f90dbedb6cf267a33fa889c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c69bfe4c30def8438f90dbedb6cf267a33fa889c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cb4318331e0040165ff7b30903b9ea1164c114c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cb4318331e0040165ff7b30903b9ea1164c114c", "html_url": "https://github.com/rust-lang/rust/commit/7cb4318331e0040165ff7b30903b9ea1164c114c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cb4318331e0040165ff7b30903b9ea1164c114c/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ee88db4121bfd4bad1dcfdb64922f126d93e286", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ee88db4121bfd4bad1dcfdb64922f126d93e286", "html_url": "https://github.com/rust-lang/rust/commit/1ee88db4121bfd4bad1dcfdb64922f126d93e286"}], "stats": {"total": 94, "additions": 90, "deletions": 4}, "files": [{"sha": "6927d89d63d4e01b9dd5a768fabf145f3c554f74", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7cb4318331e0040165ff7b30903b9ea1164c114c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cb4318331e0040165ff7b30903b9ea1164c114c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=7cb4318331e0040165ff7b30903b9ea1164c114c", "patch": "@@ -190,6 +190,16 @@ impl InferenceContext<'_> {\n                 }\n                 return Some(place);\n             }\n+            Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n+                if matches!(\n+                    self.expr_ty_after_adjustments(*expr).kind(Interner),\n+                    TyKind::Ref(..) | TyKind::Raw(..)\n+                ) {\n+                    let mut place = self.place_of_expr(*expr)?;\n+                    place.projections.push(ProjectionElem::Deref);\n+                    return Some(place);\n+                }\n+            }\n             _ => (),\n         }\n         None\n@@ -371,7 +381,12 @@ impl InferenceContext<'_> {\n             }\n             Expr::Field { expr, name: _ } => self.select_from_expr(*expr),\n             Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n-                if let Some((f, _)) = self.result.method_resolution(tgt_expr) {\n+                if matches!(\n+                    self.expr_ty_after_adjustments(*expr).kind(Interner),\n+                    TyKind::Ref(..) | TyKind::Raw(..)\n+                ) {\n+                    self.select_from_expr(*expr);\n+                } else if let Some((f, _)) = self.result.method_resolution(tgt_expr) {\n                     let mutability = 'b: {\n                         if let Some(deref_trait) =\n                             self.resolve_lang_item(LangItem::DerefMut).and_then(|x| x.as_trait())\n@@ -461,10 +476,20 @@ impl InferenceContext<'_> {\n         }\n     }\n \n-    fn expr_ty(&mut self, expr: ExprId) -> Ty {\n+    fn expr_ty(&self, expr: ExprId) -> Ty {\n         self.result[expr].clone()\n     }\n \n+    fn expr_ty_after_adjustments(&self, e: ExprId) -> Ty {\n+        let mut ty = None;\n+        if let Some(x) = self.result.expr_adjustments.get(&e) {\n+            if let Some(x) = x.last() {\n+                ty = Some(x.target.clone());\n+            }\n+        }\n+        ty.unwrap_or_else(|| self.expr_ty(e))\n+    }\n+\n     fn is_upvar(&self, place: &HirPlace) -> bool {\n         let b = &self.body[place.local];\n         if let Some(c) = self.current_closure {\n@@ -701,7 +726,9 @@ impl InferenceContext<'_> {\n         };\n         self.consume_expr(*body);\n         for item in &self.current_captures {\n-            if matches!(item.kind, CaptureKind::ByRef(BorrowKind::Mut { .. })) {\n+            if matches!(item.kind, CaptureKind::ByRef(BorrowKind::Mut { .. }))\n+                && !item.place.projections.contains(&ProjectionElem::Deref)\n+            {\n                 // FIXME: remove the `mutated_bindings_in_closure` completely and add proper fake reads in\n                 // MIR. I didn't do that due duplicate diagnostics.\n                 self.result.mutated_bindings_in_closure.insert(item.place.local);"}, {"sha": "0db4edeb698165f026b59d3dcc27dff221a2e2db", "filename": "crates/hir-ty/src/layout/tests/closure.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7cb4318331e0040165ff7b30903b9ea1164c114c/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cb4318331e0040165ff7b30903b9ea1164c114c/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs?ref=7cb4318331e0040165ff7b30903b9ea1164c114c", "patch": "@@ -40,6 +40,15 @@ fn ref_simple() {\n             y\n         }\n     }\n+    size_and_align_expr! {\n+        minicore: copy, deref_mut;\n+        stmts: [\n+            let y: &mut i32 = &mut 5;\n+        ]\n+        |x: i32| {\n+            *y += x;\n+        }\n+    }\n     size_and_align_expr! {\n         minicore: copy;\n         stmts: [\n@@ -50,6 +59,16 @@ fn ref_simple() {\n             x\n         }\n     }\n+    size_and_align_expr! {\n+        minicore: copy, deref_mut;\n+        stmts: [\n+            struct X(i32, i64);\n+            let x: &mut X = &mut X(2, 6);\n+        ]\n+        || {\n+            (*x).0 as i64 + x.1\n+        }\n+    }\n }\n \n #[test]"}, {"sha": "e161c94a0eeb68f573a1c199fd9dfe347257378b", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cb4318331e0040165ff7b30903b9ea1164c114c/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cb4318331e0040165ff7b30903b9ea1164c114c/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=7cb4318331e0040165ff7b30903b9ea1164c114c", "patch": "@@ -1564,7 +1564,10 @@ impl DefWithBody {\n                         }\n                         (mir::MutabilityReason::Not, true) => {\n                             if !infer.mutated_bindings_in_closure.contains(&binding_id) {\n-                                acc.push(UnusedMut { local }.into())\n+                                let should_ignore = matches!(body[binding_id].name.as_str(), Some(x) if x.starts_with(\"_\"));\n+                                if !should_ignore {\n+                                    acc.push(UnusedMut { local }.into())\n+                                }\n                             }\n                         }\n                     }"}, {"sha": "3847e4d30e858e7d729860b50167963a2b652ece", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7cb4318331e0040165ff7b30903b9ea1164c114c/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cb4318331e0040165ff7b30903b9ea1164c114c/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=7cb4318331e0040165ff7b30903b9ea1164c114c", "patch": "@@ -851,6 +851,43 @@ fn f() {\n }\n             \"#,\n         );\n+        check_diagnostics(\n+            r#\"\n+        //- minicore: copy, fn, deref_mut\n+        struct X(i32, i64);\n+\n+        fn f() {\n+            let mut x = &mut 5;\n+              //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            let closure1 = || { *x = 2; };\n+            let _ = closure1();\n+                  //^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `closure1`\n+            let mut x = &mut 5;\n+              //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            let closure1 = move || { *x = 2; };\n+            let _ = closure1();\n+                  //^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `closure1`\n+            let mut x = &mut X(1, 2);\n+              //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            let closure1 = || { x.0 = 2; };\n+            let _ = closure1();\n+                  //^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `closure1`\n+        }\n+                    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn allow_unused_mut_for_identifiers_starting_with_underline() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut _x = 2;\n+    f(_x);\n+}\n+\"#,\n+        );\n     }\n \n     #[test]"}]}