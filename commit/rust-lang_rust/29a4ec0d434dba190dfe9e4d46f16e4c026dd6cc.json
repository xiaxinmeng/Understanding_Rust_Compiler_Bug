{"sha": "29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YTRlYzBkNDM0ZGJhMTkwZGZlOWU0ZDQ2ZjE2ZTRjMDI2ZGQ2Y2M=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-03-15T09:03:36Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-03-24T04:21:50Z"}, "message": "Make queries thread safe. Remove the query stack and make queries point to their parents instead.", "tree": {"sha": "2f6791deaa99d94fe7edb9bc6b8bd6cdf4658c64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f6791deaa99d94fe7edb9bc6b8bd6cdf4658c64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "html_url": "https://github.com/rust-lang/rust/commit/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4be5d360cd8a9338d1408b3998874313240db395", "url": "https://api.github.com/repos/rust-lang/rust/commits/4be5d360cd8a9338d1408b3998874313240db395", "html_url": "https://github.com/rust-lang/rust/commit/4be5d360cd8a9338d1408b3998874313240db395"}], "stats": {"total": 668, "additions": 486, "deletions": 182}, "files": [{"sha": "adb0ecd39846a7bfbfdf4e46baf10631d7b6710d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 136, "deletions": 46, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "patch": "@@ -1222,7 +1222,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                     Lrc::new(StableVec::new(v)));\n         }\n \n-        tls::enter_global(GlobalCtxt {\n+        let gcx = &GlobalCtxt {\n             sess: s,\n             cstore,\n             global_arenas: &arenas.global,\n@@ -1263,7 +1263,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             all_traits: RefCell::new(None),\n             tx_to_llvm_workers: tx,\n             output_filenames: Arc::new(output_filenames.clone()),\n-       }, f)\n+        };\n+\n+        tls::enter_global(gcx, f)\n     }\n \n     pub fn consider_optimizing<T: Fn() -> String>(&self, msg: T) -> bool {\n@@ -1487,11 +1489,25 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n     /// Call the closure with a local `TyCtxt` using the given arena.\n-    pub fn enter_local<F, R>(&self, arena: &'tcx DroplessArena, f: F) -> R\n+    pub fn enter_local<F, R>(&self,\n+                             arena: &'tcx DroplessArena,\n+                             f: F) -> R\n         where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n     {\n         let interners = CtxtInterners::new(arena);\n-        tls::enter(self, &interners, f)\n+        let tcx = TyCtxt {\n+            gcx: self,\n+            interners: &interners,\n+        };\n+        ty::tls::with_related_context(tcx.global_tcx(), |icx| {\n+            let new_icx = ty::tls::ImplicitCtxt {\n+                tcx,\n+                query: icx.query.clone(),\n+            };\n+            ty::tls::enter_context(&new_icx, |new_icx| {\n+                f(new_icx.tcx)\n+            })\n+        })\n     }\n }\n \n@@ -1638,21 +1654,34 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Predicate<'a>> {\n }\n \n pub mod tls {\n-    use super::{CtxtInterners, GlobalCtxt, TyCtxt};\n+    use super::{GlobalCtxt, TyCtxt};\n \n     use std::cell::Cell;\n     use std::fmt;\n+    use std::mem;\n     use syntax_pos;\n+    use ty::maps;\n+    use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n+    use rustc_data_structures::OnDrop;\n+    use rustc_data_structures::sync::Lrc;\n+\n+    #[derive(Clone)]\n+    pub struct ImplicitCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+        pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        pub query: Option<Lrc<maps::QueryJob<'gcx>>>,\n+    }\n+\n+    thread_local!(static TLV: Cell<usize> = Cell::new(0));\n \n-    /// Marker types used for the scoped TLS slot.\n-    /// The type context cannot be used directly because the scoped TLS\n-    /// in libstd doesn't allow types generic over lifetimes.\n-    enum ThreadLocalGlobalCtxt {}\n-    enum ThreadLocalInterners {}\n+    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n+        let old = get_tlv();\n+        let _reset = OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n+        TLV.with(|tlv| tlv.set(value));\n+        f()\n+    }\n \n-    thread_local! {\n-        static TLS_TCX: Cell<Option<(*const ThreadLocalGlobalCtxt,\n-                                     *const ThreadLocalInterners)>> = Cell::new(None)\n+    fn get_tlv() -> usize {\n+        TLV.with(|tlv| tlv.get())\n     }\n \n     fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -1661,59 +1690,120 @@ pub mod tls {\n         })\n     }\n \n-    pub fn enter_global<'gcx, F, R>(gcx: GlobalCtxt<'gcx>, f: F) -> R\n-        where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'gcx>) -> R\n+    fn track_diagnostic(diagnostic: &Diagnostic) {\n+        with_context(|context| {\n+            if let Some(ref query) = context.query {\n+                query.diagnostics.lock().push(diagnostic.clone());\n+            }\n+        })\n+    }\n+\n+    pub fn with_thread_locals<F, R>(f: F) -> R\n+        where F: FnOnce() -> R\n     {\n         syntax_pos::SPAN_DEBUG.with(|span_dbg| {\n             let original_span_debug = span_dbg.get();\n             span_dbg.set(span_debug);\n-            let result = enter(&gcx, &gcx.global_interners, f);\n-            span_dbg.set(original_span_debug);\n-            result\n+\n+            let _on_drop = OnDrop(move || {\n+                span_dbg.set(original_span_debug);\n+            });\n+\n+            TRACK_DIAGNOSTICS.with(|current| {\n+                let original = current.get();\n+                current.set(track_diagnostic);\n+\n+                let _on_drop = OnDrop(move || {\n+                    current.set(original);\n+                });\n+\n+                f()\n+            })\n         })\n     }\n \n-    pub fn enter<'a, 'gcx: 'tcx, 'tcx, F, R>(gcx: &'a GlobalCtxt<'gcx>,\n-                                             interners: &'a CtxtInterners<'tcx>,\n-                                             f: F) -> R\n-        where F: FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    pub fn enter_global<'gcx, F, R>(gcx: &GlobalCtxt<'gcx>, f: F) -> R\n+        where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'gcx>) -> R\n     {\n-        let gcx_ptr = gcx as *const _ as *const ThreadLocalGlobalCtxt;\n-        let interners_ptr = interners as *const _ as *const ThreadLocalInterners;\n-        TLS_TCX.with(|tls| {\n-            let prev = tls.get();\n-            tls.set(Some((gcx_ptr, interners_ptr)));\n-            let ret = f(TyCtxt {\n+        with_thread_locals(|| {\n+            let tcx = TyCtxt {\n                 gcx,\n-                interners,\n-            });\n-            tls.set(prev);\n-            ret\n+                interners: &gcx.global_interners,\n+            };\n+            let icx = ImplicitCtxt {\n+                tcx,\n+                query: None,\n+            };\n+            enter_context(&icx, |_| {\n+                f(tcx)\n+            })\n+        })\n+    }\n+\n+    pub fn enter_context<'a, 'gcx: 'tcx, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'gcx, 'tcx>,\n+                                                     f: F) -> R\n+        where F: FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        set_tlv(context as *const _ as usize, || {\n+            f(&context)\n+        })\n+    }\n+\n+    pub fn with_context_opt<F, R>(f: F) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'gcx, 'tcx>>) -> R\n+    {\n+        let context = get_tlv();\n+        if context == 0 {\n+            f(None)\n+        } else {\n+            unsafe { f(Some(&*(context as *const ImplicitCtxt))) }\n+        }\n+    }\n+\n+    pub fn with_fully_related_context<'a, 'gcx, 'tcx, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx>, f: F) -> R\n+        where F: for<'b> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx>) -> R\n+    {\n+        with_context(|context| {\n+            unsafe {\n+                let gcx = tcx.gcx as *const _ as usize;\n+                let interners = tcx.interners as *const _ as usize;\n+                assert!(context.tcx.gcx as *const _ as usize == gcx);\n+                assert!(context.tcx.interners as *const _ as usize == interners);\n+                let context: &ImplicitCtxt = mem::transmute(context);\n+                f(context)\n+            }\n         })\n     }\n \n+    pub fn with_related_context<'a, 'gcx, 'tcx1, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx1>, f: F) -> R\n+        where F: for<'b, 'tcx2> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx2>) -> R\n+    {\n+        with_context(|context| {\n+            unsafe {\n+                let gcx = tcx.gcx as *const _ as usize;\n+                assert!(context.tcx.gcx as *const _ as usize == gcx);\n+                let context: &ImplicitCtxt = mem::transmute(context);\n+                f(context)\n+            }\n+        })\n+    }\n+\n+    pub fn with_context<F, R>(f: F) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n+    }\n+\n     pub fn with<F, R>(f: F) -> R\n         where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n     {\n-        TLS_TCX.with(|tcx| {\n-            let (gcx, interners) = tcx.get().unwrap();\n-            let gcx = unsafe { &*(gcx as *const GlobalCtxt) };\n-            let interners = unsafe { &*(interners as *const CtxtInterners) };\n-            f(TyCtxt {\n-                gcx,\n-                interners,\n-            })\n-        })\n+        with_context(|context| f(context.tcx))\n     }\n \n     pub fn with_opt<F, R>(f: F) -> R\n         where F: for<'a, 'gcx, 'tcx> FnOnce(Option<TyCtxt<'a, 'gcx, 'tcx>>) -> R\n     {\n-        if TLS_TCX.with(|tcx| tcx.get().is_some()) {\n-            with(|v| f(Some(v)))\n-        } else {\n-            f(None)\n-        }\n+        with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n     }\n }\n "}, {"sha": "2ed993bd975e5e17f6f5b7c541aa2654b0793223", "filename": "src/librustc/ty/maps/job.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs?ref=29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+\n+use std::mem;\n+use std::sync::atomic::AtomicBool;\n+use std::sync::atomic::Ordering;\n+use rustc_data_structures::sync::{Lock, LockGuard, Lrc};\n+use syntax_pos::Span;\n+use ty::tls;\n+use ty::maps::Query;\n+use ty::maps::plumbing::CycleError;\n+use ty::context::TyCtxt;\n+use errors::Diagnostic;\n+use std::process;\n+use std::fmt;\n+use std::sync::{Arc, Mutex};\n+use std::collections::HashSet;\n+\n+pub struct PoisonedJob;\n+\n+#[derive(Clone, Debug)]\n+pub struct StackEntry<'tcx> {\n+    pub span: Span,\n+    pub query: Query<'tcx>,\n+}\n+\n+pub struct QueryJob<'tcx> {\n+    pub entry: StackEntry<'tcx>,\n+    pub parent: Option<Lrc<QueryJob<'tcx>>>,\n+    pub track_diagnostics: bool,\n+    pub diagnostics: Lock<Vec<Diagnostic>>,\n+}\n+\n+impl<'tcx> QueryJob<'tcx> {\n+    pub fn new(\n+        entry: StackEntry<'tcx>,\n+        track_diagnostics: bool,\n+        parent: Option<Lrc<QueryJob<'tcx>>>,\n+    ) -> Self {\n+        QueryJob {\n+            track_diagnostics,\n+            diagnostics: Lock::new(Vec::new()),\n+            entry,\n+            parent,\n+        }\n+    }\n+\n+    pub(super) fn await<'lcx>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        span: Span,\n+    ) -> Result<(), CycleError<'tcx>> {\n+        // The query is already executing, so this must be a cycle for single threaded rustc,\n+        // so we find the cycle and return it\n+\n+        let mut current_job = tls::with_related_context(tcx, |icx| icx.query.clone());\n+        let mut cycle = Vec::new();\n+\n+        while let Some(job) = current_job {\n+            cycle.insert(0, job.entry.clone());\n+\n+            if &*job as *const _ == self as *const _ {\n+                break;\n+            }\n+\n+            current_job = job.parent.clone();\n+        }\n+\n+        Err(CycleError { span, cycle })\n+    }\n+\n+    pub fn signal_complete(&self) {\n+        // Signals to waiters that the query is complete.\n+        // This is a no-op for single threaded rustc\n+    }\n+}\n+\n+pub(super) enum QueryResult<'tcx, T> {\n+    Started(Lrc<QueryJob<'tcx>>),\n+    Complete(T),\n+    Poisoned,\n+}"}, {"sha": "6dd31baa5931b6bc02ac302fad93adef70e108bc", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n use hir::svh::Svh;\n-use infer::canonical::{Canonical, QueryResult};\n+use infer::canonical::{self, Canonical};\n use lint;\n use middle::borrowck::BorrowCheckResult;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n@@ -66,6 +66,10 @@ mod plumbing;\n use self::plumbing::*;\n pub use self::plumbing::force_from_dep_node;\n \n+mod job;\n+pub use self::job::{QueryJob, StackEntry, PoisonedJob};\n+use self::job::QueryResult;\n+\n mod keys;\n pub use self::keys::Key;\n \n@@ -399,7 +403,7 @@ define_maps! { <'tcx>\n     [] fn normalize_projection_ty: NormalizeProjectionTy(\n         CanonicalProjectionGoal<'tcx>\n     ) -> Result<\n-        Lrc<Canonical<'tcx, QueryResult<'tcx, NormalizationResult<'tcx>>>>,\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, NormalizationResult<'tcx>>>>,\n         NoSolution,\n     >,\n \n@@ -412,7 +416,7 @@ define_maps! { <'tcx>\n     [] fn dropck_outlives: DropckOutlives(\n         CanonicalTyGoal<'tcx>\n     ) -> Result<\n-        Lrc<Canonical<'tcx, QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>,\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>,\n         NoSolution,\n     >,\n "}, {"sha": "4d78703613e9442d6e6e2e6fb1b0431888fe791e", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "patch": "@@ -30,6 +30,7 @@ use syntax::codemap::{CodeMap, StableFilemapId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, FileMap};\n use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n use ty;\n+use ty::maps::job::QueryResult;\n use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use ty::context::TyCtxt;\n \n@@ -239,6 +240,10 @@ impl<'sess> OnDiskCache<'sess> {\n                 for (key, entry) in const_eval::get_cache_internal(tcx).map.iter() {\n                     use ty::maps::config::QueryDescription;\n                     if const_eval::cache_on_disk(key.clone()) {\n+                        let entry = match *entry {\n+                            QueryResult::Complete(ref v) => v,\n+                            _ => panic!(\"incomplete query\"),\n+                        };\n                         if let Ok(ref value) = entry.value {\n                             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n@@ -1109,6 +1114,10 @@ fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     for (key, entry) in Q::get_cache_internal(tcx).map.iter() {\n         if Q::cache_on_disk(key.clone()) {\n+            let entry = match *entry {\n+                QueryResult::Complete(ref v) => v,\n+                _ => panic!(\"incomplete query\"),\n+            };\n             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n             // Record position of the cache entry"}, {"sha": "895bf3d797336da13f183d67cc18c7b5eee85904", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 235, "deletions": 116, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "patch": "@@ -15,19 +15,18 @@\n use dep_graph::{DepNodeIndex, DepNode, DepKind, DepNodeColor};\n use errors::DiagnosticBuilder;\n use ty::{TyCtxt};\n-use ty::maps::Query; // NB: actually generated by the macros in this file\n use ty::maps::config::QueryDescription;\n+use ty::maps::job::{QueryResult, StackEntry};\n use ty::item_path;\n \n use rustc_data_structures::fx::{FxHashMap};\n-use std::cell::{Ref, RefMut};\n+use rustc_data_structures::sync::LockGuard;\n use std::marker::PhantomData;\n-use std::mem;\n use syntax_pos::Span;\n \n pub(super) struct QueryMap<'tcx, D: QueryDescription<'tcx>> {\n     phantom: PhantomData<(D, &'tcx ())>,\n-    pub(super) map: FxHashMap<D::Key, QueryValue<D::Value>>,\n+    pub(super) map: FxHashMap<D::Key, QueryResult<'tcx, QueryValue<D::Value>>>,\n }\n \n pub(super) struct QueryValue<T> {\n@@ -57,23 +56,19 @@ impl<'tcx, M: QueryDescription<'tcx>> QueryMap<'tcx, M> {\n \n pub(super) trait GetCacheInternal<'tcx>: QueryDescription<'tcx> + Sized {\n     fn get_cache_internal<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                              -> Ref<'a, QueryMap<'tcx, Self>>;\n+                              -> LockGuard<'a, QueryMap<'tcx, Self>>;\n }\n \n-pub(super) struct CycleError<'a, 'tcx: 'a> {\n-    span: Span,\n-    cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n+#[derive(Clone)]\n+pub(super) struct CycleError<'tcx> {\n+    pub(super) span: Span,\n+    pub(super) cycle: Vec<StackEntry<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub(super) fn report_cycle(self, CycleError { span, cycle }: CycleError)\n+    pub(super) fn report_cycle(self, CycleError { span, cycle: stack }: CycleError)\n         -> DiagnosticBuilder<'a>\n     {\n-        // Subtle: release the refcell lock before invoking `describe()`\n-        // below by dropping `cycle`.\n-        let stack = cycle.to_vec();\n-        mem::drop(cycle);\n-\n         assert!(!stack.is_empty());\n \n         // Disable naming impls with types in this path, since that\n@@ -87,44 +82,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  \"cyclic dependency detected\");\n             err.span_label(span, \"cyclic reference\");\n \n-            err.span_note(self.sess.codemap().def_span(stack[0].0),\n-                          &format!(\"the cycle begins when {}...\", stack[0].1.describe(self)));\n+            err.span_note(self.sess.codemap().def_span(stack[0].span),\n+                          &format!(\"the cycle begins when {}...\", stack[0].query.describe(self)));\n \n-            for &(span, ref query) in &stack[1..] {\n+            for &StackEntry { span, ref query, .. } in &stack[1..] {\n                 err.span_note(self.sess.codemap().def_span(span),\n                               &format!(\"...which then requires {}...\", query.describe(self)));\n             }\n \n             err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n-                              stack[0].1.describe(self)));\n+                              stack[0].query.describe(self)));\n \n             return err\n         })\n     }\n \n-    pub(super) fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n-                                    -> Result<R, CycleError<'a, 'gcx>>\n-        where F: FnOnce() -> R\n-    {\n-        {\n-            let mut stack = self.maps.query_stack.borrow_mut();\n-            if let Some((i, _)) = stack.iter().enumerate().rev()\n-                                       .find(|&(_, &(_, ref q))| *q == query) {\n-                return Err(CycleError {\n-                    span,\n-                    cycle: RefMut::map(stack, |stack| &mut stack[i..])\n-                });\n-            }\n-            stack.push((span, query));\n-        }\n-\n-        let result = compute();\n-\n-        self.maps.query_stack.borrow_mut().pop();\n-\n-        Ok(result)\n-    }\n-\n     /// Try to read a node index for the node dep_node.\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n     /// green. This function will mark the current task as a reader of the specified node, when\n@@ -202,7 +174,11 @@ macro_rules! define_maps {\n        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n         use dep_graph::DepNodeIndex;\n-        use std::cell::RefCell;\n+        use std::mem;\n+        use errors::Diagnostic;\n+        use errors::FatalError;\n+        use rustc_data_structures::sync::{Lock, LockGuard};\n+        use rustc_data_structures::OnDrop;\n \n         define_map_struct! {\n             tcx: $tcx,\n@@ -214,8 +190,7 @@ macro_rules! define_maps {\n                        -> Self {\n                 Maps {\n                     providers,\n-                    query_stack: RefCell::new(vec![]),\n-                    $($name: RefCell::new(QueryMap::new())),*\n+                    $($name: Lock::new(QueryMap::new())),*\n                 }\n             }\n         }\n@@ -263,7 +238,7 @@ macro_rules! define_maps {\n \n         impl<$tcx> GetCacheInternal<$tcx> for queries::$name<$tcx> {\n             fn get_cache_internal<'a>(tcx: TyCtxt<'a, $tcx, $tcx>)\n-                                      -> ::std::cell::Ref<'a, QueryMap<$tcx, Self>> {\n+                                      -> LockGuard<'a, QueryMap<$tcx, Self>> {\n                 tcx.maps.$name.borrow()\n             }\n         }\n@@ -277,10 +252,47 @@ macro_rules! define_maps {\n                 DepNode::new(tcx, $node(*key))\n             }\n \n+            fn try_get_lock(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                            mut span: Span,\n+                            key: &$K)\n+                            -> Result<LockGuard<'a, QueryMap<$tcx, Self>>,\n+                                      Result<($V, DepNodeIndex), CycleError<$tcx>>>\n+            {\n+                loop {\n+                    let lock = tcx.maps.$name.borrow_mut();\n+                    let job = if let Some(value) = lock.map.get(key) {\n+                        match *value {\n+                            QueryResult::Started(ref job) => Some(job.clone()),\n+                            QueryResult::Complete(ref value) => {\n+                                profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                                return Err(Ok(((&value.value).clone(), value.index)));\n+                            },\n+                            QueryResult::Poisoned => FatalError.raise(),\n+                        }\n+                    } else {\n+                        None\n+                    };\n+                    let job = if let Some(job) = job {\n+                        job\n+                    } else {\n+                        return Ok(lock);\n+                    };\n+                    mem::drop(lock);\n+\n+                    if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n+                        span = key.default_span(tcx);\n+                    }\n+\n+                    if let Err(cycle) = job.await(tcx, span) {\n+                        return Err(Err(cycle));\n+                    }\n+                }\n+            }\n+\n             fn try_get_with(tcx: TyCtxt<'a, $tcx, 'lcx>,\n                             mut span: Span,\n                             key: $K)\n-                            -> Result<$V, CycleError<'a, $tcx>>\n+                            -> Result<$V, CycleError<$tcx>>\n             {\n                 debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n                        stringify!($name),\n@@ -294,24 +306,39 @@ macro_rules! define_maps {\n                     )\n                 );\n \n-                if let Some(value) = tcx.maps.$name.borrow().map.get(&key) {\n-                    profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                    tcx.dep_graph.read_index(value.index);\n-                    return Ok((&value.value).clone());\n+                macro_rules! get_lock {\n+                    () => {{\n+                        match Self::try_get_lock(tcx, span, &key) {\n+                            Ok(lock) => lock,\n+                            Err(result) => {\n+                                return result.map(|(v, index)| {\n+                                    tcx.dep_graph.read_index(index);\n+                                    v\n+                                });\n+                            },\n+                        }\n+                    }}\n                 }\n \n+                let mut lock = get_lock!();\n+\n                 // FIXME(eddyb) Get more valid Span's on queries.\n                 // def_span guard is necessary to prevent a recursive loop,\n                 // default_span calls def_span query internally.\n                 if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n-                    span = key.default_span(tcx)\n+                    // This might deadlock if we hold the map lock since we might be\n+                    // waiting for the def_span query and switch to some other fiber\n+                    // So we drop the lock here and reacquire it\n+                    mem::drop(lock);\n+                    span = key.default_span(tcx);\n+                    lock = get_lock!();\n                 }\n \n                 // Fast path for when incr. comp. is off. `to_dep_node` is\n                 // expensive for some DepKinds.\n                 if !tcx.dep_graph.is_fully_enabled() {\n                     let null_dep_node = DepNode::new_no_params(::dep_graph::DepKind::Null);\n-                    return Self::force(tcx, key, span, null_dep_node)\n+                    return Self::force_with_lock(tcx, key, span, lock, null_dep_node)\n                                 .map(|(v, _)| v);\n                 }\n \n@@ -320,34 +347,36 @@ macro_rules! define_maps {\n                 if dep_node.kind.is_anon() {\n                     profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n \n-                    let res = tcx.cycle_check(span, Query::$name(key), || {\n-                        tcx.sess.diagnostic().track_diagnostics(|| {\n-                            tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                                Self::compute_result(tcx.global_tcx(), key)\n-                            })\n+                    let res = Self::start_job(tcx, span, key, lock, |tcx| {\n+                        tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                            Self::compute_result(tcx.global_tcx(), key)\n                         })\n                     })?;\n \n                     profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-                    let ((result, dep_node_index), diagnostics) = res;\n+                    let (((result, dep_node_index), diagnostics), job) = res;\n \n                     tcx.dep_graph.read_index(dep_node_index);\n \n                     tcx.on_disk_query_result_cache\n                        .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n \n-                    let value = QueryValue::new(result, dep_node_index);\n+                    let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n+\n+                    tcx.maps\n+                       .$name\n+                       .borrow_mut()\n+                       .map\n+                       .insert(key, QueryResult::Complete(value));\n \n-                    return Ok((&tcx.maps\n-                                    .$name\n-                                    .borrow_mut()\n-                                    .map\n-                                    .entry(key)\n-                                    .or_insert(value)\n-                                    .value).clone());\n+                    job.signal_complete();\n+\n+                    return Ok(result);\n                 }\n \n                 if !dep_node.kind.is_input() {\n+                    // try_mark_green_and_read may force queries. So we must drop our lock here\n+                    mem::drop(lock);\n                     if let Some(dep_node_index) = tcx.try_mark_green_and_read(&dep_node) {\n                         profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                         return Self::load_from_disk_and_cache_in_memory(tcx,\n@@ -356,9 +385,10 @@ macro_rules! define_maps {\n                                                                         dep_node_index,\n                                                                         &dep_node)\n                     }\n+                    lock = get_lock!();\n                 }\n \n-                match Self::force(tcx, key, span, dep_node) {\n+                match Self::force_with_lock(tcx, key, span, lock, dep_node) {\n                     Ok((result, dep_node_index)) => {\n                         tcx.dep_graph.read_index(dep_node_index);\n                         Ok(result)\n@@ -391,6 +421,63 @@ macro_rules! define_maps {\n                 }\n             }\n \n+            fn start_job<F, R>(tcx: TyCtxt<'_, $tcx, 'lcx>,\n+                               span: Span,\n+                               key: $K,\n+                               mut map: LockGuard<'_, QueryMap<$tcx, Self>>,\n+                               compute: F)\n+                -> Result<((R, Vec<Diagnostic>), Lrc<QueryJob<$tcx>>), CycleError<$tcx>>\n+                where F: for<'b> FnOnce(TyCtxt<'b, $tcx, 'lcx>) -> R\n+            {\n+                let query = Query::$name(Clone::clone(&key));\n+\n+                let entry = StackEntry {\n+                    span,\n+                    query,\n+                };\n+\n+                let (r, job) = ty::tls::with_related_context(tcx, move |icx| {\n+                    let job = Lrc::new(QueryJob::new(entry, true, icx.query.clone()));\n+\n+                    map.map.entry(key).or_insert(QueryResult::Started(job.clone()));\n+\n+                    mem::drop(map);\n+\n+                    let r = {\n+                        let on_drop = OnDrop(|| {\n+                            // Poison the query so jobs waiting on it panics\n+                            tcx.maps\n+                            .$name\n+                            .borrow_mut()\n+                            .map\n+                            .insert(key, QueryResult::Poisoned);\n+                            // Also signal the completion of the job, so waiters\n+                            // will continue execution\n+                            job.signal_complete();\n+                        });\n+\n+                        let icx = ty::tls::ImplicitCtxt {\n+                            tcx,\n+                            query: Some(job.clone()),\n+                        };\n+\n+                        let r = ty::tls::enter_context(&icx, |icx| {\n+                            compute(icx.tcx)\n+                        });\n+\n+                        mem::forget(on_drop);\n+\n+                        r\n+                    };\n+\n+                    (r, job)\n+                });\n+\n+                let diagnostics: Vec<_> = mem::replace(&mut *job.diagnostics.lock(), Vec::new());\n+\n+                Ok(((r, diagnostics), job))\n+            }\n+\n             fn compute_result(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n                 let provider = tcx.maps.providers[key.map_crate()].$name;\n                 provider(tcx.global_tcx(), key)\n@@ -401,8 +488,11 @@ macro_rules! define_maps {\n                                                   span: Span,\n                                                   dep_node_index: DepNodeIndex,\n                                                   dep_node: &DepNode)\n-                                                  -> Result<$V, CycleError<'a, $tcx>>\n+                                                  -> Result<$V, CycleError<$tcx>>\n             {\n+                // Note this function can be called concurrently from the same query\n+                // We must ensure that this is handled correctly\n+\n                 debug_assert!(tcx.dep_graph.is_green(dep_node));\n \n                 // First we try to load the result from the on-disk cache\n@@ -425,24 +515,27 @@ macro_rules! define_maps {\n                     None\n                 };\n \n-                let result = if let Some(result) = result {\n-                    result\n+                let (result, job) = if let Some(result) = result {\n+                    (result, None)\n                 } else {\n                     // We could not load a result from the on-disk cache, so\n                     // recompute.\n-                    let (result, _ ) = tcx.cycle_check(span, Query::$name(key), || {\n-                        // The diagnostics for this query have already been\n-                        // promoted to the current session during\n-                        // try_mark_green(), so we can ignore them here.\n-                        tcx.sess.diagnostic().track_diagnostics(|| {\n-                            // The dep-graph for this computation is already in\n-                            // place\n-                            tcx.dep_graph.with_ignore(|| {\n-                                Self::compute_result(tcx, key)\n-                            })\n+\n+                    // The diagnostics for this query have already been\n+                    // promoted to the current session during\n+                    // try_mark_green(), so we can ignore them here.\n+                    let ((result, _), job) = Self::start_job(tcx,\n+                                                             span,\n+                                                             key,\n+                                                             tcx.maps.$name.borrow_mut(),\n+                                                             |tcx| {\n+                        // The dep-graph for this computation is already in\n+                        // place\n+                        tcx.dep_graph.with_ignore(|| {\n+                            Self::compute_result(tcx, key)\n                         })\n                     })?;\n-                    result\n+                    (result, Some(job))\n                 };\n \n                 // If -Zincremental-verify-ich is specified, re-hash results from\n@@ -475,43 +568,67 @@ macro_rules! define_maps {\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n                 }\n \n-                let value = QueryValue::new(result, dep_node_index);\n+                let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n \n-                Ok((&tcx.maps\n-                         .$name\n-                         .borrow_mut()\n-                         .map\n-                         .entry(key)\n-                         .or_insert(value)\n-                         .value).clone())\n+                tcx.maps\n+                   .$name\n+                   .borrow_mut()\n+                   .map\n+                   .insert(key, QueryResult::Complete(value));\n+\n+                job.map(|j| j.signal_complete());\n+\n+                Ok(result)\n             }\n \n+            #[allow(dead_code)]\n             fn force(tcx: TyCtxt<'a, $tcx, 'lcx>,\n                      key: $K,\n                      span: Span,\n                      dep_node: DepNode)\n-                     -> Result<($V, DepNodeIndex), CycleError<'a, $tcx>> {\n+                     -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n+                // We may be concurrently trying both execute and force a query\n+                // Ensure that only one of them runs the query\n+                let lock = match Self::try_get_lock(tcx, span, &key) {\n+                    Ok(lock) => lock,\n+                    Err(result) => return result,\n+                };\n+                Self::force_with_lock(tcx,\n+                                      key,\n+                                      span,\n+                                      lock,\n+                                      dep_node)\n+            }\n+\n+            fn force_with_lock(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                               key: $K,\n+                               span: Span,\n+                               map: LockGuard<'_, QueryMap<$tcx, Self>>,\n+                               dep_node: DepNode)\n+                               -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n                 debug_assert!(!tcx.dep_graph.dep_node_exists(&dep_node));\n \n                 profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-                let res = tcx.cycle_check(span, Query::$name(key), || {\n-                    tcx.sess.diagnostic().track_diagnostics(|| {\n-                        if dep_node.kind.is_eval_always() {\n-                            tcx.dep_graph.with_eval_always_task(dep_node,\n-                                                                tcx,\n-                                                                key,\n-                                                                Self::compute_result)\n-                        } else {\n-                            tcx.dep_graph.with_task(dep_node,\n-                                                    tcx,\n-                                                    key,\n-                                                    Self::compute_result)\n-                        }\n-                    })\n+                let res = Self::start_job(tcx,\n+                                          span,\n+                                          key,\n+                                          map,\n+                                          |tcx| {\n+                    if dep_node.kind.is_eval_always() {\n+                        tcx.dep_graph.with_eval_always_task(dep_node,\n+                                                            tcx,\n+                                                            key,\n+                                                            Self::compute_result)\n+                    } else {\n+                        tcx.dep_graph.with_task(dep_node,\n+                                                tcx,\n+                                                key,\n+                                                Self::compute_result)\n+                    }\n                 })?;\n                 profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n \n-                let ((result, dep_node_index), diagnostics) = res;\n+                let (((result, dep_node_index), diagnostics), job) = res;\n \n                 if tcx.sess.opts.debugging_opts.query_dep_graph {\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n@@ -522,16 +639,19 @@ macro_rules! define_maps {\n                        .store_diagnostics(dep_node_index, diagnostics);\n                 }\n \n-                let value = QueryValue::new(result, dep_node_index);\n+                let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n+\n+                tcx.maps\n+                   .$name\n+                   .borrow_mut()\n+                   .map\n+                   .insert(key, QueryResult::Complete(value));\n+\n+                let job: Lrc<QueryJob> = job;\n+\n+                job.signal_complete();\n \n-                Ok(((&tcx.maps\n-                         .$name\n-                         .borrow_mut()\n-                         .map\n-                         .entry(key)\n-                         .or_insert(value)\n-                         .value).clone(),\n-                   dep_node_index))\n+                Ok((result, dep_node_index))\n             }\n \n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n@@ -599,8 +719,7 @@ macro_rules! define_map_struct {\n      input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n-            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n-            $($(#[$attr])*  $name: RefCell<QueryMap<$tcx, queries::$name<$tcx>>>,)*\n+            $($(#[$attr])*  $name: Lock<QueryMap<$tcx, queries::$name<$tcx>>>,)*\n         }\n     };\n }"}, {"sha": "23a688636e997ac6f1f15be4ee3fc127b9649091", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "patch": "@@ -42,7 +42,6 @@ use rustc_data_structures::stable_hasher::StableHasher;\n \n use std::borrow::Cow;\n use std::cell::{RefCell, Cell};\n-use std::mem;\n use std::{error, fmt};\n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering::SeqCst;\n@@ -269,7 +268,6 @@ pub struct Handler {\n     emitter: RefCell<Box<Emitter>>,\n     continue_after_error: Cell<bool>,\n     delayed_span_bug: RefCell<Option<Diagnostic>>,\n-    tracked_diagnostics: RefCell<Option<Vec<Diagnostic>>>,\n \n     // This set contains the `DiagnosticId` of all emitted diagnostics to avoid\n     // emitting the same diagnostic with extended help (`--teach`) twice, which\n@@ -282,6 +280,11 @@ pub struct Handler {\n     emitted_diagnostics: RefCell<FxHashSet<u128>>,\n }\n \n+fn default_track_diagnostic(_: &Diagnostic) {}\n+\n+thread_local!(pub static TRACK_DIAGNOSTICS: Cell<fn(&Diagnostic)> =\n+                Cell::new(default_track_diagnostic));\n+\n #[derive(Default)]\n pub struct HandlerFlags {\n     pub can_emit_warnings: bool,\n@@ -333,7 +336,6 @@ impl Handler {\n             emitter: RefCell::new(e),\n             continue_after_error: Cell::new(true),\n             delayed_span_bug: RefCell::new(None),\n-            tracked_diagnostics: RefCell::new(None),\n             tracked_diagnostic_codes: RefCell::new(FxHashSet()),\n             emitted_diagnostics: RefCell::new(FxHashSet()),\n         }\n@@ -629,17 +631,6 @@ impl Handler {\n         }\n     }\n \n-    pub fn track_diagnostics<F, R>(&self, f: F) -> (R, Vec<Diagnostic>)\n-        where F: FnOnce() -> R\n-    {\n-        let prev = mem::replace(&mut *self.tracked_diagnostics.borrow_mut(),\n-                                Some(Vec::new()));\n-        let ret = f();\n-        let diagnostics = mem::replace(&mut *self.tracked_diagnostics.borrow_mut(), prev)\n-            .unwrap();\n-        (ret, diagnostics)\n-    }\n-\n     /// `true` if a diagnostic with this code has already been emitted in this handler.\n     ///\n     /// Used to suppress emitting the same error multiple times with extended explanation when\n@@ -651,9 +642,9 @@ impl Handler {\n     fn emit_db(&self, db: &DiagnosticBuilder) {\n         let diagnostic = &**db;\n \n-        if let Some(ref mut list) = *self.tracked_diagnostics.borrow_mut() {\n-            list.push(diagnostic.clone());\n-        }\n+        TRACK_DIAGNOSTICS.with(|track_diagnostics| {\n+            track_diagnostics.get()(diagnostic);\n+        });\n \n         if let Some(ref code) = diagnostic.code {\n             self.tracked_diagnostic_codes.borrow_mut().insert(code.clone());"}]}