{"sha": "dbc697cb7d87762088ea67c665b12a7a3f441ef8", "node_id": "C_kwDOAAsO6NoAKGRiYzY5N2NiN2Q4Nzc2MjA4OGVhNjdjNjY1YjEyYTdhM2Y0NDFlZjg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-17T16:28:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-17T16:28:21Z"}, "message": "Merge #11743\n\n11743: fix: Properly unify receivers during method resolution r=flodiebold a=flodiebold\n\nThis fixes our type inference problems with `DynMap`; the problem there were the projection types in\r\n```rust\r\nimpl<P: Policy> KeyMap<Key<P::K, P::V, P>>\r\n```\r\nwhich messed up the naive type equality check we did. It also actually simplifies the logic though, IMO. I also added a fix for associated const resolution that I noticed (visibility not being taken into account).\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "0857e2fb325315bfb825056bf36fef98568184d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0857e2fb325315bfb825056bf36fef98568184d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc697cb7d87762088ea67c665b12a7a3f441ef8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiM2GlCRBK7hj4Ov3rIwAAb1sIADs4X+8r+oJxsNWp1UHyuU3m\nkQlZVUDq45ZO11iM1j0G/7ytboE9xEvYB4YRTTgjR2KEb31TwAt37zFegBhWBwud\nZRGZrcEBZyQXVYmv+6IyZL4HrGltVc0lNLsgACkcJhYpf4zyfamtjE3libR3YnCa\n/qKSwkRQnEEUsOgsg7Pi2uYdAgrloAF0oFrrkNDpDTMGJnHfrMsopHEFgslyfc2d\nlupml8HxM9Ev88aU1iw8q7xnvkyYcJDN82F7GJB4hYEegJnK4JanLL2VoB1fMx4u\n+jBCYw9wbctptLjnyTesK9jIHhIn47C5+R6OgO0xiENs97QA7VMQJ1bD6tsEewo=\n=nyH9\n-----END PGP SIGNATURE-----\n", "payload": "tree 0857e2fb325315bfb825056bf36fef98568184d2\nparent 631b504991dd50a59af30263256ab4ab4897f71f\nparent 60aeb8fa1a0432e50d880c8ba76cdea8f9344995\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647534501 +0000\ncommitter GitHub <noreply@github.com> 1647534501 +0000\n\nMerge #11743\n\n11743: fix: Properly unify receivers during method resolution r=flodiebold a=flodiebold\n\nThis fixes our type inference problems with `DynMap`; the problem there were the projection types in\r\n```rust\r\nimpl<P: Policy> KeyMap<Key<P::K, P::V, P>>\r\n```\r\nwhich messed up the naive type equality check we did. It also actually simplifies the logic though, IMO. I also added a fix for associated const resolution that I noticed (visibility not being taken into account).\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc697cb7d87762088ea67c665b12a7a3f441ef8", "html_url": "https://github.com/rust-lang/rust/commit/dbc697cb7d87762088ea67c665b12a7a3f441ef8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc697cb7d87762088ea67c665b12a7a3f441ef8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "631b504991dd50a59af30263256ab4ab4897f71f", "url": "https://api.github.com/repos/rust-lang/rust/commits/631b504991dd50a59af30263256ab4ab4897f71f", "html_url": "https://github.com/rust-lang/rust/commit/631b504991dd50a59af30263256ab4ab4897f71f"}, {"sha": "60aeb8fa1a0432e50d880c8ba76cdea8f9344995", "url": "https://api.github.com/repos/rust-lang/rust/commits/60aeb8fa1a0432e50d880c8ba76cdea8f9344995", "html_url": "https://github.com/rust-lang/rust/commit/60aeb8fa1a0432e50d880c8ba76cdea8f9344995"}], "stats": {"total": 571, "additions": 295, "deletions": 276}, "files": [{"sha": "8121b27dcb7d37a83f46a61a124a28449a363d71", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=dbc697cb7d87762088ea67c665b12a7a3f441ef8", "patch": "@@ -1541,9 +1541,7 @@ impl SelfParam {\n \n impl HasVisibility for Function {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n-        let function_data = db.function_data(self.id);\n-        let visibility = &function_data.visibility;\n-        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+        db.function_visibility(self.id)\n     }\n }\n \n@@ -1594,9 +1592,7 @@ impl Const {\n \n impl HasVisibility for Const {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n-        let function_data = db.const_data(self.id);\n-        let visibility = &function_data.visibility;\n-        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+        db.const_visibility(self.id)\n     }\n }\n "}, {"sha": "74bb7472d57d0b49a571ed0abdec452aaf70f063", "filename": "crates/hir_def/src/db.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=dbc697cb7d87762088ea67c665b12a7a3f441ef8", "patch": "@@ -175,9 +175,13 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(visibility::field_visibilities_query)]\n     fn field_visibilities(&self, var: VariantId) -> Arc<ArenaMap<LocalFieldId, Visibility>>;\n \n+    // FIXME: unify function_visibility and const_visibility?\n     #[salsa::invoke(visibility::function_visibility_query)]\n     fn function_visibility(&self, def: FunctionId) -> Visibility;\n \n+    #[salsa::invoke(visibility::const_visibility_query)]\n+    fn const_visibility(&self, def: ConstId) -> Visibility;\n+\n     #[salsa::transparent]\n     fn crate_limits(&self, crate_id: CrateId) -> CrateLimits;\n }"}, {"sha": "6e22a877a9fa7980921f19be2af230e6eec56a3b", "filename": "crates/hir_def/src/visibility.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fvisibility.rs?ref=dbc697cb7d87762088ea67c665b12a7a3f441ef8", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     nameres::DefMap,\n     path::{ModPath, PathKind},\n     resolver::HasResolver,\n-    FunctionId, HasModule, LocalFieldId, ModuleId, VariantId,\n+    ConstId, FunctionId, HasModule, LocalFieldId, ModuleId, VariantId,\n };\n \n /// Visibility of an item, not yet resolved.\n@@ -234,3 +234,9 @@ pub(crate) fn function_visibility_query(db: &dyn DefDatabase, def: FunctionId) -\n     let resolver = def.resolver(db);\n     db.function_data(def).visibility.resolve(db, &resolver)\n }\n+\n+/// Resolve visibility of a const.\n+pub(crate) fn const_visibility_query(db: &dyn DefDatabase, def: ConstId) -> Visibility {\n+    let resolver = def.resolver(db);\n+    db.const_data(def).visibility.resolve(db, &resolver)\n+}"}, {"sha": "5c77c0cdf8b9905867801dc3568e935686bbaa56", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=dbc697cb7d87762088ea67c665b12a7a3f441ef8", "patch": "@@ -15,10 +15,10 @@ use hir_def::{\n use smallvec::SmallVec;\n \n use crate::{\n-    consteval::unknown_const_as_generic, db::HirDatabase, primitive, to_assoc_type_id,\n-    to_chalk_trait_id, utils::generics, Binders, CallableSig, ConstData, ConstValue, GenericArg,\n-    GenericArgData, Interner, ProjectionTy, Substitution, TraitRef, Ty, TyDefId, TyExt, TyKind,\n-    ValueTyDefId,\n+    consteval::unknown_const_as_generic, db::HirDatabase, infer::unify::InferenceTable, primitive,\n+    to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders, CallableSig, ConstData,\n+    ConstValue, GenericArg, GenericArgData, Interner, ProjectionTy, Substitution, TraitRef, Ty,\n+    TyDefId, TyExt, TyKind, ValueTyDefId,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -111,6 +111,15 @@ impl<D> TyBuilder<D> {\n         this\n     }\n \n+    pub(crate) fn fill_with_inference_vars(self, table: &mut InferenceTable) -> Self {\n+        self.fill(|x| match x {\n+            ParamKind::Type => GenericArgData::Ty(table.new_type_var()).intern(Interner),\n+            ParamKind::Const(ty) => {\n+                GenericArgData::Const(table.new_const_var(ty.clone())).intern(Interner)\n+            }\n+        })\n+    }\n+\n     pub fn fill(mut self, filler: impl FnMut(&ParamKind) -> GenericArg) -> Self {\n         self.vec.extend(self.param_kinds.iter().skip(self.vec.len()).map(filler));\n         assert_eq!(self.remaining(), 0);"}, {"sha": "442774d0be065f4c354df70d777f842a178ad548", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=dbc697cb7d87762088ea67c665b12a7a3f441ef8", "patch": "@@ -35,18 +35,16 @@ use rustc_hash::FxHashMap;\n use stdx::impl_from;\n \n use crate::{\n-    builder::ParamKind, db::HirDatabase, fold_tys_and_consts, infer::coerce::CoerceMany,\n-    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Const, DomainGoal,\n-    GenericArg, GenericArgData, Goal, InEnvironment, Interner, ProjectionTy, Substitution,\n-    TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    db::HirDatabase, fold_tys_and_consts, infer::coerce::CoerceMany, lower::ImplTraitLoweringMode,\n+    to_assoc_type_id, AliasEq, AliasTy, Const, DomainGoal, GenericArg, Goal, InEnvironment,\n+    Interner, ProjectionTy, Substitution, TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n //\n // https://github.com/rust-lang/rust/issues/57411\n #[allow(unreachable_pub)]\n pub use unify::could_unify;\n-pub(crate) use unify::unify;\n \n pub(crate) mod unify;\n mod path;\n@@ -657,15 +655,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             TypeNs::TypeAliasId(it) => {\n                 let ty = TyBuilder::def_ty(self.db, it.into())\n-                    .fill(|x| match x {\n-                        ParamKind::Type => {\n-                            GenericArgData::Ty(self.table.new_type_var()).intern(Interner)\n-                        }\n-                        ParamKind::Const(ty) => {\n-                            GenericArgData::Const(self.table.new_const_var(ty.clone()))\n-                                .intern(Interner)\n-                        }\n-                    })\n+                    .fill_with_inference_vars(&mut self.table)\n                     .build();\n                 self.resolve_variant_on_alias(ty, unresolved, path)\n             }"}, {"sha": "53fe2131a35a9b388f6410ae69a59516f1e8024b", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=dbc697cb7d87762088ea67c665b12a7a3f441ef8", "patch": "@@ -104,9 +104,7 @@ impl<'a> InferenceContext<'a> {\n                     ParamKind::Type => {\n                         GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n                     }\n-                    ParamKind::Const(_) => {\n-                        GenericArgData::Const(consteval::usize_const(None)).intern(Interner)\n-                    }\n+                    ParamKind::Const(ty) => consteval::unknown_const_as_generic(ty.clone()),\n                 })\n             })\n             .build();\n@@ -249,15 +247,7 @@ impl<'a> InferenceContext<'a> {\n                 let substs = match container {\n                     ItemContainerId::ImplId(impl_id) => {\n                         let impl_substs = TyBuilder::subst_for_def(self.db, impl_id)\n-                            .fill(|x| match x {\n-                                ParamKind::Type => {\n-                                    GenericArgData::Ty(self.table.new_type_var()).intern(Interner)\n-                                }\n-                                ParamKind::Const(ty) => {\n-                                    GenericArgData::Const(self.table.new_const_var(ty.clone()))\n-                                        .intern(Interner)\n-                                }\n-                            })\n+                            .fill_with_inference_vars(&mut self.table)\n                             .build();\n                         let impl_self_ty =\n                             self.db.impl_self_ty(impl_id).substitute(Interner, &impl_substs);\n@@ -268,15 +258,7 @@ impl<'a> InferenceContext<'a> {\n                         // we're picking this method\n                         let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n                             .push(ty.clone())\n-                            .fill(|x| match x {\n-                                ParamKind::Type => {\n-                                    GenericArgData::Ty(self.table.new_type_var()).intern(Interner)\n-                                }\n-                                ParamKind::Const(ty) => {\n-                                    GenericArgData::Const(self.table.new_const_var(ty.clone()))\n-                                        .intern(Interner)\n-                                }\n-                            })\n+                            .fill_with_inference_vars(&mut self.table)\n                             .build();\n                         self.push_obligation(trait_ref.clone().cast(Interner));\n                         Some(trait_ref.substitution)"}, {"sha": "ef0675d59f686fb5201d1c8c5031db11f4f09ed2", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=dbc697cb7d87762088ea67c665b12a7a3f441ef8", "patch": "@@ -146,7 +146,7 @@ pub(crate) struct InferenceTable<'a> {\n \n pub(crate) struct InferenceTableSnapshot {\n     var_table_snapshot: chalk_solve::infer::InferenceSnapshot<Interner>,\n-    // FIXME: snapshot pending_obligations?\n+    pending_obligations: Vec<Canonicalized<InEnvironment<Goal>>>,\n     type_variable_table_snapshot: Vec<TypeVariableData>,\n }\n \n@@ -365,12 +365,25 @@ impl<'a> InferenceTable<'a> {\n     pub(crate) fn snapshot(&mut self) -> InferenceTableSnapshot {\n         let var_table_snapshot = self.var_unification_table.snapshot();\n         let type_variable_table_snapshot = self.type_variable_table.clone();\n-        InferenceTableSnapshot { var_table_snapshot, type_variable_table_snapshot }\n+        let pending_obligations = self.pending_obligations.clone();\n+        InferenceTableSnapshot {\n+            var_table_snapshot,\n+            pending_obligations,\n+            type_variable_table_snapshot,\n+        }\n     }\n \n     pub(crate) fn rollback_to(&mut self, snapshot: InferenceTableSnapshot) {\n         self.var_unification_table.rollback_to(snapshot.var_table_snapshot);\n         self.type_variable_table = snapshot.type_variable_table_snapshot;\n+        self.pending_obligations = snapshot.pending_obligations;\n+    }\n+\n+    pub(crate) fn run_in_snapshot<T>(&mut self, f: impl FnOnce(&mut InferenceTable) -> T) -> T {\n+        let snapshot = self.snapshot();\n+        let result = f(self);\n+        self.rollback_to(snapshot);\n+        result\n     }\n \n     /// Checks an obligation without registering it. Useful mostly to check"}, {"sha": "41bb94c5d554121c0db4fbc8a912e5e2d3dd7dc9", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=dbc697cb7d87762088ea67c665b12a7a3f441ef8", "patch": "@@ -9,6 +9,8 @@ use std::cell::{Cell, RefCell};\n use std::{iter, sync::Arc};\n \n use base_db::CrateId;\n+use chalk_ir::fold::Fold;\n+use chalk_ir::interner::HasInterner;\n use chalk_ir::{cast::Cast, fold::Shift, Mutability, Safety};\n use hir_def::generics::TypeOrConstParamData;\n use hir_def::intern::Interned;\n@@ -36,7 +38,6 @@ use stdx::{impl_from, never};\n use syntax::{ast, SmolStr};\n \n use crate::consteval::{path_to_const, unknown_const_as_generic, unknown_const_usize, usize_const};\n-use crate::method_resolution::fallback_bound_vars;\n use crate::utils::Generics;\n use crate::{all_super_traits, make_binders, Const, GenericArgData, ParamKind};\n use crate::{\n@@ -1701,3 +1702,28 @@ pub(crate) fn const_or_path_to_chalk(\n         }\n     }\n }\n+\n+/// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n+/// num_vars_to_keep) by `TyKind::Unknown`.\n+fn fallback_bound_vars<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n+    s: T,\n+    num_vars_to_keep: usize,\n+) -> T::Result {\n+    crate::fold_free_vars(\n+        s,\n+        |bound, binders| {\n+            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n+                TyKind::Error.intern(Interner)\n+            } else {\n+                bound.shifted_in_from(binders).to_ty(Interner)\n+            }\n+        },\n+        |ty, bound, binders| {\n+            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n+                consteval::unknown_const(ty.clone())\n+            } else {\n+                bound.shifted_in_from(binders).to_const(Interner, ty)\n+            }\n+        },\n+    )\n+}"}, {"sha": "1c939f3d8aac2ffaef6ce0b458ea56b4f00622a2", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 125, "deletions": 226, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=dbc697cb7d87762088ea67c665b12a7a3f441ef8", "patch": "@@ -6,7 +6,7 @@ use std::{iter, ops::ControlFlow, sync::Arc};\n \n use arrayvec::ArrayVec;\n use base_db::{CrateId, Edition};\n-use chalk_ir::{cast::Cast, fold::Fold, interner::HasInterner, Mutability, UniverseIndex};\n+use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n use hir_def::{\n     item_scope::ItemScope, lang_item::LangItemTarget, nameres::DefMap, AssocItemId, BlockId,\n     ConstId, FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId,\n@@ -18,16 +18,14 @@ use stdx::never;\n \n use crate::{\n     autoderef::{self, AutoderefKind},\n-    consteval::{self, ConstExt},\n     db::HirDatabase,\n     from_foreign_def_id,\n     infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n     primitive::{self, FloatTy, IntTy, UintTy},\n     static_lifetime,\n     utils::all_super_traits,\n-    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, GenericArgData,\n-    InEnvironment, Interner, Scalar, Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder,\n-    TyExt, TyKind,\n+    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n+    Scalar, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n };\n \n /// This is used as a key for indexing impls.\n@@ -643,11 +641,10 @@ pub fn iterate_method_candidates_dyn(\n             let mut table = InferenceTable::new(db, env.clone());\n             let ty = table.instantiate_canonical(ty.clone());\n             let (deref_chain, adj) = autoderef_method_receiver(&mut table, ty);\n-            let deref_chains = stdx::slice_tails(&deref_chain);\n \n-            let result = deref_chains.zip(adj).try_for_each(|(deref_chain, adj)| {\n+            let result = deref_chain.into_iter().zip(adj).try_for_each(|(receiver_ty, adj)| {\n                 iterate_method_candidates_with_autoref(\n-                    deref_chain,\n+                    &receiver_ty,\n                     adj,\n                     db,\n                     env.clone(),\n@@ -675,7 +672,7 @@ pub fn iterate_method_candidates_dyn(\n }\n \n fn iterate_method_candidates_with_autoref(\n-    deref_chain: &[Canonical<Ty>],\n+    receiver_ty: &Canonical<Ty>,\n     first_adjustment: ReceiverAdjustments,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n@@ -684,17 +681,9 @@ fn iterate_method_candidates_with_autoref(\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n-    let (receiver_ty, rest) = match deref_chain.split_first() {\n-        Some((rec, rest)) => (rec, rest),\n-        None => {\n-            never!(\"received empty deref-chain\");\n-            return ControlFlow::Break(());\n-        }\n-    };\n     iterate_method_candidates_by_receiver(\n         receiver_ty,\n         first_adjustment.clone(),\n-        rest,\n         db,\n         env.clone(),\n         traits_in_scope,\n@@ -712,7 +701,6 @@ fn iterate_method_candidates_with_autoref(\n     iterate_method_candidates_by_receiver(\n         &refed,\n         first_adjustment.with_autoref(Mutability::Not),\n-        deref_chain,\n         db,\n         env.clone(),\n         traits_in_scope,\n@@ -730,7 +718,6 @@ fn iterate_method_candidates_with_autoref(\n     iterate_method_candidates_by_receiver(\n         &ref_muted,\n         first_adjustment.with_autoref(Mutability::Mut),\n-        deref_chain,\n         db,\n         env,\n         traits_in_scope,\n@@ -743,38 +730,42 @@ fn iterate_method_candidates_with_autoref(\n fn iterate_method_candidates_by_receiver(\n     receiver_ty: &Canonical<Ty>,\n     receiver_adjustments: ReceiverAdjustments,\n-    rest_of_deref_chain: &[Canonical<Ty>],\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n+    let mut table = InferenceTable::new(db, env);\n+    let receiver_ty = table.instantiate_canonical(receiver_ty.clone());\n+    let snapshot = table.snapshot();\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n     // that.\n-    for self_ty in iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+    let mut autoderef = autoderef::Autoderef::new(&mut table, receiver_ty.clone());\n+    while let Some((self_ty, _)) = autoderef.next() {\n         iterate_inherent_methods(\n-            self_ty,\n-            db,\n-            env.clone(),\n+            &self_ty,\n+            &mut autoderef.table,\n             name,\n-            Some(receiver_ty),\n+            Some(&receiver_ty),\n             Some(receiver_adjustments.clone()),\n             visible_from_module,\n             &mut callback,\n         )?\n     }\n \n-    for self_ty in iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+    table.rollback_to(snapshot);\n+\n+    let mut autoderef = autoderef::Autoderef::new(&mut table, receiver_ty.clone());\n+    while let Some((self_ty, _)) = autoderef.next() {\n         iterate_trait_method_candidates(\n-            self_ty,\n-            db,\n-            env.clone(),\n+            &self_ty,\n+            &mut autoderef.table,\n             traits_in_scope,\n             name,\n-            Some(receiver_ty),\n+            Some(&receiver_ty),\n             Some(receiver_adjustments.clone()),\n             &mut callback,\n         )?\n@@ -792,43 +783,55 @@ fn iterate_method_candidates_for_self_ty(\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n+    let mut table = InferenceTable::new(db, env);\n+    let self_ty = table.instantiate_canonical(self_ty.clone());\n     iterate_inherent_methods(\n-        self_ty,\n-        db,\n-        env.clone(),\n+        &self_ty,\n+        &mut table,\n         name,\n         None,\n         None,\n         visible_from_module,\n         &mut callback,\n     )?;\n-    iterate_trait_method_candidates(self_ty, db, env, traits_in_scope, name, None, None, callback)\n+    iterate_trait_method_candidates(\n+        &self_ty,\n+        &mut table,\n+        traits_in_scope,\n+        name,\n+        None,\n+        None,\n+        callback,\n+    )\n }\n \n fn iterate_trait_method_candidates(\n-    self_ty: &Canonical<Ty>,\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n+    self_ty: &Ty,\n+    table: &mut InferenceTable,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n-    receiver_ty: Option<&Canonical<Ty>>,\n+    receiver_ty: Option<&Ty>,\n     receiver_adjustments: Option<ReceiverAdjustments>,\n     callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n-    let self_is_array = matches!(self_ty.value.kind(Interner), chalk_ir::TyKind::Array(..));\n+    let db = table.db;\n+    let env = table.trait_env.clone();\n+    let self_is_array = matches!(self_ty.kind(Interner), chalk_ir::TyKind::Array(..));\n     // if ty is `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait =\n-        self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n-    let env_traits = matches!(self_ty.value.kind(Interner), TyKind::Placeholder(_))\n+        self_ty.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n+    let env_traits = matches!(self_ty.kind(Interner), TyKind::Placeholder(_))\n         // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n         .then(|| {\n-            env.traits_in_scope_from_clauses(self_ty.value.clone())\n+            env.traits_in_scope_from_clauses(self_ty.clone())\n                 .flat_map(|t| all_super_traits(db.upcast(), t))\n         })\n         .into_iter()\n         .flatten();\n     let traits = inherent_trait.chain(env_traits).chain(traits_in_scope.iter().copied());\n \n+    let canonical_self_ty = table.canonicalize(self_ty.clone()).value;\n+\n     'traits: for t in traits {\n         let data = db.trait_data(t);\n \n@@ -852,11 +855,11 @@ fn iterate_trait_method_candidates(\n         for &(_, item) in data.items.iter() {\n             // Don't pass a `visible_from_module` down to `is_valid_candidate`,\n             // since only inherent methods should be included into visibility checking.\n-            if !is_valid_candidate(db, env.clone(), name, receiver_ty, item, self_ty, None) {\n+            if !is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n                 continue;\n             }\n             if !known_implemented {\n-                let goal = generic_implements_goal(db, env.clone(), t, self_ty);\n+                let goal = generic_implements_goal(db, env.clone(), t, &canonical_self_ty);\n                 if db.trait_solve(env.krate, goal.cast(Interner)).is_none() {\n                     continue 'traits;\n                 }\n@@ -868,40 +871,18 @@ fn iterate_trait_method_candidates(\n     ControlFlow::Continue(())\n }\n \n-fn filter_inherent_impls_for_self_ty<'i>(\n-    impls: &'i InherentImpls,\n-    self_ty: &Ty,\n-) -> impl Iterator<Item = &'i ImplId> {\n-    // inherent methods on arrays are fingerprinted as [T; {unknown}], so we must also consider them when\n-    // resolving a method call on an array with a known len\n-    let array_impls = {\n-        match self_ty.kind(Interner) {\n-            TyKind::Array(parameters, array_len) if !array_len.is_unknown() => {\n-                let unknown_array_len_ty =\n-                    TyKind::Array(parameters.clone(), consteval::usize_const(None));\n-\n-                Some(impls.for_self_ty(&unknown_array_len_ty.intern(Interner)))\n-            }\n-            _ => None,\n-        }\n-    }\n-    .into_iter()\n-    .flatten();\n-\n-    impls.for_self_ty(self_ty).iter().chain(array_impls)\n-}\n-\n fn iterate_inherent_methods(\n-    self_ty: &Canonical<Ty>,\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n+    self_ty: &Ty,\n+    table: &mut InferenceTable,\n     name: Option<&Name>,\n-    receiver_ty: Option<&Canonical<Ty>>,\n+    receiver_ty: Option<&Ty>,\n     receiver_adjustments: Option<ReceiverAdjustments>,\n     visible_from_module: VisibleFromModule,\n     callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n-    let def_crates = match def_crates(db, &self_ty.value, env.krate) {\n+    let db = table.db;\n+    let env = table.trait_env.clone();\n+    let def_crates = match def_crates(db, self_ty, env.krate) {\n         Some(k) => k,\n         None => return ControlFlow::Continue(()),\n     };\n@@ -917,8 +898,7 @@ fn iterate_inherent_methods(\n             impls_for_self_ty(\n                 &impls,\n                 self_ty,\n-                db,\n-                env.clone(),\n+                table,\n                 name,\n                 receiver_ty,\n                 receiver_adjustments.clone(),\n@@ -933,8 +913,7 @@ fn iterate_inherent_methods(\n         impls_for_self_ty(\n             &impls,\n             self_ty,\n-            db,\n-            env.clone(),\n+            table,\n             name,\n             receiver_ty,\n             receiver_adjustments.clone(),\n@@ -946,37 +925,20 @@ fn iterate_inherent_methods(\n \n     fn impls_for_self_ty(\n         impls: &InherentImpls,\n-        self_ty: &Canonical<Ty>,\n-        db: &dyn HirDatabase,\n-        env: Arc<TraitEnvironment>,\n+        self_ty: &Ty,\n+        table: &mut InferenceTable,\n         name: Option<&Name>,\n-        receiver_ty: Option<&Canonical<Ty>>,\n+        receiver_ty: Option<&Ty>,\n         receiver_adjustments: Option<ReceiverAdjustments>,\n         visible_from_module: Option<ModuleId>,\n         callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n     ) -> ControlFlow<()> {\n-        let impls_for_self_ty = filter_inherent_impls_for_self_ty(impls, &self_ty.value);\n+        let db = table.db;\n+        let impls_for_self_ty = impls.for_self_ty(self_ty);\n         for &impl_def in impls_for_self_ty {\n             for &item in &db.impl_data(impl_def).items {\n-                if !is_valid_candidate(\n-                    db,\n-                    env.clone(),\n-                    name,\n-                    receiver_ty,\n-                    item,\n-                    self_ty,\n-                    visible_from_module,\n-                ) {\n-                    continue;\n-                }\n-                // we have to check whether the self type unifies with the type\n-                // that the impl is for. If we have a receiver type, this\n-                // already happens in `is_valid_candidate` above; if not, we\n-                // check it here\n-                if receiver_ty.is_none()\n-                    && inherent_impl_substs(db, env.clone(), impl_def, self_ty).is_none()\n+                if !is_valid_candidate(table, name, receiver_ty, item, self_ty, visible_from_module)\n                 {\n-                    cov_mark::hit!(impl_self_type_match_without_receiver);\n                     continue;\n                 }\n                 callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n@@ -1005,37 +967,15 @@ pub fn resolve_indexing_op(\n     None\n }\n \n-fn is_transformed_receiver_ty_equal(transformed_receiver_ty: &Ty, receiver_ty: &Ty) -> bool {\n-    if transformed_receiver_ty == receiver_ty {\n-        return true;\n-    }\n-\n-    // a transformed receiver may be considered equal (and a valid method call candidate) if it is an array\n-    // with an unknown (i.e. generic) length, and the receiver is an array with the same item type but a known len,\n-    // this allows inherent methods on arrays to be considered valid resolution candidates\n-    match (transformed_receiver_ty.kind(Interner), receiver_ty.kind(Interner)) {\n-        (\n-            TyKind::Array(transformed_array_ty, transformed_array_len),\n-            TyKind::Array(receiver_array_ty, receiver_array_len),\n-        ) if transformed_array_ty == receiver_array_ty\n-            && transformed_array_len.is_unknown()\n-            && !receiver_array_len.is_unknown() =>\n-        {\n-            true\n-        }\n-        _ => false,\n-    }\n-}\n-\n fn is_valid_candidate(\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n+    table: &mut InferenceTable,\n     name: Option<&Name>,\n-    receiver_ty: Option<&Canonical<Ty>>,\n+    receiver_ty: Option<&Ty>,\n     item: AssocItemId,\n-    self_ty: &Canonical<Ty>,\n+    self_ty: &Ty,\n     visible_from_module: Option<ModuleId>,\n ) -> bool {\n+    let db = table.db;\n     match item {\n         AssocItemId::FunctionId(m) => {\n             let data = db.function_data(m);\n@@ -1044,123 +984,82 @@ fn is_valid_candidate(\n                     return false;\n                 }\n             }\n-            if let Some(receiver_ty) = receiver_ty {\n-                if !data.has_self_param() {\n+            table.run_in_snapshot(|table| {\n+                let subst = TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n+                let expected_self_ty = match m.lookup(db.upcast()).container {\n+                    ItemContainerId::TraitId(_) => {\n+                        subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n+                    }\n+                    ItemContainerId::ImplId(impl_id) => {\n+                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n+                    }\n+                    // We should only get called for associated items (impl/trait)\n+                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n+                        unreachable!()\n+                    }\n+                };\n+                if !table.unify(&expected_self_ty, &self_ty) {\n                     return false;\n                 }\n-                let transformed_receiver_ty = match transform_receiver_ty(db, env, m, self_ty) {\n-                    Some(ty) => ty,\n-                    None => return false,\n-                };\n+                if let Some(receiver_ty) = receiver_ty {\n+                    if !data.has_self_param() {\n+                        return false;\n+                    }\n+\n+                    let sig = db.callable_item_signature(m.into());\n+                    let expected_receiver =\n+                        sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n+                    let receiver_matches = table.unify(&receiver_ty, &expected_receiver);\n+\n+                    if !receiver_matches {\n+                        return false;\n+                    }\n+                }\n+                if let Some(from_module) = visible_from_module {\n+                    if !db.function_visibility(m).is_visible_from(db.upcast(), from_module) {\n+                        cov_mark::hit!(autoderef_candidate_not_visible);\n+                        return false;\n+                    }\n+                }\n \n-                if !is_transformed_receiver_ty_equal(&transformed_receiver_ty, &receiver_ty.value) {\n+                true\n+            })\n+        }\n+        AssocItemId::ConstId(c) => {\n+            let data = db.const_data(c);\n+            if receiver_ty.is_some() {\n+                return false;\n+            }\n+            if let Some(name) = name {\n+                if data.name.as_ref() != Some(name) {\n                     return false;\n                 }\n             }\n             if let Some(from_module) = visible_from_module {\n-                if !db.function_visibility(m).is_visible_from(db.upcast(), from_module) {\n-                    cov_mark::hit!(autoderef_candidate_not_visible);\n+                if !db.const_visibility(c).is_visible_from(db.upcast(), from_module) {\n+                    cov_mark::hit!(const_candidate_not_visible);\n+                    return false;\n+                }\n+            }\n+            if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n+                let self_ty_matches = table.run_in_snapshot(|table| {\n+                    let subst =\n+                        TyBuilder::subst_for_def(db, c).fill_with_inference_vars(table).build();\n+                    let expected_self_ty =\n+                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner);\n+                    table.unify(&expected_self_ty, &self_ty)\n+                });\n+                if !self_ty_matches {\n+                    cov_mark::hit!(const_candidate_self_type_mismatch);\n                     return false;\n                 }\n             }\n-\n             true\n         }\n-        AssocItemId::ConstId(c) => {\n-            let data = db.const_data(c);\n-            name.map_or(true, |name| data.name.as_ref() == Some(name)) && receiver_ty.is_none()\n-        }\n         _ => false,\n     }\n }\n \n-pub(crate) fn inherent_impl_substs(\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n-    impl_id: ImplId,\n-    self_ty: &Canonical<Ty>,\n-) -> Option<Substitution> {\n-    // we create a var for each type parameter of the impl; we need to keep in\n-    // mind here that `self_ty` might have vars of its own\n-    let self_ty_vars = self_ty.binders.len(Interner);\n-    let vars = TyBuilder::subst_for_def(db, impl_id)\n-        .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty_vars)\n-        .build();\n-    let self_ty_with_vars = db.impl_self_ty(impl_id).substitute(Interner, &vars);\n-    let mut kinds = self_ty.binders.interned().to_vec();\n-    kinds.extend(vars.iter(Interner).map(|x| {\n-        let kind = match x.data(Interner) {\n-            GenericArgData::Ty(_) => chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n-            GenericArgData::Const(c) => chalk_ir::VariableKind::Const(c.data(Interner).ty.clone()),\n-            GenericArgData::Lifetime(_) => chalk_ir::VariableKind::Lifetime,\n-        };\n-        chalk_ir::WithKind::new(kind, UniverseIndex::ROOT)\n-    }));\n-    let tys = Canonical {\n-        binders: CanonicalVarKinds::from_iter(Interner, kinds),\n-        value: (self_ty_with_vars, self_ty.value.clone()),\n-    };\n-    let substs = super::infer::unify(db, env, &tys)?;\n-    // We only want the substs for the vars we added, not the ones from self_ty.\n-    // Also, if any of the vars we added are still in there, we replace them by\n-    // Unknown. I think this can only really happen if self_ty contained\n-    // Unknown, and in that case we want the result to contain Unknown in those\n-    // places again.\n-    let suffix =\n-        Substitution::from_iter(Interner, substs.iter(Interner).skip(self_ty_vars).cloned());\n-    Some(fallback_bound_vars(suffix, self_ty_vars))\n-}\n-\n-/// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n-/// num_vars_to_keep) by `TyKind::Unknown`.\n-pub(crate) fn fallback_bound_vars<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n-    s: T,\n-    num_vars_to_keep: usize,\n-) -> T::Result {\n-    crate::fold_free_vars(\n-        s,\n-        |bound, binders| {\n-            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-                TyKind::Error.intern(Interner)\n-            } else {\n-                bound.shifted_in_from(binders).to_ty(Interner)\n-            }\n-        },\n-        |ty, bound, binders| {\n-            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-                consteval::usize_const(None)\n-            } else {\n-                bound.shifted_in_from(binders).to_const(Interner, ty)\n-            }\n-        },\n-    )\n-}\n-\n-fn transform_receiver_ty(\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n-    function_id: FunctionId,\n-    self_ty: &Canonical<Ty>,\n-) -> Option<Ty> {\n-    let substs = match function_id.lookup(db.upcast()).container {\n-        ItemContainerId::TraitId(_) => TyBuilder::subst_for_def(db, function_id)\n-            .push(self_ty.value.clone())\n-            .fill_with_unknown()\n-            .build(),\n-        ItemContainerId::ImplId(impl_id) => {\n-            let impl_substs = inherent_impl_substs(db, env, impl_id, self_ty)?;\n-            TyBuilder::subst_for_def(db, function_id)\n-                .use_parent_substs(&impl_substs)\n-                .fill_with_unknown()\n-                .build()\n-        }\n-        // No receiver\n-        ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => unreachable!(),\n-    };\n-    let sig = db.callable_item_signature(function_id.into());\n-    Some(sig.map(|s| s.params()[0].clone()).substitute(Interner, &substs))\n-}\n-\n pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,"}, {"sha": "56b8db1319e1ae7528e257388221063dca932c33", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=dbc697cb7d87762088ea67c665b12a7a3f441ef8", "patch": "@@ -925,7 +925,6 @@ fn test() { S2.into(); }\n \n #[test]\n fn method_resolution_overloaded_method() {\n-    cov_mark::check!(impl_self_type_match_without_receiver);\n     check_types(\n         r#\"\n struct Wrapper<T>(T);\n@@ -954,6 +953,33 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn method_resolution_overloaded_const() {\n+    cov_mark::check!(const_candidate_self_type_mismatch);\n+    check_types(\n+        r#\"\n+struct Wrapper<T>(T);\n+struct Foo<T>(T);\n+struct Bar<T>(T);\n+\n+impl<T> Wrapper<Foo<T>> {\n+    pub const VALUE: Foo<T>;\n+}\n+\n+impl<T> Wrapper<Bar<T>> {\n+    pub const VALUE: Bar<T>;\n+}\n+\n+fn main() {\n+    let a = Wrapper::<Foo<f32>>::VALUE;\n+    let b = Wrapper::<Bar<f32>>::VALUE;\n+    (a, b);\n+  //^^^^^^ (Foo<f32>, Bar<f32>)\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn method_resolution_encountering_fn_type() {\n     check_types(\n@@ -1257,6 +1283,37 @@ mod b {\n     )\n }\n \n+#[test]\n+fn trait_vs_private_inherent_const() {\n+    cov_mark::check!(const_candidate_not_visible);\n+    check(\n+        r#\"\n+mod a {\n+    pub struct Foo;\n+    impl Foo {\n+        const VALUE: u32 = 2;\n+    }\n+    pub trait Trait {\n+        const VALUE: usize;\n+    }\n+    impl Trait for Foo {\n+        const VALUE: usize = 3;\n+    }\n+\n+    fn foo() {\n+        let x = Foo::VALUE;\n+            //  ^^^^^^^^^^ type: u32\n+    }\n+}\n+use a::Trait;\n+fn foo() {\n+    let x = a::Foo::VALUE;\n+         // ^^^^^^^^^^^^^ type: usize\n+}\n+\"#,\n+    )\n+}\n+\n #[test]\n fn trait_impl_in_unnamed_const() {\n     check_types("}, {"sha": "a82b8cb466fd41f54a07a6bd46fc9dfa55ce5303", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc697cb7d87762088ea67c665b12a7a3f441ef8/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=dbc697cb7d87762088ea67c665b12a7a3f441ef8", "patch": "@@ -3609,3 +3609,40 @@ fn f<F: Foo>() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn dyn_map() {\n+    check_types(\n+        r#\"\n+pub struct Key<K, V, P = (K, V)> {}\n+\n+pub trait Policy {\n+    type K;\n+    type V;\n+}\n+\n+impl<K, V> Policy for (K, V) {\n+    type K = K;\n+    type V = V;\n+}\n+\n+pub struct KeyMap<KEY> {}\n+\n+impl<P: Policy> KeyMap<Key<P::K, P::V, P>> {\n+    pub fn get(&self, key: &P::K) -> P::V {\n+        loop {}\n+    }\n+}\n+\n+struct Fn {}\n+struct FunctionId {}\n+\n+fn test() {\n+    let key_map: &KeyMap<Key<Fn, FunctionId>> = loop {};\n+    let key;\n+    let result = key_map.get(key);\n+      //^^^^^^ FunctionId\n+}\n+\"#,\n+    )\n+}"}]}