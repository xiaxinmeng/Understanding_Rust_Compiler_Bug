{"sha": "11c2023ef534f037ba492a0725bfff9b1c315cdb", "node_id": "C_kwDOAAsO6NoAKDExYzIwMjNlZjUzNGYwMzdiYTQ5MmEwNzI1YmZmZjliMWMzMTVjZGI", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2021-09-28T00:35:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-28T00:35:45Z"}, "message": "Fix/count trailing zeroes (#95)\n\n* Fix count trailing zeroes\r\n* Fix pop count\r\n* Fix bit reverse", "tree": {"sha": "2bcdd30083ea9f832ac3f53621f0c5603b9c4b7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bcdd30083ea9f832ac3f53621f0c5603b9c4b7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11c2023ef534f037ba492a0725bfff9b1c315cdb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhUmNhCRBK7hj4Ov3rIwAAUHwIADlPJPNpKzGC8tUZ/7oMq0KV\nkYWjckoUjdY8huMu5MuFTWn627YBxZqIcBUcdTpX2WEouA8sX2BUzmEA6pxIWEfq\nHrNLrXAN+IxOf8MxyUkWTGG5HR6n6MA9xife/zhK2MWo1JafebDZUSCdpOHiWge+\nquPVmHC7Qh6Y50QV3MEaO2uFBd3lSqbGzpQ8Dtkf12+NORsL08oOaJQFgZJMAKZI\nZa9zqsHu8v9Hgx9liuoOsBn6znPLZIwpBYxUtw3u7ph/4eAbZJ+ldpLLN6HmPCRb\ncFspPeizgNVBHJ2k9whiDWlcsVUpADQH9BU8kgtHzLw2oFwaNZlY4ya5HDxcXqw=\n=NTSh\n-----END PGP SIGNATURE-----\n", "payload": "tree 2bcdd30083ea9f832ac3f53621f0c5603b9c4b7b\nparent 63608ac6b34fedfd6b7b8da42805b1f798595e57\nauthor antoyo <antoyo@users.noreply.github.com> 1632789345 -0400\ncommitter GitHub <noreply@github.com> 1632789345 -0400\n\nFix/count trailing zeroes (#95)\n\n* Fix count trailing zeroes\r\n* Fix pop count\r\n* Fix bit reverse"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11c2023ef534f037ba492a0725bfff9b1c315cdb", "html_url": "https://github.com/rust-lang/rust/commit/11c2023ef534f037ba492a0725bfff9b1c315cdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11c2023ef534f037ba492a0725bfff9b1c315cdb/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63608ac6b34fedfd6b7b8da42805b1f798595e57", "url": "https://api.github.com/repos/rust-lang/rust/commits/63608ac6b34fedfd6b7b8da42805b1f798595e57", "html_url": "https://github.com/rust-lang/rust/commit/63608ac6b34fedfd6b7b8da42805b1f798595e57"}], "stats": {"total": 378, "additions": 216, "deletions": 162}, "files": [{"sha": "bda08b653f05929fc35a58d273a80fdc20c728ae", "filename": "src/common.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/11c2023ef534f037ba492a0725bfff9b1c315cdb/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11c2023ef534f037ba492a0725bfff9b1c315cdb/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=11c2023ef534f037ba492a0725bfff9b1c315cdb", "patch": "@@ -302,6 +302,7 @@ pub trait SignType<'gcc, 'tcx> {\n     fn is_signed(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn is_unsigned(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn to_signed(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n+    fn to_unsigned(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n }\n \n impl<'gcc, 'tcx> SignType<'gcc, 'tcx> for Type<'gcc> {\n@@ -333,6 +334,27 @@ impl<'gcc, 'tcx> SignType<'gcc, 'tcx> for Type<'gcc> {\n             self.clone()\n         }\n     }\n+\n+    fn to_unsigned(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n+        if self.is_i8(cx) {\n+            cx.u8_type\n+        }\n+        else if self.is_i16(cx) {\n+            cx.u16_type\n+        }\n+        else if self.is_i32(cx) {\n+            cx.u32_type\n+        }\n+        else if self.is_i64(cx) {\n+            cx.u64_type\n+        }\n+        else if self.is_i128(cx) {\n+            cx.u128_type\n+        }\n+        else {\n+            self.clone()\n+        }\n+    }\n }\n \n pub trait TypeReflection<'gcc, 'tcx>  {"}, {"sha": "45978e1409023ebd08435c0acbc099cc0bd44dd3", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 194, "deletions": 162, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/11c2023ef534f037ba492a0725bfff9b1c315cdb/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11c2023ef534f037ba492a0725bfff9b1c315cdb/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=11c2023ef534f037ba492a0725bfff9b1c315cdb", "patch": "@@ -18,7 +18,7 @@ use rustc_target::spec::PanicStrategy;\n \n use crate::abi::GccType;\n use crate::builder::Builder;\n-use crate::common::TypeReflection;\n+use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n use crate::intrinsic::simd::generic_simd_intrinsic;\n@@ -520,163 +520,176 @@ fn int_type_width_signed<'gcc, 'tcx>(ty: Ty<'tcx>, cx: &CodegenCx<'gcc, 'tcx>) -\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     fn bit_reverse(&mut self, width: u64, value: RValue<'gcc>) -> RValue<'gcc> {\n-        let typ = value.get_type();\n+        let result_type = value.get_type();\n+        let typ = result_type.to_unsigned(self.cx);\n+\n+        let value =\n+            if result_type.is_signed(self.cx) {\n+                self.context.new_bitcast(None, value, typ)\n+            }\n+            else {\n+                value\n+            };\n+\n         let context = &self.cx.context;\n-        match width {\n-            8 => {\n-                // First step.\n-                let left = self.and(value, context.new_rvalue_from_int(typ, 0xF0));\n-                let left = self.lshr(left, context.new_rvalue_from_int(typ, 4));\n-                let right = self.and(value, context.new_rvalue_from_int(typ, 0x0F));\n-                let right = self.shl(right, context.new_rvalue_from_int(typ, 4));\n-                let step1 = self.or(left, right);\n-\n-                // Second step.\n-                let left = self.and(step1, context.new_rvalue_from_int(typ, 0xCC));\n-                let left = self.lshr(left, context.new_rvalue_from_int(typ, 2));\n-                let right = self.and(step1, context.new_rvalue_from_int(typ, 0x33));\n-                let right = self.shl(right, context.new_rvalue_from_int(typ, 2));\n-                let step2 = self.or(left, right);\n-\n-                // Third step.\n-                let left = self.and(step2, context.new_rvalue_from_int(typ, 0xAA));\n-                let left = self.lshr(left, context.new_rvalue_from_int(typ, 1));\n-                let right = self.and(step2, context.new_rvalue_from_int(typ, 0x55));\n-                let right = self.shl(right, context.new_rvalue_from_int(typ, 1));\n-                let step3 = self.or(left, right);\n-\n-                step3\n-            },\n-            16 => {\n-                // First step.\n-                let left = self.and(value, context.new_rvalue_from_int(typ, 0x5555));\n-                let left = self.shl(left, context.new_rvalue_from_int(typ, 1));\n-                let right = self.and(value, context.new_rvalue_from_int(typ, 0xAAAA));\n-                let right = self.lshr(right, context.new_rvalue_from_int(typ, 1));\n-                let step1 = self.or(left, right);\n-\n-                // Second step.\n-                let left = self.and(step1, context.new_rvalue_from_int(typ, 0x3333));\n-                let left = self.shl(left, context.new_rvalue_from_int(typ, 2));\n-                let right = self.and(step1, context.new_rvalue_from_int(typ, 0xCCCC));\n-                let right = self.lshr(right, context.new_rvalue_from_int(typ, 2));\n-                let step2 = self.or(left, right);\n-\n-                // Third step.\n-                let left = self.and(step2, context.new_rvalue_from_int(typ, 0x0F0F));\n-                let left = self.shl(left, context.new_rvalue_from_int(typ, 4));\n-                let right = self.and(step2, context.new_rvalue_from_int(typ, 0xF0F0));\n-                let right = self.lshr(right, context.new_rvalue_from_int(typ, 4));\n-                let step3 = self.or(left, right);\n-\n-                // Fourth step.\n-                let left = self.and(step3, context.new_rvalue_from_int(typ, 0x00FF));\n-                let left = self.shl(left, context.new_rvalue_from_int(typ, 8));\n-                let right = self.and(step3, context.new_rvalue_from_int(typ, 0xFF00));\n-                let right = self.lshr(right, context.new_rvalue_from_int(typ, 8));\n-                let step4 = self.or(left, right);\n-\n-                step4\n-            },\n-            32 => {\n-                // TODO(antoyo): Refactor with other implementations.\n-                // First step.\n-                let left = self.and(value, context.new_rvalue_from_long(typ, 0x55555555));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 1));\n-                let right = self.and(value, context.new_rvalue_from_long(typ, 0xAAAAAAAA));\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 1));\n-                let step1 = self.or(left, right);\n-\n-                // Second step.\n-                let left = self.and(step1, context.new_rvalue_from_long(typ, 0x33333333));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 2));\n-                let right = self.and(step1, context.new_rvalue_from_long(typ, 0xCCCCCCCC));\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 2));\n-                let step2 = self.or(left, right);\n-\n-                // Third step.\n-                let left = self.and(step2, context.new_rvalue_from_long(typ, 0x0F0F0F0F));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 4));\n-                let right = self.and(step2, context.new_rvalue_from_long(typ, 0xF0F0F0F0));\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 4));\n-                let step3 = self.or(left, right);\n-\n-                // Fourth step.\n-                let left = self.and(step3, context.new_rvalue_from_long(typ, 0x00FF00FF));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 8));\n-                let right = self.and(step3, context.new_rvalue_from_long(typ, 0xFF00FF00));\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 8));\n-                let step4 = self.or(left, right);\n-\n-                // Fifth step.\n-                let left = self.and(step4, context.new_rvalue_from_long(typ, 0x0000FFFF));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 16));\n-                let right = self.and(step4, context.new_rvalue_from_long(typ, 0xFFFF0000));\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 16));\n-                let step5 = self.or(left, right);\n-\n-                step5\n-            },\n-            64 => {\n-                // First step.\n-                let left = self.shl(value, context.new_rvalue_from_long(typ, 32));\n-                let right = self.lshr(value, context.new_rvalue_from_long(typ, 32));\n-                let step1 = self.or(left, right);\n-\n-                // Second step.\n-                let left = self.and(step1, context.new_rvalue_from_long(typ, 0x0001FFFF0001FFFF));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 15));\n-                let right = self.and(step1, context.new_rvalue_from_long(typ, 0xFFFE0000FFFE0000u64 as i64)); // TODO(antoyo): transmute the number instead?\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 17));\n-                let step2 = self.or(left, right);\n-\n-                // Third step.\n-                let left = self.lshr(step2, context.new_rvalue_from_long(typ, 10));\n-                let left = self.xor(step2, left);\n-                let temp = self.and(left, context.new_rvalue_from_long(typ, 0x003F801F003F801F));\n-\n-                let left = self.shl(temp, context.new_rvalue_from_long(typ, 10));\n-                let left = self.or(temp, left);\n-                let step3 = self.xor(left, step2);\n-\n-                // Fourth step.\n-                let left = self.lshr(step3, context.new_rvalue_from_long(typ, 4));\n-                let left = self.xor(step3, left);\n-                let temp = self.and(left, context.new_rvalue_from_long(typ, 0x0E0384210E038421));\n-\n-                let left = self.shl(temp, context.new_rvalue_from_long(typ, 4));\n-                let left = self.or(temp, left);\n-                let step4 = self.xor(left, step3);\n-\n-                // Fifth step.\n-                let left = self.lshr(step4, context.new_rvalue_from_long(typ, 2));\n-                let left = self.xor(step4, left);\n-                let temp = self.and(left, context.new_rvalue_from_long(typ, 0x2248884222488842));\n-\n-                let left = self.shl(temp, context.new_rvalue_from_long(typ, 2));\n-                let left = self.or(temp, left);\n-                let step5 = self.xor(left, step4);\n-\n-                step5\n-            },\n-            128 => {\n-                // TODO(antoyo): find a more efficient implementation?\n-                let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n-                let high = self.context.new_cast(None, value >> sixty_four, self.u64_type);\n-                let low = self.context.new_cast(None, value, self.u64_type);\n+        let result =\n+            match width {\n+                8 => {\n+                    // First step.\n+                    let left = self.and(value, context.new_rvalue_from_int(typ, 0xF0));\n+                    let left = self.lshr(left, context.new_rvalue_from_int(typ, 4));\n+                    let right = self.and(value, context.new_rvalue_from_int(typ, 0x0F));\n+                    let right = self.shl(right, context.new_rvalue_from_int(typ, 4));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_int(typ, 0xCC));\n+                    let left = self.lshr(left, context.new_rvalue_from_int(typ, 2));\n+                    let right = self.and(step1, context.new_rvalue_from_int(typ, 0x33));\n+                    let right = self.shl(right, context.new_rvalue_from_int(typ, 2));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.and(step2, context.new_rvalue_from_int(typ, 0xAA));\n+                    let left = self.lshr(left, context.new_rvalue_from_int(typ, 1));\n+                    let right = self.and(step2, context.new_rvalue_from_int(typ, 0x55));\n+                    let right = self.shl(right, context.new_rvalue_from_int(typ, 1));\n+                    let step3 = self.or(left, right);\n+\n+                    step3\n+                },\n+                16 => {\n+                    // First step.\n+                    let left = self.and(value, context.new_rvalue_from_int(typ, 0x5555));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 1));\n+                    let right = self.and(value, context.new_rvalue_from_int(typ, 0xAAAA));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 1));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_int(typ, 0x3333));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 2));\n+                    let right = self.and(step1, context.new_rvalue_from_int(typ, 0xCCCC));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 2));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.and(step2, context.new_rvalue_from_int(typ, 0x0F0F));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 4));\n+                    let right = self.and(step2, context.new_rvalue_from_int(typ, 0xF0F0));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 4));\n+                    let step3 = self.or(left, right);\n+\n+                    // Fourth step.\n+                    let left = self.and(step3, context.new_rvalue_from_int(typ, 0x00FF));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 8));\n+                    let right = self.and(step3, context.new_rvalue_from_int(typ, 0xFF00));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 8));\n+                    let step4 = self.or(left, right);\n+\n+                    step4\n+                },\n+                32 => {\n+                    // TODO(antoyo): Refactor with other implementations.\n+                    // First step.\n+                    let left = self.and(value, context.new_rvalue_from_long(typ, 0x55555555));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 1));\n+                    let right = self.and(value, context.new_rvalue_from_long(typ, 0xAAAAAAAA));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 1));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_long(typ, 0x33333333));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 2));\n+                    let right = self.and(step1, context.new_rvalue_from_long(typ, 0xCCCCCCCC));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 2));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.and(step2, context.new_rvalue_from_long(typ, 0x0F0F0F0F));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 4));\n+                    let right = self.and(step2, context.new_rvalue_from_long(typ, 0xF0F0F0F0));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 4));\n+                    let step3 = self.or(left, right);\n+\n+                    // Fourth step.\n+                    let left = self.and(step3, context.new_rvalue_from_long(typ, 0x00FF00FF));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 8));\n+                    let right = self.and(step3, context.new_rvalue_from_long(typ, 0xFF00FF00));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 8));\n+                    let step4 = self.or(left, right);\n+\n+                    // Fifth step.\n+                    let left = self.and(step4, context.new_rvalue_from_long(typ, 0x0000FFFF));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 16));\n+                    let right = self.and(step4, context.new_rvalue_from_long(typ, 0xFFFF0000));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 16));\n+                    let step5 = self.or(left, right);\n+\n+                    step5\n+                },\n+                64 => {\n+                    // First step.\n+                    let left = self.shl(value, context.new_rvalue_from_long(typ, 32));\n+                    let right = self.lshr(value, context.new_rvalue_from_long(typ, 32));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_long(typ, 0x0001FFFF0001FFFF));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 15));\n+                    let right = self.and(step1, context.new_rvalue_from_long(typ, 0xFFFE0000FFFE0000u64 as i64)); // TODO(antoyo): transmute the number instead?\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 17));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.lshr(step2, context.new_rvalue_from_long(typ, 10));\n+                    let left = self.xor(step2, left);\n+                    let temp = self.and(left, context.new_rvalue_from_long(typ, 0x003F801F003F801F));\n+\n+                    let left = self.shl(temp, context.new_rvalue_from_long(typ, 10));\n+                    let left = self.or(temp, left);\n+                    let step3 = self.xor(left, step2);\n+\n+                    // Fourth step.\n+                    let left = self.lshr(step3, context.new_rvalue_from_long(typ, 4));\n+                    let left = self.xor(step3, left);\n+                    let temp = self.and(left, context.new_rvalue_from_long(typ, 0x0E0384210E038421));\n+\n+                    let left = self.shl(temp, context.new_rvalue_from_long(typ, 4));\n+                    let left = self.or(temp, left);\n+                    let step4 = self.xor(left, step3);\n+\n+                    // Fifth step.\n+                    let left = self.lshr(step4, context.new_rvalue_from_long(typ, 2));\n+                    let left = self.xor(step4, left);\n+                    let temp = self.and(left, context.new_rvalue_from_long(typ, 0x2248884222488842));\n+\n+                    let left = self.shl(temp, context.new_rvalue_from_long(typ, 2));\n+                    let left = self.or(temp, left);\n+                    let step5 = self.xor(left, step4);\n+\n+                    step5\n+                },\n+                128 => {\n+                    // TODO(antoyo): find a more efficient implementation?\n+                    let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n+                    let high = self.context.new_cast(None, value >> sixty_four, self.u64_type);\n+                    let low = self.context.new_cast(None, value, self.u64_type);\n \n-                let reversed_high = self.bit_reverse(64, high);\n-                let reversed_low = self.bit_reverse(64, low);\n+                    let reversed_high = self.bit_reverse(64, high);\n+                    let reversed_low = self.bit_reverse(64, low);\n \n-                let new_low = self.context.new_cast(None, reversed_high, typ);\n-                let new_high = self.context.new_cast(None, reversed_low, typ) << sixty_four;\n+                    let new_low = self.context.new_cast(None, reversed_high, typ);\n+                    let new_high = self.context.new_cast(None, reversed_low, typ) << sixty_four;\n \n-                new_low | new_high\n-            },\n-            _ => {\n-                panic!(\"cannot bit reverse with width = {}\", width);\n-            },\n-        }\n+                    new_low | new_high\n+                },\n+                _ => {\n+                    panic!(\"cannot bit reverse with width = {}\", width);\n+                },\n+            };\n+\n+        self.context.new_bitcast(None, result, result_type)\n     }\n \n     fn count_leading_zeroes(&self, width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n@@ -746,6 +759,15 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn count_trailing_zeroes(&self, _width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n+        let result_type = arg.get_type();\n+        let arg =\n+            if result_type.is_signed(self.cx) {\n+                let new_type = result_type.to_unsigned(self.cx);\n+                self.context.new_bitcast(None, arg, new_type)\n+            }\n+            else {\n+                arg\n+            };\n         let arg_type = arg.get_type();\n         let (count_trailing_zeroes, expected_type) =\n             if arg_type.is_uchar(&self.cx) || arg_type.is_ushort(&self.cx) || arg_type.is_uint(&self.cx) {\n@@ -796,7 +818,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let res = self.context.new_array_access(None, result, index);\n \n-                return self.context.new_cast(None, res, arg_type);\n+                return self.context.new_bitcast(None, res, result_type);\n             }\n             else {\n                 unimplemented!(\"count_trailing_zeroes for {:?}\", arg_type);\n@@ -810,7 +832,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 arg\n             };\n         let res = self.context.new_call(None, count_trailing_zeroes, &[arg]);\n-        self.context.new_cast(None, res, arg_type)\n+        self.context.new_bitcast(None, res, result_type)\n     }\n \n     fn int_width(&self, typ: Type<'gcc>) -> i64 {\n@@ -819,7 +841,16 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n     fn pop_count(&self, value: RValue<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): use the optimized version with fewer operations.\n-        let value_type = value.get_type();\n+        let result_type = value.get_type();\n+        let value_type = result_type.to_unsigned(self.cx);\n+\n+        let value =\n+            if result_type.is_signed(self.cx) {\n+                self.context.new_bitcast(None, value, value_type)\n+            }\n+            else {\n+                value\n+            };\n \n         if value_type.is_u128(&self.cx) {\n             // TODO(antoyo): implement in the normal algorithm below to have a more efficient\n@@ -830,7 +861,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             let high = self.context.new_call(None, popcount, &[high]);\n             let low = self.context.new_cast(None, value, self.cx.ulonglong_type);\n             let low = self.context.new_call(None, popcount, &[low]);\n-            return high + low;\n+            let res = high + low;\n+            return self.context.new_bitcast(None, res, result_type);\n         }\n \n         // First step.\n@@ -855,7 +887,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u8(&self.cx) {\n-            return value;\n+            return self.context.new_bitcast(None, value, result_type);\n         }\n \n         // Fourth step.\n@@ -866,7 +898,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u16(&self.cx) {\n-            return value;\n+            return self.context.new_bitcast(None, value, result_type);\n         }\n \n         // Fifth step.\n@@ -877,7 +909,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u32(&self.cx) {\n-            return value;\n+            return self.context.new_bitcast(None, value, result_type);\n         }\n \n         // Sixth step.\n@@ -887,7 +919,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let right = shifted & mask;\n         let value = left + right;\n \n-        value\n+        self.context.new_bitcast(None, value, result_type)\n     }\n \n     // Algorithm from: https://blog.regehr.org/archives/1063"}]}