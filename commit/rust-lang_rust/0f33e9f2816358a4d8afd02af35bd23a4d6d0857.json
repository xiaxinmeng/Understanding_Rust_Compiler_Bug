{"sha": "0f33e9f2816358a4d8afd02af35bd23a4d6d0857", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMzNlOWYyODE2MzU4YTRkOGFmZDAyYWYzNWJkMjNhNGQ2ZDA4NTc=", "commit": {"author": {"name": "katelyn a. martin", "email": "me+rustlang@katelyn.world", "date": "2020-09-10T17:38:39Z"}, "committer": {"name": "katelyn a. martin", "email": "me+rustlang@katelyn.world", "date": "2021-03-09T19:38:29Z"}, "message": "implement unwinding abi's (RFC 2945)\n\n ### Changes\n\n    This commit implements unwind ABI's, specified in RFC 2945.\n\n    We adjust the `rustc_middle::ty::layout::fn_can_unwind` function,\n    used to compute whether or not a `FnAbi` object represents a\n    function that should be able to unwind when `panic=unwind` is in\n    use.\n\n    Changes are also made to\n    `rustc_mir_build::build::should_abort_on_panic` so that the\n    function ABI is used to determind whether it should abort, assuming\n    that the `panic=unwind` strategy is being used, and no explicit\n    unwind attribute was provided.\n\n ### Tests\n\n    Unit tests, checking that the behavior is correct for `C-unwind`,\n    `stdcall-unwind`, `system-unwind`, and `thiscall-unwind`, are\n    included. These alternative `unwind` ABI strings are specified in\n    RFC 2945, in the \"_Other `unwind` ABI strings_\" section.\n\n    Additionally, a test case is included to assert that the LLVM IR\n    generated for an external function defined with the `C-unwind` ABI\n    will be appropriately labeled with the `nounwind` LLVM attribute\n    when the `panic=abort` compilation flag is used.\n\n ### Ignore Directives\n\n    This commit uses `ignore-*` directives in two of our `*-unwind` ABI\n    test cases.\n\n    Specifically, the `stdcall-unwind` and `thiscall-unwind` test cases\n    ignore architectures that do not support `stdcall` and `thiscall`,\n    respectively.\n\n    These directives are cribbed from\n    `src/test/ui/c-variadic/variadic-ffi-1.rs` for `stdcall`, and\n    `src/test/ui/extern/extern-thiscall.rs` for `thiscall`.", "tree": {"sha": "289cdca5b191592de5c16a8cadf88ee4c31849c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/289cdca5b191592de5c16a8cadf88ee4c31849c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f33e9f2816358a4d8afd02af35bd23a4d6d0857", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f33e9f2816358a4d8afd02af35bd23a4d6d0857", "html_url": "https://github.com/rust-lang/rust/commit/0f33e9f2816358a4d8afd02af35bd23a4d6d0857", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/comments", "author": null, "committer": null, "parents": [{"sha": "df45c579de97777617b6f12c77a5e6224f54c897", "url": "https://api.github.com/repos/rust-lang/rust/commits/df45c579de97777617b6f12c77a5e6224f54c897", "html_url": "https://github.com/rust-lang/rust/commit/df45c579de97777617b6f12c77a5e6224f54c897"}], "stats": {"total": 192, "additions": 176, "deletions": 16}, "files": [{"sha": "ee2dffd8baeb9e7defe59a16ce167ebff6da87d2", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=0f33e9f2816358a4d8afd02af35bd23a4d6d0857", "patch": "@@ -2562,6 +2562,7 @@ fn fn_can_unwind(\n     panic_strategy: PanicStrategy,\n     codegen_fn_attr_flags: CodegenFnAttrFlags,\n     call_conv: Conv,\n+    abi: SpecAbi,\n ) -> bool {\n     if panic_strategy != PanicStrategy::Unwind {\n         // In panic=abort mode we assume nothing can unwind anywhere, so\n@@ -2586,17 +2587,16 @@ fn fn_can_unwind(\n             //\n             //  2. A Rust item using a non-Rust ABI (like `extern \"C\" fn foo() { ... }`).\n             //\n-            // Foreign items (case 1) are assumed to not unwind; it is\n-            // UB otherwise. (At least for now; see also\n-            // rust-lang/rust#63909 and Rust RFC 2753.)\n-            //\n-            // Items defined in Rust with non-Rust ABIs (case 2) are also\n-            // not supposed to unwind. Whether this should be enforced\n-            // (versus stating it is UB) and *how* it would be enforced\n-            // is currently under discussion; see rust-lang/rust#58794.\n-            //\n-            // In either case, we mark item as explicitly nounwind.\n-            false\n+            // In both of these cases, we should refer to the ABI to determine whether or not we\n+            // should unwind. See Rust RFC 2945 for more information on this behavior, here:\n+            // https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md\n+            use SpecAbi::*;\n+            match abi {\n+                C { unwind } | Stdcall { unwind } | System { unwind } | Thiscall { unwind } => {\n+                    unwind\n+                }\n+                _ => false,\n+            }\n         }\n     }\n }\n@@ -2823,7 +2823,12 @@ where\n             c_variadic: sig.c_variadic,\n             fixed_count: inputs.len(),\n             conv,\n-            can_unwind: fn_can_unwind(cx.tcx().sess.panic_strategy(), codegen_fn_attr_flags, conv),\n+            can_unwind: fn_can_unwind(\n+                cx.tcx().sess.panic_strategy(),\n+                codegen_fn_attr_flags,\n+                conv,\n+                sig.abi,\n+            ),\n         };\n         fn_abi.adjust_for_abi(cx, sig.abi);\n         debug!(\"FnAbi::new_internal = {:?}\", fn_abi);"}, {"sha": "dd9c859544f61f7aa6548725ce09e524680503ae", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=0f33e9f2816358a4d8afd02af35bd23a4d6d0857", "patch": "@@ -548,7 +548,7 @@ macro_rules! unpack {\n     }};\n }\n \n-fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: LocalDefId, _abi: Abi) -> bool {\n+fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: LocalDefId, abi: Abi) -> bool {\n     // Validate `#[unwind]` syntax regardless of platform-specific panic strategy.\n     let attrs = &tcx.get_attrs(fn_def_id.to_def_id());\n     let unwind_attr = attr::find_unwind_attr(&tcx.sess, attrs);\n@@ -558,12 +558,26 @@ fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: LocalDefId, _abi: Abi) -> b\n         return false;\n     }\n \n-    // This is a special case: some functions have a C abi but are meant to\n-    // unwind anyway. Don't stop them.\n     match unwind_attr {\n-        None => false, // FIXME(#58794); should be `!(abi == Abi::Rust || abi == Abi::RustCall)`\n+        // If an `#[unwind]` attribute was found, we should adhere to it.\n         Some(UnwindAttr::Allowed) => false,\n         Some(UnwindAttr::Aborts) => true,\n+        // If no attribute was found and the panic strategy is `unwind`, then we should examine\n+        // the function's ABI string to determine whether it should abort upon panic.\n+        None => {\n+            use Abi::*;\n+            match abi {\n+                // In the case of ABI's that have an `-unwind` equivalent, check whether the ABI\n+                // permits unwinding. If so, we should not abort. Otherwise, we should.\n+                C { unwind } | Stdcall { unwind } | System { unwind } | Thiscall { unwind } => {\n+                    !unwind\n+                }\n+                // Rust and `rust-call` functions are allowed to unwind, and should not abort.\n+                Rust | RustCall => false,\n+                // Other ABI's should abort.\n+                _ => true,\n+            }\n+        }\n     }\n }\n "}, {"sha": "afd65ff6741a654e62669b7a148fe6a28d40a4eb", "filename": "src/test/codegen/unwind-abis/c-unwind-abi-panic-abort.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi-panic-abort.rs?ref=0f33e9f2816358a4d8afd02af35bd23a4d6d0857", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: -C panic=abort -C opt-level=0\n+\n+// Test that `nounwind` atributes are applied to `C-unwind` extern functions when the\n+// code is compiled with `panic=abort`.  We disable optimizations above to prevent LLVM from\n+// inferring the attribute.\n+\n+#![crate_type = \"lib\"]\n+#![feature(c_unwind)]\n+\n+// CHECK: @rust_item_that_can_unwind() unnamed_addr #0 {\n+#[no_mangle]\n+pub extern \"C-unwind\" fn rust_item_that_can_unwind() {\n+}\n+\n+// Now, make sure that the LLVM attributes for this functions are correct.  First, make\n+// sure that the first item is correctly marked with the `nounwind` attribute:\n+//\n+// CHECK: attributes #0 = { {{.*}}nounwind{{.*}} }"}, {"sha": "f15765367532261eca351376d3d45337b642e023", "filename": "src/test/codegen/unwind-abis/c-unwind-abi.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi.rs?ref=0f33e9f2816358a4d8afd02af35bd23a4d6d0857", "patch": "@@ -0,0 +1,29 @@\n+// compile-flags: -C opt-level=0\n+\n+// Test that `nounwind` atributes are correctly applied to exported `C` and `C-unwind` extern\n+// functions. `C-unwind` functions MUST NOT have this attribute. We disable optimizations above\n+// to prevent LLVM from inferring the attribute.\n+\n+#![crate_type = \"lib\"]\n+#![feature(c_unwind)]\n+\n+// CHECK: @rust_item_that_cannot_unwind() unnamed_addr #0 {\n+#[no_mangle]\n+pub extern \"C\" fn rust_item_that_cannot_unwind() {\n+}\n+\n+// CHECK: @rust_item_that_can_unwind() unnamed_addr #1 {\n+#[no_mangle]\n+pub extern \"C-unwind\" fn rust_item_that_can_unwind() {\n+}\n+\n+// Now, make some assertions that the LLVM attributes for these functions are correct.  First, make\n+// sure that the first item is correctly marked with the `nounwind` attribute:\n+//\n+// CHECK: attributes #0 = { {{.*}}nounwind{{.*}} }\n+//\n+// Next, let's assert that the second item, which CAN unwind, does not have this attribute.\n+//\n+// CHECK: attributes #1 = {\n+// CHECK-NOT: nounwind\n+// CHECK: }"}, {"sha": "ed804ca278d2de5e4120eae497a325668919d105", "filename": "src/test/codegen/unwind-abis/stdcall-unwind-abi.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/src%2Ftest%2Fcodegen%2Funwind-abis%2Fstdcall-unwind-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/src%2Ftest%2Fcodegen%2Funwind-abis%2Fstdcall-unwind-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-abis%2Fstdcall-unwind-abi.rs?ref=0f33e9f2816358a4d8afd02af35bd23a4d6d0857", "patch": "@@ -0,0 +1,32 @@\n+// compile-flags: -C opt-level=0\n+// ignore-arm stdcall isn't supported\n+// ignore-aarch64 stdcall isn't supported\n+// ignore-riscv64 stdcall isn't supported\n+\n+// Test that `nounwind` atributes are correctly applied to exported `stdcall` and `stdcall-unwind`\n+// extern functions. `stdcall-unwind` functions MUST NOT have this attribute. We disable\n+// optimizations above to prevent LLVM from inferring the attribute.\n+\n+#![crate_type = \"lib\"]\n+#![feature(c_unwind)]\n+\n+// CHECK: @rust_item_that_cannot_unwind() unnamed_addr #0 {\n+#[no_mangle]\n+pub extern \"stdcall\" fn rust_item_that_cannot_unwind() {\n+}\n+\n+// CHECK: @rust_item_that_can_unwind() unnamed_addr #1 {\n+#[no_mangle]\n+pub extern \"stdcall-unwind\" fn rust_item_that_can_unwind() {\n+}\n+\n+// Now, make some assertions that the LLVM attributes for these functions are correct.  First, make\n+// sure that the first item is correctly marked with the `nounwind` attribute:\n+//\n+// CHECK: attributes #0 = { {{.*}}nounwind{{.*}} }\n+//\n+// Next, let's assert that the second item, which CAN unwind, does not have this attribute.\n+//\n+// CHECK: attributes #1 = {\n+// CHECK-NOT: nounwind\n+// CHECK: }"}, {"sha": "c4d51328352c06ca138f792ad2734913258244e3", "filename": "src/test/codegen/unwind-abis/system-unwind-abi.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/src%2Ftest%2Fcodegen%2Funwind-abis%2Fsystem-unwind-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/src%2Ftest%2Fcodegen%2Funwind-abis%2Fsystem-unwind-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-abis%2Fsystem-unwind-abi.rs?ref=0f33e9f2816358a4d8afd02af35bd23a4d6d0857", "patch": "@@ -0,0 +1,29 @@\n+// compile-flags: -C opt-level=0\n+\n+// Test that `nounwind` atributes are correctly applied to exported `system` and `system-unwind`\n+// extern functions. `system-unwind` functions MUST NOT have this attribute. We disable\n+// optimizations above to prevent LLVM from inferring the attribute.\n+\n+#![crate_type = \"lib\"]\n+#![feature(c_unwind)]\n+\n+// CHECK: @rust_item_that_cannot_unwind() unnamed_addr #0 {\n+#[no_mangle]\n+pub extern \"system\" fn rust_item_that_cannot_unwind() {\n+}\n+\n+// CHECK: @rust_item_that_can_unwind() unnamed_addr #1 {\n+#[no_mangle]\n+pub extern \"system-unwind\" fn rust_item_that_can_unwind() {\n+}\n+\n+// Now, make some assertions that the LLVM attributes for these functions are correct.  First, make\n+// sure that the first item is correctly marked with the `nounwind` attribute:\n+//\n+// CHECK: attributes #0 = { {{.*}}nounwind{{.*}} }\n+//\n+// Next, let's assert that the second item, which CAN unwind, does not have this attribute.\n+//\n+// CHECK: attributes #1 = {\n+// CHECK-NOT: nounwind\n+// CHECK: }"}, {"sha": "aaa63ae55c3acc756e0ecad00db8815128fac75c", "filename": "src/test/codegen/unwind-abis/thiscall-unwind-abi.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/src%2Ftest%2Fcodegen%2Funwind-abis%2Fthiscall-unwind-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f33e9f2816358a4d8afd02af35bd23a4d6d0857/src%2Ftest%2Fcodegen%2Funwind-abis%2Fthiscall-unwind-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-abis%2Fthiscall-unwind-abi.rs?ref=0f33e9f2816358a4d8afd02af35bd23a4d6d0857", "patch": "@@ -0,0 +1,33 @@\n+// compile-flags: -C opt-level=0\n+// ignore-arm thiscall isn't supported\n+// ignore-aarch64 thiscall isn't supported\n+// ignore-riscv64 thiscall isn't supported\n+\n+// Test that `nounwind` atributes are correctly applied to exported `thiscall` and\n+// `thiscall-unwind` extern functions. `thiscall-unwind` functions MUST NOT have this attribute. We\n+// disable optimizations above to prevent LLVM from inferring the attribute.\n+\n+#![crate_type = \"lib\"]\n+#![feature(abi_thiscall)]\n+#![feature(c_unwind)]\n+\n+// CHECK: @rust_item_that_cannot_unwind() unnamed_addr #0 {\n+#[no_mangle]\n+pub extern \"thiscall\" fn rust_item_that_cannot_unwind() {\n+}\n+\n+// CHECK: @rust_item_that_can_unwind() unnamed_addr #1 {\n+#[no_mangle]\n+pub extern \"thiscall-unwind\" fn rust_item_that_can_unwind() {\n+}\n+\n+// Now, make some assertions that the LLVM attributes for these functions are correct.  First, make\n+// sure that the first item is correctly marked with the `nounwind` attribute:\n+//\n+// CHECK: attributes #0 = { {{.*}}nounwind{{.*}} }\n+//\n+// Next, let's assert that the second item, which CAN unwind, does not have this attribute.\n+//\n+// CHECK: attributes #1 = {\n+// CHECK-NOT: nounwind\n+// CHECK: }"}]}