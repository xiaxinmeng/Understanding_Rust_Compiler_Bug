{"sha": "fa0cdaa63f575c81c7cc87239f7dfcc677362c78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMGNkYWE2M2Y1NzVjODFjN2NjODcyMzlmN2RmY2M2NzczNjJjNzg=", "commit": {"author": {"name": "Felix Raimundo", "email": "felix.raimundo@tweag.io", "date": "2017-05-07T16:55:20Z"}, "committer": {"name": "Felix Raimundo", "email": "felix.raimundo@tweag.io", "date": "2017-05-07T17:10:44Z"}, "message": "Inline `thread::park` documentation.\n\nPart of #29378\n\n- Moves the module documentation into `park`.\n- Add the same example as the one from `unpark` to `park`.", "tree": {"sha": "b961cb71dd708b0a2295d9cf8c53214c0e71a7d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b961cb71dd708b0a2295d9cf8c53214c0e71a7d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa0cdaa63f575c81c7cc87239f7dfcc677362c78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa0cdaa63f575c81c7cc87239f7dfcc677362c78", "html_url": "https://github.com/rust-lang/rust/commit/fa0cdaa63f575c81c7cc87239f7dfcc677362c78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa0cdaa63f575c81c7cc87239f7dfcc677362c78/comments", "author": null, "committer": null, "parents": [{"sha": "c0d475ad7b44c153b4999709ff08a9275160ea1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0d475ad7b44c153b4999709ff08a9275160ea1c", "html_url": "https://github.com/rust-lang/rust/commit/c0d475ad7b44c153b4999709ff08a9275160ea1c"}], "stats": {"total": 114, "additions": 62, "deletions": 52}, "files": [{"sha": "5373bf273d4dee7ceb89bd115e8dd478eab64fa2", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 62, "deletions": 52, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/fa0cdaa63f575c81c7cc87239f7dfcc677362c78/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0cdaa63f575c81c7cc87239f7dfcc677362c78/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=fa0cdaa63f575c81c7cc87239f7dfcc677362c78", "patch": "@@ -96,41 +96,6 @@\n //! The [`thread::current`] function is available even for threads not spawned\n //! by the APIs of this module.\n //!\n-//! ## Blocking support: park and unpark\n-//!\n-//! Every thread is equipped with some basic low-level blocking support, via the\n-//! [`thread::park`][`park`] function and [`thread::Thread::unpark()`][`unpark`]\n-//! method. [`park`] blocks the current thread, which can then be resumed from\n-//! another thread by calling the [`unpark`] method on the blocked thread's handle.\n-//!\n-//! Conceptually, each [`Thread`] handle has an associated token, which is\n-//! initially not present:\n-//!\n-//! * The [`thread::park`][`park`] function blocks the current thread unless or until\n-//!   the token is available for its thread handle, at which point it atomically\n-//!   consumes the token. It may also return *spuriously*, without consuming the\n-//!   token. [`thread::park_timeout`] does the same, but allows specifying a\n-//!   maximum time to block the thread for.\n-//!\n-//! * The [`unpark`] method on a [`Thread`] atomically makes the token available\n-//!   if it wasn't already.\n-//!\n-//! In other words, each [`Thread`] acts a bit like a semaphore with initial count\n-//! 0, except that the semaphore is *saturating* (the count cannot go above 1),\n-//! and can return spuriously.\n-//!\n-//! The API is typically used by acquiring a handle to the current thread,\n-//! placing that handle in a shared data structure so that other threads can\n-//! find it, and then `park`ing. When some desired condition is met, another\n-//! thread calls [`unpark`] on the handle.\n-//!\n-//! The motivation for this design is twofold:\n-//!\n-//! * It avoids the need to allocate mutexes and condvars when building new\n-//!   synchronization primitives; the threads already provide basic blocking/signaling.\n-//!\n-//! * It can be implemented very efficiently on many platforms.\n-//!\n //! ## Thread-local storage\n //!\n //! This module also provides an implementation of thread-local storage for Rust\n@@ -547,23 +512,71 @@ pub fn sleep(dur: Duration) {\n \n /// Blocks unless or until the current thread's token is made available.\n ///\n-/// Every thread is equipped with some basic low-level blocking support, via\n-/// the `park()` function and the [`unpark`][unpark] method. These can be\n-/// used as a more CPU-efficient implementation of a spinlock.\n+/// A call to `park` does not guarantee that the thread will remain parked\n+/// forever, and callers should be prepared for this possibility.\n+///\n+/// # park and unpark\n+///\n+/// Every thread is equipped with some basic low-level blocking support, via the\n+/// [`thread::park`][`park`] function and [`thread::Thread::unpark()`][`unpark`]\n+/// method. [`park`] blocks the current thread, which can then be resumed from\n+/// another thread by calling the [`unpark`] method on the blocked thread's\n+/// handle.\n+///\n+/// Conceptually, each [`Thread`] handle has an associated token, which is\n+/// initially not present:\n+///\n+/// * The [`thread::park`][`park`] function blocks the current thread unless or\n+///   until the token is available for its thread handle, at which point it\n+///   atomically consumes the token. It may also return *spuriously*, without\n+///   consuming the token. [`thread::park_timeout`] does the same, but allows\n+///   specifying a maximum time to block the thread for.\n+///\n+/// * The [`unpark`] method on a [`Thread`] atomically makes the token available\n+///   if it wasn't already.\n ///\n-/// [unpark]: struct.Thread.html#method.unpark\n+/// In other words, each [`Thread`] acts a bit like a spinlock that can be\n+/// locked and unlocked using `park` and `unpark`.\n ///\n /// The API is typically used by acquiring a handle to the current thread,\n /// placing that handle in a shared data structure so that other threads can\n-/// find it, and then parking (in a loop with a check for the token actually\n-/// being acquired).\n+/// find it, and then `park`ing. When some desired condition is met, another\n+/// thread calls [`unpark`] on the handle.\n ///\n-/// A call to `park` does not guarantee that the thread will remain parked\n-/// forever, and callers should be prepared for this possibility.\n+/// The motivation for this design is twofold:\n+///\n+/// * It avoids the need to allocate mutexes and condvars when building new\n+///   synchronization primitives; the threads already provide basic\n+///   blocking/signaling.\n ///\n-/// See the [module documentation][thread] for more detail.\n+/// * It can be implemented very efficiently on many platforms.\n+///\n+/// # Examples\n ///\n-/// [thread]: index.html\n+/// ```\n+/// use std::thread;\n+///\n+/// let parked_thread = thread::Builder::new()\n+///     .spawn(|| {\n+///         println!(\"Parking thread\");\n+///         thread::park();\n+///         println!(\"Thread unparked\");\n+///     })\n+///     .unwrap();\n+///\n+/// // Let some time pass for the thread to be spawned.\n+/// thread::sleep(Duration::from_millis(10));\n+///\n+/// println!(\"Unpark the thread\");\n+/// parked_thread.thread().unpark();\n+///\n+/// parked_thread.join().unwrap();\n+/// ```\n+///\n+/// [`Thread`]: ../../std/thread/struct.Thread.html\n+/// [`park`]: ../../std/thread/fn.park.html\n+/// [`unpark`]: ../../std/thread/struct.Thread.html#method.unpark\n+/// [`thread::park_timeout`]: ../../std/thread/fn.park_timeout.html\n //\n // The implementation currently uses the trivial strategy of a Mutex+Condvar\n // with wakeup flag, which does not actually allow spurious wakeups. In the\n@@ -591,11 +604,10 @@ pub fn park() {\n /// preemption or platform differences that may not cause the maximum\n /// amount of time waited to be precisely `ms` long.\n ///\n-/// See the [module documentation][thread] for more detail.\n+/// See the [park documentation][park] for more detail.\n ///\n-/// [thread]: index.html\n /// [park_timeout]: fn.park_timeout.html\n-/// [park]: fn.park.html\n+/// [park]: ../../std/thread/fn.park.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::park_timeout`\")]\n pub fn park_timeout_ms(ms: u32) {\n@@ -611,7 +623,7 @@ pub fn park_timeout_ms(ms: u32) {\n /// preemption or platform differences that may not cause the maximum\n /// amount of time waited to be precisely `dur` long.\n ///\n-/// See the [module doc][thread] for more detail.\n+/// See the [park dococumentation][park] for more details.\n ///\n /// # Platform behavior\n ///\n@@ -637,7 +649,6 @@ pub fn park_timeout_ms(ms: u32) {\n /// }\n /// ```\n ///\n-/// [thread]: index.html\n /// [park]: fn.park.html\n #[stable(feature = \"park_timeout\", since = \"1.4.0\")]\n pub fn park_timeout(dur: Duration) {\n@@ -772,7 +783,7 @@ impl Thread {\n     /// the [`park()`][park] function and the `unpark()` method. These can be\n     /// used as a more CPU-efficient implementation of a spinlock.\n     ///\n-    /// See the [module doc][thread] for more detail.\n+    /// See the [park documentation][park] for more details.\n     ///\n     /// # Examples\n     ///\n@@ -796,7 +807,6 @@ impl Thread {\n     /// parked_thread.join().unwrap();\n     /// ```\n     ///\n-    /// [thread]: index.html\n     /// [park]: fn.park.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unpark(&self) {"}]}