{"sha": "c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "node_id": "C_kwDOAAsO6NoAKGM5M2VmMzM3MDBlNGU0Zjg0ZmQ4NTY5MGRmNzFiMTRjMWQyYjBhYTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-15T10:45:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-15T10:45:36Z"}, "message": "Auto merge of #103083 - Dylan-DPC:rollup-97cvwdv, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #102773 (Use semaphores for thread parking on Apple platforms)\n - #102884 (resolve: Some cleanup, asserts and tests for lifetime ribs)\n - #102954 (Add missing checks for `doc(cfg_hide(...))`)\n - #102998 (Drop temporaries created in a condition, even if it's a let chain)\n - #103003 (Fix `suggest_floating_point_literal` ICE)\n - #103041 (Update cargo)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "40279eedaa7be0baa64437557b50667ac5bf4f2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40279eedaa7be0baa64437557b50667ac5bf4f2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "html_url": "https://github.com/rust-lang/rust/commit/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b15e2c129e732fb3f1ff3c707d76341047a66af0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b15e2c129e732fb3f1ff3c707d76341047a66af0", "html_url": "https://github.com/rust-lang/rust/commit/b15e2c129e732fb3f1ff3c707d76341047a66af0"}, {"sha": "ac23c9fde9b5298d2151e374b890c91c342fb17e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac23c9fde9b5298d2151e374b890c91c342fb17e", "html_url": "https://github.com/rust-lang/rust/commit/ac23c9fde9b5298d2151e374b890c91c342fb17e"}], "stats": {"total": 714, "additions": 610, "deletions": 104}, "files": [{"sha": "f393a91809417cba0b85cb09c019ccb4c3a65925", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -297,7 +297,7 @@ dependencies = [\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"cargo-util\",\n- \"clap 4.0.9\",\n+ \"clap 4.0.15\",\n  \"crates-io\",\n  \"curl\",\n  \"curl-sys\",\n@@ -439,7 +439,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo-util\"\n-version = \"0.2.1\"\n+version = \"0.2.2\"\n dependencies = [\n  \"anyhow\",\n  \"core-foundation\",\n@@ -602,9 +602,9 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"4.0.9\"\n+version = \"4.0.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"30607dd93c420c6f1f80b544be522a0238a7db35e6a12968d28910983fee0df0\"\n+checksum = \"6bf8832993da70a4c6d13c581f4463c2bdda27b9bf1c5498dc4365543abe6d6f\"\n dependencies = [\n  \"atty\",\n  \"bitflags\","}, {"sha": "ec9c3935020566aee76eeef1bf82fc9092125762", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -387,32 +387,58 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         then: &Block,\n         else_opt: Option<&Expr>,\n     ) -> hir::ExprKind<'hir> {\n-        let lowered_cond = self.lower_expr(cond);\n-        let new_cond = self.manage_let_cond(lowered_cond);\n+        let lowered_cond = self.lower_cond(cond);\n         let then_expr = self.lower_block_expr(then);\n         if let Some(rslt) = else_opt {\n-            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), Some(self.lower_expr(rslt)))\n+            hir::ExprKind::If(\n+                lowered_cond,\n+                self.arena.alloc(then_expr),\n+                Some(self.lower_expr(rslt)),\n+            )\n         } else {\n-            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), None)\n+            hir::ExprKind::If(lowered_cond, self.arena.alloc(then_expr), None)\n         }\n     }\n \n-    // If `cond` kind is `let`, returns `let`. Otherwise, wraps and returns `cond`\n-    // in a temporary block.\n-    fn manage_let_cond(&mut self, cond: &'hir hir::Expr<'hir>) -> &'hir hir::Expr<'hir> {\n-        fn has_let_expr<'hir>(expr: &'hir hir::Expr<'hir>) -> bool {\n-            match expr.kind {\n-                hir::ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n-                hir::ExprKind::Let(..) => true,\n+    // Lowers a condition (i.e. `cond` in `if cond` or `while cond`), wrapping it in a terminating scope\n+    // so that temporaries created in the condition don't live beyond it.\n+    fn lower_cond(&mut self, cond: &Expr) -> &'hir hir::Expr<'hir> {\n+        fn has_let_expr(expr: &Expr) -> bool {\n+            match &expr.kind {\n+                ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n+                ExprKind::Let(..) => true,\n                 _ => false,\n             }\n         }\n-        if has_let_expr(cond) {\n-            cond\n-        } else {\n-            let reason = DesugaringKind::CondTemporary;\n-            let span_block = self.mark_span_with_reason(reason, cond.span, None);\n-            self.expr_drop_temps(span_block, cond, AttrVec::new())\n+\n+        // We have to take special care for `let` exprs in the condition, e.g. in\n+        // `if let pat = val` or `if foo && let pat = val`, as we _do_ want `val` to live beyond the\n+        // condition in this case.\n+        //\n+        // In order to mantain the drop behavior for the non `let` parts of the condition,\n+        // we still wrap them in terminating scopes, e.g. `if foo && let pat = val` essentially\n+        // gets transformed into `if { let _t = foo; _t } && let pat = val`\n+        match &cond.kind {\n+            ExprKind::Binary(op @ Spanned { node: ast::BinOpKind::And, .. }, lhs, rhs)\n+                if has_let_expr(cond) =>\n+            {\n+                let op = self.lower_binop(*op);\n+                let lhs = self.lower_cond(lhs);\n+                let rhs = self.lower_cond(rhs);\n+\n+                self.arena.alloc(self.expr(\n+                    cond.span,\n+                    hir::ExprKind::Binary(op, lhs, rhs),\n+                    AttrVec::new(),\n+                ))\n+            }\n+            ExprKind::Let(..) => self.lower_expr(cond),\n+            _ => {\n+                let cond = self.lower_expr(cond);\n+                let reason = DesugaringKind::CondTemporary;\n+                let span_block = self.mark_span_with_reason(reason, cond.span, None);\n+                self.expr_drop_temps(span_block, cond, AttrVec::new())\n+            }\n         }\n     }\n \n@@ -439,14 +465,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::ExprKind<'hir> {\n-        let lowered_cond = self.with_loop_condition_scope(|t| t.lower_expr(cond));\n-        let new_cond = self.manage_let_cond(lowered_cond);\n+        let lowered_cond = self.with_loop_condition_scope(|t| t.lower_cond(cond));\n         let then = self.lower_block_expr(body);\n         let expr_break = self.expr_break(span, AttrVec::new());\n         let stmt_break = self.stmt_expr(span, expr_break);\n         let else_blk = self.block_all(span, arena_vec![self; stmt_break], None);\n         let else_expr = self.arena.alloc(self.expr_block(else_blk, AttrVec::new()));\n-        let if_kind = hir::ExprKind::If(new_cond, self.arena.alloc(then), Some(else_expr));\n+        let if_kind = hir::ExprKind::If(lowered_cond, self.arena.alloc(then), Some(else_expr));\n         let if_expr = self.expr(span, if_kind, AttrVec::new());\n         let block = self.block_expr(self.arena.alloc(if_expr));\n         let span = self.lower_span(span.with_hi(cond.span.hi()));"}, {"sha": "4bc6bd9fb220791c5a5664a45d8fb9b0b25ddc91", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -145,6 +145,9 @@ passes_doc_test_takes_list =\n passes_doc_primitive =\n     `doc(primitive)` should never have been stable\n \n+passes_doc_cfg_hide_takes_list =\n+    `#[doc(cfg_hide(...)]` takes a list of attributes\n+\n passes_doc_test_unknown_any =\n     unknown `doc` attribute `{$path}`\n "}, {"sha": "3c684fffac8809f72b321ecfc7e3241bca3add1f", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -934,6 +934,22 @@ impl CheckAttrVisitor<'_> {\n         is_valid\n     }\n \n+    /// Check that the `#![doc(cfg_hide(...))]` attribute only contains a list of attributes.\n+    /// Returns `true` if valid.\n+    fn check_doc_cfg_hide(&self, meta: &NestedMetaItem, hir_id: HirId) -> bool {\n+        if meta.meta_item_list().is_some() {\n+            true\n+        } else {\n+            self.tcx.emit_spanned_lint(\n+                INVALID_DOC_ATTRIBUTES,\n+                hir_id,\n+                meta.span(),\n+                errors::DocCfgHideTakesList,\n+            );\n+            false\n+        }\n+    }\n+\n     /// Runs various checks on `#[doc]` attributes. Returns `true` if valid.\n     ///\n     /// `specified_inline` should be initialized to `None` and kept for the scope\n@@ -987,6 +1003,13 @@ impl CheckAttrVisitor<'_> {\n                             is_valid = false;\n                         }\n \n+                        sym::cfg_hide\n+                            if !self.check_attr_crate_level(attr, meta, hir_id)\n+                                || !self.check_doc_cfg_hide(meta, hir_id) =>\n+                        {\n+                            is_valid = false;\n+                        }\n+\n                         sym::inline | sym::no_inline\n                             if !self.check_doc_inline(\n                                 attr,"}, {"sha": "ed54834134453d20649acfd9dd9d2e2fc0f56672", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -271,6 +271,10 @@ pub struct DocTestUnknown {\n #[diag(passes::doc_test_takes_list)]\n pub struct DocTestTakesList;\n \n+#[derive(LintDiagnostic)]\n+#[diag(passes::doc_cfg_hide_takes_list)]\n+pub struct DocCfgHideTakesList;\n+\n #[derive(LintDiagnostic)]\n #[diag(passes::doc_primitive)]\n pub struct DocPrimitive;"}, {"sha": "77ba7a82672bcbbb48a7812ac88ffd3ec0cfa783", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 77, "deletions": 65, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -224,22 +224,14 @@ enum LifetimeUseSet {\n \n #[derive(Copy, Clone, Debug)]\n enum LifetimeRibKind {\n-    /// This rib acts as a barrier to forbid reference to lifetimes of a parent item.\n-    Item,\n-\n+    // -- Ribs introducing named lifetimes\n+    //\n     /// This rib declares generic parameters.\n+    /// Only for this kind the `LifetimeRib::bindings` field can be non-empty.\n     Generics { binder: NodeId, span: Span, kind: LifetimeBinderKind },\n \n-    /// FIXME(const_generics): This patches over an ICE caused by non-'static lifetimes in const\n-    /// generics. We are disallowing this until we can decide on how we want to handle non-'static\n-    /// lifetimes in const generics. See issue #74052 for discussion.\n-    ConstGeneric,\n-\n-    /// Non-static lifetimes are prohibited in anonymous constants under `min_const_generics`.\n-    /// This function will emit an error if `generic_const_exprs` is not enabled, the body identified by\n-    /// `body_id` is an anonymous constant and `lifetime_ref` is non-static.\n-    AnonConst,\n-\n+    // -- Ribs introducing unnamed lifetimes\n+    //\n     /// Create a new anonymous lifetime parameter and reference it.\n     ///\n     /// If `report_in_path`, report an error when encountering lifetime elision in a path:\n@@ -256,16 +248,31 @@ enum LifetimeRibKind {\n     /// ```\n     AnonymousCreateParameter { binder: NodeId, report_in_path: bool },\n \n+    /// Replace all anonymous lifetimes by provided lifetime.\n+    Elided(LifetimeRes),\n+\n+    // -- Barrier ribs that stop lifetime lookup, or continue it but produce an error later.\n+    //\n     /// Give a hard error when either `&` or `'_` is written. Used to\n     /// rule out things like `where T: Foo<'_>`. Does not imply an\n     /// error on default object bounds (e.g., `Box<dyn Foo>`).\n     AnonymousReportError,\n \n-    /// Replace all anonymous lifetimes by provided lifetime.\n-    Elided(LifetimeRes),\n-\n     /// Signal we cannot find which should be the anonymous lifetime.\n     ElisionFailure,\n+\n+    /// FIXME(const_generics): This patches over an ICE caused by non-'static lifetimes in const\n+    /// generics. We are disallowing this until we can decide on how we want to handle non-'static\n+    /// lifetimes in const generics. See issue #74052 for discussion.\n+    ConstGeneric,\n+\n+    /// Non-static lifetimes are prohibited in anonymous constants under `min_const_generics`.\n+    /// This function will emit an error if `generic_const_exprs` is not enabled, the body\n+    /// identified by `body_id` is an anonymous constant and `lifetime_ref` is non-static.\n+    AnonConst,\n+\n+    /// This rib acts as a barrier to forbid reference to lifetimes of a parent item.\n+    Item,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -748,35 +755,31 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n         match foreign_item.kind {\n             ForeignItemKind::TyAlias(box TyAlias { ref generics, .. }) => {\n-                self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n-                    this.with_generic_param_rib(\n-                        &generics.params,\n-                        ItemRibKind(HasGenericParams::Yes(generics.span)),\n-                        LifetimeRibKind::Generics {\n-                            binder: foreign_item.id,\n-                            kind: LifetimeBinderKind::Item,\n-                            span: generics.span,\n-                        },\n-                        |this| visit::walk_foreign_item(this, foreign_item),\n-                    )\n-                });\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    ItemRibKind(HasGenericParams::Yes(generics.span)),\n+                    LifetimeRibKind::Generics {\n+                        binder: foreign_item.id,\n+                        kind: LifetimeBinderKind::Item,\n+                        span: generics.span,\n+                    },\n+                    |this| visit::walk_foreign_item(this, foreign_item),\n+                );\n             }\n             ForeignItemKind::Fn(box Fn { ref generics, .. }) => {\n-                self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n-                    this.with_generic_param_rib(\n-                        &generics.params,\n-                        ItemRibKind(HasGenericParams::Yes(generics.span)),\n-                        LifetimeRibKind::Generics {\n-                            binder: foreign_item.id,\n-                            kind: LifetimeBinderKind::Function,\n-                            span: generics.span,\n-                        },\n-                        |this| visit::walk_foreign_item(this, foreign_item),\n-                    )\n-                });\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    ItemRibKind(HasGenericParams::Yes(generics.span)),\n+                    LifetimeRibKind::Generics {\n+                        binder: foreign_item.id,\n+                        kind: LifetimeBinderKind::Function,\n+                        span: generics.span,\n+                    },\n+                    |this| visit::walk_foreign_item(this, foreign_item),\n+                );\n             }\n             ForeignItemKind::Static(..) => {\n-                self.with_item_rib(|this| {\n+                self.with_static_rib(|this| {\n                     visit::walk_foreign_item(this, foreign_item);\n                 });\n             }\n@@ -1391,9 +1394,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             return self.resolve_anonymous_lifetime(lifetime, false);\n         }\n \n-        let mut indices = (0..self.lifetime_ribs.len()).rev();\n-        for i in &mut indices {\n-            let rib = &self.lifetime_ribs[i];\n+        let mut lifetime_rib_iter = self.lifetime_ribs.iter().rev();\n+        while let Some(rib) = lifetime_rib_iter.next() {\n             let normalized_ident = ident.normalize_to_macros_2_0();\n             if let Some(&(_, res)) = rib.bindings.get(&normalized_ident) {\n                 self.record_lifetime_res(lifetime.id, res, LifetimeElisionCandidate::Named);\n@@ -1423,9 +1425,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                     } else {\n                                         LifetimeUseSet::Many\n                                     }),\n-                                    LifetimeRibKind::Generics { .. }\n-                                    | LifetimeRibKind::ConstGeneric\n-                                    | LifetimeRibKind::AnonConst => None,\n+                                    LifetimeRibKind::Generics { .. } => None,\n+                                    LifetimeRibKind::ConstGeneric | LifetimeRibKind::AnonConst => {\n+                                        span_bug!(ident.span, \"unexpected rib kind: {:?}\", rib.kind)\n+                                    }\n                                 })\n                                 .unwrap_or(LifetimeUseSet::Many);\n                             debug!(?use_ctxt, ?use_set);\n@@ -1460,13 +1463,16 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     );\n                     return;\n                 }\n-                _ => {}\n+                LifetimeRibKind::AnonymousCreateParameter { .. }\n+                | LifetimeRibKind::Elided(_)\n+                | LifetimeRibKind::Generics { .. }\n+                | LifetimeRibKind::ElisionFailure\n+                | LifetimeRibKind::AnonymousReportError => {}\n             }\n         }\n \n         let mut outer_res = None;\n-        for i in indices {\n-            let rib = &self.lifetime_ribs[i];\n+        for rib in lifetime_rib_iter {\n             let normalized_ident = ident.normalize_to_macros_2_0();\n             if let Some((&outer, _)) = rib.bindings.get_key_value(&normalized_ident) {\n                 outer_res = Some(outer);\n@@ -1493,8 +1499,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             count: 1,\n         };\n         let elision_candidate = LifetimeElisionCandidate::Missing(missing_lifetime);\n-        for i in (0..self.lifetime_ribs.len()).rev() {\n-            let rib = &mut self.lifetime_ribs[i];\n+        for rib in self.lifetime_ribs.iter().rev() {\n             debug!(?rib.kind);\n             match rib.kind {\n                 LifetimeRibKind::AnonymousCreateParameter { binder, .. } => {\n@@ -1534,9 +1539,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     return;\n                 }\n                 LifetimeRibKind::Item => break,\n-                LifetimeRibKind::Generics { .. }\n-                | LifetimeRibKind::ConstGeneric\n-                | LifetimeRibKind::AnonConst => {}\n+                LifetimeRibKind::Generics { .. } | LifetimeRibKind::ConstGeneric => {}\n+                LifetimeRibKind::AnonConst => {\n+                    // There is always an `Elided(LifetimeRes::Static)` inside an `AnonConst`.\n+                    span_bug!(lifetime.ident.span, \"unexpected rib kind: {:?}\", rib.kind)\n+                }\n             }\n         }\n         self.record_lifetime_res(lifetime.id, LifetimeRes::Error, elision_candidate);\n@@ -1751,9 +1758,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         self.report_missing_lifetime_specifiers(vec![missing_lifetime], None);\n                         break;\n                     }\n-                    LifetimeRibKind::Generics { .. }\n-                    | LifetimeRibKind::ConstGeneric\n-                    | LifetimeRibKind::AnonConst => {}\n+                    LifetimeRibKind::Generics { .. } | LifetimeRibKind::ConstGeneric => {}\n+                    LifetimeRibKind::AnonConst => {\n+                        // There is always an `Elided(LifetimeRes::Static)` inside an `AnonConst`.\n+                        span_bug!(elided_lifetime_span, \"unexpected rib kind: {:?}\", rib.kind)\n+                    }\n                 }\n             }\n \n@@ -2204,7 +2213,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n \n             ItemKind::Static(ref ty, _, ref expr) | ItemKind::Const(_, ref ty, ref expr) => {\n-                self.with_item_rib(|this| {\n+                self.with_static_rib(|this| {\n                     this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Static), |this| {\n                         this.visit_ty(ty);\n                     });\n@@ -2399,11 +2408,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         self.label_ribs.pop();\n     }\n \n-    fn with_item_rib(&mut self, f: impl FnOnce(&mut Self)) {\n+    fn with_static_rib(&mut self, f: impl FnOnce(&mut Self)) {\n         let kind = ItemRibKind(HasGenericParams::No);\n-        self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n-            this.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n-        })\n+        self.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n     }\n \n     // HACK(min_const_generics,const_evaluatable_unchecked): We\n@@ -3938,7 +3945,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         fn_id: NodeId,\n         async_node_id: Option<(NodeId, Span)>,\n     ) {\n-        if let Some((async_node_id, _)) = async_node_id {\n+        if let Some((async_node_id, span)) = async_node_id {\n             let mut extra_lifetime_params =\n                 self.r.extra_lifetime_params_map.get(&fn_id).cloned().unwrap_or_default();\n             for rib in self.lifetime_ribs.iter().rev() {\n@@ -3952,7 +3959,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             extra_lifetime_params.extend(earlier_fresh);\n                         }\n                     }\n-                    _ => {}\n+                    LifetimeRibKind::Generics { .. } => {}\n+                    _ => {\n+                        // We are in a function definition. We should only find `Generics`\n+                        // and `AnonymousCreateParameter` inside the innermost `Item`.\n+                        span_bug!(span, \"unexpected rib kind: {:?}\", rib.kind)\n+                    }\n                 }\n             }\n             self.r.extra_lifetime_params_map.insert(async_node_id, extra_lifetime_params);"}, {"sha": "4431cf9f4436b3defd70e161fa63b5483d729b09", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -2937,19 +2937,15 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             ObligationCauseCode::BinOp { rhs_span: Some(span), is_lit, .. } if *is_lit => span,\n             _ => return,\n         };\n-        match (\n-            trait_ref.skip_binder().self_ty().kind(),\n-            trait_ref.skip_binder().substs.type_at(1).kind(),\n-        ) {\n-            (ty::Float(_), ty::Infer(InferTy::IntVar(_))) => {\n-                err.span_suggestion_verbose(\n-                    rhs_span.shrink_to_hi(),\n-                    \"consider using a floating-point literal by writing it with `.0`\",\n-                    \".0\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            _ => {}\n+        if let ty::Float(_) = trait_ref.skip_binder().self_ty().kind()\n+            && let ty::Infer(InferTy::IntVar(_)) = trait_ref.skip_binder().substs.type_at(1).kind()\n+        {\n+            err.span_suggestion_verbose(\n+                rhs_span.shrink_to_hi(),\n+                \"consider using a floating-point literal by writing it with `.0`\",\n+                \".0\",\n+                Applicability::MaybeIncorrect,\n+            );\n         }\n     }\n "}, {"sha": "2f5356fe2276bbb31df2c0dea47d115364860fdc", "filename": "library/std/src/sys/unix/thread_parker/darwin.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fdarwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fdarwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fdarwin.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -0,0 +1,131 @@\n+//! Thread parking for Darwin-based systems.\n+//!\n+//! Darwin actually has futex syscalls (`__ulock_wait`/`__ulock_wake`), but they\n+//! cannot be used in `std` because they are non-public (their use will lead to\n+//! rejection from the App Store) and because they are only available starting\n+//! with macOS version 10.12, even though the minimum target version is 10.7.\n+//!\n+//! Therefore, we need to look for other synchronization primitives. Luckily, Darwin\n+//! supports semaphores, which allow us to implement the behaviour we need with\n+//! only one primitive (as opposed to a mutex-condvar pair). We use the semaphore\n+//! provided by libdispatch, as the underlying Mach semaphore is only dubiously\n+//! public.\n+\n+use crate::pin::Pin;\n+use crate::sync::atomic::{\n+    AtomicI8,\n+    Ordering::{Acquire, Release},\n+};\n+use crate::time::Duration;\n+\n+type dispatch_semaphore_t = *mut crate::ffi::c_void;\n+type dispatch_time_t = u64;\n+\n+const DISPATCH_TIME_NOW: dispatch_time_t = 0;\n+const DISPATCH_TIME_FOREVER: dispatch_time_t = !0;\n+\n+// Contained in libSystem.dylib, which is linked by default.\n+extern \"C\" {\n+    fn dispatch_time(when: dispatch_time_t, delta: i64) -> dispatch_time_t;\n+    fn dispatch_semaphore_create(val: isize) -> dispatch_semaphore_t;\n+    fn dispatch_semaphore_wait(dsema: dispatch_semaphore_t, timeout: dispatch_time_t) -> isize;\n+    fn dispatch_semaphore_signal(dsema: dispatch_semaphore_t) -> isize;\n+    fn dispatch_release(object: *mut crate::ffi::c_void);\n+}\n+\n+const EMPTY: i8 = 0;\n+const NOTIFIED: i8 = 1;\n+const PARKED: i8 = -1;\n+\n+pub struct Parker {\n+    semaphore: dispatch_semaphore_t,\n+    state: AtomicI8,\n+}\n+\n+unsafe impl Sync for Parker {}\n+unsafe impl Send for Parker {}\n+\n+impl Parker {\n+    pub unsafe fn new(parker: *mut Parker) {\n+        let semaphore = dispatch_semaphore_create(0);\n+        assert!(\n+            !semaphore.is_null(),\n+            \"failed to create dispatch semaphore for thread synchronization\"\n+        );\n+        parker.write(Parker { semaphore, state: AtomicI8::new(EMPTY) })\n+    }\n+\n+    // Does not need `Pin`, but other implementation do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        // The semaphore counter must be zero at this point, because unparking\n+        // threads will not actually increase it until we signalled that we\n+        // are waiting.\n+\n+        // Change NOTIFIED to EMPTY and EMPTY to PARKED.\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+\n+        // Another thread may increase the semaphore counter from this point on.\n+        // If it is faster than us, we will decrement it again immediately below.\n+        // If we are faster, we wait.\n+\n+        // Ensure that the semaphore counter has actually been decremented, even\n+        // if the call timed out for some reason.\n+        while dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) != 0 {}\n+\n+        // At this point, the semaphore counter is zero again.\n+\n+        // We were definitely woken up, so we don't need to check the state.\n+        // Still, we need to reset the state using a swap to observe the state\n+        // change with acquire ordering.\n+        self.state.swap(EMPTY, Acquire);\n+    }\n+\n+    // Does not need `Pin`, but other implementation do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+\n+        let nanos = dur.as_nanos().try_into().unwrap_or(i64::MAX);\n+        let timeout = dispatch_time(DISPATCH_TIME_NOW, nanos);\n+\n+        let timeout = dispatch_semaphore_wait(self.semaphore, timeout) != 0;\n+\n+        let state = self.state.swap(EMPTY, Acquire);\n+        if state == NOTIFIED && timeout {\n+            // If the state was NOTIFIED but semaphore_wait returned without\n+            // decrementing the count because of a timeout, it means another\n+            // thread is about to call semaphore_signal. We must wait for that\n+            // to happen to ensure the semaphore count is reset.\n+            while dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) != 0 {}\n+        } else {\n+            // Either a timeout occurred and we reset the state before any thread\n+            // tried to wake us up, or we were woken up and reset the state,\n+            // making sure to observe the state change with acquire ordering.\n+            // Either way, the semaphore counter is now zero again.\n+        }\n+    }\n+\n+    // Does not need `Pin`, but other implementation do.\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+        if state == PARKED {\n+            unsafe {\n+                dispatch_semaphore_signal(self.semaphore);\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for Parker {\n+    fn drop(&mut self) {\n+        // SAFETY:\n+        // We always ensure that the semaphore count is reset, so this will\n+        // never cause an exception.\n+        unsafe {\n+            dispatch_release(self.semaphore);\n+        }\n+    }\n+}"}, {"sha": "35f1e68a87e5b431faa49a551e6f32e43a97a4df", "filename": "library/std/src/sys/unix/thread_parker/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -11,7 +11,18 @@\n )))]\n \n cfg_if::cfg_if! {\n-    if #[cfg(target_os = \"netbsd\")] {\n+    if #[cfg(all(\n+        any(\n+            target_os = \"macos\",\n+            target_os = \"ios\",\n+            target_os = \"watchos\",\n+            target_os = \"tvos\",\n+        ),\n+        not(miri),\n+    ))] {\n+        mod darwin;\n+        pub use darwin::Parker;\n+    } else if #[cfg(target_os = \"netbsd\")] {\n         mod netbsd;\n         pub use netbsd::Parker;\n     } else {"}, {"sha": "dfb8765ab4eed3a3e558dbbf5c97c44e693afe30", "filename": "library/std/src/thread/tests.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -244,6 +244,28 @@ fn test_try_panic_any_message_unit_struct() {\n     }\n }\n \n+#[test]\n+fn test_park_unpark_before() {\n+    for _ in 0..10 {\n+        thread::current().unpark();\n+        thread::park();\n+    }\n+}\n+\n+#[test]\n+fn test_park_unpark_called_other_thread() {\n+    for _ in 0..10 {\n+        let th = thread::current();\n+\n+        let _guard = thread::spawn(move || {\n+            super::sleep(Duration::from_millis(50));\n+            th.unpark();\n+        });\n+\n+        thread::park();\n+    }\n+}\n+\n #[test]\n fn test_park_timeout_unpark_before() {\n     for _ in 0..10 {"}, {"sha": "5d8791748a0122401401eb591819a42710ff0151", "filename": "src/test/rustdoc-ui/doc_cfg_hide.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Frustdoc-ui%2Fdoc_cfg_hide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Frustdoc-ui%2Fdoc_cfg_hide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc_cfg_hide.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -0,0 +1,11 @@\n+#![feature(doc_cfg_hide)]\n+#![deny(warnings)]\n+\n+#![doc(cfg_hide = \"test\")] //~ ERROR\n+//~^ WARN\n+#![doc(cfg_hide)] //~ ERROR\n+//~^ WARN\n+\n+#[doc(cfg_hide(doc))] //~ ERROR\n+//~^ WARN\n+pub fn foo() {}"}, {"sha": "03623368cd0472b8203c6d16eebccd53f091f81f", "filename": "src/test/rustdoc-ui/doc_cfg_hide.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Frustdoc-ui%2Fdoc_cfg_hide.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Frustdoc-ui%2Fdoc_cfg_hide.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc_cfg_hide.stderr?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -0,0 +1,40 @@\n+error: this attribute can only be applied at the crate level\n+  --> $DIR/doc_cfg_hide.rs:9:7\n+   |\n+LL | #[doc(cfg_hide(doc))]\n+   |       ^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n+note: the lint level is defined here\n+  --> $DIR/doc_cfg_hide.rs:2:9\n+   |\n+LL | #![deny(warnings)]\n+   |         ^^^^^^^^\n+   = note: `#[deny(invalid_doc_attributes)]` implied by `#[deny(warnings)]`\n+help: to apply to the crate, use an inner attribute\n+   |\n+LL | #![doc(cfg_hide(doc))]\n+   | ~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: `#[doc(cfg_hide(...)]` takes a list of attributes\n+  --> $DIR/doc_cfg_hide.rs:4:8\n+   |\n+LL | #![doc(cfg_hide = \"test\")]\n+   |        ^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n+\n+error: `#[doc(cfg_hide(...)]` takes a list of attributes\n+  --> $DIR/doc_cfg_hide.rs:6:8\n+   |\n+LL | #![doc(cfg_hide)]\n+   |        ^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "ba1ac53aa7ce8a1c33138307ba83e617b57c9199", "filename": "src/test/ui/drop/drop_order.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -1,4 +1,6 @@\n // run-pass\n+// compile-flags: -Z validate-mir\n+#![feature(let_chains)]\n \n use std::cell::RefCell;\n use std::convert::TryInto;\n@@ -116,6 +118,58 @@ impl DropOrderCollector {\n         }\n     }\n \n+    fn let_chain(&self) {\n+        // take the \"then\" branch\n+        if self.option_loud_drop(2).is_some() // 2\n+            && self.option_loud_drop(1).is_some() // 1\n+            && let Some(_d) = self.option_loud_drop(4) { // 4\n+            self.print(3); // 3\n+        }\n+\n+        // take the \"else\" branch\n+        if self.option_loud_drop(6).is_some() // 2\n+            && self.option_loud_drop(5).is_some() // 1\n+            && let None = self.option_loud_drop(7) { // 3\n+            unreachable!();\n+        } else {\n+            self.print(8); // 4\n+        }\n+\n+        // let exprs interspersed\n+        if self.option_loud_drop(9).is_some() // 1\n+            && let Some(_d) = self.option_loud_drop(13) // 5\n+            && self.option_loud_drop(10).is_some() // 2\n+            && let Some(_e) = self.option_loud_drop(12) { // 4\n+            self.print(11); // 3\n+        }\n+\n+        // let exprs first\n+        if let Some(_d) = self.option_loud_drop(18) // 5\n+            && let Some(_e) = self.option_loud_drop(17) // 4\n+            && self.option_loud_drop(14).is_some() // 1\n+            && self.option_loud_drop(15).is_some() { // 2\n+                self.print(16); // 3\n+            }\n+\n+        // let exprs last\n+        if self.option_loud_drop(20).is_some() // 2\n+            && self.option_loud_drop(19).is_some() // 1\n+            && let Some(_d) = self.option_loud_drop(23) // 5\n+            && let Some(_e) = self.option_loud_drop(22) { // 4\n+                self.print(21); // 3\n+        }\n+    }\n+\n+    fn while_(&self) {\n+        let mut v = self.option_loud_drop(4);\n+        while let Some(_d) = v\n+            && self.option_loud_drop(1).is_some()\n+            && self.option_loud_drop(2).is_some() {\n+            self.print(3);\n+            v = None;\n+        }\n+    }\n+\n     fn assert_sorted(self) {\n         assert!(\n             self.0\n@@ -142,4 +196,14 @@ fn main() {\n     let collector = DropOrderCollector::default();\n     collector.match_();\n     collector.assert_sorted();\n+\n+    println!(\"-- let chain --\");\n+    let collector = DropOrderCollector::default();\n+    collector.let_chain();\n+    collector.assert_sorted();\n+\n+    println!(\"-- while --\");\n+    let collector = DropOrderCollector::default();\n+    collector.while_();\n+    collector.assert_sorted();\n }"}, {"sha": "b4c86aab863c8963edb342e85f86a04b55f606be", "filename": "src/test/ui/lifetimes/unusual-rib-combinations.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Fui%2Flifetimes%2Funusual-rib-combinations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Fui%2Flifetimes%2Funusual-rib-combinations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Funusual-rib-combinations.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -0,0 +1,28 @@\n+#![feature(inline_const)]\n+\n+struct S<'a>(&'a u8);\n+fn foo() {}\n+\n+// Paren generic args in AnonConst\n+fn a() -> [u8; foo::()] {\n+//~^ ERROR parenthesized type parameters may only be used with a `Fn` trait\n+//~| ERROR mismatched types\n+    panic!()\n+}\n+\n+// Paren generic args in ConstGeneric\n+fn b<const C: u8()>() {}\n+//~^ ERROR parenthesized type parameters may only be used with a `Fn` trait\n+\n+// Paren generic args in AnonymousReportError\n+fn c<T = u8()>() {}\n+//~^ ERROR parenthesized type parameters may only be used with a `Fn` trait\n+//~| ERROR defaults for type parameters are only allowed in\n+//~| WARN this was previously accepted\n+\n+// Elided lifetime in path in ConstGeneric\n+fn d<const C: S>() {}\n+//~^ ERROR missing lifetime specifier\n+//~| ERROR `S<'static>` is forbidden as the type of a const generic parameter\n+\n+fn main() {}"}, {"sha": "6d7b42506982ce0a53a4e840b5d28a4814c07d65", "filename": "src/test/ui/lifetimes/unusual-rib-combinations.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Fui%2Flifetimes%2Funusual-rib-combinations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Fui%2Flifetimes%2Funusual-rib-combinations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Funusual-rib-combinations.stderr?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -0,0 +1,61 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/unusual-rib-combinations.rs:24:15\n+   |\n+LL | fn d<const C: S>() {}\n+   |               ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn d<'a, const C: S<'a>>() {}\n+   |      +++           ++++\n+\n+error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n+  --> $DIR/unusual-rib-combinations.rs:7:16\n+   |\n+LL | fn a() -> [u8; foo::()] {\n+   |                ^^^^^^^ only `Fn` traits may use parentheses\n+\n+error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n+  --> $DIR/unusual-rib-combinations.rs:14:15\n+   |\n+LL | fn b<const C: u8()>() {}\n+   |               ^^^^ only `Fn` traits may use parentheses\n+\n+error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n+  --> $DIR/unusual-rib-combinations.rs:18:10\n+   |\n+LL | fn c<T = u8()>() {}\n+   |          ^^^^ only `Fn` traits may use parentheses\n+\n+error: defaults for type parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions\n+  --> $DIR/unusual-rib-combinations.rs:18:6\n+   |\n+LL | fn c<T = u8()>() {}\n+   |      ^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #36887 <https://github.com/rust-lang/rust/issues/36887>\n+   = note: `#[deny(invalid_type_param_default)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/unusual-rib-combinations.rs:7:16\n+   |\n+LL | fn a() -> [u8; foo::()] {\n+   |                ^^^^^^^ expected `usize`, found fn item\n+   |\n+   = note: expected type `usize`\n+           found fn item `fn() {foo}`\n+\n+error: `S<'static>` is forbidden as the type of a const generic parameter\n+  --> $DIR/unusual-rib-combinations.rs:24:15\n+   |\n+LL | fn d<const C: S>() {}\n+   |               ^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = help: more complex types are supported with `#![feature(adt_const_params)]`\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors have detailed explanations: E0106, E0214, E0308.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "62f95272fbfd26637104a676bead5a2ff712bca0", "filename": "src/test/ui/traits/issue-102989.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Fui%2Ftraits%2Fissue-102989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Fui%2Ftraits%2Fissue-102989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-102989.rs?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -0,0 +1,16 @@\n+// normalize-stderr-test \"loaded from .*libcore-.*.rlib\" -> \"loaded from SYSROOT/libcore-*.rlib\"\n+\n+#![feature(lang_items)]\n+#[lang=\"sized\"]\n+trait Sized { } //~ ERROR found duplicate lang item `sized`\n+\n+fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n+    //~^ ERROR `self` parameter is only allowed in associated functions\n+    //~| ERROR cannot find type `Struct` in this scope\n+    //~| ERROR mismatched types\n+    let x = x << 1;\n+    //~^ ERROR the size for values of type `{integer}` cannot be known at compilation time\n+    //~| ERROR cannot find value `x` in this scope\n+}\n+\n+fn main() {}"}, {"sha": "efe1a246774576a450cc5c0b25c610f89080c481", "filename": "src/test/ui/traits/issue-102989.stderr", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Fui%2Ftraits%2Fissue-102989.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c93ef33700e4e4f84fd85690df71b14c1d2b0aa3/src%2Ftest%2Fui%2Ftraits%2Fissue-102989.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-102989.stderr?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -0,0 +1,59 @@\n+error: `self` parameter is only allowed in associated functions\n+  --> $DIR/issue-102989.rs:7:15\n+   |\n+LL | fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n+   |               ^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated functions are those in `impl` or `trait` definitions\n+\n+error[E0412]: cannot find type `Struct` in this scope\n+  --> $DIR/issue-102989.rs:7:22\n+   |\n+LL | fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n+   |                      ^^^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/issue-102989.rs:11:13\n+   |\n+LL |     let x = x << 1;\n+   |             ^ help: a local variable with a similar name exists: `f`\n+\n+error[E0152]: found duplicate lang item `sized`\n+  --> $DIR/issue-102989.rs:5:1\n+   |\n+LL | trait Sized { }\n+   | ^^^^^^^^^^^\n+   |\n+   = note: the lang item is first defined in crate `core` (which `std` depends on)\n+   = note: first definition in `core` loaded from SYSROOT/libcore-*.rlib\n+   = note: second definition in the local crate (`issue_102989`)\n+\n+error[E0277]: the size for values of type `{integer}` cannot be known at compilation time\n+  --> $DIR/issue-102989.rs:11:15\n+   |\n+LL |     let x = x << 1;\n+   |               ^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-102989.rs:7:42\n+   |\n+LL | fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n+   |    ----------                            ^^^^ expected `&u32`, found `()`\n+   |    |\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+note: consider returning one of these bindings\n+  --> $DIR/issue-102989.rs:7:30\n+   |\n+LL | fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n+   |                              ^\n+...\n+LL |     let x = x << 1;\n+   |         ^\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0152, E0277, E0308, E0412, E0425.\n+For more information about an error, try `rustc --explain E0152`."}, {"sha": "b332991a57c9d055f1864de1eed93e2178d49440", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=c93ef33700e4e4f84fd85690df71b14c1d2b0aa3", "patch": "@@ -1 +1 @@\n-Subproject commit b8f30cb23c4e5f20854a4f683325782b7cff9837\n+Subproject commit b332991a57c9d055f1864de1eed93e2178d49440"}]}