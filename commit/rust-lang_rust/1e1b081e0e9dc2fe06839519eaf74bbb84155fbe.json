{"sha": "1e1b081e0e9dc2fe06839519eaf74bbb84155fbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMWIwODFlMGU5ZGMyZmUwNjgzOTUxOWVhZjc0YmJiODQxNTVmYmU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-11T20:05:35Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-18T10:42:45Z"}, "message": "resolve: Decouple scope visiting process from visitor actions", "tree": {"sha": "447dad8fbbd44a45248445586da24efccbd5dcb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/447dad8fbbd44a45248445586da24efccbd5dcb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e1b081e0e9dc2fe06839519eaf74bbb84155fbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e1b081e0e9dc2fe06839519eaf74bbb84155fbe", "html_url": "https://github.com/rust-lang/rust/commit/1e1b081e0e9dc2fe06839519eaf74bbb84155fbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e1b081e0e9dc2fe06839519eaf74bbb84155fbe/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b302f62cbc6387dc99bf1fe9db0da39e72d098ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/b302f62cbc6387dc99bf1fe9db0da39e72d098ba", "html_url": "https://github.com/rust-lang/rust/commit/b302f62cbc6387dc99bf1fe9db0da39e72d098ba"}], "stats": {"total": 308, "additions": 170, "deletions": 138}, "files": [{"sha": "5cc0c499ec32ca80a7d81b1f51c23d9205b47cad", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/1e1b081e0e9dc2fe06839519eaf74bbb84155fbe/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1b081e0e9dc2fe06839519eaf74bbb84155fbe/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1e1b081e0e9dc2fe06839519eaf74bbb84155fbe", "patch": "@@ -109,6 +109,7 @@ impl Determinacy {\n /// A specific scope in which a name can be looked up.\n /// This enum is currently used only for early resolution (imports and macros),\n /// but not for late resolution yet.\n+#[derive(Clone, Copy)]\n enum Scope<'a> {\n     DeriveHelpers,\n     MacroRules(LegacyScope<'a>),\n@@ -2143,6 +2144,128 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    /// A generic scope visitor.\n+    /// Visits scopes in order to resolve some identifier in them or perform other actions.\n+    /// If the callback returns `Some` result, we stop visiting scopes and return it.\n+    fn visit_scopes<T>(\n+        &mut self,\n+        scope_set: ScopeSet,\n+        parent_scope: &ParentScope<'a>,\n+        mut ident: Ident,\n+        mut visitor: impl FnMut(&mut Self, Scope<'a>, Ident) -> Option<T>,\n+    ) -> Option<T> {\n+        // General principles:\n+        // 1. Not controlled (user-defined) names should have higher priority than controlled names\n+        //    built into the language or standard library. This way we can add new names into the\n+        //    language or standard library without breaking user code.\n+        // 2. \"Closed set\" below means new names cannot appear after the current resolution attempt.\n+        // Places to search (in order of decreasing priority):\n+        // (Type NS)\n+        // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Extern prelude (open, the open part is from macro expansions, not controlled).\n+        // 4. Tool modules (closed, controlled right now, but not in the future).\n+        // 5. Standard library prelude (de-facto closed, controlled).\n+        // 6. Language prelude (closed, controlled).\n+        // (Value NS)\n+        // 1. FIXME: Ribs (local variables), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Standard library prelude (de-facto closed, controlled).\n+        // (Macro NS)\n+        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n+        //    are currently reported as errors. They should be higher in priority than preludes\n+        //    and probably even names in modules according to the \"general principles\" above. They\n+        //    also should be subject to restricted shadowing because are effectively produced by\n+        //    derives (you need to resolve the derive first to add helpers into scope), but they\n+        //    should be available before the derive is expanded for compatibility.\n+        //    It's mess in general, so we are being conservative for now.\n+        // 1-3. `macro_rules` (open, not controlled), loop through legacy scopes. Have higher\n+        //    priority than prelude macros, but create ambiguities with macros in modules.\n+        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled). Have higher priority than prelude macros, but create\n+        //    ambiguities with `macro_rules`.\n+        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n+        // 4a. User-defined prelude from macro-use\n+        //    (open, the open part is from macro expansions, not controlled).\n+        // 4b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n+        // 5. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n+        // 6. Language prelude: builtin attributes (closed, controlled).\n+        // 4-6. Legacy plugin helpers (open, not controlled). Similar to derive helpers,\n+        //    but introduced by legacy plugins using `register_attribute`. Priority is somewhere\n+        //    in prelude, not sure where exactly (creates ambiguities with any other prelude names).\n+\n+        let (ns, is_absolute_path) = match scope_set {\n+            ScopeSet::Import(ns) => (ns, false),\n+            ScopeSet::AbsolutePath(ns) => (ns, true),\n+            ScopeSet::Macro(_) => (MacroNS, false),\n+            ScopeSet::Module => (TypeNS, false),\n+        };\n+        let mut scope = match ns {\n+            _ if is_absolute_path => Scope::CrateRoot,\n+            TypeNS | ValueNS => Scope::Module(parent_scope.module),\n+            MacroNS => Scope::DeriveHelpers,\n+        };\n+\n+        loop {\n+            if let break_result @ Some(..) = visitor(self, scope, ident) {\n+                return break_result;\n+            }\n+\n+            scope = match scope {\n+                Scope::DeriveHelpers =>\n+                    Scope::MacroRules(parent_scope.legacy),\n+                Scope::MacroRules(legacy_scope) => match legacy_scope {\n+                    LegacyScope::Binding(binding) => Scope::MacroRules(\n+                        binding.parent_legacy_scope\n+                    ),\n+                    LegacyScope::Invocation(invoc) => Scope::MacroRules(\n+                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope)\n+                    ),\n+                    LegacyScope::Empty => Scope::Module(parent_scope.module),\n+                }\n+                Scope::CrateRoot => match ns {\n+                    TypeNS => {\n+                        ident.span.adjust(Mark::root());\n+                        Scope::ExternPrelude\n+                    }\n+                    ValueNS | MacroNS => break,\n+                }\n+                Scope::Module(module) => {\n+                    match self.hygienic_lexical_parent(module, &mut ident.span) {\n+                        Some(parent_module) => Scope::Module(parent_module),\n+                        None => {\n+                            ident.span.adjust(Mark::root());\n+                            match ns {\n+                                TypeNS => Scope::ExternPrelude,\n+                                ValueNS => Scope::StdLibPrelude,\n+                                MacroNS => Scope::MacroUsePrelude,\n+                            }\n+                        }\n+                    }\n+                }\n+                Scope::MacroUsePrelude => Scope::StdLibPrelude,\n+                Scope::BuiltinMacros => Scope::BuiltinAttrs,\n+                Scope::BuiltinAttrs => Scope::LegacyPluginHelpers,\n+                Scope::LegacyPluginHelpers => break, // nowhere else to search\n+                Scope::ExternPrelude if is_absolute_path => break,\n+                Scope::ExternPrelude => Scope::ToolPrelude,\n+                Scope::ToolPrelude => Scope::StdLibPrelude,\n+                Scope::StdLibPrelude => match ns {\n+                    TypeNS => Scope::BuiltinTypes,\n+                    ValueNS => break, // nowhere else to search\n+                    MacroNS => Scope::BuiltinMacros,\n+                }\n+                Scope::BuiltinTypes => break, // nowhere else to search\n+            };\n+        }\n+\n+        None\n+    }\n+\n     /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n     /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n     /// `ident` in the first scope that defines it (or None if no scopes define it)."}, {"sha": "bc10d230dbdc0d5a5299ef8fef8ead66022ad81a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 47, "deletions": 138, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/1e1b081e0e9dc2fe06839519eaf74bbb84155fbe/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1b081e0e9dc2fe06839519eaf74bbb84155fbe/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=1e1b081e0e9dc2fe06839519eaf74bbb84155fbe", "patch": "@@ -59,7 +59,7 @@ impl<'a> InvocationData<'a> {\n pub struct LegacyBinding<'a> {\n     binding: &'a NameBinding<'a>,\n     /// Legacy scope into which the `macro_rules` item was planted.\n-    parent_legacy_scope: LegacyScope<'a>,\n+    crate parent_legacy_scope: LegacyScope<'a>,\n     ident: Ident,\n }\n \n@@ -421,50 +421,6 @@ impl<'a> Resolver<'a> {\n         force: bool,\n         path_span: Span,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        // General principles:\n-        // 1. Not controlled (user-defined) names should have higher priority than controlled names\n-        //    built into the language or standard library. This way we can add new names into the\n-        //    language or standard library without breaking user code.\n-        // 2. \"Closed set\" below means new names cannot appear after the current resolution attempt.\n-        // Places to search (in order of decreasing priority):\n-        // (Type NS)\n-        // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n-        //    (open set, not controlled).\n-        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 3. Extern prelude (closed, not controlled).\n-        // 4. Tool modules (closed, controlled right now, but not in the future).\n-        // 5. Standard library prelude (de-facto closed, controlled).\n-        // 6. Language prelude (closed, controlled).\n-        // (Value NS)\n-        // 1. FIXME: Ribs (local variables), there's no necessary infrastructure yet\n-        //    (open set, not controlled).\n-        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 3. Standard library prelude (de-facto closed, controlled).\n-        // (Macro NS)\n-        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n-        //    are currently reported as errors. They should be higher in priority than preludes\n-        //    and probably even names in modules according to the \"general principles\" above. They\n-        //    also should be subject to restricted shadowing because are effectively produced by\n-        //    derives (you need to resolve the derive first to add helpers into scope), but they\n-        //    should be available before the derive is expanded for compatibility.\n-        //    It's mess in general, so we are being conservative for now.\n-        // 1-3. `macro_rules` (open, not controlled), loop through legacy scopes. Have higher\n-        //    priority than prelude macros, but create ambiguities with macros in modules.\n-        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled). Have higher priority than prelude macros, but create\n-        //    ambiguities with `macro_rules`.\n-        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n-        // 4a. User-defined prelude from macro-use\n-        //    (open, the open part is from macro expansions, not controlled).\n-        // 4b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n-        // 5. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n-        // 6. Language prelude: builtin attributes (closed, controlled).\n-        // 4-6. Legacy plugin helpers (open, not controlled). Similar to derive helpers,\n-        //    but introduced by legacy plugins using `register_attribute`. Priority is somewhere\n-        //    in prelude, not sure where exactly (creates ambiguities with any other prelude names).\n-\n         bitflags::bitflags! {\n             struct Flags: u8 {\n                 const MACRO_RULES        = 1 << 0;\n@@ -477,13 +433,21 @@ impl<'a> Resolver<'a> {\n         }\n \n         assert!(force || !record_used); // `record_used` implies `force`\n-        let mut ident = orig_ident.modern();\n+        let ident = orig_ident.modern();\n \n         // Make sure `self`, `super` etc produce an error when passed to here.\n         if ident.is_path_segment_keyword() {\n             return Err(Determinacy::Determined);\n         }\n \n+        let rust_2015 = orig_ident.span.rust_2015();\n+        let (ns, macro_kind, is_import, is_absolute_path) = match scope_set {\n+            ScopeSet::Import(ns) => (ns, None, true, false),\n+            ScopeSet::AbsolutePath(ns) => (ns, None, false, true),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false, false),\n+            ScopeSet::Module => (TypeNS, None, false, false),\n+        };\n+\n         // This is *the* result, resolution from the scope closest to the resolved identifier.\n         // However, sometimes this result is \"weak\" because it comes from a glob import or\n         // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.\n@@ -496,34 +460,22 @@ impl<'a> Resolver<'a> {\n         // So we have to save the innermost solution and continue searching in outer scopes\n         // to detect potential ambiguities.\n         let mut innermost_result: Option<(&NameBinding<'_>, Flags)> = None;\n-\n-        // Go through all the scopes and try to resolve the name.\n-        let rust_2015 = orig_ident.span.rust_2015();\n-        let (ns, macro_kind, is_import, is_absolute_path) = match scope_set {\n-            ScopeSet::Import(ns) => (ns, None, true, false),\n-            ScopeSet::AbsolutePath(ns) => (ns, None, false, true),\n-            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false, false),\n-            ScopeSet::Module => (TypeNS, None, false, false),\n-        };\n-        let mut where_to_resolve = match ns {\n-            _ if is_absolute_path => Scope::CrateRoot,\n-            TypeNS | ValueNS => Scope::Module(parent_scope.module),\n-            MacroNS => Scope::DeriveHelpers,\n-        };\n         let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n         let mut determinacy = Determinacy::Determined;\n-        loop {\n-            let result = match where_to_resolve {\n+\n+        // Go through all the scopes and try to resolve the name.\n+        let break_result = self.visit_scopes(scope_set, parent_scope, ident, |this, scope, ident| {\n+            let result = match scope {\n                 Scope::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n                     for derive in &parent_scope.derives {\n                         let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n-                        match self.resolve_macro_path(derive, MacroKind::Derive,\n+                        match this.resolve_macro_path(derive, MacroKind::Derive,\n                                                       &parent_scope, true, force) {\n                             Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n                                 let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n                                                ty::Visibility::Public, derive.span, Mark::root())\n-                                               .to_name_binding(self.arenas);\n+                                               .to_name_binding(this.arenas);\n                                 result = Ok((binding, Flags::empty()));\n                                 break;\n                             }\n@@ -543,8 +495,8 @@ impl<'a> Resolver<'a> {\n                 }\n                 Scope::CrateRoot => {\n                     let root_ident = Ident::new(kw::PathRoot, orig_ident.span);\n-                    let root_module = self.resolve_crate_root(root_ident);\n-                    let binding = self.resolve_ident_in_module_ext(\n+                    let root_module = this.resolve_crate_root(root_ident);\n+                    let binding = this.resolve_ident_in_module_ext(\n                         ModuleOrUniformRoot::Module(root_module),\n                         orig_ident,\n                         ns,\n@@ -555,15 +507,16 @@ impl<'a> Resolver<'a> {\n                     match binding {\n                         Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n                         Err((Determinacy::Undetermined, Weak::No)) =>\n-                            return Err(Determinacy::determined(force)),\n+                            return Some(Err(Determinacy::determined(force))),\n                         Err((Determinacy::Undetermined, Weak::Yes)) =>\n                             Err(Determinacy::Undetermined),\n                         Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n                     }\n                 }\n                 Scope::Module(module) => {\n-                    let orig_current_module = mem::replace(&mut self.current_module, module);\n-                    let binding = self.resolve_ident_in_module_unadjusted_ext(\n+                    use_prelude = !module.no_implicit_prelude;\n+                    let orig_current_module = mem::replace(&mut this.current_module, module);\n+                    let binding = this.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(module),\n                         ident,\n                         ns,\n@@ -572,10 +525,10 @@ impl<'a> Resolver<'a> {\n                         record_used,\n                         path_span,\n                     );\n-                    self.current_module = orig_current_module;\n+                    this.current_module = orig_current_module;\n                     match binding {\n                         Ok(binding) => {\n-                            let misc_flags = if ptr::eq(module, self.graph_root) {\n+                            let misc_flags = if ptr::eq(module, this.graph_root) {\n                                 Flags::MISC_SUGGEST_CRATE\n                             } else if module.is_normal() {\n                                 Flags::MISC_SUGGEST_SELF\n@@ -585,27 +538,27 @@ impl<'a> Resolver<'a> {\n                             Ok((binding, Flags::MODULE | misc_flags))\n                         }\n                         Err((Determinacy::Undetermined, Weak::No)) =>\n-                            return Err(Determinacy::determined(force)),\n+                            return Some(Err(Determinacy::determined(force))),\n                         Err((Determinacy::Undetermined, Weak::Yes)) =>\n                             Err(Determinacy::Undetermined),\n                         Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n                     }\n                 }\n                 Scope::MacroUsePrelude => {\n                     if use_prelude || rust_2015 {\n-                        match self.macro_use_prelude.get(&ident.name).cloned() {\n+                        match this.macro_use_prelude.get(&ident.name).cloned() {\n                             Some(binding) =>\n                                 Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n                             None => Err(Determinacy::determined(\n-                                self.graph_root.unresolved_invocations.borrow().is_empty()\n+                                this.graph_root.unresolved_invocations.borrow().is_empty()\n                             ))\n                         }\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n                 }\n                 Scope::BuiltinMacros => {\n-                    match self.builtin_macros.get(&ident.name).cloned() {\n+                    match this.builtin_macros.get(&ident.name).cloned() {\n                         Some(binding) => Ok((binding, Flags::PRELUDE)),\n                         None => Err(Determinacy::Determined),\n                     }\n@@ -614,30 +567,30 @@ impl<'a> Resolver<'a> {\n                     if is_builtin_attr_name(ident.name) {\n                         let binding = (Res::NonMacroAttr(NonMacroAttrKind::Builtin),\n                                        ty::Visibility::Public, DUMMY_SP, Mark::root())\n-                                       .to_name_binding(self.arenas);\n+                                       .to_name_binding(this.arenas);\n                         Ok((binding, Flags::PRELUDE))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n                 }\n                 Scope::LegacyPluginHelpers => {\n                     if (use_prelude || rust_2015) &&\n-                       self.session.plugin_attributes.borrow().iter()\n+                       this.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == *name) {\n                         let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n                                        ty::Visibility::Public, DUMMY_SP, Mark::root())\n-                                       .to_name_binding(self.arenas);\n+                                       .to_name_binding(this.arenas);\n                         Ok((binding, Flags::PRELUDE))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n                 }\n                 Scope::ExternPrelude => {\n                     if use_prelude || is_absolute_path {\n-                        match self.extern_prelude_get(ident, !record_used) {\n+                        match this.extern_prelude_get(ident, !record_used) {\n                             Some(binding) => Ok((binding, Flags::PRELUDE)),\n                             None => Err(Determinacy::determined(\n-                                self.graph_root.unresolved_invocations.borrow().is_empty()\n+                                this.graph_root.unresolved_invocations.borrow().is_empty()\n                             )),\n                         }\n                     } else {\n@@ -647,7 +600,7 @@ impl<'a> Resolver<'a> {\n                 Scope::ToolPrelude => {\n                     if use_prelude && is_known_tool(ident.name) {\n                         let binding = (Res::ToolMod, ty::Visibility::Public,\n-                                       DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n+                                       DUMMY_SP, Mark::root()).to_name_binding(this.arenas);\n                         Ok((binding, Flags::PRELUDE))\n                     } else {\n                         Err(Determinacy::Determined)\n@@ -656,8 +609,8 @@ impl<'a> Resolver<'a> {\n                 Scope::StdLibPrelude => {\n                     let mut result = Err(Determinacy::Determined);\n                     if use_prelude {\n-                        if let Some(prelude) = self.prelude {\n-                            if let Ok(binding) = self.resolve_ident_in_module_unadjusted(\n+                        if let Some(prelude) = this.prelude {\n+                            if let Ok(binding) = this.resolve_ident_in_module_unadjusted(\n                                 ModuleOrUniformRoot::Module(prelude),\n                                 ident,\n                                 ns,\n@@ -671,10 +624,10 @@ impl<'a> Resolver<'a> {\n                     result\n                 }\n                 Scope::BuiltinTypes => {\n-                    match self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n+                    match this.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n                         Some(prim_ty) => {\n                             let binding = (Res::PrimTy(prim_ty), ty::Visibility::Public,\n-                                           DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n+                                           DUMMY_SP, Mark::root()).to_name_binding(this.arenas);\n                             Ok((binding, Flags::PRELUDE))\n                         }\n                         None => Err(Determinacy::Determined)\n@@ -685,7 +638,7 @@ impl<'a> Resolver<'a> {\n             match result {\n                 Ok((binding, flags)) if sub_namespace_match(binding.macro_kind(), macro_kind) => {\n                     if !record_used {\n-                        return Ok(binding);\n+                        return Some(Ok(binding));\n                     }\n \n                     if let Some((innermost_binding, innermost_flags)) = innermost_result {\n@@ -710,11 +663,11 @@ impl<'a> Resolver<'a> {\n                                 Some(AmbiguityKind::LegacyHelperVsPrelude)\n                             } else if innermost_flags.contains(Flags::MACRO_RULES) &&\n                                       flags.contains(Flags::MODULE) &&\n-                                      !self.disambiguate_legacy_vs_modern(innermost_binding,\n+                                      !this.disambiguate_legacy_vs_modern(innermost_binding,\n                                                                           binding) ||\n                                       flags.contains(Flags::MACRO_RULES) &&\n                                       innermost_flags.contains(Flags::MODULE) &&\n-                                      !self.disambiguate_legacy_vs_modern(binding,\n+                                      !this.disambiguate_legacy_vs_modern(binding,\n                                                                           innermost_binding) {\n                                 Some(AmbiguityKind::LegacyVsModern)\n                             } else if innermost_binding.is_glob_import() {\n@@ -735,15 +688,15 @@ impl<'a> Resolver<'a> {\n                                 } else {\n                                     AmbiguityErrorMisc::None\n                                 };\n-                                self.ambiguity_errors.push(AmbiguityError {\n+                                this.ambiguity_errors.push(AmbiguityError {\n                                     kind,\n                                     ident: orig_ident,\n                                     b1: innermost_binding,\n                                     b2: binding,\n                                     misc1: misc(innermost_flags),\n                                     misc2: misc(flags),\n                                 });\n-                                return Ok(innermost_binding);\n+                                return Some(Ok(innermost_binding));\n                             }\n                         }\n                     } else {\n@@ -755,55 +708,11 @@ impl<'a> Resolver<'a> {\n                 Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined\n             }\n \n-            where_to_resolve = match where_to_resolve {\n-                Scope::DeriveHelpers =>\n-                    Scope::MacroRules(parent_scope.legacy),\n-                Scope::MacroRules(legacy_scope) => match legacy_scope {\n-                    LegacyScope::Binding(binding) => Scope::MacroRules(\n-                        binding.parent_legacy_scope\n-                    ),\n-                    LegacyScope::Invocation(invoc) => Scope::MacroRules(\n-                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope)\n-                    ),\n-                    LegacyScope::Empty => Scope::Module(parent_scope.module),\n-                }\n-                Scope::CrateRoot => match ns {\n-                    TypeNS => {\n-                        ident.span.adjust(Mark::root());\n-                        Scope::ExternPrelude\n-                    }\n-                    ValueNS | MacroNS => break,\n-                }\n-                Scope::Module(module) => {\n-                    match self.hygienic_lexical_parent(module, &mut ident.span) {\n-                        Some(parent_module) => Scope::Module(parent_module),\n-                        None => {\n-                            ident.span.adjust(Mark::root());\n-                            use_prelude = !module.no_implicit_prelude;\n-                            match ns {\n-                                TypeNS => Scope::ExternPrelude,\n-                                ValueNS => Scope::StdLibPrelude,\n-                                MacroNS => Scope::MacroUsePrelude,\n-                            }\n-                        }\n-                    }\n-                }\n-                Scope::MacroUsePrelude => Scope::StdLibPrelude,\n-                Scope::BuiltinMacros => Scope::BuiltinAttrs,\n-                Scope::BuiltinAttrs => Scope::LegacyPluginHelpers,\n-                Scope::LegacyPluginHelpers => break, // nowhere else to search\n-                Scope::ExternPrelude if is_absolute_path => break,\n-                Scope::ExternPrelude => Scope::ToolPrelude,\n-                Scope::ToolPrelude => Scope::StdLibPrelude,\n-                Scope::StdLibPrelude => match ns {\n-                    TypeNS => Scope::BuiltinTypes,\n-                    ValueNS => break, // nowhere else to search\n-                    MacroNS => Scope::BuiltinMacros,\n-                }\n-                Scope::BuiltinTypes => break, // nowhere else to search\n-            };\n+            None\n+        });\n \n-            continue;\n+        if let Some(break_result) = break_result {\n+            return break_result;\n         }\n \n         // The first found solution was the only one, return it."}]}