{"sha": "1fdea560d2b756d1372aa7a8db52aec3a0b94f0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZGVhNTYwZDJiNzU2ZDEzNzJhYTdhOGRiNTJhZWMzYTBiOTRmMGI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-08-14T17:51:49Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-08-18T21:01:12Z"}, "message": "rustc_privacy: Replace `HirId`s and `DefId`s with `LocalDefId`s where possible", "tree": {"sha": "7da10583e8eeb6ff4028e58c28efc5dc419a7b20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7da10583e8eeb6ff4028e58c28efc5dc419a7b20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fdea560d2b756d1372aa7a8db52aec3a0b94f0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fdea560d2b756d1372aa7a8db52aec3a0b94f0b", "html_url": "https://github.com/rust-lang/rust/commit/1fdea560d2b756d1372aa7a8db52aec3a0b94f0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fdea560d2b756d1372aa7a8db52aec3a0b94f0b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1", "html_url": "https://github.com/rust-lang/rust/commit/3d0774d0dc98084d25d95cc1909a8051ebbd9cb1"}], "stats": {"total": 139, "additions": 76, "deletions": 63}, "files": [{"sha": "a683cb05e16b69c448dbe6af7a9ba823fad4d3a6", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 76, "deletions": 63, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/1fdea560d2b756d1372aa7a8db52aec3a0b94f0b/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fdea560d2b756d1372aa7a8db52aec3a0b94f0b/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=1fdea560d2b756d1372aa7a8db52aec3a0b94f0b", "patch": "@@ -11,7 +11,8 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet};\n+use rustc_hir::def_id::{CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, DeepVisitor, NestedVisitorMap, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n@@ -354,9 +355,8 @@ trait VisibilityLike: Sized {\n \n     // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n-    fn of_impl(hir_id: hir::HirId, tcx: TyCtxt<'_>, access_levels: &AccessLevels) -> Self {\n+    fn of_impl(def_id: LocalDefId, tcx: TyCtxt<'_>, access_levels: &AccessLevels) -> Self {\n         let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n-        let def_id = tcx.hir().local_def_id(hir_id);\n         find.visit(tcx.type_of(def_id));\n         if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n             find.visit_trait(trait_ref);\n@@ -424,7 +424,7 @@ struct EmbargoVisitor<'tcx> {\n \n struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n     access_level: Option<AccessLevel>,\n-    item_def_id: DefId,\n+    item_def_id: LocalDefId,\n     ev: &'a mut EmbargoVisitor<'tcx>,\n }\n \n@@ -448,12 +448,12 @@ impl EmbargoVisitor<'tcx> {\n \n     fn reach(\n         &mut self,\n-        item_id: hir::HirId,\n+        def_id: LocalDefId,\n         access_level: Option<AccessLevel>,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n-            item_def_id: self.tcx.hir().local_def_id(item_id).to_def_id(),\n+            item_def_id: def_id,\n             ev: self,\n         }\n     }\n@@ -536,10 +536,10 @@ impl EmbargoVisitor<'tcx> {\n                     | hir::ItemKind::Union(ref struct_def, _) = item.kind\n                     {\n                         for field in struct_def.fields() {\n-                            let field_vis =\n-                                self.tcx.visibility(self.tcx.hir().local_def_id(field.hir_id));\n+                            let def_id = self.tcx.hir().local_def_id(field.hir_id);\n+                            let field_vis = self.tcx.visibility(def_id);\n                             if field_vis.is_accessible_from(module.to_def_id(), self.tcx) {\n-                                self.reach(field.hir_id, level).ty();\n+                                self.reach(def_id, level).ty();\n                             }\n                         }\n                     } else {\n@@ -638,7 +638,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let inherited_item_level = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                Option::<AccessLevel>::of_impl(item.hir_id(), self.tcx, &self.access_levels)\n+                Option::<AccessLevel>::of_impl(item.def_id, self.tcx, &self.access_levels)\n             }\n             // Foreign modules inherit level from parents.\n             hir::ItemKind::ForeignMod { .. } => self.prev_level,\n@@ -750,7 +750,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n                     let exist_level =\n                         cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n-                    self.reach(item.hir_id(), exist_level).generics().predicates().ty();\n+                    self.reach(item.def_id, exist_level).generics().predicates().ty();\n                 }\n             }\n             // Visit everything.\n@@ -759,15 +759,15 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates().ty();\n+                    self.reach(item.def_id, item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates();\n+                    self.reach(item.def_id, item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n-                        let mut reach = self.reach(trait_item_ref.id.hir_id(), item_level);\n+                        let mut reach = self.reach(trait_item_ref.id.def_id, item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n@@ -782,18 +782,18 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates();\n+                    self.reach(item.def_id, item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates().ty().trait_ref();\n+                    self.reach(item.def_id, item_level).generics().predicates().ty().trait_ref();\n \n                     for impl_item_ref in impl_.items {\n                         let impl_item_level = self.get(impl_item_ref.id.def_id);\n                         if impl_item_level.is_some() {\n-                            self.reach(impl_item_ref.id.hir_id(), impl_item_level)\n+                            self.reach(impl_item_ref.id.def_id, impl_item_level)\n                                 .generics()\n                                 .predicates()\n                                 .ty();\n@@ -805,13 +805,14 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates();\n+                    self.reach(item.def_id, item_level).generics().predicates();\n                 }\n                 for variant in def.variants {\n                     let variant_level = self.get(self.tcx.hir().local_def_id(variant.id));\n                     if variant_level.is_some() {\n                         for field in variant.data.fields() {\n-                            self.reach(field.hir_id, variant_level).ty();\n+                            self.reach(self.tcx.hir().local_def_id(field.hir_id), variant_level)\n+                                .ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n@@ -824,7 +825,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 for foreign_item in items {\n                     let foreign_item_level = self.get(foreign_item.id.def_id);\n                     if foreign_item_level.is_some() {\n-                        self.reach(foreign_item.id.hir_id(), foreign_item_level)\n+                        self.reach(foreign_item.id.def_id, foreign_item_level)\n                             .generics()\n                             .predicates()\n                             .ty();\n@@ -834,11 +835,12 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates();\n+                    self.reach(item.def_id, item_level).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_level = self.get(self.tcx.hir().local_def_id(field.hir_id));\n+                        let def_id = self.tcx.hir().local_def_id(field.hir_id);\n+                        let field_level = self.get(def_id);\n                         if field_level.is_some() {\n-                            self.reach(field.hir_id, field_level).ty();\n+                            self.reach(def_id, field_level).ty();\n                         }\n                     }\n                 }\n@@ -992,7 +994,7 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n struct NamePrivacyVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n-    current_item: Option<hir::HirId>,\n+    current_item: LocalDefId,\n }\n \n impl<'tcx> NamePrivacyVisitor<'tcx> {\n@@ -1014,11 +1016,15 @@ impl<'tcx> NamePrivacyVisitor<'tcx> {\n         field: &'tcx ty::FieldDef,\n         in_update_syntax: bool,\n     ) {\n+        if def.is_enum() {\n+            return;\n+        }\n+\n         // definition of the field\n         let ident = Ident::new(kw::Empty, use_ctxt);\n-        let current_hir = self.current_item.unwrap();\n-        let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did, current_hir).1;\n-        if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(self.current_item);\n+        let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did, hir_id).1;\n+        if !field.vis.is_accessible_from(def_id, self.tcx) {\n             let label = if in_update_syntax {\n                 format!(\"field `{}` is private\", field.ident)\n             } else {\n@@ -1063,7 +1069,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = self.current_item.replace(item.hir_id());\n+        let orig_current_item = mem::replace(&mut self.current_item, item.def_id);\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n     }\n@@ -1763,9 +1769,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n struct SearchInterfaceForPrivateItemsVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    item_id: hir::HirId,\n-    item_def_id: DefId,\n-    span: Span,\n+    item_def_id: LocalDefId,\n     /// The visitor checks that each component type is at least this visible.\n     required_visibility: ty::Visibility,\n     has_pub_restricted: bool,\n@@ -1820,8 +1824,8 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n         if self.leaks_private_dep(def_id) {\n             self.tcx.struct_span_lint_hir(\n                 lint::builtin::EXPORTED_PRIVATE_DEPENDENCIES,\n-                self.item_id,\n-                self.span,\n+                self.tcx.hir().local_def_id_to_hir_id(self.item_def_id),\n+                self.tcx.def_span(self.item_def_id.to_def_id()),\n                 |lint| {\n                     lint.build(&format!(\n                         \"{} `{}` from private dependency '{}' in public \\\n@@ -1856,23 +1860,24 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n                 }\n             };\n             let make_msg = || format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n+            let span = self.tcx.def_span(self.item_def_id.to_def_id());\n             if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n                 let mut err = if kind == \"trait\" {\n-                    struct_span_err!(self.tcx.sess, self.span, E0445, \"{}\", make_msg())\n+                    struct_span_err!(self.tcx.sess, span, E0445, \"{}\", make_msg())\n                 } else {\n-                    struct_span_err!(self.tcx.sess, self.span, E0446, \"{}\", make_msg())\n+                    struct_span_err!(self.tcx.sess, span, E0446, \"{}\", make_msg())\n                 };\n                 let vis_span =\n                     self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id));\n-                err.span_label(self.span, format!(\"can't leak {} {}\", vis_descr, kind));\n+                err.span_label(span, format!(\"can't leak {} {}\", vis_descr, kind));\n                 err.span_label(vis_span, format!(\"`{}` declared as {}\", descr, vis_descr));\n                 err.emit();\n             } else {\n                 let err_code = if kind == \"trait\" { \"E0445\" } else { \"E0446\" };\n                 self.tcx.struct_span_lint_hir(\n                     lint::builtin::PRIVATE_IN_PUBLIC,\n                     hir_id,\n-                    self.span,\n+                    span,\n                     |lint| lint.build(&format!(\"{} (error {})\", make_msg(), err_code)).emit(),\n                 );\n             }\n@@ -1915,35 +1920,33 @@ impl DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n struct PrivateItemsInPublicInterfacesVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     has_pub_restricted: bool,\n-    old_error_set_ancestry: HirIdSet,\n+    old_error_set_ancestry: LocalDefIdSet,\n }\n \n impl<'tcx> PrivateItemsInPublicInterfacesVisitor<'tcx> {\n     fn check(\n         &self,\n-        item_id: hir::HirId,\n+        def_id: LocalDefId,\n         required_visibility: ty::Visibility,\n     ) -> SearchInterfaceForPrivateItemsVisitor<'tcx> {\n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: self.tcx,\n-            item_id,\n-            item_def_id: self.tcx.hir().local_def_id(item_id).to_def_id(),\n-            span: self.tcx.hir().span(item_id),\n+            item_def_id: def_id,\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,\n-            has_old_errors: self.old_error_set_ancestry.contains(&item_id),\n+            has_old_errors: self.old_error_set_ancestry.contains(&def_id),\n             in_assoc_ty: false,\n         }\n     }\n \n     fn check_assoc_item(\n         &self,\n-        hir_id: hir::HirId,\n+        def_id: LocalDefId,\n         assoc_item_kind: AssocItemKind,\n         defaultness: hir::Defaultness,\n         vis: ty::Visibility,\n     ) {\n-        let mut check = self.check(hir_id, vis);\n+        let mut check = self.check(def_id, vis);\n \n         let (check_ty, is_assoc_ty) = match assoc_item_kind {\n             AssocItemKind::Const | AssocItemKind::Fn { .. } => (true, false),\n@@ -1982,72 +1985,73 @@ impl<'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'tcx> {\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n-                self.check(item.hir_id(), item_visibility).generics().predicates().ty();\n+                self.check(item.def_id, item_visibility).generics().predicates().ty();\n             }\n             hir::ItemKind::OpaqueTy(..) => {\n                 // `ty()` for opaque types is the underlying type,\n                 // it's not a part of interface, so we skip it.\n-                self.check(item.hir_id(), item_visibility).generics().bounds();\n+                self.check(item.def_id, item_visibility).generics().bounds();\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n-                self.check(item.hir_id(), item_visibility).generics().predicates();\n+                self.check(item.def_id, item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n                     self.check_assoc_item(\n-                        trait_item_ref.id.hir_id(),\n+                        trait_item_ref.id.def_id,\n                         trait_item_ref.kind,\n                         trait_item_ref.defaultness,\n                         item_visibility,\n                     );\n \n                     if let AssocItemKind::Type = trait_item_ref.kind {\n-                        self.check(trait_item_ref.id.hir_id(), item_visibility).bounds();\n+                        self.check(trait_item_ref.id.def_id, item_visibility).bounds();\n                     }\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                self.check(item.hir_id(), item_visibility).generics().predicates();\n+                self.check(item.def_id, item_visibility).generics().predicates();\n             }\n             hir::ItemKind::Enum(ref def, _) => {\n-                self.check(item.hir_id(), item_visibility).generics().predicates();\n+                self.check(item.def_id, item_visibility).generics().predicates();\n \n                 for variant in def.variants {\n                     for field in variant.data.fields() {\n-                        self.check(field.hir_id, item_visibility).ty();\n+                        self.check(self.tcx.hir().local_def_id(field.hir_id), item_visibility).ty();\n                     }\n                 }\n             }\n             // Subitems of foreign modules have their own publicity.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n                     let vis = tcx.visibility(foreign_item.id.def_id);\n-                    self.check(foreign_item.id.hir_id(), vis).generics().predicates().ty();\n+                    self.check(foreign_item.id.def_id, vis).generics().predicates().ty();\n                 }\n             }\n             // Subitems of structs and unions have their own publicity.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.check(item.hir_id(), item_visibility).generics().predicates();\n+                self.check(item.def_id, item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n-                    let field_visibility = tcx.visibility(tcx.hir().local_def_id(field.hir_id));\n-                    self.check(field.hir_id, min(item_visibility, field_visibility, tcx)).ty();\n+                    let def_id = tcx.hir().local_def_id(field.hir_id);\n+                    let field_visibility = tcx.visibility(def_id);\n+                    self.check(def_id, min(item_visibility, field_visibility, tcx)).ty();\n                 }\n             }\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity.\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n             hir::ItemKind::Impl(ref impl_) => {\n-                let impl_vis = ty::Visibility::of_impl(item.hir_id(), tcx, &Default::default());\n-                self.check(item.hir_id(), impl_vis).generics().predicates();\n+                let impl_vis = ty::Visibility::of_impl(item.def_id, tcx, &Default::default());\n+                self.check(item.def_id, impl_vis).generics().predicates();\n                 for impl_item_ref in impl_.items {\n                     let impl_item_vis = if impl_.of_trait.is_none() {\n                         min(tcx.visibility(impl_item_ref.id.def_id), impl_vis, tcx)\n                     } else {\n                         impl_vis\n                     };\n                     self.check_assoc_item(\n-                        impl_item_ref.id.hir_id(),\n+                        impl_item_ref.id.def_id,\n                         impl_item_ref.kind,\n                         impl_item_ref.defaultness,\n                         impl_item_vis,\n@@ -2119,7 +2123,8 @@ fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n \n fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     // Check privacy of names not checked in previous compilation stages.\n-    let mut visitor = NamePrivacyVisitor { tcx, maybe_typeck_results: None, current_item: None };\n+    let mut visitor =\n+        NamePrivacyVisitor { tcx, maybe_typeck_results: None, current_item: module_def_id };\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n \n     intravisit::walk_mod(&mut visitor, module, hir_id);\n@@ -2188,7 +2193,15 @@ fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n     }\n \n     // Check for private types and traits in public interfaces.\n-    let mut visitor =\n-        PrivateItemsInPublicInterfacesVisitor { tcx, has_pub_restricted, old_error_set_ancestry };\n+    let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n+        tcx,\n+        has_pub_restricted,\n+        // Only definition IDs are ever searched in `old_error_set_ancestry`,\n+        // so we can filter away all non-definition IDs at this point.\n+        old_error_set_ancestry: old_error_set_ancestry\n+            .into_iter()\n+            .filter_map(|hir_id| tcx.hir().opt_local_def_id(hir_id))\n+            .collect(),\n+    };\n     krate.visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n }"}]}