{"sha": "5c704f11d2ef82d7517680bba6dd0015d750fca2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNzA0ZjExZDJlZjgyZDc1MTc2ODBiYmE2ZGQwMDE1ZDc1MGZjYTI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-30T16:49:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-30T16:49:13Z"}, "message": "Merge #10088\n\n10088: feat: improve CPU usage r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "58502b4899aa090bb879105b151021333179f35b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58502b4899aa090bb879105b151021333179f35b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c704f11d2ef82d7517680bba6dd0015d750fca2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhLQwJCRBK7hj4Ov3rIwAAx7gIADmz7M182rd2+QBZHJfQ171i\nZiNdOqNhdcPwwW+ct62gmeTwkUBN8Cd35Nyqe/3ZsYgqgnFe7NfT/jmy8cKqxoA1\nCS15WO2uCEQHek3trqktX0sMc7ustjJBo+E30c6AGxGgWOdqHDYPNUtfnctSHZmY\n0Bbk9hAL8Ro7T8iBkFh9Uc8D26S13z9xS24gRXOAUbL9DF9kxp5B/vtCBkeRPjEl\nO0tVFfTirpNAfJgnCj2bJqJhDJSloBBxiGmjBnZSu8vd5EbIM0mRbg+NROxpkxOA\nL7J8VfKQ9v0/3o4k33VqIJHSOnqsmIvPg490Ly9q09uSPBTxwiaC8LZcHH+AeQc=\n=Stj2\n-----END PGP SIGNATURE-----\n", "payload": "tree 58502b4899aa090bb879105b151021333179f35b\nparent bb1987b45e90a4f4bceabe4added1998dc0b2092\nparent 53d20500859fa22fb1c5d96a7c34d72d933ddbea\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1630342153 +0000\ncommitter GitHub <noreply@github.com> 1630342153 +0000\n\nMerge #10088\n\n10088: feat: improve CPU usage r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c704f11d2ef82d7517680bba6dd0015d750fca2", "html_url": "https://github.com/rust-lang/rust/commit/5c704f11d2ef82d7517680bba6dd0015d750fca2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c704f11d2ef82d7517680bba6dd0015d750fca2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb1987b45e90a4f4bceabe4added1998dc0b2092", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb1987b45e90a4f4bceabe4added1998dc0b2092", "html_url": "https://github.com/rust-lang/rust/commit/bb1987b45e90a4f4bceabe4added1998dc0b2092"}, {"sha": "53d20500859fa22fb1c5d96a7c34d72d933ddbea", "url": "https://api.github.com/repos/rust-lang/rust/commits/53d20500859fa22fb1c5d96a7c34d72d933ddbea", "html_url": "https://github.com/rust-lang/rust/commit/53d20500859fa22fb1c5d96a7c34d72d933ddbea"}], "stats": {"total": 198, "additions": 99, "deletions": 99}, "files": [{"sha": "88a9240bfac31f4bbde220e80b916c65e00dc5a6", "filename": "crates/ide/src/prime_caches.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5c704f11d2ef82d7517680bba6dd0015d750fca2/crates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c704f11d2ef82d7517680bba6dd0015d750fca2/crates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches.rs?ref=5c704f11d2ef82d7517680bba6dd0015d750fca2", "patch": "@@ -8,39 +8,26 @@ use ide_db::base_db::SourceDatabase;\n \n use crate::RootDatabase;\n \n+/// We started indexing a crate.\n #[derive(Debug)]\n-pub enum PrimeCachesProgress {\n-    Started,\n-    /// We started indexing a crate.\n-    StartedOnCrate {\n-        on_crate: String,\n-        n_done: usize,\n-        n_total: usize,\n-    },\n-    /// We finished indexing all crates.\n-    Finished,\n+pub struct PrimeCachesProgress {\n+    pub on_crate: String,\n+    pub n_done: usize,\n+    pub n_total: usize,\n }\n \n pub(crate) fn prime_caches(db: &RootDatabase, cb: &(dyn Fn(PrimeCachesProgress) + Sync)) {\n     let _p = profile::span(\"prime_caches\");\n     let graph = db.crate_graph();\n     let topo = &graph.crates_in_topological_order();\n \n-    cb(PrimeCachesProgress::Started);\n-    // Take care to emit the finish signal even when the computation is canceled.\n-    let _d = stdx::defer(|| cb(PrimeCachesProgress::Finished));\n-\n     // FIXME: This would be easy to parallelize, since it's in the ideal ordering for that.\n     // Unfortunately rayon prevents panics from propagation out of a `scope`, which breaks\n     // cancellation, so we cannot use rayon.\n     for (i, &crate_id) in topo.iter().enumerate() {\n         let crate_name = graph[crate_id].display_name.as_deref().unwrap_or_default().to_string();\n \n-        cb(PrimeCachesProgress::StartedOnCrate {\n-            on_crate: crate_name,\n-            n_done: i,\n-            n_total: topo.len(),\n-        });\n+        cb(PrimeCachesProgress { on_crate: crate_name, n_done: i, n_total: topo.len() });\n         db.crate_def_map(crate_id);\n         db.import_map(crate_id);\n     }"}, {"sha": "ad43e7eca0e5b38cc0c0fbda99fbeeb6d937e626", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 67, "deletions": 38, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5c704f11d2ef82d7517680bba6dd0015d750fca2/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c704f11d2ef82d7517680bba6dd0015d750fca2/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=5c704f11d2ef82d7517680bba6dd0015d750fca2", "patch": "@@ -8,11 +8,10 @@ use std::{\n \n use always_assert::always;\n use crossbeam_channel::{select, Receiver};\n-use ide::{FileId, PrimeCachesProgress};\n use ide_db::base_db::{SourceDatabaseExt, VfsPath};\n use lsp_server::{Connection, Notification, Request};\n use lsp_types::notification::Notification as _;\n-use vfs::ChangeKind;\n+use vfs::{ChangeKind, FileId};\n \n use crate::{\n     config::Config,\n@@ -67,6 +66,13 @@ pub(crate) enum Task {\n     FetchBuildData(BuildDataProgress),\n }\n \n+#[derive(Debug)]\n+pub(crate) enum PrimeCachesProgress {\n+    Begin,\n+    Report(ide::PrimeCachesProgress),\n+    End { cancelled: bool },\n+}\n+\n impl fmt::Debug for Event {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let debug_verbose_not = |not: &Notification, f: &mut fmt::Formatter| {\n@@ -146,8 +152,10 @@ impl GlobalState {\n             );\n         }\n \n-        self.fetch_workspaces_request();\n-        self.fetch_workspaces_if_needed();\n+        self.fetch_workspaces_queue.request_op();\n+        if self.fetch_workspaces_queue.should_start_op() {\n+            self.fetch_workspaces();\n+        }\n \n         while let Some(event) = self.next_event(&inbox) {\n             if let Event::Lsp(lsp_server::Message::Notification(not)) = &event {\n@@ -209,17 +217,17 @@ impl GlobalState {\n                             }\n                         }\n                         Task::PrimeCaches(progress) => match progress {\n-                            PrimeCachesProgress::Started => prime_caches_progress.push(progress),\n-                            PrimeCachesProgress::StartedOnCrate { .. } => {\n+                            PrimeCachesProgress::Begin => prime_caches_progress.push(progress),\n+                            PrimeCachesProgress::Report(_) => {\n                                 match prime_caches_progress.last_mut() {\n-                                    Some(last @ PrimeCachesProgress::StartedOnCrate { .. }) => {\n+                                    Some(last @ PrimeCachesProgress::Report(_)) => {\n                                         // Coalesce subsequent update events.\n                                         *last = progress;\n                                     }\n                                     _ => prime_caches_progress.push(progress),\n                                 }\n                             }\n-                            PrimeCachesProgress::Finished => prime_caches_progress.push(progress),\n+                            PrimeCachesProgress::End { .. } => prime_caches_progress.push(progress),\n                         },\n                         Task::FetchWorkspace(progress) => {\n                             let (state, msg) = match progress {\n@@ -228,14 +236,14 @@ impl GlobalState {\n                                     (Progress::Report, Some(msg))\n                                 }\n                                 ProjectWorkspaceProgress::End(workspaces) => {\n-                                    self.fetch_workspaces_completed(workspaces);\n+                                    self.fetch_workspaces_queue.op_completed(workspaces);\n \n                                     let old = Arc::clone(&self.workspaces);\n                                     self.switch_workspaces();\n                                     let workspaces_updated = !Arc::ptr_eq(&old, &self.workspaces);\n \n                                     if self.config.run_build_scripts() && workspaces_updated {\n-                                        self.fetch_build_data_request()\n+                                        self.fetch_build_data_queue.request_op()\n                                     }\n \n                                     (Progress::End, None)\n@@ -251,7 +259,7 @@ impl GlobalState {\n                                     (Some(Progress::Report), Some(msg))\n                                 }\n                                 BuildDataProgress::End(build_data_result) => {\n-                                    self.fetch_build_data_completed(build_data_result);\n+                                    self.fetch_build_data_queue.op_completed(build_data_result);\n \n                                     self.switch_workspaces();\n \n@@ -275,22 +283,28 @@ impl GlobalState {\n                 for progress in prime_caches_progress {\n                     let (state, message, fraction);\n                     match progress {\n-                        PrimeCachesProgress::Started => {\n+                        PrimeCachesProgress::Begin => {\n                             state = Progress::Begin;\n                             message = None;\n                             fraction = 0.0;\n                         }\n-                        PrimeCachesProgress::StartedOnCrate { on_crate, n_done, n_total } => {\n+                        PrimeCachesProgress::Report(report) => {\n                             state = Progress::Report;\n-                            message = Some(format!(\"{}/{} ({})\", n_done, n_total, on_crate));\n-                            fraction = Progress::fraction(n_done, n_total);\n+                            message = Some(format!(\n+                                \"{}/{} ({})\",\n+                                report.n_done, report.n_total, report.on_crate\n+                            ));\n+                            fraction = Progress::fraction(report.n_done, report.n_total);\n                         }\n-                        PrimeCachesProgress::Finished => {\n+                        PrimeCachesProgress::End { cancelled } => {\n                             state = Progress::End;\n                             message = None;\n                             fraction = 1.0;\n \n                             self.prime_caches_queue.op_completed(());\n+                            if cancelled {\n+                                self.prime_caches_queue.request_op();\n+                            }\n                         }\n                     };\n \n@@ -413,26 +427,10 @@ impl GlobalState {\n                 for flycheck in &self.flycheck {\n                     flycheck.update();\n                 }\n+                self.prime_caches_queue.request_op();\n             }\n \n             if !was_quiescent || state_changed {\n-                // Ensure that only one cache priming task can run at a time\n-                self.prime_caches_queue.request_op();\n-                if self.prime_caches_queue.should_start_op() {\n-                    self.task_pool.handle.spawn_with_sender({\n-                        let analysis = self.snapshot().analysis;\n-                        move |sender| {\n-                            let cb = |progress| {\n-                                sender.send(Task::PrimeCaches(progress)).unwrap();\n-                            };\n-                            match analysis.prime_caches(cb) {\n-                                Ok(()) => (),\n-                                Err(_canceled) => (),\n-                            }\n-                        }\n-                    });\n-                }\n-\n                 // Refresh semantic tokens if the client supports it.\n                 if self.config.semantic_tokens_refresh() {\n                     self.semantic_tokens_cache.lock().clear();\n@@ -478,11 +476,43 @@ impl GlobalState {\n         }\n \n         if self.config.cargo_autoreload() {\n-            self.fetch_workspaces_if_needed();\n+            if self.fetch_workspaces_queue.should_start_op() {\n+                self.fetch_workspaces();\n+            }\n+        }\n+        if self.fetch_build_data_queue.should_start_op() {\n+            self.fetch_build_data();\n+        }\n+        if self.prime_caches_queue.should_start_op() {\n+            self.task_pool.handle.spawn_with_sender({\n+                let analysis = self.snapshot().analysis;\n+                move |sender| {\n+                    sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n+                    let res = analysis.prime_caches(|progress| {\n+                        let report = PrimeCachesProgress::Report(progress);\n+                        sender.send(Task::PrimeCaches(report)).unwrap();\n+                    });\n+                    sender\n+                        .send(Task::PrimeCaches(PrimeCachesProgress::End {\n+                            cancelled: res.is_err(),\n+                        }))\n+                        .unwrap();\n+                }\n+            });\n         }\n-        self.fetch_build_data_if_needed();\n \n-        self.report_new_status_if_needed();\n+        let status = self.current_status();\n+        if self.last_reported_status.as_ref() != Some(&status) {\n+            self.last_reported_status = Some(status.clone());\n+\n+            if let (lsp_ext::Health::Error, Some(message)) = (status.health, &status.message) {\n+                self.show_message(lsp_types::MessageType::Error, message.clone());\n+            }\n+\n+            if self.config.server_status_notification() {\n+                self.send_notification::<lsp_ext::ServerStatusNotification>(status);\n+            }\n+        }\n \n         let loop_duration = loop_start.elapsed();\n         if loop_duration > Duration::from_millis(100) {\n@@ -521,8 +551,7 @@ impl GlobalState {\n \n         RequestDispatcher { req: Some(req), global_state: self }\n             .on_sync_mut::<lsp_ext::ReloadWorkspace>(|s, ()| {\n-                s.fetch_workspaces_request();\n-                s.fetch_workspaces_if_needed();\n+                s.fetch_workspaces_queue.request_op();\n                 Ok(())\n             })?\n             .on_sync_mut::<lsp_types::request::Shutdown>(|s, ()| {"}, {"sha": "ad4d81ada7a75291395e1f9440bd246e58bbfeff", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 7, "deletions": 42, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5c704f11d2ef82d7517680bba6dd0015d750fca2/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c704f11d2ef82d7517680bba6dd0015d750fca2/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=5c704f11d2ef82d7517680bba6dd0015d750fca2", "patch": "@@ -47,7 +47,7 @@ impl GlobalState {\n             self.analysis_host.update_lru_capacity(self.config.lru_capacity());\n         }\n         if self.config.linked_projects() != old_config.linked_projects() {\n-            self.fetch_workspaces_request()\n+            self.fetch_workspaces_queue.request_op()\n         } else if self.config.flycheck() != old_config.flycheck() {\n             self.reload_flycheck();\n         }\n@@ -71,7 +71,7 @@ impl GlobalState {\n                 \", \"\n             )\n         );\n-        self.fetch_workspaces_request();\n+        self.fetch_workspaces_queue.request_op();\n \n         fn is_interesting(path: &AbsPath, change_kind: ChangeKind) -> bool {\n             const IMPLICIT_TARGET_FILES: &[&str] = &[\"build.rs\", \"src/main.rs\", \"src/lib.rs\"];\n@@ -109,7 +109,8 @@ impl GlobalState {\n             false\n         }\n     }\n-    pub(crate) fn report_new_status_if_needed(&mut self) {\n+\n+    pub(crate) fn current_status(&self) -> lsp_ext::ServerStatusParams {\n         let mut status = lsp_ext::ServerStatusParams {\n             health: lsp_ext::Health::Ok,\n             quiescent: self.is_quiescent(),\n@@ -132,27 +133,10 @@ impl GlobalState {\n             status.health = lsp_ext::Health::Error;\n             status.message = Some(error)\n         }\n-\n-        if self.last_reported_status.as_ref() != Some(&status) {\n-            self.last_reported_status = Some(status.clone());\n-\n-            if let (lsp_ext::Health::Error, Some(message)) = (status.health, &status.message) {\n-                self.show_message(lsp_types::MessageType::Error, message.clone());\n-            }\n-\n-            if self.config.server_status_notification() {\n-                self.send_notification::<lsp_ext::ServerStatusNotification>(status);\n-            }\n-        }\n+        status\n     }\n \n-    pub(crate) fn fetch_workspaces_request(&mut self) {\n-        self.fetch_workspaces_queue.request_op()\n-    }\n-    pub(crate) fn fetch_workspaces_if_needed(&mut self) {\n-        if !self.fetch_workspaces_queue.should_start_op() {\n-            return;\n-        }\n+    pub(crate) fn fetch_workspaces(&mut self) {\n         tracing::info!(\"will fetch workspaces\");\n \n         self.task_pool.handle.spawn_with_sender({\n@@ -203,21 +187,8 @@ impl GlobalState {\n             }\n         });\n     }\n-    pub(crate) fn fetch_workspaces_completed(\n-        &mut self,\n-        workspaces: Vec<anyhow::Result<ProjectWorkspace>>,\n-    ) {\n-        self.fetch_workspaces_queue.op_completed(workspaces)\n-    }\n-\n-    pub(crate) fn fetch_build_data_request(&mut self) {\n-        self.fetch_build_data_queue.request_op();\n-    }\n-    pub(crate) fn fetch_build_data_if_needed(&mut self) {\n-        if !self.fetch_build_data_queue.should_start_op() {\n-            return;\n-        }\n \n+    pub(crate) fn fetch_build_data(&mut self) {\n         let workspaces = Arc::clone(&self.workspaces);\n         let config = self.config.cargo();\n         self.task_pool.handle.spawn_with_sender(move |sender| {\n@@ -236,12 +207,6 @@ impl GlobalState {\n             sender.send(Task::FetchBuildData(BuildDataProgress::End((workspaces, res)))).unwrap();\n         });\n     }\n-    pub(crate) fn fetch_build_data_completed(\n-        &mut self,\n-        build_data: (Arc<Vec<ProjectWorkspace>>, Vec<anyhow::Result<WorkspaceBuildScripts>>),\n-    ) {\n-        self.fetch_build_data_queue.op_completed(build_data)\n-    }\n \n     pub(crate) fn switch_workspaces(&mut self) {\n         let _p = profile::span(\"GlobalState::switch_workspaces\");"}, {"sha": "6131cdcbdce20cfdf91769697c92628bf8f67e0f", "filename": "docs/dev/style.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5c704f11d2ef82d7517680bba6dd0015d750fca2/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c704f11d2ef82d7517680bba6dd0015d750fca2/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=5c704f11d2ef82d7517680bba6dd0015d750fca2", "patch": "@@ -257,6 +257,25 @@ if idx >= len {\n \n **Rationale:** it's useful to see the invariant relied upon by the rest of the function clearly spelled out.\n \n+## Control Flow\n+\n+As a special case of the previous rule, do not hide control flow inside functions, push it to the caller:\n+\n+```rust\n+// GOOD\n+if cond {\n+    f()\n+}\n+\n+// BAD\n+fn f() {\n+    if !cond {\n+        return;\n+    }\n+    ...\n+}\n+```\n+\n ## Assertions\n \n Assert liberally."}]}