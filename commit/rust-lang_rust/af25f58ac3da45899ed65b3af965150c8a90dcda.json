{"sha": "af25f58ac3da45899ed65b3af965150c8a90dcda", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMjVmNThhYzNkYTQ1ODk5ZWQ2NWIzYWY5NjUxNTBjOGE5MGRjZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-25T19:45:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-25T19:45:54Z"}, "message": "auto merge of #9498 : catamorphism/rust/rust-path-hack-fix, r=cmr,metajack\n\nr? @metajack", "tree": {"sha": "eca071107edf532e600606f68f602e7e3d8f56d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eca071107edf532e600606f68f602e7e3d8f56d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af25f58ac3da45899ed65b3af965150c8a90dcda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af25f58ac3da45899ed65b3af965150c8a90dcda", "html_url": "https://github.com/rust-lang/rust/commit/af25f58ac3da45899ed65b3af965150c8a90dcda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af25f58ac3da45899ed65b3af965150c8a90dcda/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0186473bd2ec34a56496c7b513ee380cbf30a6a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0186473bd2ec34a56496c7b513ee380cbf30a6a3", "html_url": "https://github.com/rust-lang/rust/commit/0186473bd2ec34a56496c7b513ee380cbf30a6a3"}, {"sha": "667adad26f9cc1cfa4eeba8aee15035da7544f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/667adad26f9cc1cfa4eeba8aee15035da7544f8c", "html_url": "https://github.com/rust-lang/rust/commit/667adad26f9cc1cfa4eeba8aee15035da7544f8c"}], "stats": {"total": 162, "additions": 132, "deletions": 30}, "files": [{"sha": "c2fddafd5fe221bf217e73631d7c263432fd214e", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af25f58ac3da45899ed65b3af965150c8a90dcda/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af25f58ac3da45899ed65b3af965150c8a90dcda/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=af25f58ac3da45899ed65b3af965150c8a90dcda", "patch": "@@ -59,7 +59,8 @@ impl PkgSrc {\n         use conditions::nonexistent_package::cond;\n \n         debug!(\"Checking package source for package ID %s, \\\n-               workspace = %s\", id.to_str(), workspace.to_str());\n+               workspace = %s use_rust_path_hack = %?\",\n+               id.to_str(), workspace.to_str(), use_rust_path_hack);\n \n         let mut to_try = ~[];\n         if use_rust_path_hack {"}, {"sha": "7061345341f9c4b9767cbb3af7dc4564e4035c51", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/af25f58ac3da45899ed65b3af965150c8a90dcda/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af25f58ac3da45899ed65b3af965150c8a90dcda/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=af25f58ac3da45899ed65b3af965150c8a90dcda", "patch": "@@ -421,11 +421,16 @@ fn dir_has_file(dir: &Path, file: &str) -> bool {\n pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {\n     let rp = rust_path();\n     for dir in rp.iter() {\n-        debug!(\"In find_dir_using_rust_path_hack: checking dir %s\", dir.to_str());\n-        if dir_has_file(dir, \"lib.rs\") || dir_has_file(dir, \"main.rs\")\n-            || dir_has_file(dir, \"test.rs\") || dir_has_file(dir, \"bench.rs\") {\n-            debug!(\"Did find id %s in dir %s\", p.to_str(), dir.to_str());\n-            return Some(dir.clone());\n+        // Require that the parent directory match the package ID\n+        // Note that this only matches if the package ID being searched for\n+        // has a name that's a single component\n+        if dir.is_parent_of(&p.path) || dir.is_parent_of(&versionize(&p.path, &p.version)) {\n+            debug!(\"In find_dir_using_rust_path_hack: checking dir %s\", dir.to_str());\n+            if dir_has_file(dir, \"lib.rs\") || dir_has_file(dir, \"main.rs\")\n+                || dir_has_file(dir, \"test.rs\") || dir_has_file(dir, \"bench.rs\") {\n+                debug!(\"Did find id %s in dir %s\", p.to_str(), dir.to_str());\n+                return Some(dir.clone());\n+            }\n         }\n         debug!(\"Didn't find id %s in dir %s\", p.to_str(), dir.to_str())\n     }\n@@ -440,3 +445,11 @@ pub fn user_set_rust_path() -> bool {\n         Some(_)         => true\n     }\n }\n+\n+/// Append the version string onto the end of the path's filename\n+fn versionize(p: &Path, v: &Version) -> Path {\n+    let q = p.file_path().to_str();\n+    p.with_filename(fmt!(\"%s-%s\", q, v.to_str()))\n+}\n+\n+"}, {"sha": "52545d60420f9f4aaf80fbdccd6d1606936a3900", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/af25f58ac3da45899ed65b3af965150c8a90dcda/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af25f58ac3da45899ed65b3af965150c8a90dcda/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=af25f58ac3da45899ed65b3af965150c8a90dcda", "patch": "@@ -1267,7 +1267,9 @@ fn test_rust_path_can_contain_package_dirs_without_flag() {\n #[test]\n fn rust_path_hack_cwd() {\n    // Same as rust_path_hack_test, but the CWD is the dir to build out of\n-   let cwd = mkdtemp(&os::tmpdir(), \"pkg_files\").expect(\"rust_path_hack_cwd\");\n+   let cwd = mkdtemp(&os::tmpdir(), \"foo\").expect(\"rust_path_hack_cwd\");\n+   let cwd = cwd.push(\"foo\");\n+   assert!(os::mkdir_recursive(&cwd, U_RWX));\n    writeFile(&cwd.push(\"lib.rs\"), \"pub fn f() { }\");\n \n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n@@ -1763,6 +1765,41 @@ fn reinstall() {\n     assert_built_executable_exists(&workspace, b.short_name);\n }\n \n+#[test]\n+fn correct_package_name_with_rust_path_hack() {\n+    /*\n+    Set rust_path_hack flag\n+\n+    Try to install bar\n+    Check that:\n+    - no output gets produced in any workspace\n+    - there's an error\n+    */\n+\n+    // Set RUST_PATH to something containing only the sources for foo\n+    let foo_id = PkgId::new(\"foo\");\n+    let bar_id = PkgId::new(\"bar\");\n+    let foo_workspace = create_local_package(&foo_id);\n+    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n+\n+    writeFile(&dest_workspace.push_many([\"src\", \"bar-0.1\", \"main.rs\"]),\n+              \"extern mod blat; fn main() { let _x = (); }\");\n+\n+    let rust_path = Some(~[(~\"RUST_PATH\", fmt!(\"%s:%s\", dest_workspace.to_str(),\n+                        foo_workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n+    // bar doesn't exist, but we want to make sure rustpkg doesn't think foo is bar\n+    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"bar\"],\n+                               &dest_workspace, rust_path);\n+    assert!(!executable_exists(&dest_workspace, \"bar\"));\n+    assert!(!lib_exists(&dest_workspace, &bar_id.path.clone(), bar_id.version.clone()));\n+    assert!(!executable_exists(&dest_workspace, \"foo\"));\n+    assert!(!lib_exists(&dest_workspace, &foo_id.path.clone(), foo_id.version.clone()));\n+    assert!(!executable_exists(&foo_workspace, \"bar\"));\n+    assert!(!lib_exists(&foo_workspace, &bar_id.path.clone(), bar_id.version.clone()));\n+    assert!(!executable_exists(&foo_workspace, \"foo\"));\n+    assert!(!lib_exists(&foo_workspace, &foo_id.path.clone(), foo_id.version.clone()));\n+}\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};"}, {"sha": "b30ad6f2c92970ac6d3152606935a4270a134dd5", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/af25f58ac3da45899ed65b3af965150c8a90dcda/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af25f58ac3da45899ed65b3af965150c8a90dcda/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=af25f58ac3da45899ed65b3af965150c8a90dcda", "patch": "@@ -439,26 +439,30 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                         let pkg_id = PkgId::new(lib_name);\n                         let workspaces = pkg_parent_workspaces(&self.context.context,\n                                                                &pkg_id);\n-                        let dep_workspace = if workspaces.is_empty() {\n-                            error(fmt!(\"Couldn't find package %s, which is needed by %s, \\\n-                                            in any of the workspaces in the RUST_PATH (%?)\",\n-                                            lib_name,\n-                                            self.parent.to_str(),\n-                                            rust_path()));\n+                        let source_workspace = if workspaces.is_empty() {\n+                            error(fmt!(\"Couldn't find package %s \\\n+                                       in any of the workspaces in the RUST_PATH (%s)\",\n+                                       lib_name,\n+                                       rust_path().map(|s| s.to_str()).connect(\":\")));\n                             cond.raise((pkg_id.clone(), ~\"Dependency not found\"))\n                         }\n-                        else {\n+                            else {\n                             workspaces[0]\n                         };\n                         let (outputs_disc, inputs_disc) =\n-                            self.context.install(PkgSrc::new(dep_workspace.clone(),\n-                                                             false,\n+                            self.context.install(PkgSrc::new(source_workspace.clone(),\n+                            // Use the rust_path_hack to search for dependencies iff\n+                            // we were already using it\n+                            self.context.context.use_rust_path_hack,\n                                                              pkg_id),\n                                                  &JustOne(Path(\n-                                                    lib_crate_filename)));\n+                                    lib_crate_filename)));\n                         debug!(\"Installed %s, returned %? dependencies and \\\n                                %? transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());\n+                        // It must have installed *something*...\n+                        assert!(!outputs_disc.is_empty());\n+                        let target_workspace = outputs_disc[0].pop();\n                         for dep in outputs_disc.iter() {\n                             debug!(\"Discovering a binary input: %s\", dep.to_str());\n                             self.exec.discover_input(\"binary\",\n@@ -471,31 +475,24 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                          *dep,\n                                                          digest_file_with_date(&Path(*dep)));\n                             }\n-                            else if *what == ~\"binary\" {\n+                                else if *what == ~\"binary\" {\n                                 self.exec.discover_input(*what,\n                                                          *dep,\n                                                          digest_only_date(&Path(*dep)));\n                             }\n-                            else {\n+                                else {\n                                 fail!(\"Bad kind: %s\", *what);\n                             }\n                         }\n                         // Also, add an additional search path\n-                        debug!(\"Adding additional search path: %s\", lib_name);\n-                        let installed_library =\n-                            installed_library_in_workspace(&Path(lib_name), &dep_workspace)\n-                                .expect(fmt!(\"rustpkg failed to install dependency %s\",\n-                                              lib_name));\n-                        let install_dir = installed_library.pop();\n-                        debug!(\"Installed %s into %s [%?]\", lib_name, install_dir.to_str(),\n-                               datestamp(&installed_library));\n-                        (self.save)(install_dir);\n+                        debug!(\"Installed %s into %s\", lib_name, target_workspace.to_str());\n+                        (self.save)(target_workspace);\n                     }\n-                }}\n+                }\n+            }\n             // Ignore `use`s\n             _ => ()\n         }\n-\n         visit::walk_view_item(self, vi, env)\n     }\n }"}, {"sha": "af2565ec67a36eea69fb70c138b03eca36e38f42", "filename": "src/libstd/path.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/af25f58ac3da45899ed65b3af965150c8a90dcda/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af25f58ac3da45899ed65b3af965150c8a90dcda/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=af25f58ac3da45899ed65b3af965150c8a90dcda", "patch": "@@ -233,6 +233,21 @@ pub trait GenericPath : Clone + Eq + ToStr {\n         result\n     }\n \n+\n+    /// Returns `true` iff `child` is a suffix of `parent`. See the test\n+    /// case for examples.\n+    fn is_parent_of(&self, child: &Self) -> bool {\n+        if !self.is_absolute() || child.is_absolute()\n+            || self.components().len() < child.components().len()\n+            || self.components().is_empty() {\n+            return false;\n+        }\n+        let child_components = child.components().len();\n+        let parent_components = self.components().len();\n+        let to_drop = self.components().len() - child_components;\n+        self.components().slice(to_drop, parent_components) == child.components()\n+    }\n+\n     fn components<'a>(&'a self) -> &'a [~str];\n }\n \n@@ -1450,4 +1465,43 @@ mod tests {\n \n     }\n \n+\n+    #[test]\n+    fn test_is_parent_of() {\n+        fn is_parent_of_pp(p: &PosixPath, q: &PosixPath) -> bool {\n+            p.is_parent_of(q)\n+        }\n+\n+        assert!(is_parent_of_pp(&PosixPath(\"/a/b/c/d/e\"), &PosixPath(\"c/d/e\")));\n+        assert!(!is_parent_of_pp(&PosixPath(\"a/b/c/d/e\"), &PosixPath(\"c/d/e\")));\n+        assert!(!is_parent_of_pp(&PosixPath(\"/a/b/c/d/e\"), &PosixPath(\"/c/d/e\")));\n+        assert!(!is_parent_of_pp(&PosixPath(\"\"), &PosixPath(\"\")));\n+        assert!(!is_parent_of_pp(&PosixPath(\"\"), &PosixPath(\"a/b/c\")));\n+        assert!(is_parent_of_pp(&PosixPath(\"/a/b/c\"), &PosixPath(\"\")));\n+        assert!(is_parent_of_pp(&PosixPath(\"/a/b/c\"), &PosixPath(\"a/b/c\")));\n+        assert!(!is_parent_of_pp(&PosixPath(\"/a/b/c\"), &PosixPath(\"d/e/f\")));\n+\n+        fn is_parent_of_wp(p: &WindowsPath, q: &WindowsPath) -> bool {\n+            p.is_parent_of(q)\n+        }\n+\n+        let abcde = WindowsPath(\"C:\\\\a\\\\b\\\\c\\\\d\\\\e\");\n+        let rel_abcde = WindowsPath(\"a\\\\b\\\\c\\\\d\\\\e\");\n+        let cde   = WindowsPath(\"c\\\\d\\\\e\");\n+        let slashcde = WindowsPath(\"C:\\\\c\\\\d\\\\e\");\n+        let empty = WindowsPath(\"\");\n+        let abc = WindowsPath(\"C:\\\\a\\\\b\\\\c\");\n+        let rel_abc = WindowsPath(\"a\\\\b\\\\c\");\n+        let def = WindowsPath(\"d\\\\e\\\\f\");\n+\n+        assert!(is_parent_of_wp(&abcde, &cde));\n+        assert!(!is_parent_of_wp(&rel_abcde, &cde));\n+        assert!(!is_parent_of_wp(&abcde, &slashcde));\n+        assert!(!is_parent_of_wp(&empty, &empty));\n+        assert!(!is_parent_of_wp(&empty, &rel_abc));\n+        assert!(is_parent_of_wp(&abc, &empty));\n+        assert!(is_parent_of_wp(&abc, &rel_abc));\n+        assert!(!is_parent_of_wp(&abc, &def));\n+    }\n+\n }"}]}