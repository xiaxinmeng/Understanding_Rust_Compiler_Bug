{"sha": "d26d187ff83b0b10687a3c380114cda1590d9e26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNmQxODdmZjgzYjBiMTA2ODdhM2MzODAxMTRjZGExNTkwZDllMjY=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-05-07T21:51:10Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-05-07T22:57:25Z"}, "message": "Replace `MatchVisitor::check_in_cx` with `MatchVisitor::new_cx`.\n\nThe closure isn't necessary.", "tree": {"sha": "3e3d0177fae588ac3c39121126fbef9785adb69c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e3d0177fae588ac3c39121126fbef9785adb69c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d26d187ff83b0b10687a3c380114cda1590d9e26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d26d187ff83b0b10687a3c380114cda1590d9e26", "html_url": "https://github.com/rust-lang/rust/commit/d26d187ff83b0b10687a3c380114cda1590d9e26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d26d187ff83b0b10687a3c380114cda1590d9e26/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95f600d6b9aa892000c8d525a5f5cee9f89b6d1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/95f600d6b9aa892000c8d525a5f5cee9f89b6d1d", "html_url": "https://github.com/rust-lang/rust/commit/95f600d6b9aa892000c8d525a5f5cee9f89b6d1d"}], "stats": {"total": 155, "additions": 75, "deletions": 80}, "files": [{"sha": "0f22288437ca198dec8f5d601e71eb7a5404f55d", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 75, "deletions": 80, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/d26d187ff83b0b10687a3c380114cda1590d9e26/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d187ff83b0b10687a3c380114cda1590d9e26/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=d26d187ff83b0b10687a3c380114cda1590d9e26", "patch": "@@ -147,15 +147,13 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         (pattern, pattern_ty)\n     }\n \n-    fn check_in_cx(&self, hir_id: HirId, f: impl FnOnce(MatchCheckCtxt<'_, 'tcx>)) {\n-        let module = self.tcx.parent_module(hir_id);\n-        let cx = MatchCheckCtxt {\n+    fn new_cx(&self, hir_id: HirId) -> MatchCheckCtxt<'_, 'tcx> {\n+        MatchCheckCtxt {\n             tcx: self.tcx,\n             param_env: self.param_env,\n-            module: module.to_def_id(),\n+            module: self.tcx.parent_module(hir_id).to_def_id(),\n             pattern_arena: &self.pattern_arena,\n-        };\n-        f(cx);\n+        }\n     }\n \n     fn check_match(\n@@ -169,91 +167,88 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             self.check_patterns(arm.guard.is_some(), &arm.pat);\n         }\n \n-        self.check_in_cx(scrut.hir_id, |ref mut cx| {\n-            let mut have_errors = false;\n+        let mut cx = self.new_cx(scrut.hir_id);\n \n-            let inlined_arms: Vec<_> = arms\n-                .iter()\n-                .map(|hir::Arm { pat, guard, .. }| {\n-                    (self.lower_pattern(cx, pat, &mut have_errors).0, pat.hir_id, guard.is_some())\n-                })\n-                .collect();\n+        let mut have_errors = false;\n \n-            // Bail out early if inlining failed.\n-            if have_errors {\n-                return;\n-            }\n+        let inlined_arms: Vec<_> = arms\n+            .iter()\n+            .map(|hir::Arm { pat, guard, .. }| {\n+                (self.lower_pattern(&mut cx, pat, &mut have_errors).0, pat.hir_id, guard.is_some())\n+            })\n+            .collect();\n \n-            // Fourth, check for unreachable arms.\n-            let matrix = check_arms(cx, &inlined_arms, source);\n+        // Bail out early if inlining failed.\n+        if have_errors {\n+            return;\n+        }\n+\n+        // Fourth, check for unreachable arms.\n+        let matrix = check_arms(&mut cx, &inlined_arms, source);\n \n-            // Fifth, check if the match is exhaustive.\n-            let scrut_ty = self.tables.node_type(scrut.hir_id);\n-            // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n-            // since an empty matrix can occur when there are arms, if those arms all have guards.\n-            let is_empty_match = inlined_arms.is_empty();\n-            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n-        })\n+        // Fifth, check if the match is exhaustive.\n+        let scrut_ty = self.tables.node_type(scrut.hir_id);\n+        // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n+        // since an empty matrix can occur when there are arms, if those arms all have guards.\n+        let is_empty_match = inlined_arms.is_empty();\n+        check_exhaustive(&mut cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n     }\n \n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n-        self.check_in_cx(pat.hir_id, |ref mut cx| {\n-            let (pattern, pattern_ty) = self.lower_pattern(cx, pat, &mut false);\n-            let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n-\n-            let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n-                Ok(_) => return,\n-                Err(err) => err,\n-            };\n-\n-            let joined_patterns = joined_uncovered_patterns(&witnesses);\n-            let mut err = struct_span_err!(\n-                self.tcx.sess,\n-                pat.span,\n-                E0005,\n-                \"refutable pattern in {}: {} not covered\",\n-                origin,\n-                joined_patterns\n-            );\n-            let suggest_if_let = match &pat.kind {\n-                hir::PatKind::Path(hir::QPath::Resolved(None, path))\n-                    if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n-                {\n-                    const_not_var(&mut err, cx.tcx, pat, path);\n-                    false\n-                }\n-                _ => {\n-                    err.span_label(\n-                        pat.span,\n-                        pattern_not_covered_label(&witnesses, &joined_patterns),\n-                    );\n-                    true\n-                }\n-            };\n+        let mut cx = self.new_cx(pat.hir_id);\n \n-            if let (Some(span), true) = (sp, suggest_if_let) {\n-                err.note(\n-                    \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n-                     an `enum` with only one variant\",\n-                );\n-                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"you might want to use `if let` to ignore the variant that isn't matched\",\n-                        format!(\"if {} {{ /* */ }}\", &snippet[..snippet.len() - 1]),\n-                        Applicability::HasPlaceholders,\n-                    );\n-                }\n-                err.note(\n-                    \"for more information, visit \\\n-                     https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n+        let (pattern, pattern_ty) = self.lower_pattern(&mut cx, pat, &mut false);\n+        let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n+\n+        let witnesses = match check_not_useful(&mut cx, pattern_ty, &pats, pat.hir_id) {\n+            Ok(_) => return,\n+            Err(err) => err,\n+        };\n+\n+        let joined_patterns = joined_uncovered_patterns(&witnesses);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            pat.span,\n+            E0005,\n+            \"refutable pattern in {}: {} not covered\",\n+            origin,\n+            joined_patterns\n+        );\n+        let suggest_if_let = match &pat.kind {\n+            hir::PatKind::Path(hir::QPath::Resolved(None, path))\n+                if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n+            {\n+                const_not_var(&mut err, cx.tcx, pat, path);\n+                false\n+            }\n+            _ => {\n+                err.span_label(pat.span, pattern_not_covered_label(&witnesses, &joined_patterns));\n+                true\n+            }\n+        };\n+\n+        if let (Some(span), true) = (sp, suggest_if_let) {\n+            err.note(\n+                \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n+                 an `enum` with only one variant\",\n+            );\n+            if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                err.span_suggestion(\n+                    span,\n+                    \"you might want to use `if let` to ignore the variant that isn't matched\",\n+                    format!(\"if {} {{ /* */ }}\", &snippet[..snippet.len() - 1]),\n+                    Applicability::HasPlaceholders,\n                 );\n             }\n+            err.note(\n+                \"for more information, visit \\\n+                 https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n+            );\n+        }\n \n-            adt_defined_here(cx, &mut err, pattern_ty, &witnesses);\n-            err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n-            err.emit();\n-        });\n+        adt_defined_here(&mut cx, &mut err, pattern_ty, &witnesses);\n+        err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n+        err.emit();\n     }\n }\n "}]}