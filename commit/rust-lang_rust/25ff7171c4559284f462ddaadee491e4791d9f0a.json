{"sha": "25ff7171c4559284f462ddaadee491e4791d9f0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZmY3MTcxYzQ1NTkyODRmNDYyZGRhYWRlZTQ5MWU0NzkxZDlmMGE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-02T18:42:25Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-03T14:41:53Z"}, "message": "Introduce TypeInfo", "tree": {"sha": "c6d5bb1859aa9216cb3f0414840dc529cda23299", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6d5bb1859aa9216cb3f0414840dc529cda23299"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25ff7171c4559284f462ddaadee491e4791d9f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25ff7171c4559284f462ddaadee491e4791d9f0a", "html_url": "https://github.com/rust-lang/rust/commit/25ff7171c4559284f462ddaadee491e4791d9f0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25ff7171c4559284f462ddaadee491e4791d9f0a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29506b5a26ef0c448c0e50164b2a7782fb7e3f5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/29506b5a26ef0c448c0e50164b2a7782fb7e3f5a", "html_url": "https://github.com/rust-lang/rust/commit/29506b5a26ef0c448c0e50164b2a7782fb7e3f5a"}], "stats": {"total": 251, "additions": 127, "deletions": 124}, "files": [{"sha": "c47988fc4c2620eca90911dacb465f1fd6ca73fc", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -89,7 +89,7 @@ pub use crate::{\n         UnresolvedModule, UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n-    semantics::{PathResolution, Semantics, SemanticsScope},\n+    semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo},\n };\n \n // Be careful with these re-exports."}, {"sha": "c94c7923c9bca3d7a2fb2176306defa4f6fed819", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -87,6 +87,28 @@ impl PathResolution {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct TypeInfo {\n+    /// The original type of the expression or pattern.\n+    pub ty: Type,\n+    /// The coerced type, if a coercion happened.\n+    pub coerced: Option<Type>,\n+}\n+\n+impl TypeInfo {\n+    pub fn ty(self) -> Type {\n+        self.ty\n+    }\n+\n+    pub fn coerced(self) -> Option<Type> {\n+        self.coerced\n+    }\n+\n+    pub fn coerced_or_original(self) -> Type {\n+        self.coerced.unwrap_or(self.ty)\n+    }\n+}\n+\n /// Primary API to get semantic information, like types, from syntax trees.\n pub struct Semantics<'db, DB> {\n     pub db: &'db DB,\n@@ -212,23 +234,14 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_type(ty)\n     }\n \n-    pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n+    pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<TypeInfo> {\n         self.imp.type_of_expr(expr)\n     }\n \n-    /// Returns true in case a coercion happened.\n-    pub fn type_of_expr_with_coercion(&self, expr: &ast::Expr) -> Option<(Type, bool)> {\n-        self.imp.type_of_expr_with_coercion(expr)\n-    }\n-\n-    pub fn type_of_pat(&self, pat: &ast::Pat) -> Option<Type> {\n+    pub fn type_of_pat(&self, pat: &ast::Pat) -> Option<TypeInfo> {\n         self.imp.type_of_pat(pat)\n     }\n \n-    pub fn type_of_pat_with_coercion(&self, expr: &ast::Pat) -> Option<(Type, bool)> {\n-        self.imp.type_of_pat_with_coercion(expr)\n-    }\n-\n     pub fn type_of_self(&self, param: &ast::SelfParam) -> Option<Type> {\n         self.imp.type_of_self(param)\n     }\n@@ -565,20 +578,16 @@ impl<'db> SemanticsImpl<'db> {\n         Type::new_with_resolver(self.db, &scope.resolver, ty)\n     }\n \n-    fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n-        self.analyze(expr.syntax()).type_of_expr(self.db, expr)\n-    }\n-\n-    fn type_of_expr_with_coercion(&self, expr: &ast::Expr) -> Option<(Type, bool)> {\n-        self.analyze(expr.syntax()).type_of_expr_with_coercion(self.db, expr)\n-    }\n-\n-    fn type_of_pat(&self, pat: &ast::Pat) -> Option<Type> {\n-        self.analyze(pat.syntax()).type_of_pat(self.db, pat)\n+    fn type_of_expr(&self, expr: &ast::Expr) -> Option<TypeInfo> {\n+        self.analyze(expr.syntax())\n+            .type_of_expr(self.db, expr)\n+            .map(|(ty, coerced)| TypeInfo { ty, coerced })\n     }\n \n-    fn type_of_pat_with_coercion(&self, pat: &ast::Pat) -> Option<(Type, bool)> {\n-        self.analyze(pat.syntax()).type_of_pat_with_coercion(self.db, pat)\n+    fn type_of_pat(&self, pat: &ast::Pat) -> Option<TypeInfo> {\n+        self.analyze(pat.syntax())\n+            .type_of_pat(self.db, pat)\n+            .map(|(ty, coerced)| TypeInfo { ty, coerced })\n     }\n \n     fn type_of_self(&self, param: &ast::SelfParam) -> Option<Type> {\n@@ -757,7 +766,7 @@ impl<'db> SemanticsImpl<'db> {\n                     ast::Expr::FieldExpr(field_expr) => field_expr,\n                     _ => return None,\n                 };\n-                let ty = self.type_of_expr(&field_expr.expr()?)?;\n+                let ty = self.type_of_expr(&field_expr.expr()?)?.ty;\n                 if !ty.is_packed(self.db) {\n                     return None;\n                 }\n@@ -784,7 +793,7 @@ impl<'db> SemanticsImpl<'db> {\n                 self.type_of_expr(&expr)\n             })\n             // Binding a reference to a packed type is possibly unsafe.\n-            .map(|ty| ty.is_packed(self.db))\n+            .map(|ty| ty.ty.is_packed(self.db))\n             .unwrap_or(false)\n \n         // FIXME This needs layout computation to be correct. It will highlight\n@@ -830,7 +839,7 @@ impl<'db> SemanticsImpl<'db> {\n                 }\n             })\n             // Binding a reference to a packed type is possibly unsafe.\n-            .map(|ty| ty.is_packed(self.db))\n+            .map(|ty| ty.ty.is_packed(self.db))\n             .unwrap_or(false)\n     }\n }"}, {"sha": "cb6fd69bc600b9cd2e86a8a2758c276d31a96286", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -116,46 +116,36 @@ impl SourceAnalyzer {\n         Some(res)\n     }\n \n-    pub(crate) fn type_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<Type> {\n-        let expr_id = self.expr_id(db, expr)?;\n-        let ty = self.infer.as_ref()?[expr_id].clone();\n-        Type::new_with_resolver(db, &self.resolver, ty)\n-    }\n-\n-    pub(crate) fn type_of_expr_with_coercion(\n+    pub(crate) fn type_of_expr(\n         &self,\n         db: &dyn HirDatabase,\n         expr: &ast::Expr,\n-    ) -> Option<(Type, bool)> {\n+    ) -> Option<(Type, Option<Type>)> {\n         let expr_id = self.expr_id(db, expr)?;\n         let infer = self.infer.as_ref()?;\n-        let (ty, coerced) = infer\n+        let coerced = infer\n             .expr_adjustments\n             .get(&expr_id)\n-            .and_then(|adjusts| adjusts.last().map(|adjust| (&adjust.target, true)))\n-            .unwrap_or_else(|| (&infer[expr_id], false));\n-        Type::new_with_resolver(db, &self.resolver, ty.clone()).zip(Some(coerced))\n-    }\n-\n-    pub(crate) fn type_of_pat(&self, db: &dyn HirDatabase, pat: &ast::Pat) -> Option<Type> {\n-        let pat_id = self.pat_id(pat)?;\n-        let ty = self.infer.as_ref()?[pat_id].clone();\n-        Type::new_with_resolver(db, &self.resolver, ty)\n+            .and_then(|adjusts| adjusts.last().map(|adjust| adjust.target.clone()));\n+        let ty = infer[expr_id].clone();\n+        let mk_ty = |ty| Type::new_with_resolver(db, &self.resolver, ty);\n+        mk_ty(ty.clone()).zip(Some(coerced.and_then(mk_ty)))\n     }\n \n-    pub(crate) fn type_of_pat_with_coercion(\n+    pub(crate) fn type_of_pat(\n         &self,\n         db: &dyn HirDatabase,\n         pat: &ast::Pat,\n-    ) -> Option<(Type, bool)> {\n+    ) -> Option<(Type, Option<Type>)> {\n         let pat_id = self.pat_id(pat)?;\n         let infer = self.infer.as_ref()?;\n-        let (ty, coerced) = infer\n+        let coerced = infer\n             .pat_adjustments\n             .get(&pat_id)\n-            .and_then(|adjusts| adjusts.last().map(|adjust| (&adjust.target, true)))\n-            .unwrap_or_else(|| (&infer[pat_id], false));\n-        Type::new_with_resolver(db, &self.resolver, ty.clone()).zip(Some(coerced))\n+            .and_then(|adjusts| adjusts.last().map(|adjust| adjust.target.clone()));\n+        let ty = infer[pat_id].clone();\n+        let mk_ty = |ty| Type::new_with_resolver(db, &self.resolver, ty);\n+        mk_ty(ty.clone()).zip(Some(coerced.and_then(mk_ty)))\n     }\n \n     pub(crate) fn type_of_self("}, {"sha": "428f3f1c6d66058184e76ddf6ae7d2db33c92b4b", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -86,7 +86,7 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n             let name_ref = call_node.name_ref()?;\n             let func_target = match call_node {\n                 FnCallNode::CallExpr(expr) => {\n-                    let callable = sema.type_of_expr(&expr.expr()?)?.as_callable(db)?;\n+                    let callable = sema.type_of_expr(&expr.expr()?)?.ty.as_callable(db)?;\n                     match callable.kind() {\n                         hir::CallableKind::Function(it) => it.try_to_nav(db),\n                         _ => None,"}, {"sha": "3e9dfb8cb672d80a448362b84c3abf66ff929289", "filename": "crates/ide/src/goto_type_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -32,8 +32,8 @@ pub(crate) fn goto_type_definition(\n     let (ty, node) = sema.token_ancestors_with_macros(token).find_map(|node| {\n         let ty = match_ast! {\n             match node {\n-                ast::Expr(it) => sema.type_of_expr(&it)?,\n-                ast::Pat(it) => sema.type_of_pat(&it)?,\n+                ast::Expr(it) => sema.type_of_expr(&it)?.ty,\n+                ast::Pat(it) => sema.type_of_pat(&it)?.ty,\n                 ast::SelfParam(it) => sema.type_of_self(&it)?,\n                 ast::Type(it) => sema.resolve_type(&it)?,\n                 ast::RecordField(it) => sema.to_def(&it).map(|d| d.ty(db.upcast()))?,"}, {"sha": "a1c50c6364ea99cc40634447497cb0af2c82b2ca", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -123,7 +123,7 @@ fn highlight_exit_points(\n                 }\n             }\n             ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroCall(_) => {\n-                if sema.type_of_expr(&expr).map_or(false, |ty| ty.is_never()) {\n+                if sema.type_of_expr(&expr).map_or(false, |ty| ty.ty.is_never()) {\n                     highlights\n                         .push(HighlightedRange { access: None, range: expr.syntax().text_range() });\n                 }"}, {"sha": "9ca20776b54417fadf40443714db7ed41b917385", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics};\n+use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n use ide_db::{\n     base_db::{FileRange, SourceDatabase},\n     defs::{Definition, NameClass, NameRefClass},\n@@ -225,19 +225,15 @@ fn hover_type_info(\n     config: &HoverConfig,\n     expr_or_pat: &Either<ast::Expr, ast::Pat>,\n ) -> Option<HoverResult> {\n-    let (ty, coerced) = match expr_or_pat {\n-        Either::Left(expr) => sema.type_of_expr_with_coercion(expr)?,\n-        Either::Right(pat) => sema.type_of_pat_with_coercion(pat)?,\n+    let TypeInfo { ty, coerced } = match expr_or_pat {\n+        Either::Left(expr) => sema.type_of_expr(expr)?,\n+        Either::Right(pat) => sema.type_of_pat(pat)?,\n     };\n \n     let mut res = HoverResult::default();\n-    res.markup = if coerced {\n-        let uncoerced_ty = match expr_or_pat {\n-            Either::Left(expr) => sema.type_of_expr(expr)?,\n-            Either::Right(pat) => sema.type_of_pat(pat)?,\n-        };\n-        let uncoerced = uncoerced_ty.display(sema.db).to_string();\n-        let coerced = ty.display(sema.db).to_string();\n+    res.markup = if let Some(coerced_ty) = coerced {\n+        let uncoerced = ty.display(sema.db).to_string();\n+        let coerced = coerced_ty.display(sema.db).to_string();\n         format!(\n             \"```text\\nType: {:>upad$}\\nCoerced to: {:>cpad$}\\n```\\n\",\n             uncoerced = uncoerced,"}, {"sha": "48c2f893aaf9963d5967fbacbe05d1bb04acff32", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use hir::{known, Callable, HasVisibility, HirDisplay, Semantics};\n+use hir::{known, Callable, HasVisibility, HirDisplay, Semantics, TypeInfo};\n use ide_db::helpers::FamousDefs;\n use ide_db::RootDatabase;\n use stdx::to_lower_snake_case;\n@@ -117,7 +117,7 @@ fn get_chaining_hints(\n             next_next = tokens.next()?.kind();\n         }\n         if next_next == T![.] {\n-            let ty = sema.type_of_expr(&expr)?;\n+            let ty = sema.type_of_expr(&expr)?.ty;\n             if ty.is_unknown() {\n                 return None;\n             }\n@@ -189,7 +189,7 @@ fn get_bind_pat_hints(\n     let krate = sema.scope(pat.syntax()).module().map(|it| it.krate());\n     let famous_defs = FamousDefs(sema, krate);\n \n-    let ty = sema.type_of_pat(&pat.clone().into())?;\n+    let ty = sema.type_of_pat(&pat.clone().into())?.ty;\n \n     if should_not_display_type_hint(sema, &pat, &ty) {\n         return None;\n@@ -308,6 +308,7 @@ fn should_not_display_type_hint(\n                     return it.in_token().is_none() ||\n                         it.iterable()\n                             .and_then(|iterable_expr| sema.type_of_expr(&iterable_expr))\n+                            .map(TypeInfo::ty)\n                             .map_or(true, |iterable_ty| iterable_ty.is_unknown() || iterable_ty.is_unit())\n                 },\n                 _ => (),\n@@ -393,7 +394,7 @@ fn is_enum_name_similar_to_param_name(\n     argument: &ast::Expr,\n     param_name: &str,\n ) -> bool {\n-    match sema.type_of_expr(argument).and_then(|t| t.as_adt()) {\n+    match sema.type_of_expr(argument).and_then(|t| t.ty.as_adt()) {\n         Some(hir::Adt::Enum(e)) => to_lower_snake_case(&e.name(sema.db).to_string()) == param_name,\n         _ => false,\n     }\n@@ -430,7 +431,7 @@ fn get_callable(\n ) -> Option<(hir::Callable, ast::ArgList)> {\n     match expr {\n         ast::Expr::CallExpr(expr) => {\n-            sema.type_of_expr(&expr.expr()?)?.as_callable(sema.db).zip(expr.arg_list())\n+            sema.type_of_expr(&expr.expr()?)?.ty.as_callable(sema.db).zip(expr.arg_list())\n         }\n         ast::Expr::MethodCallExpr(expr) => {\n             sema.resolve_method_call_as_callable(expr).zip(expr.arg_list())"}, {"sha": "9d028c29014c48fd2b28e5d95481aae1e75b3073", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -123,7 +123,7 @@ pub(super) fn element(\n                 let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n \n                 let expr = prefix_expr.expr()?;\n-                let ty = sema.type_of_expr(&expr)?;\n+                let ty = sema.type_of_expr(&expr)?.ty;\n                 if ty.is_raw_ptr() {\n                     HlTag::Operator(HlOperator::Other) | HlMod::Unsafe\n                 } else if let Some(ast::PrefixOp::Deref) = prefix_expr.op_kind() {\n@@ -555,7 +555,7 @@ fn highlight_method_call(\n                 if let Some(receiver_ty) =\n                     method_call.receiver().and_then(|it| sema.type_of_expr(&it))\n                 {\n-                    if !receiver_ty.is_copy(sema.db) {\n+                    if !receiver_ty.ty.is_copy(sema.db) {\n                         h |= HlMod::Consuming\n                     }\n                 }"}, {"sha": "9b5bb71b1b469a8f50dfeda68ba63e7c0e57860f", "filename": "crates/ide_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -54,9 +54,10 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     }\n \n     let ty = match (pat, expr) {\n-        (ast::Pat::IdentPat(_), Some(expr)) => ctx.sema.type_of_expr_with_coercion(&expr)?.0,\n+        (ast::Pat::IdentPat(_), Some(expr)) => ctx.sema.type_of_expr(&expr)?,\n         (pat, _) => ctx.sema.type_of_pat(&pat)?,\n-    };\n+    }\n+    .coerced_or_original();\n \n     // Unresolved or unnameable types can't be annotated\n     if ty.contains_unknown() || ty.is_closure() {"}, {"sha": "b6457da36211687e8fe7ca1ee19b5b5ad7be09e4", "filename": "crates/ide_assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -86,7 +86,7 @@ fn validate_method_call_expr(\n     let receiver = expr.receiver()?;\n     let expr = ast::Expr::MethodCallExpr(expr);\n \n-    let it_type = sema.type_of_expr(&receiver)?;\n+    let it_type = sema.type_of_expr(&receiver)?.ty;\n     let module = sema.scope(receiver.syntax()).module()?;\n     let krate = module.krate();\n "}, {"sha": "3ac794f45e04319b24eff90889869b99cd28a06c", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -2,7 +2,7 @@ use std::{hash::BuildHasherDefault, iter};\n \n use ast::make;\n use either::Either;\n-use hir::{HirDisplay, Local, Semantics};\n+use hir::{HirDisplay, Local, Semantics, TypeInfo};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n     search::{FileReference, ReferenceAccess, SearchScope},\n@@ -344,7 +344,9 @@ impl FlowKind {\n         match self {\n             FlowKind::Return(Some(expr))\n             | FlowKind::Break(Some(expr))\n-            | FlowKind::TryReturn { expr, .. } => ctx.sema.type_of_expr(expr),\n+            | FlowKind::TryReturn { expr, .. } => {\n+                ctx.sema.type_of_expr(expr).map(TypeInfo::coerced_or_original)\n+            }\n             FlowKind::Try { .. } => {\n                 stdx::never!(\"try does not have defined expr_ty\");\n                 None\n@@ -850,10 +852,7 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n \n fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n     match body.tail_expr() {\n-        Some(expr) => {\n-            let ty = ctx.sema.type_of_expr(&expr)?;\n-            Some(RetType::Expr(ty))\n-        }\n+        Some(expr) => ctx.sema.type_of_expr(&expr).map(TypeInfo::ty).map(RetType::Expr),\n         None => Some(RetType::Stmt),\n     }\n }\n@@ -950,7 +949,7 @@ fn expr_err_kind(expr: &ast::Expr, ctx: &AssistContext) -> Option<TryKind> {\n     let text = func_name.syntax().text();\n \n     if text == \"Err\" {\n-        Some(TryKind::Result { ty: ctx.sema.type_of_expr(expr)? })\n+        Some(TryKind::Result { ty: ctx.sema.type_of_expr(expr).map(TypeInfo::ty)? })\n     } else if text == \"None\" {\n         Some(TryKind::Option)\n     } else {"}, {"sha": "6d457f319162ddae14831470051909f7f6cccb29", "filename": "crates/ide_assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -39,8 +39,8 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext) -> Option\n         .ancestors()\n         .take_while(|it| it.text_range().contains_range(ctx.frange.range))\n         .find_map(valid_target_expr)?;\n-    if let Some(ty) = ctx.sema.type_of_expr(&to_extract) {\n-        if ty.is_unit() {\n+    if let Some(ty_info) = ctx.sema.type_of_expr(&to_extract) {\n+        if ty_info.ty.is_unit() {\n             return None;\n         }\n     }"}, {"sha": "4e060529a9de629519369c3979544540670fc739", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -223,7 +223,7 @@ impl ExtendedEnum {\n }\n \n fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<ExtendedEnum> {\n-    sema.type_of_expr(expr)?.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n+    sema.type_of_expr(expr)?.ty.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n         Some(Adt::Enum(e)) => Some(ExtendedEnum::Enum(e)),\n         _ => ty.is_bool().then(|| ExtendedEnum::Bool),\n     })\n@@ -234,6 +234,7 @@ fn resolve_tuple_of_enum_def(\n     expr: &ast::Expr,\n ) -> Option<Vec<ExtendedEnum>> {\n     sema.type_of_expr(expr)?\n+        .ty\n         .tuple_fields(sema.db)\n         .iter()\n         .map(|ty| {"}, {"sha": "365f26a02a7074e346bf28f8edfb34e28605822f", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -1,4 +1,4 @@\n-use hir::HirDisplay;\n+use hir::{HirDisplay, TypeInfo};\n use ide_db::{base_db::FileId, helpers::SnippetCap};\n use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::to_lower_snake_case;\n@@ -153,7 +153,7 @@ impl FunctionBuilder {\n         // type, but that the current state of their code doesn't allow that return type\n         // to be accurately inferred.\n         let (ret_ty, should_render_snippet) = {\n-            match ctx.sema.type_of_expr(&ast::Expr::CallExpr(call.clone())) {\n+            match ctx.sema.type_of_expr(&ast::Expr::CallExpr(call.clone())).map(TypeInfo::ty) {\n                 Some(ty) if ty.is_unknown() || ty.is_unit() => (make::ty_unit(), true),\n                 Some(ty) => {\n                     let rendered = ty.display_source_code(ctx.db(), target_module.into());\n@@ -331,7 +331,7 @@ fn fn_arg_type(\n     target_module: hir::Module,\n     fn_arg: &ast::Expr,\n ) -> Option<String> {\n-    let ty = ctx.sema.type_of_expr(fn_arg)?;\n+    let ty = ctx.sema.type_of_expr(fn_arg)?.ty;\n     if ty.is_unknown() {\n         return None;\n     }"}, {"sha": "0dfce46466e82726ddceff66293ad3545cff9d4e", "filename": "crates/ide_assists/src/handlers/infer_function_return_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -18,7 +18,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n pub(crate) fn infer_function_return_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let (fn_type, tail_expr, builder_edit_pos) = extract_tail(ctx)?;\n     let module = ctx.sema.scope(tail_expr.syntax()).module()?;\n-    let ty = ctx.sema.type_of_expr(&tail_expr)?;\n+    let ty = ctx.sema.type_of_expr(&tail_expr)?.ty;\n     if ty.is_unit() {\n         return None;\n     }"}, {"sha": "fd098bcaf9d711649fa3df71ef2fa645f1b21698", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -1,5 +1,5 @@\n use ast::make;\n-use hir::{HasSource, PathResolution};\n+use hir::{HasSource, PathResolution, TypeInfo};\n use ide_db::{defs::Definition, search::FileReference};\n use itertools::izip;\n use syntax::{\n@@ -189,10 +189,9 @@ pub(crate) fn inline_(\n                     _ => {\n                         let ty = ctx\n                             .sema\n-                            .type_of_expr_with_coercion(&expr)\n-                            .map_or(false, |(_, coerced)| coerced)\n-                            .then(|| param_ty)\n-                            .flatten();\n+                            .type_of_expr(&expr)\n+                            .and_then(TypeInfo::coerced)\n+                            .and_then(|_| param_ty);\n                         body.push_front(\n                             make::let_stmt(pat, ty, Some(expr)).clone_for_update().into(),\n                         )"}, {"sha": "b67ec8b14c509a57bc2efa8a2c10b917bc2ad49b", "filename": "crates/ide_assists/src/handlers/replace_for_loop_with_for_each.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -80,13 +80,13 @@ fn is_ref_and_impls_iter_method(\n     };\n     let wanted_method = if ref_expr.mut_token().is_some() { known::iter_mut } else { known::iter };\n     let expr_behind_ref = ref_expr.expr()?;\n-    let typ = sema.type_of_expr(&expr_behind_ref)?;\n+    let ty = sema.type_of_expr(&expr_behind_ref)?.ty;\n     let scope = sema.scope(iterable.syntax());\n     let krate = scope.module()?.krate();\n     let traits_in_scope = scope.traits_in_scope();\n     let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n \n-    let has_wanted_method = typ\n+    let has_wanted_method = ty\n         .iterate_method_candidates(\n             sema.db,\n             krate,\n@@ -110,7 +110,7 @@ fn is_ref_and_impls_iter_method(\n /// Whether iterable implements core::Iterator\n fn impls_core_iter(sema: &hir::Semantics<ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {\n     let it_typ = match sema.type_of_expr(iterable) {\n-        Some(it) => it,\n+        Some(it) => it.ty,\n         None => return false,\n     };\n "}, {"sha": "a458bced0c4143094a3017eb8b62e03614d065b0", "filename": "crates/ide_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -127,7 +127,7 @@ fn make_else_arm(\n         let pattern = if let [(Either::Left(pat), _)] = conditionals {\n             ctx.sema\n                 .type_of_pat(&pat)\n-                .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n+                .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty.ty))\n                 .zip(Some(pat))\n         } else {\n             None\n@@ -268,7 +268,7 @@ fn binds_name(pat: &ast::Pat) -> bool {\n \n fn is_sad_pat(sema: &hir::Semantics<RootDatabase>, pat: &ast::Pat) -> bool {\n     sema.type_of_pat(pat)\n-        .and_then(|ty| TryEnum::from_ty(sema, &ty))\n+        .and_then(|ty| TryEnum::from_ty(sema, &ty.ty))\n         .map_or(false, |it| does_pat_match_variant(pat, &it.sad_pattern()))\n }\n "}, {"sha": "2f95af8ef2e1d6ae941b36dbdf48f1ea54e595e2", "filename": "crates/ide_assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -50,7 +50,7 @@ pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) ->\n         |edit| {\n             let ty = ctx.sema.type_of_expr(&init);\n             let happy_variant =\n-                ty.and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty)).map(|it| it.happy_case());\n+                ty.and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty.ty)).map(|it| it.happy_case());\n             let pat = match happy_variant {\n                 None => original_pat,\n                 Some(var_name) => {"}, {"sha": "2e58c58c19ca69fb4438ccb56f2cf2b30f1737c2", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -273,7 +273,9 @@ fn bin_impls_ord(sema: &Semantics<RootDatabase>, bin: &ast::BinExpr) -> bool {\n         bin.lhs().and_then(|lhs| sema.type_of_expr(&lhs)),\n         bin.rhs().and_then(|rhs| sema.type_of_expr(&rhs)),\n     ) {\n-        (Some(lhs_ty), Some(rhs_ty)) if lhs_ty == rhs_ty => {\n+        (Some(hir::TypeInfo { ty: lhs_ty, .. }), Some(hir::TypeInfo { ty: rhs_ty, .. }))\n+            if lhs_ty == rhs_ty =>\n+        {\n             let krate = sema.scope(bin.syntax()).module().map(|it| it.krate());\n             let ord_trait = FamousDefs(sema, krate).core_cmp_Ord();\n             ord_trait.map_or(false, |ord_trait| {"}, {"sha": "da5370a6d0bd6c2f198f4652649b00534ea2d4b0", "filename": "crates/ide_assists/src/utils/suggest_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -197,7 +197,7 @@ fn from_param(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> Option<St\n         match args_parent {\n             ast::CallExpr(call) => {\n                 let func = call.expr()?;\n-                let func_ty = sema.type_of_expr(&func)?;\n+                let func_ty = sema.type_of_expr(&func)?.ty;\n                 func_ty.as_callable(sema.db)?\n             },\n             ast::MethodCallExpr(method) => sema.resolve_method_call_as_callable(&method)?,\n@@ -225,7 +225,7 @@ fn var_name_from_pat(pat: &ast::Pat) -> Option<ast::Name> {\n }\n \n fn from_type(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> Option<String> {\n-    let ty = sema.type_of_expr(expr)?;\n+    let ty = sema.type_of_expr(expr)?.ty;\n     let ty = ty.remove_ref().unwrap_or(ty);\n \n     name_of_type(&ty, sema.db)"}, {"sha": "564f5f2eae491bba7b3f577cc72dd79deef8a9ba", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -14,7 +14,7 @@ pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     };\n \n     let receiver_ty = match ctx.sema.type_of_expr(dot_receiver) {\n-        Some(ty) => ty,\n+        Some(ty) => ty.ty,\n         _ => return,\n     };\n "}, {"sha": "e10eb269368d3cddbdc02d8b78bb0fe52641e80e", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -180,7 +180,7 @@ fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAs\n     if let Some(dot_receiver) = ctx.dot_receiver() {\n         ImportAssets::for_fuzzy_method_call(\n             current_module,\n-            ctx.sema.type_of_expr(dot_receiver)?,\n+            ctx.sema.type_of_expr(dot_receiver)?.ty,\n             fuzzy_name,\n             dot_receiver.syntax().clone(),\n         )"}, {"sha": "7ec1f939c3e7a8d76bb902106b3a9bddb29f596c", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -38,7 +38,7 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n     let receiver_text = get_receiver_text(dot_receiver, receiver_is_ambiguous_float_literal);\n \n     let receiver_ty = match ctx.sema.type_of_expr(dot_receiver) {\n-        Some(it) => it,\n+        Some(it) => it.ty,\n         None => return,\n     };\n "}, {"sha": "d15375634de5d7a37fe0e4816243f7ef4e42d893", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -14,7 +14,7 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n             let default_trait = FamousDefs(&ctx.sema, ctx.krate).core_default_Default();\n             let impl_default_trait = default_trait\n                 .zip(ty)\n-                .map_or(false, |(default_trait, ty)| ty.impls_trait(ctx.db, default_trait, &[]));\n+                .map_or(false, |(default_trait, ty)| ty.ty.impls_trait(ctx.db, default_trait, &[]));\n \n             let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n             if impl_default_trait && !missing_fields.is_empty() {"}, {"sha": "6922c203cead414efa9522871159b187414f3383", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -1,7 +1,7 @@\n //! See `CompletionContext` structure.\n \n use base_db::SourceDatabaseExt;\n-use hir::{Local, Name, ScopeDef, Semantics, SemanticsScope, Type};\n+use hir::{Local, Name, ScopeDef, Semantics, SemanticsScope, Type, TypeInfo};\n use ide_db::{\n     base_db::{FilePosition, SourceDatabase},\n     call_info::ActiveParameter,\n@@ -453,7 +453,8 @@ impl<'a> CompletionContext<'a> {\n                         cov_mark::hit!(expected_type_let_without_leading_char);\n                         let ty = it.pat()\n                             .and_then(|pat| self.sema.type_of_pat(&pat))\n-                            .or_else(|| it.initializer().and_then(|it| self.sema.type_of_expr(&it)));\n+                            .or_else(|| it.initializer().and_then(|it| self.sema.type_of_expr(&it)))\n+                            .map(TypeInfo::ty);\n                         let name = if let Some(ast::Pat::IdentPat(ident)) = it.pat() {\n                             ident.name().map(NameOrNameRef::Name)\n                         } else {\n@@ -496,27 +497,27 @@ impl<'a> CompletionContext<'a> {\n                     ast::RecordExprField(it) => {\n                         cov_mark::hit!(expected_type_struct_field_with_leading_char);\n                         (\n-                            it.expr().as_ref().and_then(|e| self.sema.type_of_expr(e)),\n+                            it.expr().as_ref().and_then(|e| self.sema.type_of_expr(e)).map(TypeInfo::ty),\n                             it.field_name().map(NameOrNameRef::NameRef),\n                         )\n                     },\n                     ast::MatchExpr(it) => {\n                         cov_mark::hit!(expected_type_match_arm_without_leading_char);\n-                        let ty = it.expr()\n-                            .and_then(|e| self.sema.type_of_expr(&e));\n+                        let ty = it.expr().and_then(|e| self.sema.type_of_expr(&e)).map(TypeInfo::ty);\n                         (ty, None)\n                     },\n                     ast::IfExpr(it) => {\n                         cov_mark::hit!(expected_type_if_let_without_leading_char);\n                         let ty = it.condition()\n                             .and_then(|cond| cond.expr())\n-                            .and_then(|e| self.sema.type_of_expr(&e));\n+                            .and_then(|e| self.sema.type_of_expr(&e))\n+                            .map(TypeInfo::ty);\n                         (ty, None)\n                     },\n                     ast::IdentPat(it) => {\n                         cov_mark::hit!(expected_type_if_let_with_leading_char);\n                         cov_mark::hit!(expected_type_match_arm_with_leading_char);\n-                        let ty = self.sema.type_of_pat(&ast::Pat::from(it));\n+                        let ty = self.sema.type_of_pat(&ast::Pat::from(it)).map(TypeInfo::ty);\n                         (ty, None)\n                     },\n                     ast::Fn(it) => {\n@@ -527,7 +528,7 @@ impl<'a> CompletionContext<'a> {\n                     },\n                     ast::ClosureExpr(it) => {\n                         let ty = self.sema.type_of_expr(&it.into());\n-                        ty.and_then(|ty| ty.as_callable(self.db))\n+                        ty.and_then(|ty| ty.ty.as_callable(self.db))\n                             .map(|c| (Some(c.return_type()), None))\n                             .unwrap_or((None, None))\n                     },"}, {"sha": "ea2662185f08868e39c60638cea4847256fc13f6", "filename": "crates/ide_db/src/call_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -118,7 +118,7 @@ fn call_info_impl(\n     let calling_node = FnCallNode::with_node(&token.parent()?)?;\n \n     let callable = match &calling_node {\n-        FnCallNode::CallExpr(call) => sema.type_of_expr(&call.expr()?)?.as_callable(sema.db)?,\n+        FnCallNode::CallExpr(call) => sema.type_of_expr(&call.expr()?)?.ty.as_callable(sema.db)?,\n         FnCallNode::MethodCallExpr(call) => sema.resolve_method_call_as_callable(call)?,\n     };\n     let active_param = if let Some(arg_list) = calling_node.arg_list() {"}, {"sha": "6e174ffb840435a220b9c899e4356b6e4fa7ded7", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -543,7 +543,7 @@ impl ImportCandidate {\n         match sema.resolve_method_call(method_call) {\n             Some(_) => None,\n             None => Some(Self::TraitMethod(TraitImportCandidate {\n-                receiver_ty: sema.type_of_expr(&method_call.receiver()?)?,\n+                receiver_ty: sema.type_of_expr(&method_call.receiver()?)?.ty,\n                 assoc_item_name: NameToImport::Exact(method_call.name_ref()?.to_string()),\n             })),\n         }"}, {"sha": "06dc8dcd8bad9ec9c6891f2d879d069d271f809b", "filename": "crates/ide_diagnostics/src/handlers/missing_ok_or_some_in_tail_expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -1,4 +1,4 @@\n-use hir::db::AstDatabase;\n+use hir::{db::AstDatabase, TypeInfo};\n use ide_db::{assists::Assist, helpers::for_each_tail_expr, source_change::SourceChange};\n use syntax::AstNode;\n use text_edit::TextEdit;\n@@ -35,7 +35,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingOkOrSomeInTailExpr) -> Op\n     let tail_expr_range = tail_expr.syntax().text_range();\n     let mut builder = TextEdit::builder();\n     for_each_tail_expr(&tail_expr, &mut |expr| {\n-        if ctx.sema.type_of_expr(expr).as_ref() != Some(&d.expected) {\n+        if ctx.sema.type_of_expr(expr).map(TypeInfo::ty).as_ref() != Some(&d.expected) {\n             builder.insert(expr.syntax().text_range().start(), format!(\"{}(\", d.required));\n             builder.insert(expr.syntax().text_range().end(), \")\".to_string());\n         }"}, {"sha": "cf0d5f9b25133ac0a1dadf99155c13f915bf9081", "filename": "crates/ide_diagnostics/src/handlers/no_such_field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -62,7 +62,7 @@ fn missing_record_expr_field_fixes(\n     };\n     let def_file_id = def_file_id.original_file(sema.db);\n \n-    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n+    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?.ty;\n     if new_field_type.is_unknown() {\n         return None;\n     }"}, {"sha": "6699d29f97b43ec9ddcf61fc5e5338722aed5cde", "filename": "crates/ide_ssr/src/matching.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ff7171c4559284f462ddaadee491e4791d9f0a/crates%2Fide_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fmatching.rs?ref=25ff7171c4559284f462ddaadee491e4791d9f0a", "patch": "@@ -609,9 +609,13 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         expr: &ast::Expr,\n     ) -> Result<usize, MatchFailed> {\n         use hir::HirDisplay;\n-        let code_type = self.sema.type_of_expr(expr).ok_or_else(|| {\n-            match_error!(\"Failed to get receiver type for `{}`\", expr.syntax().text())\n-        })?;\n+        let code_type = self\n+            .sema\n+            .type_of_expr(expr)\n+            .ok_or_else(|| {\n+                match_error!(\"Failed to get receiver type for `{}`\", expr.syntax().text())\n+            })?\n+            .ty;\n         // Temporary needed to make the borrow checker happy.\n         let res = code_type\n             .autoderef(self.sema.db)"}]}