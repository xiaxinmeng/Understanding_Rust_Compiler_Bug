{"sha": "aa03871a6efd240c16eacf6f8e9a56d708a71b62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMDM4NzFhNmVmZDI0MGMxNmVhY2Y2ZjhlOWE1NmQ3MDhhNzFiNjI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-23T23:54:32Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-26T04:34:56Z"}, "message": "rustc: combine type-flag-checking traits and fns and into one trait.", "tree": {"sha": "e33a6202a5b9b214d3627d0b705f8c2cf738b394", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e33a6202a5b9b214d3627d0b705f8c2cf738b394"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa03871a6efd240c16eacf6f8e9a56d708a71b62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa03871a6efd240c16eacf6f8e9a56d708a71b62", "html_url": "https://github.com/rust-lang/rust/commit/aa03871a6efd240c16eacf6f8e9a56d708a71b62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa03871a6efd240c16eacf6f8e9a56d708a71b62/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "378a370ff2057afeb1eae86eb6e78c476866a4a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/378a370ff2057afeb1eae86eb6e78c476866a4a6", "html_url": "https://github.com/rust-lang/rust/commit/378a370ff2057afeb1eae86eb6e78c476866a4a6"}], "stats": {"total": 737, "additions": 306, "deletions": 431}, "files": [{"sha": "57814fbe8f89e01c62373c0166e9b5af71b1c9f8", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -21,7 +21,7 @@ pub use self::DefIdSource::*;\n use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty::{self, ToPredicate, Ty};\n+use middle::ty::{self, ToPredicate, Ty, HasTypeFlags};\n \n use std::str;\n use syntax::abi;\n@@ -534,7 +534,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n             // If there is a closure buried in the type some where, then we\n             // need to re-convert any def ids (see case 'k', below). That means\n             // we can't reuse the cached version.\n-            if !ty::type_has_ty_closure(tt) {\n+            if !tt.has_closure_types() {\n                 return tt;\n             }\n           }"}, {"sha": "5e720125aa00b2907056bc0f7aea8b6ec4dbda30", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -400,7 +400,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n \n     fn fully_normalize<T>(&self, value: &T) -> Result<T,ErrorReported>\n-        where T : TypeFoldable<'tcx> + ty::HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + ty::HasTypeFlags\n     {\n         let value =\n             traits::fully_normalize(self.infcx,"}, {"sha": "8839e68e767f2f77261137f86fca775f42eafc46", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -77,7 +77,7 @@ use middle::def;\n use middle::infer;\n use middle::region;\n use middle::subst;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::{Region, ReFree};\n \n use std::cell::{Cell, RefCell};\n@@ -226,7 +226,7 @@ pub trait ErrorReporting<'tcx> {\n \n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>;\n@@ -504,18 +504,18 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>\n     {\n         let expected = exp_found.expected.resolve(self);\n-        if expected.contains_error() {\n+        if expected.references_error() {\n             return None;\n         }\n \n         let found = exp_found.found.resolve(self);\n-        if found.contains_error() {\n+        if found.references_error() {\n             return None;\n         }\n \n@@ -1793,26 +1793,19 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n pub trait Resolvable<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Self;\n-    fn contains_error(&self) -> bool;\n }\n \n impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n-    fn contains_error(&self) -> bool {\n-        ty::type_is_error(*self)\n-    }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n                    -> ty::TraitRef<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n-    fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(self)\n-    }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n@@ -1822,10 +1815,6 @@ impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n     {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n-\n-    fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(&self.0)\n-    }\n }\n \n fn lifetimes_in_scope(tcx: &ty::ctxt,"}, {"sha": "26655a24c324b93013dcf426874738f745460170", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -30,7 +30,7 @@\n //! variable only once, and it does so as soon as it can, so it is reasonable to ask what the type\n //! inferencer knows \"so far\".\n \n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n@@ -104,7 +104,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_needs_infer(t) && !ty::type_has_erasable_regions(t) {\n+        if !t.needs_infer() && !t.has_erasable_regions() {\n             return t;\n         }\n "}, {"sha": "0c38b655b34ad87c1c333179cbb2c53745e9945d", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -26,7 +26,7 @@ use middle::free_region::FreeRegionMap;\n use middle::subst;\n use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n@@ -973,20 +973,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let resolved_expected = expected_ty.map(|e_ty| self.resolve_type_vars_if_possible(&e_ty));\n \n-        match resolved_expected {\n-            Some(t) if ty::type_is_error(t) => (),\n-            _ => {\n-                let error_str = err.map_or(\"\".to_string(), |t_err| {\n-                    format!(\" ({})\", t_err)\n-                });\n+        if !resolved_expected.references_error() {\n+            let error_str = err.map_or(\"\".to_string(), |t_err| {\n+                format!(\" ({})\", t_err)\n+            });\n \n-                self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n-                    mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                    error_str));\n+            self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n+                mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n+                error_str));\n \n-                if let Some(err) = err {\n-                    ty::note_and_explain_type_err(self.tcx, err, sp)\n-                }\n+            if let Some(err) = err {\n+                ty::note_and_explain_type_err(self.tcx, err, sp)\n             }\n         }\n     }\n@@ -1001,7 +998,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n \n         // Don't report an error if actual type is TyError.\n-        if ty::type_is_error(actual_ty) {\n+        if actual_ty.references_error() {\n             return;\n         }\n "}, {"sha": "41a0d373fba43da8a8979a135ed658701337df10", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::{InferCtxt, fixup_err, fres, unresolved_ty, unresolved_int_ty, unresolved_float_ty};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFoldable};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -36,7 +36,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx>\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_has_ty_infer(t) {\n+        if !t.has_infer_types() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t0 = self.infcx.shallow_resolve(t);\n@@ -75,7 +75,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_needs_infer(t) {\n+        if !t.needs_infer() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);"}, {"sha": "cf70d63106c70471ab164a36cfd68a0ead538e5f", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -13,7 +13,7 @@ use metadata::csearch;\n use middle::def::DefFn;\n use middle::subst::{Subst, Substs, EnumeratedItems};\n use middle::ty::{TransmuteRestriction, ctxt, TyBareFn};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n \n use std::fmt;\n \n@@ -92,8 +92,8 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n \n         // Simple case: no type parameters involved.\n         if\n-            !ty::type_has_params(from) && !ty::type_has_self(from) &&\n-            !ty::type_has_params(to) && !ty::type_has_self(to)\n+            !from.has_param_types() && !from.has_self_ty() &&\n+            !to.has_param_types() && !to.has_self_ty()\n         {\n             let restriction = TransmuteRestriction {\n                 span: span,"}, {"sha": "56798ae6848a54152ac8bfb3580b7cce2d94a567", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -13,7 +13,7 @@\n pub use self::ParamSpace::*;\n pub use self::RegionSubsts::*;\n \n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags, RegionEscape};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n \n use std::fmt;\n@@ -100,17 +100,6 @@ impl<'tcx> Substs<'tcx> {\n         *self.types.get(ty_param_def.space, ty_param_def.index as usize)\n     }\n \n-    pub fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.types.iter().any(|&t| ty::type_escapes_depth(t, depth)) || {\n-            match self.regions {\n-                ErasedRegions =>\n-                    false,\n-                NonerasedRegions(ref regions) =>\n-                    regions.iter().any(|r| r.escapes_depth(depth)),\n-            }\n-        }\n-    }\n-\n     pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n         self.types.get_self().cloned()\n     }\n@@ -632,7 +621,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_needs_subst(t) {\n+        if !t.needs_subst() {\n             return t;\n         }\n \n@@ -729,10 +718,10 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n     /// first case we do not increase the Debruijn index and in the second case we do. The reason\n     /// is that only in the second case have we passed through a fn binder.\n     fn shift_regions_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"shift_regions(ty={:?}, region_binders_passed={:?}, type_has_escaping_regions={:?})\",\n-               ty, self.region_binders_passed, ty::type_has_escaping_regions(ty));\n+        debug!(\"shift_regions(ty={:?}, region_binders_passed={:?}, has_escaping_regions={:?})\",\n+               ty, self.region_binders_passed, ty.has_escaping_regions());\n \n-        if self.region_binders_passed == 0 || !ty::type_has_escaping_regions(ty) {\n+        if self.region_binders_passed == 0 || !ty.has_escaping_regions() {\n             return ty;\n         }\n "}, {"sha": "7b86e1b4539e6a5be83439b139995e56a35f30c4", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -25,7 +25,7 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use middle::infer::InferCtxt;\n-use middle::ty::{self, ToPredicate, ReferencesError, ToPolyTraitRef, TraitRef};\n+use middle::ty::{self, ToPredicate, HasTypeFlags, ToPolyTraitRef, TraitRef};\n use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n use std::fmt;\n@@ -245,7 +245,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n             let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n             let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n-            if !ty::type_is_error(actual_trait_ref.self_ty()) {\n+            if !actual_trait_ref.self_ty().references_error() {\n                 span_err!(infcx.tcx.sess, obligation.cause.span, E0281,\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n                         but the trait `{}` is required ({})\",\n@@ -325,8 +325,8 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let trait_ref = data.to_poly_trait_ref();\n             let self_ty = trait_ref.self_ty();\n             let all_types = &trait_ref.substs().types;\n-            if all_types.iter().any(|&t| ty::type_is_error(t)) {\n-            } else if all_types.iter().any(|&t| ty::type_needs_infer(t)) {\n+            if all_types.references_error() {\n+            } else if all_types.needs_infer() {\n                 // This is kind of a hack: it frequently happens that some earlier\n                 // error prevents types from being fully inferred, and then we get\n                 // a bunch of uninteresting errors saying something like \"<generic"}, {"sha": "a26dff4e9fdae4ae5427b502fb98e911f691671d", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::infer::InferCtxt;\n-use middle::ty::{self, RegionEscape, Ty};\n+use middle::ty::{self, RegionEscape, Ty, HasTypeFlags};\n \n use std::collections::HashSet;\n use std::fmt;"}, {"sha": "845ba62307fa57340b9ed4c995f085ced55306f1", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -17,7 +17,7 @@ pub use self::ObligationCauseCode::*;\n \n use middle::free_region::FreeRegionMap;\n use middle::subst;\n-use middle::ty::{self, HasProjectionTypes, Ty};\n+use middle::ty::{self, HasTypeFlags, Ty};\n use middle::ty_fold::TypeFoldable;\n use middle::infer::{self, fixup_err_to_string, InferCtxt};\n use std::rc::Rc;\n@@ -432,7 +432,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                   cause: ObligationCause<'tcx>,\n                                   value: &T)\n                                   -> Result<T, Vec<FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     debug!(\"normalize_param_env(value={:?})\", value);\n "}, {"sha": "0203a860beb422b1213abe642c8bf4996c6902cd", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -23,8 +23,7 @@ use super::util;\n \n use middle::infer;\n use middle::subst::Subst;\n-use middle::ty::{self, ToPredicate, ReferencesError, RegionEscape,\n-                 HasProjectionTypes, ToPolyTraitRef, Ty};\n+use middle::ty::{self, ToPredicate, RegionEscape, HasTypeFlags, ToPolyTraitRef, Ty};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use syntax::parse::token;\n use util::common::FN_OUTPUT_NAME;\n@@ -195,7 +194,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                value: &T)\n                                -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     normalize_with_depth(selcx, cause, 0, value)\n }\n@@ -206,7 +205,7 @@ pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tc\n                                           depth: usize,\n                                           value: &T)\n                                           -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n     let result = normalizer.fold(value);\n@@ -238,7 +237,7 @@ impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n         }\n     }\n \n-    fn fold<T:TypeFoldable<'tcx> + HasProjectionTypes>(&mut self, value: &T) -> T {\n+    fn fold<T:TypeFoldable<'tcx> + HasTypeFlags>(&mut self, value: &T) -> T {\n         let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n \n         if !value.has_projection_types() {\n@@ -374,7 +373,7 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n                    depth,\n                    obligations);\n \n-            if ty::type_has_projection(projected_ty) {\n+            if projected_ty.has_projection_types() {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n                 let normalized_ty = normalizer.fold(&projected_ty);\n "}, {"sha": "fcc6365dab5a738181f0b4b5e1ce846f9336d48e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -38,7 +38,7 @@ use super::util;\n \n use middle::fast_reject;\n use middle::subst::{Subst, Substs, TypeSpace};\n-use middle::ty::{self, ToPredicate, RegionEscape, ToPolyTraitRef, Ty};\n+use middle::ty::{self, ToPredicate, RegionEscape, ToPolyTraitRef, Ty, HasTypeFlags};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n@@ -675,7 +675,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               stack: &TraitObligationStack<'o, 'tcx>)\n                                               -> SelectionResult<'tcx, SelectionCandidate<'tcx>>\n     {\n-        if ty::type_is_error(stack.obligation.predicate.0.self_ty()) {\n+        if stack.obligation.predicate.0.self_ty().references_error() {\n             return Ok(Some(ErrorCandidate));\n         }\n \n@@ -886,7 +886,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match *candidate {\n             Ok(Some(_)) | Err(_) => true,\n             Ok(None) => {\n-                cache_fresh_trait_pred.0.input_types().iter().any(|&t| ty::type_has_ty_infer(t))\n+                cache_fresh_trait_pred.0.input_types().has_infer_types()\n             }\n         }\n     }\n@@ -2558,7 +2558,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     new_substs.types.get_mut_slice(TypeSpace)[i] = tcx.types.err;\n                 }\n                 for &ty in fields.init() {\n-                    if ty::type_is_error(ty.subst(tcx, &new_substs)) {\n+                    if ty.subst(tcx, &new_substs).references_error() {\n                         return Err(Unimplemented);\n                     }\n                 }"}, {"sha": "47d66db88b04add20c73d906628088b90d094e8c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 160, "deletions": 256, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -1180,64 +1180,6 @@ impl<'tcx> Borrow<TypeVariants<'tcx>> for InternedTy<'tcx> {\n     }\n }\n \n-pub fn type_has_params(ty: Ty) -> bool {\n-    ty.flags.get().intersects(TypeFlags::HAS_PARAMS)\n-}\n-pub fn type_has_self(ty: Ty) -> bool {\n-    ty.flags.get().intersects(TypeFlags::HAS_SELF)\n-}\n-pub fn type_has_ty_infer(ty: Ty) -> bool {\n-    ty.flags.get().intersects(TypeFlags::HAS_TY_INFER)\n-}\n-pub fn type_needs_infer(ty: Ty) -> bool {\n-    ty.flags.get().intersects(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n-}\n-pub fn type_is_global(ty: Ty) -> bool {\n-    !ty.flags.get().intersects(TypeFlags::HAS_LOCAL_NAMES)\n-}\n-pub fn type_has_projection(ty: Ty) -> bool {\n-    ty.flags.get().intersects(TypeFlags::HAS_PROJECTION)\n-}\n-pub fn type_has_ty_closure(ty: Ty) -> bool {\n-    ty.flags.get().intersects(TypeFlags::HAS_TY_CLOSURE)\n-}\n-\n-pub fn type_has_erasable_regions(ty: Ty) -> bool {\n-    ty.flags.get().intersects(TypeFlags::HAS_RE_EARLY_BOUND |\n-                              TypeFlags::HAS_RE_INFER |\n-                              TypeFlags::HAS_FREE_REGIONS)\n-}\n-\n-/// An \"escaping region\" is a bound region whose binder is not part of `t`.\n-///\n-/// So, for example, consider a type like the following, which has two binders:\n-///\n-///    for<'a> fn(x: for<'b> fn(&'a isize, &'b isize))\n-///    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ outer scope\n-///                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~  inner scope\n-///\n-/// This type has *bound regions* (`'a`, `'b`), but it does not have escaping regions, because the\n-/// binders of both `'a` and `'b` are part of the type itself. However, if we consider the *inner\n-/// fn type*, that type has an escaping region: `'a`.\n-///\n-/// Note that what I'm calling an \"escaping region\" is often just called a \"free region\". However,\n-/// we already use the term \"free region\". It refers to the regions that we use to represent bound\n-/// regions on a fn definition while we are typechecking its body.\n-///\n-/// To clarify, conceptually there is no particular difference between an \"escaping\" region and a\n-/// \"free\" region. However, there is a big difference in practice. Basically, when \"entering\" a\n-/// binding level, one is generally required to do some sort of processing to a bound region, such\n-/// as replacing it with a fresh/skolemized region, or making an entry in the environment to\n-/// represent the scope to which it is attached, etc. An escaping region represents a bound region\n-/// for which this processing has not yet been done.\n-pub fn type_has_escaping_regions(ty: Ty) -> bool {\n-    type_escapes_depth(ty, 0)\n-}\n-\n-pub fn type_escapes_depth(ty: Ty, depth: u32) -> bool {\n-    ty.region_depth > depth\n-}\n-\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct BareFnTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n@@ -1497,15 +1439,6 @@ pub struct UpvarBorrow {\n pub type UpvarCaptureMap = FnvHashMap<UpvarId, UpvarCapture>;\n \n impl Region {\n-    pub fn is_global(&self) -> bool {\n-        // does this represent a region that can be named in a global\n-        // way? used in fulfillment caching.\n-        match *self {\n-            ty::ReStatic | ty::ReEmpty => true,\n-            _ => false,\n-        }\n-    }\n-\n     pub fn is_bound(&self) -> bool {\n         match *self {\n             ty::ReEarlyBound(..) => true,\n@@ -2254,29 +2187,6 @@ impl<'tcx> Predicate<'tcx> {\n                 Predicate::Projection(ty::Binder(data.subst(tcx, substs))),\n         }\n     }\n-\n-    // Indicates whether this predicate references only 'global'\n-    // types/lifetimes that are the same regardless of what fn we are\n-    // in. This is used for caching. Errs on the side of returning\n-    // false.\n-    pub fn is_global(&self) -> bool {\n-        match *self {\n-            ty::Predicate::Trait(ref data) => {\n-                let substs = data.skip_binder().trait_ref.substs;\n-\n-                substs.types.iter().all(|t| ty::type_is_global(t)) && {\n-                    match substs.regions {\n-                        subst::ErasedRegions => true,\n-                        subst::NonerasedRegions(ref r) => r.iter().all(|r| r.is_global()),\n-                    }\n-                }\n-            }\n-\n-            _ => {\n-                false\n-            }\n-        }\n-    }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash)]\n@@ -3711,18 +3621,6 @@ pub fn type_is_nil(ty: Ty) -> bool {\n     }\n }\n \n-pub fn type_is_error(ty: Ty) -> bool {\n-    ty.flags.get().intersects(TypeFlags::HAS_TY_ERR)\n-}\n-\n-pub fn type_needs_subst(ty: Ty) -> bool {\n-    ty.flags.get().intersects(TypeFlags::NEEDS_SUBST)\n-}\n-\n-pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n-    tref.substs.types.any(|&ty| type_is_error(ty))\n-}\n-\n pub fn type_is_ty_var(ty: Ty) -> bool {\n     match ty.sty {\n         TyInfer(TyVar(_)) => true,\n@@ -4255,7 +4153,7 @@ pub fn type_moves_by_default<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n         return ty.flags.get().intersects(TypeFlags::MOVES_BY_DEFAULT);\n     }\n \n-    assert!(!ty::type_needs_infer(ty));\n+    assert!(!ty.needs_infer());\n \n     // Fast-path for primitive types\n     let result = match ty.sty {\n@@ -4277,7 +4175,7 @@ pub fn type_moves_by_default<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n                                           ty::BoundCopy,\n                                           span));\n \n-    if !type_has_params(ty) && !type_has_self(ty) {\n+    if !ty.has_param_types() && !ty.has_self_ty() {\n         ty.flags.set(ty.flags.get() | if result {\n             TypeFlags::MOVENESS_CACHED | TypeFlags::MOVES_BY_DEFAULT\n         } else {\n@@ -4307,7 +4205,7 @@ fn type_is_sized_uncached<'a,'tcx>(param_env: Option<&ParameterEnvironment<'a,'t\n                                    tcx: &ty::ctxt<'tcx>,\n                                    span: Span,\n                                    ty: Ty<'tcx>) -> bool {\n-    assert!(!ty::type_needs_infer(ty));\n+    assert!(!ty.needs_infer());\n \n     // Fast-path for primitive types\n     let result = match ty.sty {\n@@ -4321,7 +4219,7 @@ fn type_is_sized_uncached<'a,'tcx>(param_env: Option<&ParameterEnvironment<'a,'t\n         TyInfer(..) | TyError => None\n     }.unwrap_or_else(|| type_impls_bound(param_env, tcx, ty, ty::BoundSized, span));\n \n-    if !type_has_params(ty) && !type_has_self(ty) {\n+    if !ty.has_param_types() && !ty.has_self_ty() {\n         ty.flags.set(ty.flags.get() | if result {\n             TypeFlags::SIZEDNESS_CACHED | TypeFlags::IS_SIZED\n         } else {\n@@ -5028,7 +4926,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                 AdjustDerefRef(ref adj) => {\n                     let mut adjusted_ty = unadjusted_ty;\n \n-                    if !ty::type_is_error(adjusted_ty) {\n+                    if !adjusted_ty.references_error() {\n                         for i in 0..adj.autoderefs {\n                             let method_call = MethodCall::autoderef(expr_id, i as u32);\n                             match method_type(method_call) {\n@@ -7362,11 +7260,33 @@ pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tc\n     Ok(())\n }\n \n-// FIXME(#20298) -- all of these types basically walk various\n+// FIXME(#20298) -- all of these traits basically walk various\n // structures to test whether types/regions are reachable with various\n // properties. It should be possible to express them in terms of one\n // common \"walker\" trait or something.\n \n+/// An \"escaping region\" is a bound region whose binder is not part of `t`.\n+///\n+/// So, for example, consider a type like the following, which has two binders:\n+///\n+///    for<'a> fn(x: for<'b> fn(&'a isize, &'b isize))\n+///    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ outer scope\n+///                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~  inner scope\n+///\n+/// This type has *bound regions* (`'a`, `'b`), but it does not have escaping regions, because the\n+/// binders of both `'a` and `'b` are part of the type itself. However, if we consider the *inner\n+/// fn type*, that type has an escaping region: `'a`.\n+///\n+/// Note that what I'm calling an \"escaping region\" is often just called a \"free region\". However,\n+/// we already use the term \"free region\". It refers to the regions that we use to represent bound\n+/// regions on a fn definition while we are typechecking its body.\n+///\n+/// To clarify, conceptually there is no particular difference between an \"escaping\" region and a\n+/// \"free\" region. However, there is a big difference in practice. Basically, when \"entering\" a\n+/// binding level, one is generally required to do some sort of processing to a bound region, such\n+/// as replacing it with a fresh/skolemized region, or making an entry in the environment to\n+/// represent the scope to which it is attached, etc. An escaping region represents a bound region\n+/// for which this processing has not yet been done.\n pub trait RegionEscape {\n     fn has_escaping_regions(&self) -> bool {\n         self.has_regions_escaping_depth(0)\n@@ -7377,7 +7297,7 @@ pub trait RegionEscape {\n \n impl<'tcx> RegionEscape for Ty<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        ty::type_escapes_depth(*self, depth)\n+        self.region_depth > depth\n     }\n }\n \n@@ -7491,237 +7411,221 @@ impl<'tcx> RegionEscape for ProjectionTy<'tcx> {\n     }\n }\n \n-pub trait HasProjectionTypes {\n-    fn has_projection_types(&self) -> bool;\n-}\n-\n-impl<'tcx,T:HasProjectionTypes> HasProjectionTypes for Vec<T> {\n+pub trait HasTypeFlags {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool;\n     fn has_projection_types(&self) -> bool {\n-        self.iter().any(|p| p.has_projection_types())\n+        self.has_type_flags(TypeFlags::HAS_PROJECTION)\n     }\n-}\n-\n-impl<'tcx,T:HasProjectionTypes> HasProjectionTypes for VecPerParamSpace<T> {\n-    fn has_projection_types(&self) -> bool {\n-        self.iter().any(|p| p.has_projection_types())\n+    fn references_error(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_ERR)\n     }\n-}\n-\n-impl<'tcx> HasProjectionTypes for ClosureTy<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.sig.has_projection_types()\n+    fn has_param_types(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_PARAMS)\n     }\n-}\n-\n-impl<'tcx> HasProjectionTypes for ClosureUpvar<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.ty.has_projection_types()\n+    fn has_self_ty(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_SELF)\n     }\n-}\n-\n-impl<'tcx> HasProjectionTypes for ty::InstantiatedPredicates<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.predicates.has_projection_types()\n+    fn has_infer_types(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }\n-}\n-\n-impl<'tcx> HasProjectionTypes for Predicate<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        match *self {\n-            Predicate::Trait(ref data) => data.has_projection_types(),\n-            Predicate::Equate(ref data) => data.has_projection_types(),\n-            Predicate::RegionOutlives(ref data) => data.has_projection_types(),\n-            Predicate::TypeOutlives(ref data) => data.has_projection_types(),\n-            Predicate::Projection(ref data) => data.has_projection_types(),\n-        }\n+    fn needs_infer(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n     }\n-}\n-\n-impl<'tcx> HasProjectionTypes for TraitPredicate<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.trait_ref.has_projection_types()\n+    fn needs_subst(&self) -> bool {\n+        self.has_type_flags(TypeFlags::NEEDS_SUBST)\n     }\n-}\n-\n-impl<'tcx> HasProjectionTypes for EquatePredicate<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.0.has_projection_types() || self.1.has_projection_types()\n+    fn has_closure_types(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_CLOSURE)\n     }\n-}\n-\n-impl HasProjectionTypes for Region {\n-    fn has_projection_types(&self) -> bool {\n-        false\n+    fn has_erasable_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_RE_EARLY_BOUND |\n+                            TypeFlags::HAS_RE_INFER |\n+                            TypeFlags::HAS_FREE_REGIONS)\n     }\n-}\n-\n-impl<T:HasProjectionTypes,U:HasProjectionTypes> HasProjectionTypes for OutlivesPredicate<T,U> {\n-    fn has_projection_types(&self) -> bool {\n-        self.0.has_projection_types() || self.1.has_projection_types()\n+    /// Indicates whether this value references only 'global'\n+    /// types/lifetimes that are the same regardless of what fn we are\n+    /// in. This is used for caching. Errs on the side of returning\n+    /// false.\n+    fn is_global(&self) -> bool {\n+        !self.has_type_flags(TypeFlags::HAS_LOCAL_NAMES)\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for ProjectionPredicate<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.projection_ty.has_projection_types() || self.ty.has_projection_types()\n+impl<'tcx,T:HasTypeFlags> HasTypeFlags for Vec<T> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self[..].has_type_flags(flags)\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for ProjectionTy<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.trait_ref.has_projection_types()\n+impl<'tcx,T:HasTypeFlags> HasTypeFlags for [T] {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.iter().any(|p| p.has_type_flags(flags))\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for Ty<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        ty::type_has_projection(*self)\n+impl<'tcx,T:HasTypeFlags> HasTypeFlags for VecPerParamSpace<T> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.iter().any(|p| p.has_type_flags(flags))\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for TraitRef<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.substs.has_projection_types()\n+impl<'tcx> HasTypeFlags for ClosureTy<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.sig.has_type_flags(flags)\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for subst::Substs<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.types.iter().any(|t| t.has_projection_types())\n+impl<'tcx> HasTypeFlags for ClosureUpvar<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.ty.has_type_flags(flags)\n     }\n }\n \n-impl<'tcx,T> HasProjectionTypes for Option<T>\n-    where T : HasProjectionTypes\n-{\n-    fn has_projection_types(&self) -> bool {\n-        self.iter().any(|t| t.has_projection_types())\n+impl<'tcx> HasTypeFlags for ty::InstantiatedPredicates<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.predicates.has_type_flags(flags)\n     }\n }\n \n-impl<'tcx,T> HasProjectionTypes for Rc<T>\n-    where T : HasProjectionTypes\n-{\n-    fn has_projection_types(&self) -> bool {\n-        (**self).has_projection_types()\n+impl<'tcx> HasTypeFlags for Predicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        match *self {\n+            Predicate::Trait(ref data) => data.has_type_flags(flags),\n+            Predicate::Equate(ref data) => data.has_type_flags(flags),\n+            Predicate::RegionOutlives(ref data) => data.has_type_flags(flags),\n+            Predicate::TypeOutlives(ref data) => data.has_type_flags(flags),\n+            Predicate::Projection(ref data) => data.has_type_flags(flags),\n+        }\n     }\n }\n \n-impl<'tcx,T> HasProjectionTypes for Box<T>\n-    where T : HasProjectionTypes\n-{\n-    fn has_projection_types(&self) -> bool {\n-        (**self).has_projection_types()\n+impl<'tcx> HasTypeFlags for TraitPredicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.trait_ref.has_type_flags(flags)\n     }\n }\n \n-impl<T> HasProjectionTypes for Binder<T>\n-    where T : HasProjectionTypes\n-{\n-    fn has_projection_types(&self) -> bool {\n-        self.0.has_projection_types()\n+impl<'tcx> HasTypeFlags for EquatePredicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.0.has_type_flags(flags) || self.1.has_type_flags(flags)\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for FnOutput<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        match *self {\n-            FnConverging(t) => t.has_projection_types(),\n-            FnDiverging => false,\n+impl HasTypeFlags for Region {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        if flags.intersects(TypeFlags::HAS_LOCAL_NAMES) {\n+            // does this represent a region that cannot be named in a global\n+            // way? used in fulfillment caching.\n+            match *self {\n+                ty::ReStatic | ty::ReEmpty => {}\n+                _ => return true\n+            }\n         }\n+        if flags.intersects(TypeFlags::HAS_RE_INFER) {\n+            if let ty::ReInfer(_) = *self {\n+                return true;\n+            }\n+        }\n+        false\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for FnSig<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.inputs.iter().any(|t| t.has_projection_types()) ||\n-            self.output.has_projection_types()\n+impl<T:HasTypeFlags,U:HasTypeFlags> HasTypeFlags for OutlivesPredicate<T,U> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.0.has_type_flags(flags) || self.1.has_type_flags(flags)\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for field<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.mt.ty.has_projection_types()\n+impl<'tcx> HasTypeFlags for ProjectionPredicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.projection_ty.has_type_flags(flags) || self.ty.has_type_flags(flags)\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for BareFnTy<'tcx> {\n-    fn has_projection_types(&self) -> bool {\n-        self.sig.has_projection_types()\n+impl<'tcx> HasTypeFlags for ProjectionTy<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.trait_ref.has_type_flags(flags)\n     }\n }\n \n-pub trait ReferencesError {\n-    fn references_error(&self) -> bool;\n+impl<'tcx> HasTypeFlags for Ty<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.flags.get().intersects(flags)\n+    }\n }\n \n-impl<T:ReferencesError> ReferencesError for Binder<T> {\n-    fn references_error(&self) -> bool {\n-        self.0.references_error()\n+impl<'tcx> HasTypeFlags for TraitRef<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.substs.has_type_flags(flags)\n     }\n }\n \n-impl<T:ReferencesError> ReferencesError for Rc<T> {\n-    fn references_error(&self) -> bool {\n-        (&**self).references_error()\n+impl<'tcx> HasTypeFlags for subst::Substs<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.types.has_type_flags(flags) || match self.regions {\n+            subst::ErasedRegions => false,\n+            subst::NonerasedRegions(ref r) => r.has_type_flags(flags)\n+        }\n     }\n }\n \n-impl<'tcx> ReferencesError for TraitPredicate<'tcx> {\n-    fn references_error(&self) -> bool {\n-        self.trait_ref.references_error()\n+impl<'tcx,T> HasTypeFlags for Option<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.iter().any(|t| t.has_type_flags(flags))\n     }\n }\n \n-impl<'tcx> ReferencesError for ProjectionPredicate<'tcx> {\n-    fn references_error(&self) -> bool {\n-        self.projection_ty.trait_ref.references_error() || self.ty.references_error()\n+impl<'tcx,T> HasTypeFlags for Rc<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        (**self).has_type_flags(flags)\n     }\n }\n \n-impl<'tcx> ReferencesError for TraitRef<'tcx> {\n-    fn references_error(&self) -> bool {\n-        self.input_types().iter().any(|t| t.references_error())\n+impl<'tcx,T> HasTypeFlags for Box<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        (**self).has_type_flags(flags)\n     }\n }\n \n-impl<'tcx> ReferencesError for Ty<'tcx> {\n-    fn references_error(&self) -> bool {\n-        type_is_error(*self)\n+impl<T> HasTypeFlags for Binder<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.0.has_type_flags(flags)\n     }\n }\n \n-impl<'tcx> ReferencesError for Predicate<'tcx> {\n-    fn references_error(&self) -> bool {\n+impl<'tcx> HasTypeFlags for FnOutput<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n         match *self {\n-            Predicate::Trait(ref data) => data.references_error(),\n-            Predicate::Equate(ref data) => data.references_error(),\n-            Predicate::RegionOutlives(ref data) => data.references_error(),\n-            Predicate::TypeOutlives(ref data) => data.references_error(),\n-            Predicate::Projection(ref data) => data.references_error(),\n+            FnConverging(t) => t.has_type_flags(flags),\n+            FnDiverging => false,\n         }\n     }\n }\n \n-impl<A,B> ReferencesError for OutlivesPredicate<A,B>\n-    where A : ReferencesError, B : ReferencesError\n-{\n-    fn references_error(&self) -> bool {\n-        self.0.references_error() || self.1.references_error()\n+impl<'tcx> HasTypeFlags for FnSig<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.inputs.iter().any(|t| t.has_type_flags(flags)) ||\n+            self.output.has_type_flags(flags)\n     }\n }\n \n-impl<'tcx> ReferencesError for EquatePredicate<'tcx>\n-{\n-    fn references_error(&self) -> bool {\n-        self.0.references_error() || self.1.references_error()\n+impl<'tcx> HasTypeFlags for field<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.mt.ty.has_type_flags(flags)\n     }\n }\n \n-impl ReferencesError for Region\n-{\n-    fn references_error(&self) -> bool {\n-        false\n+impl<'tcx> HasTypeFlags for BareFnTy<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.sig.has_type_flags(flags)\n     }\n }\n "}, {"sha": "ea52b1da36168744c24e65d6408db3478428d246", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -36,7 +36,7 @@\n \n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags, RegionEscape};\n use middle::traits;\n \n use std::fmt;\n@@ -896,7 +896,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_escapes_depth(t, self.current_depth-1) {\n+        if !t.has_regions_escaping_depth(self.current_depth-1) {\n             return t;\n         }\n \n@@ -946,7 +946,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_has_erasable_regions(t) {\n+        if !t.has_erasable_regions() {\n             return t;\n         }\n "}, {"sha": "fcff4363fd60370a3c3372d04c4d239b0b62f532", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -14,13 +14,12 @@ use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n use middle::ty::{ReSkolemized, ReVar, BrEnv};\n-use middle::ty::{mt, Ty};\n use middle::ty::{TyBool, TyChar, TyStruct, TyEnum};\n use middle::ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyBareFn};\n use middle::ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n use middle::ty::TyClosure;\n use middle::ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n-use middle::ty;\n+use middle::ty::{self, mt, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFoldable};\n \n use std::fmt;\n@@ -155,7 +154,7 @@ fn parameterized<GG>(f: &mut fmt::Formatter,\n             ty_params.iter().zip(tps).rev().take_while(|&(def, &actual)| {\n                 match def.default {\n                     Some(default) => {\n-                        if !has_self && ty::type_has_self(default) {\n+                        if !has_self && default.has_self_ty() {\n                             // In an object type, there is no `Self`, and\n                             // thus if the default value references Self,\n                             // the user will be required to give an"}, {"sha": "9ceaf748af7b1605c7d6777c4c3b0f65a3291744", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -22,7 +22,7 @@ use rustc_typeck::middle::resolve_lifetime;\n use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;\n use rustc_typeck::middle::subst::Subst;\n-use rustc_typeck::middle::ty::{self, Ty};\n+use rustc_typeck::middle::ty::{self, Ty, RegionEscape};\n use rustc_typeck::middle::ty_relate::TypeRelation;\n use rustc_typeck::middle::infer;\n use rustc_typeck::middle::infer::lub::Lub;\n@@ -745,22 +745,22 @@ fn escaping() {\n         // Situation:\n         // Theta = [A -> &'a foo]\n \n-        assert!(!ty::type_has_escaping_regions(env.t_nil()));\n+        assert!(!env.t_nil().has_escaping_regions());\n \n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        assert!(!ty::type_has_escaping_regions(t_rptr_free1));\n+        assert!(!t_rptr_free1.has_escaping_regions());\n \n         let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));\n-        assert!(ty::type_has_escaping_regions(t_rptr_bound1));\n+        assert!(t_rptr_bound1.has_escaping_regions());\n \n         let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n-        assert!(ty::type_has_escaping_regions(t_rptr_bound2));\n+        assert!(t_rptr_bound2.has_escaping_regions());\n \n         // t_fn = fn(A)\n         let t_param = env.t_param(subst::TypeSpace, 0);\n-        assert!(!ty::type_has_escaping_regions(t_param));\n+        assert!(!t_param.has_escaping_regions());\n         let t_fn = env.t_fn(&[t_param], env.t_nil());\n-        assert!(!ty::type_has_escaping_regions(t_fn));\n+        assert!(!t_fn.has_escaping_regions());\n     })\n }\n "}, {"sha": "c7288bb1eef8037231317b5098c7c2ae7589423c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -40,7 +40,7 @@ use middle::cfg;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n use middle::subst::Substs;\n-use middle::ty::{self, Ty, ClosureTyper, type_is_simd, simd_size};\n+use middle::ty::{self, Ty, ClosureTyper, type_is_simd, simd_size, HasTypeFlags};\n use rustc::ast_map;\n use session::config::{self, NoDebugInfo};\n use session::Session;\n@@ -1007,7 +1007,7 @@ pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, name: &str) ->\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n-    assert!(!ty::type_has_params(t));\n+    assert!(!t.has_param_types());\n     let val = alloca(bcx, ty, name);\n     return val;\n }"}, {"sha": "c036078f42f55acdd9ed0344b7da31f74694c32a", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -49,7 +49,7 @@ use trans::meth;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags, RegionEscape};\n use middle::ty::MethodCall;\n use rustc::ast_map;\n \n@@ -402,8 +402,8 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n            param_substs,\n            substs);\n \n-    assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n-    assert!(substs.types.all(|t| !ty::type_has_escaping_regions(*t)));\n+    assert!(!substs.types.needs_infer());\n+    assert!(!substs.types.has_escaping_regions());\n     let substs = substs.erase_regions();\n \n     // Load the info for the appropriate trait if necessary."}, {"sha": "0127c57d9cf3412705f5a271b3b52f6b7ff27753", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -37,7 +37,7 @@ use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n use middle::traits;\n-use middle::ty::{self, HasProjectionTypes, Ty};\n+use middle::ty::{self, HasTypeFlags, Ty};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rustc::ast_map::{PathElem, PathName};\n@@ -336,7 +336,7 @@ pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n pub type ExternMap = FnvHashMap<String, ValueRef>;\n \n pub fn validate_substs(substs: &Substs) {\n-    assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n+    assert!(!substs.types.needs_infer());\n }\n \n // work around bizarre resolve errors\n@@ -512,7 +512,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n         monomorphize::apply_param_substs(self.ccx.tcx(),\n                                          self.param_substs,\n@@ -610,7 +610,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n         monomorphize::apply_param_substs(self.tcx(),\n                                          self.fcx.param_substs,\n@@ -1194,7 +1194,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    if substs.types.any(|t| ty::type_needs_infer(*t)) {\n+    if substs.types.needs_infer() {\n             tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n                                  node, substs));\n         }"}, {"sha": "a90b462b9857237e8fe11c22569a7f2d7898d33a", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -30,7 +30,7 @@ use trans::type_of;\n use trans::machine;\n use trans::machine::llsize_of;\n use trans::type_::Type;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use syntax::abi::RustIntrinsic;\n use syntax::ast;\n use syntax::parse::token;\n@@ -103,8 +103,8 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n \n         debug!(\"transmute_restriction: {:?}\", transmute_restriction);\n \n-        assert!(!ty::type_has_params(transmute_restriction.substituted_from));\n-        assert!(!ty::type_has_params(transmute_restriction.substituted_to));\n+        assert!(!transmute_restriction.substituted_from.has_param_types());\n+        assert!(!transmute_restriction.substituted_to.has_param_types());\n \n         let llfromtype = type_of::sizing_type_of(ccx,\n                                                  transmute_restriction.substituted_from);"}, {"sha": "f78d1c44f5f425ec7ffb9cc1ed581d1efb5635c8", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -37,7 +37,7 @@ use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::MethodCall;\n \n use syntax::abi::{Rust, RustCall};\n@@ -248,7 +248,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             substs: impl_substs,\n             nested: _ }) =>\n         {\n-            assert!(impl_substs.types.all(|t| !ty::type_needs_infer(*t)));\n+            assert!(!impl_substs.types.needs_infer());\n \n             // Create the substitutions that are in scope. This combines\n             // the type parameters from the impl with those declared earlier."}, {"sha": "4d64b1c03b80086c6677e81903ee4c35d37eb307", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -25,7 +25,7 @@ use trans::base;\n use trans::common::*;\n use trans::declare;\n use trans::foreign;\n-use middle::ty::{self, HasProjectionTypes, Ty};\n+use middle::ty::{self, HasTypeFlags, Ty};\n \n use syntax::abi;\n use syntax::ast;\n@@ -47,9 +47,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            psubsts,\n            ref_id);\n \n-    assert!(psubsts.types.all(|t| {\n-        !ty::type_needs_infer(*t) && !ty::type_has_params(*t)\n-    }));\n+    assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n \n     let _icx = push_ctxt(\"monomorphic_fn\");\n \n@@ -302,7 +300,7 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n                                   param_substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     let substituted = value.subst(tcx, param_substs);\n     normalize_associated_type(tcx, &substituted)\n@@ -313,7 +311,7 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n /// and hence we can be sure that all associated types will be\n /// completely normalized away.\n pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     debug!(\"normalize_associated_type(t={:?})\", value);\n "}, {"sha": "ec5b543cfcd18c0ab4368b53ebfb2c5dea85fe64", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -56,7 +56,7 @@ use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::traits;\n-use middle::ty::{self, RegionEscape, Ty, ToPredicate};\n+use middle::ty::{self, RegionEscape, Ty, ToPredicate, HasTypeFlags};\n use middle::ty_fold;\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope, ExplicitRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n@@ -439,7 +439,7 @@ fn create_substs_for_ast_path<'tcx>(\n             // other type parameters may reference `Self` in their\n             // defaults. This will lead to an ICE if we are not\n             // careful!\n-            if self_ty.is_none() && ty::type_has_self(default) {\n+            if self_ty.is_none() && default.has_self_ty() {\n                 span_err!(tcx.sess, span, E0393,\n                           \"the type parameter `{}` must be explicitly specified \\\n                            in an object type because its default value `{}` references \\"}, {"sha": "95814370900c46b5b9b9f37cb474273e9a004900", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -15,7 +15,7 @@ use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::Substs;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n use check::{check_expr_with_lvalue_pref, LvaluePreference};\n@@ -499,7 +499,7 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             check_expr_has_type(fcx, &**e, tcx.types.bool);\n         }\n \n-        if ty::type_is_error(result_ty) || ty::type_is_error(bty) {\n+        if result_ty.references_error() || bty.references_error() {\n             tcx.types.err\n         } else {\n             let (origin, expected, found) = match match_src {"}, {"sha": "4eafbaaf794d21914b5aef521b1f9eb121d79d4d", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -11,7 +11,7 @@\n use middle::infer::InferCtxt;\n use middle::traits::{self, FulfillmentContext, Normalized, MiscObligation,\n                      SelectionContext, ObligationCause};\n-use middle::ty::{self, HasProjectionTypes};\n+use middle::ty::{self, HasTypeFlags};\n use middle::ty_fold::TypeFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -23,7 +23,7 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 body_id: ast::NodeId,\n                                                 value: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     debug!(\"normalize_associated_types_in(value={:?})\", value);\n     let mut selcx = SelectionContext::new(infcx, typer);"}, {"sha": "5bf1ef346113cb670b207a32d3d99767bc20d534", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -45,8 +45,7 @@ use super::structurally_resolved_type;\n \n use lint;\n use middle::cast::{CastKind, CastTy};\n-use middle::ty;\n-use middle::ty::Ty;\n+use middle::ty::{self, Ty, HasTypeFlags};\n use syntax::ast;\n use syntax::ast::UintTy::{TyU8};\n use syntax::codemap::Span;\n@@ -199,7 +198,7 @@ impl<'tcx> CastCheck<'tcx> {\n         debug!(\"check_cast({}, {:?} as {:?})\", self.expr.id, self.expr_ty,\n                self.cast_ty);\n \n-        if ty::type_is_error(self.expr_ty) || ty::type_is_error(self.cast_ty) {\n+        if self.expr_ty.references_error() || self.cast_ty.references_error() {\n             // No sense in giving duplicate error messages\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);"}, {"sha": "f8ce3879694586f5109c8aa7e081754d0b95146a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -21,6 +21,7 @@ use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n use middle::ty::{self, RegionEscape, Ty, ToPolyTraitRef, TraitRef};\n+use middle::ty::HasTypeFlags;\n use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n@@ -528,7 +529,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             // artifacts. This means it is safe to put into the\n             // `WhereClauseCandidate` and (eventually) into the\n             // `WhereClausePick`.\n-            assert!(trait_ref.substs.types.iter().all(|&t| !ty::type_needs_infer(t)));\n+            assert!(!trait_ref.substs.types.needs_infer());\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -928,7 +929,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n         debug!(\"pick_step: step={:?}\", step);\n \n-        if ty::type_is_error(step.self_ty) {\n+        if step.self_ty.references_error() {\n             return None;\n         }\n \n@@ -1357,7 +1358,7 @@ impl<'tcx> Candidate<'tcx> {\n                     // inference variables or other artifacts. This\n                     // means they are safe to put into the\n                     // `WhereClausePick`.\n-                    assert!(trait_ref.substs().types.iter().all(|&t| !ty::type_needs_infer(t)));\n+                    assert!(!trait_ref.substs().types.needs_infer());\n \n                     WhereClausePick((*trait_ref).clone(), index)\n                 }"}, {"sha": "de8629da3cade268cc72aa7899b49b3bacbbf2a2", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -15,7 +15,7 @@ use CrateCtxt;\n \n use astconv::AstConv;\n use check::{self, FnCtxt};\n-use middle::ty::{self, Ty, ToPolyTraitRef, ToPredicate};\n+use middle::ty::{self, Ty, ToPolyTraitRef, ToPredicate, HasTypeFlags};\n use middle::def;\n use middle::lang_items::FnOnceTraitLangItem;\n use middle::subst::Substs;\n@@ -40,7 +40,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               error: MethodError<'tcx>)\n {\n     // avoid suggestions when we don't know what's going on.\n-    if ty::type_is_error(rcvr_ty) {\n+    if rcvr_ty.references_error() {\n         return\n     }\n "}, {"sha": "fa768cb9adbb88c61b634ee668d58467b8977686", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -96,7 +96,7 @@ use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace\n use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n-use middle::ty::{self, HasProjectionTypes, RegionEscape, ToPolyTraitRef, Ty};\n+use middle::ty::{self, HasTypeFlags, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty::{MethodCall, MethodCallee, MethodMap};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n@@ -397,7 +397,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n                                         body_id: ast::NodeId,\n                                         value: &T)\n                                         -> T\n-        where T : TypeFoldable<'tcx> + HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n         assoc::normalize_associated_types_in(&self.infcx,\n@@ -1296,23 +1296,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn resolve_type_vars_if_possible(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"resolve_type_vars_if_possible(ty={:?})\", ty);\n \n-        // No ty::infer()? Nothing needs doing.\n-        if !ty::type_has_ty_infer(ty) {\n+        // No TyInfer()? Nothing needs doing.\n+        if !ty.has_infer_types() {\n             debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n-        if !ty::type_has_ty_infer(ty) {\n+        if !ty.has_infer_types() {\n             debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If not, try resolving any new fcx obligations that have cropped up.\n         self.select_new_obligations();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n-        if !ty::type_has_ty_infer(ty) {\n+        if !ty.has_infer_types() {\n             debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n@@ -1333,9 +1333,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// main checking when doing a second pass before writeback. The\n     /// justification is that writeback will produce an error for\n     /// these unconstrained type variables.\n-    fn resolve_type_vars_or_error(&self, t: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n-        let t = self.infcx().resolve_type_vars_if_possible(t);\n-        if ty::type_has_ty_infer(t) || ty::type_is_error(t) { Err(()) } else { Ok(t) }\n+    fn resolve_type_vars_or_error(&self, ty: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n+        let ty = self.infcx().resolve_type_vars_if_possible(ty);\n+        if ty.has_infer_types() || ty.references_error() { Err(()) } else { Ok(ty) }\n     }\n \n     fn record_deferred_call_resolution(&self,\n@@ -1443,7 +1443,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                   substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-        where T : TypeFoldable<'tcx> + HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n         let value = value.subst(self.tcx(), substs);\n         let result = self.normalize_associated_types_in(span, &value);\n@@ -1469,7 +1469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n \n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n         self.inh.normalize_associated_types_in(self, span, self.body_id, value)\n     }\n@@ -1954,7 +1954,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 fcx.resolve_type_vars_if_possible(t)\n             }\n         };\n-        if ty::type_is_error(resolved_t) {\n+        if resolved_t.references_error() {\n             return (resolved_t, autoderefs, None);\n         }\n \n@@ -2186,7 +2186,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          tuple_arguments: TupleArgumentsFlag,\n                                          expected: Expectation<'tcx>)\n                                          -> ty::FnOutput<'tcx> {\n-    if ty::type_is_error(method_fn_ty) {\n+    if method_fn_ty.references_error() {\n         let err_inputs = err_args(fcx.tcx(), args_no_rcvr.len());\n \n         let err_inputs = match tuple_arguments {\n@@ -2607,7 +2607,7 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n /// Invariant:\n /// If an expression has any sub-expressions that result in a type error,\n-/// inspecting that expression's type with `ty::type_is_error` will return\n+/// inspecting that expression's type with `ty.references_error()` will return\n /// true. Likewise, if an expression is known to diverge, inspecting its\n /// type with `ty::type_is_bot` will return true (n.b.: since Rust is\n /// strict, _|_ can appear in the type of an expression that does not,\n@@ -2710,7 +2710,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         let cond_ty = fcx.expr_ty(cond_expr);\n-        let if_ty = if ty::type_is_error(cond_ty) {\n+        let if_ty = if cond_ty.references_error() {\n             fcx.tcx().types.err\n         } else {\n             branches_ty\n@@ -3022,7 +3022,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        fields,\n                                        base_expr.is_none(),\n                                        None);\n-        if ty::type_is_error(fcx.node_ty(id)) {\n+        if fcx.node_ty(id).references_error() {\n             struct_type = tcx.types.err;\n         }\n \n@@ -3153,7 +3153,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             fcx, &**oprnd, expected_inner, lvalue_pref);\n         let mut oprnd_t = fcx.expr_ty(&**oprnd);\n \n-        if !ty::type_is_error(oprnd_t) {\n+        if !oprnd_t.references_error() {\n             match unop {\n                 ast::UnUniq => {\n                     oprnd_t = ty::mk_uniq(tcx, oprnd_t);\n@@ -3232,7 +3232,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                     lvalue_pref);\n \n         let tm = ty::mt { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n-        let oprnd_t = if ty::type_is_error(tm.ty) {\n+        let oprnd_t = if tm.ty.references_error() {\n             tcx.types.err\n         } else {\n             // Note: at this point, we cannot say what the best lifetime\n@@ -3352,7 +3352,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         fcx.require_expr_have_sized_type(&**lhs, traits::AssignmentLhsSized);\n \n-        if ty::type_is_error(lhs_ty) || ty::type_is_error(rhs_ty) {\n+        if lhs_ty.references_error() || rhs_ty.references_error() {\n             fcx.write_error(id);\n         } else {\n             fcx.write_nil(id);\n@@ -3370,7 +3370,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         check_block_no_value(fcx, &**body);\n         let cond_ty = fcx.expr_ty(&**cond);\n         let body_ty = fcx.node_ty(body.id);\n-        if ty::type_is_error(cond_ty) || ty::type_is_error(body_ty) {\n+        if cond_ty.references_error() || body_ty.references_error() {\n             fcx.write_error(id);\n         }\n         else {\n@@ -3409,7 +3409,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let  args_err = arg_tys.fold(false,\n              |rest_err, a| {\n-              rest_err || ty::type_is_error(a)});\n+              rest_err || a.references_error()});\n         if args_err {\n             fcx.write_error(id);\n         }\n@@ -3427,7 +3427,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let t_expr = fcx.expr_ty(e);\n \n         // Eagerly check for some obvious errors.\n-        if ty::type_is_error(t_expr) {\n+        if t_expr.references_error() {\n             fcx.write_error(id);\n         } else if !fcx.type_is_known_to_be_sized(t_cast, expr.span) {\n             report_cast_to_unsized_type(fcx, expr.span, t.span, e.span, t_cast, t_expr, id);\n@@ -3504,7 +3504,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 ty::BoundCopy);\n         }\n \n-        if ty::type_is_error(element_ty) {\n+        if element_ty.references_error() {\n             fcx.write_error(id);\n         } else {\n             let t = ty::mk_vec(tcx, t, Some(count));\n@@ -3532,7 +3532,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     fcx.expr_ty(&**e)\n                 }\n             };\n-            err_field = err_field || ty::type_is_error(t);\n+            err_field = err_field || t.references_error();\n             t\n         }).collect();\n         if err_field {\n@@ -3592,7 +3592,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // the resulting structure type. This is needed to handle type\n         // parameters correctly.\n         let actual_structure_type = fcx.expr_ty(&*expr);\n-        if !ty::type_is_error(actual_structure_type) {\n+        if !actual_structure_type.references_error() {\n             let type_and_substs = fcx.instantiate_struct_literal_ty(struct_id, path);\n             match fcx.mk_subty(false,\n                                infer::Misc(path.span),\n@@ -3630,9 +3630,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           let base_t = fcx.expr_ty(&**base);\n           let idx_t = fcx.expr_ty(&**idx);\n \n-          if ty::type_is_error(base_t) {\n+          if base_t.references_error() {\n               fcx.write_ty(id, base_t);\n-          } else if ty::type_is_error(idx_t) {\n+          } else if idx_t.references_error() {\n               fcx.write_ty(id, idx_t);\n           } else {\n               let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n@@ -3671,8 +3671,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n               (Some(ty), None) | (None, Some(ty)) => {\n                   Some(ty)\n               }\n-              (Some(t_start), Some(t_end)) if (ty::type_is_error(t_start) ||\n-                                               ty::type_is_error(t_end)) => {\n+              (Some(t_start), Some(t_end)) if (t_start.references_error() ||\n+                                               t_end.references_error()) => {\n                   Some(fcx.tcx().types.err)\n               }\n               (Some(t_start), Some(t_end)) => {\n@@ -3690,7 +3690,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           // some bounds, then we'll need to check `t_start` against them here.\n \n           let range_type = match idx_type {\n-            Some(idx_type) if ty::type_is_error(idx_type) => {\n+            Some(idx_type) if idx_type.references_error() => {\n                 fcx.tcx().types.err\n             }\n             Some(idx_type) => {\n@@ -3765,7 +3765,7 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n                                                 node_id: ast::NodeId) -> bool {\n         match def {\n             def::DefAssociatedConst(..) => {\n-                if ty::type_has_params(ty) || ty::type_has_self(ty) {\n+                if ty.has_param_types() || ty.has_self_ty() {\n                     span_err!(fcx.sess(), span, E0329,\n                               \"Associated consts cannot depend \\\n                                on type parameters or Self.\");\n@@ -3933,7 +3933,7 @@ pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx ast::Local)\n     if let Some(ref init) = local.init {\n         check_decl_initializer(fcx, local, &**init);\n         let init_ty = fcx.expr_ty(&**init);\n-        if ty::type_is_error(init_ty) {\n+        if init_ty.references_error() {\n             fcx.write_ty(local.id, init_ty);\n         }\n     }\n@@ -3944,7 +3944,7 @@ pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx ast::Local)\n     };\n     _match::check_pat(&pcx, &*local.pat, t);\n     let pat_ty = fcx.node_ty(local.pat.id);\n-    if ty::type_is_error(pat_ty) {\n+    if pat_ty.references_error() {\n         fcx.write_ty(local.id, pat_ty);\n     }\n }\n@@ -3961,7 +3961,7 @@ pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx ast::Stmt)  {\n               check_decl_local(fcx, &**l);\n               let l_t = fcx.node_ty(l.id);\n               saw_bot = saw_bot || fcx.infcx().type_var_diverges(l_t);\n-              saw_err = saw_err || ty::type_is_error(l_t);\n+              saw_err = saw_err || l_t.references_error();\n           }\n           ast::DeclItem(_) => {/* ignore for now */ }\n         }\n@@ -3972,14 +3972,14 @@ pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx ast::Stmt)  {\n         check_expr_has_type(fcx, &**expr, ty::mk_nil(fcx.tcx()));\n         let expr_ty = fcx.expr_ty(&**expr);\n         saw_bot = saw_bot || fcx.infcx().type_var_diverges(expr_ty);\n-        saw_err = saw_err || ty::type_is_error(expr_ty);\n+        saw_err = saw_err || expr_ty.references_error();\n       }\n       ast::StmtSemi(ref expr, id) => {\n         node_id = id;\n         check_expr(fcx, &**expr);\n         let expr_ty = fcx.expr_ty(&**expr);\n         saw_bot |= fcx.infcx().type_var_diverges(expr_ty);\n-        saw_err |= ty::type_is_error(expr_ty);\n+        saw_err |= expr_ty.references_error();\n       }\n       ast::StmtMac(..) => fcx.ccx.tcx.sess.bug(\"unexpanded macro\")\n     }\n@@ -3997,7 +3997,7 @@ pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx ast::Stmt)  {\n pub fn check_block_no_value<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, blk: &'tcx ast::Block)  {\n     check_block_with_expected(fcx, blk, ExpectHasType(ty::mk_nil(fcx.tcx())));\n     let blkty = fcx.node_ty(blk.id);\n-    if ty::type_is_error(blkty) {\n+    if blkty.references_error() {\n         fcx.write_error(blk.id);\n     } else {\n         let nilty = ty::mk_nil(fcx.tcx());\n@@ -4041,7 +4041,7 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             warned = true;\n         }\n         any_diverges = any_diverges || fcx.infcx().type_var_diverges(s_ty);\n-        any_err = any_err || ty::type_is_error(s_ty);\n+        any_err = any_err || s_ty.references_error();\n     }\n     match blk.expr {\n         None => if any_err {\n@@ -4184,7 +4184,7 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n \n pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     let t = ty::node_id_to_type(tcx, id);\n-    if ty::type_needs_subst(t) {\n+    if t.needs_subst() {\n         span_err!(tcx.sess, sp, E0074, \"SIMD vector cannot be generic\");\n         return;\n     }\n@@ -4874,7 +4874,7 @@ fn structurally_resolve_type_or_else<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let alternative = f();\n \n         // If not, error.\n-        if ty::type_is_ty_var(alternative) || ty::type_is_error(alternative) {\n+        if ty::type_is_ty_var(alternative) || alternative.references_error() {\n             fcx.type_error_message(sp, |_actual| {\n                 \"the type of this value must be known in this context\".to_string()\n             }, ty, None);"}, {"sha": "8aeef7f03b4e8cd5d25ddb6dd35abe55d9b369e1", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -21,7 +21,7 @@ use super::{\n     structurally_resolved_type,\n };\n use middle::traits;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n@@ -46,7 +46,7 @@ pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         fcx.write_nil(expr.id);\n     } else {\n         // error types are considered \"builtin\"\n-        assert!(!ty::type_is_error(lhs_ty) || !ty::type_is_error(rhs_ty));\n+        assert!(!lhs_ty.references_error() || !rhs_ty.references_error());\n         span_err!(tcx.sess, lhs_expr.span, E0368,\n                   \"binary assignment operation `{}=` cannot be applied to types `{}` and `{}`\",\n                   ast_util::binop_to_string(op.node),\n@@ -228,7 +228,7 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Ok(return_ty) => return_ty,\n         Err(()) => {\n             // error types are considered \"builtin\"\n-            if !ty::type_is_error(lhs_ty) {\n+            if !lhs_ty.references_error() {\n                 span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n                           \"binary operation `{}` cannot be applied to type `{}`\",\n                           ast_util::binop_to_string(op.node),\n@@ -428,28 +428,28 @@ fn is_builtin_binop<'tcx>(cx: &ty::ctxt<'tcx>,\n         }\n \n         BinOpCategory::Shift => {\n-            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n+            lhs.references_error() || rhs.references_error() ||\n                 ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n                 ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n         }\n \n         BinOpCategory::Math => {\n-            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n+            lhs.references_error() || rhs.references_error() ||\n                 ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n                 ty::type_is_floating_point(lhs) && ty::type_is_floating_point(rhs) ||\n                 ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n         }\n \n         BinOpCategory::Bitwise => {\n-            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n+            lhs.references_error() || rhs.references_error() ||\n                 ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n                 ty::type_is_floating_point(lhs) && ty::type_is_floating_point(rhs) ||\n                 ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs) ||\n                 ty::type_is_bool(lhs) && ty::type_is_bool(rhs)\n         }\n \n         BinOpCategory::Comparison => {\n-            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n+            lhs.references_error() || rhs.references_error() ||\n                 ty::type_is_scalar(lhs) && ty::type_is_scalar(rhs) ||\n                 ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n         }"}, {"sha": "4441afcec5f29fbd72b92cd93b5134109528a8b3", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -91,7 +91,7 @@ use middle::mem_categorization as mc;\n use middle::region::CodeExtent;\n use middle::subst::Substs;\n use middle::traits;\n-use middle::ty::{self, ClosureTyper, ReScope, Ty, MethodCall};\n+use middle::ty::{self, ClosureTyper, ReScope, Ty, MethodCall, HasTypeFlags};\n use middle::infer::{self, GenericKind};\n use middle::pat_util;\n \n@@ -262,7 +262,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// Try to resolve the type for the given node.\n     pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> Ty<'tcx> {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n-        if ty::type_is_error(ty_unadjusted) {\n+        if ty_unadjusted.references_error() {\n             ty_unadjusted\n         } else {\n             let tcx = self.fcx.tcx();\n@@ -1172,7 +1172,7 @@ fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n            id, mutbl, cmt_borrowed);\n \n     let rptr_ty = rcx.resolve_node_type(id);\n-    if !ty::type_is_error(rptr_ty) {\n+    if !rptr_ty.references_error() {\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"rptr_ty={}\",  rptr_ty);\n         let r = ty::ty_region(tcx, span, rptr_ty);"}, {"sha": "d968d854bb3655b4b12bc2a67459467ba3478d3b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa03871a6efd240c16eacf6f8e9a56d708a71b62/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=aa03871a6efd240c16eacf6f8e9a56d708a71b62", "patch": "@@ -105,7 +105,7 @@ pub use rustc::util;\n use middle::def;\n use middle::infer;\n use middle::subst;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use rustc::ast_map;\n use session::config;\n use util::common::time;\n@@ -148,7 +148,7 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n // Functions that write types into the node type table\n fn write_ty_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n     debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n-    assert!(!ty::type_needs_infer(ty));\n+    assert!(!ty.needs_infer());\n     tcx.node_type_insert(node_id, ty);\n }\n \n@@ -160,7 +160,7 @@ fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n                node_id,\n                item_substs);\n \n-        assert!(item_substs.substs.types.all(|t| !ty::type_needs_infer(*t)));\n+        assert!(!item_substs.substs.types.needs_infer());\n \n         tcx.item_substs.borrow_mut().insert(node_id, item_substs);\n     }"}]}