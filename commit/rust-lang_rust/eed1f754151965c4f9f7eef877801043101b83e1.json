{"sha": "eed1f754151965c4f9f7eef877801043101b83e1", "node_id": "C_kwDOAAsO6NoAKGVlZDFmNzU0MTUxOTY1YzRmOWY3ZWVmODc3ODAxMDQzMTAxYjgzZTE", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-03-25T14:30:12Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-03-25T14:30:12Z"}, "message": "Don't store vector types in ssa variables\n\nThey have been causing a lot of trouble. For example current MIR\nbuilding thinks that it is fine to dynamically index into them. And\nthere are different paths depending on if the repr(simd) struct uses\nfields or a single array as interior. There is also trouble with moving\nthe inner array of a repr(simd) type that is an array wrapper.\n\nIf performance becomes a concern, I will implement this in a more\nprincipled way.", "tree": {"sha": "f4e9a1ae8d091a84685d2616b28002dd88e875c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4e9a1ae8d091a84685d2616b28002dd88e875c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eed1f754151965c4f9f7eef877801043101b83e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eed1f754151965c4f9f7eef877801043101b83e1", "html_url": "https://github.com/rust-lang/rust/commit/eed1f754151965c4f9f7eef877801043101b83e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eed1f754151965c4f9f7eef877801043101b83e1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bced6e4346370c747e4669685ad824706289244", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bced6e4346370c747e4669685ad824706289244", "html_url": "https://github.com/rust-lang/rust/commit/6bced6e4346370c747e4669685ad824706289244"}], "stats": {"total": 182, "additions": 15, "deletions": 167}, "files": [{"sha": "527a505ccc4eecb7bfdf299a37df87dcac87cc14", "filename": "scripts/test_rustc_tests.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eed1f754151965c4f9f7eef877801043101b83e1/scripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/eed1f754151965c4f9f7eef877801043101b83e1/scripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftest_rustc_tests.sh?ref=eed1f754151965c4f9f7eef877801043101b83e1", "patch": "@@ -112,7 +112,6 @@ rm tests/incremental/spike-neg2.rs # same\n \n rm tests/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n \n-rm tests/ui/simd/intrinsic/generic-as.rs # crash when accessing vector type field (#1318)\n rm tests/ui/simd/simd-bitmask.rs # crash\n \n # bugs in the test suite"}, {"sha": "24923e5a4089e04cbea8830a9e24262216ed299e", "filename": "src/abi/comments.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=eed1f754151965c4f9f7eef877801043101b83e1", "patch": "@@ -100,7 +100,6 @@ pub(super) fn add_local_place_comments<'tcx>(\n             assert_eq!(local, place_local);\n             (\"ssa\", Cow::Owned(format!(\"var=({}, {})\", var1.index(), var2.index())))\n         }\n-        CPlaceInner::VarLane(_local, _var, _lane) => unreachable!(),\n         CPlaceInner::Addr(ptr, meta) => {\n             let meta = if let Some(meta) = meta {\n                 Cow::Owned(format!(\"meta={}\", meta))"}, {"sha": "d847e524f8cfa7740488cf3b847ccfadf1309da8", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=eed1f754151965c4f9f7eef877801043101b83e1", "patch": "@@ -84,7 +84,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                     attrs\n                 )],\n                 Abi::Vector { .. } => {\n-                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout);\n                     smallvec![AbiParam::new(vector_ty)]\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n@@ -135,7 +135,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                     (None, vec![AbiParam::new(scalar_to_clif_type(tcx, scalar))])\n                 }\n                 Abi::Vector { .. } => {\n-                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout);\n                     (None, vec![AbiParam::new(vector_ty)])\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),"}, {"sha": "089a5b038e393c6e93306ad635df700336048fd0", "filename": "src/common.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=eed1f754151965c4f9f7eef877801043101b83e1", "patch": "@@ -72,19 +72,6 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n                 pointer_ty(tcx)\n             }\n         }\n-        ty::Adt(adt_def, _) if adt_def.repr().simd() => {\n-            let (element, count) = match &tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().abi\n-            {\n-                Abi::Vector { element, count } => (*element, *count),\n-                _ => unreachable!(),\n-            };\n-\n-            match scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()) {\n-                // Cranelift currently only implements icmp for 128bit vectors.\n-                Some(vector_ty) if vector_ty.bits() == 128 => vector_ty,\n-                _ => return None,\n-            }\n-        }\n         ty::Param(_) => bug!(\"ty param {:?}\", ty),\n         _ => return None,\n     })\n@@ -96,12 +83,7 @@ fn clif_pair_type_from_ty<'tcx>(\n ) -> Option<(types::Type, types::Type)> {\n     Some(match ty.kind() {\n         ty::Tuple(types) if types.len() == 2 => {\n-            let a = clif_type_from_ty(tcx, types[0])?;\n-            let b = clif_type_from_ty(tcx, types[1])?;\n-            if a.is_vector() || b.is_vector() {\n-                return None;\n-            }\n-            (a, b)\n+            (clif_type_from_ty(tcx, types[0])?, clif_type_from_ty(tcx, types[1])?)\n         }\n         ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, *pointee_ty) {"}, {"sha": "4166e763012ab4b4b1e83471a9b3a714c852a91e", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=eed1f754151965c4f9f7eef877801043101b83e1", "patch": "@@ -51,17 +51,13 @@ fn report_atomic_type_validation_error<'tcx>(\n     fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n \n-pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n+pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Type {\n     let (element, count) = match layout.abi {\n         Abi::Vector { element, count } => (element, count),\n         _ => unreachable!(),\n     };\n \n-    match scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()) {\n-        // Cranelift currently only implements icmp for 128bit vectors.\n-        Some(vector_ty) if vector_ty.bits() == 128 => Some(vector_ty),\n-        _ => None,\n-    }\n+    scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()).unwrap()\n }\n \n fn simd_for_each_lane<'tcx>("}, {"sha": "264b578c168b2fb3148fd69b1cd95da59236037f", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=eed1f754151965c4f9f7eef877801043101b83e1", "patch": "@@ -253,7 +253,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             }\n \n             ret.write_cvalue(fx, base);\n-            let ret_lane = ret.place_field(fx, mir::Field::new(idx.try_into().unwrap()));\n+            let ret_lane = ret.place_lane(fx, idx.try_into().unwrap());\n             ret_lane.write_cvalue(fx, val);\n         }\n "}, {"sha": "622ad2ae78a25f9bb937b0a490b1528fde723655", "filename": "src/value_and_place.rs", "status": "modified", "additions": 9, "deletions": 137, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed1f754151965c4f9f7eef877801043101b83e1/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=eed1f754151965c4f9f7eef877801043101b83e1", "patch": "@@ -3,7 +3,6 @@\n use crate::prelude::*;\n \n use cranelift_codegen::ir::immediates::Offset32;\n-use cranelift_codegen::ir::{InstructionData, Opcode};\n \n fn codegen_field<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n@@ -166,9 +165,6 @@ impl<'tcx> CValue<'tcx> {\n             CValueInner::ByRef(ptr, None) => {\n                 let clif_ty = match layout.abi {\n                     Abi::Scalar(scalar) => scalar_to_clif_type(fx.tcx, scalar),\n-                    Abi::Vector { element, count } => scalar_to_clif_type(fx.tcx, element)\n-                        .by(u32::try_from(count).unwrap())\n-                        .unwrap(),\n                     _ => unreachable!(\"{:?}\", layout.ty),\n                 };\n                 let mut flags = MemFlags::new();\n@@ -214,17 +210,7 @@ impl<'tcx> CValue<'tcx> {\n     ) -> CValue<'tcx> {\n         let layout = self.1;\n         match self.0 {\n-            CValueInner::ByVal(val) => match layout.abi {\n-                Abi::Vector { element: _, count } => {\n-                    let count = u8::try_from(count).expect(\"SIMD type with more than 255 lanes???\");\n-                    let field = u8::try_from(field.index()).unwrap();\n-                    assert!(field < count);\n-                    let lane = fx.bcx.ins().extractlane(val, field);\n-                    let field_layout = layout.field(&*fx, usize::from(field));\n-                    CValue::by_val(lane, field_layout)\n-                }\n-                _ => unreachable!(\"value_field for ByVal with abi {:?}\", layout.abi),\n-            },\n+            CValueInner::ByVal(_) => unreachable!(),\n             CValueInner::ByValPair(val1, val2) => match layout.abi {\n                 Abi::ScalarPair(_, _) => {\n                     let val = match field.as_u32() {\n@@ -258,16 +244,7 @@ impl<'tcx> CValue<'tcx> {\n         let lane_layout = fx.layout_of(lane_ty);\n         assert!(lane_idx < lane_count);\n         match self.0 {\n-            CValueInner::ByVal(val) => match layout.abi {\n-                Abi::Vector { element: _, count: _ } => {\n-                    assert!(lane_count <= u8::MAX.into(), \"SIMD type with more than 255 lanes???\");\n-                    let lane_idx = u8::try_from(lane_idx).unwrap();\n-                    let lane = fx.bcx.ins().extractlane(val, lane_idx);\n-                    CValue::by_val(lane, lane_layout)\n-                }\n-                _ => unreachable!(\"value_lane for ByVal with abi {:?}\", layout.abi),\n-            },\n-            CValueInner::ByValPair(_, _) => unreachable!(),\n+            CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => unreachable!(),\n             CValueInner::ByRef(ptr, None) => {\n                 let field_offset = lane_layout.size * lane_idx;\n                 let field_ptr = ptr.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap());\n@@ -348,7 +325,6 @@ pub(crate) struct CPlace<'tcx> {\n pub(crate) enum CPlaceInner {\n     Var(Local, Variable),\n     VarPair(Local, Variable, Variable),\n-    VarLane(Local, Variable, u8),\n     Addr(Pointer, Option<Value>),\n }\n \n@@ -442,12 +418,6 @@ impl<'tcx> CPlace<'tcx> {\n                 //fx.bcx.set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n                 CValue::by_val_pair(val1, val2, layout)\n             }\n-            CPlaceInner::VarLane(_local, var, lane) => {\n-                let val = fx.bcx.use_var(var);\n-                //fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n-                let val = fx.bcx.ins().extractlane(val, lane);\n-                CValue::by_val(val, layout)\n-            }\n             CPlaceInner::Addr(ptr, extra) => {\n                 if let Some(extra) = extra {\n                     CValue::by_ref_unsized(ptr, extra, layout)\n@@ -470,9 +440,9 @@ impl<'tcx> CPlace<'tcx> {\n     pub(crate) fn to_ptr_maybe_unsized(self) -> (Pointer, Option<Value>) {\n         match self.inner {\n             CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n-            CPlaceInner::Var(_, _)\n-            | CPlaceInner::VarPair(_, _, _)\n-            | CPlaceInner::VarLane(_, _, _) => bug!(\"Expected CPlace::Addr, found {:?}\", self),\n+            CPlaceInner::Var(_, _) | CPlaceInner::VarPair(_, _, _) => {\n+                bug!(\"Expected CPlace::Addr, found {:?}\", self)\n+            }\n         }\n     }\n \n@@ -565,26 +535,6 @@ impl<'tcx> CPlace<'tcx> {\n         let dst_layout = self.layout();\n         let to_ptr = match self.inner {\n             CPlaceInner::Var(_local, var) => {\n-                if let ty::Array(element, len) = dst_layout.ty.kind() {\n-                    // Can only happen for vector types\n-                    let len = u32::try_from(len.eval_target_usize(fx.tcx, ParamEnv::reveal_all()))\n-                        .unwrap();\n-                    let vector_ty = fx.clif_type(*element).unwrap().by(len).unwrap();\n-\n-                    let data = match from.0 {\n-                        CValueInner::ByRef(ptr, None) => {\n-                            let mut flags = MemFlags::new();\n-                            flags.set_notrap();\n-                            ptr.load(fx, vector_ty, flags)\n-                        }\n-                        CValueInner::ByVal(_)\n-                        | CValueInner::ByValPair(_, _)\n-                        | CValueInner::ByRef(_, Some(_)) => bug!(\"array should be ByRef\"),\n-                    };\n-\n-                    fx.bcx.def_var(var, data);\n-                    return;\n-                }\n                 let data = CValue(from.0, dst_layout).load_scalar(fx);\n                 let dst_ty = fx.clif_type(self.layout().ty).unwrap();\n                 transmute_value(fx, var, data, dst_ty);\n@@ -603,22 +553,6 @@ impl<'tcx> CPlace<'tcx> {\n                 transmute_value(fx, var2, data2, dst_ty2);\n                 return;\n             }\n-            CPlaceInner::VarLane(_local, var, lane) => {\n-                let data = from.load_scalar(fx);\n-\n-                // First get the old vector\n-                let vector = fx.bcx.use_var(var);\n-                //fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n-\n-                // Next insert the written lane into the vector\n-                let vector = fx.bcx.ins().insertlane(vector, data, lane);\n-\n-                // Finally write the new vector\n-                //fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n-                fx.bcx.def_var(var, vector);\n-\n-                return;\n-            }\n             CPlaceInner::Addr(ptr, None) => {\n                 if dst_layout.size == Size::ZERO || dst_layout.abi == Abi::Uninhabited {\n                     return;\n@@ -631,7 +565,6 @@ impl<'tcx> CPlace<'tcx> {\n         let mut flags = MemFlags::new();\n         flags.set_notrap();\n         match from.layout().abi {\n-            // FIXME make Abi::Vector work too\n             Abi::Scalar(_) => {\n                 let val = from.load_scalar(fx);\n                 to_ptr.store(fx, val, flags);\n@@ -692,39 +625,6 @@ impl<'tcx> CPlace<'tcx> {\n         let layout = self.layout();\n \n         match self.inner {\n-            CPlaceInner::Var(local, var) => match layout.ty.kind() {\n-                ty::Array(_, _) => {\n-                    // Can only happen for vector types\n-                    return CPlace {\n-                        inner: CPlaceInner::VarLane(local, var, field.as_u32().try_into().unwrap()),\n-                        layout: layout.field(fx, field.as_u32().try_into().unwrap()),\n-                    };\n-                }\n-                ty::Adt(adt_def, substs) if layout.ty.is_simd() => {\n-                    let f0_ty = adt_def.non_enum_variant().fields[0].ty(fx.tcx, substs);\n-\n-                    match f0_ty.kind() {\n-                        ty::Array(_, _) => {\n-                            assert_eq!(field.as_u32(), 0);\n-                            return CPlace {\n-                                inner: CPlaceInner::Var(local, var),\n-                                layout: layout.field(fx, field.as_u32().try_into().unwrap()),\n-                            };\n-                        }\n-                        _ => {\n-                            return CPlace {\n-                                inner: CPlaceInner::VarLane(\n-                                    local,\n-                                    var,\n-                                    field.as_u32().try_into().unwrap(),\n-                                ),\n-                                layout: layout.field(fx, field.as_u32().try_into().unwrap()),\n-                            };\n-                        }\n-                    }\n-                }\n-                _ => {}\n-            },\n             CPlaceInner::VarPair(local, var1, var2) => {\n                 let layout = layout.field(&*fx, field.index());\n \n@@ -766,15 +666,8 @@ impl<'tcx> CPlace<'tcx> {\n         assert!(lane_idx < lane_count);\n \n         match self.inner {\n-            CPlaceInner::Var(local, var) => {\n-                assert!(matches!(layout.abi, Abi::Vector { .. }));\n-                CPlace {\n-                    inner: CPlaceInner::VarLane(local, var, lane_idx.try_into().unwrap()),\n-                    layout: lane_layout,\n-                }\n-            }\n+            CPlaceInner::Var(_, _) => unreachable!(),\n             CPlaceInner::VarPair(_, _, _) => unreachable!(),\n-            CPlaceInner::VarLane(_, _, _) => unreachable!(),\n             CPlaceInner::Addr(ptr, None) => {\n                 let field_offset = lane_layout.size * lane_idx;\n                 let field_ptr = ptr.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap());\n@@ -793,32 +686,11 @@ impl<'tcx> CPlace<'tcx> {\n             ty::Array(elem_ty, _) => {\n                 let elem_layout = fx.layout_of(*elem_ty);\n                 match self.inner {\n-                    CPlaceInner::Var(local, var) => {\n-                        // This is a hack to handle `vector_val.0[1]`. It doesn't allow dynamic\n-                        // indexing.\n-                        let lane_idx = match fx.bcx.func.dfg.insts\n-                            [fx.bcx.func.dfg.value_def(index).unwrap_inst()]\n-                        {\n-                            InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => imm,\n-                            _ => bug!(\n-                                \"Dynamic indexing into a vector type is not supported: {self:?}[{index}]\"\n-                            ),\n-                        };\n-                        return CPlace {\n-                            inner: CPlaceInner::VarLane(\n-                                local,\n-                                var,\n-                                lane_idx.bits().try_into().unwrap(),\n-                            ),\n-                            layout: elem_layout,\n-                        };\n-                    }\n                     CPlaceInner::Addr(addr, None) => (elem_layout, addr),\n-                    CPlaceInner::Addr(_, Some(_))\n-                    | CPlaceInner::VarPair(_, _, _)\n-                    | CPlaceInner::VarLane(_, _, _) => bug!(\"Can't index into {self:?}\"),\n+                    CPlaceInner::Var(_, _)\n+                    | CPlaceInner::Addr(_, Some(_))\n+                    | CPlaceInner::VarPair(_, _, _) => bug!(\"Can't index into {self:?}\"),\n                 }\n-                // FIXME use VarLane in case of Var with simd type\n             }\n             ty::Slice(elem_ty) => (fx.layout_of(*elem_ty), self.to_ptr_maybe_unsized().0),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),"}]}