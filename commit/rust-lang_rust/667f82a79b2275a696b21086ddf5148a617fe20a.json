{"sha": "667f82a79b2275a696b21086ddf5148a617fe20a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2N2Y4MmE3OWIyMjc1YTY5NmIyMTA4NmRkZjUxNDhhNjE3ZmUyMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-06T08:36:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-06T08:36:39Z"}, "message": "auto merge of #13268 : alexcrichton/rust/parse-closure, r=cmr\n\nIn summary these are some example transitions this change makes:\r\n\r\n    'a ||       => ||: 'a\r\n    proc:Send() => proc():Send\r\n\r\nThe intended syntax for closures is to put the lifetime bound not at the front\r\nbut rather in the list of bounds. Currently there is no official support in the\r\nAST for bounds that are not 'static, so this case is currently specially handled\r\nin the parser to desugar to what the AST is expecting. Additionally, this moves\r\nthe bounds on procedures to the correct position, which is after the argument\r\nlist.\r\n\r\nThe current grammar for closures and procedures is:\r\n\r\n    procedure := 'proc' [ '<' lifetime-list '>' ] '(' arg-list ')'\r\n                        [ ':' bound-list ] [ '->' type ]\r\n    closure := [ 'unsafe' ] ['<' lifetime-list '>' ] '|' arg-list '|'\r\n                        [ ':' bound-list ] [ '->' type ]\r\n    lifetime-list := lifetime | lifetime ',' lifetime-list\r\n    arg-list := ident ':' type | ident ':' type ',' arg-list\r\n    bound-list := bound | bound '+' bound-list\r\n    bound := path | lifetime\r\n\r\nThis does not currently handle the << ambiguity in `Option<<'a>||>`, I am\r\ndeferring that to a later patch. Additionally, this removes the support for the\r\nobsolete syntaxes of ~fn and &fn.\r\n\r\nCloses #10553\r\nCloses #10767 \r\nCloses #11209\r\nCloses #11210\r\nCloses #11211", "tree": {"sha": "563c7ec6a927ebf26af2d2154ca1311073233657", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/563c7ec6a927ebf26af2d2154ca1311073233657"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/667f82a79b2275a696b21086ddf5148a617fe20a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/667f82a79b2275a696b21086ddf5148a617fe20a", "html_url": "https://github.com/rust-lang/rust/commit/667f82a79b2275a696b21086ddf5148a617fe20a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/667f82a79b2275a696b21086ddf5148a617fe20a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e9e25907b6c63e3bde3dd122160ec07ef1ba6b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9e25907b6c63e3bde3dd122160ec07ef1ba6b9", "html_url": "https://github.com/rust-lang/rust/commit/4e9e25907b6c63e3bde3dd122160ec07ef1ba6b9"}, {"sha": "d1c584e41bc4f7c49123911dd93c2b3db38b0f8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1c584e41bc4f7c49123911dd93c2b3db38b0f8f", "html_url": "https://github.com/rust-lang/rust/commit/d1c584e41bc4f7c49123911dd93c2b3db38b0f8f"}], "stats": {"total": 462, "additions": 293, "deletions": 169}, "files": [{"sha": "1e1278f08bb9319c99810e6aa2f87c5af2c32a3a", "filename": "src/doc/rust.md", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -3420,8 +3420,21 @@ x = bo(5,7);\n \n ### Closure types\n \n-The type of a closure mapping an input of type `A` to an output of type `B` is `|A| -> B`. A closure with no arguments or return values has type `||`.\n+~~~~ {.notrust .ebnf .notation}\n+closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'\n+                [ ':' bound-list ] [ '->' type ]\n+procedure_type := 'proc' [ '<' lifetime-list '>' ] '(' arg-list ')'\n+                  [ ':' bound-list ] [ '->' type ]\n+lifetime-list := lifetime | lifetime ',' lifetime-list\n+arg-list := ident ':' type | ident ':' type ',' arg-list\n+bound-list := bound | bound '+' bound-list\n+bound := path | lifetime\n+~~~~\n \n+The type of a closure mapping an input of type `A` to an output of type `B` is\n+`|A| -> B`. A closure with no arguments or return values has type `||`.\n+Similarly, a procedure mapping `A` to `B` is `proc(A) -> B` and a no-argument\n+and no-return value closure has type `proc()`.\n \n An example of creating and calling a closure:\n \n@@ -3444,6 +3457,30 @@ call_closure(closure_no_args, closure_args);\n \n ```\n \n+Unlike closures, procedures may only be invoked once, but own their\n+environment, and are allowed to move out of their environment. Procedures are\n+allocated on the heap (unlike closures). An example of creating and calling a\n+procedure:\n+\n+```rust\n+let string = ~\"Hello\";\n+\n+// Creates a new procedure, passing it to the `spawn` function.\n+spawn(proc() {\n+  println!(\"{} world!\", string);\n+});\n+\n+// the variable `string` has been moved into the previous procedure, so it is\n+// no longer usable.\n+\n+\n+// Create an invoke a procedure. Note that the procedure is *moved* when\n+// invoked, so it cannot be invoked again.\n+let f = proc(n: int) { n + 22 };\n+println!(\"answer: {}\", f(20));\n+\n+```\n+\n ### Object types\n \n Every trait item (see [traits](#traits)) defines a type with the same name as the trait."}, {"sha": "d09a002e11765cf0b0d64857de36164b39f1044d", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -36,8 +36,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteEnumWildcard,\n     ObsoleteStructWildcard,\n     ObsoleteVecDotDotWildcard,\n-    ObsoleteBoxedClosure,\n-    ObsoleteClosureType,\n     ObsoleteMultipleImport,\n     ObsoleteManagedPattern,\n     ObsoleteManagedString,\n@@ -111,16 +109,6 @@ impl<'a> ParserObsoleteMethods for Parser<'a> {\n                 \"vec slice wildcard\",\n                 \"use `..` instead of `.._` for matching slices\"\n             ),\n-            ObsoleteBoxedClosure => (\n-                \"managed or owned closure\",\n-                \"managed closures have been removed and owned closures are \\\n-                 now written `proc()`\"\n-            ),\n-            ObsoleteClosureType => (\n-                \"closure type\",\n-                \"closures are now written `|A| -> B` rather than `&fn(A) -> \\\n-                 B`.\"\n-            ),\n             ObsoleteMultipleImport => (\n                 \"multiple imports\",\n                 \"only one import is allowed per `use` statement\""}, {"sha": "62ce0f1e113992385c79e2febd2752fde3715b5b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 112, "deletions": 111, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -29,7 +29,7 @@ use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprVstore, ExprVstoreSlice};\n use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, ExternFn, Field, FnDecl};\n-use ast::{ExprVstoreUniq, Onceness, Once, Many};\n+use ast::{ExprVstoreUniq, Once, Many};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n use ast::{Ident, ImpureFn, Inherited, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl};\n@@ -892,8 +892,44 @@ impl<'a> Parser<'a> {\n     // Parses a procedure type (`proc`). The initial `proc` keyword must\n     // already have been parsed.\n     pub fn parse_proc_type(&mut self) -> Ty_ {\n-        let bounds = self.parse_optional_ty_param_bounds();\n-        let (decl, lifetimes) = self.parse_ty_fn_decl(false);\n+        /*\n+\n+        proc <'lt> (S) [:Bounds] -> T\n+        ^~~^ ^~~~^  ^  ^~~~~~~~^    ^\n+         |     |    |      |        |\n+         |     |    |      |      Return type\n+         |     |    |    Bounds\n+         |     |  Argument types\n+         |   Lifetimes\n+        the `proc` keyword\n+\n+        */\n+\n+        // NOTE: remove after the next stage0 snap\n+        let (decl, lifetimes, bounds) = if self.token == token::COLON {\n+            let (_, bounds) = self.parse_optional_ty_param_bounds(false);\n+            let (decl, lifetimes) = self.parse_ty_fn_decl(false);\n+            (decl, lifetimes, bounds)\n+        } else {\n+            let lifetimes = if self.eat(&token::LT) {\n+                let lifetimes = self.parse_lifetimes();\n+                self.expect_gt();\n+                lifetimes\n+            } else {\n+                Vec::new()\n+            };\n+\n+            let (inputs, variadic) = self.parse_fn_args(false, false);\n+            let (_, bounds) = self.parse_optional_ty_param_bounds(false);\n+            let (ret_style, ret_ty) = self.parse_ret_ty();\n+            let decl = P(FnDecl {\n+                inputs: inputs,\n+                output: ret_ty,\n+                cf: ret_style,\n+                variadic: variadic\n+            });\n+            (decl, lifetimes, bounds)\n+        };\n         TyClosure(@ClosureTy {\n             sigil: OwnedSigil,\n             region: None,\n@@ -906,102 +942,68 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a TyClosure type\n-    pub fn parse_ty_closure(&mut self,\n-                            opt_sigil: Option<ast::Sigil>,\n-                            mut region: Option<ast::Lifetime>)\n-                            -> Ty_ {\n+    pub fn parse_ty_closure(&mut self) -> Ty_ {\n         /*\n \n-        (&|~|@) ['r] [unsafe] [once] fn [:Bounds] <'lt> (S) -> T\n-        ^~~~~~^ ^~~^ ^~~~~~~^ ^~~~~^    ^~~~~~~~^ ^~~~^ ^~^    ^\n-           |     |     |        |           |       |    |     |\n-           |     |     |        |           |       |    |   Return type\n-           |     |     |        |           |       |  Argument types\n-           |     |     |        |           |   Lifetimes\n-           |     |     |        |       Closure bounds\n-           |     |     |     Once-ness (a.k.a., affine)\n-           |     |   Purity\n-           | Lifetime bound\n-        Allocation type\n+        [unsafe] [once] <'lt> |S| [:Bounds] -> T\n+        ^~~~~~~^ ^~~~~^ ^~~~^  ^  ^~~~~~~~^    ^\n+          |        |      |    |      |        |\n+          |        |      |    |      |      Return type\n+          |        |      |    |  Closure bounds\n+          |        |      |  Argument types\n+          |        |    Lifetimes\n+          |     Once-ness (a.k.a., affine)\n+        Purity\n \n         */\n \n-        // At this point, the allocation type and lifetime bound have been\n-        // parsed.\n-\n+        // NOTE: remove 'let region' after a stage0 snap\n+        let region = self.parse_opt_lifetime();\n         let purity = self.parse_unsafety();\n-        let onceness = parse_onceness(self);\n-\n-        let (sigil, decl, lifetimes, bounds) = match opt_sigil {\n-            Some(sigil) => {\n-                // Old-style closure syntax (`fn(A)->B`).\n-                self.expect_keyword(keywords::Fn);\n-                let bounds = self.parse_optional_ty_param_bounds();\n-                let (decl, lifetimes) = self.parse_ty_fn_decl(false);\n-                (sigil, decl, lifetimes, bounds)\n-            }\n-            None => {\n-                // New-style closure syntax (`<'lt>|A|:K -> B`).\n-                let lifetimes = if self.eat(&token::LT) {\n-                    let lifetimes = self.parse_lifetimes();\n-                    self.expect_gt();\n-\n-                    // Re-parse the region here. What a hack.\n-                    if region.is_some() {\n-                        self.span_err(self.last_span,\n-                                      \"lifetime declarations must precede \\\n-                                       the lifetime associated with a \\\n-                                       closure\");\n-                    }\n-                    region = self.parse_opt_lifetime();\n+        let onceness = if self.eat_keyword(keywords::Once) {Once} else {Many};\n \n-                    lifetimes\n-                } else {\n-                    Vec::new()\n-                };\n+        let lifetimes = if self.eat(&token::LT) {\n+            let lifetimes = self.parse_lifetimes();\n+            self.expect_gt();\n \n-                let inputs = if self.eat(&token::OROR) {\n-                    Vec::new()\n-                } else {\n-                    self.expect_or();\n-                    let inputs = self.parse_seq_to_before_or(\n-                        &token::COMMA,\n-                        |p| p.parse_arg_general(false));\n-                    self.expect_or();\n-                    inputs\n-                };\n+            lifetimes\n+        } else {\n+            Vec::new()\n+        };\n \n-                let bounds = self.parse_optional_ty_param_bounds();\n+        let inputs = if self.eat(&token::OROR) {\n+            Vec::new()\n+        } else {\n+            self.expect_or();\n+            let inputs = self.parse_seq_to_before_or(\n+                &token::COMMA,\n+                |p| p.parse_arg_general(false));\n+            self.expect_or();\n+            inputs\n+        };\n \n-                let (return_style, output) = self.parse_ret_ty();\n-                let decl = P(FnDecl {\n-                    inputs: inputs,\n-                    output: output,\n-                    cf: return_style,\n-                    variadic: false\n-                });\n+        let (new_region, bounds) = self.parse_optional_ty_param_bounds(true);\n \n-                (BorrowedSigil, decl, lifetimes, bounds)\n-            }\n-        };\n+        // NOTE: this should be removed after a stage0 snap\n+        let region = new_region.or(region);\n+\n+        let (return_style, output) = self.parse_ret_ty();\n+        let decl = P(FnDecl {\n+            inputs: inputs,\n+            output: output,\n+            cf: return_style,\n+            variadic: false\n+        });\n \n-        return TyClosure(@ClosureTy {\n-            sigil: sigil,\n+        TyClosure(@ClosureTy {\n+            sigil: BorrowedSigil,\n             region: region,\n             purity: purity,\n             onceness: onceness,\n             bounds: bounds,\n             decl: decl,\n             lifetimes: lifetimes,\n-        });\n-\n-        fn parse_onceness(this: &mut Parser) -> Onceness {\n-            if this.eat_keyword(keywords::Once) {\n-                Once\n-            } else {\n-                Many\n-            }\n-        }\n+        })\n     }\n \n     pub fn parse_unsafety(&mut self) -> Purity {\n@@ -1245,16 +1247,15 @@ impl<'a> Parser<'a> {\n                 self.token == token::BINOP(token::OR) ||\n                 self.token == token::OROR ||\n                 self.token == token::LT ||\n+                // NOTE: remove this clause after a stage0 snap\n                 Parser::token_is_lifetime(&self.token) {\n             // CLOSURE\n             //\n             // FIXME(pcwalton): Eventually `token::LT` will not unambiguously\n             // introduce a closure, once procs can have lifetime bounds. We\n             // will need to refactor the grammar a little bit at that point.\n \n-            let lifetime = self.parse_opt_lifetime();\n-            let result = self.parse_ty_closure(None, lifetime);\n-            result\n+            self.parse_ty_closure()\n         } else if self.eat_keyword(keywords::Typeof) {\n             // TYPEOF\n             // In order to not be ambiguous, the type must be surrounded by parens.\n@@ -1288,23 +1289,6 @@ impl<'a> Parser<'a> {\n     pub fn parse_box_or_uniq_pointee(&mut self,\n                                      sigil: ast::Sigil)\n                                      -> Ty_ {\n-        // ~'foo fn() or ~fn() are parsed directly as obsolete fn types:\n-        match self.token {\n-            token::LIFETIME(..) => {\n-                let lifetime = self.parse_lifetime();\n-                self.obsolete(self.last_span, ObsoleteBoxedClosure);\n-                return self.parse_ty_closure(Some(sigil), Some(lifetime));\n-            }\n-\n-            token::IDENT(..) => {\n-                if self.token_is_old_style_closure_keyword() {\n-                    self.obsolete(self.last_span, ObsoleteBoxedClosure);\n-                    return self.parse_ty_closure(Some(sigil), None);\n-                }\n-            }\n-            _ => {}\n-        }\n-\n         // other things are parsed as @/~ + a type.  Note that constructs like\n         // ~[] and ~str will be resolved during typeck to slices and so forth,\n         // rather than boxed ptrs.  But the special casing of str/vec is not\n@@ -1320,11 +1304,6 @@ impl<'a> Parser<'a> {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n         let opt_lifetime = self.parse_opt_lifetime();\n \n-        if self.token_is_old_style_closure_keyword() {\n-            self.obsolete(self.last_span, ObsoleteClosureType);\n-            return self.parse_ty_closure(Some(BorrowedSigil), opt_lifetime);\n-        }\n-\n         let mt = self.parse_mt();\n         return TyRptr(opt_lifetime, mt);\n     }\n@@ -1540,7 +1519,8 @@ impl<'a> Parser<'a> {\n \n         // Next, parse a colon and bounded type parameters, if applicable.\n         let bounds = if mode == LifetimeAndTypesAndBounds {\n-            self.parse_optional_ty_param_bounds()\n+            let (_, bounds) = self.parse_optional_ty_param_bounds(false);\n+            bounds\n         } else {\n             None\n         };\n@@ -3376,18 +3356,39 @@ impl<'a> Parser<'a> {\n     // Returns \"Some(Empty)\" if there's a colon but nothing after (e.g. \"T:\")\n     // Returns \"Some(stuff)\" otherwise (e.g. \"T:stuff\").\n     // NB: The None/Some distinction is important for issue #7264.\n-    fn parse_optional_ty_param_bounds(&mut self) -> Option<OwnedSlice<TyParamBound>> {\n+    //\n+    // Note that the `allow_any_lifetime` argument is a hack for now while the\n+    // AST doesn't support arbitrary lifetimes in bounds on type parameters. In\n+    // the future, this flag should be removed, and the return value of this\n+    // function should be Option<~[TyParamBound]>\n+    fn parse_optional_ty_param_bounds(&mut self, allow_any_lifetime: bool)\n+        -> (Option<ast::Lifetime>, Option<OwnedSlice<TyParamBound>>)\n+    {\n         if !self.eat(&token::COLON) {\n-            return None;\n+            return (None, None);\n         }\n \n+        let mut ret_lifetime = None;\n         let mut result = vec!();\n         loop {\n             match self.token {\n                 token::LIFETIME(lifetime) => {\n                     let lifetime_interned_string = token::get_ident(lifetime);\n                     if lifetime_interned_string.equiv(&(\"static\")) {\n                         result.push(RegionTyParamBound);\n+                        if allow_any_lifetime && ret_lifetime.is_none() {\n+                            ret_lifetime = Some(ast::Lifetime {\n+                                id: ast::DUMMY_NODE_ID,\n+                                span: self.span,\n+                                name: lifetime.name\n+                            });\n+                        }\n+                    } else if allow_any_lifetime && ret_lifetime.is_none() {\n+                        ret_lifetime = Some(ast::Lifetime {\n+                            id: ast::DUMMY_NODE_ID,\n+                            span: self.span,\n+                            name: lifetime.name\n+                        });\n                     } else {\n                         self.span_err(self.span,\n                                       \"`'static` is the only permissible region bound here\");\n@@ -3406,13 +3407,13 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return Some(OwnedSlice::from_vec(result));\n+        return (ret_lifetime, Some(OwnedSlice::from_vec(result)));\n     }\n \n     // matches typaram = IDENT optbounds ( EQ ty )?\n     fn parse_ty_param(&mut self) -> TyParam {\n         let ident = self.parse_ident();\n-        let opt_bounds = self.parse_optional_ty_param_bounds();\n+        let (_, opt_bounds) = self.parse_optional_ty_param_bounds(false);\n         // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n         let bounds = opt_bounds.unwrap_or_default();\n "}, {"sha": "44e95aa9573c07909224bf7c91dc0f42fe837c77", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -1557,7 +1557,7 @@ impl<'a> State<'a> {\n \n         match *opt_bounds {\n             None => Ok(()),\n-            Some(ref bounds) => self.print_bounds(bounds, true),\n+            Some(ref bounds) => self.print_bounds(&None, bounds, true),\n         }\n     }\n \n@@ -1813,11 +1813,24 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(decl.output.span.lo)\n     }\n \n-    pub fn print_bounds(&mut self, bounds: &OwnedSlice<ast::TyParamBound>,\n+    pub fn print_bounds(&mut self,\n+                        region: &Option<ast::Lifetime>,\n+                        bounds: &OwnedSlice<ast::TyParamBound>,\n                         print_colon_anyway: bool) -> IoResult<()> {\n-        if !bounds.is_empty() {\n+        if !bounds.is_empty() || region.is_some() {\n             try!(word(&mut self.s, \":\"));\n             let mut first = true;\n+            match *region {\n+                Some(ref lt) => {\n+                    let token = token::get_name(lt.name);\n+                    if token.get() != \"static\" {\n+                        try!(self.nbsp());\n+                        first = false;\n+                        try!(self.print_lifetime(lt));\n+                    }\n+                }\n+                None => {}\n+            }\n             for bound in bounds.iter() {\n                 try!(self.nbsp());\n                 if first {\n@@ -1866,7 +1879,7 @@ impl<'a> State<'a> {\n                         let idx = idx - generics.lifetimes.len();\n                         let param = generics.ty_params.get(idx);\n                         try!(s.print_ident(param.ident));\n-                        try!(s.print_bounds(&param.bounds, false));\n+                        try!(s.print_bounds(&None, &param.bounds, false));\n                         match param.default {\n                             Some(default) => {\n                                 try!(space(&mut s.s));\n@@ -2027,15 +2040,11 @@ impl<'a> State<'a> {\n             try!(word(&mut self.s, \"proc\"));\n         } else if opt_sigil == Some(ast::BorrowedSigil) {\n             try!(self.print_extern_opt_abi(opt_abi));\n-            for lifetime in opt_region.iter() {\n-                try!(self.print_lifetime(lifetime));\n-            }\n             try!(self.print_purity(purity));\n             try!(self.print_onceness(onceness));\n         } else {\n             try!(self.print_opt_abi_and_extern_if_nondefault(opt_abi));\n             try!(self.print_opt_sigil(opt_sigil));\n-            try!(self.print_opt_lifetime(opt_region));\n             try!(self.print_purity(purity));\n             try!(self.print_onceness(onceness));\n             try!(word(&mut self.s, \"fn\"));\n@@ -2049,10 +2058,6 @@ impl<'a> State<'a> {\n             _ => ()\n         }\n \n-        if opt_sigil != Some(ast::BorrowedSigil) {\n-            opt_bounds.as_ref().map(|bounds| self.print_bounds(bounds, true));\n-        }\n-\n         match generics { Some(g) => try!(self.print_generics(g)), _ => () }\n         try!(zerobreak(&mut self.s));\n \n@@ -2066,15 +2071,17 @@ impl<'a> State<'a> {\n \n         if opt_sigil == Some(ast::BorrowedSigil) {\n             try!(word(&mut self.s, \"|\"));\n-\n-            opt_bounds.as_ref().map(|bounds| self.print_bounds(bounds, true));\n         } else {\n             if decl.variadic {\n                 try!(word(&mut self.s, \", ...\"));\n             }\n             try!(self.pclose());\n         }\n \n+        opt_bounds.as_ref().map(|bounds| {\n+            self.print_bounds(opt_region, bounds, true)\n+        });\n+\n         try!(self.maybe_print_comment(decl.output.span.lo));\n \n         match decl.output.node {"}, {"sha": "ee1697e52cffde7c71971bcfa90f138c5d75e343", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -15,11 +15,11 @@\n \n // returns an infinite iterator of repeated applications of f to x,\n // i.e. [x, f(x), f(f(x)), ...], as haskell iterate function.\n-fn iterate<'a, T>(x: T, f: 'a |&T| -> T) -> Iterate<'a, T> {\n+fn iterate<'a, T>(x: T, f: |&T|: 'a -> T) -> Iterate<'a, T> {\n     Iterate {f: f, next: x}\n }\n struct Iterate<'a, T> {\n-    f: 'a |&T| -> T,\n+    f: |&T|: 'a -> T,\n     next: T\n }\n impl<'a, T> Iterator<T> for Iterate<'a, T> {"}, {"sha": "9176412cd79feff56bcdca5fcbf87423310eebe6", "filename": "src/test/compile-fail/closure-bounds-static-cant-capture-borrowed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -12,8 +12,8 @@ fn bar(blk: ||:'static) {\n }\n \n fn foo(x: &()) {\n-    bar(|| {\n-        let _ = x; //~ ERROR does not fulfill `'static`\n+    bar(|| { //~ ERROR cannot infer an appropriate lifetime\n+        let _ = x;\n     })\n }\n "}, {"sha": "798808a157277013fd505ceb486fec14906ff570", "filename": "src/test/run-pass/closure-syntax.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty #13324\n+\n+#![allow(dead_code)]\n+\n+fn foo<T>() {}\n+\n+trait Bar1 {}\n+impl Bar1 for proc() {}\n+\n+trait Bar2 {}\n+impl Bar2 for proc(): Send {}\n+\n+trait Bar3 {}\n+impl<'b> Bar3 for <'a>|&'a int|: 'b + Send -> &'a int {}\n+\n+trait Bar4 {}\n+impl Bar4 for proc<'a>(&'a int) -> &'a int {}\n+\n+struct Foo<'a> {\n+    a: ||: 'a,\n+    b: ||: 'static,\n+    c: <'b>||: 'a,\n+    d: ||: 'a + Share,\n+    e: <'b>|int|: 'a + Share -> &'b f32,\n+    f: proc(),\n+    g: proc(): 'static + Share,\n+    h: proc<'b>(int): Share -> &'b f32,\n+}\n+\n+fn f<'a>(a: &'a int, f: <'b>|&'b int| -> &'b int) -> &'a int {\n+    f(a)\n+}\n+\n+fn g<'a>(a: &'a int, f: proc<'b>(&'b int) -> &'b int) -> &'a int {\n+    f(a)\n+}\n+\n+fn bar<'b>() {\n+    foo::<||>();\n+    foo::<|| -> ()>();\n+    foo::<||:>();\n+    foo::<||:'b>();\n+    foo::<||:'b + Share>();\n+    foo::<||:Share>();\n+    foo::< <'a>|int, f32, &'a int|:'b + Share -> &'a int>();\n+    foo::<proc()>();\n+    foo::<proc() -> ()>();\n+    foo::<proc():>();\n+    foo::<proc():'static>();\n+    foo::<proc():Share>();\n+    foo::<proc<'a>(int, f32, &'a int):'static + Share -> &'a int>();\n+\n+    // issue #11209\n+    let _: 'b ||; // for comparison\n+    let _: <'a> ||;\n+\n+    let _: Option<||:'b>;\n+    // let _: Option<<'a>||>;\n+    let _: Option< <'a>||>;\n+\n+    // issue #11210\n+    let _: 'static ||;\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "57e37aaf393bcea755d371a2e16a0460e7d4388c", "filename": "src/test/run-pass/const-fn-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -12,7 +12,7 @@ fn foo() -> int {\n     return 0xca7f000d;\n }\n \n-struct Bar<'a> { f: 'a || -> int }\n+struct Bar<'a> { f: ||: 'a -> int }\n \n static mut b : Bar<'static> = Bar { f: foo };\n "}, {"sha": "1f5c1a556a991090a2fb486e86d2e615839cd0cc", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -17,7 +17,7 @@\n \n fn f() { }\n static bare_fns: &'static [fn()] = &[f, f];\n-struct S<'a>('a ||);\n+struct S<'a>(||:'a);\n static mut closures: &'static [S<'static>] = &[S(f), S(f)];\n \n pub fn main() {"}, {"sha": "3a6cd61fa099234b7233933a13ba8745f7818a8c", "filename": "src/test/run-pass/expr-block-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -11,7 +11,7 @@\n \n \n fn test_fn() {\n-    type t = 'static || -> int;\n+    type t = ||: 'static -> int;\n     fn ten() -> int { return 10; }\n     let rs: t = ten;\n     assert!((rs() == 10));"}, {"sha": "513dbf2eba866b47e3af5de004cf4096270cf116", "filename": "src/test/run-pass/expr-block-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -10,7 +10,7 @@\n \n #[feature(managed_boxes)];\n \n-type compare<T> = 'static |@T, @T| -> bool;\n+type compare<T> = |@T, @T|: 'static -> bool;\n \n fn test_generic<T>(expected: @T, eq: compare<T>) {\n     let actual: @T = { expected };"}, {"sha": "5eb3f36ce1b788ed7679bf49dcfa283d9894f250", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -12,7 +12,7 @@\n \n // ignore-fast\n \n-type compare<'a, T> = 'a |T, T| -> bool;\n+type compare<'a, T> = |T, T|: 'a -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = { expected.clone() };"}, {"sha": "95f3ff62d269725c3eec4244c58bc9da0665f2d9", "filename": "src/test/run-pass/expr-block-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-type compare<'a, T> = 'a |~T, ~T| -> bool;\n+type compare<'a, T> = |~T, ~T|: 'a -> bool;\n \n fn test_generic<T:Clone>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = { expected.clone() };"}, {"sha": "85a1d137d211ba07a5055a0de7d305e8cbad3489", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-fast\n \n-type compare<'a, T> = 'a |T, T| -> bool;\n+type compare<'a, T> = |T, T|: 'a -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = { expected.clone() };"}, {"sha": "4c8a32ce3cb39293e0ed04edac8f5ef881d08784", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -12,7 +12,7 @@\n // ignore-fast\n \n // Tests for standalone blocks as expressions with dynamic type sizes\n-type compare<'a, T> = 'a |T, T| -> bool;\n+type compare<'a, T> = |T, T|: 'a -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = { expected.clone() };"}, {"sha": "78f42120ab77fdd4eed16f085672d00b92ebfc86", "filename": "src/test/run-pass/expr-if-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -10,7 +10,7 @@\n \n #[feature(managed_boxes)];\n \n-type compare<T> = 'static |@T, @T| -> bool;\n+type compare<T> = |@T, @T|: 'static -> bool;\n \n fn test_generic<T>(expected: @T, not_expected: @T, eq: compare<T>) {\n     let actual: @T = if true { expected } else { not_expected };"}, {"sha": "8b78aabd8601c268c18fae6efbcd001806196dcf", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -12,7 +12,7 @@\n \n // ignore-fast\n \n-type compare<T> = 'static |T, T| -> bool;\n+type compare<T> = |T, T|: 'static -> bool;\n \n fn test_generic<T:Clone>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected.clone() } else { not_expected };"}, {"sha": "f250db1f692c3fd021bd8e59f56ae9c0db9085cb", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -11,7 +11,7 @@\n // ignore-fast\n \n // Tests for if as expressions with dynamic type sizes\n-type compare<T> = 'static |T, T| -> bool;\n+type compare<T> = |T, T|: 'static -> bool;\n \n fn test_generic<T:Clone>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected.clone() } else { not_expected };"}, {"sha": "287e0ea349de65db4ee8b45ac1b23bd2084dad89", "filename": "src/test/run-pass/expr-match-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box1.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -10,7 +10,7 @@\n \n #[feature(managed_boxes)];\n \n-type compare<T> = 'static |@T, @T| -> bool;\n+type compare<T> = |@T, @T|: 'static -> bool;\n \n fn test_generic<T>(expected: @T, eq: compare<T>) {\n     let actual: @T = match true { true => { expected }, _ => fail!() };"}, {"sha": "01b46528c7b453e01101add86de7101d66fbab4a", "filename": "src/test/run-pass/expr-match-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -12,7 +12,7 @@\n \n // ignore-fast\n \n-type compare<T> = 'static |T, T| -> bool;\n+type compare<T> = |T, T|: 'static -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = match true { true => { expected.clone() }, _ => fail!(\"wat\") };"}, {"sha": "991a1f449f191b6e7daec808e8de3ab1de6d8865", "filename": "src/test/run-pass/expr-match-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique1.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-type compare<T> = 'static |~T, ~T| -> bool;\n+type compare<T> = |~T, ~T|: 'static -> bool;\n \n fn test_generic<T:Clone>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = match true {"}, {"sha": "6c1a6d22de70333247285d4881e751cba376b617", "filename": "src/test/run-pass/expr-match-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique2.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-fast\n \n-type compare<'a, T> = 'a |T, T| -> bool;\n+type compare<'a, T> = |T, T|: 'a -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = match true {"}, {"sha": "6b7490ba67368ce0b56f77e648b3c1690b9cb85c", "filename": "src/test/run-pass/fn-coerce-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct r<'a> {\n-    field: 'a ||\n+    field: ||: 'a,\n }\n \n pub fn main() {"}, {"sha": "3ff7fea95f1b763fab8f4828d9e96228892bee53", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -28,7 +28,7 @@ mod map_reduce {\n     use std::str;\n     use std::task;\n \n-    pub type putter<'a> = 'a |~str, ~str|;\n+    pub type putter<'a> = |~str, ~str|: 'a;\n \n     pub type mapper = extern fn(~str, putter);\n "}, {"sha": "3254f5bc35f903ab51be34e715e8543efc52c10e", "filename": "src/test/run-pass/issue-10767.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fissue-10767.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fissue-10767.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10767.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    fn f() {\n+    };\n+    let _: ~fn() = ~f;\n+}"}, {"sha": "00e6b5ca8fedc3d19131c8e57c9857046b4809ba", "filename": "src/test/run-pass/issue-3052.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fissue-3052.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fissue-3052.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3052.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-type Connection = 'static |Vec<u8> |;\n+type Connection = |Vec<u8>|: 'static;\n \n fn f() -> Option<Connection> {\n     let mock_connection: Connection = |_| {};"}, {"sha": "81a7d073c4cda18237a930e61db10d365538e64d", "filename": "src/test/run-pass/issue-3904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fissue-3904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fissue-3904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3904.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type ErrPrinter<'a> = 'a |&str, &str|;\n+type ErrPrinter<'a> = |&str, &str|: 'a;\n \n fn example_err(prog: &str, arg: &str) {\n     println!(\"{}: {}\", prog, arg)"}, {"sha": "5a78aed5826de45dc11ab19d952848ee064c9b56", "filename": "src/test/run-pass/issue-6157.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fissue-6157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fissue-6157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6157.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -10,7 +10,7 @@\n \n pub trait OpInt<'a> { fn call<'a>(&'a self, int, int) -> int; }\n \n-impl<'a> OpInt<'a> for 'a |int, int| -> int {\n+impl<'a> OpInt<'a> for |int, int|: 'a -> int {\n     fn call(&self, a:int, b:int) -> int {\n         (*self)(a, b)\n     }"}, {"sha": "995fc0911130e9f4335e1bdf5c5b5f7b5e094fa9", "filename": "src/test/run-pass/once-move-out-on-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -12,7 +12,7 @@\n \n // ignore-fast\n \n-#[feature(once_fns)];\n+#![feature(once_fns)]\n extern crate sync;\n use sync::Arc;\n "}, {"sha": "ac40fb885a134b908f8ecff5f3be6b9c65eb49e7", "filename": "src/test/run-pass/regions-copy-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n struct closure_box<'a> {\n-    cl: 'a ||,\n+    cl: ||: 'a,\n }\n \n-fn box_it<'r>(x: 'r ||) -> closure_box<'r> {\n+fn box_it<'r>(x: ||: 'r) -> closure_box<'r> {\n     closure_box {cl: x}\n }\n "}, {"sha": "e9cd7fb49731fc7838cef65621006f4a7a84a253", "filename": "src/test/run-pass/regions-dependent-autofn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fregions-dependent-autofn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fregions-dependent-autofn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-autofn.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -11,9 +11,9 @@\n // Test lifetimes are linked properly when we autoslice a vector.\n // Issue #3148.\n \n-fn subslice<'r>(v: 'r ||) -> 'r || { v }\n+fn subslice<'r>(v: ||: 'r) -> ||: 'r { v }\n \n-fn both<'r>(v: 'r ||) -> 'r || {\n+fn both<'r>(v: ||: 'r) -> ||: 'r {\n     subslice(subslice(v))\n }\n "}, {"sha": "d91c11dde10e2da6e24f2eaa2c5f35e2203b07d4", "filename": "src/test/run-pass/regions-static-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f82a79b2275a696b21086ddf5148a617fe20a/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs?ref=667f82a79b2275a696b21086ddf5148a617fe20a", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n struct closure_box<'a> {\n-    cl: 'a ||,\n+    cl: ||: 'a,\n }\n \n-fn box_it<'r>(x: 'r ||) -> closure_box<'r> {\n+fn box_it<'r>(x: ||: 'r) -> closure_box<'r> {\n     closure_box {cl: x}\n }\n "}]}