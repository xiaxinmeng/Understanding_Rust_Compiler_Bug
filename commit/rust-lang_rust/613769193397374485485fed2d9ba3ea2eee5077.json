{"sha": "613769193397374485485fed2d9ba3ea2eee5077", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMzc2OTE5MzM5NzM3NDQ4NTQ4NWZlZDJkOWJhM2VhMmVlZTUwNzc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-27T17:54:54Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-09-15T11:57:58Z"}, "message": "const interning: move mutability computation into intern_shallow, and always intern constants as immutable", "tree": {"sha": "311b1194a72aa56c02a204592972b053bbd571c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/311b1194a72aa56c02a204592972b053bbd571c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/613769193397374485485fed2d9ba3ea2eee5077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/613769193397374485485fed2d9ba3ea2eee5077", "html_url": "https://github.com/rust-lang/rust/commit/613769193397374485485fed2d9ba3ea2eee5077", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/613769193397374485485fed2d9ba3ea2eee5077/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bf776d5c2fc88624d2562e493aab0d324a3b7d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bf776d5c2fc88624d2562e493aab0d324a3b7d8", "html_url": "https://github.com/rust-lang/rust/commit/8bf776d5c2fc88624d2562e493aab0d324a3b7d8"}], "stats": {"total": 127, "additions": 60, "deletions": 67}, "files": [{"sha": "e05b31477e175ba01c926ebf992881b08feb0cb9", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 59, "deletions": 66, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/613769193397374485485fed2d9ba3ea2eee5077/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613769193397374485485fed2d9ba3ea2eee5077/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=613769193397374485485fed2d9ba3ea2eee5077", "patch": "@@ -3,18 +3,17 @@\n //! After a const evaluation has computed a value, before we destroy the const evaluator's session\n //! memory, we need to extract all memory allocations to the global memory pool so they stay around.\n \n-use rustc::ty::{Ty, TyCtxt, ParamEnv, self};\n+use rustc::ty::{Ty, ParamEnv, self};\n use rustc::mir::interpret::{InterpResult, ErrorHandled};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use super::validity::RefTracking;\n use rustc_data_structures::fx::FxHashSet;\n \n use syntax::ast::Mutability;\n-use syntax_pos::Span;\n \n use super::{\n-    ValueVisitor, MemoryKind, Pointer, AllocId, MPlaceTy, Scalar,\n+    ValueVisitor, MemoryKind, AllocId, MPlaceTy, Scalar,\n };\n use crate::const_eval::{CompileTimeInterpreter, CompileTimeEvalContext};\n \n@@ -27,12 +26,10 @@ struct InternVisitor<'rt, 'mir, 'tcx> {\n     /// for sanity assertions that will ICE when `const_qualif` screws up.\n     mode: InternMode,\n     /// This field stores the mutability of the value *currently* being checked.\n-    /// It is set to mutable when an `UnsafeCell` is encountered\n-    /// When recursing across a reference, we don't recurse but store the\n-    /// value to be checked in `ref_tracking` together with the mutability at which we are checking\n-    /// the value.\n-    /// When encountering an immutable reference, we treat everything as immutable that is behind\n-    /// it.\n+    /// When encountering a mutable reference, we determine the pointee mutability\n+    /// taking into account the mutability of the context: `& &mut i32` is entirely immutable,\n+    /// despite the nested mutable reference!\n+    /// The field gets updated when an `UnsafeCell` is encountered.\n     mutability: Mutability,\n     /// A list of all encountered relocations. After type-based interning, we traverse this list to\n     /// also intern allocations that are only referenced by a raw pointer or inside a union.\n@@ -45,9 +42,10 @@ enum InternMode {\n     /// `static`. In a `static mut` we start out as mutable and thus can also contain further `&mut`\n     /// that will actually be treated as mutable.\n     Static,\n-    /// UnsafeCell is OK in the value of a constant, but not behind references in a constant\n+    /// UnsafeCell is OK in the value of a constant: `const FOO = Cell::new(0)` creates\n+    /// a new cell every time it is used.\n     ConstBase,\n-    /// `UnsafeCell` ICEs\n+    /// `UnsafeCell` ICEs.\n     Const,\n }\n \n@@ -56,26 +54,31 @@ enum InternMode {\n struct IsStaticOrFn;\n \n impl<'rt, 'mir, 'tcx> InternVisitor<'rt, 'mir, 'tcx> {\n-    /// Intern an allocation without looking at its children\n+    /// Intern an allocation without looking at its children.\n+    /// `mutablity` is the mutability of the place to be interned; even if that says\n+    /// `immutable` things might become mutable if `ty` is not frozen.\n     fn intern_shallow(\n         &mut self,\n-        ptr: Pointer,\n+        alloc_id: AllocId,\n         mutability: Mutability,\n+        ty: Option<Ty<'tcx>>,\n     ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n         trace!(\n             \"InternVisitor::intern {:?} with {:?}\",\n-            ptr, mutability,\n+            alloc_id, mutability,\n         );\n         // remove allocation\n         let tcx = self.ecx.tcx;\n         let memory = self.ecx.memory_mut();\n-        let (kind, mut alloc) = match memory.alloc_map.remove(&ptr.alloc_id) {\n+        let (kind, mut alloc) = match memory.alloc_map.remove(&alloc_id) {\n             Some(entry) => entry,\n             None => {\n-                // if the pointer is dangling (neither in local nor global memory), we leave it\n+                // Pointer not found in local memory map. It is either a pointer to the global\n+                // map, or dangling.\n+                // If the pointer is dangling (neither in local nor global memory), we leave it\n                 // to validation to error. The `delay_span_bug` ensures that we don't forget such\n                 // a check in validation.\n-                if tcx.alloc_map.lock().get(ptr.alloc_id).is_none() {\n+                if tcx.alloc_map.lock().get(alloc_id).is_none() {\n                     tcx.sess.delay_span_bug(self.ecx.tcx.span, \"tried to intern dangling pointer\");\n                 }\n                 // treat dangling pointers like other statics\n@@ -88,14 +91,35 @@ impl<'rt, 'mir, 'tcx> InternVisitor<'rt, 'mir, 'tcx> {\n         match kind {\n             MemoryKind::Stack | MemoryKind::Vtable => {},\n         }\n-        // Ensure llvm knows to only put this into immutable memory if the value is immutable either\n-        // by being behind a reference or by being part of a static or const without interior\n-        // mutability\n-        alloc.mutability = mutability;\n+        // Set allocation mutability as appropriate. This is used by LLVM to put things into\n+        // read-only memory, and also by Miri when evluating other constants/statics that\n+        // access this one.\n+        if self.mode == InternMode::Static {\n+            let frozen = ty.map_or(true, |ty| ty.is_freeze(\n+                self.ecx.tcx.tcx,\n+                self.param_env,\n+                self.ecx.tcx.span,\n+            ));\n+            // For statics, allocation mutability is the combination of the place mutability and\n+            // the type mutability.\n+            // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n+            if mutability == Mutability::Immutable && frozen {\n+                alloc.mutability = Mutability::Immutable;\n+            } else {\n+                // Just making sure we are not \"upgrading\" an immutable allocation to mutable.\n+                assert_eq!(alloc.mutability, Mutability::Mutable);\n+            }\n+        } else {\n+            // We *could* be non-frozen at `ConstBase`, for constants like `Cell::new(0)`.\n+            // But we still intern that as immutable as the memory cannot be changed once the\n+            // initial value was computed.\n+            // Constants are never mutable.\n+            alloc.mutability = Mutability::Immutable;\n+        };\n         // link the alloc id to the actual allocation\n         let alloc = tcx.intern_const_alloc(alloc);\n         self.leftover_relocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n-        tcx.alloc_map.lock().set_alloc_id_memory(ptr.alloc_id, alloc);\n+        tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n         Ok(None)\n     }\n }\n@@ -119,14 +143,16 @@ for\n     ) -> InterpResult<'tcx> {\n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n             if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n-                // We are crossing over an `UnsafeCell`, we can mutate again\n+                // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n+                // References we encounter inside here are interned as pointing to mutable\n+                // allocations.\n                 let old = std::mem::replace(&mut self.mutability, Mutability::Mutable);\n                 assert_ne!(\n                     self.mode, InternMode::Const,\n                     \"UnsafeCells are not allowed behind references in constants. This should have \\\n                     been prevented statically by const qualification. If this were allowed one \\\n-                    would be able to change a constant at one use site and other use sites may \\\n-                    arbitrarily decide to change, too.\",\n+                    would be able to change a constant at one use site and other use sites could \\\n+                    observe that mutation.\",\n                 );\n                 let walked = self.walk_aggregate(mplace, fields);\n                 self.mutability = old;\n@@ -150,7 +176,7 @@ for\n                     if let Ok(vtable) = meta.unwrap().to_ptr() {\n                         // explitly choose `Immutable` here, since vtables are immutable, even\n                         // if the reference of the fat pointer is mutable\n-                        self.intern_shallow(vtable, Mutability::Immutable)?;\n+                        self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n                     }\n                 }\n             }\n@@ -195,21 +221,13 @@ for\n                     (Mutability::Mutable, hir::Mutability::MutMutable) => Mutability::Mutable,\n                     _ => Mutability::Immutable,\n                 };\n-                // Compute the mutability of the allocation\n-                let intern_mutability = intern_mutability(\n-                    self.ecx.tcx.tcx,\n-                    self.param_env,\n-                    mplace.layout.ty,\n-                    self.ecx.tcx.span,\n-                    mutability,\n-                );\n                 // Recursing behind references changes the intern mode for constants in order to\n                 // cause assertions to trigger if we encounter any `UnsafeCell`s.\n                 let mode = match self.mode {\n                     InternMode::ConstBase => InternMode::Const,\n                     other => other,\n                 };\n-                match self.intern_shallow(ptr, intern_mutability)? {\n+                match self.intern_shallow(ptr.alloc_id, mutability, Some(mplace.layout.ty))? {\n                     // No need to recurse, these are interned already and statics may have\n                     // cycles, so we don't want to recurse there\n                     Some(IsStaticOrFn) => {},\n@@ -224,23 +242,6 @@ for\n     }\n }\n \n-/// Figure out the mutability of the allocation.\n-/// Mutable if it has interior mutability *anywhere* in the type.\n-fn intern_mutability<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-    span: Span,\n-    mutability: Mutability,\n-) -> Mutability {\n-    let has_interior_mutability = !ty.is_freeze(tcx, param_env, span);\n-    if has_interior_mutability {\n-        Mutability::Mutable\n-    } else {\n-        mutability\n-    }\n-}\n-\n pub fn intern_const_alloc_recursive(\n     ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n     def_id: DefId,\n@@ -251,34 +252,26 @@ pub fn intern_const_alloc_recursive(\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n     // this `mutability` is the mutability of the place, ignoring the type\n-    let (mutability, base_intern_mode) = match tcx.static_mutability(def_id) {\n+    let (base_mutability, base_intern_mode) = match tcx.static_mutability(def_id) {\n         Some(hir::Mutability::MutImmutable) => (Mutability::Immutable, InternMode::Static),\n         None => (Mutability::Immutable, InternMode::ConstBase),\n         // `static mut` doesn't care about interior mutability, it's mutable anyway\n         Some(hir::Mutability::MutMutable) => (Mutability::Mutable, InternMode::Static),\n     };\n \n     // type based interning\n-    let mut ref_tracking = RefTracking::new((ret, mutability, base_intern_mode));\n+    let mut ref_tracking = RefTracking::new((ret, base_mutability, base_intern_mode));\n     let leftover_relocations = &mut FxHashSet::default();\n \n-    // This mutability is the combination of the place mutability and the type mutability. If either\n-    // is mutable, `alloc_mutability` is mutable. This exists because the entire allocation needs\n-    // to be mutable if it contains an `UnsafeCell` anywhere. The other `mutability` exists so that\n-    // the visitor does not treat everything outside the `UnsafeCell` as mutable.\n-    let alloc_mutability = intern_mutability(\n-        tcx.tcx, param_env, ret.layout.ty, tcx.span, mutability,\n-    );\n-\n     // start with the outermost allocation\n     InternVisitor {\n         ref_tracking: &mut ref_tracking,\n         ecx,\n         mode: base_intern_mode,\n         leftover_relocations,\n         param_env,\n-        mutability,\n-    }.intern_shallow(ret.ptr.to_ptr()?, alloc_mutability)?;\n+        mutability: base_mutability,\n+    }.intern_shallow(ret.ptr.to_ptr()?.alloc_id, base_mutability, Some(ret.layout.ty))?;\n \n     while let Some(((mplace, mutability, mode), _)) = ref_tracking.todo.pop() {\n         let interned = InternVisitor {\n@@ -312,8 +305,8 @@ pub fn intern_const_alloc_recursive(\n     let mut todo: Vec<_> = leftover_relocations.iter().cloned().collect();\n     while let Some(alloc_id) = todo.pop() {\n         if let Some((_, alloc)) = ecx.memory_mut().alloc_map.remove(&alloc_id) {\n-            // We can't call the `intern` method here, as its logic is tailored to safe references.\n-            // So we hand-roll the interning logic here again\n+            // We can't call the `intern_shallow` method here, as its logic is tailored to safe\n+            // references. So we hand-roll the interning logic here again.\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n             for &(_, ((), reloc)) in alloc.relocations().iter() {"}, {"sha": "28cf3537d605a41d005f78f29b5afa6f30980ab3", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/613769193397374485485fed2d9ba3ea2eee5077/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/613769193397374485485fed2d9ba3ea2eee5077/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr?ref=613769193397374485485fed2d9ba3ea2eee5077", "patch": "@@ -6,7 +6,7 @@ LL |         *MUH.x.get() = 99;\n \n thread 'rustc' panicked at 'assertion failed: `(left != right)`\n   left: `Const`,\n- right: `Const`: UnsafeCells are not allowed behind references in constants. This should have been prevented statically by const qualification. If this were allowed one would be able to change a constant at one use site and other use sites may arbitrarily decide to change, too.', src/librustc_mir/interpret/intern.rs:LL:CC\n+ right: `Const`: UnsafeCells are not allowed behind references in constants. This should have been prevented statically by const qualification. If this were allowed one would be able to change a constant at one use site and other use sites could observe that mutation.', src/librustc_mir/interpret/intern.rs:LL:CC\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n error: internal compiler error: unexpected panic"}]}