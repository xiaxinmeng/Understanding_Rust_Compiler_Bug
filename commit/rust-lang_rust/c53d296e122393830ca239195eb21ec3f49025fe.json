{"sha": "c53d296e122393830ca239195eb21ec3f49025fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1M2QyOTZlMTIyMzkzODMwY2EyMzkxOTVlYjIxZWMzZjQ5MDI1ZmU=", "commit": {"author": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-06T18:59:33Z"}, "committer": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-06T18:59:33Z"}, "message": "Change check_loans to use ExprUseVisitor.", "tree": {"sha": "fb996addb8de05e48a457f64a1887b28caa2e4bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb996addb8de05e48a457f64a1887b28caa2e4bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c53d296e122393830ca239195eb21ec3f49025fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c53d296e122393830ca239195eb21ec3f49025fe", "html_url": "https://github.com/rust-lang/rust/commit/c53d296e122393830ca239195eb21ec3f49025fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c53d296e122393830ca239195eb21ec3f49025fe/comments", "author": null, "committer": null, "parents": [{"sha": "78934b03e39af86e60bdafcfe186b0f88c5b192e", "url": "https://api.github.com/repos/rust-lang/rust/commits/78934b03e39af86e60bdafcfe186b0f88c5b192e", "html_url": "https://github.com/rust-lang/rust/commit/78934b03e39af86e60bdafcfe186b0f88c5b192e"}], "stats": {"total": 453, "additions": 223, "deletions": 230}, "files": [{"sha": "fed1fb9c60992e687dc2228b3fe243c33df4d49f", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 216, "deletions": 212, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/c53d296e122393830ca239195eb21ec3f49025fe/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53d296e122393830ca239195eb21ec3f49025fe/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=c53d296e122393830ca239195eb21ec3f49025fe", "patch": "@@ -20,15 +20,10 @@\n \n use middle::borrowck::*;\n use euv = middle::expr_use_visitor;\n-use middle::freevars;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use middle::typeck::MethodCall;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::codemap::Span;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n@@ -40,35 +35,104 @@ struct CheckLoanCtxt<'a> {\n     all_loans: &'a [Loan],\n }\n \n-impl<'a> Visitor<()> for CheckLoanCtxt<'a> {\n+impl<'a> euv::Delegate for CheckLoanCtxt<'a> {\n+    fn consume(&mut self,\n+               consume_id: ast::NodeId,\n+               consume_span: Span,\n+               cmt: mc::cmt,\n+               mode: euv::ConsumeMode) {\n+        debug!(\"consume(consume_id={}, cmt={}, mode={})\",\n+               consume_id, cmt.repr(self.tcx()), mode);\n \n-    fn visit_expr(&mut self, ex: &ast::Expr, _: ()) {\n-        check_loans_in_expr(self, ex);\n+        self.consume_common(consume_id, consume_span, cmt, mode);\n     }\n-    fn visit_local(&mut self, l: &ast::Local, _: ()) {\n-        check_loans_in_local(self, l);\n-    }\n-    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n-        check_loans_in_block(self, b);\n+\n+    fn consume_pat(&mut self,\n+                   consume_pat: &ast::Pat,\n+                   cmt: mc::cmt,\n+                   mode: euv::ConsumeMode) {\n+        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={})\",\n+               consume_pat.repr(self.tcx()),\n+               cmt.repr(self.tcx()),\n+               mode);\n+\n+        self.consume_common(consume_pat.id, consume_pat.span, cmt, mode);\n     }\n-    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n-        check_loans_in_pat(self, p);\n+\n+    fn borrow(&mut self,\n+              borrow_id: ast::NodeId,\n+              borrow_span: Span,\n+              cmt: mc::cmt,\n+              loan_region: ty::Region,\n+              bk: ty::BorrowKind,\n+              loan_cause: euv::LoanCause)\n+    {\n+        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={}, \\\n+               bk={}, loan_cause={:?})\",\n+               borrow_id, cmt.repr(self.tcx()), loan_region,\n+               bk, loan_cause);\n+\n+        match opt_loan_path(&cmt) {\n+            Some(lp) => {\n+                let moved_value_use_kind = match loan_cause {\n+                    euv::ClosureCapture(_) => MovedInCapture,\n+                    _ => MovedInUse,\n+                };\n+                self.check_if_path_is_moved(borrow_id, borrow_span, moved_value_use_kind, &lp);\n+            }\n+            None => { }\n+        }\n+\n+        self.check_for_conflicting_loans(borrow_id);\n     }\n-    fn visit_fn(&mut self, _fk: &visit::FnKind, _fd: &ast::FnDecl,\n-                _b: &ast::Block, _s: Span, _n: ast::NodeId, _: ()) {\n-        // Don't process nested items or closures here,\n-        // the outer loop will take care of it.\n-        return;\n+\n+    fn mutate(&mut self,\n+              assignment_id: ast::NodeId,\n+              assignment_span: Span,\n+              assignee_cmt: mc::cmt,\n+              mode: euv::MutateMode)\n+    {\n+        debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n+               assignment_id, assignee_cmt.repr(self.tcx()));\n+\n+        match opt_loan_path(&assignee_cmt) {\n+            Some(lp) => {\n+                match mode {\n+                    euv::Init | euv::JustWrite => {\n+                        // In a case like `path = 1`, then path does not\n+                        // have to be *FULLY* initialized, but we still\n+                        // must be careful lest it contains derefs of\n+                        // pointers.\n+                        self.check_if_assigned_path_is_moved(assignee_cmt.id,\n+                                                             assignment_span,\n+                                                             MovedInUse,\n+                                                             &lp);\n+                    }\n+                    euv::WriteAndRead => {\n+                        // In a case like `path += 1`, then path must be\n+                        // fully initialized, since we will read it before\n+                        // we write it.\n+                        self.check_if_path_is_moved(assignee_cmt.id,\n+                                                    assignment_span,\n+                                                    MovedInUse,\n+                                                    &lp);\n+                    }\n+                }\n+            }\n+            None => { }\n+        }\n+\n+        self.check_assignment(assignment_id, assignment_span, assignee_cmt, mode);\n     }\n \n-    // FIXME(#10894) should continue recursing\n-    fn visit_ty(&mut self, _t: &ast::Ty, _: ()) {}\n+    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n }\n \n pub fn check_loans(bccx: &BorrowckCtxt,\n                    dfcx_loans: &LoanDataFlow,\n                    move_data: move_data::FlowedMoveData,\n                    all_loans: &[Loan],\n+                   decl: &ast::FnDecl,\n                    body: &ast::Block) {\n     debug!(\"check_loans(body id={:?})\", body.id);\n \n@@ -79,7 +143,10 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n         all_loans: all_loans,\n     };\n \n-    clcx.visit_block(body, ());\n+    {\n+        let mut euv = euv::ExprUseVisitor::new(&mut clcx, bccx.tcx);\n+        euv.walk_fn(decl, body);\n+    }\n }\n \n #[deriving(PartialEq)]\n@@ -355,18 +422,130 @@ impl<'a> CheckLoanCtxt<'a> {\n         true\n     }\n \n-    pub fn is_local_variable(&self, cmt: mc::cmt) -> bool {\n+    pub fn is_local_variable_or_arg(&self, cmt: mc::cmt) -> bool {\n         match cmt.cat {\n-          mc::cat_local(_) => true,\n+          mc::cat_local(_) | mc::cat_arg(_) => true,\n           _ => false\n         }\n     }\n \n-    pub fn check_if_path_is_moved(&self,\n-                                  id: ast::NodeId,\n-                                  span: Span,\n-                                  use_kind: MovedValueUseKind,\n-                                  lp: &Rc<LoanPath>) {\n+    fn consume_common(&self,\n+                      id: ast::NodeId,\n+                      span: Span,\n+                      cmt: mc::cmt,\n+                      mode: euv::ConsumeMode) {\n+        match opt_loan_path(&cmt) {\n+            Some(lp) => {\n+                let moved_value_use_kind = match mode {\n+                    euv::Copy => {\n+                        // FIXME(#12624) -- If we are copying the value,\n+                        // we don't care if it's borrowed.\n+                        MovedInUse\n+                    }\n+                    euv::Move(_) => {\n+                        match self.move_data.kind_of_move_of_path(id, &lp) {\n+                            None => {\n+                                // Sometimes moves don't have a move kind;\n+                                // this either means that the original move\n+                                // was from something illegal to move,\n+                                // or was moved from referent of an unsafe\n+                                // pointer or something like that.\n+                                MovedInUse\n+                            }\n+                            Some(move_kind) => {\n+                                self.check_for_move_of_borrowed_path(id, span,\n+                                                                     &lp, move_kind);\n+                                if move_kind == move_data::Captured {\n+                                    MovedInCapture\n+                                } else {\n+                                    MovedInUse\n+                                }\n+                            }\n+                        }\n+                    }\n+                };\n+\n+                self.check_if_path_is_moved(id, span, moved_value_use_kind, &lp);\n+            }\n+            None => { }\n+        }\n+    }\n+\n+    fn check_for_move_of_borrowed_path(&self,\n+                                       id: ast::NodeId,\n+                                       span: Span,\n+                                       move_path: &Rc<LoanPath>,\n+                                       move_kind: move_data::MoveKind) {\n+        match self.analyze_move_out_from(id, &**move_path) {\n+            MoveOk => { }\n+            MoveWhileBorrowed(loan_path, loan_span) => {\n+                let err_message = match move_kind {\n+                    move_data::Captured =>\n+                        format!(\"cannot move `{}` into closure because it is borrowed\",\n+                                self.bccx.loan_path_to_str(&**move_path).as_slice()),\n+                    move_data::Declared |\n+                    move_data::MoveExpr |\n+                    move_data::MovePat =>\n+                        format!(\"cannot move out of `{}` because it is borrowed\",\n+                                self.bccx.loan_path_to_str(&**move_path).as_slice())\n+                };\n+\n+                self.bccx.span_err(span, err_message.as_slice());\n+                self.bccx.span_note(\n+                    loan_span,\n+                    format!(\"borrow of `{}` occurs here\",\n+                            self.bccx.loan_path_to_str(&*loan_path).as_slice())\n+                    .as_slice());\n+            }\n+        }\n+    }\n+\n+    fn check_if_assigned_path_is_moved(&self,\n+                                       id: ast::NodeId,\n+                                       span: Span,\n+                                       use_kind: MovedValueUseKind,\n+                                       lp: &Rc<LoanPath>)\n+    {\n+        /*!\n+         * Reports an error if assigning to `lp` will use a\n+         * moved/uninitialized value. Mainly this is concerned with\n+         * detecting derefs of uninitialized pointers.\n+         *\n+         * For example:\n+         *\n+         *     let a: int;\n+         *     a = 10; // ok, even though a is uninitialized\n+         *\n+         *     struct Point { x: uint, y: uint }\n+         *     let p: Point;\n+         *     p.x = 22; // ok, even though `p` is uninitialized\n+         *\n+         *     let p: ~Point;\n+         *     (*p).x = 22; // not ok, p is uninitialized, can't deref\n+         */\n+\n+        match **lp {\n+            LpVar(_) => {\n+                // assigning to `x` does not require that `x` is initialized\n+            }\n+            LpExtend(ref lp_base, _, LpInterior(_)) => {\n+                // assigning to `P.f` is ok if assigning to `P` is ok\n+                self.check_if_assigned_path_is_moved(id, span,\n+                                                     use_kind, lp_base);\n+            }\n+            LpExtend(ref lp_base, _, LpDeref(_)) => {\n+                // assigning to `(*P)` requires that `P` be initialized\n+                self.check_if_path_is_moved(id, span,\n+                                            use_kind, lp_base);\n+            }\n+        }\n+    }\n+\n+    fn check_if_path_is_moved(&self,\n+                              id: ast::NodeId,\n+                              span: Span,\n+                              use_kind: MovedValueUseKind,\n+                              lp: &Rc<LoanPath>) {\n         /*!\n          * Reports an error if `expr` (which should be a path)\n          * is using a moved/uninitialized value\n@@ -385,32 +564,21 @@ impl<'a> CheckLoanCtxt<'a> {\n         });\n     }\n \n-    pub fn check_assignment_expr(&self, expr: &ast::Expr) {\n-        let assignment_id = expr.id;\n-        let assignment_span = expr.span;\n-\n-        // We don't use cat_expr() here because we don't want to treat\n-        // auto-ref'd parameters in overloaded operators as rvalues.\n-        let assignee_cmt = match self.bccx.tcx.adjustments.borrow().find(&assignment_id) {\n-            None => self.bccx.cat_expr_unadjusted(expr),\n-            Some(adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n-        };\n-\n-        self.check_assignment(assignment_id, assignment_span, assignee_cmt);\n-    }\n-\n     fn check_assignment(&self,\n                         assignment_id: ast::NodeId,\n                         assignment_span: Span,\n-                        assignee_cmt: mc::cmt) {\n+                        assignee_cmt: mc::cmt,\n+                        mode: euv::MutateMode) {\n         debug!(\"check_assignment(assignee_cmt={})\", assignee_cmt.repr(self.tcx()));\n \n         // Mutable values can be assigned, as long as they obey loans\n         // and aliasing restrictions:\n         if assignee_cmt.mutbl.is_mutable() {\n             if check_for_aliasable_mutable_writes(self, assignment_span, assignee_cmt.clone()) {\n-                if check_for_assignment_to_restricted_or_frozen_location(\n-                    self, assignment_id, assignment_span, assignee_cmt.clone()) {\n+                if mode != euv::Init &&\n+                    check_for_assignment_to_restricted_or_frozen_location(\n+                        self, assignment_id, assignment_span, assignee_cmt.clone())\n+                {\n                     // Safe, but record for lint pass later:\n                     mark_variable_as_used_mut(self, assignee_cmt);\n                 }\n@@ -420,7 +588,7 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         // For immutable local variables, assignments are legal\n         // if they cannot already have been assigned\n-        if self.is_local_variable(assignee_cmt.clone()) {\n+        if self.is_local_variable_or_arg(assignee_cmt.clone()) {\n             assert!(assignee_cmt.mutbl.is_immutable()); // no \"const\" locals\n             let lp = opt_loan_path(&assignee_cmt).unwrap();\n             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n@@ -695,86 +863,6 @@ impl<'a> CheckLoanCtxt<'a> {\n                     self.bccx.loan_path_to_str(loan_path)).as_slice());\n     }\n \n-    fn check_move_out_from_expr(&self, expr: &ast::Expr) {\n-        match expr.node {\n-            ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-                // Moves due to captures are checked in\n-                // check_captured_variables() because it allows\n-                // us to give a more precise error message with\n-                // a more precise span.\n-            }\n-            _ => {\n-                self.check_move_out_from_id(expr.id, expr.span)\n-            }\n-        }\n-    }\n-\n-    fn check_move_out_from_id(&self, id: ast::NodeId, span: Span) {\n-        self.move_data.each_path_moved_by(id, |_, move_path| {\n-            match self.analyze_move_out_from(id, move_path) {\n-                MoveOk => {}\n-                MoveWhileBorrowed(loan_path, loan_span) => {\n-                    self.bccx.span_err(\n-                        span,\n-                        format!(\"cannot move out of `{}` \\\n-                                because it is borrowed\",\n-                                self.bccx.loan_path_to_str(\n-                                    move_path)).as_slice());\n-                    self.bccx.span_note(\n-                        loan_span,\n-                        format!(\"borrow of `{}` occurs here\",\n-                                self.bccx.loan_path_to_str(\n-                                    &*loan_path)).as_slice());\n-                }\n-            }\n-            true\n-        });\n-    }\n-\n-    fn check_captured_variables(&self,\n-                                closure_id: ast::NodeId,\n-                                span: Span) {\n-        let freevar_mode = freevars::get_capture_mode(self.tcx(), closure_id);\n-        freevars::with_freevars(self.tcx(), closure_id, |freevars| {\n-            for freevar in freevars.iter() {\n-                let var_id = ast_util::def_id_of_def(freevar.def).node;\n-                let var_path = Rc::new(LpVar(var_id));\n-                self.check_if_path_is_moved(closure_id, span,\n-                                            MovedInCapture, &var_path);\n-                match freevar_mode {\n-                    freevars::CaptureByRef => { }\n-                    freevars::CaptureByValue => {\n-                        check_by_move_capture(self, closure_id, freevar.span, &*var_path);\n-                    }\n-                }\n-            }\n-        });\n-        return;\n-\n-        fn check_by_move_capture(this: &CheckLoanCtxt,\n-                                 closure_id: ast::NodeId,\n-                                 freevar_span: Span,\n-                                 move_path: &LoanPath) {\n-            let move_err = this.analyze_move_out_from(closure_id, move_path);\n-            match move_err {\n-                MoveOk => {}\n-                MoveWhileBorrowed(loan_path, loan_span) => {\n-                    this.bccx.span_err(\n-                        freevar_span,\n-                        format!(\"cannot move `{}` into closure \\\n-                                because it is borrowed\",\n-                                this.bccx.loan_path_to_str(\n-                                    move_path)).as_slice());\n-                    this.bccx.span_note(\n-                        loan_span,\n-                        format!(\"borrow of `{}` occurs here\",\n-                                this.bccx.loan_path_to_str(\n-                                    &*loan_path)).as_slice());\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn analyze_move_out_from(&self,\n                                  expr_id: ast::NodeId,\n                                  move_path: &LoanPath)\n@@ -805,89 +893,5 @@ impl<'a> CheckLoanCtxt<'a> {\n             }\n         }\n     }\n-\n-    pub fn check_call(&self,\n-                      _expr: &ast::Expr,\n-                      _callee: Option<@ast::Expr>,\n-                      _callee_span: Span,\n-                      _args: &[@ast::Expr]) {\n-        // NB: This call to check for conflicting loans is not truly\n-        // necessary, because the callee_id never issues new loans.\n-        // However, I added it for consistency and lest the system\n-        // should change in the future.\n-        //\n-        // FIXME(#6268) nested method calls\n-        // self.check_for_conflicting_loans(callee_id);\n-    }\n-}\n-\n-fn check_loans_in_local<'a>(this: &mut CheckLoanCtxt<'a>,\n-                            local: &ast::Local) {\n-    visit::walk_local(this, local, ());\n-}\n-\n-fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n-                           expr: &ast::Expr) {\n-    visit::walk_expr(this, expr, ());\n-\n-    debug!(\"check_loans_in_expr(expr={})\",\n-           expr.repr(this.tcx()));\n-\n-    this.check_for_conflicting_loans(expr.id);\n-    this.check_move_out_from_expr(expr);\n-\n-    let method_map = this.bccx.tcx.method_map.borrow();\n-    match expr.node {\n-      ast::ExprPath(..) => {\n-          if !this.move_data.is_assignee(expr.id) {\n-              let cmt = this.bccx.cat_expr_unadjusted(expr);\n-              debug!(\"path cmt={}\", cmt.repr(this.tcx()));\n-              for lp in opt_loan_path(&cmt).iter() {\n-                  this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);\n-              }\n-          }\n-      }\n-      ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-          this.check_captured_variables(expr.id, expr.span)\n-      }\n-      ast::ExprAssign(dest, _) |\n-      ast::ExprAssignOp(_, dest, _) => {\n-        this.check_assignment_expr(dest);\n-      }\n-      ast::ExprCall(f, ref args) => {\n-        this.check_call(expr, Some(f), f.span, args.as_slice());\n-      }\n-      ast::ExprMethodCall(_, _, ref args) => {\n-        this.check_call(expr, None, expr.span, args.as_slice());\n-      }\n-      ast::ExprIndex(_, rval) | ast::ExprBinary(_, _, rval)\n-      if method_map.contains_key(&MethodCall::expr(expr.id)) => {\n-        this.check_call(expr, None, expr.span, [rval]);\n-      }\n-      ast::ExprUnary(_, _) | ast::ExprIndex(_, _)\n-      if method_map.contains_key(&MethodCall::expr(expr.id)) => {\n-        this.check_call(expr, None, expr.span, []);\n-      }\n-      ast::ExprInlineAsm(ref ia) => {\n-          for &(_, out) in ia.outputs.iter() {\n-              this.check_assignment_expr(out);\n-          }\n-      }\n-      _ => {}\n-    }\n }\n \n-fn check_loans_in_pat<'a>(this: &mut CheckLoanCtxt<'a>,\n-                          pat: &ast::Pat)\n-{\n-    this.check_for_conflicting_loans(pat.id);\n-    this.check_move_out_from_id(pat.id, pat.span);\n-    visit::walk_pat(this, pat, ());\n-}\n-\n-fn check_loans_in_block<'a>(this: &mut CheckLoanCtxt<'a>,\n-                            blk: &ast::Block)\n-{\n-    visit::walk_block(this, blk, ());\n-    this.check_for_conflicting_loans(blk.id);\n-}"}, {"sha": "0fbcf157dacad562721144b91a3680cb448fce46", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53d296e122393830ca239195eb21ec3f49025fe/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53d296e122393830ca239195eb21ec3f49025fe/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=c53d296e122393830ca239195eb21ec3f49025fe", "patch": "@@ -142,7 +142,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                                                       body);\n \n     check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n-                             all_loans.as_slice(), body);\n+                             all_loans.as_slice(), decl, body);\n \n     visit::walk_fn(this, fk, decl, body, sp, ());\n }"}, {"sha": "f7c26292334841c6e20bb4b47dee8bfcc5191afd", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c53d296e122393830ca239195eb21ec3f49025fe/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53d296e122393830ca239195eb21ec3f49025fe/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=c53d296e122393830ca239195eb21ec3f49025fe", "patch": "@@ -115,6 +115,7 @@ pub struct MovePath {\n     pub next_sibling: MovePathIndex,\n }\n \n+#[deriving(PartialEq)]\n pub enum MoveKind {\n     Declared,   // When declared, variables start out \"moved\".\n     MoveExpr,   // Expression or binding that moves a variable"}, {"sha": "6a42989b47bba79dfa05ce0bc4bff9b0175d9dc4", "filename": "src/test/compile-fail/borrowck-init-in-fru.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fru.rs?ref=c53d296e122393830ca239195eb21ec3f49025fe", "patch": "@@ -16,6 +16,6 @@ struct point {\n \n fn main() {\n     let mut origin: point;\n-    origin = point {x: 10,.. origin}; //~ ERROR use of possibly uninitialized variable: `origin`\n+    origin = point {x: 10,.. origin}; //~ ERROR use of possibly uninitialized variable: `origin.y`\n     origin.clone();\n }"}, {"sha": "4b578765f32f411ccbf0e287679aa0f42b4b7adc", "filename": "src/test/compile-fail/liveness-use-after-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs?ref=c53d296e122393830ca239195eb21ec3f49025fe", "patch": "@@ -13,6 +13,6 @@ extern crate debug;\n fn main() {\n     let x = box 5;\n     let y = x;\n-    println!(\"{:?}\", *x); //~ ERROR use of moved value: `x`\n+    println!(\"{:?}\", *x); //~ ERROR use of partially moved value: `*x`\n     y.clone();\n }"}, {"sha": "f09e80974bd42d97d11745fc8d9ab277726ac9ab", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=c53d296e122393830ca239195eb21ec3f49025fe", "patch": "@@ -17,12 +17,6 @@ struct Foo { f: String, y: int }\n fn consume(_s: String) {}\n fn touch<A>(_a: &A) {}\n \n-fn f10() {\n-    let x = Foo { f: \"hi\".to_string(), y: 3 };\n-    consume(x.f);\n-    touch(&x.y); //~ ERROR use of partially moved value: `x`\n-}\n-\n fn f20() {\n     let x = vec!(\"hi\".to_string());\n     consume(x.move_iter().next().unwrap());"}, {"sha": "8b02740497df8945cbfd3dbacc2da4b9c2c638ed", "filename": "src/test/compile-fail/moves-sru-moved-field.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs?ref=c53d296e122393830ca239195eb21ec3f49025fe", "patch": "@@ -26,13 +26,7 @@ fn test0(f: Foo, g: Noncopyable, h: Noncopyable) {\n fn test1(f: Foo, g: Noncopyable, h: Noncopyable) {\n     // copying move-by-default fields from `f`, so move:\n     let _b = Foo {noncopyable: g, ..f};\n-    let _c = Foo {noncopyable: h, ..f}; //~ ERROR use of partially moved value: `f`\n-}\n-\n-fn test2(f: Foo, g: Noncopyable) {\n-    // move non-copyable field\n-    let _b = Foo {copied: 22, moved: box 23, ..f};\n-    let _c = Foo {noncopyable: g, ..f}; //~ ERROR use of partially moved value: `f`\n+    let _c = Foo {noncopyable: h, ..f}; //~ ERROR use of moved value: `f.moved`\n }\n \n fn main() {}"}, {"sha": "b11650a6a4f1fdb7dfcc981f0e6c1f2bf4c3198f", "filename": "src/test/compile-fail/use-after-move-self-based-on-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs?ref=c53d296e122393830ca239195eb21ec3f49025fe", "patch": "@@ -19,7 +19,7 @@ impl Drop for S {\n impl S {\n     pub fn foo(self) -> int {\n         self.bar();\n-        return self.x;  //~ ERROR use of moved value: `self`\n+        return self.x;  //~ ERROR use of partially moved value: `self.x`\n     }\n \n     pub fn bar(self) {}"}, {"sha": "22c3ec7c3417ced1ddb9cc9269923be53f259a73", "filename": "src/test/compile-fail/use-after-move-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53d296e122393830ca239195eb21ec3f49025fe/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs?ref=c53d296e122393830ca239195eb21ec3f49025fe", "patch": "@@ -16,7 +16,7 @@ struct S {\n impl S {\n     pub fn foo(self) -> int {\n         self.bar();\n-        return *self.x;  //~ ERROR use of moved value: `self`\n+        return *self.x;  //~ ERROR use of partially moved value: `*self.x`\n     }\n \n     pub fn bar(self) {}"}]}