{"sha": "648a35e3279f98783aaa0f78b71f5aee2f247225", "node_id": "C_kwDOAAsO6NoAKDY0OGEzNWUzMjc5Zjk4NzgzYWFhMGY3OGI3MWY1YWVlMmYyNDcyMjU", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-12-29T09:45:19Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2023-04-04T08:05:15Z"}, "message": "Add ability to transmute with generic consts\n\nPreviously if the expression contained generic consts and did not have a directly equivalent\ntype, transmuting the type in this way was forbidden, despite the two sizes being identical.\nInstead, we should be able to lazily tell if the two consts are identical, and if so allow them\nto be transmuted.", "tree": {"sha": "df4175c3274bd5ddebd6efa95e8995c43d02cd51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df4175c3274bd5ddebd6efa95e8995c43d02cd51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/648a35e3279f98783aaa0f78b71f5aee2f247225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/648a35e3279f98783aaa0f78b71f5aee2f247225", "html_url": "https://github.com/rust-lang/rust/commit/648a35e3279f98783aaa0f78b71f5aee2f247225", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/648a35e3279f98783aaa0f78b71f5aee2f247225/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82bfda848e28d7616c7045d7ced8cee88d2d1a8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/82bfda848e28d7616c7045d7ced8cee88d2d1a8f", "html_url": "https://github.com/rust-lang/rust/commit/82bfda848e28d7616c7045d7ced8cee88d2d1a8f"}], "stats": {"total": 268, "additions": 268, "deletions": 0}, "files": [{"sha": "eedab9fa1b0a109ea40bb8fc64116704b85c3412", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/648a35e3279f98783aaa0f78b71f5aee2f247225/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/648a35e3279f98783aaa0f78b71f5aee2f247225/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=648a35e3279f98783aaa0f78b71f5aee2f247225", "patch": "@@ -84,6 +84,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let skeleton_string = |ty: Ty<'tcx>, sk| match sk {\n             Ok(SizeSkeleton::Known(size)) => format!(\"{} bits\", size.bits()),\n             Ok(SizeSkeleton::Pointer { tail, .. }) => format!(\"pointer to `{tail}`\"),\n+            Ok(SizeSkeleton::Generic(size)) => {\n+                if let Some(size) = size.try_eval_target_usize(tcx, self.param_env) {\n+                    format!(\"{size} bytes\")\n+                } else {\n+                    format!(\"generic size\")\n+                }\n+            }\n             Err(LayoutError::Unknown(bad)) => {\n                 if bad == ty {\n                     \"this type does not have a fixed size\".to_owned()"}, {"sha": "2a057e71eac456caa116310827ff842a4d8dfe95", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/648a35e3279f98783aaa0f78b71f5aee2f247225/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/648a35e3279f98783aaa0f78b71f5aee2f247225/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=648a35e3279f98783aaa0f78b71f5aee2f247225", "patch": "@@ -281,6 +281,12 @@ pub enum SizeSkeleton<'tcx> {\n     /// Any statically computable Layout.\n     Known(Size),\n \n+    /// This is a generic const expression (i.e. N * 2), which may contain some parameters.\n+    /// It must be of type usize, and represents the size of a type in bytes.\n+    /// It is not required to be evaluatable to a concrete value, but can be used to check\n+    /// that another SizeSkeleton is of equal size.\n+    Generic(ty::Const<'tcx>),\n+\n     /// A potentially-fat pointer.\n     Pointer {\n         /// If true, this pointer is never null.\n@@ -326,6 +332,35 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                     ),\n                 }\n             }\n+            ty::Array(inner, len) if len.ty() == tcx.types.usize => {\n+                match SizeSkeleton::compute(inner, tcx, param_env)? {\n+                    // This may succeed because the multiplication of two types may overflow\n+                    // but a single size of a nested array will not.\n+                    SizeSkeleton::Known(s) => {\n+                        if let Some(c) = len.try_eval_target_usize(tcx, param_env) {\n+                            let size = s\n+                                .bytes()\n+                                .checked_mul(c)\n+                                .ok_or_else(|| LayoutError::SizeOverflow(ty))?;\n+                            return Ok(SizeSkeleton::Known(Size::from_bytes(size)));\n+                        }\n+                        let len = tcx.expand_abstract_consts(len);\n+                        let prev = ty::Const::from_target_usize(tcx, s.bytes());\n+                        let Some(gen_size) = mul_sorted_consts(tcx, param_env, len, prev) else {\n+                            return Err(LayoutError::SizeOverflow(ty));\n+                        };\n+                        Ok(SizeSkeleton::Generic(gen_size))\n+                    }\n+                    SizeSkeleton::Pointer { .. } => Err(err),\n+                    SizeSkeleton::Generic(g) => {\n+                        let len = tcx.expand_abstract_consts(len);\n+                        let Some(gen_size) = mul_sorted_consts(tcx, param_env, len, g) else {\n+                            return Err(LayoutError::SizeOverflow(ty));\n+                        };\n+                        Ok(SizeSkeleton::Generic(gen_size))\n+                    }\n+                }\n+            }\n \n             ty::Adt(def, substs) => {\n                 // Only newtypes and enums w/ nullable pointer optimization.\n@@ -355,6 +390,9 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                                 }\n                                 ptr = Some(field);\n                             }\n+                            SizeSkeleton::Generic(_) => {\n+                                return Err(err);\n+                            }\n                         }\n                     }\n                     Ok(ptr)\n@@ -410,11 +448,66 @@ impl<'tcx> SizeSkeleton<'tcx> {\n             (SizeSkeleton::Pointer { tail: a, .. }, SizeSkeleton::Pointer { tail: b, .. }) => {\n                 a == b\n             }\n+            // constants are always pre-normalized into a canonical form so this\n+            // only needs to check if their pointers are identical.\n+            (SizeSkeleton::Generic(a), SizeSkeleton::Generic(b)) => a == b,\n             _ => false,\n         }\n     }\n }\n \n+/// When creating the layout for types with abstract conts in their size (i.e. [usize; 4 * N]),\n+/// to ensure that they have a canonical order and can be compared directly we combine all\n+/// constants, and sort the other terms. This allows comparison of expressions of sizes,\n+/// allowing for things like transmutating between types that depend on generic consts.\n+/// This returns `None` if multiplication of constants overflows.\n+fn mul_sorted_consts<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    a: ty::Const<'tcx>,\n+    b: ty::Const<'tcx>,\n+) -> Option<ty::Const<'tcx>> {\n+    use crate::mir::BinOp::Mul;\n+    use ty::ConstKind::Expr;\n+    use ty::Expr::Binop;\n+\n+    let mut work = vec![a, b];\n+    let mut done = vec![];\n+    while let Some(n) = work.pop() {\n+        if let Expr(Binop(Mul, l, r)) = n.kind() {\n+            work.push(l);\n+            work.push(r)\n+        } else {\n+            done.push(n);\n+        }\n+    }\n+    let mut k = 1;\n+    let mut overflow = false;\n+    for _ in done.drain_filter(|c| {\n+        let Some(c) = c.try_eval_target_usize(tcx, param_env) else {\n+            return false;\n+        };\n+        let Some(next) = c.checked_mul(k) else {\n+            overflow = true;\n+            return true;\n+        };\n+        k *= next;\n+        true\n+    }) {}\n+    if overflow {\n+        return None;\n+    }\n+    if k != 1 {\n+        done.push(ty::Const::from_target_usize(tcx, k));\n+    } else if k == 0 {\n+        return Some(ty::Const::from_target_usize(tcx, 0));\n+    }\n+    done.sort_unstable();\n+\n+    // create a single tree from the buffer\n+    done.into_iter().reduce(|acc, n| tcx.mk_const(Expr(Binop(Mul, n, acc)), n.ty()))\n+}\n+\n pub trait HasTyCtxt<'tcx>: HasDataLayout {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n }"}, {"sha": "490e4de9aac71cbe197b259eb1228d8f81e4942f", "filename": "tests/ui/const-generics/transmute-fail.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/648a35e3279f98783aaa0f78b71f5aee2f247225/tests%2Fui%2Fconst-generics%2Ftransmute-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/648a35e3279f98783aaa0f78b71f5aee2f247225/tests%2Fui%2Fconst-generics%2Ftransmute-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftransmute-fail.rs?ref=648a35e3279f98783aaa0f78b71f5aee2f247225", "patch": "@@ -0,0 +1,34 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+fn foo<const W: usize, const H: usize>(v: [[u32;H+1]; W]) -> [[u32; W+1]; H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn bar<const W: bool, const H: usize>(v: [[u32; H]; W]) -> [[u32; W]; H] {\n+  //~^ ERROR mismatched types\n+  //~| ERROR mismatched types\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute between types\n+  }\n+}\n+\n+fn baz<const W: usize, const H: usize>(v: [[u32; H]; W]) -> [u32; W * H * H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn overflow(v: [[[u32; 8888888]; 9999999]; 777777777]) -> [[[u32; 9999999]; 777777777]; 8888888] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn main() {}"}, {"sha": "bf6a3b61dbb271b51391157755803e938964df83", "filename": "tests/ui/const-generics/transmute-fail.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/648a35e3279f98783aaa0f78b71f5aee2f247225/tests%2Fui%2Fconst-generics%2Ftransmute-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/648a35e3279f98783aaa0f78b71f5aee2f247225/tests%2Fui%2Fconst-generics%2Ftransmute-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftransmute-fail.stderr?ref=648a35e3279f98783aaa0f78b71f5aee2f247225", "patch": "@@ -0,0 +1,52 @@\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute-fail.rs:6:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[u32; H+1]; W]` (generic size)\n+   = note: target type: `[[u32; W+1]; H]` (generic size)\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute-fail.rs:15:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[u32; H]; W]` (this type does not have a fixed size)\n+   = note: target type: `[[u32; W]; H]` (size can vary because of [u32; W])\n+\n+error[E0308]: mismatched types\n+  --> $DIR/transmute-fail.rs:11:53\n+   |\n+LL | fn bar<const W: bool, const H: usize>(v: [[u32; H]; W]) -> [[u32; W]; H] {\n+   |                                                     ^ expected `usize`, found `bool`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/transmute-fail.rs:11:67\n+   |\n+LL | fn bar<const W: bool, const H: usize>(v: [[u32; H]; W]) -> [[u32; W]; H] {\n+   |                                                                   ^ expected `usize`, found `bool`\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute-fail.rs:22:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[u32; H]; W]` (generic size)\n+   = note: target type: `[u32; W * H * H]` (generic size)\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute-fail.rs:29:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[[u32; 8888888]; 9999999]; 777777777]` (values of the type `[[[u32; 8888888]; 9999999]; 777777777]` are too big for the current architecture)\n+   = note: target type: `[[[u32; 9999999]; 777777777]; 8888888]` (values of the type `[[[u32; 9999999]; 777777777]; 8888888]` are too big for the current architecture)\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0308, E0512.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "9571b9157049eff4d80871e2a70dc2fce726bdf4", "filename": "tests/ui/const-generics/transmute.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/648a35e3279f98783aaa0f78b71f5aee2f247225/tests%2Fui%2Fconst-generics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/648a35e3279f98783aaa0f78b71f5aee2f247225/tests%2Fui%2Fconst-generics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftransmute.rs?ref=648a35e3279f98783aaa0f78b71f5aee2f247225", "patch": "@@ -0,0 +1,82 @@\n+// run-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+fn transpose<const W: usize, const H: usize>(v: [[u32;H]; W]) -> [[u32; W]; H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn ident<const W: usize, const H: usize>(v: [[u32; H]; W]) -> [[u32; H]; W] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn flatten<const W: usize, const H: usize>(v: [[u32; H]; W]) -> [u32; W * H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn coagulate<const W: usize, const H: usize>(v: [u32; H*W]) -> [[u32; W];H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn flatten_3d<const W: usize, const H: usize, const D: usize>(\n+  v: [[[u32; D]; H]; W]\n+) -> [u32; D * W * H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn flatten_somewhat<const W: usize, const H: usize, const D: usize>(\n+  v: [[[u32; D]; H]; W]\n+) -> [[u32; D * W]; H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn known_size<const L: usize>(v: [u16; L]) -> [u8; L * 2] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn condense_bytes<const L: usize>(v: [u8; L * 2]) -> [u16; L] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn singleton_each<const L: usize>(v: [u8; L]) -> [[u8;1]; L] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn transpose_with_const<const W: usize, const H: usize>(\n+  v: [[u32; 2 * H]; W + W]\n+) -> [[u32; W + W]; 2 * H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn main() {\n+  let _ = transpose([[0; 8]; 16]);\n+  let _ = transpose_with_const::<8,4>([[0; 8]; 16]);\n+  let _ = ident([[0; 8]; 16]);\n+  let _ = flatten([[0; 13]; 5]);\n+  let _: [[_; 5]; 13] = coagulate([0; 65]);\n+  let _ = flatten_3d([[[0; 3]; 13]; 5]);\n+  let _ = flatten_somewhat([[[0; 3]; 13]; 5]);\n+  let _ = known_size([16; 13]);\n+  let _: [u16; 5] = condense_bytes([16u8; 10]);\n+  let _ = singleton_each([16; 10]);\n+}"}]}