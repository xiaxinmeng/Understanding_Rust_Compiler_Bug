{"sha": "e9fd063edb4f6783fbd91a82a0f61626dacf8dad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZmQwNjNlZGI0ZjY3ODNmYmQ5MWE4MmEwZjYxNjI2ZGFjZjhkYWQ=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-05-31T16:23:42Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-06-11T20:47:28Z"}, "message": "Document memory allocation APIs\n\nAdd some docs where they were missing,\nattempt to fix them where they were out of date.", "tree": {"sha": "aa482195798794cd021da59d3b556b366262e632", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa482195798794cd021da59d3b556b366262e632"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9fd063edb4f6783fbd91a82a0f61626dacf8dad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9fd063edb4f6783fbd91a82a0f61626dacf8dad", "html_url": "https://github.com/rust-lang/rust/commit/e9fd063edb4f6783fbd91a82a0f61626dacf8dad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9fd063edb4f6783fbd91a82a0f61626dacf8dad/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0081d8826b00f4eaf217d4d68d54e715bd98dcb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0081d8826b00f4eaf217d4d68d54e715bd98dcb9", "html_url": "https://github.com/rust-lang/rust/commit/0081d8826b00f4eaf217d4d68d54e715bd98dcb9"}], "stats": {"total": 295, "additions": 245, "deletions": 50}, "files": [{"sha": "c9430a29e4cd5f217ee8984f7d4ca674d0c01987", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e9fd063edb4f6783fbd91a82a0f61626dacf8dad/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9fd063edb4f6783fbd91a82a0f61626dacf8dad/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=e9fd063edb4f6783fbd91a82a0f61626dacf8dad", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Memory allocation APIs\n+\n #![unstable(feature = \"allocator_api\",\n             reason = \"the precise API and guarantees it provides may be tweaked \\\n                       slightly, especially to possibly take into account the \\\n@@ -37,27 +39,80 @@ extern \"Rust\" {\n     fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n }\n \n+/// The global memory allocator.\n+///\n+/// This type implements the [`Alloc`] trait by forwarding calls\n+/// to the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;\n \n+/// Allocate memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::alloc`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `alloc` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::alloc`].\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[inline]\n pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n     __rust_alloc(layout.size(), layout.align())\n }\n \n+/// Deallocate memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::dealloc`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `dealloc` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::dealloc`].\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[inline]\n pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n     __rust_dealloc(ptr, layout.size(), layout.align())\n }\n \n+/// Reallocate memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::realloc`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `realloc` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::realloc`].\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[inline]\n pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n     __rust_realloc(ptr, layout.size(), layout.align(), new_size)\n }\n \n+/// Allocate zero-initialized memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::alloc_zeroed`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `alloc_zeroed` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::alloc_zeroed`].\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[inline]\n pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n@@ -123,6 +178,16 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n     }\n }\n \n+/// Abort on memory allocation error or failure.\n+///\n+/// Callers of memory allocation APIs wishing to abort computation\n+/// in response to an allocation error are encouraged to call this function,\n+/// rather than directly invoking `panic!` or similar.\n+///\n+/// The default behavior of this function is to print a message to standard error\n+/// and abort the process.\n+/// It can be replaced with [`std::alloc::set_oom_hook`]\n+/// and [`std::alloc::take_oom_hook`].\n #[rustc_allocator_nounwind]\n pub fn oom(layout: Layout) -> ! {\n     #[allow(improper_ctypes)]"}, {"sha": "85bf43a54297d42b9ff5ecaab352555bf0919c9b", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9fd063edb4f6783fbd91a82a0f61626dacf8dad/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9fd063edb4f6783fbd91a82a0f61626dacf8dad/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=e9fd063edb4f6783fbd91a82a0f61626dacf8dad", "patch": "@@ -44,6 +44,7 @@ const MIN_ALIGN: usize = 16;\n use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout};\n use core::ptr::NonNull;\n \n+/// The default memory allocator provided by the operating system.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub struct System;\n "}, {"sha": "8fcd8555cdcfbc2165146f75022b605b642114cf", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 178, "deletions": 49, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/e9fd063edb4f6783fbd91a82a0f61626dacf8dad/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9fd063edb4f6783fbd91a82a0f61626dacf8dad/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=e9fd063edb4f6783fbd91a82a0f61626dacf8dad", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Memory allocation APIs\n+\n #![unstable(feature = \"allocator_api\",\n             reason = \"the precise API and guarantees it provides may be tweaked \\\n                       slightly, especially to possibly take into account the \\\n@@ -315,8 +317,9 @@ impl Layout {\n     }\n }\n \n-/// The parameters given to `Layout::from_size_align` do not satisfy\n-/// its documented constraints.\n+/// The parameters given to `Layout::from_size_align`\n+/// or some other `Layout` constructor\n+/// do not satisfy its documented constraints.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct LayoutErr {\n     private: ()\n@@ -329,8 +332,8 @@ impl fmt::Display for LayoutErr {\n     }\n }\n \n-/// The `AllocErr` error specifies whether an allocation failure is\n-/// specifically due to resource exhaustion or if it is due to\n+/// The `AllocErr` error indicates an allocation failure\n+/// that may be due to resource exhaustion or to\n /// something wrong when combining the given input arguments with this\n /// allocator.\n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -346,6 +349,7 @@ impl fmt::Display for AllocErr {\n /// The `CannotReallocInPlace` error is used when `grow_in_place` or\n /// `shrink_in_place` were unable to reuse the given memory block for\n /// a requested layout.\n+// FIXME: should this be in libcore or liballoc?\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct CannotReallocInPlace;\n \n@@ -363,6 +367,7 @@ impl fmt::Display for CannotReallocInPlace {\n }\n \n /// Augments `AllocErr` with a CapacityOverflow variant.\n+// FIXME: should this be in libcore or liballoc?\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n pub enum CollectionAllocErr {\n@@ -389,27 +394,125 @@ impl From<LayoutErr> for CollectionAllocErr {\n     }\n }\n \n-/// A memory allocator that can be registered to be the one backing `std::alloc::Global`\n+/// A memory allocator that can be registered as the standard library\u2019s default\n /// though the `#[global_allocator]` attributes.\n+///\n+/// Some of the methods require that a memory block be *currently\n+/// allocated* via an allocator. This means that:\n+///\n+/// * the starting address for that memory block was previously\n+///   returned by a previous call to an allocation method\n+///   such as `alloc`, and\n+///\n+/// * the memory block has not been subsequently deallocated, where\n+///   blocks are deallocated either by being passed to a deallocation\n+///   method such as `dealloc` or by being\n+///   passed to a reallocation method that returns a non-null pointer.\n+///\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// use std::alloc::{GlobalAlloc, Layout, alloc};\n+/// use std::ptr::null_mut;\n+///\n+/// struct MyAllocator;\n+///\n+/// unsafe impl GlobalAlloc for MyAllocator {\n+///     unsafe fn alloc(&self, _layout: Layout) -> *mut u8 { null_mut() }\n+///     unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n+/// }\n+///\n+/// #[global_allocator]\n+/// static A: MyAllocator = MyAllocator;\n+///\n+/// fn main() {\n+///     unsafe {\n+///         assert!(alloc(Layout::new::<u32>()).is_null())\n+///     }\n+/// }\n+/// ```\n+///\n+/// # Unsafety\n+///\n+/// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n+/// implementors must ensure that they adhere to these contracts:\n+///\n+/// * Pointers returned from allocation functions must point to valid memory and\n+///   retain their validity until at least the instance of `GlobalAlloc` is dropped\n+///   itself.\n+///\n+/// * It's undefined behavior if global allocators unwind.  This restriction may\n+///   be lifted in the future, but currently a panic from any of these\n+///   functions may lead to memory unsafety.\n+///\n+/// * `Layout` queries and calculations in general must be correct. Callers of\n+///   this trait are allowed to rely on the contracts defined on each method,\n+///   and implementors must ensure such contracts remain true.\n pub unsafe trait GlobalAlloc {\n     /// Allocate memory as described by the given `layout`.\n     ///\n     /// Returns a pointer to newly-allocated memory,\n-    /// or NULL to indicate allocation failure.\n+    /// or null to indicate allocation failure.\n     ///\n     /// # Safety\n     ///\n-    /// **FIXME:** what are the exact requirements?\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure that `layout` has non-zero size.\n+    ///\n+    /// (Extension subtraits might provide more specific bounds on\n+    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// in response to a zero-size allocation request.)\n+    ///\n+    /// The allocated block of memory may or may not be initialized.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning a null pointer indicates that either memory is exhausted\n+    /// or `layout` does not meet allocator's size or alignment constraints.\n+    ///\n+    /// Implementations are encouraged to return null on memory\n+    /// exhaustion rather than aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8;\n \n     /// Deallocate the block of memory at the given `ptr` pointer with the given `layout`.\n     ///\n     /// # Safety\n     ///\n-    /// **FIXME:** what are the exact requirements?\n-    /// In particular around layout *fit*. (See docs for the `Alloc` trait.)\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must denote a block of memory currently allocated via\n+    ///   this allocator,\n+    ///\n+    /// * `layout` must be the same layout that was used\n+    ///   to allocated that block of memory,\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);\n \n+    /// Behaves like `alloc`, but also ensures that the contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    /// However the allocated block of memory is guaranteed to be initialized.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning a null pointer indicates that either memory is exhausted\n+    /// or `layout` does not meet allocator's size or alignment constraints,\n+    /// just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n         let size = layout.size();\n         let ptr = self.alloc(layout);\n@@ -422,19 +525,51 @@ pub unsafe trait GlobalAlloc {\n     /// Shink or grow a block of memory to the given `new_size`.\n     /// The block is described by the given `ptr` pointer and `layout`.\n     ///\n-    /// Return a new pointer (which may or may not be the same as `ptr`),\n-    /// or NULL to indicate reallocation failure.\n+    /// If this returns a non-null pointer, then ownership of the memory block\n+    /// referenced by `ptr` has been transferred to this alloctor.\n+    /// The memory may or may not have been deallocated,\n+    /// and should be considered unusable (unless of course it was\n+    /// transferred back to the caller again via the return value of\n+    /// this method).\n     ///\n-    /// If reallocation is successful, the old `ptr` pointer is considered\n-    /// to have been deallocated.\n+    /// If this method returns null, then ownership of the memory\n+    /// block has not been transferred to this allocator, and the\n+    /// contents of the memory block are unaltered.\n     ///\n     /// # Safety\n     ///\n-    /// `new_size`, when rounded up to the nearest multiple of `old_layout.align()`,\n-    /// must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must be currently allocated via this allocator,\n+    ///\n+    /// * `layout` must be the same layout that was used\n+    ///   to allocated that block of memory,\n+    ///\n+    /// * `new_size` must be greater than zero.\n+    ///\n+    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n+    ///   must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n+    ///\n+    /// (Extension subtraits might provide more specific bounds on\n+    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// in response to a zero-size allocation request.)\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns null if the new layout does not meet the size\n+    /// and alignment constraints of the allocator, or if reallocation\n+    /// otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return null on memory\n+    /// exhaustion rather than panicking or aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n     ///\n-    /// **FIXME:** what are the exact requirements?\n-    /// In particular around layout *fit*. (See docs for the `Alloc` trait.)\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let new_ptr = self.alloc(new_layout);\n@@ -523,27 +658,21 @@ pub unsafe trait GlobalAlloc {\n ///   retain their validity until at least the instance of `Alloc` is dropped\n ///   itself.\n ///\n-/// * It's undefined behavior if global allocators unwind.  This restriction may\n-///   be lifted in the future, but currently a panic from any of these\n-///   functions may lead to memory unsafety. Note that as of the time of this\n-///   writing allocators *not* intending to be global allocators can still panic\n-///   in their implementation without violating memory safety.\n-///\n /// * `Layout` queries and calculations in general must be correct. Callers of\n ///   this trait are allowed to rely on the contracts defined on each method,\n ///   and implementors must ensure such contracts remain true.\n ///\n /// Note that this list may get tweaked over time as clarifications are made in\n-/// the future. Additionally global allocators may gain unique requirements for\n-/// how to safely implement one in the future as well.\n+/// the future.\n pub unsafe trait Alloc {\n \n-    // (Note: existing allocators have unspecified but well-defined\n+    // (Note: some existing allocators have unspecified but well-defined\n     // behavior in response to a zero size allocation request ;\n     // e.g. in C, `malloc` of 0 will either return a null pointer or a\n     // unique pointer, but will not have arbitrary undefined\n-    // behavior. Rust should consider revising the alloc::heap crate\n-    // to reflect this reality.)\n+    // behavior.\n+    // However in jemalloc for example,\n+    // `mallocx(0)` is documented as undefined behavior.)\n \n     /// Returns a pointer meeting the size and alignment guarantees of\n     /// `layout`.\n@@ -579,8 +708,8 @@ pub unsafe trait Alloc {\n     /// library that aborts on memory exhaustion.)\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// allocation error are encouraged to call the `oom` function,\n+    /// rather than directly invoking `panic!` or similar.\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>;\n \n     /// Deallocate the memory referenced by `ptr`.\n@@ -686,9 +815,9 @@ pub unsafe trait Alloc {\n     /// implement this trait atop an underlying native allocation\n     /// library that aborts on memory exhaustion.)\n     ///\n-    /// Clients wishing to abort computation in response to an\n-    /// reallocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n     unsafe fn realloc(&mut self,\n                       ptr: NonNull<u8>,\n                       layout: Layout,\n@@ -731,8 +860,8 @@ pub unsafe trait Alloc {\n     /// constraints, just as in `alloc`.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n     unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         let size = layout.size();\n         let p = self.alloc(layout);\n@@ -757,8 +886,8 @@ pub unsafe trait Alloc {\n     /// constraints, just as in `alloc`.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n     unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n         let usable_size = self.usable_size(&layout);\n         self.alloc(layout).map(|p| Excess(p, usable_size.1))\n@@ -778,9 +907,9 @@ pub unsafe trait Alloc {\n     /// `layout` does not meet allocator's size or alignment\n     /// constraints, just as in `realloc`.\n     ///\n-    /// Clients wishing to abort computation in response to an\n-    /// reallocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n     unsafe fn realloc_excess(&mut self,\n                              ptr: NonNull<u8>,\n                              layout: Layout,\n@@ -823,7 +952,7 @@ pub unsafe trait Alloc {\n     /// could fit `layout`.\n     ///\n     /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n-    /// method; clients are expected either to be able to recover from\n+    /// function; clients are expected either to be able to recover from\n     /// `grow_in_place` failures without aborting, or to fall back on\n     /// another reallocation method before resorting to an abort.\n     unsafe fn grow_in_place(&mut self,\n@@ -878,7 +1007,7 @@ pub unsafe trait Alloc {\n     /// could fit `layout`.\n     ///\n     /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n-    /// method; clients are expected either to be able to recover from\n+    /// function; clients are expected either to be able to recover from\n     /// `shrink_in_place` failures without aborting, or to fall back\n     /// on another reallocation method before resorting to an abort.\n     unsafe fn shrink_in_place(&mut self,\n@@ -926,8 +1055,8 @@ pub unsafe trait Alloc {\n     /// will *not* yield undefined behavior.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n     fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>\n         where Self: Sized\n     {\n@@ -993,8 +1122,8 @@ pub unsafe trait Alloc {\n     /// Always returns `Err` on arithmetic overflow.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n     fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>\n         where Self: Sized\n     {\n@@ -1037,9 +1166,9 @@ pub unsafe trait Alloc {\n     ///\n     /// Always returns `Err` on arithmetic overflow.\n     ///\n-    /// Clients wishing to abort computation in response to an\n-    /// reallocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n     unsafe fn realloc_array<T>(&mut self,\n                                ptr: NonNull<T>,\n                                n_old: usize,"}, {"sha": "9126155a7c9aa7a171cdb96e46e440e6a345c835", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9fd063edb4f6783fbd91a82a0f61626dacf8dad/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9fd063edb4f6783fbd91a82a0f61626dacf8dad/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=e9fd063edb4f6783fbd91a82a0f61626dacf8dad", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! dox\n+//! Memory allocation APIs\n \n #![unstable(issue = \"32838\", feature = \"allocator_api\")]\n "}]}