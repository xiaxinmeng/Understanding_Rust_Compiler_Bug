{"sha": "a5e7a61c490ce619010f585006880b84f3174cd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZTdhNjFjNDkwY2U2MTkwMTBmNTg1MDA2ODgwYjg0ZjMxNzRjZDQ=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-11-16T17:57:57Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-12-15T10:25:05Z"}, "message": "Implement references to functions and constants", "tree": {"sha": "522f8e5615dbf8a756230407290b1f38b06895b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/522f8e5615dbf8a756230407290b1f38b06895b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5e7a61c490ce619010f585006880b84f3174cd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5e7a61c490ce619010f585006880b84f3174cd4", "html_url": "https://github.com/rust-lang/rust/commit/a5e7a61c490ce619010f585006880b84f3174cd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5e7a61c490ce619010f585006880b84f3174cd4/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59e6b20cf2c504dee56e20665bf71fb2d9f0030c", "url": "https://api.github.com/repos/rust-lang/rust/commits/59e6b20cf2c504dee56e20665bf71fb2d9f0030c", "html_url": "https://github.com/rust-lang/rust/commit/59e6b20cf2c504dee56e20665bf71fb2d9f0030c"}], "stats": {"total": 411, "additions": 395, "deletions": 16}, "files": [{"sha": "e83fe60f419a6dcb928df5d9a59ca7302e35658e", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -698,10 +698,20 @@ pub struct Constant<'tcx> {\n     pub literal: Literal<'tcx>,\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+pub enum ItemKind {\n+    Constant,\n+    Function,\n+    Struct,\n+    Variant,\n+    Method,\n+}\n+\n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Item {\n         def_id: DefId,\n+        kind: ItemKind,\n         substs: &'tcx Substs<'tcx>,\n     },\n     Value {"}, {"sha": "5d040bcb40ad8e72c2a1e111e47923df09e05d99", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -66,6 +66,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                             -> Operand<'tcx> {\n         let literal = Literal::Item {\n             def_id: item_ref.def_id,\n+            kind: item_ref.kind,\n             substs: item_ref.substs,\n         };\n         self.literal_operand(span, item_ref.ty, literal)"}, {"sha": "d1455e7016524117b4a0fe86831890602d543686", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -480,6 +480,7 @@ fn method_callee<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n         kind: ExprKind::Literal {\n             literal: Literal::Item {\n                 def_id: callee.def_id,\n+                kind: ItemKind::Method,\n                 substs: callee.substs,\n             },\n         },\n@@ -520,18 +521,29 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n         def::DefVariant(_, def_id, false) |\n         def::DefStruct(def_id) |\n         def::DefFn(def_id, _) |\n-        def::DefMethod(def_id) =>\n+        def::DefMethod(def_id) => {\n+            let kind = match def {\n+                def::DefVariant(..) => ItemKind::Variant,\n+                def::DefStruct(..) => ItemKind::Struct,\n+                def::DefFn(..) => ItemKind::Function,\n+                def::DefMethod(..) => ItemKind::Method,\n+                _ => panic!()\n+            };\n             ExprKind::Literal {\n-                literal: Literal::Item { def_id: def_id, substs: substs }\n-            },\n-\n+                literal: Literal::Item { def_id: def_id, kind: kind, substs: substs }\n+            }\n+        },\n         def::DefConst(def_id) |\n         def::DefAssociatedConst(def_id) => {\n             if let Some(v) = cx.try_const_eval_literal(expr) {\n                 ExprKind::Literal { literal: v }\n             } else {\n                 ExprKind::Literal {\n-                    literal: Literal::Item { def_id: def_id, substs: substs }\n+                    literal: Literal::Item {\n+                        def_id: def_id,\n+                        kind: ItemKind::Constant,\n+                        substs: substs\n+                    }\n                 }\n             }\n         }"}, {"sha": "d6cfd1a2c6ecf532e4452c3b94299acf6a27c498", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -139,6 +139,7 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n                         let method_ty = method_ty.ty.subst(self.tcx, &substs);\n                         return ItemRef {\n                             ty: method_ty,\n+                            kind: ItemKind::Method,\n                             def_id: method.def_id,\n                             substs: self.tcx.mk_substs(substs),\n                         };"}, {"sha": "c32efcd1a7dab03c322bae69896453e42678c86b", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -97,7 +97,11 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                                     Literal::Value { value: value }\n                                 } else {\n                                     let substs = self.cx.tcx.mk_substs(Substs::empty());\n-                                    Literal::Item { def_id: def_id, substs: substs }\n+                                    Literal::Item {\n+                                        def_id: def_id,\n+                                        kind: ItemKind::Constant,\n+                                        substs: substs\n+                                    }\n                                 };\n                                 PatternKind::Constant { value: literal }\n                             }"}, {"sha": "99e6d6633f2889c767839c57491b86f5b92f21ed", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -14,7 +14,7 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp};\n+use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp, ItemKind};\n use rustc::middle::def_id::DefId;\n use rustc::middle::region::CodeExtent;\n use rustc::middle::subst::Substs;\n@@ -29,6 +29,7 @@ pub mod cx;\n #[derive(Clone, Debug)]\n pub struct ItemRef<'tcx> {\n     pub ty: Ty<'tcx>,\n+    pub kind: ItemKind,\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n }"}, {"sha": "9c10721cf8b16b567b0ed6a987bb1a4e732d01bb", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -473,7 +473,7 @@ fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n ///\n /// In fact, all virtual calls can be thought of as normal trait calls\n /// that go through this shim function.\n-fn trans_object_shim<'a, 'tcx>(\n+pub fn trans_object_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n     method_id: DefId,"}, {"sha": "cbcc1c3c47db901f8c18c4d08d3c3ed7e72ddac8", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -14,7 +14,8 @@ use rustc::mir::repr as mir;\n use trans::consts;\n use trans::common::{self, Block};\n \n-use super::operand::OperandRef;\n+\n+use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n@@ -24,8 +25,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           ty: Ty<'tcx>)\n                           -> OperandRef<'tcx>\n     {\n-        use super::operand::OperandValue::{Ref, Immediate};\n-\n         let ccx = bcx.ccx();\n         let val = consts::trans_constval(ccx, cv, ty, bcx.fcx.param_substs);\n         let val = if common::type_is_immediate(ccx, ty) {\n@@ -47,13 +46,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           constant: &mir::Constant<'tcx>)\n                           -> OperandRef<'tcx>\n     {\n-        let constant_ty = bcx.monomorphize(&constant.ty);\n+        let ty = bcx.monomorphize(&constant.ty);\n         match constant.literal {\n-            mir::Literal::Item { .. } => {\n-                unimplemented!()\n-            }\n+            mir::Literal::Item { def_id, kind, substs } =>\n+                self.trans_item_ref(bcx, ty, kind, substs, def_id),\n             mir::Literal::Value { ref value } => {\n-                self.trans_constval(bcx, value, constant_ty)\n+                self.trans_constval(bcx, value, ty)\n             }\n         }\n     }"}, {"sha": "28a7ca3f72f49353905306c59a6a02f3f00fe2cb", "filename": "src/librustc_trans/trans/mir/did.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -0,0 +1,158 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code for translating references to other items (DefIds).\n+\n+use syntax::codemap::DUMMY_SP;\n+use rustc::front::map;\n+use rustc::middle::ty::{self, Ty, HasTypeFlags};\n+use rustc::middle::subst::Substs;\n+use rustc::middle::const_eval;\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::subst;\n+use rustc::middle::traits;\n+use rustc::mir::repr::ItemKind;\n+use trans::common::{Block, fulfill_obligation};\n+use trans::base;\n+use trans::expr;\n+use trans::monomorphize;\n+use trans::meth;\n+use trans::inline;\n+\n+use super::MirContext;\n+use super::operand::{OperandRef, OperandValue};\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    /// Translate reference to item.\n+    pub fn trans_item_ref(&mut self,\n+                          bcx: Block<'bcx, 'tcx>,\n+                          ty: Ty<'tcx>,\n+                          kind: ItemKind,\n+                          substs: &'tcx Substs<'tcx>,\n+                          did: DefId)\n+                          -> OperandRef<'tcx> {\n+        match kind {\n+            ItemKind::Function |\n+            ItemKind::Struct |\n+            ItemKind::Variant => self.trans_fn_ref(bcx, ty, substs, did),\n+            ItemKind::Method => match bcx.tcx().impl_or_trait_item(did).container() {\n+                ty::ImplContainer(_) => self.trans_fn_ref(bcx, ty, substs, did),\n+                ty::TraitContainer(tdid) => self.trans_static_method(bcx, ty, did, tdid, substs)\n+            },\n+            ItemKind::Constant => {\n+                let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n+                let expr = const_eval::lookup_const_by_id(bcx.tcx(), did, None)\n+                            .expect(\"def was const, but lookup_const_by_id failed\");\n+                let d = expr::trans(bcx, expr);\n+                OperandRef::from_rvalue_datum(d.datum.to_rvalue_datum(d.bcx, \"\").datum)\n+            }\n+        }\n+    }\n+\n+    /// Translates references to a function-like items.\n+    ///\n+    /// That includes regular functions, non-static methods, struct and enum variant constructors,\n+    /// closures and possibly more.\n+    ///\n+    /// This is an adaptation of callee::trans_fn_ref_with_substs.\n+    pub fn trans_fn_ref(&mut self,\n+                        bcx: Block<'bcx, 'tcx>,\n+                        ty: Ty<'tcx>,\n+                        substs: &'tcx Substs<'tcx>,\n+                        did: DefId)\n+                        -> OperandRef<'tcx> {\n+        let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n+\n+        if !substs.types.is_empty() || is_named_tuple_constructor(bcx.tcx(), did) {\n+            let (val, fn_ty, _) = monomorphize::monomorphic_fn(bcx.ccx(), did, substs, None);\n+            // FIXME: cast fnptr to proper type if necessary\n+            OperandRef {\n+                ty: fn_ty,\n+                val: OperandValue::Immediate(val)\n+            }\n+        } else {\n+            let val = if let Some(node_id) = bcx.tcx().map.as_local_node_id(did) {\n+                base::get_item_val(bcx.ccx(), node_id)\n+            } else {\n+                base::trans_external_path(bcx.ccx(), did, ty)\n+            };\n+            // FIXME: cast fnptr to proper type if necessary\n+            OperandRef {\n+                ty: ty,\n+                val: OperandValue::Immediate(val)\n+            }\n+        }\n+    }\n+\n+    /// Translates references to static methods.\n+    ///\n+    /// This is an adaptation of meth::trans_static_method_callee\n+    pub fn trans_static_method(&mut self,\n+                               bcx: Block<'bcx, 'tcx>,\n+                               ty: Ty<'tcx>,\n+                               method_id: DefId,\n+                               trait_id: DefId,\n+                               substs: &'tcx Substs<'tcx>)\n+                               -> OperandRef<'tcx> {\n+        let ccx = bcx.ccx();\n+        let tcx = bcx.tcx();\n+        let mname = tcx.item_name(method_id);\n+        let subst::SeparateVecsPerParamSpace {\n+            types: rcvr_type,\n+            selfs: rcvr_self,\n+            fns: rcvr_method\n+        } = substs.clone().types.split();\n+        let trait_substs = Substs::erased(\n+            subst::VecPerParamSpace::new(rcvr_type, rcvr_self, Vec::new())\n+        );\n+        let trait_substs = tcx.mk_substs(trait_substs);\n+        let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, trait_substs));\n+        let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+        match vtbl {\n+            traits::VtableImpl(traits::VtableImplData { impl_def_id, substs: imp_substs, .. }) => {\n+                assert!(!imp_substs.types.needs_infer());\n+                let subst::SeparateVecsPerParamSpace {\n+                    types: impl_type,\n+                    selfs: impl_self,\n+                    fns: _\n+                } = imp_substs.types.split();\n+                let callee_substs = Substs::erased(\n+                    subst::VecPerParamSpace::new(impl_type, impl_self, rcvr_method)\n+                );\n+                let mth = tcx.get_impl_method(impl_def_id, callee_substs, mname);\n+                let mthsubsts = tcx.mk_substs(mth.substs);\n+                self.trans_fn_ref(bcx, ty, mthsubsts, mth.method.def_id)\n+            },\n+            traits::VtableObject(ref data) => {\n+                let idx = traits::get_vtable_index_of_object_method(tcx, data, method_id);\n+                OperandRef::from_rvalue_datum(\n+                    meth::trans_object_shim(ccx, data.upcast_trait_ref.clone(), method_id, idx)\n+                )\n+            }\n+            _ => {\n+                tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\", vtbl));\n+            }\n+        }\n+   }\n+}\n+\n+fn is_named_tuple_constructor(tcx: &ty::ctxt, def_id: DefId) -> bool {\n+    let node_id = match tcx.map.as_local_node_id(def_id) {\n+        Some(n) => n,\n+        None => { return false; }\n+    };\n+    match tcx.map.find(node_id).expect(\"local item should be in ast map\") {\n+        map::NodeVariant(v) => {\n+            v.node.data.is_tuple()\n+        }\n+        map::NodeStructCtor(_) => true,\n+        _ => false\n+    }\n+}"}, {"sha": "0ed76ebeb4362aabde20923530a8111e42260ae6", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -192,3 +192,4 @@ mod lvalue;\n mod rvalue;\n mod operand;\n mod statement;\n+mod did;"}, {"sha": "3a3087b478852166f4a121a033ea05af45b07a12", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -76,6 +76,16 @@ impl<'tcx> OperandRef<'tcx> {\n             }\n         }\n     }\n+\n+    pub fn from_rvalue_datum(datum: datum::Datum<'tcx, datum::Rvalue>) -> OperandRef {\n+        OperandRef {\n+            ty: datum.ty,\n+            val: match datum.kind.mode {\n+                datum::RvalueMode::ByRef => OperandValue::Ref(datum.val),\n+                datum::RvalueMode::ByValue => OperandValue::Immediate(datum.val),\n+            }\n+        }\n+    }\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {"}, {"sha": "4cad98004d7e46563064ac716a2020289261461c", "filename": "src/test/auxiliary/mir_external_refs.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Ftest%2Fauxiliary%2Fmir_external_refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Ftest%2Fauxiliary%2Fmir_external_refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmir_external_refs.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub struct S(pub u8);\n+\n+impl S {\n+    pub fn hey() -> u8 { 24 }\n+}\n+\n+pub trait X {\n+    fn hoy(&self) -> u8 { 25 }\n+}\n+\n+impl X for S {}\n+\n+pub enum E {\n+    U(u8)\n+}\n+\n+pub fn regular_fn() -> u8 { 12 }"}, {"sha": "32aea5c5e3c8909e05fba3bc4d93efde0d7e7bac", "filename": "src/test/run-pass/mir_refs_correct.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7a61c490ce619010f585006880b84f3174cd4/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs?ref=a5e7a61c490ce619010f585006880b84f3174cd4", "patch": "@@ -0,0 +1,155 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+// aux-build:mir_external_refs.rs\n+\n+\n+extern crate mir_external_refs as ext;\n+\n+struct S(u8);\n+\n+impl S {\n+    fn hey() -> u8 { 42 }\n+    fn hey2(&self) -> u8 { 44 }\n+}\n+\n+trait X {\n+    fn hoy(&self) -> u8 { 43 }\n+    fn hoy2() -> u8 { 45 }\n+}\n+\n+impl X for S {}\n+\n+enum E {\n+    U(u8)\n+}\n+\n+const C: u8 = 84;\n+const C2: [u8; 5] = [42; 5];\n+\n+fn regular() -> u8 {\n+    21\n+}\n+\n+fn parametric<T>(u: T) -> T {\n+    u\n+}\n+\n+#[rustc_mir]\n+fn t1() -> fn()->u8 {\n+    regular\n+}\n+\n+#[rustc_mir]\n+fn t2() -> fn(u8)->E {\n+    E::U\n+}\n+\n+#[rustc_mir]\n+fn t3() -> fn(u8)->S {\n+    S\n+}\n+\n+#[rustc_mir]\n+fn t4() -> fn()->u8 {\n+    S::hey\n+}\n+\n+#[rustc_mir]\n+fn t5() -> fn(&S)-> u8 {\n+    <S as X>::hoy\n+}\n+\n+\n+#[rustc_mir]\n+fn t6() -> fn()->u8{\n+    ext::regular_fn\n+}\n+\n+#[rustc_mir]\n+fn t7() -> fn(u8)->ext::E {\n+    ext::E::U\n+}\n+\n+#[rustc_mir]\n+fn t8() -> fn(u8)->ext::S {\n+    ext::S\n+}\n+\n+#[rustc_mir]\n+fn t9() -> fn()->u8 {\n+    ext::S::hey\n+}\n+\n+#[rustc_mir]\n+fn t10() -> fn(&ext::S)->u8 {\n+    <ext::S as ext::X>::hoy\n+}\n+\n+#[rustc_mir]\n+fn t11() -> fn(u8)->u8 {\n+    parametric\n+}\n+\n+#[rustc_mir]\n+fn t12() -> u8 {\n+    C\n+}\n+\n+#[rustc_mir]\n+fn t13() -> [u8; 5] {\n+    C2\n+}\n+\n+#[rustc_mir]\n+fn t14() -> fn()-> u8 {\n+    <S as X>::hoy2\n+}\n+\n+#[rustc_mir]\n+fn t15() -> fn(&S)-> u8 {\n+    S::hey2\n+}\n+\n+fn main(){\n+    unsafe {\n+        assert_eq!(t1()(), regular());\n+\n+        assert!(::std::mem::transmute::<_, *mut ()>(t2()) ==\n+                ::std::mem::transmute::<_, *mut ()>(E::U));\n+        assert!(::std::mem::transmute::<_, *mut ()>(t3()) ==\n+                ::std::mem::transmute::<_, *mut ()>(S));\n+\n+        assert_eq!(t4()(), S::hey());\n+        let s = S(42);\n+        assert_eq!(t5()(&s), <S as X>::hoy(&s));\n+\n+\n+        assert_eq!(t6()(), ext::regular_fn());\n+        assert!(::std::mem::transmute::<_, *mut ()>(t7()) ==\n+                ::std::mem::transmute::<_, *mut ()>(ext::E::U));\n+        assert!(::std::mem::transmute::<_, *mut ()>(t8()) ==\n+                ::std::mem::transmute::<_, *mut ()>(ext::S));\n+\n+        assert_eq!(t9()(), ext::S::hey());\n+        let sext = ext::S(6);\n+        assert_eq!(t10()(&sext), <ext::S as ext::X>::hoy(&sext));\n+\n+        let p = parametric::<u8>;\n+        assert!(::std::mem::transmute::<_, *mut ()>(t11()) ==\n+                ::std::mem::transmute::<_, *mut ()>(p));\n+\n+        assert_eq!(t12(), C);\n+        assert_eq!(t13(), C2);\n+\n+        assert_eq!(t14()(), <S as X>::hoy2());\n+        assert_eq!(t15()(&s), S::hey2(&s));\n+    }\n+}"}]}