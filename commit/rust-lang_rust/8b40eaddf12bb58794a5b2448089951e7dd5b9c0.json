{"sha": "8b40eaddf12bb58794a5b2448089951e7dd5b9c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNDBlYWRkZjEyYmI1ODc5NGE1YjI0NDgwODk5NTFlN2RkNWI5YzA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-23T09:32:58Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-26T04:15:27Z"}, "message": "Refactor `parse_expansion` out of `ResultAnyMacro`.", "tree": {"sha": "f834949e551075660905b7011a3db9ea9ee2bf00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f834949e551075660905b7011a3db9ea9ee2bf00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b40eaddf12bb58794a5b2448089951e7dd5b9c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b40eaddf12bb58794a5b2448089951e7dd5b9c0", "html_url": "https://github.com/rust-lang/rust/commit/8b40eaddf12bb58794a5b2448089951e7dd5b9c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b40eaddf12bb58794a5b2448089951e7dd5b9c0/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fc14c1a6f66c2d9300afd282210fe743878c9a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc14c1a6f66c2d9300afd282210fe743878c9a7", "html_url": "https://github.com/rust-lang/rust/commit/5fc14c1a6f66c2d9300afd282210fe743878c9a7"}], "stats": {"total": 155, "additions": 63, "deletions": 92}, "files": [{"sha": "d6874f60cde709c65a9c7cbf57b6101b0b9f3eb8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8b40eaddf12bb58794a5b2448089951e7dd5b9c0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b40eaddf12bb58794a5b2448089951e7dd5b9c0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8b40eaddf12bb58794a5b2448089951e7dd5b9c0", "patch": "@@ -21,9 +21,9 @@ use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::{ParseSess, lexer};\n+use parse::{ParseSess, PResult, lexer};\n use parse::parser::Parser;\n-use parse::token::{intern, keywords};\n+use parse::token::{self, intern, keywords};\n use print::pprust;\n use ptr::P;\n use tokenstream::{TokenTree, TokenStream};\n@@ -38,12 +38,12 @@ macro_rules! expansions {\n     ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n             $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n             $(.$visit:ident)*  $(lift .$visit_elt:ident)*;)*) => {\n-        #[derive(Copy, Clone)]\n+        #[derive(Copy, Clone, PartialEq, Eq)]\n         pub enum ExpansionKind { OptExpr, $( $kind, )*  }\n         pub enum Expansion { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n \n         impl ExpansionKind {\n-            fn name(self) -> &'static str {\n+            pub fn name(self) -> &'static str {\n                 match self {\n                     ExpansionKind::OptExpr => \"expression\",\n                     $( ExpansionKind::$kind => $kind_name, )*\n@@ -106,6 +106,12 @@ macro_rules! expansions {\n                 self.expand(Expansion::$kind(SmallVector::one(node))).$make()\n             })*)*\n         }\n+\n+        impl<'a> MacResult for ::ext::tt::macro_rules::ParserAnyMacro<'a> {\n+            $(fn $make(self: Box<::ext::tt::macro_rules::ParserAnyMacro<'a>>) -> Option<$ty> {\n+                Some(self.make(ExpansionKind::$kind).$make())\n+            })*\n+        }\n     }\n }\n \n@@ -450,6 +456,47 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n }\n \n+impl<'a> Parser<'a> {\n+    pub fn parse_expansion(&mut self, kind: ExpansionKind) -> PResult<'a, Expansion> {\n+        Ok(match kind {\n+            ExpansionKind::Items => {\n+                let mut items = SmallVector::zero();\n+                while let Some(item) = self.parse_item()? {\n+                    items.push(item);\n+                }\n+                Expansion::Items(items)\n+            }\n+            ExpansionKind::TraitItems => {\n+                let mut items = SmallVector::zero();\n+                while self.token != token::Eof {\n+                    items.push(self.parse_trait_item()?);\n+                }\n+                Expansion::TraitItems(items)\n+            }\n+            ExpansionKind::ImplItems => {\n+                let mut items = SmallVector::zero();\n+                while self.token != token::Eof {\n+                    items.push(self.parse_impl_item()?);\n+                }\n+                Expansion::ImplItems(items)\n+            }\n+            ExpansionKind::Stmts => {\n+                let mut stmts = SmallVector::zero();\n+                while self.token != token::Eof {\n+                    if let Some(stmt) = self.parse_full_stmt(true)? {\n+                        stmts.push(stmt);\n+                    }\n+                }\n+                Expansion::Stmts(stmts)\n+            }\n+            ExpansionKind::Expr => Expansion::Expr(self.parse_expr()?),\n+            ExpansionKind::OptExpr => Expansion::OptExpr(Some(self.parse_expr()?)),\n+            ExpansionKind::Ty => Expansion::Ty(self.parse_ty()?),\n+            ExpansionKind::Pat => Expansion::Pat(self.parse_pat()?),\n+        })\n+    }\n+}\n+\n struct InvocationCollector<'a, 'b: 'a> {\n     cx: &'a mut ExtCtxt<'b>,\n     cfg: StripUnconfigured<'a>,"}, {"sha": "8c95e7d31f79ccc163113da9a15f17d667ec8259", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 88, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/8b40eaddf12bb58794a5b2448089951e7dd5b9c0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b40eaddf12bb58794a5b2448089951e7dd5b9c0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=8b40eaddf12bb58794a5b2448089951e7dd5b9c0", "patch": "@@ -12,6 +12,7 @@ use {ast, attr};\n use syntax_pos::{Span, DUMMY_SP};\n use ext::base::{DummyResult, ExtCtxt, MacEager, MacResult, SyntaxExtension};\n use ext::base::{IdentMacroExpander, NormalTT, TTMacroExpander};\n+use ext::expand::{Expansion, ExpansionKind};\n use ext::placeholders;\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n@@ -22,18 +23,14 @@ use parse::parser::{Parser, Restrictions};\n use parse::token::{self, gensym_ident, NtTT, Token};\n use parse::token::Token::*;\n use print;\n-use ptr::P;\n use tokenstream::{self, TokenTree};\n \n-use util::small_vector::SmallVector;\n-\n-use std::cell::RefCell;\n use std::collections::{HashMap};\n use std::collections::hash_map::{Entry};\n use std::rc::Rc;\n \n-struct ParserAnyMacro<'a> {\n-    parser: RefCell<Parser<'a>>,\n+pub struct ParserAnyMacro<'a> {\n+    parser: Parser<'a>,\n \n     /// Span of the expansion site of the macro this parser is for\n     site_span: Span,\n@@ -48,8 +45,8 @@ impl<'a> ParserAnyMacro<'a> {\n     /// about e.g. the semicolon in `macro_rules! kapow { () => {\n     /// panic!(); } }` doesn't get picked up by .parse_expr(), but it's\n     /// allowed to be there.\n-    fn ensure_complete_parse(&self, allow_semi: bool, context: &str) {\n-        let mut parser = self.parser.borrow_mut();\n+    fn ensure_complete_parse(&mut self, allow_semi: bool, context: &str) {\n+        let ParserAnyMacro { site_span, macro_ident, ref mut parser } = *self;\n         parser.ensure_complete_parse(allow_semi, |parser| {\n             let token_str = parser.this_token_to_string();\n             let msg = format!(\"macro expansion ignores token `{}` and any \\\n@@ -59,89 +56,16 @@ impl<'a> ParserAnyMacro<'a> {\n             let mut err = parser.diagnostic().struct_span_err(span, &msg);\n             let msg = format!(\"caused by the macro expansion here; the usage \\\n                                of `{}!` is likely invalid in {} context\",\n-                               self.macro_ident, context);\n-            err.span_note(self.site_span, &msg)\n+                               macro_ident, context);\n+            err.span_note(site_span, &msg)\n                .emit();\n         });\n     }\n-}\n-\n-impl<'a> MacResult for ParserAnyMacro<'a> {\n-    fn make_expr(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Expr>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_expr());\n-        self.ensure_complete_parse(true, \"expression\");\n-        Some(ret)\n-    }\n-    fn make_pat(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Pat>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_pat());\n-        self.ensure_complete_parse(false, \"pattern\");\n-        Some(ret)\n-    }\n-    fn make_items(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Item>>> {\n-        let mut ret = SmallVector::zero();\n-        while let Some(item) = panictry!(self.parser.borrow_mut().parse_item()) {\n-            ret.push(item);\n-        }\n-        self.ensure_complete_parse(false, \"item\");\n-        Some(ret)\n-    }\n-\n-    fn make_impl_items(self: Box<ParserAnyMacro<'a>>)\n-                       -> Option<SmallVector<ast::ImplItem>> {\n-        let mut ret = SmallVector::zero();\n-        loop {\n-            let mut parser = self.parser.borrow_mut();\n-            match parser.token {\n-                token::Eof => break,\n-                _ => ret.push(panictry!(parser.parse_impl_item()))\n-            }\n-        }\n-        self.ensure_complete_parse(false, \"item\");\n-        Some(ret)\n-    }\n-\n-    fn make_trait_items(self: Box<ParserAnyMacro<'a>>)\n-                       -> Option<SmallVector<ast::TraitItem>> {\n-        let mut ret = SmallVector::zero();\n-        loop {\n-            let mut parser = self.parser.borrow_mut();\n-            match parser.token {\n-                token::Eof => break,\n-                _ => ret.push(panictry!(parser.parse_trait_item()))\n-            }\n-        }\n-        self.ensure_complete_parse(false, \"item\");\n-        Some(ret)\n-    }\n-\n-\n-    fn make_stmts(self: Box<ParserAnyMacro<'a>>)\n-                 -> Option<SmallVector<ast::Stmt>> {\n-        let mut ret = SmallVector::zero();\n-        loop {\n-            let mut parser = self.parser.borrow_mut();\n-            match parser.token {\n-                token::Eof => break,\n-                _ => match parser.parse_full_stmt(true) {\n-                    Ok(maybe_stmt) => match maybe_stmt {\n-                        Some(stmt) => ret.push(stmt),\n-                        None => (),\n-                    },\n-                    Err(mut e) => {\n-                        e.emit();\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-        self.ensure_complete_parse(false, \"statement\");\n-        Some(ret)\n-    }\n \n-    fn make_ty(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Ty>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_ty());\n-        self.ensure_complete_parse(false, \"type\");\n-        Some(ret)\n+    pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: ExpansionKind) -> Expansion {\n+        let expansion = panictry!(self.parser.parse_expansion(kind));\n+        self.ensure_complete_parse(kind == ExpansionKind::Expr, kind.name());\n+        expansion\n     }\n }\n \n@@ -219,7 +143,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return Box::new(ParserAnyMacro {\n-                    parser: RefCell::new(p),\n+                    parser: p,\n \n                     // Pass along the original expansion site and the name of the macro\n                     // so we can print a useful error message if the parse of the expanded"}]}