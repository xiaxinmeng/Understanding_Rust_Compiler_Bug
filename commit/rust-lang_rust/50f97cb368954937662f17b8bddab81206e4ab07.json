{"sha": "50f97cb368954937662f17b8bddab81206e4ab07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZjk3Y2IzNjg5NTQ5Mzc2NjJmMTdiOGJkZGFiODEyMDZlNGFiMDc=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-08-05T00:24:54Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-09T22:53:26Z"}, "message": "Port the stdlib to the ivec type [T] syntax.", "tree": {"sha": "12ac9a9d8d127e1ea8ecf563f3c29987ae70439c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12ac9a9d8d127e1ea8ecf563f3c29987ae70439c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50f97cb368954937662f17b8bddab81206e4ab07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50f97cb368954937662f17b8bddab81206e4ab07", "html_url": "https://github.com/rust-lang/rust/commit/50f97cb368954937662f17b8bddab81206e4ab07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50f97cb368954937662f17b8bddab81206e4ab07/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf84d20f7cfba43abb7c895f31b3da23c1fd4a9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf84d20f7cfba43abb7c895f31b3da23c1fd4a9a", "html_url": "https://github.com/rust-lang/rust/commit/bf84d20f7cfba43abb7c895f31b3da23c1fd4a9a"}], "stats": {"total": 334, "additions": 167, "deletions": 167}, "files": [{"sha": "81c6ddf80fb734dfb5ade670b1c10d89386907b6", "filename": "src/lib/aio.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -10,7 +10,7 @@ native \"rust\" mod rustrt {\n     fn aio_connect(host: sbuf, port: int, connected: chan[socket]);\n     fn aio_serve(host: sbuf, port: int, acceptChan: chan[socket]) -> server;\n     fn aio_writedata(s: socket, buf: *u8, size: uint, status: chan[bool]);\n-    fn aio_read(s: socket, reader: chan[u8[]]);\n+    fn aio_read(s: socket, reader: chan[[u8]]);\n     fn aio_close_server(s: server, status: chan[bool]);\n     fn aio_close_socket(s: socket);\n     fn aio_is_null_client(s: socket) -> bool;\n@@ -26,7 +26,7 @@ tag pending_connection {\n tag socket_event {\n     connected(client);\n     closed;\n-    received(u8[]);\n+    received([u8]);\n }\n \n tag server_event {\n@@ -37,7 +37,7 @@ tag request {\n     quit;\n     connect(pending_connection,chan[socket_event]);\n     serve(str,int,chan[server_event],chan[server]);\n-    write(client,u8[],chan[bool]);\n+    write(client,[u8],chan[bool]);\n     close_server(server, chan[bool]);\n     close_client(client);\n }\n@@ -56,14 +56,14 @@ fn new_client(client: client, evt: chan[socket_event]) {\n     // Start the read before notifying about the connect.  This avoids a race\n     // condition where the receiver can close the socket before we start\n     // reading.\n-    let reader: port[u8[]] = port();\n+    let reader: port[[u8]] = port();\n     rustrt::aio_read(client, chan(reader));\n \n     evt <| connected(client);\n \n     while (true) {\n         log \"waiting for bytes\";\n-        let data: u8[];\n+        let data: [u8];\n         reader |> data;\n         log \"got some bytes\";\n         log ivec::len[u8](data);"}, {"sha": "b5b376be5c189cd6572c7480def785fd7ba65583", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -24,7 +24,7 @@ export eq_vec;\n //        an optimizing version of this module that produces a different obj\n //        for the case where nbits <= 32.\n \n-type t = @{storage: uint[mutable ], nbits: uint};\n+type t = @{storage: [mutable uint], nbits: uint};\n \n \n // FIXME: this should be a constant once they work\n@@ -150,7 +150,7 @@ fn to_vec(v: &t) -> vec[uint] {\n     ret vec::init_fn[uint](sub, v.nbits);\n }\n \n-fn to_ivec(v: &t) -> uint[] {\n+fn to_ivec(v: &t) -> [uint] {\n     let sub = bind init_to_vec(v, _);\n     ret ivec::init_fn[uint](sub, v.nbits);\n }\n@@ -178,7 +178,7 @@ fn eq_vec(v0: &t, v1: &vec[uint]) -> bool {\n     ret true;\n }\n \n-fn eq_ivec(v0: &t, v1: &uint[]) -> bool {\n+fn eq_ivec(v0: &t, v1: &[uint]) -> bool {\n     assert (v0.nbits == ivec::len[uint](v1));\n     let len = v0.nbits;\n     let i = 0u;"}, {"sha": "a6c43572bb5dd7e7e27f2522615e05de74619f57", "filename": "src/lib/deque.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -26,10 +26,10 @@ fn create[@T]() -> t[T] {\n       */\n \n \n-    fn grow[@T](nelts: uint, lo: uint, elts: &(cell[T])[mutable ]) ->\n-       (cell[T])[mutable ] {\n+    fn grow[@T](nelts: uint, lo: uint, elts: &[mutable cell[T]]) ->\n+       [mutable cell[T]] {\n         assert (nelts == ivec::len(elts));\n-        let rv = ~[mutable ];\n+        let rv = ~[mutable];\n \n         let i = 0u;\n         let nalloc = uint::next_power_of_two(nelts + 1u);\n@@ -42,13 +42,13 @@ fn create[@T]() -> t[T] {\n \n         ret rv;\n     }\n-    fn get[@T](elts: &(cell[T])[mutable ], i: uint) -> T {\n+    fn get[@T](elts: &[mutable cell[T]], i: uint) -> T {\n         ret alt elts.(i) { option::some(t) { t } _ { fail } };\n     }\n     obj deque[@T](mutable nelts: uint,\n                   mutable lo: uint,\n                   mutable hi: uint,\n-                  mutable elts: (cell[T])[mutable ]) {\n+                  mutable elts: [mutable cell[T]]) {\n         fn size() -> uint { ret nelts; }\n         fn add_front(t: &T) {\n             let oldlo: uint = lo;\n@@ -101,7 +101,7 @@ fn create[@T]() -> t[T] {\n             ret get[T](elts, idx);\n         }\n     }\n-    let v: (cell[T])[mutable ] =\n+    let v: [mutable cell[T]] =\n         ivec::init_elt_mut(option::none, initial_capacity);\n     ret deque[T](0u, 0u, 0u, v);\n }"}, {"sha": "1fb5860b4a0c25e423d074117a1fb9959b75c320", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -15,9 +15,9 @@ type ebml_state = {ebml_tag: ebml_tag, tag_pos: uint, data_pos: uint};\n // modules within this file.\n \n // ebml reading\n-type doc = {data: @u8[], start: uint, end: uint};\n+type doc = {data: @[u8], start: uint, end: uint};\n \n-fn vint_at(data: &u8[], start: uint) -> {val: uint, next: uint} {\n+fn vint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n     let a = data.(start);\n     if a & 0x80u8 != 0u8 { ret {val: a & 0x7fu8 as uint, next: start + 1u}; }\n     if a & 0x40u8 != 0u8 {\n@@ -39,11 +39,11 @@ fn vint_at(data: &u8[], start: uint) -> {val: uint, next: uint} {\n     } else { log_err \"vint too big\"; fail; }\n }\n \n-fn new_doc(data: &@u8[]) -> doc {\n+fn new_doc(data: &@[u8]) -> doc {\n     ret {data: data, start: 0u, end: ivec::len[u8](*data)};\n }\n \n-fn doc_at(data: &@u8[], start: uint) -> doc {\n+fn doc_at(data: &@[u8], start: uint) -> doc {\n     let elt_tag = vint_at(*data, start);\n     let elt_size = vint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n@@ -96,9 +96,9 @@ iter tagged_docs(d: doc, tg: uint) -> doc {\n     }\n }\n \n-fn doc_data(d: doc) -> u8[] { ret ivec::slice[u8](*d.data, d.start, d.end); }\n+fn doc_data(d: doc) -> [u8] { ret ivec::slice[u8](*d.data, d.start, d.end); }\n \n-fn be_uint_from_bytes(data: &@u8[], start: uint, size: uint) -> uint {\n+fn be_uint_from_bytes(data: &@[u8], start: uint, size: uint) -> uint {\n     let sz = size;\n     assert (sz <= 4u);\n     let val = 0u;\n@@ -117,10 +117,10 @@ fn doc_as_uint(d: doc) -> uint {\n \n \n // ebml writing\n-type writer = {writer: ioivec::buf_writer, mutable size_positions: uint[]};\n+type writer = {writer: ioivec::buf_writer, mutable size_positions: [uint]};\n \n fn write_sized_vint(w: &ioivec::buf_writer, n: uint, size: uint) {\n-    let buf: u8[];\n+    let buf: [u8];\n     alt size {\n       1u { buf = ~[0x80u8 | (n as u8)]; }\n       2u { buf = ~[0x40u8 | (n >> 8u as u8), n & 0xffu as u8]; }\n@@ -149,7 +149,7 @@ fn write_vint(w: &ioivec::buf_writer, n: uint) {\n }\n \n fn create_writer(w: &ioivec::buf_writer) -> writer {\n-    let size_positions: uint[] = ~[];\n+    let size_positions: [uint] = ~[];\n     ret {writer: w, mutable size_positions: size_positions};\n }\n \n@@ -162,7 +162,7 @@ fn start_tag(w: &writer, tag_id: uint) {\n     // Write a placeholder four-byte size.\n \n     w.size_positions += ~[w.writer.tell()];\n-    let zeroes: u8[] = ~[0u8, 0u8, 0u8, 0u8];\n+    let zeroes: [u8] = ~[0u8, 0u8, 0u8, 0u8];\n     w.writer.write(zeroes);\n }\n "}, {"sha": "5ca232a617f17027bdb9a624f8ee46cab9196f89", "filename": "src/lib/either.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -13,25 +13,25 @@ fn either[T, U,\n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n \n-fn lefts[T, U](eithers: &(t[T, U])[]) -> T[] {\n-    let result: T[] = ~[];\n+fn lefts[T, U](eithers: &[t[T, U]]) -> [T] {\n+    let result: [T] = ~[];\n     for elt: t[T, U]  in eithers {\n         alt elt { left(l) { result += ~[l] } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn rights[T, U](eithers: &(t[T, U])[]) -> U[] {\n-    let result: U[] = ~[];\n+fn rights[T, U](eithers: &[t[T, U]]) -> [U] {\n+    let result: [U] = ~[];\n     for elt: t[T, U]  in eithers {\n         alt elt { right(r) { result += ~[r] } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn partition[T, U](eithers: &(t[T, U])[]) -> {lefts: T[], rights: U[]} {\n-    let lefts: T[] = ~[];\n-    let rights: U[] = ~[];\n+fn partition[T, U](eithers: &[t[T, U]]) -> {lefts: [T], rights: [U]} {\n+    let lefts: [T] = ~[];\n+    let rights: [U] = ~[];\n     for elt: t[T, U]  in eithers {\n         alt elt { left(l) { lefts += ~[l] } right(r) { rights += ~[r] } }\n     }"}, {"sha": "9f47b2d11f7f44d38871e3cde5818c4b706ce5b5", "filename": "src/lib/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -44,10 +44,10 @@ fn connect(pre: path, post: path) -> path {\n \n fn file_is_dir(p: path) -> bool { ret rustrt::rust_file_is_dir(p) != 0; }\n \n-fn list_dir(p: path) -> str[] {\n+fn list_dir(p: path) -> [str] {\n     let pl = str::byte_len(p);\n     if pl == 0u || p.(pl - 1u) as char != os_fs::path_sep { p += path_sep(); }\n-    let full_paths: str[] = ~[];\n+    let full_paths: [str] = ~[];\n     for filename: str  in os_fs::list_dir(p) {\n         if !str::eq(filename, \".\") {\n             if !str::eq(filename, \"..\") { full_paths += ~[p + filename]; }"}, {"sha": "3ae030e8717f087d8b3dda445a18bd3c95632736", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -66,7 +66,7 @@ fn optmulti(name: str) -> opt {\n \n tag optval { val(str); given; }\n \n-type match = {opts: opt[], vals: optval[][mutable ], free: vec[str]};\n+type match = {opts: [opt], vals: [mutable [optval]], free: vec[str]};\n \n fn is_arg(arg: str) -> bool {\n     ret str::byte_len(arg) > 1u && arg.(0) == '-' as u8;\n@@ -76,7 +76,7 @@ fn name_str(nm: name) -> str {\n     ret alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n }\n \n-fn find_opt(opts: &opt[], nm: name) -> option::t[uint] {\n+fn find_opt(opts: &[opt], nm: name) -> option::t[uint] {\n     let i = 0u;\n     let l = ivec::len[opt](opts);\n     while i < l { if opts.(i).name == nm { ret some[uint](i); } i += 1u; }\n@@ -116,10 +116,10 @@ fn getopts(args: vec[str], opts: vec[opt]) -> result {\n     ret getopts_ivec(args_ivec, opts_ivec);\n }\n \n-fn getopts_ivec(args: &str[], opts: &opt[]) -> result {\n+fn getopts_ivec(args: &[str], opts: &[opt]) -> result {\n     let n_opts = ivec::len[opt](opts);\n-    fn f(x: uint) -> optval[] { ret ~[]; }\n-    let vals = ivec::init_fn_mut[optval[]](f, n_opts);\n+    fn f(x: uint) -> [optval] { ret ~[]; }\n+    let vals = ivec::init_fn_mut[[optval]](f, n_opts);\n     let free: vec[str] = [];\n     let l = ivec::len[str](args);\n     let i = 0u;\n@@ -209,7 +209,7 @@ fn getopts_ivec(args: &str[], opts: &opt[]) -> result {\n     ret success({opts: opts, vals: vals, free: free});\n }\n \n-fn opt_vals(m: &match, nm: str) -> optval[] {\n+fn opt_vals(m: &match, nm: str) -> [optval] {\n     ret alt find_opt(m.opts, mkname(nm)) {\n           some(id) { m.vals.(id) }\n           none. { log_err \"No option '\" + nm + \"' defined.\"; fail }\n@@ -234,8 +234,8 @@ fn opt_strs(m: &match, nm: str) -> vec[str] {\n     ret acc;\n }\n \n-fn opt_strs_ivec(m: &match, nm: str) -> str[] {\n-    let acc: str[] = ~[];\n+fn opt_strs_ivec(m: &match, nm: str) -> [str] {\n+    let acc: [str] = ~[];\n     for v: optval  in opt_vals(m, nm) {\n         alt v { val(s) { acc += ~[s]; } _ { } }\n     }"}, {"sha": "95c0e4254250723571ab4b0a60bc5f1251088f18", "filename": "src/lib/ioivec.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fioivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fioivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fioivec.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -19,7 +19,7 @@ type buf_reader =\n     // FIXME: Seekable really should be orthogonal. We will need\n     // inheritance.\n     obj {\n-        fn read(uint) -> u8[] ;\n+        fn read(uint) -> [u8] ;\n         fn read_byte() -> int ;\n         fn unread_byte(int) ;\n         fn eof() -> bool ;\n@@ -38,15 +38,15 @@ type reader =\n         fn get_buf_reader() -> buf_reader ;\n         fn read_byte() -> int ;\n         fn unread_byte(int) ;\n-        fn read_bytes(uint) -> u8[] ;\n+        fn read_bytes(uint) -> [u8] ;\n         fn read_char() -> char ;\n         fn eof() -> bool ;\n         fn read_line() -> str ;\n         fn read_c_str() -> str ;\n         fn read_le_uint(uint) -> uint ;\n         fn read_le_int(uint) -> int ;\n         fn read_be_uint(uint) -> uint ;\n-        fn read_whole_stream() -> u8[] ;\n+        fn read_whole_stream() -> [u8] ;\n         fn seek(int, seek_style) ;\n         fn tell() -> uint ;\n     };\n@@ -60,7 +60,7 @@ resource FILE_res(f: os::libc::FILE) {\n }\n \n obj FILE_buf_reader(f: os::libc::FILE, res: option::t[@FILE_res]) {\n-    fn read(len: uint) -> u8[] {\n+    fn read(len: uint) -> [u8] {\n         let buf = ~[];\n         ivec::reserve[u8](buf, len);\n         let read = os::libc_ivec::fread(ivec::to_ptr[u8](buf), 1u, len, f);\n@@ -84,7 +84,7 @@ obj new_reader(rdr: buf_reader) {\n     fn get_buf_reader() -> buf_reader { ret rdr; }\n     fn read_byte() -> int { ret rdr.read_byte(); }\n     fn unread_byte(byte: int) { ret rdr.unread_byte(byte); }\n-    fn read_bytes(len: uint) -> u8[] { ret rdr.read(len); }\n+    fn read_bytes(len: uint) -> [u8] { ret rdr.read(len); }\n     fn read_char() -> char {\n         let c0 = rdr.read_byte();\n         if c0 == -1 {\n@@ -111,7 +111,7 @@ obj new_reader(rdr: buf_reader) {\n     }\n     fn eof() -> bool { ret rdr.eof(); }\n     fn read_line() -> str {\n-        let buf: u8[] = ~[];\n+        let buf: [u8] = ~[];\n         // No break yet in rustc\n \n         let go_on = true;\n@@ -124,7 +124,7 @@ obj new_reader(rdr: buf_reader) {\n         ret str::unsafe_from_bytes_ivec(buf);\n     }\n     fn read_c_str() -> str {\n-        let buf: u8[] = ~[];\n+        let buf: [u8] = ~[];\n         let go_on = true;\n         while go_on {\n             let ch = rdr.read_byte();\n@@ -165,8 +165,8 @@ obj new_reader(rdr: buf_reader) {\n         }\n         ret val;\n     }\n-    fn read_whole_stream() -> u8[] {\n-        let buf: u8[] = ~[];\n+    fn read_whole_stream() -> [u8] {\n+        let buf: [u8] = ~[];\n         while !rdr.eof() { buf += rdr.read(2048u); }\n         ret buf;\n     }\n@@ -192,10 +192,10 @@ fn new_reader_(bufr: buf_reader) -> reader { ret new_reader(bufr); }\n // Byte buffer readers\n \n // TODO: mutable? u8, but this fails with rustboot.\n-type byte_buf = @{buf: u8[], mutable pos: uint};\n+type byte_buf = @{buf: [u8], mutable pos: uint};\n \n obj byte_buf_reader(bbuf: byte_buf) {\n-    fn read(len: uint) -> u8[] {\n+    fn read(len: uint) -> [u8] {\n         let rest = ivec::len[u8](bbuf.buf) - bbuf.pos;\n         let to_read = len;\n         if rest < to_read { to_read = rest; }\n@@ -219,7 +219,7 @@ obj byte_buf_reader(bbuf: byte_buf) {\n     fn tell() -> uint { ret bbuf.pos; }\n }\n \n-fn new_byte_buf_reader(buf: &u8[]) -> buf_reader {\n+fn new_byte_buf_reader(buf: &[u8]) -> buf_reader {\n     ret byte_buf_reader(@{buf: buf, mutable pos: 0u});\n }\n \n@@ -238,13 +238,13 @@ type buf_writer =\n      // FIXME: eventually u64\n \n     obj {\n-        fn write(&u8[]) ;\n+        fn write(&[u8]) ;\n         fn seek(int, seek_style) ;\n         fn tell() -> uint ;\n     };\n \n obj FILE_writer(f: os::libc::FILE, res: option::t[@FILE_res]) {\n-    fn write(v: &u8[]) {\n+    fn write(v: &[u8]) {\n         let len = ivec::len[u8](v);\n         let vbuf = ivec::to_ptr[u8](v);\n         let nout = os::libc_ivec::fwrite(vbuf, len, 1u, f);\n@@ -263,7 +263,7 @@ resource fd_res(fd: int) {\n }\n \n obj fd_buf_writer(fd: int, res: option::t[@fd_res]) {\n-    fn write(v: &u8[]) {\n+    fn write(v: &[u8]) {\n         let len = ivec::len[u8](v);\n         let count = 0u;\n         let vbuf;\n@@ -288,7 +288,7 @@ obj fd_buf_writer(fd: int, res: option::t[@fd_res]) {\n     }\n }\n \n-fn file_buf_writer(path: str, flags: &fileflag[]) -> buf_writer {\n+fn file_buf_writer(path: str, flags: &[fileflag]) -> buf_writer {\n     let fflags: int =\n         os::libc_constants::O_WRONLY() | os::libc_constants::O_BINARY();\n     for f: fileflag  in flags {\n@@ -322,20 +322,20 @@ type writer =\n         fn write_char(char) ;\n         fn write_int(int) ;\n         fn write_uint(uint) ;\n-        fn write_bytes(&u8[]) ;\n+        fn write_bytes(&[u8]) ;\n         fn write_le_uint(uint, uint) ;\n         fn write_le_int(int, uint) ;\n         fn write_be_uint(uint, uint) ;\n     };\n \n-fn uint_to_le_bytes(n: uint, size: uint) -> u8[] {\n-    let bytes: u8[] = ~[];\n+fn uint_to_le_bytes(n: uint, size: uint) -> [u8] {\n+    let bytes: [u8] = ~[];\n     while size > 0u { bytes += ~[n & 255u as u8]; n >>= 8u; size -= 1u; }\n     ret bytes;\n }\n \n-fn uint_to_be_bytes(n: uint, size: uint) -> u8[] {\n-    let bytes: u8[] = ~[];\n+fn uint_to_be_bytes(n: uint, size: uint) -> [u8] {\n+    let bytes: [u8] = ~[];\n     let i = size - 1u as int;\n     while i >= 0 { bytes += ~[n >> (i * 8 as uint) & 255u as u8]; i -= 1; }\n     ret bytes;\n@@ -357,7 +357,7 @@ obj new_writer(out: buf_writer) {\n     fn write_uint(n: uint) {\n         out.write(str::bytes_ivec(uint::to_str(n, 10u)));\n     }\n-    fn write_bytes(bytes: &u8[]) { out.write(bytes); }\n+    fn write_bytes(bytes: &[u8]) { out.write(bytes); }\n     fn write_le_uint(n: uint, size: uint) {\n         out.write(uint_to_le_bytes(n, size));\n     }\n@@ -373,7 +373,7 @@ obj new_writer(out: buf_writer) {\n // FIXME: Remove me once objects are exported.\n fn new_writer_(out: buf_writer) -> writer { ret new_writer(out); }\n \n-fn file_writer(path: str, flags: &fileflag[]) -> writer {\n+fn file_writer(path: str, flags: &[fileflag]) -> writer {\n     ret new_writer(file_buf_writer(path, flags));\n }\n \n@@ -395,10 +395,10 @@ type str_writer =\n         fn get_str() -> str ;\n     };\n \n-type mutable_byte_buf = @{mutable buf: u8[mutable ], mutable pos: uint};\n+type mutable_byte_buf = @{mutable buf: [mutable u8], mutable pos: uint};\n \n obj byte_buf_writer(buf: mutable_byte_buf) {\n-    fn write(v: &u8[]) {\n+    fn write(v: &[u8]) {\n         // Fast path.\n \n         if buf.pos == ivec::len(buf.buf) {\n@@ -430,7 +430,7 @@ obj byte_buf_writer(buf: mutable_byte_buf) {\n fn string_writer() -> str_writer {\n     // FIXME: yikes, this is bad. Needs fixing of mutable syntax.\n \n-    let b: u8[mutable ] = ~[mutable 0u8];\n+    let b: [mutable u8] = ~[mutable 0u8];\n     ivec::pop(b);\n     let buf: mutable_byte_buf = @{mutable buf: b, mutable pos: 0u};\n     obj str_writer_wrap(wr: writer, buf: mutable_byte_buf) {\n@@ -459,7 +459,7 @@ fn read_whole_file_str(file: &str) -> str {\n     str::unsafe_from_bytes_ivec(read_whole_file(file))\n }\n \n-fn read_whole_file(file: &str) -> u8[] {\n+fn read_whole_file(file: &str) -> [u8] {\n     // FIXME: There's a lot of copying here\n     file_reader(file).read_whole_stream()\n }"}, {"sha": "a60b8aa63de4f92bbf1208bcec054e6b3d0c6eaa", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -8,26 +8,26 @@ import ptr::addr_of;\n type operator2[T, U, V] = fn(&T, &U) -> V ;\n \n native \"rust-intrinsic\" mod rusti {\n-    fn ivec_len[T](v: &T[]) -> uint;\n+    fn ivec_len[T](v: &[T]) -> uint;\n }\n \n native \"rust\" mod rustrt {\n-    fn ivec_reserve_shared[T](v: &mutable T[mutable? ], n: uint);\n-    fn ivec_on_heap[T](v: &T[]) -> uint;\n-    fn ivec_to_ptr[T](v: &T[]) -> *T;\n-    fn ivec_copy_from_buf_shared[T](v: &mutable T[mutable? ], ptr: *T,\n+    fn ivec_reserve_shared[T](v: &mutable [mutable? T], n: uint);\n+    fn ivec_on_heap[T](v: &[T]) -> uint;\n+    fn ivec_to_ptr[T](v: &[T]) -> *T;\n+    fn ivec_copy_from_buf_shared[T](v: &mutable [mutable? T], ptr: *T,\n                                     count: uint);\n }\n \n-fn from_vec[@T](v: &vec[T]) -> T[] {\n-    let iv: T[] = ~[];\n+fn from_vec[@T](v: &vec[T]) -> [T] {\n+    let iv = ~[];\n     for e in v {\n         iv += ~[e];\n     }\n     ret iv;\n }\n \n-fn to_vec[@T](iv: &T[]) -> vec[T] {\n+fn to_vec[@T](iv: &[T]) -> vec[T] {\n     let v: vec[T] = [];\n     for e in iv {\n         v += [e];\n@@ -36,19 +36,19 @@ fn to_vec[@T](iv: &T[]) -> vec[T] {\n }\n \n /// Reserves space for `n` elements in the given vector.\n-fn reserve[@T](v: &mutable T[mutable? ], n: uint) {\n+fn reserve[@T](v: &mutable [mutable? T], n: uint) {\n     rustrt::ivec_reserve_shared(v, n);\n }\n \n-fn on_heap[T](v: &T[]) -> bool { ret rustrt::ivec_on_heap(v) != 0u; }\n+fn on_heap[T](v: &[T]) -> bool { ret rustrt::ivec_on_heap(v) != 0u; }\n \n-fn to_ptr[T](v: &T[]) -> *T { ret rustrt::ivec_to_ptr(v); }\n+fn to_ptr[T](v: &[T]) -> *T { ret rustrt::ivec_to_ptr(v); }\n \n-fn len[T](v: &T[mutable? ]) -> uint { ret rusti::ivec_len(v); }\n+fn len[T](v: &[mutable? T]) -> uint { ret rusti::ivec_len(v); }\n \n type init_op[T] = fn(uint) -> T ;\n \n-fn init_fn[@T](op: &init_op[T], n_elts: uint) -> T[] {\n+fn init_fn[@T](op: &init_op[T], n_elts: uint) -> [T] {\n     let v = ~[];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -57,15 +57,15 @@ fn init_fn[@T](op: &init_op[T], n_elts: uint) -> T[] {\n }\n \n // TODO: Remove me once we have slots.\n-fn init_fn_mut[@T](op: &init_op[T], n_elts: uint) -> T[mutable ] {\n-    let v = ~[mutable ];\n+fn init_fn_mut[@T](op: &init_op[T], n_elts: uint) -> [mutable T] {\n+    let v = ~[mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n     while i < n_elts { v += ~[mutable op(i)]; i += 1u; }\n     ret v;\n }\n \n-fn init_elt[@T](t: &T, n_elts: uint) -> T[] {\n+fn init_elt[@T](t: &T, n_elts: uint) -> [T] {\n     let v = ~[];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -74,53 +74,53 @@ fn init_elt[@T](t: &T, n_elts: uint) -> T[] {\n }\n \n // TODO: Remove me once we have slots.\n-fn init_elt_mut[@T](t: &T, n_elts: uint) -> T[mutable ] {\n-    let v = ~[mutable ];\n+fn init_elt_mut[@T](t: &T, n_elts: uint) -> [mutable T] {\n+    let v = ~[mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n     while i < n_elts { v += ~[mutable t]; i += 1u; }\n     ret v;\n }\n \n-fn to_mut[@T](v: &T[]) -> T[mutable ] {\n-    let vres = ~[mutable ];\n+fn to_mut[@T](v: &[T]) -> [mutable T] {\n+    let vres = ~[mutable];\n     for t: T  in v { vres += ~[mutable t]; }\n     ret vres;\n }\n \n-fn from_mut[@T](v: &T[mutable ]) -> T[] {\n+fn from_mut[@T](v: &[mutable T]) -> [T] {\n     let vres = ~[];\n     for t: T  in v { vres += ~[t]; }\n     ret vres;\n }\n \n // Predicates\n-pred is_empty[T](v: &T[mutable? ]) -> bool {\n+pred is_empty[T](v: &[mutable? T]) -> bool {\n     // FIXME: This would be easier if we could just call len\n     for t: T in v { ret false; }\n     ret true;\n }\n \n-pred is_not_empty[T](v: &T[mutable? ]) -> bool { ret !is_empty(v); }\n+pred is_not_empty[T](v: &[mutable? T]) -> bool { ret !is_empty(v); }\n \n // Accessors\n \n /// Returns the first element of a vector\n-fn head[@T](v: &T[mutable?]) : is_not_empty(v) -> T { ret v.(0); }\n+fn head[@T](v: &[mutable? T]) : is_not_empty(v) -> T { ret v.(0); }\n \n /// Returns all but the first element of a vector\n-fn tail[@T](v: &T[mutable? ]) : is_not_empty(v)  -> T[mutable?] {\n+fn tail[@T](v: &[mutable? T]) : is_not_empty(v) -> [mutable? T] {\n     ret slice(v, 1u, len(v));\n }\n \n /// Returns the last element of `v`.\n-fn last[@T](v: &T[mutable? ]) -> option::t[T] {\n+fn last[@T](v: &[mutable? T]) -> option::t[T] {\n     if len(v) == 0u { ret none; }\n     ret some(v.(len(v) - 1u));\n }\n \n /// Returns a copy of the elements from [`start`..`end`) from `v`.\n-fn slice[@T](v: &T[mutable? ], start: uint, end: uint) -> T[] {\n+fn slice[@T](v: &[mutable? T], start: uint, end: uint) -> [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let result = ~[];\n@@ -131,10 +131,10 @@ fn slice[@T](v: &T[mutable? ], start: uint, end: uint) -> T[] {\n }\n \n // TODO: Remove me once we have slots.\n-fn slice_mut[@T](v: &T[mutable? ], start: uint, end: uint) -> T[mutable ] {\n+fn slice_mut[@T](v: &[mutable? T], start: uint, end: uint) -> [mutable T] {\n     assert (start <= end);\n     assert (end <= len(v));\n-    let result = ~[mutable ];\n+    let result = ~[mutable];\n     reserve(result, end - start);\n     let i = start;\n     while i < end { result += ~[mutable v.(i)]; i += 1u; }\n@@ -145,7 +145,7 @@ fn slice_mut[@T](v: &T[mutable? ], start: uint, end: uint) -> T[mutable ] {\n // Mutators\n \n // TODO: Write this, unsafely, in a way that's not O(n).\n-fn pop[@T](v: &mutable T[mutable? ]) -> T {\n+fn pop[@T](v: &mutable [mutable? T]) -> T {\n     let ln = len(v);\n     assert (ln > 0u);\n     ln -= 1u;\n@@ -160,22 +160,22 @@ fn pop[@T](v: &mutable T[mutable? ]) -> T {\n // Appending\n \n /// Expands the given vector in-place by appending `n` copies of `initval`.\n-fn grow[@T](v: &mutable T[], n: uint, initval: &T) {\n+fn grow[@T](v: &mutable [T], n: uint, initval: &T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += ~[initval]; i += 1u; }\n }\n \n // TODO: Remove me once we have slots.\n-fn grow_mut[@T](v: &mutable T[mutable ], n: uint, initval: &T) {\n+fn grow_mut[@T](v: &mutable [mutable T], n: uint, initval: &T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += ~[mutable initval]; i += 1u; }\n }\n \n /// Calls `f` `n` times and appends the results of these calls to the given\n /// vector.\n-fn grow_fn[@T](v: &mutable T[], n: uint, init_fn: fn(uint) -> T ) {\n+fn grow_fn[@T](v: &mutable [T], n: uint, init_fn: fn(uint) -> T ) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += ~[init_fn(i)]; i += 1u; }\n@@ -184,15 +184,15 @@ fn grow_fn[@T](v: &mutable T[], n: uint, init_fn: fn(uint) -> T ) {\n /// Sets the element at position `index` to `val`. If `index` is past the end\n /// of the vector, expands the vector by replicating `initval` to fill the\n /// intervening space.\n-fn grow_set[@T](v: &mutable T[mutable ], index: uint, initval: &T, val: &T) {\n+fn grow_set[@T](v: &mutable [mutable T], index: uint, initval: &T, val: &T) {\n     if index >= len(v) { grow_mut(v, index - len(v) + 1u, initval); }\n     v.(index) = val;\n }\n \n \n // Functional utilities\n \n-fn map[@T, @U](f: fn(&T) -> U , v: &T[mutable? ]) -> U[] {\n+fn map[@T, @U](f: fn(&T) -> U , v: &[mutable? T]) -> [U] {\n     let result = ~[];\n     reserve(result, len(v));\n     for elem: T  in v {\n@@ -202,7 +202,7 @@ fn map[@T, @U](f: fn(&T) -> U , v: &T[mutable? ]) -> U[] {\n     ret result;\n }\n \n-fn filter_map[@T, @U](f: fn(&T) -> option::t[U] , v: &T[mutable? ]) -> U[] {\n+fn filter_map[@T, @U](f: fn(&T) -> option::t[U] , v: &[mutable? T]) -> [U] {\n     let result = ~[];\n     for elem: T  in v {\n         let elem2 = elem; // satisfies alias checker\n@@ -214,41 +214,41 @@ fn filter_map[@T, @U](f: fn(&T) -> option::t[U] , v: &T[mutable? ]) -> U[] {\n     ret result;\n }\n \n-fn foldl[@T, @U](p: fn(&U, &T) -> U , z: &U, v: &T[mutable? ]) -> U {\n+fn foldl[@T, @U](p: fn(&U, &T) -> U , z: &U, v: &[mutable? T]) -> U {\n     let sz = len(v);\n     if sz == 0u { ret z; }\n     let first = v.(0);\n     let rest = slice(v, 1u, sz);\n     ret p(foldl[T, U](p, z, rest), first);\n }\n \n-fn any[T](f: fn(&T) -> bool , v: &T[]) -> bool {\n+fn any[T](f: fn(&T) -> bool , v: &[T]) -> bool {\n     for elem: T  in v { if f(elem) { ret true; } }\n     ret false;\n }\n \n-fn all[T](f: fn(&T) -> bool , v: &T[]) -> bool {\n+fn all[T](f: fn(&T) -> bool , v: &[T]) -> bool {\n     for elem: T  in v { if !f(elem) { ret false; } }\n     ret true;\n }\n \n-fn member[T](x: &T, v: &T[]) -> bool {\n+fn member[T](x: &T, v: &[T]) -> bool {\n     for elt: T  in v { if x == elt { ret true; } }\n     ret false;\n }\n \n-fn count[T](x: &T, v: &T[mutable? ]) -> uint {\n+fn count[T](x: &T, v: &[mutable? T]) -> uint {\n     let cnt = 0u;\n     for elt: T  in v { if x == elt { cnt += 1u; } }\n     ret cnt;\n }\n \n-fn find[@T](f: fn(&T) -> bool , v: &T[]) -> option::t[T] {\n+fn find[@T](f: fn(&T) -> bool , v: &[T]) -> option::t[T] {\n     for elt: T  in v { if f(elt) { ret some[T](elt); } }\n     ret none[T];\n }\n \n-fn unzip[@T, @U](v: &{_0: T, _1: U}[]) -> {_0: T[], _1: U[]} {\n+fn unzip[@T, @U](v: &[{_0: T, _1: U}]) -> {_0: [T], _1: [U]} {\n     let sz = len(v);\n     if sz == 0u {\n         ret {_0: ~[], _1: ~[]};\n@@ -263,7 +263,7 @@ fn unzip[@T, @U](v: &{_0: T, _1: U}[]) -> {_0: T[], _1: U[]} {\n \n \n // FIXME make the lengths being equal a constraint\n-fn zip[@T, @U](v: &T[], u: &U[]) -> {_0: T, _1: U}[] {\n+fn zip[@T, @U](v: &[T], u: &[U]) -> [{_0: T, _1: U}] {\n     let sz = len(v);\n     assert (sz == len(u));\n     if sz == 0u {\n@@ -281,17 +281,17 @@ mod unsafe {\n          heap_part: *mutable ivec_heap_part};\n     type ivec_heap_part = {mutable fill: uint};\n \n-    fn copy_from_buf[T](v: &mutable T[], ptr: *T, count: uint) {\n+    fn copy_from_buf[T](v: &mutable [T], ptr: *T, count: uint) {\n         ret rustrt::ivec_copy_from_buf_shared(v, ptr, count);\n     }\n \n-    fn from_buf[T](ptr: *T, bytes: uint) -> T[] {\n+    fn from_buf[T](ptr: *T, bytes: uint) -> [T] {\n         let v = ~[];\n         copy_from_buf(v, ptr, bytes);\n         ret v;\n     }\n \n-    fn set_len[T](v: &mutable T[], new_len: uint) {\n+    fn set_len[T](v: &mutable [T], new_len: uint) {\n         let new_fill = new_len * sys::size_of[T]();\n         let stack_part: *mutable ivec_repr =\n             ::unsafe::reinterpret_cast(addr_of(v));"}, {"sha": "738adaf377f7253ca760504b11c1559c689dd270", "filename": "src/lib/map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -26,7 +26,7 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n \n     let load_factor: util::rational = {num: 3, den: 4};\n     tag bucket[@K, @V] { nil; deleted; some(K, V); }\n-    fn make_buckets[@K, @V](nbkts: uint) -> (bucket[K, V])[mutable ] {\n+    fn make_buckets[@K, @V](nbkts: uint) -> [mutable (bucket[K, V])] {\n         ret ivec::init_elt_mut[bucket[K, V]](nil[K, V], nbkts);\n     }\n     // Derive two hash functions from the one given by taking the upper\n@@ -55,7 +55,7 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n \n     fn insert_common[@K,\n                      @V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                         bkts: &(bucket[K, V])[mutable ], nbkts: uint,\n+                         bkts: &[mutable bucket[K, V]], nbkts: uint,\n                          key: &K, val: &V) -> bool {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n@@ -80,7 +80,7 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n     }\n     fn find_common[@K,\n                    @V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                       bkts: &(bucket[K, V])[mutable ], nbkts: uint, key: &K)\n+                       bkts: &[mutable bucket[K, V]], nbkts: uint, key: &K)\n        -> option::t[V] {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n@@ -103,8 +103,8 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n     }\n     fn rehash[@K,\n               @V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                  oldbkts: &(bucket[K, V])[mutable ], noldbkts: uint,\n-                  newbkts: &(bucket[K, V])[mutable ], nnewbkts: uint) {\n+                  oldbkts: &[mutable bucket[K, V]], noldbkts: uint,\n+                  newbkts: &[mutable bucket[K, V]], nnewbkts: uint) {\n         for b: bucket[K, V]  in oldbkts {\n             alt b {\n               some(k_, v_) {\n@@ -119,7 +119,7 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n     obj hashmap[@K,\n                 @V](hasher: hashfn[K],\n                     eqer: eqfn[K],\n-                    mutable bkts: (bucket[K, V])[mutable ],\n+                    mutable bkts: [mutable bucket[K, V]],\n                     mutable nbkts: uint,\n                     mutable nelts: uint,\n                     lf: util::rational) {"}, {"sha": "381a0c71755bf02d18c4f8938454efcb340db85e", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -1,11 +1,11 @@\n \n native \"rust\" mod rustrt {\n     fn rust_list_files(path: str) -> vec[str];\n-    fn rust_list_files_ivec(path: str) -> @str[];\n+    fn rust_list_files_ivec(path: str) -> @[str];\n     fn rust_dirent_filename(ent: os::libc::dirent) -> str;\n }\n \n-fn list_dir(path: str) -> str[] {\n+fn list_dir(path: str) -> [str] {\n     ret *rustrt::rust_list_files_ivec(path);\n     // TODO ensure this is always closed\n "}, {"sha": "ed38c757fc4f8101a375ac80a1eb7d269ccd818e", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -26,10 +26,10 @@ type sha1 =\n     // automatically during construction\n     obj {\n         fn input(&vec[u8]) ;\n-        fn input_ivec(&u8[]) ;\n+        fn input_ivec(&[u8]) ;\n         fn input_str(&str) ;\n         fn result() -> vec[u8] ;\n-        fn result_ivec() -> u8[] ;\n+        fn result_ivec() -> [u8] ;\n         fn result_str() -> str ;\n         fn reset() ;\n     };\n@@ -54,15 +54,15 @@ const k3: u32 = 0xCA62C1D6u32;\n // Builds a sha1 object\n fn mk_sha1() -> sha1 {\n     type sha1state =\n-        {h: u32[mutable ],\n+        {h: [mutable u32],\n          mutable len_low: u32,\n          mutable len_high: u32,\n-         msg_block: u8[mutable ],\n+         msg_block: [mutable u8],\n          mutable msg_block_idx: uint,\n          mutable computed: bool,\n-         work_buf: u32[mutable ]};\n+         work_buf: [mutable u32]};\n \n-    fn add_input(st: &sha1state, msg: &u8[]) {\n+    fn add_input(st: &sha1state, msg: &[u8]) {\n         // FIXME: Should be typestate precondition\n \n         assert (!st.computed);\n@@ -164,9 +164,9 @@ fn mk_sha1() -> sha1 {\n     fn circular_shift(bits: u32, word: u32) -> u32 {\n         ret word << bits | word >> 32u32 - bits;\n     }\n-    fn mk_result(st: &sha1state) -> u8[] {\n+    fn mk_result(st: &sha1state) -> [u8] {\n         if !st.computed { pad_msg(st); st.computed = true; }\n-        let rs: u8[] = ~[];\n+        let rs: [u8] = ~[];\n         for hpart: u32  in st.h {\n             let a = hpart >> 24u32 & 0xFFu32 as u8;\n             let b = hpart >> 16u32 & 0xFFu32 as u8;\n@@ -244,15 +244,15 @@ fn mk_sha1() -> sha1 {\n             for b: u8  in msg { m += ~[b]; }\n             add_input(st, m);\n         }\n-        fn input_ivec(msg: &u8[]) { add_input(st, msg); }\n+        fn input_ivec(msg: &[u8]) { add_input(st, msg); }\n         fn input_str(msg: &str) { add_input(st, str::bytes_ivec(msg)); }\n         fn result() -> vec[u8] {\n             let rivec = mk_result(st);\n             let rvec = [];\n             for b: u8  in rivec { rvec += [b]; }\n             ret rvec;\n         }\n-        fn result_ivec() -> u8[] { ret mk_result(st); }\n+        fn result_ivec() -> [u8] { ret mk_result(st); }\n         fn result_str() -> str {\n             let r = mk_result(st);\n             let s = \"\";"}, {"sha": "464c05a0340eb299660f33e6520bc3b184d5c4d4", "filename": "src/lib/sio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fsio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fsio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsio.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -28,7 +28,7 @@ fn connect_to(ctx: ctx, ip: str, portnum: int) -> client {\n     ret make_socket(ctx, p);\n }\n \n-fn read(c: client) -> u8[] {\n+fn read(c: client) -> [u8] {\n     let evt: aio::socket_event;\n     c.evt |> evt;\n     alt evt {\n@@ -62,7 +62,7 @@ fn accept_from(server: server) -> client {\n     }\n }\n \n-fn write_data(c: client, data: u8[]) -> bool {\n+fn write_data(c: client, data: [u8]) -> bool {\n     let p: port[bool] = port();\n     c.ctx <| aio::write(c.client, data, chan(p));\n     let success: bool;"}, {"sha": "abb1979b66f81b71f5d14698fec9fbed3a7b7bb5", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -7,10 +7,10 @@ import option::some;\n \n // FIXME: Should not be @; there's a bug somewhere in rustc that requires this\n // to be.\n-type smallintmap[T] = @{mutable v: (option::t[T])[mutable ]};\n+type smallintmap[T] = @{mutable v: [mutable option::t[T]]};\n \n fn mk[@T]() -> smallintmap[T] {\n-    let v: (option::t[T])[mutable ] = ~[mutable ];\n+    let v: [mutable option::t[T]] = ~[mutable];\n     ret @{mutable v: v};\n }\n "}, {"sha": "28592b9ca6feca9bb1f28d968895d785aac70789", "filename": "src/lib/sort.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -144,9 +144,9 @@ mod ivector {\n \n     type lteq[T] = fn(&T, &T) -> bool ;\n \n-    fn merge_sort[@T](le: lteq[T], v: &T[]) -> T[] {\n-        fn merge[@T](le: lteq[T], a: &T[], b: &T[]) -> T[] {\n-            let rs: T[] = ~[];\n+    fn merge_sort[@T](le: lteq[T], v: &[T]) -> [T] {\n+        fn merge[@T](le: lteq[T], a: &[T], b: &[T]) -> [T] {\n+            let rs: [T] = ~[];\n             let a_len: uint = ilen[T](a);\n             let a_ix: uint = 0u;\n             let b_len: uint = ilen[T](b);\n@@ -164,18 +164,18 @@ mod ivector {\n         let v_len: uint = ilen[T](v);\n         if v_len <= 1u { ret v; }\n         let mid: uint = v_len / 2u;\n-        let a: T[] = islice[T](v, 0u, mid);\n-        let b: T[] = islice[T](v, mid, v_len);\n+        let a: [T] = islice[T](v, 0u, mid);\n+        let b: [T] = islice[T](v, mid, v_len);\n         ret merge[T](le, merge_sort[T](le, a), merge_sort[T](le, b));\n     }\n \n-    fn swap[@T](arr: &T[mutable ], x: uint, y: uint) {\n+    fn swap[@T](arr: &[mutable T], x: uint, y: uint) {\n         let a = arr.(x);\n         arr.(x) = arr.(y);\n         arr.(y) = a;\n     }\n \n-    fn part[@T](compare_func: lteq[T], arr: &T[mutable ], left: uint,\n+    fn part[@T](compare_func: lteq[T], arr: &[mutable T], left: uint,\n                right: uint, pivot: uint) -> uint {\n         let pivot_value = arr.(pivot);\n         swap[T](arr, pivot, right);\n@@ -192,7 +192,7 @@ mod ivector {\n         ret storage_index;\n     }\n \n-    fn qsort[@T](compare_func: lteq[T], arr: &T[mutable ], left: uint,\n+    fn qsort[@T](compare_func: lteq[T], arr: &[mutable T], left: uint,\n                 right: uint) {\n         if right > left {\n             let pivot = (left + right) / 2u;\n@@ -205,7 +205,7 @@ mod ivector {\n         }\n     }\n \n-    fn quick_sort[@T](compare_func: lteq[T], arr: &T[mutable ]) {\n+    fn quick_sort[@T](compare_func: lteq[T], arr: &[mutable T]) {\n         if ilen[T](arr) == 0u { ret; }\n         qsort[T](compare_func, arr, 0u, ilen[T](arr) - 1u);\n     }\n@@ -217,7 +217,7 @@ mod ivector {\n     // 'randomly ordered keys, abstract compare' & 'small number of key\n     // values'\n     fn qsort3[@T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n-                 arr: &T[mutable ], left: int, right: int) {\n+                 arr: &[mutable T], left: int, right: int) {\n         if right <= left { ret; }\n         let v: T = arr.(right);\n         let i: int = left - 1;\n@@ -265,7 +265,7 @@ mod ivector {\n     }\n \n     fn quick_sort3[@T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n-                      arr: &T[mutable ]) {\n+                      arr: &[mutable T]) {\n         if ilen[T](arr) == 0u { ret; }\n         qsort3[T](compare_func_lt, compare_func_eq, arr, 0,\n                   (ilen[T](arr) as int) - 1);"}, {"sha": "8a5586c3455fdf95c911826c944c319dc3151e08", "filename": "src/lib/str.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -65,7 +65,7 @@ native \"rust\" mod rustrt {\n     fn str_vec(s: str) -> vec[u8];\n     fn str_byte_len(s: str) -> uint;\n     fn str_alloc(n_bytes: uint) -> str;\n-    fn str_from_ivec(b: &u8[mutable? ]) -> str;\n+    fn str_from_ivec(b: &[mutable? u8]) -> str;\n     fn str_from_vec(b: vec[mutable? u8]) -> str;\n     fn str_from_cstr(cstr: sbuf) -> str;\n     fn str_from_buf(buf: sbuf, len: uint) -> str;\n@@ -190,7 +190,7 @@ fn buf(s: &str) -> sbuf { ret rustrt::str_buf(s); }\n \n fn bytes(s: &str) -> vec[u8] { ret rustrt::str_vec(s); }\n \n-fn bytes_ivec(s: str) -> u8[] {\n+fn bytes_ivec(s: str) -> [u8] {\n     let sbuffer = buf(s);\n     let ptr = unsafe::reinterpret_cast(sbuffer);\n     ret ivec::unsafe::from_buf(ptr, byte_len(s));\n@@ -204,7 +204,7 @@ fn unsafe_from_bytes(v: vec[mutable? u8]) -> str {\n     ret rustrt::str_from_vec(v);\n }\n \n-fn unsafe_from_bytes_ivec(v: &u8[mutable? ]) -> str {\n+fn unsafe_from_bytes_ivec(v: &[mutable? u8]) -> str {\n     ret rustrt::str_from_ivec(v);\n }\n \n@@ -463,8 +463,8 @@ fn split(s: str, sep: u8) -> vec[str] {\n     ret v;\n }\n \n-fn split_ivec(s: str, sep: u8) -> str[] {\n-    let v: str[] = ~[];\n+fn split_ivec(s: str, sep: u8) -> [str] {\n+    let v: [str] = ~[];\n     let accum: str = \"\";\n     let ends_with_sep: bool = false;\n     for c: u8  in s {\n@@ -494,7 +494,7 @@ fn connect(v: vec[str], sep: str) -> str {\n     ret s;\n }\n \n-fn connect_ivec(v: &str[], sep: str) -> str {\n+fn connect_ivec(v: &[str], sep: str) -> str {\n     let s: str = \"\";\n     let first: bool = true;\n     for ss: str  in v {"}, {"sha": "70f9580bf732dca9994e2d89aca4fd04c44a77c1", "filename": "src/lib/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -48,7 +48,7 @@ type test_desc = {name: test_name, fn: test_fn, ignore: bool};\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n-fn test_main(args: &vec[str], tests: &test_desc[]) {\n+fn test_main(args: &vec[str], tests: &[test_desc]) {\n     let ivec_args =\n         { let iargs = ~[]; for arg: str  in args { iargs += ~[arg] } iargs };\n     check (ivec::is_not_empty(ivec_args));\n@@ -65,7 +65,7 @@ type test_opts = {filter: option::t[str], run_ignored: bool};\n type opt_res = either::t[test_opts, str];\n \n // Parses command line arguments into test options\n-fn parse_opts(args: &str[]) : ivec::is_not_empty(args) -> opt_res {\n+fn parse_opts(args: &[str]) : ivec::is_not_empty(args) -> opt_res {\n \n     // FIXME (#649): Shouldn't have to check here\n     check (ivec::is_not_empty(args));\n@@ -98,11 +98,11 @@ tag test_result { tr_ok; tr_failed; tr_ignored; }\n type test_to_task = fn(&fn()) -> task ;\n \n // A simple console test runner\n-fn run_tests_console(opts: &test_opts, tests: &test_desc[]) -> bool {\n+fn run_tests_console(opts: &test_opts, tests: &[test_desc]) -> bool {\n     run_tests_console_(opts, tests, default_test_to_task)\n }\n \n-fn run_tests_console_(opts: &test_opts, tests: &test_desc[],\n+fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n                       to_task: &test_to_task) -> bool {\n \n     type test_state = @{\n@@ -112,7 +112,7 @@ fn run_tests_console_(opts: &test_opts, tests: &test_desc[],\n         mutable passed: uint,\n         mutable failed: uint,\n         mutable ignored: uint,\n-        mutable failures: test_desc[]\n+        mutable failures: [test_desc]\n     };\n \n     fn callback(event: testevent, st: test_state) {\n@@ -210,12 +210,12 @@ fn use_color() -> bool {\n }\n \n tag testevent {\n-    te_filtered(test_desc[]);\n+    te_filtered([test_desc]);\n     te_wait(test_desc);\n     te_result(test_desc, test_result);\n }\n \n-fn run_tests(opts: &test_opts, tests: &test_desc[],\n+fn run_tests(opts: &test_opts, tests: &[test_desc],\n              to_task: &test_to_task, callback: fn(testevent)) {\n \n     let filtered_tests = filter_tests(opts, tests);\n@@ -249,7 +249,7 @@ fn run_tests(opts: &test_opts, tests: &test_desc[],\n \n fn get_concurrency() -> uint { rustrt::sched_threads() }\n \n-fn filter_tests(opts: &test_opts, tests: &test_desc[]) -> test_desc[] {\n+fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n     let filtered = tests;\n \n     // Remove tests that don't match the test filter"}, {"sha": "ab456d23b88f608fd111de55a3e57235a38edddc", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -10,7 +10,7 @@ type node = option::t[uint];\n \n type ufind = {mutable nodes: vec[mutable node]};\n \n-fn make() -> ufind { ret {mutable nodes: [mutable ]}; }\n+fn make() -> ufind { ret {mutable nodes: [mutable]}; }\n \n fn make_set(ufnd: &ufind) -> uint {\n     let idx = vec::len(ufnd.nodes);"}, {"sha": "79a2811653acbe101b4eef92c8cf64b63dbefa95", "filename": "src/lib/ufindivec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fufindivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fufindivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufindivec.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -8,9 +8,9 @@ import option::some;\n // than the node itself.\n type node = option::t[uint];\n \n-type ufind = {mutable nodes: node[mutable ]};\n+type ufind = {mutable nodes: [mutable node]};\n \n-fn make() -> ufind { ret {mutable nodes: ~[mutable ]}; }\n+fn make() -> ufind { ret {mutable nodes: ~[mutable]}; }\n \n fn make_set(ufnd: &ufind) -> uint {\n     let idx = ivec::len(ufnd.nodes);"}, {"sha": "cd300941df091d5923cb9d26fbd54f85048e62f7", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f97cb368954937662f17b8bddab81206e4ab07/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=50f97cb368954937662f17b8bddab81206e4ab07", "patch": "@@ -2,11 +2,11 @@\n \n native \"rust\" mod rustrt {\n     fn rust_list_files(path: str) -> vec[str];\n-    fn rust_list_files_ivec(path: str) -> @str[];\n+    fn rust_list_files_ivec(path: str) -> @[str];\n     fn rust_file_is_dir(path: str) -> int;\n }\n \n-fn list_dir(path: str) -> str[] {\n+fn list_dir(path: str) -> [str] {\n     ret *rustrt::rust_list_files_ivec(path + \"*\");\n }\n "}]}