{"sha": "84ddff3909b5920228642649b7f5cc011c0b900a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ZGRmZjM5MDliNTkyMDIyODY0MjY0OWI3ZjVjYzAxMWMwYjkwMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-28T04:51:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-28T04:51:53Z"}, "message": "auto merge of #5578 : erickt/rust/incoming, r=jbclements,erickt\n\nHey folks,\r\n\r\nThis patch series does some work on the json decoder, specifically with auto decoding of enums. Previously, we would take this code:\r\n\r\n```\r\nenum A {\r\n    B,\r\n    C(~str, uint)\r\n}\r\n```\r\n\r\nand would encode a value of this enum to either `[\"B\", []]` or `[\"C\", [\"D\", 123]]`. I've changed this to `\"B\"` or `[\"C\", \"D\", 123]`. This matches the style of the O'Caml json library [json-wheel](http://mjambon.com/json-wheel.html). I've added tests to make sure all this work.\r\n\r\nIn order to make this change, I added passing a `&[&str]` vec to `Decode::emit_enum_variant` so the json decoder can convert the name of a variant into it's position. I also changed the impl of `Encodable` for `Option<T>` to have the right upper casing.\r\n\r\nI also did some work on the parser, which allows for `fn foo<T: ::cmp::Eq>() { ... }` statements (#5572), fixed the pretty printer properly expanding `debug!(\"...\")` expressions, and removed `ast::expr_vstore_fixed`, which doesn't appear to be used anymore.", "tree": {"sha": "25cfe9b7ddd20bc08ea56de4fe87dbabf9a885f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25cfe9b7ddd20bc08ea56de4fe87dbabf9a885f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84ddff3909b5920228642649b7f5cc011c0b900a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84ddff3909b5920228642649b7f5cc011c0b900a", "html_url": "https://github.com/rust-lang/rust/commit/84ddff3909b5920228642649b7f5cc011c0b900a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84ddff3909b5920228642649b7f5cc011c0b900a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4954d3e50177c46d260a5340ff91bfada8590ef0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4954d3e50177c46d260a5340ff91bfada8590ef0", "html_url": "https://github.com/rust-lang/rust/commit/4954d3e50177c46d260a5340ff91bfada8590ef0"}, {"sha": "c317d3f6fa9475e65b6276743c09444441059ca7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c317d3f6fa9475e65b6276743c09444441059ca7", "html_url": "https://github.com/rust-lang/rust/commit/c317d3f6fa9475e65b6276743c09444441059ca7"}], "stats": {"total": 1136, "additions": 820, "deletions": 316}, "files": [{"sha": "c2692e9fa105d53b9496570e80dc4395345d72a7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -681,6 +681,7 @@ impl vtable_decoder_helpers for reader::Decoder {\n         @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n     }\n \n+    #[cfg(stage0)]\n     fn read_vtable_origin(&self, xcx: @ExtendedDecodeContext)\n         -> typeck::vtable_origin {\n         do self.read_enum(~\"vtable_origin\") {\n@@ -715,6 +716,44 @@ impl vtable_decoder_helpers for reader::Decoder {\n             }\n         }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_vtable_origin(&self, xcx: @ExtendedDecodeContext)\n+        -> typeck::vtable_origin {\n+        do self.read_enum(\"vtable_origin\") {\n+            do self.read_enum_variant([\"vtable_static\", \"vtable_param\"]) |i| {\n+                match i {\n+                  0 => {\n+                    typeck::vtable_static(\n+                        do self.read_enum_variant_arg(0u) {\n+                            self.read_def_id(xcx)\n+                        },\n+                        do self.read_enum_variant_arg(1u) {\n+                            self.read_tys(xcx)\n+                        },\n+                        do self.read_enum_variant_arg(2u) {\n+                            self.read_vtable_res(xcx)\n+                        }\n+                    )\n+                  }\n+                  1 => {\n+                    typeck::vtable_param(\n+                        do self.read_enum_variant_arg(0u) {\n+                            self.read_uint()\n+                        },\n+                        do self.read_enum_variant_arg(1u) {\n+                            self.read_uint()\n+                        }\n+                    )\n+                  }\n+                  // hard to avoid - user input\n+                  _ => fail!(~\"bad enum variant\")\n+                }\n+            }\n+        }\n+    }\n }\n \n // ______________________________________________________________________"}, {"sha": "4bbedf5fc00388c658a20c4e17bc5d741246979f", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -156,7 +156,6 @@ pub fn check_expr(sess: Session,\n           expr_paren(e) => { check_expr(sess, def_map, method_map,\n                                          tcx, e, is_const, v); }\n           expr_vstore(_, expr_vstore_slice) |\n-          expr_vstore(_, expr_vstore_fixed(_)) |\n           expr_vec(_, m_imm) |\n           expr_addr_of(m_imm, _) |\n           expr_field(*) |"}, {"sha": "d610b007f3503429a2a8c2cd56a8b3ec6808dd2b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -110,7 +110,6 @@ pub fn classify(e: @expr,\n \n               ast::expr_vstore(e, vstore) => {\n                   match vstore {\n-                      ast::expr_vstore_fixed(_) |\n                       ast::expr_vstore_slice => classify(e, tcx),\n                       ast::expr_vstore_uniq |\n                       ast::expr_vstore_box |"}, {"sha": "503077e5b06e892792d47b5084edd0827a443999", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -1290,7 +1290,7 @@ pub impl Liveness {\n             self.propagate_through_expr(l, ln)\n           }\n \n-          expr_log(_, l, r) |\n+          expr_log(l, r) |\n           expr_index(l, r) |\n           expr_binary(_, l, r) => {\n             self.propagate_through_exprs(~[l, r], succ)"}, {"sha": "a8749138549a9d5f015c08a108cbcbf37a8adde2", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -567,7 +567,7 @@ pub impl VisitContext {\n                 self.consume_block(blk, visitor);\n             }\n \n-            expr_log(_, a_expr, b_expr) => {\n+            expr_log(a_expr, b_expr) => {\n                 self.consume_expr(a_expr, visitor);\n                 self.use_expr(b_expr, Read, visitor);\n             }"}, {"sha": "050fc0dd334ad87a31109ec5c073b9ef00462e68", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -466,9 +466,6 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             let (v, _, _) = const_vec(cx, e, *es);\n             v\n           }\n-          ast::expr_vstore(e, ast::expr_vstore_fixed(_)) => {\n-            const_expr(cx, e)\n-          }\n           ast::expr_vstore(sub, ast::expr_vstore_slice) => {\n             match sub.node {\n               ast::expr_lit(ref lit) => {"}, {"sha": "4ee63f8bf338313022817032157f3750a5b1d1cd", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -496,7 +496,7 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n         ast::expr_ret(ex) => {\n             return controlflow::trans_ret(bcx, ex);\n         }\n-        ast::expr_log(_, lvl, a) => {\n+        ast::expr_log(lvl, a) => {\n             return controlflow::trans_log(expr, lvl, bcx, a);\n         }\n         ast::expr_while(cond, ref body) => {\n@@ -703,9 +703,6 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_vstore(contents, ast::expr_vstore_mut_slice) => {\n             return tvec::trans_slice_vstore(bcx, expr, contents, dest);\n         }\n-        ast::expr_vstore(contents, ast::expr_vstore_fixed(_)) => {\n-            return tvec::trans_fixed_vstore(bcx, expr, contents, dest);\n-        }\n         ast::expr_vec(*) | ast::expr_repeat(*) => {\n             return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n         }"}, {"sha": "1d9e57ce8ce1537e78358cb7097725faf901bc1b", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -329,7 +329,7 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n         mark_for_method_call(cx, e.id, e.callee_id);\n       }\n-      expr_log(_, _, val) => {\n+      expr_log(_, val) => {\n         node_type_needs(cx, use_tydesc, val.id);\n       }\n       expr_call(f, _, _) => {"}, {"sha": "58db934160ba0db77dbd8619b45ba08b2c23ecba", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -3114,7 +3114,6 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_lit(@codemap::spanned {node: lit_str(_), _}) |\n         ast::expr_vstore(_, ast::expr_vstore_slice) |\n         ast::expr_vstore(_, ast::expr_vstore_mut_slice) |\n-        ast::expr_vstore(_, ast::expr_vstore_fixed(_)) |\n         ast::expr_vec(*) => {\n             RvalueDpsExpr\n         }"}, {"sha": "8762cdf516bb9e1fc722a1c9d94f8c33efb189c2", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -2366,7 +2366,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n         fcx.write_bot(id);\n       }\n-      ast::expr_log(_, lv, e) => {\n+      ast::expr_log(lv, e) => {\n         check_expr_has_type(fcx, lv,\n                                   ty::mk_mach_uint(tcx, ast::ty_u32));\n \n@@ -3301,14 +3301,6 @@ pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n                                  v: ast::expr_vstore)\n                               -> ty::vstore {\n     match v {\n-        ast::expr_vstore_fixed(None) => ty::vstore_fixed(n),\n-        ast::expr_vstore_fixed(Some(u)) => {\n-            if n != u {\n-                let s = fmt!(\"fixed-size sequence mismatch: %u vs. %u\",u, n);\n-                fcx.ccx.tcx.sess.span_err(e.span,s);\n-            }\n-            ty::vstore_fixed(u)\n-        }\n         ast::expr_vstore_uniq => ty::vstore_uniq,\n         ast::expr_vstore_box | ast::expr_vstore_mut_box => ty::vstore_box,\n         ast::expr_vstore_slice | ast::expr_vstore_mut_slice => {"}, {"sha": "8b559295819783a812c82f1c1d1ea843d8cf6809", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -335,6 +335,7 @@ pub mod reader {\n             self.push_doc(self.next_doc(EsEnum), f)\n         }\n \n+        #[cfg(stage0)]\n         fn read_enum_variant<T>(&self, f: &fn(uint) -> T) -> T {\n             debug!(\"read_enum_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n@@ -344,6 +345,18 @@ pub mod reader {\n             }\n         }\n \n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        #[cfg(stage3)]\n+        fn read_enum_variant<T>(&self, _names: &[&str], f: &fn(uint) -> T) -> T {\n+            debug!(\"read_enum_variant()\");\n+            let idx = self._next_uint(EsEnumVid);\n+            debug!(\"  idx=%u\", idx);\n+            do self.push_doc(self.next_doc(EsEnumBody)) {\n+                f(idx)\n+            }\n+        }\n+\n         fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n             debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n             f()\n@@ -397,8 +410,37 @@ pub mod reader {\n             debug!(\"read_tup_elt(idx=%u)\", idx);\n             f()\n         }\n-    }\n \n+        #[cfg(stage0)]\n+        fn read_option<T>(&self, f: &fn() -> T) -> Option<T> {\n+            debug!(\"read_option()\");\n+            do self.read_enum(\"Option\") || {\n+                do self.read_enum_variant |idx| {\n+                    match idx {\n+                        0 => None,\n+                        1 => Some(f()),\n+                        _ => fail!(),\n+                    }\n+                }\n+            }\n+        }\n+\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        #[cfg(stage3)]\n+        fn read_option<T>(&self, f: &fn() -> T) -> Option<T> {\n+            debug!(\"read_option()\");\n+            do self.read_enum(\"Option\") || {\n+                do self.read_enum_variant([\"None\", \"Some\"]) |idx| {\n+                    match idx {\n+                        0 => None,\n+                        1 => Some(f()),\n+                        _ => fail!(),\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n pub mod writer {\n@@ -664,9 +706,19 @@ pub mod writer {\n \n         fn emit_tup(&self, _len: uint, f: &fn()) { f() }\n         fn emit_tup_elt(&self, _idx: uint, f: &fn()) { f() }\n-    }\n \n+        fn emit_option(&self, f: &fn()) {\n+            self.emit_enum(\"Option\", f);\n+        }\n+        fn emit_option_none(&self) {\n+            self.emit_enum_variant(\"None\", 0, 0, || ())\n+        }\n+        fn emit_option_some(&self, f: &fn()) {\n+            self.emit_enum_variant(\"Some\", 1, 1, f)\n+        }\n+    }\n }\n+\n // ___________________________________________________________________________\n // Testing\n "}, {"sha": "c48b210dca219c3023eb4a6eebdcd049037f1394", "filename": "src/libstd/json.rs", "status": "modified", "additions": 393, "deletions": 188, "changes": 581, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -119,39 +119,19 @@ impl serialize::Encoder for Encoder {\n         f()\n     }\n \n-    fn emit_enum_variant(&self, name: &str, _id: uint, _cnt: uint, f: &fn()) {\n-        // encoding of enums is special-cased for Option. Specifically:\n-        // Some(34) => 34\n-        // None => null\n-\n-        // other enums are encoded as vectors:\n+    fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n+        // enums are encoded as strings or vectors:\n+        // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => [\"Kangaroo\",[34,\"William\"]]\n \n-        // the default expansion for enums is more verbose than I'd like;\n-        // specifically, the inner pair of brackets seems superfluous,\n-        // BUT the design of the enumeration framework and the requirements\n-        // of the special-case for Option mean that a first argument must\n-        // be encoded \"naked\"--with no commas--and that the option name\n-        // can't be followed by just a comma, because there might not\n-        // be any elements in the tuple.\n-\n-        // FIXME #4872: this would be more precise and less frightening\n-        // with fully-qualified option names. To get that information,\n-        // we'd have to change the expansion of auto-encode to pass\n-        // those along.\n-\n-        if (name == ~\"Some\") {\n-            f();\n-        } else if (name == ~\"None\") {\n-            self.wr.write_str(~\"null\");\n+        if cnt == 0 {\n+            self.wr.write_str(escape_str(name));\n         } else {\n             self.wr.write_char('[');\n             self.wr.write_str(escape_str(name));\n             self.wr.write_char(',');\n-            self.wr.write_char('[');\n             f();\n             self.wr.write_char(']');\n-            self.wr.write_char(']');\n         }\n     }\n \n@@ -200,6 +180,10 @@ impl serialize::Encoder for Encoder {\n     fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n         self.emit_vec_elt(idx, f)\n     }\n+\n+    fn emit_option(&self, f: &fn()) { f(); }\n+    fn emit_option_none(&self) { self.emit_nil(); }\n+    fn emit_option_some(&self, f: &fn()) { f(); }\n }\n \n pub struct PrettyEncoder {\n@@ -250,27 +234,44 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_owned(&self, f: &fn()) { f() }\n     fn emit_managed(&self, f: &fn()) { f() }\n \n-    fn emit_enum(&self, name: &str, f: &fn()) {\n-        if name != \"option\" { fail!(~\"only supports option enum\") }\n-        f()\n-    }\n-    fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: &fn()) {\n-        if id == 0 {\n-            self.emit_nil();\n+    fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n+    fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n+        if cnt == 0 {\n+            self.wr.write_str(escape_str(name));\n         } else {\n-            f()\n+            self.wr.write_char('[');\n+            self.indent += 2;\n+            self.wr.write_char('\\n');\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_str(escape_str(name));\n+            self.wr.write_str(\",\\n\");\n+            f();\n+            self.wr.write_char('\\n');\n+            self.indent -= 2;\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_char(']');\n         }\n     }\n-    fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) {\n+    fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n+        if idx != 0 {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n         f()\n     }\n \n-    fn emit_borrowed_vec(&self, _len: uint, f: &fn()) {\n-        self.wr.write_char('[');\n-        self.indent += 2;\n-        f();\n-        self.indent -= 2;\n-        self.wr.write_char(']');\n+    fn emit_borrowed_vec(&self, len: uint, f: &fn()) {\n+        if len == 0 {\n+            self.wr.write_str(\"[]\");\n+        } else {\n+            self.wr.write_char('[');\n+            self.indent += 2;\n+            f();\n+            self.wr.write_char('\\n');\n+            self.indent -= 2;\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_char(']');\n+        }\n     }\n     fn emit_owned_vec(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f)\n@@ -292,11 +293,17 @@ impl serialize::Encoder for PrettyEncoder {\n         self.wr.write_char('{');\n         self.indent += 2;\n         f();\n+        self.wr.write_char('\\n');\n         self.indent -= 2;\n+        self.wr.write_str(spaces(self.indent));\n         self.wr.write_char('}');\n     }\n-    fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) {\n-        self.emit_rec(f)\n+    fn emit_struct(&self, _name: &str, len: uint, f: &fn()) {\n+        if len == 0 {\n+            self.wr.write_str(\"{}\");\n+        } else {\n+            self.emit_rec(f)\n+        }\n     }\n     fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx == 0 {\n@@ -315,6 +322,10 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n         self.emit_vec_elt(idx, f)\n     }\n+\n+    fn emit_option(&self, f: &fn()) { f(); }\n+    fn emit_option_none(&self) { self.emit_nil(); }\n+    fn emit_option_some(&self, f: &fn()) { f(); }\n }\n \n impl<S:serialize::Encoder> serialize::Encodable<S> for Json {\n@@ -816,15 +827,15 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n         debug!(\"read_owned_str\");\n         match *self.pop() {\n             String(ref s) => copy *s,\n-            _ => fail!(~\"not a string\")\n+            ref json => fail!(fmt!(\"not a string: %?\", *json))\n         }\n     }\n \n     fn read_managed_str(&self) -> @str {\n         debug!(\"read_managed_str\");\n         match *self.pop() {\n             String(ref s) => s.to_managed(),\n-            _ => fail!(~\"not a string\")\n+            ref json => fail!(fmt!(\"not a string: %?\", *json))\n         }\n     }\n \n@@ -840,10 +851,10 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n \n     fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n-        if name != ~\"option\" { fail!(~\"only supports the option enum\") }\n         f()\n     }\n \n+    #[cfg(stage0)]\n     fn read_enum_variant<T>(&self, f: &fn(uint) -> T) -> T {\n         debug!(\"read_enum_variant()\");\n         let idx = match *self.peek() {\n@@ -853,10 +864,32 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n         f(idx)\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T {\n+        debug!(\"read_enum_variant(names=%?)\", names);\n+        let name = match *self.peek() {\n+            String(ref s) => s,\n+            List([String(ref s), .. _]) => s,\n+            ref json => fail!(fmt!(\"invalid variant: %?\", *json)),\n+        };\n+        let idx = match vec::position(names, |n| str::eq_slice(*n, *name)) {\n+            Some(idx) => idx,\n+            None => fail!(fmt!(\"Unknown variant name: %?\", name)),\n+        };\n+        f(idx)\n+    }\n+\n     fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n-        if idx != 0 { fail!(~\"unknown index\") }\n-        f()\n+        match *self.peek() {\n+            List(ref list) => {\n+                self.stack.push(&list[idx + 1]);\n+                f()\n+            }\n+            ref json => fail!(fmt!(\"not a list: %?\", json)),\n+        }\n     }\n \n     fn read_owned_vec<T>(&self, f: &fn(uint) -> T) -> T {\n@@ -946,6 +979,13 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n             _ => fail!(~\"not a list\")\n         }\n     }\n+\n+    fn read_option<T>(&self, f: &fn() -> T) -> Option<T> {\n+        match *self.peek() {\n+            Null => { self.pop(); None }\n+            _ => Some(f()),\n+        }\n+    }\n }\n \n impl Eq for Json {\n@@ -1195,14 +1235,12 @@ impl to_str::ToStr for Error {\n \n #[cfg(test)]\n mod tests {\n-    use core::prelude::*;\n-\n-    use json::*;\n-    use serialize;\n+    use super::*;\n \n-    use core::result;\n+    use core::prelude::*;\n     use core::hashmap::linear::LinearMap;\n \n+    use std::serialize::Decodable;\n \n     fn mk_object(items: &[(~str, Json)]) -> Json {\n         let mut d = ~LinearMap::new();\n@@ -1218,45 +1256,89 @@ mod tests {\n \n     #[test]\n     fn test_write_null() {\n-        fail_unless!(to_str(&Null) == ~\"null\");\n+        assert_eq!(to_str(&Null), ~\"null\");\n     }\n \n     #[test]\n     fn test_write_number() {\n-        fail_unless!(to_str(&Number(3f)) == ~\"3\");\n-        fail_unless!(to_str(&Number(3.1f)) == ~\"3.1\");\n-        fail_unless!(to_str(&Number(-1.5f)) == ~\"-1.5\");\n-        fail_unless!(to_str(&Number(0.5f)) == ~\"0.5\");\n+        assert_eq!(to_str(&Number(3f)), ~\"3\");\n+        assert_eq!(to_str(&Number(3.1f)), ~\"3.1\");\n+        assert_eq!(to_str(&Number(-1.5f)), ~\"-1.5\");\n+        assert_eq!(to_str(&Number(0.5f)), ~\"0.5\");\n     }\n \n     #[test]\n     fn test_write_str() {\n-        fail_unless!(to_str(&String(~\"\")) == ~\"\\\"\\\"\");\n-        fail_unless!(to_str(&String(~\"foo\")) == ~\"\\\"foo\\\"\");\n+        assert_eq!(to_str(&String(~\"\")), ~\"\\\"\\\"\");\n+        assert_eq!(to_str(&String(~\"foo\")), ~\"\\\"foo\\\"\");\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        fail_unless!(to_str(&Boolean(true)) == ~\"true\");\n-        fail_unless!(to_str(&Boolean(false)) == ~\"false\");\n+        assert_eq!(to_str(&Boolean(true)), ~\"true\");\n+        assert_eq!(to_str(&Boolean(false)), ~\"false\");\n     }\n \n     #[test]\n     fn test_write_list() {\n-        fail_unless!(to_str(&List(~[])) == ~\"[]\");\n-        fail_unless!(to_str(&List(~[Boolean(true)])) == ~\"[true]\");\n-        fail_unless!(to_str(&List(~[\n+        assert_eq!(to_str(&List(~[])), ~\"[]\");\n+        assert_eq!(to_str(&List(~[Boolean(true)])), ~\"[true]\");\n+        assert_eq!(to_str(&List(~[\n             Boolean(false),\n             Null,\n             List(~[String(~\"foo\\nbar\"), Number(3.5f)])\n-        ])) == ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n+        ])), ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n+    }\n+\n+    #[test]\n+    fn test_write_list_pretty() {\n+        assert_eq!(to_pretty_str(&List(~[])), ~\"[]\");\n+        assert_eq!(\n+            to_pretty_str(&List(~[Boolean(true)])),\n+            ~\"\\\n+            [\\n  \\\n+                true\\n\\\n+            ]\"\n+        );\n+        assert_eq!(\n+            to_pretty_str(&List(~[\n+                Boolean(false),\n+                Null,\n+                List(~[String(~\"foo\\nbar\"), Number(3.5f)])\n+            ])),\n+            ~\"\\\n+            [\\n  \\\n+                false,\\n  \\\n+                null,\\n  \\\n+                [\\n    \\\n+                    \\\"foo\\\\nbar\\\",\\n    \\\n+                    3.5\\n  \\\n+                ]\\n\\\n+            ]\"\n+        );\n     }\n \n     #[test]\n     fn test_write_object() {\n-        fail_unless!(to_str(&mk_object(~[])) == ~\"{}\");\n-        fail_unless!(to_str(&mk_object(~[(~\"a\", Boolean(true))]))\n-            == ~\"{\\\"a\\\":true}\");\n+        assert_eq!(to_str(&mk_object(~[])), ~\"{}\");\n+        assert_eq!(\n+            to_str(&mk_object(~[(~\"a\", Boolean(true))])),\n+            ~\"{\\\"a\\\":true}\"\n+        );\n+        assert_eq!(\n+            to_str(&mk_object(~[\n+                (~\"b\", List(~[\n+                    mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n+                    mk_object(~[(~\"d\", String(~\"\"))])\n+                ]))\n+            ])),\n+            ~\"{\\\n+                \\\"b\\\":[\\\n+                    {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n+                    {\\\"d\\\":\\\"\\\"}\\\n+                ]\\\n+            }\"\n+        );\n         let a = mk_object(~[\n             (~\"a\", Boolean(true)),\n             (~\"b\", List(~[\n@@ -1266,256 +1348,351 @@ mod tests {\n         ]);\n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n-        let b = result::unwrap(from_str(to_str(&a)));\n-        fail_unless!(a == b);\n+        let b = from_str(to_str(&a)).unwrap();\n+        assert_eq!(a, b);\n     }\n \n     #[test]\n-    fn test_write_enum () {\n-        let bw = @io::BytesWriter();\n-        let bww : @io::Writer = (bw as @io::Writer);\n-        let encoder = (@Encoder(bww) as @serialize::Encoder);\n-        do encoder.emit_enum(~\"animal\") {\n-            do encoder.emit_enum_variant (~\"frog\",37,1242) {\n-                // name of frog:\n-                do encoder.emit_enum_variant_arg (0) {\n-                    encoder.emit_owned_str(~\"Henry\")\n-                }\n-                // mass of frog in grams:\n-                do encoder.emit_enum_variant_arg (1) {\n-                    encoder.emit_int(349);\n-                }\n-            }\n-        }\n-        assert_eq!(str::from_bytes(bw.bytes), ~\"[\\\"frog\\\",[\\\"Henry\\\",349]]\");\n+    fn test_write_object_pretty() {\n+        assert_eq!(to_pretty_str(&mk_object(~[])), ~\"{\\n}\");\n+        assert_eq!(\n+            to_pretty_str(&mk_object(~[(~\"a\", Boolean(true))])),\n+            ~\"\\\n+            {\\n  \\\n+                \\\"a\\\": true\\n\\\n+            }\"\n+        );\n+        assert_eq!(\n+            to_pretty_str(&mk_object(~[\n+                (~\"b\", List(~[\n+                    mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n+                    mk_object(~[(~\"d\", String(~\"\"))])\n+                ]))\n+            ])),\n+            ~\"\\\n+            {\\n  \\\n+                \\\"b\\\": [\\n    \\\n+                    {\\n      \\\n+                        \\\"c\\\": \\\"\\\\f\\\\r\\\"\\n    \\\n+                    },\\n    \\\n+                    {\\n      \\\n+                        \\\"d\\\": \\\"\\\"\\n    \\\n+                    }\\n  \\\n+                ]\\n\\\n+            }\"\n+        );\n+        let a = mk_object(~[\n+            (~\"a\", Boolean(true)),\n+            (~\"b\", List(~[\n+                mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n+                mk_object(~[(~\"d\", String(~\"\"))])\n+            ]))\n+        ]);\n+        // We can't compare the strings directly because the object fields be\n+        // printed in a different order.\n+        let b = from_str(to_str(&a)).unwrap();\n+        assert_eq!(a, b);\n+    }\n+\n+    #[auto_encode]\n+    #[auto_decode]\n+    #[deriving(Eq)]\n+    enum Animal {\n+        Dog,\n+        Frog(~str, int)\n     }\n \n     #[test]\n-    fn test_write_some () {\n-        let bw = @io::BytesWriter();\n-        let bww : @io::Writer = (bw as @io::Writer);\n-        let encoder = (@Encoder(bww) as @serialize::Encoder);\n-        do encoder.emit_enum(~\"Option\") {\n-            do encoder.emit_enum_variant (~\"Some\",37,1242) {\n-                do encoder.emit_enum_variant_arg (0) {\n-                    encoder.emit_owned_str(~\"jodhpurs\")\n-                }\n-            }\n-        }\n-        assert_eq!(str::from_bytes(bw.bytes), ~\"\\\"jodhpurs\\\"\");\n+    fn test_write_enum_no_args() {\n+        let animal = Dog;\n+\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = Encoder(wr);\n+            animal.encode(&encoder);\n+        };\n+        assert_eq!(s, ~\"\\\"Dog\\\"\");\n     }\n \n     #[test]\n-    fn test_write_none () {\n-        let bw = @io::BytesWriter();\n-        let bww : @io::Writer = (bw as @io::Writer);\n-        let encoder = (@Encoder(bww) as @serialize::Encoder);\n-        do encoder.emit_enum(~\"Option\") {\n-            do encoder.emit_enum_variant (~\"None\",37,1242) {\n-            }\n-        }\n-        assert_eq!(str::from_bytes(bw.bytes), ~\"null\");\n+    fn test_write_enum_no_args_pretty() {\n+        let animal = Dog;\n+\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = PrettyEncoder(wr);\n+            animal.encode(&encoder);\n+        };\n+        assert_eq!(s, ~\"\\\"Dog\\\"\");\n+    }\n+\n+    #[test]\n+    fn test_write_enum_multiple_args() {\n+        let animal = Frog(~\"Henry\", 349);\n+\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = Encoder(wr);\n+            animal.encode(&encoder);\n+        };\n+        assert_eq!(s, ~\"[\\\"Frog\\\",\\\"Henry\\\",349]\");\n+    }\n+\n+    #[test]\n+    fn test_write_enum_multiple_args_pretty() {\n+        let animal = Frog(~\"Henry\", 349);\n+\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = PrettyEncoder(wr);\n+            animal.encode(&encoder);\n+        };\n+        assert_eq!(\n+            s,\n+            ~\"\\\n+            [\\n  \\\n+                \\\"Frog\\\",\\n  \\\n+                \\\"Henry\\\",\\n  \\\n+                349\\n\\\n+            ]\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_write_some() {\n+        let value = Some(~\"jodhpurs\");\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = Encoder(wr);\n+            value.encode(&encoder);\n+        };\n+        assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n+    }\n+\n+    #[test]\n+    fn test_write_some_pretty() {\n+        let value = Some(~\"jodhpurs\");\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = PrettyEncoder(wr);\n+            value.encode(&encoder);\n+        };\n+        assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n+    }\n+\n+    #[test]\n+    fn test_write_none() {\n+        let value: Option<~str> = None;\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = Encoder(wr);\n+            value.encode(&encoder);\n+        };\n+        assert_eq!(s, ~\"null\");\n+    }\n+\n+    #[test]\n+    fn test_write_none_pretty() {\n+        let value: Option<~str> = None;\n+        let s = do io::with_str_writer |wr| {\n+            let encoder = Encoder(wr);\n+            value.encode(&encoder);\n+        };\n+        assert_eq!(s, ~\"null\");\n     }\n \n     #[test]\n     fn test_trailing_characters() {\n-        fail_unless!(from_str(~\"nulla\") ==\n+        assert_eq!(from_str(~\"nulla\"),\n             Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n-        fail_unless!(from_str(~\"truea\") ==\n+        assert_eq!(from_str(~\"truea\"),\n             Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n-        fail_unless!(from_str(~\"falsea\") ==\n+        assert_eq!(from_str(~\"falsea\"),\n             Err(Error {line: 1u, col: 6u, msg: @~\"trailing characters\"}));\n-        fail_unless!(from_str(~\"1a\") ==\n+        assert_eq!(from_str(~\"1a\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"trailing characters\"}));\n-        fail_unless!(from_str(~\"[]a\") ==\n+        assert_eq!(from_str(~\"[]a\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n-        fail_unless!(from_str(~\"{}a\") ==\n+        assert_eq!(from_str(~\"{}a\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n-        fail_unless!(from_str(~\"n\") ==\n+        assert_eq!(from_str(~\"n\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n-        fail_unless!(from_str(~\"nul\") ==\n+        assert_eq!(from_str(~\"nul\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n \n-        fail_unless!(from_str(~\"t\") ==\n+        assert_eq!(from_str(~\"t\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n-        fail_unless!(from_str(~\"truz\") ==\n+        assert_eq!(from_str(~\"truz\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n \n-        fail_unless!(from_str(~\"f\") ==\n+        assert_eq!(from_str(~\"f\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n-        fail_unless!(from_str(~\"faz\") ==\n+        assert_eq!(from_str(~\"faz\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"invalid syntax\"}));\n \n-        fail_unless!(from_str(~\"null\") == Ok(Null));\n-        fail_unless!(from_str(~\"true\") == Ok(Boolean(true)));\n-        fail_unless!(from_str(~\"false\") == Ok(Boolean(false)));\n-        fail_unless!(from_str(~\" null \") == Ok(Null));\n-        fail_unless!(from_str(~\" true \") == Ok(Boolean(true)));\n-        fail_unless!(from_str(~\" false \") == Ok(Boolean(false)));\n+        assert_eq!(from_str(~\"null\"), Ok(Null));\n+        assert_eq!(from_str(~\"true\"), Ok(Boolean(true)));\n+        assert_eq!(from_str(~\"false\"), Ok(Boolean(false)));\n+        assert_eq!(from_str(~\" null \"), Ok(Null));\n+        assert_eq!(from_str(~\" true \"), Ok(Boolean(true)));\n+        assert_eq!(from_str(~\" false \"), Ok(Boolean(false)));\n     }\n \n     #[test]\n     fn test_read_number() {\n-        fail_unless!(from_str(~\"+\") ==\n+        assert_eq!(from_str(~\"+\"),\n             Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n-        fail_unless!(from_str(~\".\") ==\n+        assert_eq!(from_str(~\".\"),\n             Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n \n-        fail_unless!(from_str(~\"-\") ==\n+        assert_eq!(from_str(~\"-\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n-        fail_unless!(from_str(~\"00\") ==\n+        assert_eq!(from_str(~\"00\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n-        fail_unless!(from_str(~\"1.\") ==\n+        assert_eq!(from_str(~\"1.\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n-        fail_unless!(from_str(~\"1e\") ==\n+        assert_eq!(from_str(~\"1e\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n-        fail_unless!(from_str(~\"1e+\") ==\n+        assert_eq!(from_str(~\"1e+\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid number\"}));\n \n-        fail_unless!(from_str(~\"3\") == Ok(Number(3f)));\n-        fail_unless!(from_str(~\"3.1\") == Ok(Number(3.1f)));\n-        fail_unless!(from_str(~\"-1.2\") == Ok(Number(-1.2f)));\n-        fail_unless!(from_str(~\"0.4\") == Ok(Number(0.4f)));\n-        fail_unless!(from_str(~\"0.4e5\") == Ok(Number(0.4e5f)));\n-        fail_unless!(from_str(~\"0.4e+15\") == Ok(Number(0.4e15f)));\n-        fail_unless!(from_str(~\"0.4e-01\") == Ok(Number(0.4e-01f)));\n-        fail_unless!(from_str(~\" 3 \") == Ok(Number(3f)));\n+        assert_eq!(from_str(~\"3\"), Ok(Number(3f)));\n+        assert_eq!(from_str(~\"3.1\"), Ok(Number(3.1f)));\n+        assert_eq!(from_str(~\"-1.2\"), Ok(Number(-1.2f)));\n+        assert_eq!(from_str(~\"0.4\"), Ok(Number(0.4f)));\n+        assert_eq!(from_str(~\"0.4e5\"), Ok(Number(0.4e5f)));\n+        assert_eq!(from_str(~\"0.4e+15\"), Ok(Number(0.4e15f)));\n+        assert_eq!(from_str(~\"0.4e-01\"), Ok(Number(0.4e-01f)));\n+        assert_eq!(from_str(~\" 3 \"), Ok(Number(3f)));\n     }\n \n     #[test]\n     fn test_read_str() {\n-        fail_unless!(from_str(~\"\\\"\") ==\n+        assert_eq!(from_str(~\"\\\"\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing string\"\n         }));\n-        fail_unless!(from_str(~\"\\\"lol\") ==\n+        assert_eq!(from_str(~\"\\\"lol\"),\n             Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing string\"\n         }));\n \n-        fail_unless!(from_str(~\"\\\"\\\"\") == Ok(String(~\"\")));\n-        fail_unless!(from_str(~\"\\\"foo\\\"\") == Ok(String(~\"foo\")));\n-        fail_unless!(from_str(~\"\\\"\\\\\\\"\\\"\") == Ok(String(~\"\\\"\")));\n-        fail_unless!(from_str(~\"\\\"\\\\b\\\"\") == Ok(String(~\"\\x08\")));\n-        fail_unless!(from_str(~\"\\\"\\\\n\\\"\") == Ok(String(~\"\\n\")));\n-        fail_unless!(from_str(~\"\\\"\\\\r\\\"\") == Ok(String(~\"\\r\")));\n-        fail_unless!(from_str(~\"\\\"\\\\t\\\"\") == Ok(String(~\"\\t\")));\n-        fail_unless!(from_str(~\" \\\"foo\\\" \") == Ok(String(~\"foo\")));\n+        assert_eq!(from_str(~\"\\\"\\\"\"), Ok(String(~\"\")));\n+        assert_eq!(from_str(~\"\\\"foo\\\"\"), Ok(String(~\"foo\")));\n+        assert_eq!(from_str(~\"\\\"\\\\\\\"\\\"\"), Ok(String(~\"\\\"\")));\n+        assert_eq!(from_str(~\"\\\"\\\\b\\\"\"), Ok(String(~\"\\x08\")));\n+        assert_eq!(from_str(~\"\\\"\\\\n\\\"\"), Ok(String(~\"\\n\")));\n+        assert_eq!(from_str(~\"\\\"\\\\r\\\"\"), Ok(String(~\"\\r\")));\n+        assert_eq!(from_str(~\"\\\"\\\\t\\\"\"), Ok(String(~\"\\t\")));\n+        assert_eq!(from_str(~\" \\\"foo\\\" \"), Ok(String(~\"foo\")));\n     }\n \n     #[test]\n     fn test_unicode_hex_escapes_in_str() {\n-        fail_unless!(from_str(~\"\\\"\\\\u12ab\\\"\") == Ok(String(~\"\\u12ab\")));\n-        fail_unless!(from_str(~\"\\\"\\\\uAB12\\\"\") == Ok(String(~\"\\uAB12\")));\n+        assert_eq!(from_str(~\"\\\"\\\\u12ab\\\"\"), Ok(String(~\"\\u12ab\")));\n+        assert_eq!(from_str(~\"\\\"\\\\uAB12\\\"\"), Ok(String(~\"\\uAB12\")));\n     }\n \n     #[test]\n     fn test_read_list() {\n-        fail_unless!(from_str(~\"[\") ==\n+        assert_eq!(from_str(~\"[\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing value\"}));\n-        fail_unless!(from_str(~\"[1\") ==\n+        assert_eq!(from_str(~\"[1\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing list\"}));\n-        fail_unless!(from_str(~\"[1,\") ==\n+        assert_eq!(from_str(~\"[1,\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"EOF while parsing value\"}));\n-        fail_unless!(from_str(~\"[1,]\") ==\n+        assert_eq!(from_str(~\"[1,]\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n-        fail_unless!(from_str(~\"[6 7]\") ==\n+        assert_eq!(from_str(~\"[6 7]\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"}));\n \n-        fail_unless!(from_str(~\"[]\") == Ok(List(~[])));\n-        fail_unless!(from_str(~\"[ ]\") == Ok(List(~[])));\n-        fail_unless!(from_str(~\"[true]\") == Ok(List(~[Boolean(true)])));\n-        fail_unless!(from_str(~\"[ false ]\") == Ok(List(~[Boolean(false)])));\n-        fail_unless!(from_str(~\"[null]\") == Ok(List(~[Null])));\n-        fail_unless!(from_str(~\"[3, 1]\") ==\n+        assert_eq!(from_str(~\"[]\"), Ok(List(~[])));\n+        assert_eq!(from_str(~\"[ ]\"), Ok(List(~[])));\n+        assert_eq!(from_str(~\"[true]\"), Ok(List(~[Boolean(true)])));\n+        assert_eq!(from_str(~\"[ false ]\"), Ok(List(~[Boolean(false)])));\n+        assert_eq!(from_str(~\"[null]\"), Ok(List(~[Null])));\n+        assert_eq!(from_str(~\"[3, 1]\"),\n                      Ok(List(~[Number(3f), Number(1f)])));\n-        fail_unless!(from_str(~\"\\n[3, 2]\\n\") ==\n+        assert_eq!(from_str(~\"\\n[3, 2]\\n\"),\n                      Ok(List(~[Number(3f), Number(2f)])));\n-        fail_unless!(from_str(~\"[2, [4, 1]]\") ==\n+        assert_eq!(from_str(~\"[2, [4, 1]]\"),\n                Ok(List(~[Number(2f), List(~[Number(4f), Number(1f)])])));\n     }\n \n     #[test]\n     fn test_read_object() {\n-        fail_unless!(from_str(~\"{\") ==\n+        assert_eq!(from_str(~\"{\"),\n             Err(Error {\n                 line: 1u,\n                 col: 2u,\n                 msg: @~\"EOF while parsing object\"}));\n-        fail_unless!(from_str(~\"{ \") ==\n+        assert_eq!(from_str(~\"{ \"),\n             Err(Error {\n                 line: 1u,\n                 col: 3u,\n                 msg: @~\"EOF while parsing object\"}));\n-        fail_unless!(from_str(~\"{1\") ==\n+        assert_eq!(from_str(~\"{1\"),\n             Err(Error {\n                 line: 1u,\n                 col: 2u,\n                 msg: @~\"key must be a string\"}));\n-        fail_unless!(from_str(~\"{ \\\"a\\\"\") ==\n+        assert_eq!(from_str(~\"{ \\\"a\\\"\"),\n             Err(Error {\n                 line: 1u,\n                 col: 6u,\n                 msg: @~\"EOF while parsing object\"}));\n-        fail_unless!(from_str(~\"{\\\"a\\\"\") ==\n+        assert_eq!(from_str(~\"{\\\"a\\\"\"),\n             Err(Error {\n                 line: 1u,\n                 col: 5u,\n                 msg: @~\"EOF while parsing object\"}));\n-        fail_unless!(from_str(~\"{\\\"a\\\" \") ==\n+        assert_eq!(from_str(~\"{\\\"a\\\" \"),\n             Err(Error {\n                 line: 1u,\n                 col: 6u,\n                 msg: @~\"EOF while parsing object\"}));\n \n-        fail_unless!(from_str(~\"{\\\"a\\\" 1\") ==\n+        assert_eq!(from_str(~\"{\\\"a\\\" 1\"),\n             Err(Error {line: 1u, col: 6u, msg: @~\"expected `:`\"}));\n-        fail_unless!(from_str(~\"{\\\"a\\\":\") ==\n+        assert_eq!(from_str(~\"{\\\"a\\\":\"),\n             Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing value\"}));\n-        fail_unless!(from_str(~\"{\\\"a\\\":1\") ==\n+        assert_eq!(from_str(~\"{\\\"a\\\":1\"),\n             Err(Error {\n                 line: 1u,\n                 col: 7u,\n                 msg: @~\"EOF while parsing object\"}));\n-        fail_unless!(from_str(~\"{\\\"a\\\":1 1\") ==\n+        assert_eq!(from_str(~\"{\\\"a\\\":1 1\"),\n             Err(Error {line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"}));\n-        fail_unless!(from_str(~\"{\\\"a\\\":1,\") ==\n+        assert_eq!(from_str(~\"{\\\"a\\\":1,\"),\n             Err(Error {\n                 line: 1u,\n                 col: 8u,\n                 msg: @~\"EOF while parsing object\"}));\n \n-        fail_unless!(result::unwrap(from_str(~\"{}\")) == mk_object(~[]));\n-        fail_unless!(result::unwrap(from_str(~\"{\\\"a\\\": 3}\")) ==\n+        assert_eq!(result::unwrap(from_str(~\"{}\")), mk_object(~[]));\n+        assert_eq!(result::unwrap(from_str(~\"{\\\"a\\\": 3}\")),\n                   mk_object(~[(~\"a\", Number(3.0f))]));\n \n-        fail_unless!(result::unwrap(from_str(\n-                ~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")) ==\n+        assert_eq!(result::unwrap(from_str(\n+                ~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n                   mk_object(~[\n                       (~\"a\", Null),\n                       (~\"b\", Boolean(true))]));\n-        fail_unless!(result::unwrap(\n-                      from_str(~\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")) ==\n+        assert_eq!(result::unwrap(\n+                      from_str(~\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n                   mk_object(~[\n                       (~\"a\", Null),\n                       (~\"b\", Boolean(true))]));\n-        fail_unless!(result::unwrap(from_str(\n-                ~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")) ==\n+        assert_eq!(result::unwrap(from_str(\n+                ~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n                   mk_object(~[\n                       (~\"a\", Number(1.0)),\n                       (~\"b\", List(~[Boolean(true)]))\n                   ]));\n-        fail_unless!(result::unwrap(from_str(\n+        assert_eq!(result::unwrap(from_str(\n                       ~\"{\" +\n                           ~\"\\\"a\\\": 1.0, \" +\n                           ~\"\\\"b\\\": [\" +\n                               ~\"true,\" +\n                               ~\"\\\"foo\\\\nbar\\\", \" +\n                               ~\"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n                           ~\"]\" +\n-                      ~\"}\")) ==\n+                      ~\"}\")),\n                   mk_object(~[\n                       (~\"a\", Number(1.0f)),\n                       (~\"b\", List(~[\n@@ -1528,9 +1705,37 @@ mod tests {\n                   ]));\n     }\n \n+    #[test]\n+    fn test_read_none() {\n+        let decoder = Decoder(from_str(~\"null\").unwrap());\n+        let value: Option<~str> = Decodable::decode(&decoder);\n+        assert_eq!(value, None);\n+    }\n+\n+    #[test]\n+    fn test_read_some() {\n+        let decoder = Decoder(from_str(~\"\\\"jodhpurs\\\"\").unwrap());\n+        let value: Option<~str> = Decodable::decode(&decoder);\n+        assert_eq!(value, Some(~\"jodhpurs\"));\n+    }\n+\n+    #[test]\n+    fn test_read_enum_no_args() {\n+        let decoder = Decoder(from_str(~\"\\\"Dog\\\"\").unwrap());\n+        let value: Animal = Decodable::decode(&decoder);\n+        assert_eq!(value, Dog);\n+    }\n+\n+    #[test]\n+    fn test_read_enum_multiple_args() {\n+        let decoder = Decoder(from_str(~\"[\\\"Frog\\\",\\\"Henry\\\",349]\").unwrap());\n+        let value: Animal = Decodable::decode(&decoder);\n+        assert_eq!(value, Frog(~\"Henry\", 349));\n+    }\n+\n     #[test]\n     fn test_multiline_errors() {\n-        fail_unless!(from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n+        assert_eq!(from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n             Err(Error {\n                 line: 3u,\n                 col: 8u,"}, {"sha": "ed4f3e957c02af8258f6762569a0039730ec3420", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -182,4 +182,18 @@ impl serialize::Encoder for Serializer {\n         if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }\n+\n+    fn emit_option(&self, f: &fn()) {\n+        f();\n+    }\n+\n+    fn emit_option_none(&self) {\n+        self.wr.write_str(\"None\");\n+    }\n+\n+    fn emit_option_some(&self, f: &fn()) {\n+        self.wr.write_str(\"Some(\");\n+        f();\n+        self.wr.write_char(')');\n+    }\n }"}, {"sha": "02f4a934874325bc73ab582ecc2e4fdb624a4b53", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -62,6 +62,11 @@ pub trait Encoder {\n \n     fn emit_tup(&self, len: uint, f: &fn());\n     fn emit_tup_elt(&self, idx: uint, f: &fn());\n+\n+    // Specialized types:\n+    fn emit_option(&self, f: &fn());\n+    fn emit_option_none(&self);\n+    fn emit_option_some(&self, f: &fn());\n }\n \n pub trait Decoder {\n@@ -87,7 +92,15 @@ pub trait Decoder {\n \n     // Compound types:\n     fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T;\n+\n+    #[cfg(stage0)]\n     fn read_enum_variant<T>(&self, f: &fn(uint) -> T) -> T;\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T;\n+\n     fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T;\n \n     fn read_owned<T>(&self, f: &fn() -> T) -> T;\n@@ -103,6 +116,9 @@ pub trait Decoder {\n \n     fn read_tup<T>(&self, sz: uint, f: &fn() -> T) -> T;\n     fn read_tup_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n+\n+    // Specialized types:\n+    fn read_option<T>(&self, f: &fn() -> T) -> Option<T>;\n }\n \n pub trait Encodable<S:Encoder> {\n@@ -368,31 +384,18 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &S) {\n-        do s.emit_enum(~\"option\") {\n+        do s.emit_option {\n             match *self {\n-              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n-              },\n-\n-              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n-                s.emit_enum_variant_arg(0u, || v.encode(s))\n-              }\n+                None => s.emit_option_none(),\n+                Some(ref v) => s.emit_option_some(|| v.encode(s)),\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n     fn decode(d: &D) -> Option<T> {\n-        do d.read_enum(~\"option\") {\n-            do d.read_enum_variant |i| {\n-                match i {\n-                  0 => None,\n-                  1 => Some(d.read_enum_variant_arg(\n-                      0u, || Decodable::decode(d))),\n-                  _ => fail!(fmt!(\"Bad variant for option: %u\", i))\n-                }\n-            }\n-        }\n+        d.read_option(|| Decodable::decode(d))\n     }\n }\n "}, {"sha": "6b788810a790092d1ed3e8e87c7111d7a45ebb9a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -386,7 +386,6 @@ pub enum vstore {\n #[auto_decode]\n #[deriving(Eq)]\n pub enum expr_vstore {\n-    expr_vstore_fixed(Option<uint>),   // [1,2,3,4]\n     expr_vstore_uniq,                  // ~[1,2,3,4]\n     expr_vstore_box,                   // @[1,2,3,4]\n     expr_vstore_mut_box,               // @mut [1,2,3,4]\n@@ -543,12 +542,6 @@ pub struct expr {\n     span: span,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n-pub enum log_level { error, debug, log_other }\n-// 0 = error, 1 = debug, 2 = log_other\n-\n #[auto_encode]\n #[auto_decode]\n #[deriving(Eq)]\n@@ -598,7 +591,7 @@ pub enum expr_ {\n     expr_break(Option<ident>),\n     expr_again(Option<ident>),\n     expr_ret(Option<@expr>),\n-    expr_log(log_level, @expr, @expr),\n+    expr_log(@expr, @expr),\n \n     expr_inline_asm(@~str,              // asm\n                     ~[(@~str, @expr)],  // inputs"}, {"sha": "2a112f106a850b43f9eb1a46b309b5b4b362ba73", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 84, "deletions": 12, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -1059,6 +1059,18 @@ fn mk_enum_deser_body(\n     name: ast::ident,\n     variants: ~[ast::variant]\n ) -> @ast::expr {\n+    let expr_arm_names = build::mk_base_vec_e(\n+        ext_cx,\n+        span,\n+         do variants.map |variant| {\n+            build::mk_base_str(\n+                ext_cx,\n+                span,\n+                ext_cx.str_of(variant.node.name)\n+            )\n+        }\n+    );\n+\n     let mut arms = do variants.mapi |v_idx, variant| {\n         let body = match variant.node.kind {\n             ast::tuple_variant_kind(ref args) => {\n@@ -1152,13 +1164,13 @@ fn mk_enum_deser_body(\n         )\n     );\n \n-    // ast for `__d.read_enum_variant($(expr_lambda))`\n+    // ast for `__d.read_enum_variant($expr_arm_names, $(expr_lambda))`\n     let expr_lambda = ext_cx.lambda_expr(\n         ext_cx.expr_method_call(\n             span,\n             ext_cx.expr_var(span, ~\"__d\"),\n             ext_cx.ident_of(~\"read_enum_variant\"),\n-            ~[expr_lambda]\n+            ~[expr_arm_names, expr_lambda]\n         )\n     );\n \n@@ -1174,9 +1186,9 @@ fn mk_enum_deser_body(\n     )\n }\n \n-\n #[cfg(test)]\n mod test {\n+    use core::option::{None, Some};\n     use std::serialize::Encodable;\n     use std::serialize::Encoder;\n \n@@ -1190,6 +1202,9 @@ mod test {\n         CallToEmitNil,\n         CallToEmitStruct(~str,uint),\n         CallToEmitField(~str,uint),\n+        CallToEmitOption,\n+        CallToEmitOptionNone,\n+        CallToEmitOptionSome,\n         // all of the ones I was too lazy to handle:\n         CallToOther\n     }\n@@ -1281,6 +1296,18 @@ mod test {\n         fn emit_tup_elt(&self, +_idx: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n+\n+        fn emit_option(&self, f: &fn()) {\n+            self.add_to_log(CallToEmitOption);\n+            f();\n+        }\n+        fn emit_option_none(&self) {\n+            self.add_to_log(CallToEmitOptionNone);\n+        }\n+        fn emit_option_some(&self, f: &fn()) {\n+            self.add_to_log(CallToEmitOptionSome);\n+            f();\n+        }\n     }\n \n \n@@ -1296,13 +1323,58 @@ mod test {\n         Magazine(~str)\n     }\n \n-    #[test] fn encode_enum_test () {\n-        assert_eq!(to_call_log(Book(34,44)),\n-                     ~[CallToEmitEnum (~\"Written\"),\n-                       CallToEmitEnumVariant (~\"Book\",0,2),\n-                       CallToEmitEnumVariantArg (0),\n-                       CallToEmitUint (34),\n-                       CallToEmitEnumVariantArg (1),\n-                       CallToEmitUint (44)]);\n-        }\n+    #[test]\n+    fn test_encode_enum() {\n+        assert_eq!(\n+            to_call_log(Book(34,44)),\n+            ~[\n+                CallToEmitEnum(~\"Written\"),\n+                CallToEmitEnumVariant(~\"Book\",0,2),\n+                CallToEmitEnumVariantArg(0),\n+                CallToEmitUint(34),\n+                CallToEmitEnumVariantArg(1),\n+                CallToEmitUint(44),\n+            ]\n+        );\n+    }\n+\n+    pub struct BPos(uint);\n+\n+    #[auto_encode]\n+    pub struct HasPos { pos : BPos }\n+\n+    #[test]\n+    fn test_encode_newtype() {\n+        assert_eq!(\n+            to_call_log(HasPos { pos:BPos(48) }),\n+            ~[\n+                CallToEmitStruct(~\"HasPos\",1),\n+                CallToEmitField(~\"pos\",0),\n+                CallToEmitUint(48),\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_encode_option() {\n+        let mut v = None;\n+\n+        assert_eq!(\n+            to_call_log(v),\n+            ~[\n+                CallToEmitOption,\n+                CallToEmitOptionNone,\n+            ]\n+        );\n+\n+        v = Some(54u);\n+        assert_eq!(\n+            to_call_log(v),\n+            ~[\n+                CallToEmitOption,\n+                CallToEmitOptionSome,\n+                CallToEmitUint(54)\n+            ]\n+        );\n+    }\n }"}, {"sha": "9499f95f0e76feef79e8b8ec2ec6641bfd525a2a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -152,11 +152,6 @@ pub fn mk_slice_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_slice)\n }\n-pub fn mk_fixed_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n-                   -> @ast::expr {\n-    mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n-                ast::expr_vstore_fixed(None))\n-}\n pub fn mk_base_str(cx: @ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n     let lit = ast::lit_str(@s);\n     return mk_lit(cx, sp, lit);"}, {"sha": "a6f078d07b42092e7d8afd6cc4ae63017980a3b3", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 161, "deletions": 6, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -42,8 +42,7 @@ pub mod rt {\n     pub use ast::*;\n     pub use parse::token::*;\n     pub use parse::new_parser_from_tts;\n-    pub use codemap::BytePos;\n-    pub use codemap::span;\n+    pub use codemap::{BytePos, span, dummy_spanned};\n \n     use print::pprust;\n     use print::pprust::{item_to_str, ty_to_str};\n@@ -89,7 +88,7 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for ~[@ast::item] {\n+    impl<'self> ToSource for &'self [@ast::item] {\n         fn to_source(&self, cx: @ext_ctxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), ~\"\\n\\n\")\n         }\n@@ -101,7 +100,7 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for ~[@ast::Ty] {\n+    impl<'self> ToSource for &'self [@ast::Ty] {\n         fn to_source(&self, cx: @ext_ctxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), ~\", \")\n         }\n@@ -119,6 +118,90 @@ pub mod rt {\n         }\n     }\n \n+    impl ToSource for ast::blk {\n+        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+            pprust::block_to_str(self, cx.parse_sess().interner)\n+        }\n+    }\n+\n+    impl<'self> ToSource for &'self str {\n+        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+            let lit = dummy_spanned(ast::lit_str(@str::from_slice(*self)));\n+            pprust::lit_to_str(@lit)\n+        }\n+    }\n+\n+    impl ToSource for int {\n+        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+            let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i));\n+            pprust::lit_to_str(@lit)\n+        }\n+    }\n+\n+    impl ToSource for i8 {\n+        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+            let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i8));\n+            pprust::lit_to_str(@lit)\n+        }\n+    }\n+\n+    impl ToSource for i16 {\n+        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+            let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i16));\n+            pprust::lit_to_str(@lit)\n+        }\n+    }\n+\n+\n+    impl ToSource for i32 {\n+        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+            let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i32));\n+            pprust::lit_to_str(@lit)\n+        }\n+    }\n+\n+    impl ToSource for i64 {\n+        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+            let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i64));\n+            pprust::lit_to_str(@lit)\n+        }\n+    }\n+\n+    impl ToSource for uint {\n+        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+            let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u));\n+            pprust::lit_to_str(@lit)\n+        }\n+    }\n+\n+    impl ToSource for u8 {\n+        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+            let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u8));\n+            pprust::lit_to_str(@lit)\n+        }\n+    }\n+\n+    impl ToSource for u16 {\n+        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+            let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u16));\n+            pprust::lit_to_str(@lit)\n+        }\n+    }\n+\n+    impl ToSource for u32 {\n+        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+            let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u32));\n+            pprust::lit_to_str(@lit)\n+        }\n+    }\n+\n+    impl ToSource for u64 {\n+        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+            let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u64));\n+            pprust::lit_to_str(@lit)\n+        }\n+    }\n+\n     // Alas ... we write these out instead. All redundant.\n \n     impl ToTokens for ast::ident {\n@@ -133,7 +216,7 @@ pub mod rt {\n         }\n     }\n \n-    impl ToTokens for ~[@ast::item] {\n+    impl<'self> ToTokens for &'self [@ast::item] {\n         fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n@@ -145,7 +228,7 @@ pub mod rt {\n         }\n     }\n \n-    impl ToTokens for ~[@ast::Ty] {\n+    impl<'self> ToTokens for &'self [@ast::Ty] {\n         fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n@@ -163,6 +246,78 @@ pub mod rt {\n         }\n     }\n \n+    impl ToTokens for ast::blk {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n+    impl<'self> ToTokens for &'self str {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n+    impl ToTokens for int {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n+    impl ToTokens for i8 {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n+    impl ToTokens for i16 {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n+    impl ToTokens for i32 {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n+    impl ToTokens for i64 {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n+    impl ToTokens for uint {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n+    impl ToTokens for u8 {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n+    impl ToTokens for u16 {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n+    impl ToTokens for u32 {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n+    impl ToTokens for u64 {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+            cx.parse_tts(self.to_source(cx))\n+        }\n+    }\n+\n     pub trait ExtParseUtils {\n         fn parse_item(&self, s: ~str) -> @ast::item;\n         fn parse_expr(&self, s: ~str) -> @ast::expr;"}, {"sha": "279d57a291e2995f77b0108d9ba101bf2b6e035b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -552,9 +552,8 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n         expr_ret(ref e) => {\n             expr_ret(e.map(|x| fld.fold_expr(*x)))\n         }\n-        expr_log(i, lv, e) => {\n+        expr_log(lv, e) => {\n             expr_log(\n-                i,\n                 fld.fold_expr(lv),\n                 fld.fold_expr(e)\n             )"}, {"sha": "0ddf9111e025550c017a7eb96e0f559e9d1a32f7", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -326,19 +326,32 @@ mod test {\n             @~\"fn foo (x : int) { x; }\",\n             ~[],\n             new_parse_sess(None));\n-        assert_eq!(to_json_str(@tts),\n-                    ~\"[[\\\"tt_tok\\\",[null,[\\\"IDENT\\\",[\\\"fn\\\",false]]]],\\\n-                      [\\\"tt_tok\\\",[null,[\\\"IDENT\\\",[\\\"foo\\\",false]]]],\\\n-                      [\\\"tt_delim\\\",[[[\\\"tt_tok\\\",[null,[\\\"LPAREN\\\",[]]]],\\\n-                      [\\\"tt_tok\\\",[null,[\\\"IDENT\\\",[\\\"x\\\",false]]]],\\\n-                      [\\\"tt_tok\\\",[null,[\\\"COLON\\\",[]]]],\\\n-                      [\\\"tt_tok\\\",[null,[\\\"IDENT\\\",[\\\"int\\\",false]]]],\\\n-                      [\\\"tt_tok\\\",[null,[\\\"RPAREN\\\",[]]]]]]],\\\n-                      [\\\"tt_delim\\\",[[[\\\"tt_tok\\\",[null,[\\\"LBRACE\\\",[]]]],\\\n-                      [\\\"tt_tok\\\",[null,[\\\"IDENT\\\",[\\\"x\\\",false]]]],\\\n-                      [\\\"tt_tok\\\",[null,[\\\"SEMI\\\",[]]]],\\\n-                      [\\\"tt_tok\\\",[null,[\\\"RBRACE\\\",[]]]]]]]]\"\n-                   );\n+        assert_eq!(\n+            to_json_str(@tts),\n+            ~\"[\\\n+                [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"fn\\\",false]],\\\n+                [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"foo\\\",false]],\\\n+                [\\\n+                    \\\"tt_delim\\\",\\\n+                    [\\\n+                        [\\\"tt_tok\\\",null,\\\"LPAREN\\\"],\\\n+                        [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"x\\\",false]],\\\n+                        [\\\"tt_tok\\\",null,\\\"COLON\\\"],\\\n+                        [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"int\\\",false]],\\\n+                        [\\\"tt_tok\\\",null,\\\"RPAREN\\\"]\\\n+                    ]\\\n+                ],\\\n+                [\\\n+                    \\\"tt_delim\\\",\\\n+                    [\\\n+                        [\\\"tt_tok\\\",null,\\\"LBRACE\\\"],\\\n+                        [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"x\\\",false]],\\\n+                        [\\\"tt_tok\\\",null,\\\"SEMI\\\"],\\\n+                        [\\\"tt_tok\\\",null,\\\"RBRACE\\\"]\\\n+                    ]\\\n+                ]\\\n+            ]\"\n+        );\n         let ast1 = new_parser_from_tts(new_parse_sess(None),~[],tts)\n             .parse_item(~[]);\n         let ast2 = parse_item_from_source_str("}, {"sha": "6ca91791ffde4a5cc6abcba6e5e1088d0176ad80", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -28,7 +28,7 @@ use ast::{expr_lit, expr_log, expr_loop, expr_loop_body, expr_mac};\n use ast::{expr_method_call, expr_paren, expr_path, expr_repeat};\n use ast::{expr_ret, expr_swap, expr_struct, expr_tup, expr_unary};\n use ast::{expr_vec, expr_vstore, expr_vstore_mut_box, expr_inline_asm};\n-use ast::{expr_vstore_fixed, expr_vstore_slice, expr_vstore_box};\n+use ast::{expr_vstore_slice, expr_vstore_box};\n use ast::{expr_vstore_mut_slice, expr_while, extern_fn, field, fn_decl};\n use ast::{expr_vstore_uniq, TyClosure, TyBareFn, Onceness, Once, Many};\n use ast::{foreign_item, foreign_item_const, foreign_item_fn, foreign_mod};\n@@ -1223,7 +1223,7 @@ pub impl Parser {\n             let lvl = self.parse_expr();\n             self.expect(&token::COMMA);\n             let e = self.parse_expr();\n-            ex = expr_log(ast::log_other, lvl, e);\n+            ex = expr_log(lvl, e);\n             hi = self.span.hi;\n             self.expect(&token::RPAREN);\n         } else if self.eat_keyword(&~\"return\") {\n@@ -2721,8 +2721,9 @@ pub impl Parser {\n                     }\n                     self.bump();\n                 }\n-                token::IDENT(*) => {\n+                token::MOD_SEP | token::IDENT(*) => {\n                     let maybe_bound = match *self.token {\n+                        token::MOD_SEP => None,\n                         token::IDENT(copy sid, _) => {\n                             match *self.id_to_str(sid) {\n                                 ~\"send\" |\n@@ -2750,7 +2751,7 @@ pub impl Parser {\n                             result.push(bound);\n                         }\n                         None => {\n-                            let ty = self.parse_ty(false);\n+                            let ty = self.parse_ty(true);\n                             result.push(TraitTyParamBound(ty));\n                         }\n                     }\n@@ -3099,14 +3100,6 @@ pub impl Parser {\n     //    impl<T> Foo { ... }\n     //    impl<T> ToStr for ~[T] { ... }\n     fn parse_item_impl(&self, visibility: ast::visibility) -> item_info {\n-        fn wrap_path(p: &Parser, pt: @path) -> @Ty {\n-            @Ty {\n-                id: p.get_id(),\n-                node: ty_path(pt, p.get_id()),\n-                span: pt.span,\n-            }\n-        }\n-\n         // First, parse type parameters if necessary.\n         let generics = self.parse_generics();\n "}, {"sha": "cb142ef3f5487808cf0ae7034788707eeb3ab47e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -325,7 +325,7 @@ pub fn commasep<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n                          get_span: &fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n-    let len = vec::len::<IN>(elts);\n+    let len = elts.len();\n     let mut i = 0u;\n     for elts.each |elt| {\n         maybe_print_comment(s, get_span(*elt).hi);\n@@ -1029,8 +1029,6 @@ pub fn print_vstore(s: @ps, t: ast::vstore) {\n \n pub fn print_expr_vstore(s: @ps, t: ast::expr_vstore) {\n     match t {\n-      ast::expr_vstore_fixed(Some(i)) => word(s.s, fmt!(\"%u\", i)),\n-      ast::expr_vstore_fixed(None) => word(s.s, ~\"_\"),\n       ast::expr_vstore_uniq => word(s.s, ~\"~\"),\n       ast::expr_vstore_box => word(s.s, ~\"@\"),\n       ast::expr_vstore_mut_box => {\n@@ -1105,16 +1103,9 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n     let ann_node = node_expr(s, expr);\n     (s.ann.pre)(ann_node);\n     match expr.node {\n-        ast::expr_vstore(e, v) => match v {\n-            ast::expr_vstore_fixed(_) => {\n-                print_expr(s, e);\n-                word(s.s, ~\"/\");\n-                print_expr_vstore(s, v);\n-            }\n-            _ => {\n-                print_expr_vstore(s, v);\n-                print_expr(s, e);\n-            }\n+        ast::expr_vstore(e, v) => {\n+            print_expr_vstore(s, v);\n+            print_expr(s, e);\n         },\n       ast::expr_vec(ref exprs, mutbl) => {\n         ibox(s, indent_unit);\n@@ -1391,20 +1382,14 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n           _ => ()\n         }\n       }\n-      ast::expr_log(lvl, lexp, expr) => {\n-        match lvl {\n-          ast::debug => { word_nbsp(s, ~\"log\"); print_expr(s, expr); }\n-          ast::error => { word_nbsp(s, ~\"log_err\"); print_expr(s, expr); }\n-          ast::log_other => {\n-            word_nbsp(s, ~\"log\");\n-            popen(s);\n-            print_expr(s, lexp);\n-            word(s.s, ~\",\");\n-            space_if_not_bol(s);\n-            print_expr(s, expr);\n-            pclose(s);\n-          }\n-        }\n+      ast::expr_log(lexp, expr) => {\n+        word(s.s, ~\"__log\");\n+        popen(s);\n+        print_expr(s, lexp);\n+        word(s.s, ~\",\");\n+        space_if_not_bol(s);\n+        print_expr(s, expr);\n+        pclose(s);\n       }\n       ast::expr_inline_asm(a, in, out, c, v, _) => {\n         if v {\n@@ -2139,7 +2124,7 @@ pub fn print_comment(s: @ps, cmnt: comments::cmnt) {\n     }\n }\n \n-pub fn print_string(s: @ps, st: ~str) {\n+pub fn print_string(s: @ps, st: &str) {\n     word(s.s, ~\"\\\"\");\n     word(s.s, str::escape_default(st));\n     word(s.s, ~\"\\\"\");"}, {"sha": "2bdf26fba586270bf2032bba8430b75d4cb40e74", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -559,7 +559,7 @@ pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         expr_break(_) => (),\n         expr_again(_) => (),\n         expr_ret(eo) => visit_expr_opt(eo, e, v),\n-        expr_log(_, lv, x) => {\n+        expr_log(lv, x) => {\n             (v.visit_expr)(lv, e, v);\n             (v.visit_expr)(x, e, v);\n         }"}, {"sha": "d0db5e5cb3ce467113d7b89364741237ea010ea7", "filename": "src/test/run-pass/issue-5572.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Ftest%2Frun-pass%2Fissue-5572.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ddff3909b5920228642649b7f5cc011c0b900a/src%2Ftest%2Frun-pass%2Fissue-5572.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5572.rs?ref=84ddff3909b5920228642649b7f5cc011c0b900a", "patch": "@@ -0,0 +1,3 @@\n+fn foo<T: ::cmp::Eq>(t: T) { }\n+\n+fn main() { }"}]}