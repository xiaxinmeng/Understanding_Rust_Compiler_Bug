{"sha": "59337cddd41880f8075b07860a99be4dc402ddb1", "node_id": "C_kwDOAAsO6NoAKDU5MzM3Y2RkZDQxODgwZjgwNzViMDc4NjBhOTliZTRkYzQwMmRkYjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-24T04:59:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-24T04:59:05Z"}, "message": "Auto merge of #91342 - RalfJung:fn-abi, r=eddyb,oli-obk\n\nCTFE eval_fn_call: use FnAbi to determine argument skipping and compatibility\n\nThis makes use of the `FnAbi` type in CTFE/Miri, which `@eddyb` has been saying for years is what we should do.^^ `FnAbi` is used to\n- determine which arguments to skip (rather than the previous heuristic of skipping ZST arguments with the Rust ABI)\n- impose further restrictions on whether caller and callee are consistent in how a given argument is passed\n\nI was hoping it would also simplify the code, but that is not the case -- the previous type compatibility checks are still required (AFAIK), only the ZST skipping is gone and that took barely any code. We also need some hacks because `FnAbi` assumes a certain way of implementing `caller_location` (by passing extra arguments), but Miri can just read the caller location from the call stack so it doesn't need those arguments. (The fact that every backend has to separately implement support for these arguments seems suboptimal -- looks like this might have been better implemented on the MIR level.) To avoid having to implement those unnecessary arguments in Miri, we just compute *whether* the argument is present on the caller/callee side, but don't actually pass that argument around.\n\nI have no idea if this looks the way `@eddyb` thinks it should look... but it makes Miri's test suite pass. ;)\nOne of rustc's tests fails unfortunately (`ui/const-generics/issues/issue-67739.rs`), some const generic code that is evaluated too early -- I think that should raise `TooGeneric` but instead it ICEs. My assumption is this is some FnAbi code that has not been properly tested on polymorphic code, but it might also be me calling that FnAbi code the wrong way.\n\nr? `@oli-obk` `@eddyb`\nFixes https://github.com/rust-lang/rust/issues/56166\nMiri PR at https://github.com/rust-lang/miri/pull/1928", "tree": {"sha": "3980802e91f1ed0b8d5834e9e1d3c0c5588fcf2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3980802e91f1ed0b8d5834e9e1d3c0c5588fcf2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59337cddd41880f8075b07860a99be4dc402ddb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59337cddd41880f8075b07860a99be4dc402ddb1", "html_url": "https://github.com/rust-lang/rust/commit/59337cddd41880f8075b07860a99be4dc402ddb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59337cddd41880f8075b07860a99be4dc402ddb1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6f1f04e5215124244dfc87a5f9867580bf9386b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6f1f04e5215124244dfc87a5f9867580bf9386b", "html_url": "https://github.com/rust-lang/rust/commit/e6f1f04e5215124244dfc87a5f9867580bf9386b"}, {"sha": "56b7d5fc494639ad58111a73028dcee965df7246", "url": "https://api.github.com/repos/rust-lang/rust/commits/56b7d5fc494639ad58111a73028dcee965df7246", "html_url": "https://github.com/rust-lang/rust/commit/56b7d5fc494639ad58111a73028dcee965df7246"}], "stats": {"total": 385, "additions": 238, "deletions": 147}, "files": [{"sha": "fef0e00e507ebc698f7bd27ea0a85c0c6d0867d4", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=59337cddd41880f8075b07860a99be4dc402ddb1", "patch": "@@ -260,7 +260,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         args: &[OpTy<'tcx>],\n         _ret: Option<(&PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: StackPopUnwind, // unwinding is not supported in consts\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n \n         // Only check non-glue functions\n@@ -279,11 +279,21 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n             if let Some(new_instance) = ecx.hook_special_const_fn(instance, args)? {\n                 // We call another const fn instead.\n-                return Self::find_mir_or_eval_fn(ecx, new_instance, _abi, args, _ret, _unwind);\n+                // However, we return the *original* instance to make backtraces work out\n+                // (and we hope this does not confuse the FnAbi checks too much).\n+                return Ok(Self::find_mir_or_eval_fn(\n+                    ecx,\n+                    new_instance,\n+                    _abi,\n+                    args,\n+                    _ret,\n+                    _unwind,\n+                )?\n+                .map(|(body, _instance)| (body, instance)));\n             }\n         }\n         // This is a const fn. Call it.\n-        Ok(Some(ecx.load_mir(instance.def, None)?))\n+        Ok(Some((ecx.load_mir(instance.def, None)?, instance)))\n     }\n \n     fn call_intrinsic("}, {"sha": "246807a112a40b733c4290e44aed653c72898f1a", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=59337cddd41880f8075b07860a99be4dc402ddb1", "patch": "@@ -8,15 +8,18 @@ use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{InterpError, InvalidProgramInfo};\n-use rustc_middle::ty::layout::{self, LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n+use rustc_middle::ty::layout::{\n+    self, FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOf, LayoutOfHelpers,\n+    TyAndLayout,\n+};\n use rustc_middle::ty::{\n     self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_mir_dataflow::storage::AlwaysLiveLocals;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::Limit;\n use rustc_span::{Pos, Span};\n-use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n+use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n     AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine, MemPlace,\n@@ -333,6 +336,24 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOfHelpers<'tcx> for InterpC\n     }\n }\n \n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> FnAbiOfHelpers<'tcx> for InterpCx<'mir, 'tcx, M> {\n+    type FnAbiOfResult = InterpResult<'tcx, &'tcx FnAbi<'tcx, Ty<'tcx>>>;\n+\n+    fn handle_fn_abi_err(\n+        &self,\n+        err: FnAbiError<'tcx>,\n+        _span: Span,\n+        _fn_abi_request: FnAbiRequest<'tcx>,\n+    ) -> InterpErrorInfo<'tcx> {\n+        match err {\n+            FnAbiError::Layout(err) => err_inval!(Layout(err)).into(),\n+            FnAbiError::AdjustForForeignAbi(err) => {\n+                err_inval!(FnAbiAdjustForForeignAbi(err)).into()\n+            }\n+        }\n+    }\n+}\n+\n /// Test if it is valid for a MIR assignment to assign `src`-typed place to `dest`-typed value.\n /// This test should be symmetric, as it is primarily about layout compatibility.\n pub(super) fn mir_assign_valid_types<'tcx>("}, {"sha": "6a03b699d47d442e945b6416764fbd47b5f18a23", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=59337cddd41880f8075b07860a99be4dc402ddb1", "patch": "@@ -167,7 +167,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         ret: Option<(&PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n         unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>>;\n \n     /// Execute `fn_val`.  It is the hook's responsibility to advance the instruction\n     /// pointer as appropriate."}, {"sha": "f3910c9765d2e65c91685ff5339ceba640375a80", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 185, "deletions": 133, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=59337cddd41880f8075b07860a99be4dc402ddb1", "patch": "@@ -1,14 +1,14 @@\n use std::borrow::Cow;\n use std::convert::TryFrom;\n \n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_middle::ty::layout::{self, LayoutOf as _, TyAndLayout};\n+use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_middle::ty::Instance;\n use rustc_middle::{\n     mir,\n     ty::{self, Ty},\n };\n use rustc_target::abi;\n+use rustc_target::abi::call::{ArgAbi, ArgAttribute, ArgAttributes, FnAbi, PassMode};\n use rustc_target::spec::abi::Abi;\n \n use super::{\n@@ -17,10 +17,6 @@ use super::{\n };\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    fn fn_can_unwind(&self, attrs: CodegenFnAttrFlags, abi: Abi) -> bool {\n-        layout::fn_can_unwind(*self.tcx, attrs, abi)\n-    }\n-\n     pub(super) fn eval_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n@@ -64,25 +60,27 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let old_stack = self.frame_idx();\n                 let old_loc = self.frame().loc;\n                 let func = self.eval_operand(func, None)?;\n-                let (fn_val, abi, caller_can_unwind) = match *func.layout.ty.kind() {\n-                    ty::FnPtr(sig) => {\n-                        let caller_abi = sig.abi();\n+                let args = self.eval_operands(args)?;\n+\n+                let fn_sig_binder = func.layout.ty.fn_sig(*self.tcx);\n+                let fn_sig =\n+                    self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig_binder);\n+                let extra_args = &args[fn_sig.inputs().len()..];\n+                let extra_args = self.tcx.mk_type_list(extra_args.iter().map(|arg| arg.layout.ty));\n+\n+                let (fn_val, fn_abi, with_caller_location) = match *func.layout.ty.kind() {\n+                    ty::FnPtr(_sig) => {\n                         let fn_ptr = self.read_pointer(&func)?;\n                         let fn_val = self.memory.get_fn(fn_ptr)?;\n-                        (\n-                            fn_val,\n-                            caller_abi,\n-                            self.fn_can_unwind(CodegenFnAttrFlags::empty(), caller_abi),\n-                        )\n+                        (fn_val, self.fn_abi_of_fn_ptr(fn_sig_binder, extra_args)?, false)\n                     }\n                     ty::FnDef(def_id, substs) => {\n-                        let sig = func.layout.ty.fn_sig(*self.tcx);\n+                        let instance =\n+                            self.resolve(ty::WithOptConstParam::unknown(def_id), substs)?;\n                         (\n-                            FnVal::Instance(\n-                                self.resolve(ty::WithOptConstParam::unknown(def_id), substs)?,\n-                            ),\n-                            sig.abi(),\n-                            self.fn_can_unwind(self.tcx.codegen_fn_attrs(def_id).flags, sig.abi()),\n+                            FnVal::Instance(instance),\n+                            self.fn_abi_of_instance(instance, extra_args)?,\n+                            instance.def.requires_caller_location(*self.tcx),\n                         )\n                     }\n                     _ => span_bug!(\n@@ -91,7 +89,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         func.layout.ty\n                     ),\n                 };\n-                let args = self.eval_operands(args)?;\n+\n                 let dest_place;\n                 let ret = match destination {\n                     Some((dest, ret)) => {\n@@ -102,10 +100,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 self.eval_fn_call(\n                     fn_val,\n-                    abi,\n+                    (fn_sig.abi, fn_abi),\n                     &args,\n+                    with_caller_location,\n                     ret,\n-                    match (cleanup, caller_can_unwind) {\n+                    match (cleanup, fn_abi.can_unwind) {\n                         (Some(cleanup), true) => StackPopUnwind::Cleanup(*cleanup),\n                         (None, true) => StackPopUnwind::Skip,\n                         (_, false) => StackPopUnwind::NotAllowed,\n@@ -174,68 +173,128 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     fn check_argument_compat(\n-        rust_abi: bool,\n-        caller: TyAndLayout<'tcx>,\n-        callee: TyAndLayout<'tcx>,\n+        caller_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+        callee_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ) -> bool {\n-        if caller.ty == callee.ty {\n-            // No question\n+        // Heuristic for type comparison.\n+        let layout_compat = || {\n+            if caller_abi.layout.ty == callee_abi.layout.ty {\n+                // No question\n+                return true;\n+            }\n+            // Compare layout\n+            match (caller_abi.layout.abi, callee_abi.layout.abi) {\n+                // Different valid ranges are okay (once we enforce validity,\n+                // that will take care to make it UB to leave the range, just\n+                // like for transmute).\n+                (abi::Abi::Scalar(caller), abi::Abi::Scalar(callee)) => {\n+                    caller.value == callee.value\n+                }\n+                (\n+                    abi::Abi::ScalarPair(caller1, caller2),\n+                    abi::Abi::ScalarPair(callee1, callee2),\n+                ) => caller1.value == callee1.value && caller2.value == callee2.value,\n+                // Be conservative\n+                _ => false,\n+            }\n+        };\n+        // Padding must be fully equal.\n+        let pad_compat = || caller_abi.pad == callee_abi.pad;\n+        // When comparing the PassMode, we have to be smart about comparing the attributes.\n+        let arg_attr_compat = |a1: ArgAttributes, a2: ArgAttributes| {\n+            // There's only one regular attribute that matters for the call ABI: InReg.\n+            // Everything else is things like noalias, dereferencable, nonnull, ...\n+            // (This also applies to pointee_size, pointee_align.)\n+            if a1.regular.contains(ArgAttribute::InReg) != a2.regular.contains(ArgAttribute::InReg)\n+            {\n+                return false;\n+            }\n+            // We also compare the sign extension mode -- this could let the callee make assumptions\n+            // about bits that conceptually were not even passed.\n+            if a1.arg_ext != a2.arg_ext {\n+                return false;\n+            }\n             return true;\n-        }\n-        if !rust_abi {\n-            // Don't risk anything\n-            return false;\n-        }\n-        // Compare layout\n-        match (caller.abi, callee.abi) {\n-            // Different valid ranges are okay (once we enforce validity,\n-            // that will take care to make it UB to leave the range, just\n-            // like for transmute).\n-            (abi::Abi::Scalar(caller), abi::Abi::Scalar(callee)) => caller.value == callee.value,\n-            (abi::Abi::ScalarPair(caller1, caller2), abi::Abi::ScalarPair(callee1, callee2)) => {\n-                caller1.value == callee1.value && caller2.value == callee2.value\n+        };\n+        let mode_compat = || match (caller_abi.mode, callee_abi.mode) {\n+            (PassMode::Ignore, PassMode::Ignore) => true,\n+            (PassMode::Direct(a1), PassMode::Direct(a2)) => arg_attr_compat(a1, a2),\n+            (PassMode::Pair(a1, b1), PassMode::Pair(a2, b2)) => {\n+                arg_attr_compat(a1, a2) && arg_attr_compat(b1, b2)\n             }\n-            // Be conservative\n+            (PassMode::Cast(c1), PassMode::Cast(c2)) => c1 == c2,\n+            (\n+                PassMode::Indirect { attrs: a1, extra_attrs: None, on_stack: s1 },\n+                PassMode::Indirect { attrs: a2, extra_attrs: None, on_stack: s2 },\n+            ) => arg_attr_compat(a1, a2) && s1 == s2,\n+            (\n+                PassMode::Indirect { attrs: a1, extra_attrs: Some(e1), on_stack: s1 },\n+                PassMode::Indirect { attrs: a2, extra_attrs: Some(e2), on_stack: s2 },\n+            ) => arg_attr_compat(a1, a2) && arg_attr_compat(e1, e2) && s1 == s2,\n             _ => false,\n+        };\n+\n+        if layout_compat() && pad_compat() && mode_compat() {\n+            return true;\n         }\n+        trace!(\n+            \"check_argument_compat: incompatible ABIs:\\ncaller: {:?}\\ncallee: {:?}\",\n+            caller_abi,\n+            callee_abi\n+        );\n+        return false;\n     }\n \n-    /// Pass a single argument, checking the types for compatibility.\n-    fn pass_argument(\n+    /// Initialize a single callee argument, checking the types for compatibility.\n+    fn pass_argument<'x, 'y>(\n         &mut self,\n-        rust_abi: bool,\n-        caller_arg: &mut impl Iterator<Item = OpTy<'tcx, M::PointerTag>>,\n+        caller_args: &mut impl Iterator<\n+            Item = (&'x OpTy<'tcx, M::PointerTag>, &'y ArgAbi<'tcx, Ty<'tcx>>),\n+        >,\n+        callee_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n         callee_arg: &PlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        if rust_abi && callee_arg.layout.is_zst() {\n-            // Nothing to do.\n-            trace!(\"Skipping callee ZST\");\n+    ) -> InterpResult<'tcx>\n+    where\n+        'tcx: 'x,\n+        'tcx: 'y,\n+    {\n+        if matches!(callee_abi.mode, PassMode::Ignore) {\n+            // This one is skipped.\n             return Ok(());\n         }\n-        let caller_arg = caller_arg.next().ok_or_else(|| {\n+        // Find next caller arg.\n+        let (caller_arg, caller_abi) = caller_args.next().ok_or_else(|| {\n             err_ub_format!(\"calling a function with fewer arguments than it requires\")\n         })?;\n-        if rust_abi {\n-            assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n-        }\n         // Now, check\n-        if !Self::check_argument_compat(rust_abi, caller_arg.layout, callee_arg.layout) {\n+        if !Self::check_argument_compat(caller_abi, callee_abi) {\n             throw_ub_format!(\n                 \"calling a function with argument of type {:?} passing data of type {:?}\",\n                 callee_arg.layout.ty,\n                 caller_arg.layout.ty\n             )\n         }\n-        // We allow some transmutes here\n+        // We allow some transmutes here.\n+        // FIXME: Depending on the PassMode, this should reset some padding to uninitialized. (This\n+        // is true for all `copy_op`, but there are a lot of special cases for argument passing\n+        // specifically.)\n         self.copy_op_transmute(&caller_arg, callee_arg)\n     }\n \n     /// Call this function -- pushing the stack frame and initializing the arguments.\n+    ///\n+    /// `caller_fn_abi` is used to determine if all the arguments are passed the proper way.\n+    /// However, we also need `caller_abi` to determine if we need to do untupling of arguments.\n+    ///\n+    /// `with_caller_location` indicates whether the caller passed a caller location. Miri\n+    /// implements caller locations without argument passing, but to match `FnAbi` we need to know\n+    /// when those arguments are present.\n     pub(crate) fn eval_fn_call(\n         &mut self,\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n-        caller_abi: Abi,\n+        (caller_abi, caller_fn_abi): (Abi, &FnAbi<'tcx, Ty<'tcx>>),\n         args: &[OpTy<'tcx, M::PointerTag>],\n+        with_caller_location: bool,\n         ret: Option<(&PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n         mut unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n@@ -248,39 +307,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         };\n \n-        let get_abi = |this: &Self, instance_ty: Ty<'tcx>| match instance_ty.kind() {\n-            ty::FnDef(..) => instance_ty.fn_sig(*this.tcx).abi(),\n-            ty::Closure(..) => Abi::RustCall,\n-            ty::Generator(..) => Abi::Rust,\n-            _ => span_bug!(this.cur_span(), \"unexpected callee ty: {:?}\", instance_ty),\n-        };\n-\n-        // ABI check\n-        let check_abi = |callee_abi: Abi| -> InterpResult<'tcx> {\n-            let normalize_abi = |abi| match abi {\n-                Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic =>\n-                // These are all the same ABI, really.\n-                {\n-                    Abi::Rust\n-                }\n-                abi => abi,\n-            };\n-            if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n-                throw_ub_format!(\n-                    \"calling a function with ABI {} using caller ABI {}\",\n-                    callee_abi.name(),\n-                    caller_abi.name()\n-                )\n-            }\n-            Ok(())\n-        };\n-\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n-                if M::enforce_abi(self) {\n-                    check_abi(get_abi(self, instance.ty(*self.tcx, self.param_env)))?;\n-                }\n                 assert!(caller_abi == Abi::RustIntrinsic || caller_abi == Abi::PlatformIntrinsic);\n+                // caller_fn_abi is not relevant here, we interpret the arguments directly for each intrinsic.\n                 M::call_intrinsic(self, instance, args, ret, unwind)\n             }\n             ty::InstanceDef::VtableShim(..)\n@@ -291,26 +321,37 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | ty::InstanceDef::CloneShim(..)\n             | ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n-                let body =\n+                let (body, instance) =\n                     match M::find_mir_or_eval_fn(self, instance, caller_abi, args, ret, unwind)? {\n                         Some(body) => body,\n                         None => return Ok(()),\n                     };\n \n-                // Check against the ABI of the MIR body we are calling (not the ABI of `instance`;\n-                // these can differ when `find_mir_or_eval_fn` does something clever like resolve\n-                // exported symbol names).\n-                let callee_def_id = body.source.def_id();\n-                let callee_abi = get_abi(self, self.tcx.type_of(callee_def_id));\n+                // Compute callee information using the `instance` returned by\n+                // `find_mir_or_eval_fn`.\n+                // FIXME: for variadic support, do we have to somehow determine calle's extra_args?\n+                let callee_fn_abi = self.fn_abi_of_instance(instance, ty::List::empty())?;\n+\n+                if callee_fn_abi.c_variadic != caller_fn_abi.c_variadic {\n+                    throw_ub_format!(\n+                        \"calling a c-variadic function via a non-variadic call site, or vice versa\"\n+                    );\n+                }\n+                if callee_fn_abi.c_variadic {\n+                    throw_unsup_format!(\"calling a c-variadic function is not supported\");\n+                }\n \n                 if M::enforce_abi(self) {\n-                    check_abi(callee_abi)?;\n+                    if caller_fn_abi.conv != callee_fn_abi.conv {\n+                        throw_ub_format!(\n+                            \"calling a function with calling convention {:?} using calling convention {:?}\",\n+                            callee_fn_abi.conv,\n+                            caller_fn_abi.conv\n+                        )\n+                    }\n                 }\n \n-                if !matches!(unwind, StackPopUnwind::NotAllowed)\n-                    && !self\n-                        .fn_can_unwind(self.tcx.codegen_fn_attrs(callee_def_id).flags, callee_abi)\n-                {\n+                if !matches!(unwind, StackPopUnwind::NotAllowed) && !callee_fn_abi.can_unwind {\n                     // The callee cannot unwind.\n                     unwind = StackPopUnwind::NotAllowed;\n                 }\n@@ -343,12 +384,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             .collect::<Vec<_>>()\n                     );\n \n-                    // Figure out how to pass which arguments.\n-                    // The Rust ABI is special: ZST get skipped.\n-                    let rust_abi = matches!(caller_abi, Abi::Rust | Abi::RustCall);\n-\n-                    // We have two iterators: Where the arguments come from,\n-                    // and where they go to.\n+                    // In principle, we have two iterators: Where the arguments come from, and where\n+                    // they go to.\n \n                     // For where they come from: If the ABI is RustCall, we untuple the\n                     // last incoming argument.  These two iterators do not have the same type,\n@@ -373,53 +410,59 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             // Plain arg passing\n                             Cow::from(args)\n                         };\n-                    // Skip ZSTs\n-                    let mut caller_iter =\n-                        caller_args.iter().filter(|op| !rust_abi || !op.layout.is_zst()).copied();\n+                    // If `with_caller_location` is set we pretend there is an extra argument (that\n+                    // we will not pass).\n+                    assert_eq!(\n+                        caller_args.len() + if with_caller_location { 1 } else { 0 },\n+                        caller_fn_abi.args.len(),\n+                        \"mismatch between caller ABI and caller arguments\",\n+                    );\n+                    let mut caller_args = caller_args\n+                        .iter()\n+                        .zip(caller_fn_abi.args.iter())\n+                        .filter(|arg_and_abi| !matches!(arg_and_abi.1.mode, PassMode::Ignore));\n \n                     // Now we have to spread them out across the callee's locals,\n                     // taking into account the `spread_arg`.  If we could write\n                     // this is a single iterator (that handles `spread_arg`), then\n                     // `pass_argument` would be the loop body. It takes care to\n                     // not advance `caller_iter` for ZSTs.\n+                    let mut callee_args_abis = callee_fn_abi.args.iter();\n                     for local in body.args_iter() {\n                         let dest = self.eval_place(mir::Place::from(local))?;\n                         if Some(local) == body.spread_arg {\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n                                 let dest = self.place_field(&dest, i)?;\n-                                self.pass_argument(rust_abi, &mut caller_iter, &dest)?;\n+                                let callee_abi = callee_args_abis.next().unwrap();\n+                                self.pass_argument(&mut caller_args, callee_abi, &dest)?;\n                             }\n                         } else {\n                             // Normal argument\n-                            self.pass_argument(rust_abi, &mut caller_iter, &dest)?;\n+                            let callee_abi = callee_args_abis.next().unwrap();\n+                            self.pass_argument(&mut caller_args, callee_abi, &dest)?;\n                         }\n                     }\n-                    // Now we should have no more caller args\n-                    if caller_iter.next().is_some() {\n+                    // If the callee needs a caller location, pretend we consume one more argument from the ABI.\n+                    if instance.def.requires_caller_location(*self.tcx) {\n+                        callee_args_abis.next().unwrap();\n+                    }\n+                    // Now we should have no more caller args or callee arg ABIs\n+                    assert!(\n+                        callee_args_abis.next().is_none(),\n+                        \"mismatch between callee ABI and callee body arguments\"\n+                    );\n+                    if caller_args.next().is_some() {\n                         throw_ub_format!(\"calling a function with more arguments than it expected\")\n                     }\n                     // Don't forget to check the return type!\n-                    if let Some((caller_ret, _)) = ret {\n-                        let callee_ret = self.eval_place(mir::Place::return_place())?;\n-                        if !Self::check_argument_compat(\n-                            rust_abi,\n-                            caller_ret.layout,\n-                            callee_ret.layout,\n-                        ) {\n-                            throw_ub_format!(\n-                                \"calling a function with return type {:?} passing \\\n-                                     return place of type {:?}\",\n-                                callee_ret.layout.ty,\n-                                caller_ret.layout.ty\n-                            )\n-                        }\n-                    } else {\n-                        let local = mir::RETURN_PLACE;\n-                        let callee_layout = self.layout_of_local(self.frame(), local, None)?;\n-                        if !callee_layout.abi.is_uninhabited() {\n-                            throw_ub_format!(\"calling a returning function without a return place\")\n-                        }\n+                    if !Self::check_argument_compat(&caller_fn_abi.ret, &callee_fn_abi.ret) {\n+                        throw_ub_format!(\n+                            \"calling a function with return type {:?} passing \\\n+                                    return place of type {:?}\",\n+                            callee_fn_abi.ret.layout.ty,\n+                            caller_fn_abi.ret.layout.ty,\n+                        )\n                     }\n                 };\n                 match res {\n@@ -464,7 +507,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ));\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(fn_val, caller_abi, &args, ret, unwind)\n+                self.eval_fn_call(\n+                    fn_val,\n+                    (caller_abi, caller_fn_abi),\n+                    &args,\n+                    with_caller_location,\n+                    ret,\n+                    unwind,\n+                )\n             }\n         }\n     }\n@@ -489,6 +539,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             _ => (instance, place),\n         };\n+        let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty())?;\n \n         let arg = ImmTy::from_immediate(\n             place.to_ref(self),\n@@ -500,8 +551,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         self.eval_fn_call(\n             FnVal::Instance(instance),\n-            Abi::Rust,\n+            (Abi::Rust, fn_abi),\n             &[arg.into()],\n+            false,\n             Some((&dest.into(), target)),\n             match unwind {\n                 Some(cleanup) => StackPopUnwind::Cleanup(cleanup),"}, {"sha": "e9a857d09124f4cad822cd3213adb0625d761891", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=59337cddd41880f8075b07860a99be4dc402ddb1", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorReported}\n use rustc_macros::HashStable;\n use rustc_session::CtfeBacktrace;\n use rustc_span::def_id::DefId;\n-use rustc_target::abi::{Align, Size};\n+use rustc_target::abi::{call, Align, Size};\n use std::{any::Any, backtrace::Backtrace, fmt};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n@@ -141,6 +141,10 @@ pub enum InvalidProgramInfo<'tcx> {\n     AlreadyReported(ErrorReported),\n     /// An error occurred during layout computation.\n     Layout(layout::LayoutError<'tcx>),\n+    /// An error occurred during FnAbi computation: the passed --target lacks FFI support\n+    /// (which unfortunately typeck does not reject).\n+    /// Not using `FnAbiError` as that contains a nested `LayoutError`.\n+    FnAbiAdjustForForeignAbi(call::AdjustForForeignAbiError),\n     /// An invalid transmute happened.\n     TransmuteSizeDiff(Ty<'tcx>, Ty<'tcx>),\n     /// SizeOf of unsized type was requested.\n@@ -157,6 +161,7 @@ impl fmt::Display for InvalidProgramInfo<'_> {\n                 write!(f, \"encountered constants with type errors, stopping evaluation\")\n             }\n             Layout(ref err) => write!(f, \"{}\", err),\n+            FnAbiAdjustForForeignAbi(ref err) => write!(f, \"{}\", err),\n             TransmuteSizeDiff(from_ty, to_ty) => write!(\n                 f,\n                 \"transmuting `{}` to `{}` is not possible, because these types do not have the same size\","}, {"sha": "196fe7ce1b6ac46a2e6fe1c605eb197b5ba38390", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=59337cddd41880f8075b07860a99be4dc402ddb1", "patch": "@@ -2581,9 +2581,12 @@ impl<'tcx> ty::Instance<'tcx> {\n     // for `Instance` (e.g. typeck would use `Ty::fn_sig` instead),\n     // or should go through `FnAbi` instead, to avoid losing any\n     // adjustments `fn_abi_of_instance` might be performing.\n-    fn fn_sig_for_fn_abi(&self, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        // FIXME(davidtwco,eddyb): A `ParamEnv` should be passed through to this function.\n-        let ty = self.ty(tcx, ty::ParamEnv::reveal_all());\n+    fn fn_sig_for_fn_abi(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> ty::PolyFnSig<'tcx> {\n+        let ty = self.ty(tcx, param_env);\n         match *ty.kind() {\n             ty::FnDef(..) => {\n                 // HACK(davidtwco,eddyb): This is a workaround for polymorphization considering\n@@ -2965,7 +2968,7 @@ fn fn_abi_of_instance<'tcx>(\n ) -> Result<&'tcx FnAbi<'tcx, Ty<'tcx>>, FnAbiError<'tcx>> {\n     let (param_env, (instance, extra_args)) = query.into_parts();\n \n-    let sig = instance.fn_sig_for_fn_abi(tcx);\n+    let sig = instance.fn_sig_for_fn_abi(tcx, param_env);\n \n     let caller_location = if instance.def.requires_caller_location(tcx) {\n         Some(tcx.caller_location_ty())"}, {"sha": "7e56e062fc989b66dbb35868a6f03edf434bb2e1", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59337cddd41880f8075b07860a99be4dc402ddb1/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=59337cddd41880f8075b07860a99be4dc402ddb1", "patch": "@@ -207,7 +207,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _args: &[OpTy<'tcx>],\n         _ret: Option<(&PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx, Option<&'mir Body<'tcx>>> {\n+    ) -> InterpResult<'tcx, Option<(&'mir Body<'tcx>, ty::Instance<'tcx>)>> {\n         Ok(None)\n     }\n "}, {"sha": "3360e9cacda655064862a8a9fcbf46b2af6a9c91", "filename": "src/test/ui/consts/miri_unleashed/abi-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59337cddd41880f8075b07860a99be4dc402ddb1/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59337cddd41880f8075b07860a99be4dc402ddb1/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.rs?ref=59337cddd41880f8075b07860a99be4dc402ddb1", "patch": "@@ -9,7 +9,7 @@ const extern \"C\" fn c_fn() {}\n const fn call_rust_fn(my_fn: extern \"Rust\" fn()) {\n     my_fn();\n     //~^ ERROR could not evaluate static initializer\n-    //~| NOTE calling a function with ABI C using caller ABI Rust\n+    //~| NOTE calling a function with calling convention C using calling convention Rust\n     //~| NOTE inside `call_rust_fn`\n }\n "}, {"sha": "e2f9708ddcb0143509ce9918fb39dbbd717ae7ea", "filename": "src/test/ui/consts/miri_unleashed/abi-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59337cddd41880f8075b07860a99be4dc402ddb1/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59337cddd41880f8075b07860a99be4dc402ddb1/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr?ref=59337cddd41880f8075b07860a99be4dc402ddb1", "patch": "@@ -4,7 +4,7 @@ error[E0080]: could not evaluate static initializer\n LL |     my_fn();\n    |     ^^^^^^^\n    |     |\n-   |     calling a function with ABI C using caller ABI Rust\n+   |     calling a function with calling convention C using calling convention Rust\n    |     inside `call_rust_fn` at $DIR/abi-mismatch.rs:10:5\n ...\n LL | static VAL: () = call_rust_fn(unsafe { std::mem::transmute(c_fn as extern \"C\" fn()) });"}]}