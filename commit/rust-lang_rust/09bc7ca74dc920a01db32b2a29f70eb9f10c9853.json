{"sha": "09bc7ca74dc920a01db32b2a29f70eb9f10c9853", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YmM3Y2E3NGRjOTIwYTAxZGIzMmIyYTI5ZjcwZWI5ZjEwYzk4NTM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-26T12:22:46Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-26T12:22:46Z"}, "message": "Reduce visibility", "tree": {"sha": "8dd02f98b36c9e452b2a2f33d33f64d1fdd17470", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dd02f98b36c9e452b2a2f33d33f64d1fdd17470"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09bc7ca74dc920a01db32b2a29f70eb9f10c9853", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09bc7ca74dc920a01db32b2a29f70eb9f10c9853", "html_url": "https://github.com/rust-lang/rust/commit/09bc7ca74dc920a01db32b2a29f70eb9f10c9853", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09bc7ca74dc920a01db32b2a29f70eb9f10c9853/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3a4c4429de83450654795534e64e878a774a088", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a4c4429de83450654795534e64e878a774a088", "html_url": "https://github.com/rust-lang/rust/commit/c3a4c4429de83450654795534e64e878a774a088"}], "stats": {"total": 157, "additions": 81, "deletions": 76}, "files": [{"sha": "3aa7c487041b44c798ec8b0b15bc7c8d4345073d", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09bc7ca74dc920a01db32b2a29f70eb9f10c9853/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bc7ca74dc920a01db32b2a29f70eb9f10c9853/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=09bc7ca74dc920a01db32b2a29f70eb9f10c9853", "patch": "@@ -40,6 +40,7 @@ from_id![\n     (hir_def::ConstId, crate::Const),\n     (hir_def::FunctionId, crate::Function),\n     (hir_def::ImplId, crate::ImplBlock),\n+    (hir_def::TypeParamId, crate::TypeParam),\n     (hir_expand::MacroDefId, crate::MacroDef)\n ];\n "}, {"sha": "9fedb7657937666c119274bfde8f0f053780bfc2", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/09bc7ca74dc920a01db32b2a29f70eb9f10c9853/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bc7ca74dc920a01db32b2a29f70eb9f10c9853/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=09bc7ca74dc920a01db32b2a29f70eb9f10c9853", "patch": "@@ -4,16 +4,16 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use hir_def::{\n     resolver::{self, HasResolver, Resolver},\n-    TraitId,\n+    DefWithBodyId, TraitId,\n };\n use ra_db::{FileId, FileRange};\n-use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextUnit};\n+use ra_syntax::{ast, match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextUnit};\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     db::HirDatabase,\n     source_analyzer::{resolve_hir_path, ReferenceDescriptor, SourceAnalyzer},\n-    source_binder::{ChildContainer, SourceBinder, ToDef},\n+    source_binder::{ChildContainer, SourceBinder},\n     Function, HirFileId, InFile, Local, MacroDef, Module, Name, Origin, Path, PathResolution,\n     ScopeDef, StructField, Trait, Type, TypeParam, VariantDef,\n };\n@@ -129,9 +129,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     // pub fn resolve_name_ref(&self, name_ref: &ast::NameRef) -> Option<???>;\n \n     pub fn to_def<T: ToDef + Clone>(&self, src: &T) -> Option<T::Def> {\n-        let src = self.find_file(src.syntax().clone()).with_value(src.clone());\n-        let mut sb = self.sb.borrow_mut();\n-        T::to_def(self.db, &mut sb, src)\n+        T::to_def(self, src)\n     }\n \n     pub fn to_module_def(&self, file: FileId) -> Option<Module> {\n@@ -227,6 +225,68 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     }\n }\n \n+pub trait ToDef: Sized + AstNode + 'static {\n+    type Def;\n+    fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: &Self) -> Option<Self::Def>;\n+}\n+\n+macro_rules! to_def_impls {\n+    ($(($def:path, $ast:path)),* ,) => {$(\n+        impl ToDef for $ast {\n+            type Def = $def;\n+            fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: &Self)\n+                -> Option<Self::Def>\n+            {\n+                let src = sema.find_file(src.syntax().clone()).with_value(src);\n+                sema.sb.borrow_mut().to_id(sema.db, src.cloned()).map(Into::into)\n+            }\n+        }\n+    )*}\n+}\n+\n+to_def_impls![\n+    (crate::Module, ast::Module),\n+    (crate::Struct, ast::StructDef),\n+    (crate::Enum, ast::EnumDef),\n+    (crate::Union, ast::UnionDef),\n+    (crate::Trait, ast::TraitDef),\n+    (crate::ImplBlock, ast::ImplBlock),\n+    (crate::TypeAlias, ast::TypeAliasDef),\n+    (crate::Const, ast::ConstDef),\n+    (crate::Static, ast::StaticDef),\n+    (crate::Function, ast::FnDef),\n+    (crate::StructField, ast::RecordFieldDef),\n+    (crate::EnumVariant, ast::EnumVariant),\n+    (crate::TypeParam, ast::TypeParam),\n+    (crate::MacroDef, ast::MacroCall), // this one is dubious, not all calls are macros\n+];\n+\n+impl ToDef for ast::BindPat {\n+    type Def = Local;\n+\n+    fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: &Self) -> Option<Local> {\n+        let src = sema.find_file(src.syntax().clone()).with_value(src);\n+        let file_id = src.file_id;\n+        let mut sb = sema.sb.borrow_mut();\n+        let db = sema.db;\n+        let parent: DefWithBodyId = src.value.syntax().ancestors().find_map(|it| {\n+            let res = match_ast! {\n+                match it {\n+                    ast::ConstDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n+                    ast::StaticDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n+                    ast::FnDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n+                    _ => return None,\n+                }\n+            };\n+            Some(res)\n+        })?;\n+        let (_body, source_map) = db.body_with_source_map(parent);\n+        let src = src.cloned().map(ast::Pat::from);\n+        let pat_id = source_map.node_pat(src.as_ref())?;\n+        Some(Local { parent: parent.into(), pat_id })\n+    }\n+}\n+\n fn find_root(node: &SyntaxNode) -> SyntaxNode {\n     node.ancestors().last().unwrap()\n }"}, {"sha": "4353e25ac847057ad0c132b86ef671d9bf1e2d8d", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 14, "deletions": 70, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/09bc7ca74dc920a01db32b2a29f70eb9f10c9853/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bc7ca74dc920a01db32b2a29f70eb9f10c9853/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=09bc7ca74dc920a01db32b2a29f70eb9f10c9853", "patch": "@@ -6,7 +6,7 @@ use hir_def::{\n     dyn_map::DynMap,\n     keys::{self, Key},\n     ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId, ImplId, ModuleId,\n-    StaticId, StructFieldId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n+    StaticId, StructFieldId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::AsName, AstId, InFile, MacroDefId, MacroDefKind};\n use ra_db::FileId;\n@@ -17,9 +17,9 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashMap;\n \n-use crate::{db::HirDatabase, Local, Module, TypeParam};\n+use crate::{db::HirDatabase, Module};\n \n-pub struct SourceBinder {\n+pub(crate) struct SourceBinder {\n     child_by_source_cache: FxHashMap<ChildContainer, DynMap>,\n }\n \n@@ -38,7 +38,11 @@ impl SourceBinder {\n         Some(Module { id: ModuleId { krate, local_id } })\n     }\n \n-    fn to_id<T: ToId>(&mut self, db: &impl HirDatabase, src: InFile<T>) -> Option<T::ID> {\n+    pub(crate) fn to_id<T: ToId>(\n+        &mut self,\n+        db: &impl HirDatabase,\n+        src: InFile<T>,\n+    ) -> Option<T::ID> {\n         T::to_id(db, self, src)\n     }\n \n@@ -118,42 +122,6 @@ pub(crate) trait ToId: Sized {\n     ) -> Option<Self::ID>;\n }\n \n-pub trait ToDef: Sized + AstNode + 'static {\n-    type Def;\n-    fn to_def<DB: HirDatabase>(\n-        db: &DB,\n-        sb: &mut SourceBinder,\n-        src: InFile<Self>,\n-    ) -> Option<Self::Def>;\n-}\n-\n-macro_rules! to_def_impls {\n-    ($(($def:path, $ast:path)),* ,) => {$(\n-        impl ToDef for $ast {\n-            type Def = $def;\n-            fn to_def<DB: HirDatabase>(db: &DB, sb: &mut SourceBinder, src: InFile<Self>)\n-                -> Option<Self::Def>\n-            { sb.to_id(db, src).map(Into::into) }\n-        }\n-    )*}\n-}\n-\n-to_def_impls![\n-    (crate::Module, ast::Module),\n-    (crate::Struct, ast::StructDef),\n-    (crate::Enum, ast::EnumDef),\n-    (crate::Union, ast::UnionDef),\n-    (crate::Trait, ast::TraitDef),\n-    (crate::ImplBlock, ast::ImplBlock),\n-    (crate::TypeAlias, ast::TypeAliasDef),\n-    (crate::Const, ast::ConstDef),\n-    (crate::Static, ast::StaticDef),\n-    (crate::Function, ast::FnDef),\n-    (crate::StructField, ast::RecordFieldDef),\n-    (crate::EnumVariant, ast::EnumVariant),\n-    (crate::MacroDef, ast::MacroCall), // this one is dubious, not all calls are macros\n-];\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub(crate) enum ChildContainer {\n     DefWithBodyId(DefWithBodyId),\n@@ -245,37 +213,14 @@ impl ToId for ast::MacroCall {\n     }\n }\n \n-impl ToDef for ast::BindPat {\n-    type Def = Local;\n+impl ToId for ast::TypeParam {\n+    type ID = TypeParamId;\n \n-    fn to_def<DB: HirDatabase>(db: &DB, sb: &mut SourceBinder, src: InFile<Self>) -> Option<Local> {\n-        let file_id = src.file_id;\n-        let parent: DefWithBodyId = src.value.syntax().ancestors().find_map(|it| {\n-            let res = match_ast! {\n-                match it {\n-                    ast::ConstDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    ast::StaticDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    ast::FnDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    _ => return None,\n-                }\n-            };\n-            Some(res)\n-        })?;\n-        let (_body, source_map) = db.body_with_source_map(parent);\n-        let src = src.map(ast::Pat::from);\n-        let pat_id = source_map.node_pat(src.as_ref())?;\n-        Some(Local { parent: parent.into(), pat_id })\n-    }\n-}\n-\n-impl ToDef for ast::TypeParam {\n-    type Def = TypeParam;\n-\n-    fn to_def<DB: HirDatabase>(\n+    fn to_id<DB: HirDatabase>(\n         db: &DB,\n         sb: &mut SourceBinder,\n-        src: InFile<ast::TypeParam>,\n-    ) -> Option<TypeParam> {\n+        src: InFile<Self>,\n+    ) -> Option<Self::ID> {\n         let file_id = src.file_id;\n         let parent: GenericDefId = src.value.syntax().ancestors().find_map(|it| {\n             let res = match_ast! {\n@@ -291,8 +236,7 @@ impl ToDef for ast::TypeParam {\n             };\n             Some(res)\n         })?;\n-        let &id = sb.child_by_source(db, parent.into())[keys::TYPE_PARAM].get(&src)?;\n-        Some(TypeParam { id })\n+        sb.child_by_source(db, parent.into())[keys::TYPE_PARAM].get(&src).copied()\n     }\n }\n "}]}