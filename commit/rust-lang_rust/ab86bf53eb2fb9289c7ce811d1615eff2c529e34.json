{"sha": "ab86bf53eb2fb9289c7ce811d1615eff2c529e34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiODZiZjUzZWIyZmI5Mjg5YzdjZTgxMWQxNjE1ZWZmMmM1MjllMzQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-24T20:27:00Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-09-02T22:42:18Z"}, "message": "consolidate type-variable handling in assemble_candidates\n\nthis resolves type-variables early in assemble_candidates and\nbails out quickly if the self type is an inference variable (which would\nfail anyway because of `assemble_candidates_from_projected_tys`).\n\nIn both these cases, `assemble_candidates_from_impls` would try to go\nover all impls and match them, leading to O(n*m) performance. Fixing this\nimproves rustc type-checking performance by 10%. As type-checking is only\nis 5% of compilation, this doesn't impact bootstrap times, but *does*\nimprove type-error-detection time which is nice.\n\nCrates that have many dependencies and contain significant amounts of\ngeneric functions could see a bigger perf boost. As a microbenchmark,\nthe crate generated by\n\necho '#![feature(rustc_private)]'\necho 'extern crate rustc_driver;'\nfor i in {1..1000}; do cat << _EOF_\n    pub fn foo$i<T>() {\n        let mut v = Vec::new();\n        let _w = v.clone();\n        v.push(\"\");\n    }\n_EOF_\ndone\n\nsees performance improve from 7.2 to 1.4 seconds. I imagine many crates\nwould fall somewhere in-between.", "tree": {"sha": "cb9012cce6643929300130b29cfc2b4713fc38dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb9012cce6643929300130b29cfc2b4713fc38dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab86bf53eb2fb9289c7ce811d1615eff2c529e34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab86bf53eb2fb9289c7ce811d1615eff2c529e34", "html_url": "https://github.com/rust-lang/rust/commit/ab86bf53eb2fb9289c7ce811d1615eff2c529e34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab86bf53eb2fb9289c7ce811d1615eff2c529e34/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfd76b364cd01695517467299618ef63f1c0cc07", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfd76b364cd01695517467299618ef63f1c0cc07", "html_url": "https://github.com/rust-lang/rust/commit/cfd76b364cd01695517467299618ef63f1c0cc07"}], "stats": {"total": 67, "additions": 36, "deletions": 31}, "files": [{"sha": "8526f74b76ef1bb5b5da6172234580bff27334b6", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ab86bf53eb2fb9289c7ce811d1615eff2c529e34/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab86bf53eb2fb9289c7ce811d1615eff2c529e34/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=ab86bf53eb2fb9289c7ce811d1615eff2c529e34", "patch": "@@ -185,7 +185,7 @@ pub enum MethodMatchedData {\n /// that we can have both a projection candidate and a where-clause candidate\n /// for the same obligation. In that case either would do (except that\n /// different \"leaps of logic\" would occur if inference variables are\n-/// present), and we just pick the projection. This is, for example,\n+/// present), and we just pick the where-clause. This is, for example,\n /// required for associated types to work in default impls, as the bounds\n /// are visible both as projection bounds and as where-clauses from the\n /// parameter environment.\n@@ -915,6 +915,24 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n         let TraitObligationStack { obligation, .. } = *stack;\n+        let ref obligation = Obligation {\n+            cause: obligation.cause.clone(),\n+            recursion_depth: obligation.recursion_depth,\n+            predicate: self.infcx().resolve_type_vars_if_possible(&obligation.predicate)\n+        };\n+\n+        if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n+            // FIXME(#20297): Self is a type variable (e.g. `_: AsRef<str>`).\n+            //\n+            // This is somewhat problematic, as the current scheme can't really\n+            // handle it turning to be a projection. This does end up as truly\n+            // ambiguous in most cases anyway.\n+            //\n+            // Until this is fixed, take the fast path out - this also improves\n+            // performance by preventing assemble_candidates_from_impls from\n+            // matching every impl for this trait.\n+            return Ok(SelectionCandidateSet { vec: vec![], ambiguous: true });\n+        }\n \n         let mut candidates = SelectionCandidateSet {\n             vec: Vec::new(),\n@@ -935,13 +953,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // For other types, we'll use the builtin rules.\n                 try!(self.assemble_builtin_bound_candidates(ty::BoundCopy,\n-                                                            stack,\n+                                                            obligation,\n                                                             &mut candidates));\n             }\n             Some(bound @ ty::BoundSized) => {\n                 // Sized is never implementable by end-users, it is\n                 // always automatically computed.\n-                try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n+                try!(self.assemble_builtin_bound_candidates(bound,\n+                                                            obligation,\n+                                                            &mut candidates));\n             }\n \n             None if self.tcx().lang_items.unsize_trait() ==\n@@ -974,29 +994,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               obligation: &TraitObligation<'tcx>,\n                                               candidates: &mut SelectionCandidateSet<'tcx>)\n     {\n-        let poly_trait_predicate =\n-            self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n-\n-        debug!(\"assemble_candidates_for_projected_tys({:?},{:?})\",\n-               obligation,\n-               poly_trait_predicate);\n+        debug!(\"assemble_candidates_for_projected_tys({:?})\", obligation);\n \n         // FIXME(#20297) -- just examining the self-type is very simplistic\n \n         // before we go into the whole skolemization thing, just\n         // quickly check if the self-type is a projection at all.\n-        let trait_def_id = match poly_trait_predicate.0.trait_ref.self_ty().sty {\n+        let trait_def_id = match obligation.predicate.0.trait_ref.self_ty().sty {\n             ty::TyProjection(ref data) => data.trait_ref.def_id,\n             ty::TyInfer(ty::TyVar(_)) => {\n-                // If the self-type is an inference variable, then it MAY wind up\n-                // being a projected type, so induce an ambiguity.\n-                //\n-                // FIXME(#20297) -- being strict about this can cause\n-                // inference failures with BorrowFrom, which is\n-                // unfortunate. Can we do better here?\n-                debug!(\"assemble_candidates_for_projected_tys: ambiguous self-type\");\n-                candidates.ambiguous = true;\n-                return;\n+                self.tcx().sess.span_bug(obligation.cause.span,\n+                    \"Self=_ should have been handled by assemble_candidates\");\n             }\n             _ => { return; }\n         };\n@@ -1164,7 +1172,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // ok to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = *obligation.self_ty().skip_binder();\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::TyClosure(id, ref substs) => (id, substs),\n             ty::TyInfer(ty::TyVar(_)) => {\n@@ -1208,7 +1216,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // ok to skip binder because what we are inspecting doesn't involve bound regions\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.sty {\n             ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n@@ -1265,7 +1273,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               -> Result<(), SelectionError<'tcx>>\n     {\n         // OK to skip binder here because the tests we do below do not involve bound regions\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = *obligation.self_ty().skip_binder();\n         debug!(\"assemble_candidates_from_default_impls(self_ty={:?})\", self_ty);\n \n         let def_id = obligation.predicate.def_id();\n@@ -1321,7 +1329,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           candidates: &mut SelectionCandidateSet<'tcx>)\n     {\n         debug!(\"assemble_candidates_from_object_ty(self_ty={:?})\",\n-               self.infcx.shallow_resolve(*obligation.self_ty().skip_binder()));\n+               obligation.self_ty().skip_binder());\n \n         // Object-safety candidates are only applicable to object-safe\n         // traits. Including this check is useful because it helps\n@@ -1336,10 +1344,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         self.infcx.commit_if_ok(|snapshot| {\n-            let bound_self_ty =\n-                self.infcx.resolve_type_vars_if_possible(&obligation.self_ty());\n             let (self_ty, _) =\n-                self.infcx().skolemize_late_bound_regions(&bound_self_ty, snapshot);\n+                self.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n             let poly_trait_ref = match self_ty.sty {\n                 ty::TyTrait(ref data) => {\n                     match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n@@ -1413,15 +1419,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         //     T: Trait\n         // so it seems ok if we (conservatively) fail to accept that `Unsize`\n         // obligation above. Should be possible to extend this in the future.\n-        let self_ty = match self.tcx().no_late_bound_regions(&obligation.self_ty()) {\n+        let source = match self.tcx().no_late_bound_regions(&obligation.self_ty()) {\n             Some(t) => t,\n             None => {\n                 // Don't add any candidates if there are bound regions.\n                 return;\n             }\n         };\n-        let source = self.infcx.shallow_resolve(self_ty);\n-        let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n+        let target = obligation.predicate.0.input_types()[0];\n \n         debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\",\n                source, target);\n@@ -1576,11 +1581,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn assemble_builtin_bound_candidates<'o>(&mut self,\n                                              bound: ty::BuiltinBound,\n-                                             stack: &TraitObligationStack<'o, 'tcx>,\n+                                             obligation: &TraitObligation<'tcx>,\n                                              candidates: &mut SelectionCandidateSet<'tcx>)\n                                              -> Result<(),SelectionError<'tcx>>\n     {\n-        match self.builtin_bound(bound, stack.obligation) {\n+        match self.builtin_bound(bound, obligation) {\n             Ok(If(..)) => {\n                 debug!(\"builtin_bound: bound={:?}\",\n                        bound);"}]}