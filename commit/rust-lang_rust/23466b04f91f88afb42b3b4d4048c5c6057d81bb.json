{"sha": "23466b04f91f88afb42b3b4d4048c5c6057d81bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNDY2YjA0ZjkxZjg4YWZiNDJiM2I0ZDQwNDhjNWM2MDU3ZDgxYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-29T06:11:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-29T06:11:41Z"}, "message": "auto merge of #16034 : sfackler/rust/test-reexport-fix, r=alexcrichton\n\nWe previously reexported entire modules, which caused private things to\r\nbecome reachable and trip the dead code and private items in public API\r\nlints.\r\n\r\nCloses #15912", "tree": {"sha": "30e88832937317b20c2a102733009f2a909b6e57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30e88832937317b20c2a102733009f2a909b6e57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23466b04f91f88afb42b3b4d4048c5c6057d81bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23466b04f91f88afb42b3b4d4048c5c6057d81bb", "html_url": "https://github.com/rust-lang/rust/commit/23466b04f91f88afb42b3b4d4048c5c6057d81bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23466b04f91f88afb42b3b4d4048c5c6057d81bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f653d9f9bf9b69211226dabd13db188afd6b1fdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f653d9f9bf9b69211226dabd13db188afd6b1fdb", "html_url": "https://github.com/rust-lang/rust/commit/f653d9f9bf9b69211226dabd13db188afd6b1fdb"}, {"sha": "97721fa719882731fd7cce96225c140e094c61b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/97721fa719882731fd7cce96225c140e094c61b5", "html_url": "https://github.com/rust-lang/rust/commit/97721fa719882731fd7cce96225c140e094c61b5"}], "stats": {"total": 49, "additions": 31, "deletions": 18}, "files": [{"sha": "0fce75c8369bc24c4f6b1791d0bba9bc2e61c21a", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/23466b04f91f88afb42b3b4d4048c5c6057d81bb/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23466b04f91f88afb42b3b4d4048c5c6057d81bb/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=23466b04f91f88afb42b3b4d4048c5c6057d81bb", "patch": "@@ -48,7 +48,6 @@ struct Test {\n struct TestCtxt<'a> {\n     sess: &'a Session,\n     path: Vec<ast::Ident>,\n-    reexports: Vec<Vec<ast::Ident>>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: Vec<Test>,\n     reexport_mod_ident: ast::Ident,\n@@ -74,6 +73,8 @@ pub fn modify_for_testing(sess: &Session,\n \n struct TestHarnessGenerator<'a> {\n     cx: TestCtxt<'a>,\n+    tests: Vec<ast::Ident>,\n+    tested_submods: Vec<ast::Ident>,\n }\n \n impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n@@ -111,7 +112,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                         should_fail: should_fail(i)\n                     };\n                     self.cx.testfns.push(test);\n-                    self.cx.reexports.push(self.cx.path.clone());\n+                    self.tests.push(i.ident);\n                     // debug!(\"have {} test/bench functions\",\n                     //        cx.testfns.len());\n                 }\n@@ -129,9 +130,11 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     }\n \n     fn fold_mod(&mut self, m: &ast::Mod) -> ast::Mod {\n-        let reexports = mem::replace(&mut self.cx.reexports, Vec::new());\n+        let tests = mem::replace(&mut self.tests, Vec::new());\n+        let tested_submods = mem::replace(&mut self.tested_submods, Vec::new());\n         let mut mod_folded = fold::noop_fold_mod(m, self);\n-        let reexports = mem::replace(&mut self.cx.reexports, reexports);\n+        let tests = mem::replace(&mut self.tests, tests);\n+        let tested_submods = mem::replace(&mut self.tested_submods, tested_submods);\n \n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n@@ -152,20 +155,32 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         for i in mod_folded.items.mut_iter() {\n             *i = nomain(*i);\n         }\n-        if !reexports.is_empty() {\n-            mod_folded.items.push(mk_reexport_mod(&mut self.cx, reexports));\n-            self.cx.reexports.push(self.cx.path.clone());\n+        if !tests.is_empty() || !tested_submods.is_empty() {\n+            mod_folded.items.push(mk_reexport_mod(&mut self.cx, tests,\n+                                                  tested_submods));\n+            if !self.cx.path.is_empty() {\n+                self.tested_submods.push(self.cx.path[self.cx.path.len()-1]);\n+            }\n         }\n \n         mod_folded\n     }\n }\n \n-fn mk_reexport_mod(cx: &mut TestCtxt, reexports: Vec<Vec<ast::Ident>>)\n-                   -> Gc<ast::Item> {\n-    let view_items = reexports.move_iter().map(|r| {\n-        cx.ext_cx.view_use_simple(DUMMY_SP, ast::Public, cx.ext_cx.path(DUMMY_SP, r))\n-    }).collect();\n+fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n+                   tested_submods: Vec<ast::Ident>) -> Gc<ast::Item> {\n+    let mut view_items = Vec::new();\n+    let super_ = token::str_to_ident(\"super\");\n+\n+    view_items.extend(tests.move_iter().map(|r| {\n+        cx.ext_cx.view_use_simple(DUMMY_SP, ast::Public,\n+                                  cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n+    }));\n+    view_items.extend(tested_submods.move_iter().map(|r| {\n+        let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, cx.reexport_mod_ident]);\n+        cx.ext_cx.view_use_simple_(DUMMY_SP, ast::Public, r, path)\n+    }));\n+\n     let reexport_mod = ast::Mod {\n         inner: DUMMY_SP,\n         view_items: view_items,\n@@ -190,7 +205,6 @@ fn generate_test_harness(sess: &Session, krate: ast::Crate) -> ast::Crate {\n                                  crate_name: \"test\".to_string(),\n                              }),\n         path: Vec::new(),\n-        reexports: Vec::new(),\n         testfns: Vec::new(),\n         reexport_mod_ident: token::str_to_ident(\"__test_reexports\"),\n         is_test_crate: is_test_crate(&krate),\n@@ -208,6 +222,8 @@ fn generate_test_harness(sess: &Session, krate: ast::Crate) -> ast::Crate {\n \n     let mut fold = TestHarnessGenerator {\n         cx: cx,\n+        tests: Vec::new(),\n+        tested_submods: Vec::new(),\n     };\n     let res = fold.fold_crate(krate);\n     fold.cx.ext_cx.bt_pop();\n@@ -448,11 +464,8 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> Gc<ast::Expr> {\n           span: span\n     };\n \n-    let mut visible_path = Vec::new();\n-    for ident in path.move_iter() {\n-        visible_path.push(cx.reexport_mod_ident.clone());\n-        visible_path.push(ident);\n-    }\n+    let mut visible_path = vec![cx.reexport_mod_ident.clone()];\n+    visible_path.extend(path.move_iter());\n     let fn_path = cx.ext_cx.path_global(DUMMY_SP, visible_path);\n \n     let fn_expr = box(GC) ast::Expr {"}]}