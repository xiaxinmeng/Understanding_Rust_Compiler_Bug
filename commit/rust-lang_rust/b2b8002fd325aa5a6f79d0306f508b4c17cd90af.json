{"sha": "b2b8002fd325aa5a6f79d0306f508b4c17cd90af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYjgwMDJmZDMyNWFhNWE2Zjc5ZDAzMDZmNTA4YjRjMTdjZDkwYWY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-15T19:38:43Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-15T19:39:27Z"}, "message": "Fix unsafe uses of aliases in tail calls", "tree": {"sha": "eb703852649477aa42d5b07aa12c4b1b41ae8b71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb703852649477aa42d5b07aa12c4b1b41ae8b71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2b8002fd325aa5a6f79d0306f508b4c17cd90af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b8002fd325aa5a6f79d0306f508b4c17cd90af", "html_url": "https://github.com/rust-lang/rust/commit/b2b8002fd325aa5a6f79d0306f508b4c17cd90af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2b8002fd325aa5a6f79d0306f508b4c17cd90af/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0987b17dcbe4a0a8f40d91c02823082ee8d5565f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0987b17dcbe4a0a8f40d91c02823082ee8d5565f", "html_url": "https://github.com/rust-lang/rust/commit/0987b17dcbe4a0a8f40d91c02823082ee8d5565f"}], "stats": {"total": 71, "additions": 44, "deletions": 27}, "files": [{"sha": "9605f4d6e63d11ed9f3f55aec7ab77da47fe514e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2b8002fd325aa5a6f79d0306f508b4c17cd90af/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b8002fd325aa5a6f79d0306f508b4c17cd90af/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b2b8002fd325aa5a6f79d0306f508b4c17cd90af", "patch": "@@ -1115,7 +1115,7 @@ fn trans_non_gc_free(&@block_ctxt cx, ValueRef v) -> result {\n fn find_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n     if (cx.kind != NON_SCOPE_BLOCK) { ret cx; }\n     alt (cx.parent) {\n-        case (parent_some(?b)) { be find_scope_cx(b); }\n+        case (parent_some(?b)) { ret find_scope_cx(b); }\n         case (parent_none) {\n             cx.fcx.lcx.ccx.sess.bug(\"trans::find_scope_cx() \" +\n                                         \"called on parentless block_ctxt\");\n@@ -2455,7 +2455,7 @@ fn iter_structural_ty(&@block_ctxt cx, ValueRef v, &ty::t t, val_and_ty_fn f)\n                   ty::t t) -> result {\n         ret f(cx, av, t);\n     }\n-    be iter_structural_ty_full(cx, v, v, t, bind adaptor_fn(f, _, _, _, _));\n+    ret iter_structural_ty_full(cx, v, v, t, bind adaptor_fn(f, _, _, _, _));\n }\n \n fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n@@ -2693,8 +2693,8 @@ fn iter_sequence_inner(&@block_ctxt cx, ValueRef src,\n         ret f(cx, load_if_immediate(cx, p, elt_ty), elt_ty);\n     }\n     auto elt_sz = size_of(cx, elt_ty);\n-    be iter_sequence_raw(elt_sz.bcx, src, src, src_lim, elt_sz.val,\n-                         bind adaptor_fn(f, elt_ty, _, _, _));\n+    ret iter_sequence_raw(elt_sz.bcx, src, src, src_lim, elt_sz.val,\n+                          bind adaptor_fn(f, elt_ty, _, _, _));\n }\n \n "}, {"sha": "48ca4d8a8bc843043589cd8994fdd536c33293c9", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2b8002fd325aa5a6f79d0306f508b4c17cd90af/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b8002fd325aa5a6f79d0306f508b4c17cd90af/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=b2b8002fd325aa5a6f79d0306f508b4c17cd90af", "patch": "@@ -388,7 +388,7 @@ mod write {\n     // Writes a type parameter count and type pair into the node type table.\n     fn ty(&ty::ctxt tcx, uint node_id, &ty_param_substs_opt_and_ty tpot) {\n         assert (!ty::type_contains_vars(tcx, tpot._1));\n-        be inner(tcx.node_types, node_id, tpot);\n+        ret inner(tcx.node_types, node_id, tpot);\n     }\n \n     // Writes a type parameter count and type pair into the node type table.\n@@ -404,23 +404,23 @@ mod write {\n \n     // Writes a type with no type parameters into the node type table.\n     fn ty_only(&ty::ctxt tcx, uint node_id, ty::t typ) {\n-        be ty(tcx, node_id, tup(none[vec[ty::t]], typ));\n+        ret ty(tcx, node_id, tup(none[vec[ty::t]], typ));\n     }\n \n     // Writes a type with no type parameters into the node type table. This\n     // function allows for the possibility of type variables.\n     fn ty_only_fixup(@fn_ctxt fcx, uint node_id, ty::t typ) {\n-        be ty_fixup(fcx, node_id, tup(none[vec[ty::t]], typ));\n+        ret ty_fixup(fcx, node_id, tup(none[vec[ty::t]], typ));\n     }\n \n     // Writes a nil type into the node type table.\n     fn nil_ty(&ty::ctxt tcx, uint node_id) {\n-        be ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n+        ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n     }\n \n     // Writes the bottom type into the node type table.\n     fn bot_ty(&ty::ctxt tcx, uint node_id) {\n-        be ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_bot(tcx)));\n+        ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_bot(tcx)));\n     }\n }\n "}, {"sha": "a752e005b5e30bbec47cc5ca6ac7716722f2f59b", "filename": "src/lib/list.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b2b8002fd325aa5a6f79d0306f508b4c17cd90af/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b8002fd325aa5a6f79d0306f508b4c17cd90af/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=b2b8002fd325aa5a6f79d0306f508b4c17cd90af", "patch": "@@ -18,35 +18,52 @@ fn from_vec[T](vec[T] v) -> list[T] {\n     ret l;\n }\n \n-fn foldl[T, U](&list[T] ls, &U u, fn(&T, &U) -> U  f) -> U {\n-    alt (ls) {\n-        case (cons(?hd, ?tl)) {\n-            auto u_ = f(hd, u);\n-            be foldl[T, U](*tl, u_, f);\n+fn foldl[T, U](&list[T] ls_, &U u, fn(&T, &U) -> U  f) -> U {\n+    let U accum = u;\n+    auto ls = ls_;\n+    while (true) {\n+        alt (ls) {\n+            case (cons(?hd, ?tl)) {\n+                accum = f(hd, accum);\n+                ls = *tl;\n+            }\n+            case (nil) { break; }\n         }\n-        case (nil) { ret u; }\n     }\n+    ret accum;\n }\n \n-fn find[T, U](&list[T] ls, fn(&T) -> option::t[U]  f) -> option::t[U] {\n-    alt (ls) {\n-        case (cons(?hd, ?tl)) {\n-            alt (f(hd)) {\n-                case (none) { be find[T, U](*tl, f); }\n-                case (some(?res)) { ret some[U](res); }\n+fn find[T, U](&list[T] ls_, fn(&T) -> option::t[U]  f) -> option::t[U] {\n+    auto ls = ls_;\n+    while (true) {\n+        alt (ls) {\n+            case (cons(?hd, ?tl)) {\n+                alt (f(hd)) {\n+                    case (none) { ls = *tl; }\n+                    case (some(?res)) { ret some(res); }\n+                }\n             }\n+            case (nil) { break; }\n         }\n-        case (nil) { ret none[U]; }\n     }\n+    ret none;\n }\n \n-fn has[T](&list[T] ls, &T elt) -> bool {\n-    alt (ls) {\n-        case (cons(?hd, ?tl)) {\n-            if (elt == hd) { ret true; } else { be has(*tl, elt); }\n+fn has[T](&list[T] ls_, &T elt) -> bool {\n+    auto ls = ls_;\n+    while (true) {\n+        alt (ls) {\n+            case (cons(?hd, ?tl)) {\n+                if (elt == hd) {\n+                    ret true;\n+                } else {\n+                    ls = *tl;\n+                }\n+            }\n+            case (nil) { ret false; }\n         }\n-        case (nil) { ret false; }\n     }\n+    ret false; // Typestate checker doesn't understand infinite loops\n }\n \n fn length[T](&list[T] ls) -> uint {"}]}