{"sha": "2c0bc9444eea8677a307c2440b2f206911d5bbbe", "node_id": "C_kwDOAAsO6NoAKDJjMGJjOTQ0NGVlYTg2NzdhMzA3YzI0NDBiMmYyMDY5MTFkNWJiYmU", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2022-03-13T05:39:20Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2022-09-11T05:50:35Z"}, "message": "implement Copy/Clone for generators", "tree": {"sha": "6a9429d879d6caaec5d054fd4c2229d8f753f25d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a9429d879d6caaec5d054fd4c2229d8f753f25d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c0bc9444eea8677a307c2440b2f206911d5bbbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c0bc9444eea8677a307c2440b2f206911d5bbbe", "html_url": "https://github.com/rust-lang/rust/commit/2c0bc9444eea8677a307c2440b2f206911d5bbbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c0bc9444eea8677a307c2440b2f206911d5bbbe/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abd4d2ef0d23553c1d21b90d3b1353e3a42e1edf", "url": "https://api.github.com/repos/rust-lang/rust/commits/abd4d2ef0d23553c1d21b90d3b1353e3a42e1edf", "html_url": "https://github.com/rust-lang/rust/commit/abd4d2ef0d23553c1d21b90d3b1353e3a42e1edf"}], "stats": {"total": 170, "additions": 135, "deletions": 35}, "files": [{"sha": "0be2cbb2094a745076c456186bf1f1acf6f75f37", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 97, "deletions": 32, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/2c0bc9444eea8677a307c2440b2f206911d5bbbe/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0bc9444eea8677a307c2440b2f206911d5bbbe/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=2c0bc9444eea8677a307c2440b2f206911d5bbbe", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_middle::mir::*;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n-use rustc_middle::ty::{self, EarlyBinder, Ty, TyCtxt};\n+use rustc_middle::ty::{self, EarlyBinder, Ty, TyCtxt, GeneratorSubsts};\n use rustc_target::abi::VariantIdx;\n \n use rustc_index::vec::{Idx, IndexVec};\n@@ -323,6 +323,9 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n             builder.tuple_like_shim(dest, src, substs.as_closure().upvar_tys())\n         }\n         ty::Tuple(..) => builder.tuple_like_shim(dest, src, self_ty.tuple_fields()),\n+        ty::Generator(gen_def_id, substs, hir::Movability::Movable) => {\n+            builder.generator_shim(dest, src, *gen_def_id, substs.as_generator())\n+        }\n         _ => bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty),\n     };\n \n@@ -388,7 +391,7 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n     /// offset=0 will give you the index of the next BasicBlock,\n     /// offset=1 will give the index of the next-to-next block,\n     /// offset=-1 will give you the index of the last-created block\n-    fn block_index_offset(&mut self, offset: usize) -> BasicBlock {\n+    fn block_index_offset(&self, offset: usize) -> BasicBlock {\n         BasicBlock::new(self.blocks.len() + offset)\n     }\n \n@@ -461,49 +464,111 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n         );\n     }\n \n-    fn tuple_like_shim<I>(&mut self, dest: Place<'tcx>, src: Place<'tcx>, tys: I)\n+    fn clone_fields<I>(\n+        &mut self,\n+        dest: Place<'tcx>,\n+        src: Place<'tcx>,\n+        target: BasicBlock,\n+        mut unwind: BasicBlock,\n+        tys: I,\n+    ) -> BasicBlock\n     where\n         I: IntoIterator<Item = Ty<'tcx>>,\n     {\n-        let mut previous_field = None;\n         for (i, ity) in tys.into_iter().enumerate() {\n             let field = Field::new(i);\n             let src_field = self.tcx.mk_place_field(src, field, ity);\n \n             let dest_field = self.tcx.mk_place_field(dest, field, ity);\n \n-            // #(2i + 1) is the cleanup block for the previous clone operation\n-            let cleanup_block = self.block_index_offset(1);\n-            // #(2i + 2) is the next cloning block\n-            // (or the Return terminator if this is the last block)\n+            let next_unwind = self.block_index_offset(1);\n             let next_block = self.block_index_offset(2);\n+            self.make_clone_call(dest_field, src_field, ity, next_block, unwind);\n+            self.block(\n+                vec![],\n+                TerminatorKind::Drop {\n+                    place: dest_field,\n+                    target: unwind,\n+                    unwind: None,\n+                },\n+                true,\n+            );\n+            unwind = next_unwind;\n+        }\n+        self.block(\n+            vec![],\n+            TerminatorKind::Goto { target },\n+            false,\n+        );\n+        unwind\n+    }\n \n-            // BB #(2i)\n-            // `dest.i = Clone::clone(&src.i);`\n-            // Goto #(2i + 2) if ok, #(2i + 1) if unwinding happens.\n-            self.make_clone_call(dest_field, src_field, ity, next_block, cleanup_block);\n-\n-            // BB #(2i + 1) (cleanup)\n-            if let Some((previous_field, previous_cleanup)) = previous_field.take() {\n-                // Drop previous field and goto previous cleanup block.\n-                self.block(\n-                    vec![],\n-                    TerminatorKind::Drop {\n-                        place: previous_field,\n-                        target: previous_cleanup,\n-                        unwind: None,\n-                    },\n-                    true,\n-                );\n-            } else {\n-                // Nothing to drop, just resume.\n-                self.block(vec![], TerminatorKind::Resume, true);\n-            }\n+    fn tuple_like_shim<I>(&mut self, dest: Place<'tcx>, src: Place<'tcx>, tys: I)\n+    where\n+        I: IntoIterator<Item = Ty<'tcx>>,\n+    {\n+        self.block(\n+            vec![],\n+            TerminatorKind::Goto { target: self.block_index_offset(3) },\n+            false,\n+        );\n+        let unwind = self.block(vec![], TerminatorKind::Resume, true);\n+        let target = self.block(vec![], TerminatorKind::Return, false);\n \n-            previous_field = Some((dest_field, cleanup_block));\n-        }\n+        let _final_cleanup_block = self.clone_fields(dest, src, target, unwind, tys);\n+    }\n \n-        self.block(vec![], TerminatorKind::Return, false);\n+    fn generator_shim(\n+        &mut self,\n+        dest: Place<'tcx>,\n+        src: Place<'tcx>,\n+        gen_def_id: DefId,\n+        substs: GeneratorSubsts<'tcx>,\n+    ) {\n+        self.block(\n+            vec![],\n+            TerminatorKind::Goto { target: self.block_index_offset(3) },\n+            false,\n+        );\n+        let unwind = self.block(vec![], TerminatorKind::Resume, true);\n+        // This will get overwritten with a switch once we know the target blocks\n+        let switch = self.block(vec![], TerminatorKind::Unreachable, false);\n+        let unwind = self.clone_fields(dest, src, switch, unwind, substs.upvar_tys());\n+        let target = self.block(vec![], TerminatorKind::Return, false);\n+        let unreachable = self.block(vec![], TerminatorKind::Unreachable, false);\n+        let mut cases = Vec::with_capacity(substs.state_tys(gen_def_id, self.tcx).count());\n+        for (index, state_tys) in substs.state_tys(gen_def_id, self.tcx).enumerate() {\n+            let variant_index = VariantIdx::new(index);\n+            let dest = self.tcx.mk_place_downcast_unnamed(dest, variant_index);\n+            let src = self.tcx.mk_place_downcast_unnamed(src, variant_index);\n+            let start_block = self.block_index_offset(0);\n+            let clone_block = self.block_index_offset(1);\n+            cases.push((index as u128, start_block));\n+            self.block(\n+                vec![self.make_statement(StatementKind::SetDiscriminant {\n+                    place: Box::new(Place::return_place()),\n+                    variant_index,\n+                })],\n+                TerminatorKind::Goto { target: clone_block },\n+                false,\n+            );\n+            let _final_cleanup_block = self.clone_fields(dest, src, target, unwind, state_tys);\n+        }\n+        let discr_ty = substs.discr_ty(self.tcx);\n+        let temp = self.make_place(Mutability::Mut, discr_ty);\n+        let rvalue = Rvalue::Discriminant(src);\n+        let statement = self.make_statement(StatementKind::Assign(Box::new((temp, rvalue))));\n+        match &mut self.blocks[switch] {\n+            BasicBlockData { statements, terminator: Some(Terminator { kind, .. }), .. } => {\n+                statements.push(statement);\n+                *kind = TerminatorKind::SwitchInt {\n+                    discr: Operand::Move(temp),\n+                    switch_ty: discr_ty,\n+                    targets: SwitchTargets::new(cases.into_iter(), unreachable),\n+                };\n+            },\n+            BasicBlockData { terminator: None, .. } => unreachable!(),\n+        }\n     }\n }\n "}, {"sha": "592c6c8e05564fb8a357c5f1d5ab1554d3cb27a6", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2c0bc9444eea8677a307c2440b2f206911d5bbbe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0bc9444eea8677a307c2440b2f206911d5bbbe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=2c0bc9444eea8677a307c2440b2f206911d5bbbe", "patch": "@@ -1928,8 +1928,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::Dynamic(..)\n             | ty::Str\n             | ty::Slice(..)\n-            | ty::Generator(..)\n-            | ty::GeneratorWitness(..)\n+            | ty::Generator(_, _, hir::Movability::Static)\n             | ty::Foreign(..)\n             | ty::Ref(_, _, hir::Mutability::Mut) => None,\n \n@@ -1938,6 +1937,39 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Where(obligation.predicate.rebind(tys.iter().collect()))\n             }\n \n+            ty::Generator(_, substs, hir::Movability::Movable) => {\n+                let resolved_upvars = self.infcx.shallow_resolve(substs.as_generator().tupled_upvars_ty());\n+                let resolved_witness = self.infcx.shallow_resolve(substs.as_generator().witness());\n+                if {\n+                    matches!(resolved_upvars.kind(), ty::Infer(ty::TyVar(_))) ||\n+                    matches!(resolved_witness.kind(), ty::Infer(ty::TyVar(_)))\n+                } {\n+                    // Not yet resolved.\n+                    Ambiguous\n+                } else {\n+                    let mut all = substs.as_generator().upvar_tys().collect::<Vec<_>>();\n+                    all.push(substs.as_generator().witness());\n+                    Where(obligation.predicate.rebind(all))\n+                }\n+            }\n+\n+            ty::GeneratorWitness(binder) => {\n+                let tys = binder.no_bound_vars().unwrap();\n+                let mut iter = tys.iter();\n+                loop {\n+                    let ty = match iter.next() {\n+                        Some(ty) => ty,\n+                        Option::None => {\n+                            break Where(obligation.predicate.rebind(tys.to_vec()))\n+                        },\n+                    };\n+                    let resolved = self.infcx.shallow_resolve(ty);\n+                    if matches!(resolved.kind(), ty::Infer(ty::TyVar(_))) {\n+                        break Ambiguous;\n+                    }\n+                }\n+            }\n+\n             ty::Closure(_, substs) => {\n                 // (*) binder moved here\n                 let ty = self.infcx.shallow_resolve(substs.as_closure().tupled_upvars_ty());"}, {"sha": "87eca3d388b43e3dd84117d0349e70d44c4af01f", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2c0bc9444eea8677a307c2440b2f206911d5bbbe/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0bc9444eea8677a307c2440b2f206911d5bbbe/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=2c0bc9444eea8677a307c2440b2f206911d5bbbe", "patch": "@@ -263,7 +263,10 @@ fn resolve_associated_item<'tcx>(\n                     let is_copy = self_ty.is_copy_modulo_regions(tcx.at(DUMMY_SP), param_env);\n                     match self_ty.kind() {\n                         _ if is_copy => (),\n-                        ty::Closure(..) | ty::Tuple(..) => {}\n+                        ty::Generator(..) |\n+                        ty::GeneratorWitness(..) |\n+                        ty::Closure(..) |\n+                        ty::Tuple(..) => {},\n                         _ => return Ok(None),\n                     };\n "}]}