{"sha": "3e450cf89f9fcb7356a12487ccac7f8e21811095", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNDUwY2Y4OWY5ZmNiNzM1NmExMjQ4N2NjYWM3ZjhlMjE4MTEwOTU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-14T11:37:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-14T11:37:51Z"}, "message": "Merge #6207 #6224 #6226 #6227\n\n6207: Extract ImportAssets out of auto_import r=matklad a=Veykril\n\nSee https://github.com/rust-analyzer/rust-analyzer/pull/6172#issuecomment-707182140\r\n\r\nI couldn't fully pull out `AssistContext` as `find_node_at_offset_with_descend`: https://github.com/rust-analyzer/rust-analyzer/blob/81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61/crates/assists/src/assist_context.rs#L90-L92 requires the `SourceFile` which is private in it and I don't think making it public just for this is the right call?\n\n6224: :arrow_up: salsa r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\n6226: Add reminder to update lsp-extensions.md r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\n6227: Reduce bors timeout r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "6e7ba39d146308ca2ea63cbe6687f84ccf540651", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e7ba39d146308ca2ea63cbe6687f84ccf540651"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e450cf89f9fcb7356a12487ccac7f8e21811095", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfhuMQCRBK7hj4Ov3rIwAAdHIIACTqwXjIlheCx/BykweSaPT/\nxK6+P7YQF13jZO5Jdx56qSzKwX4k34R5s83VSNlU44Sj+rMMNhYiM5LPjXw5P95z\n6WGLwOdtxEyFxEe4xc7UiMshd4N3TZkT/N45OMiu924FXhSTHInRxAH0eKmoPQbV\n1HeqRO/pTzWA9+E6pkgoKr+ycMX2g4v5Zw4/VKBpE/wQg/Pzzey0A8K2Zzp/aJbf\nozxRjvAwFUlO8mfJNMiwRBfw8A6vVVIkSLD737l6w+yKOpT27FrT1S6OMoB9oELs\nND9sC3QyN/zaSbwj/W2oyO49eC5zlAYE9iG8vLswH1y1+bNDEba2cpj8Gd+ZPGk=\n=hKnY\n-----END PGP SIGNATURE-----\n", "payload": "tree 6e7ba39d146308ca2ea63cbe6687f84ccf540651\nparent b62f48f535039e123b46f2d8b3e9d403cbfe1967\nparent 01b410c69a6f79880ab078d231b0d121fac5d21a\nparent 41e2639f35df1f609b0a1ab677872149679a0371\nparent d852189e56056c1c1742ad56a09c4a3e4a75b170\nparent 74b5f7cd82b1dd035439aa3a704dcefdc399dbf9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1602675471 +0000\ncommitter GitHub <noreply@github.com> 1602675471 +0000\n\nMerge #6207 #6224 #6226 #6227\n\n6207: Extract ImportAssets out of auto_import r=matklad a=Veykril\n\nSee https://github.com/rust-analyzer/rust-analyzer/pull/6172#issuecomment-707182140\r\n\r\nI couldn't fully pull out `AssistContext` as `find_node_at_offset_with_descend`: https://github.com/rust-analyzer/rust-analyzer/blob/81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61/crates/assists/src/assist_context.rs#L90-L92 requires the `SourceFile` which is private in it and I don't think making it public just for this is the right call?\n\n6224: :arrow_up: salsa r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\n6226: Add reminder to update lsp-extensions.md r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\n6227: Reduce bors timeout r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e450cf89f9fcb7356a12487ccac7f8e21811095", "html_url": "https://github.com/rust-lang/rust/commit/3e450cf89f9fcb7356a12487ccac7f8e21811095", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e450cf89f9fcb7356a12487ccac7f8e21811095/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b62f48f535039e123b46f2d8b3e9d403cbfe1967", "url": "https://api.github.com/repos/rust-lang/rust/commits/b62f48f535039e123b46f2d8b3e9d403cbfe1967", "html_url": "https://github.com/rust-lang/rust/commit/b62f48f535039e123b46f2d8b3e9d403cbfe1967"}, {"sha": "01b410c69a6f79880ab078d231b0d121fac5d21a", "url": "https://api.github.com/repos/rust-lang/rust/commits/01b410c69a6f79880ab078d231b0d121fac5d21a", "html_url": "https://github.com/rust-lang/rust/commit/01b410c69a6f79880ab078d231b0d121fac5d21a"}, {"sha": "41e2639f35df1f609b0a1ab677872149679a0371", "url": "https://api.github.com/repos/rust-lang/rust/commits/41e2639f35df1f609b0a1ab677872149679a0371", "html_url": "https://github.com/rust-lang/rust/commit/41e2639f35df1f609b0a1ab677872149679a0371"}, {"sha": "d852189e56056c1c1742ad56a09c4a3e4a75b170", "url": "https://api.github.com/repos/rust-lang/rust/commits/d852189e56056c1c1742ad56a09c4a3e4a75b170", "html_url": "https://github.com/rust-lang/rust/commit/d852189e56056c1c1742ad56a09c4a3e4a75b170"}, {"sha": "74b5f7cd82b1dd035439aa3a704dcefdc399dbf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/74b5f7cd82b1dd035439aa3a704dcefdc399dbf9", "html_url": "https://github.com/rust-lang/rust/commit/74b5f7cd82b1dd035439aa3a704dcefdc399dbf9"}], "stats": {"total": 606, "additions": 359, "deletions": 247}, "files": [{"sha": "d470d84f2c87701736cc092f76d4d362dc6040de", "filename": "Cargo.lock", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e450cf89f9fcb7356a12487ccac7f8e21811095/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3e450cf89f9fcb7356a12487ccac7f8e21811095/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3e450cf89f9fcb7356a12487ccac7f8e21811095", "patch": "@@ -1361,11 +1361,11 @@ checksum = \"71d301d4193d031abdd79ff7e3dd721168a9572ef3fe51a1517aba235bd8f86e\"\n \n [[package]]\n name = \"salsa\"\n-version = \"0.15.2\"\n+version = \"0.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9ab29056d4fb4048a5f0d169c9b6e5526160c9ec37aded5a6879c2c9c445a8e4\"\n+checksum = \"d8fadca2ab5de17acf66d744f4888049ca8f1bb9b8a1ab8afd9d032cc959c5dc\"\n dependencies = [\n- \"crossbeam-utils 0.7.2\",\n+ \"crossbeam-utils 0.8.0\",\n  \"indexmap\",\n  \"lock_api\",\n  \"log\",\n@@ -1378,9 +1378,9 @@ dependencies = [\n \n [[package]]\n name = \"salsa-macros\"\n-version = \"0.15.2\"\n+version = \"0.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a1c3aec007c63c4ed4cd7a018529fb0b5575c4562575fc6a40d6cd2ae0b792ef\"\n+checksum = \"cd3904a4ba0a9d0211816177fd34b04c7095443f8cdacd11175064fe541c8fe2\"\n dependencies = [\n  \"heck\",\n  \"proc-macro2\","}, {"sha": "1f660303032ebbb31e1cd9d99d665ad952edcb1c", "filename": "bors.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e450cf89f9fcb7356a12487ccac7f8e21811095/bors.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3e450cf89f9fcb7356a12487ccac7f8e21811095/bors.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bors.toml?ref=3e450cf89f9fcb7356a12487ccac7f8e21811095", "patch": "@@ -6,3 +6,4 @@ status = [\n     \"TypeScript (windows-latest)\",\n ]\n delete_merged_branches = true\n+timeout_sec = 1200 # 20 min"}, {"sha": "e595b5b937af36409f5116c76122421b9a462721", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 28, "deletions": 241, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/3e450cf89f9fcb7356a12487ccac7f8e21811095/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e450cf89f9fcb7356a12487ccac7f8e21811095/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=3e450cf89f9fcb7356a12487ccac7f8e21811095", "patch": "@@ -1,21 +1,9 @@\n-use std::collections::BTreeSet;\n-\n-use either::Either;\n-use hir::{\n-    AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,\n-    Type,\n-};\n-use ide_db::{imports_locator, RootDatabase};\n-use insert_use::ImportScope;\n-use rustc_hash::FxHashSet;\n-use syntax::{\n-    ast::{self, AstNode},\n-    SyntaxNode,\n-};\n+use syntax::ast;\n \n use crate::{\n-    utils::insert_use, utils::mod_path_to_ast, AssistContext, AssistId, AssistKind, Assists,\n-    GroupLabel,\n+    utils::import_assets::{ImportAssets, ImportCandidate},\n+    utils::{insert_use, mod_path_to_ast, ImportScope},\n+    AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n };\n \n // Assist: auto_import\n@@ -38,16 +26,24 @@ use crate::{\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let auto_import_assets = AutoImportAssets::new(ctx)?;\n-    let proposed_imports = auto_import_assets.search_for_imports(ctx);\n+    let import_assets =\n+        if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n+            ImportAssets::for_regular_path(path_under_caret, &ctx.sema)\n+        } else if let Some(method_under_caret) =\n+            ctx.find_node_at_offset_with_descend::<ast::MethodCallExpr>()\n+        {\n+            ImportAssets::for_method_call(method_under_caret, &ctx.sema)\n+        } else {\n+            None\n+        }?;\n+    let proposed_imports = import_assets.search_for_imports(&ctx.sema, &ctx.config.insert_use);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n-    let range = ctx.sema.original_range(&auto_import_assets.syntax_under_caret).range;\n-    let group = auto_import_assets.get_import_group_message();\n-    let scope =\n-        ImportScope::find_insert_use_container(&auto_import_assets.syntax_under_caret, ctx)?;\n+    let range = ctx.sema.original_range(import_assets.syntax_under_caret()).range;\n+    let group = import_group_message(import_assets.import_candidate());\n+    let scope = ImportScope::find_insert_use_container(import_assets.syntax_under_caret(), ctx)?;\n     let syntax = scope.as_syntax_node();\n     for import in proposed_imports {\n         acc.add_group(\n@@ -65,227 +61,18 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     Some(())\n }\n \n-#[derive(Debug)]\n-struct AutoImportAssets {\n-    import_candidate: ImportCandidate,\n-    module_with_name_to_import: Module,\n-    syntax_under_caret: SyntaxNode,\n-}\n-\n-impl AutoImportAssets {\n-    fn new(ctx: &AssistContext) -> Option<Self> {\n-        if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n-            Self::for_regular_path(path_under_caret, &ctx)\n-        } else {\n-            Self::for_method_call(ctx.find_node_at_offset_with_descend()?, &ctx)\n-        }\n-    }\n-\n-    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistContext) -> Option<Self> {\n-        let syntax_under_caret = method_call.syntax().to_owned();\n-        let module_with_name_to_import = ctx.sema.scope(&syntax_under_caret).module()?;\n-        Some(Self {\n-            import_candidate: ImportCandidate::for_method_call(&ctx.sema, &method_call)?,\n-            module_with_name_to_import,\n-            syntax_under_caret,\n-        })\n-    }\n-\n-    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistContext) -> Option<Self> {\n-        let syntax_under_caret = path_under_caret.syntax().to_owned();\n-        if syntax_under_caret.ancestors().find_map(ast::Use::cast).is_some() {\n-            return None;\n-        }\n-\n-        let module_with_name_to_import = ctx.sema.scope(&syntax_under_caret).module()?;\n-        Some(Self {\n-            import_candidate: ImportCandidate::for_regular_path(&ctx.sema, &path_under_caret)?,\n-            module_with_name_to_import,\n-            syntax_under_caret,\n-        })\n-    }\n-\n-    fn get_search_query(&self) -> &str {\n-        match &self.import_candidate {\n-            ImportCandidate::UnqualifiedName(name) => name,\n-            ImportCandidate::QualifierStart(qualifier_start) => qualifier_start,\n-            ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => trait_assoc_item_name,\n-            ImportCandidate::TraitMethod(_, trait_method_name) => trait_method_name,\n-        }\n-    }\n-\n-    fn get_import_group_message(&self) -> GroupLabel {\n-        let name = match &self.import_candidate {\n-            ImportCandidate::UnqualifiedName(name) => format!(\"Import {}\", name),\n-            ImportCandidate::QualifierStart(qualifier_start) => {\n-                format!(\"Import {}\", qualifier_start)\n-            }\n-            ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => {\n-                format!(\"Import a trait for item {}\", trait_assoc_item_name)\n-            }\n-            ImportCandidate::TraitMethod(_, trait_method_name) => {\n-                format!(\"Import a trait for method {}\", trait_method_name)\n-            }\n-        };\n-        GroupLabel(name)\n-    }\n-\n-    fn search_for_imports(&self, ctx: &AssistContext) -> BTreeSet<ModPath> {\n-        let _p = profile::span(\"auto_import::search_for_imports\");\n-        let db = ctx.db();\n-        let current_crate = self.module_with_name_to_import.krate();\n-        imports_locator::find_imports(&ctx.sema, current_crate, &self.get_search_query())\n-            .into_iter()\n-            .filter_map(|candidate| match &self.import_candidate {\n-                ImportCandidate::TraitAssocItem(assoc_item_type, _) => {\n-                    let located_assoc_item = match candidate {\n-                        Either::Left(ModuleDef::Function(located_function)) => located_function\n-                            .as_assoc_item(db)\n-                            .map(|assoc| assoc.container(db))\n-                            .and_then(Self::assoc_to_trait),\n-                        Either::Left(ModuleDef::Const(located_const)) => located_const\n-                            .as_assoc_item(db)\n-                            .map(|assoc| assoc.container(db))\n-                            .and_then(Self::assoc_to_trait),\n-                        _ => None,\n-                    }?;\n-\n-                    let mut trait_candidates = FxHashSet::default();\n-                    trait_candidates.insert(located_assoc_item.into());\n-\n-                    assoc_item_type\n-                        .iterate_path_candidates(\n-                            db,\n-                            current_crate,\n-                            &trait_candidates,\n-                            None,\n-                            |_, assoc| Self::assoc_to_trait(assoc.container(db)),\n-                        )\n-                        .map(ModuleDef::from)\n-                        .map(Either::Left)\n-                }\n-                ImportCandidate::TraitMethod(function_callee, _) => {\n-                    let located_assoc_item =\n-                        if let Either::Left(ModuleDef::Function(located_function)) = candidate {\n-                            located_function\n-                                .as_assoc_item(db)\n-                                .map(|assoc| assoc.container(db))\n-                                .and_then(Self::assoc_to_trait)\n-                        } else {\n-                            None\n-                        }?;\n-\n-                    let mut trait_candidates = FxHashSet::default();\n-                    trait_candidates.insert(located_assoc_item.into());\n-\n-                    function_callee\n-                        .iterate_method_candidates(\n-                            db,\n-                            current_crate,\n-                            &trait_candidates,\n-                            None,\n-                            |_, function| {\n-                                Self::assoc_to_trait(function.as_assoc_item(db)?.container(db))\n-                            },\n-                        )\n-                        .map(ModuleDef::from)\n-                        .map(Either::Left)\n-                }\n-                _ => Some(candidate),\n-            })\n-            .filter_map(|candidate| match candidate {\n-                Either::Left(module_def) => self.module_with_name_to_import.find_use_path_prefixed(\n-                    db,\n-                    module_def,\n-                    ctx.config.insert_use.prefix_kind,\n-                ),\n-                Either::Right(macro_def) => self.module_with_name_to_import.find_use_path_prefixed(\n-                    db,\n-                    macro_def,\n-                    ctx.config.insert_use.prefix_kind,\n-                ),\n-            })\n-            .filter(|use_path| !use_path.segments.is_empty())\n-            .take(20)\n-            .collect::<BTreeSet<_>>()\n-    }\n-\n-    fn assoc_to_trait(assoc: AssocItemContainer) -> Option<Trait> {\n-        if let AssocItemContainer::Trait(extracted_trait) = assoc {\n-            Some(extracted_trait)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-enum ImportCandidate {\n-    /// Simple name like 'HashMap'\n-    UnqualifiedName(String),\n-    /// First part of the qualified name.\n-    /// For 'std::collections::HashMap', that will be 'std'.\n-    QualifierStart(String),\n-    /// A trait associated function (with no self parameter) or associated constant.\n-    /// For 'test_mod::TestEnum::test_function', `Type` is the `test_mod::TestEnum` expression type\n-    /// and `String` is the `test_function`\n-    TraitAssocItem(Type, String),\n-    /// A trait method with self parameter.\n-    /// For 'test_enum.test_method()', `Type` is the `test_enum` expression type\n-    /// and `String` is the `test_method`\n-    TraitMethod(Type, String),\n-}\n-\n-impl ImportCandidate {\n-    fn for_method_call(\n-        sema: &Semantics<RootDatabase>,\n-        method_call: &ast::MethodCallExpr,\n-    ) -> Option<Self> {\n-        if sema.resolve_method_call(method_call).is_some() {\n-            return None;\n-        }\n-        Some(Self::TraitMethod(\n-            sema.type_of_expr(&method_call.receiver()?)?,\n-            method_call.name_ref()?.syntax().to_string(),\n-        ))\n-    }\n-\n-    fn for_regular_path(\n-        sema: &Semantics<RootDatabase>,\n-        path_under_caret: &ast::Path,\n-    ) -> Option<Self> {\n-        if sema.resolve_path(path_under_caret).is_some() {\n-            return None;\n+fn import_group_message(import_candidate: &ImportCandidate) -> GroupLabel {\n+    let name = match import_candidate {\n+        ImportCandidate::UnqualifiedName(candidate)\n+        | ImportCandidate::QualifierStart(candidate) => format!(\"Import {}\", &candidate.name),\n+        ImportCandidate::TraitAssocItem(candidate) => {\n+            format!(\"Import a trait for item {}\", &candidate.name)\n         }\n-\n-        let segment = path_under_caret.segment()?;\n-        if let Some(qualifier) = path_under_caret.qualifier() {\n-            let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n-            let qualifier_start_path =\n-                qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n-            if let Some(qualifier_start_resolution) = sema.resolve_path(&qualifier_start_path) {\n-                let qualifier_resolution = if qualifier_start_path == qualifier {\n-                    qualifier_start_resolution\n-                } else {\n-                    sema.resolve_path(&qualifier)?\n-                };\n-                if let PathResolution::Def(ModuleDef::Adt(assoc_item_path)) = qualifier_resolution {\n-                    Some(ImportCandidate::TraitAssocItem(\n-                        assoc_item_path.ty(sema.db),\n-                        segment.syntax().to_string(),\n-                    ))\n-                } else {\n-                    None\n-                }\n-            } else {\n-                Some(ImportCandidate::QualifierStart(qualifier_start.syntax().to_string()))\n-            }\n-        } else {\n-            Some(ImportCandidate::UnqualifiedName(\n-                segment.syntax().descendants().find_map(ast::NameRef::cast)?.syntax().to_string(),\n-            ))\n+        ImportCandidate::TraitMethod(candidate) => {\n+            format!(\"Import a trait for method {}\", &candidate.name)\n         }\n-    }\n+    };\n+    GroupLabel(name)\n }\n \n #[cfg(test)]"}, {"sha": "b37b0d2b68c345b8050d17ed5f14833fe6404ebc", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e450cf89f9fcb7356a12487ccac7f8e21811095/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e450cf89f9fcb7356a12487ccac7f8e21811095/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=3e450cf89f9fcb7356a12487ccac7f8e21811095", "patch": "@@ -1,5 +1,6 @@\n //! Assorted functions shared by several assists.\n pub(crate) mod insert_use;\n+pub(crate) mod import_assets;\n \n use std::{iter, ops};\n "}, {"sha": "601f51098d0c4a3fea7855f0e460f702da43600e", "filename": "crates/assists/src/utils/import_assets.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/3e450cf89f9fcb7356a12487ccac7f8e21811095/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e450cf89f9fcb7356a12487ccac7f8e21811095/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs?ref=3e450cf89f9fcb7356a12487ccac7f8e21811095", "patch": "@@ -0,0 +1,268 @@\n+//! Look up accessible paths for items.\n+use std::collections::BTreeSet;\n+\n+use either::Either;\n+use hir::{AsAssocItem, AssocItemContainer, ModuleDef, Semantics};\n+use ide_db::{imports_locator, RootDatabase};\n+use rustc_hash::FxHashSet;\n+use syntax::{ast, AstNode, SyntaxNode};\n+\n+use crate::assist_config::InsertUseConfig;\n+\n+#[derive(Debug)]\n+pub(crate) enum ImportCandidate {\n+    /// Simple name like 'HashMap'\n+    UnqualifiedName(PathImportCandidate),\n+    /// First part of the qualified name.\n+    /// For 'std::collections::HashMap', that will be 'std'.\n+    QualifierStart(PathImportCandidate),\n+    /// A trait associated function (with no self parameter) or associated constant.\n+    /// For 'test_mod::TestEnum::test_function', `ty` is the `test_mod::TestEnum` expression type\n+    /// and `name` is the `test_function`\n+    TraitAssocItem(TraitImportCandidate),\n+    /// A trait method with self parameter.\n+    /// For 'test_enum.test_method()', `ty` is the `test_enum` expression type\n+    /// and `name` is the `test_method`\n+    TraitMethod(TraitImportCandidate),\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct TraitImportCandidate {\n+    pub ty: hir::Type,\n+    pub name: String,\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct PathImportCandidate {\n+    pub name: String,\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct ImportAssets {\n+    import_candidate: ImportCandidate,\n+    module_with_name_to_import: hir::Module,\n+    syntax_under_caret: SyntaxNode,\n+}\n+\n+impl ImportAssets {\n+    pub(crate) fn for_method_call(\n+        method_call: ast::MethodCallExpr,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> Option<Self> {\n+        let syntax_under_caret = method_call.syntax().to_owned();\n+        let module_with_name_to_import = sema.scope(&syntax_under_caret).module()?;\n+        Some(Self {\n+            import_candidate: ImportCandidate::for_method_call(sema, &method_call)?,\n+            module_with_name_to_import,\n+            syntax_under_caret,\n+        })\n+    }\n+\n+    pub(crate) fn for_regular_path(\n+        path_under_caret: ast::Path,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> Option<Self> {\n+        let syntax_under_caret = path_under_caret.syntax().to_owned();\n+        if syntax_under_caret.ancestors().find_map(ast::Use::cast).is_some() {\n+            return None;\n+        }\n+\n+        let module_with_name_to_import = sema.scope(&syntax_under_caret).module()?;\n+        Some(Self {\n+            import_candidate: ImportCandidate::for_regular_path(sema, &path_under_caret)?,\n+            module_with_name_to_import,\n+            syntax_under_caret,\n+        })\n+    }\n+\n+    pub(crate) fn syntax_under_caret(&self) -> &SyntaxNode {\n+        &self.syntax_under_caret\n+    }\n+\n+    pub(crate) fn import_candidate(&self) -> &ImportCandidate {\n+        &self.import_candidate\n+    }\n+\n+    fn get_search_query(&self) -> &str {\n+        match &self.import_candidate {\n+            ImportCandidate::UnqualifiedName(candidate)\n+            | ImportCandidate::QualifierStart(candidate) => &candidate.name,\n+            ImportCandidate::TraitAssocItem(candidate)\n+            | ImportCandidate::TraitMethod(candidate) => &candidate.name,\n+        }\n+    }\n+\n+    pub(crate) fn search_for_imports(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        config: &InsertUseConfig,\n+    ) -> BTreeSet<hir::ModPath> {\n+        let _p = profile::span(\"import_assists::search_for_imports\");\n+        self.search_for(sema, Some(config.prefix_kind))\n+    }\n+\n+    /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n+    #[allow(dead_code)]\n+    pub(crate) fn search_for_relative_paths(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> BTreeSet<hir::ModPath> {\n+        let _p = profile::span(\"import_assists::search_for_relative_paths\");\n+        self.search_for(sema, None)\n+    }\n+\n+    fn search_for(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        prefixed: Option<hir::PrefixKind>,\n+    ) -> BTreeSet<hir::ModPath> {\n+        let db = sema.db;\n+        let mut trait_candidates = FxHashSet::default();\n+        let current_crate = self.module_with_name_to_import.krate();\n+\n+        let filter = |candidate: Either<hir::ModuleDef, hir::MacroDef>| {\n+            trait_candidates.clear();\n+            match &self.import_candidate {\n+                ImportCandidate::TraitAssocItem(trait_candidate) => {\n+                    let located_assoc_item = match candidate {\n+                        Either::Left(ModuleDef::Function(located_function)) => {\n+                            located_function.as_assoc_item(db)\n+                        }\n+                        Either::Left(ModuleDef::Const(located_const)) => {\n+                            located_const.as_assoc_item(db)\n+                        }\n+                        _ => None,\n+                    }\n+                    .map(|assoc| assoc.container(db))\n+                    .and_then(Self::assoc_to_trait)?;\n+\n+                    trait_candidates.insert(located_assoc_item.into());\n+\n+                    trait_candidate\n+                        .ty\n+                        .iterate_path_candidates(\n+                            db,\n+                            current_crate,\n+                            &trait_candidates,\n+                            None,\n+                            |_, assoc| Self::assoc_to_trait(assoc.container(db)),\n+                        )\n+                        .map(ModuleDef::from)\n+                        .map(Either::Left)\n+                }\n+                ImportCandidate::TraitMethod(trait_candidate) => {\n+                    let located_assoc_item =\n+                        if let Either::Left(ModuleDef::Function(located_function)) = candidate {\n+                            located_function\n+                                .as_assoc_item(db)\n+                                .map(|assoc| assoc.container(db))\n+                                .and_then(Self::assoc_to_trait)\n+                        } else {\n+                            None\n+                        }?;\n+\n+                    trait_candidates.insert(located_assoc_item.into());\n+\n+                    trait_candidate\n+                        .ty\n+                        .iterate_method_candidates(\n+                            db,\n+                            current_crate,\n+                            &trait_candidates,\n+                            None,\n+                            |_, function| {\n+                                Self::assoc_to_trait(function.as_assoc_item(db)?.container(db))\n+                            },\n+                        )\n+                        .map(ModuleDef::from)\n+                        .map(Either::Left)\n+                }\n+                _ => Some(candidate),\n+            }\n+        };\n+\n+        imports_locator::find_imports(sema, current_crate, &self.get_search_query())\n+            .into_iter()\n+            .filter_map(filter)\n+            .filter_map(|candidate| {\n+                let item: hir::ItemInNs = candidate.either(Into::into, Into::into);\n+                if let Some(prefix_kind) = prefixed {\n+                    self.module_with_name_to_import.find_use_path_prefixed(db, item, prefix_kind)\n+                } else {\n+                    self.module_with_name_to_import.find_use_path(db, item)\n+                }\n+            })\n+            .filter(|use_path| !use_path.segments.is_empty())\n+            .take(20)\n+            .collect::<BTreeSet<_>>()\n+    }\n+\n+    fn assoc_to_trait(assoc: AssocItemContainer) -> Option<hir::Trait> {\n+        if let AssocItemContainer::Trait(extracted_trait) = assoc {\n+            Some(extracted_trait)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl ImportCandidate {\n+    fn for_method_call(\n+        sema: &Semantics<RootDatabase>,\n+        method_call: &ast::MethodCallExpr,\n+    ) -> Option<Self> {\n+        match sema.resolve_method_call(method_call) {\n+            Some(_) => None,\n+            None => Some(Self::TraitMethod(TraitImportCandidate {\n+                ty: sema.type_of_expr(&method_call.receiver()?)?,\n+                name: method_call.name_ref()?.syntax().to_string(),\n+            })),\n+        }\n+    }\n+\n+    fn for_regular_path(\n+        sema: &Semantics<RootDatabase>,\n+        path_under_caret: &ast::Path,\n+    ) -> Option<Self> {\n+        if sema.resolve_path(path_under_caret).is_some() {\n+            return None;\n+        }\n+\n+        let segment = path_under_caret.segment()?;\n+        let candidate = if let Some(qualifier) = path_under_caret.qualifier() {\n+            let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n+            let qualifier_start_path =\n+                qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n+            if let Some(qualifier_start_resolution) = sema.resolve_path(&qualifier_start_path) {\n+                let qualifier_resolution = if qualifier_start_path == qualifier {\n+                    qualifier_start_resolution\n+                } else {\n+                    sema.resolve_path(&qualifier)?\n+                };\n+                match qualifier_resolution {\n+                    hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => {\n+                        ImportCandidate::TraitAssocItem(TraitImportCandidate {\n+                            ty: assoc_item_path.ty(sema.db),\n+                            name: segment.syntax().to_string(),\n+                        })\n+                    }\n+                    _ => return None,\n+                }\n+            } else {\n+                ImportCandidate::QualifierStart(PathImportCandidate {\n+                    name: qualifier_start.syntax().to_string(),\n+                })\n+            }\n+        } else {\n+            ImportCandidate::UnqualifiedName(PathImportCandidate {\n+                name: segment\n+                    .syntax()\n+                    .descendants()\n+                    .find_map(ast::NameRef::cast)?\n+                    .syntax()\n+                    .to_string(),\n+            })\n+        };\n+        Some(candidate)\n+    }\n+}"}, {"sha": "1724d2f85afc015bd38096d68a14a5e62a33a7f2", "filename": "crates/base_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e450cf89f9fcb7356a12487ccac7f8e21811095/crates%2Fbase_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3e450cf89f9fcb7356a12487ccac7f8e21811095/crates%2Fbase_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2FCargo.toml?ref=3e450cf89f9fcb7356a12487ccac7f8e21811095", "patch": "@@ -10,7 +10,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n-salsa = \"0.15.2\"\n+salsa = \"0.16.0\"\n rustc-hash = \"1.1.0\"\n \n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "43a69d6ce75caf33a6350fd3e08011f1984a634c", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e450cf89f9fcb7356a12487ccac7f8e21811095/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e450cf89f9fcb7356a12487ccac7f8e21811095/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=3e450cf89f9fcb7356a12487ccac7f8e21811095", "patch": "@@ -1,3 +1,13 @@\n+<!---\n+lsp_ext.rs hash: 286f8bbac885531a\n+\n+If you need to change the above hash to make the test pass, please check if you\n+need to adjust this doc as well and ping this issue:\n+\n+  https://github.com/rust-analyzer/rust-analyzer/issues/4604\n+\n+--->\n+\n # LSP Extensions\n \n This document describes LSP extensions used by rust-analyzer."}, {"sha": "b3bb9d543a1d1e587333a500fa2838686a06a233", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3e450cf89f9fcb7356a12487ccac7f8e21811095/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e450cf89f9fcb7356a12487ccac7f8e21811095/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=3e450cf89f9fcb7356a12487ccac7f8e21811095", "patch": "@@ -44,6 +44,41 @@ fn smoke_test_docs_generation() {\n     codegen::generate_feature_docs(Mode::Overwrite).unwrap();\n }\n \n+#[test]\n+fn check_lsp_extensions_docs() {\n+    let expected_hash = {\n+        let lsp_ext_rs =\n+            fs2::read_to_string(project_root().join(\"crates/rust-analyzer/src/lsp_ext.rs\"))\n+                .unwrap();\n+        stable_hash(lsp_ext_rs.as_str())\n+    };\n+\n+    let actual_hash = {\n+        let lsp_extensions_md =\n+            fs2::read_to_string(project_root().join(\"docs/dev/lsp-extensions.md\")).unwrap();\n+        let text = lsp_extensions_md\n+            .lines()\n+            .find_map(|line| line.strip_prefix(\"lsp_ext.rs hash:\"))\n+            .unwrap()\n+            .trim();\n+        u64::from_str_radix(text, 16).unwrap()\n+    };\n+\n+    if actual_hash != expected_hash {\n+        panic!(\n+            \"\n+lsp_ext.rs was changed without touching lsp-extensions.md.\n+\n+Expected hash: {:x}\n+Actual hash:   {:x}\n+\n+Please adjust docs/dev/lsp-extensions.md.\n+\",\n+            expected_hash, actual_hash\n+        )\n+    }\n+}\n+\n #[test]\n fn rust_files_are_tidy() {\n     let mut tidy_docs = TidyDocs::default();\n@@ -280,3 +315,13 @@ fn is_exclude_dir(p: &Path, dirs_to_exclude: &[&str]) -> bool {\n         .filter_map(|it| it.as_os_str().to_str())\n         .any(|it| dirs_to_exclude.contains(&it))\n }\n+\n+#[allow(deprecated)]\n+fn stable_hash(text: &str) -> u64 {\n+    use std::hash::{Hash, Hasher, SipHasher};\n+\n+    let text = text.replace('\\r', \"\");\n+    let mut hasher = SipHasher::default();\n+    text.hash(&mut hasher);\n+    hasher.finish()\n+}"}]}