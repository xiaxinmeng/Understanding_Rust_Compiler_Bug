{"sha": "9c25eb7aa3a71fb951564b0ddf131be59c2c951d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMjVlYjdhYTNhNzFmYjk1MTU2NGIwZGRmMTMxYmU1OWMyYzk1MWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-25T19:01:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-25T19:01:10Z"}, "message": "Auto merge of #86595 - a1phyr:allocator_api_for_vecdeque, r=Amanieu\n\nAdd support for custom allocator in `VecDeque`\n\nThis follows the [roadmap](https://github.com/rust-lang/wg-allocators/issues/7) of the allocator WG to add custom allocators to collections.\n\n`@rustbot` modify labels: +A-allocators +T-libs", "tree": {"sha": "c6271de6ff2a94233ea6ffe8ddc9e0e36e99d04b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6271de6ff2a94233ea6ffe8ddc9e0e36e99d04b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c25eb7aa3a71fb951564b0ddf131be59c2c951d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c25eb7aa3a71fb951564b0ddf131be59c2c951d", "html_url": "https://github.com/rust-lang/rust/commit/9c25eb7aa3a71fb951564b0ddf131be59c2c951d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "478126c0f3520ccd95a6f16be2812a78e3da711c", "url": "https://api.github.com/repos/rust-lang/rust/commits/478126c0f3520ccd95a6f16be2812a78e3da711c", "html_url": "https://github.com/rust-lang/rust/commit/478126c0f3520ccd95a6f16be2812a78e3da711c"}, {"sha": "8987b74164507db4dc4d578f7fa0915e6252ae47", "url": "https://api.github.com/repos/rust-lang/rust/commits/8987b74164507db4dc4d578f7fa0915e6252ae47", "html_url": "https://github.com/rust-lang/rust/commit/8987b74164507db4dc4d578f7fa0915e6252ae47"}], "stats": {"total": 215, "additions": 139, "deletions": 76}, "files": [{"sha": "dfa0227dea3b8263f03af04c99d213e18c768cd1", "filename": "library/alloc/src/collections/vec_deque/drain.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=9c25eb7aa3a71fb951564b0ddf131be59c2c951d", "patch": "@@ -2,6 +2,8 @@ use core::iter::FusedIterator;\n use core::ptr::{self, NonNull};\n use core::{fmt, mem};\n \n+use crate::alloc::{Allocator, Global};\n+\n use super::{count, Iter, VecDeque};\n \n /// A draining iterator over the elements of a `VecDeque`.\n@@ -11,15 +13,19 @@ use super::{count, Iter, VecDeque};\n ///\n /// [`drain`]: VecDeque::drain\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-pub struct Drain<'a, T: 'a> {\n+pub struct Drain<\n+    'a,\n+    T: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     pub(crate) after_tail: usize,\n     pub(crate) after_head: usize,\n     pub(crate) iter: Iter<'a, T>,\n-    pub(crate) deque: NonNull<VecDeque<T>>,\n+    pub(crate) deque: NonNull<VecDeque<T, A>>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Drain\")\n             .field(&self.after_tail)\n@@ -30,16 +36,16 @@ impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n+unsafe impl<T: Sync, A: Allocator + Sync> Sync for Drain<'_, T, A> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Send> Send for Drain<'_, T> {}\n+unsafe impl<T: Send, A: Allocator + Send> Send for Drain<'_, T, A> {}\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> Drop for Drain<'_, T> {\n+impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n     fn drop(&mut self) {\n-        struct DropGuard<'r, 'a, T>(&'r mut Drain<'a, T>);\n+        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n \n-        impl<'r, 'a, T> Drop for DropGuard<'r, 'a, T> {\n+        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n             fn drop(&mut self) {\n                 self.0.for_each(drop);\n \n@@ -96,7 +102,7 @@ impl<T> Drop for Drain<'_, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> Iterator for Drain<'_, T> {\n+impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n     type Item = T;\n \n     #[inline]\n@@ -111,15 +117,15 @@ impl<T> Iterator for Drain<'_, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> DoubleEndedIterator for Drain<'_, T> {\n+impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back().map(|elt| unsafe { ptr::read(elt) })\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> ExactSizeIterator for Drain<'_, T> {}\n+impl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Drain<'_, T> {}\n+impl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}"}, {"sha": "5f13c3bf30387bdb74c75ad497c00c35533a797f", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=9c25eb7aa3a71fb951564b0ddf131be59c2c951d", "patch": "@@ -1,6 +1,8 @@\n use core::fmt;\n use core::iter::{FusedIterator, TrustedLen};\n \n+use crate::alloc::{Allocator, Global};\n+\n use super::VecDeque;\n \n /// An owning iterator over the elements of a `VecDeque`.\n@@ -11,19 +13,22 @@ use super::VecDeque;\n /// [`into_iter`]: VecDeque::into_iter\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<T> {\n-    pub(crate) inner: VecDeque<T>,\n+pub struct IntoIter<\n+    T,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    pub(crate) inner: VecDeque<T, A>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\").field(&self.inner).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Iterator for IntoIter<T> {\n+impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     type Item = T;\n \n     #[inline]\n@@ -39,22 +44,22 @@ impl<T> Iterator for IntoIter<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> DoubleEndedIterator for IntoIter<T> {\n+impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IntoIter<T> {\n+impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n     fn is_empty(&self) -> bool {\n         self.inner.is_empty()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for IntoIter<T> {}\n+impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T> TrustedLen for IntoIter<T> {}\n+unsafe impl<T, A: Allocator> TrustedLen for IntoIter<T, A> {}"}, {"sha": "5c7913073fe8780f48c29f98b259caaf0f740a98", "filename": "library/alloc/src/collections/vec_deque/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs?ref=9c25eb7aa3a71fb951564b0ddf131be59c2c951d", "patch": "@@ -1,9 +1,9 @@\n macro_rules! __impl_slice_eq1 {\n     ([$($vars:tt)*] $lhs:ty, $rhs:ty, $($constraints:tt)*) => {\n         #[stable(feature = \"vec_deque_partial_eq_slice\", since = \"1.17.0\")]\n-        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n+        impl<T, U, A: Allocator, $($vars)*> PartialEq<$rhs> for $lhs\n         where\n-            A: PartialEq<B>,\n+            T: PartialEq<U>,\n             $($constraints)*\n         {\n             fn eq(&self, other: &$rhs) -> bool {"}, {"sha": "386c7c2612d572e91ece1bc0254b2a6407b3cf26", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 101, "deletions": 51, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=9c25eb7aa3a71fb951564b0ddf131be59c2c951d", "patch": "@@ -17,6 +17,7 @@ use core::ops::{Index, IndexMut, Range, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice;\n \n+use crate::alloc::{Allocator, Global};\n use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n@@ -88,21 +89,26 @@ const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible\n /// [`make_contiguous`]: VecDeque::make_contiguous\n #[cfg_attr(not(test), rustc_diagnostic_item = \"vecdeque_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct VecDeque<T> {\n+pub struct VecDeque<\n+    T,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n     // to where data should be written.\n     // If tail == head the buffer is empty. The length of the ringbuffer\n     // is defined as the distance between the two.\n     tail: usize,\n     head: usize,\n-    buf: RawVec<T>,\n+    buf: RawVec<T, A>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone> Clone for VecDeque<T> {\n-    fn clone(&self) -> VecDeque<T> {\n-        self.iter().cloned().collect()\n+impl<T: Clone, A: Allocator + Clone> Clone for VecDeque<T, A> {\n+    fn clone(&self) -> Self {\n+        let mut deq = Self::with_capacity_in(self.len(), self.allocator().clone());\n+        deq.extend(self.iter().cloned());\n+        deq\n     }\n \n     fn clone_from(&mut self, other: &Self) {\n@@ -122,7 +128,7 @@ impl<T: Clone> Clone for VecDeque<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T> Drop for VecDeque<T> {\n+unsafe impl<#[may_dangle] T, A: Allocator> Drop for VecDeque<T, A> {\n     fn drop(&mut self) {\n         /// Runs the destructor for all items in the slice when it gets dropped (normally or\n         /// during unwinding).\n@@ -155,7 +161,7 @@ impl<T> Default for VecDeque<T> {\n     }\n }\n \n-impl<T> VecDeque<T> {\n+impl<T, A: Allocator> VecDeque<T, A> {\n     /// Marginally more convenient\n     #[inline]\n     fn ptr(&self) -> *mut T {\n@@ -465,9 +471,10 @@ impl<T> VecDeque<T> {\n     ///\n     /// let vector: VecDeque<u32> = VecDeque::new();\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> VecDeque<T> {\n-        VecDeque::with_capacity(INITIAL_CAPACITY)\n+        VecDeque::new_in(Global)\n     }\n \n     /// Creates an empty `VecDeque` with space for at least `capacity` elements.\n@@ -479,13 +486,45 @@ impl<T> VecDeque<T> {\n     ///\n     /// let vector: VecDeque<u32> = VecDeque::with_capacity(10);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> VecDeque<T> {\n+        Self::with_capacity_in(capacity, Global)\n+    }\n+}\n+\n+impl<T, A: Allocator> VecDeque<T, A> {\n+    /// Creates an empty `VecDeque`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let vector: VecDeque<u32> = VecDeque::new();\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub fn new_in(alloc: A) -> VecDeque<T, A> {\n+        VecDeque::with_capacity_in(INITIAL_CAPACITY, alloc)\n+    }\n+\n+    /// Creates an empty `VecDeque` with space for at least `capacity` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let vector: VecDeque<u32> = VecDeque::with_capacity(10);\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub fn with_capacity_in(capacity: usize, alloc: A) -> VecDeque<T, A> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(capacity + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n         assert!(cap > capacity, \"capacity overflow\");\n \n-        VecDeque { tail: 0, head: 0, buf: RawVec::with_capacity(cap) }\n+        VecDeque { tail: 0, head: 0, buf: RawVec::with_capacity_in(cap, alloc) }\n     }\n \n     /// Provides a reference to the element at the given index.\n@@ -912,6 +951,13 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        self.buf.allocator()\n+    }\n+\n     /// Returns a front-to-back iterator.\n     ///\n     /// # Examples\n@@ -1184,7 +1230,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T>\n+    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T, A>\n     where\n         R: RangeBounds<usize>,\n     {\n@@ -1973,12 +2019,15 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[must_use = \"use `.truncate()` if you don't need the other half\"]\n     #[stable(feature = \"split_off\", since = \"1.4.0\")]\n-    pub fn split_off(&mut self, at: usize) -> Self {\n+    pub fn split_off(&mut self, at: usize) -> Self\n+    where\n+        A: Clone,\n+    {\n         let len = self.len();\n         assert!(at <= len, \"`at` out of bounds\");\n \n         let other_len = len - at;\n-        let mut other = VecDeque::with_capacity(other_len);\n+        let mut other = VecDeque::with_capacity_in(other_len, self.allocator().clone());\n \n         unsafe {\n             let (first_half, second_half) = self.as_slices();\n@@ -2601,7 +2650,7 @@ impl<T> VecDeque<T> {\n     }\n }\n \n-impl<T: Clone> VecDeque<T> {\n+impl<T: Clone, A: Allocator> VecDeque<T, A> {\n     /// Modifies the `VecDeque` in-place so that `len()` is equal to new_len,\n     /// either by removing excess elements from the back or by appending clones of `value`\n     /// to the back.\n@@ -2645,8 +2694,8 @@ fn count(tail: usize, head: usize, size: usize) -> usize {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialEq> PartialEq for VecDeque<A> {\n-    fn eq(&self, other: &VecDeque<A>) -> bool {\n+impl<T: PartialEq, A: Allocator> PartialEq for VecDeque<T, A> {\n+    fn eq(&self, other: &Self) -> bool {\n         if self.len() != other.len() {\n             return false;\n         }\n@@ -2684,32 +2733,32 @@ impl<A: PartialEq> PartialEq for VecDeque<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Eq> Eq for VecDeque<A> {}\n+impl<T: Eq, A: Allocator> Eq for VecDeque<T, A> {}\n \n-__impl_slice_eq1! { [] VecDeque<A>, Vec<B>, }\n-__impl_slice_eq1! { [] VecDeque<A>, &[B], }\n-__impl_slice_eq1! { [] VecDeque<A>, &mut [B], }\n-__impl_slice_eq1! { [const N: usize] VecDeque<A>, [B; N], }\n-__impl_slice_eq1! { [const N: usize] VecDeque<A>, &[B; N], }\n-__impl_slice_eq1! { [const N: usize] VecDeque<A>, &mut [B; N], }\n+__impl_slice_eq1! { [] VecDeque<T, A>, Vec<U, A>, }\n+__impl_slice_eq1! { [] VecDeque<T, A>, &[U], }\n+__impl_slice_eq1! { [] VecDeque<T, A>, &mut [U], }\n+__impl_slice_eq1! { [const N: usize] VecDeque<T, A>, [U; N], }\n+__impl_slice_eq1! { [const N: usize] VecDeque<T, A>, &[U; N], }\n+__impl_slice_eq1! { [const N: usize] VecDeque<T, A>, &mut [U; N], }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialOrd> PartialOrd for VecDeque<A> {\n-    fn partial_cmp(&self, other: &VecDeque<A>) -> Option<Ordering> {\n+impl<T: PartialOrd, A: Allocator> PartialOrd for VecDeque<T, A> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         self.iter().partial_cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Ord> Ord for VecDeque<A> {\n+impl<T: Ord, A: Allocator> Ord for VecDeque<T, A> {\n     #[inline]\n-    fn cmp(&self, other: &VecDeque<A>) -> Ordering {\n+    fn cmp(&self, other: &Self) -> Ordering {\n         self.iter().cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Hash> Hash for VecDeque<A> {\n+impl<T: Hash, A: Allocator> Hash for VecDeque<T, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.len().hash(state);\n         // It's not possible to use Hash::hash_slice on slices\n@@ -2723,26 +2772,26 @@ impl<A: Hash> Hash for VecDeque<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Index<usize> for VecDeque<A> {\n-    type Output = A;\n+impl<T, A: Allocator> Index<usize> for VecDeque<T, A> {\n+    type Output = T;\n \n     #[inline]\n-    fn index(&self, index: usize) -> &A {\n+    fn index(&self, index: usize) -> &T {\n         self.get(index).expect(\"Out of bounds access\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> IndexMut<usize> for VecDeque<A> {\n+impl<T, A: Allocator> IndexMut<usize> for VecDeque<T, A> {\n     #[inline]\n-    fn index_mut(&mut self, index: usize) -> &mut A {\n+    fn index_mut(&mut self, index: usize) -> &mut T {\n         self.get_mut(index).expect(\"Out of bounds access\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> FromIterator<A> for VecDeque<A> {\n-    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> VecDeque<A> {\n+impl<T> FromIterator<T> for VecDeque<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> VecDeque<T> {\n         let iterator = iter.into_iter();\n         let (lower, _) = iterator.size_hint();\n         let mut deq = VecDeque::with_capacity(lower);\n@@ -2752,19 +2801,19 @@ impl<A> FromIterator<A> for VecDeque<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for VecDeque<T> {\n+impl<T, A: Allocator> IntoIterator for VecDeque<T, A> {\n     type Item = T;\n-    type IntoIter = IntoIter<T>;\n+    type IntoIter = IntoIter<T, A>;\n \n     /// Consumes the `VecDeque` into a front-to-back iterator yielding elements by\n     /// value.\n-    fn into_iter(self) -> IntoIter<T> {\n+    fn into_iter(self) -> IntoIter<T, A> {\n         IntoIter { inner: self }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a VecDeque<T> {\n+impl<'a, T, A: Allocator> IntoIterator for &'a VecDeque<T, A> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -2774,7 +2823,7 @@ impl<'a, T> IntoIterator for &'a VecDeque<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n+impl<'a, T, A: Allocator> IntoIterator for &'a mut VecDeque<T, A> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n@@ -2784,8 +2833,8 @@ impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Extend<A> for VecDeque<A> {\n-    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n+impl<T, A: Allocator> Extend<T> for VecDeque<T, A> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         // This function should be the moral equivalent of:\n         //\n         //      for item in iter.into_iter() {\n@@ -2807,7 +2856,7 @@ impl<A> Extend<A> for VecDeque<A> {\n     }\n \n     #[inline]\n-    fn extend_one(&mut self, elem: A) {\n+    fn extend_one(&mut self, elem: T) {\n         self.push_back(elem);\n     }\n \n@@ -2818,7 +2867,7 @@ impl<A> Extend<A> for VecDeque<A> {\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n+impl<'a, T: 'a + Copy, A: Allocator> Extend<&'a T> for VecDeque<T, A> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n@@ -2835,14 +2884,14 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for VecDeque<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self).finish()\n     }\n }\n \n #[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\n-impl<T> From<Vec<T>> for VecDeque<T> {\n+impl<T, A: Allocator> From<Vec<T, A>> for VecDeque<T, A> {\n     /// Turn a [`Vec<T>`] into a [`VecDeque<T>`].\n     ///\n     /// [`Vec<T>`]: crate::vec::Vec\n@@ -2851,7 +2900,7 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n     /// This avoids reallocating where possible, but the conditions for that are\n     /// strict, and subject to change, and so shouldn't be relied upon unless the\n     /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n-    fn from(mut other: Vec<T>) -> Self {\n+    fn from(mut other: Vec<T, A>) -> Self {\n         let len = other.len();\n         if mem::size_of::<T>() == 0 {\n             // There's no actual allocation for ZSTs to worry about capacity,\n@@ -2869,15 +2918,15 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n         }\n \n         unsafe {\n-            let (other_buf, len, capacity) = other.into_raw_parts();\n-            let buf = RawVec::from_raw_parts(other_buf, capacity);\n+            let (other_buf, len, capacity, alloc) = other.into_raw_parts_with_alloc();\n+            let buf = RawVec::from_raw_parts_in(other_buf, capacity, alloc);\n             VecDeque { tail: 0, head: len, buf }\n         }\n     }\n }\n \n #[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\n-impl<T> From<VecDeque<T>> for Vec<T> {\n+impl<T, A: Allocator> From<VecDeque<T, A>> for Vec<T, A> {\n     /// Turn a [`VecDeque<T>`] into a [`Vec<T>`].\n     ///\n     /// [`Vec<T>`]: crate::vec::Vec\n@@ -2907,19 +2956,20 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n     /// assert_eq!(vec.as_ptr(), ptr);\n     /// ```\n-    fn from(mut other: VecDeque<T>) -> Self {\n+    fn from(mut other: VecDeque<T, A>) -> Self {\n         other.make_contiguous();\n \n         unsafe {\n             let other = ManuallyDrop::new(other);\n             let buf = other.buf.ptr();\n             let len = other.len();\n             let cap = other.cap();\n+            let alloc = ptr::read(other.allocator());\n \n             if other.tail != 0 {\n                 ptr::copy(buf.add(other.tail), buf, len);\n             }\n-            Vec::from_raw_parts(buf, len, cap)\n+            Vec::from_raw_parts_in(buf, len, cap, alloc)\n         }\n     }\n }"}, {"sha": "8e3ac9cfd1d87dc919b7cce59bd8fb1ee8a3b663", "filename": "library/alloc/src/collections/vec_deque/pair_slices.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs?ref=9c25eb7aa3a71fb951564b0ddf131be59c2c951d", "patch": "@@ -1,6 +1,8 @@\n use core::cmp::{self};\n use core::mem::replace;\n \n+use crate::alloc::Allocator;\n+\n use super::VecDeque;\n \n /// PairSlices pairs up equal length slice parts of two deques\n@@ -25,7 +27,7 @@ pub struct PairSlices<'a, 'b, T> {\n }\n \n impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n-    pub fn from(to: &'a mut VecDeque<T>, from: &'b VecDeque<T>) -> Self {\n+    pub fn from<A: Allocator>(to: &'a mut VecDeque<T, A>, from: &'b VecDeque<T, A>) -> Self {\n         let (a0, a1) = to.as_mut_slices();\n         let (b0, b1) = from.as_slices();\n         PairSlices { a0, a1, b0, b1 }"}, {"sha": "baeada69d1c9a2883ff095deed89c8fc9b5b4d6b", "filename": "src/test/debuginfo/pretty-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c25eb7aa3a71fb951564b0ddf131be59c2c951d/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs?ref=9c25eb7aa3a71fb951564b0ddf131be59c2c951d", "patch": "@@ -137,8 +137,8 @@\n // cdb-check:    [0x1]            : 42 [Type: int]\n \n // cdb-command: dx vecdeque\n-// cdb-check:vecdeque         : { len=0x2 } [Type: alloc::collections::vec_deque::VecDeque<i32>]\n-// cdb-check:    [<Raw View>]     [Type: alloc::collections::vec_deque::VecDeque<i32>]\n+// cdb-check:vecdeque         : { len=0x2 } [Type: alloc::collections::vec_deque::VecDeque<i32,alloc::alloc::Global>]\n+// cdb-check:    [<Raw View>]     [Type: alloc::collections::vec_deque::VecDeque<i32,alloc::alloc::Global>]\n // cdb-check:    [len]            : 0x2\n // cdb-check:    [capacity]       : 0x8 [Type: unsigned [...]]\n // cdb-check:    [0x0]            : 90 [Type: int]"}]}