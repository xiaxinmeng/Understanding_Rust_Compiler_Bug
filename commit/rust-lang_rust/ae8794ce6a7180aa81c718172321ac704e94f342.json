{"sha": "ae8794ce6a7180aa81c718172321ac704e94f342", "node_id": "C_kwDOAAsO6NoAKGFlODc5NGNlNmE3MTgwYWE4MWM3MTgxNzIzMjFhYzcwNGU5NGYzNDI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-10T08:24:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-10T08:24:40Z"}, "message": "Rollup merge of #98391 - joboet:sgx_parker, r=m-ou-se\n\nReimplement std's thread parker on top of events on SGX\n\nMutex and Condvar are being replaced by more efficient implementations, which need thread parking themselves (see #93740). Therefore, the generic `Parker` needs to be replaced on all platforms where the new lock implementation will be used.\n\nSGX enclaves have a per-thread event state, which allows waiting for and setting specific bits. This is already used by the current mutex implementation. The thread parker can however be much more efficient, as it only needs to store the `TCS` address of one thread. This address is stored in a state variable, which can also be set to indicate the thread was already notified.\n\n`park_timeout` does not guard against spurious wakeups like the current condition variable does. This is allowed by the API of `Parker`, and I think it is better to let users handle these wakeups themselves as the guarding is quite expensive and might not be necessary.\n\n`@jethrogb` as you wrote the initial SGX support for `std`, I assume you are the target maintainer? Could you help me test this, please? Lacking a x86_64 chip, I can't run SGX.", "tree": {"sha": "f7a0bae7048c5ddd5c79478b7d2b05a42bd23e7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7a0bae7048c5ddd5c79478b7d2b05a42bd23e7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae8794ce6a7180aa81c718172321ac704e94f342", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjlEJICRBK7hj4Ov3rIwAAA58IAIwnoP6RHp0WKXeMQl5XUAzI\nqjIu5GOEEnERPu3OuREzvxC+Qu+TY3JQnIjoWXc+dMYcX0qonYcca9jQpzNEPt4o\nmBYFAzQ7JHXdB+4JzraA+66wkJxh0cx28oCrlZ1C9xobYXB9+9EMBHbUI3DQL+3z\nsXnCvWbmqPfKx5AwLIjX2wIJ6K6j1j/dygJX25HLihGTMVHVL+yL8o+1dBta1G0A\noiyqLKaF4pVT44sEaxdc7TqbA6qIA7SsbZOvRU6Ounem1u2k21J2vgWnO5XTMft9\nuG0eQAnITcQD1yd5FRcaj0tlNN4R5E1LfNOXHScstRD1QwrrwzsZUAGoNBEKSwI=\n=z7Ad\n-----END PGP SIGNATURE-----\n", "payload": "tree f7a0bae7048c5ddd5c79478b7d2b05a42bd23e7b\nparent a000811405e6a3ca9b0b129c1177e78564e09666\nparent a40d300100a5e48cb66f5261738496dbacf11f99\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670660680 +0100\ncommitter GitHub <noreply@github.com> 1670660680 +0100\n\nRollup merge of #98391 - joboet:sgx_parker, r=m-ou-se\n\nReimplement std's thread parker on top of events on SGX\n\nMutex and Condvar are being replaced by more efficient implementations, which need thread parking themselves (see #93740). Therefore, the generic `Parker` needs to be replaced on all platforms where the new lock implementation will be used.\n\nSGX enclaves have a per-thread event state, which allows waiting for and setting specific bits. This is already used by the current mutex implementation. The thread parker can however be much more efficient, as it only needs to store the `TCS` address of one thread. This address is stored in a state variable, which can also be set to indicate the thread was already notified.\n\n`park_timeout` does not guard against spurious wakeups like the current condition variable does. This is allowed by the API of `Parker`, and I think it is better to let users handle these wakeups themselves as the guarding is quite expensive and might not be necessary.\n\n`@jethrogb` as you wrote the initial SGX support for `std`, I assume you are the target maintainer? Could you help me test this, please? Lacking a x86_64 chip, I can't run SGX.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae8794ce6a7180aa81c718172321ac704e94f342", "html_url": "https://github.com/rust-lang/rust/commit/ae8794ce6a7180aa81c718172321ac704e94f342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae8794ce6a7180aa81c718172321ac704e94f342/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a000811405e6a3ca9b0b129c1177e78564e09666", "url": "https://api.github.com/repos/rust-lang/rust/commits/a000811405e6a3ca9b0b129c1177e78564e09666", "html_url": "https://github.com/rust-lang/rust/commit/a000811405e6a3ca9b0b129c1177e78564e09666"}, {"sha": "a40d300100a5e48cb66f5261738496dbacf11f99", "url": "https://api.github.com/repos/rust-lang/rust/commits/a40d300100a5e48cb66f5261738496dbacf11f99", "html_url": "https://github.com/rust-lang/rust/commit/a40d300100a5e48cb66f5261738496dbacf11f99"}], "stats": {"total": 131, "additions": 119, "deletions": 12}, "files": [{"sha": "63e070207cd707cca701b47e7db0ca5e05b6b4eb", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae8794ce6a7180aa81c718172321ac704e94f342/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8794ce6a7180aa81c718172321ac704e94f342/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=ae8794ce6a7180aa81c718172321ac704e94f342", "patch": "@@ -34,6 +34,7 @@ pub mod process;\n pub mod stdio;\n pub mod thread;\n pub mod thread_local_key;\n+pub mod thread_parker;\n pub mod time;\n \n mod condvar;"}, {"sha": "579f758c6cc339fe10f5eb65192851c5e48bf15c", "filename": "library/std/src/sys/sgx/thread.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ae8794ce6a7180aa81c718172321ac704e94f342/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8794ce6a7180aa81c718172321ac704e94f342/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs?ref=ae8794ce6a7180aa81c718172321ac704e94f342", "patch": "@@ -65,39 +65,36 @@ mod task_queue {\n /// execution. The signal is sent once all TLS destructors have finished at\n /// which point no new thread locals should be created.\n pub mod wait_notify {\n-    use super::super::waitqueue::{SpinMutex, WaitQueue, WaitVariable};\n+    use super::super::thread_parker::Parker;\n+    use crate::pin::Pin;\n     use crate::sync::Arc;\n \n-    pub struct Notifier(Arc<SpinMutex<WaitVariable<bool>>>);\n+    pub struct Notifier(Arc<Parker>);\n \n     impl Notifier {\n         /// Notify the waiter. The waiter is either notified right away (if\n         /// currently blocked in `Waiter::wait()`) or later when it calls the\n         /// `Waiter::wait()` method.\n         pub fn notify(self) {\n-            let mut guard = self.0.lock();\n-            *guard.lock_var_mut() = true;\n-            let _ = WaitQueue::notify_one(guard);\n+            Pin::new(&*self.0).unpark()\n         }\n     }\n \n-    pub struct Waiter(Arc<SpinMutex<WaitVariable<bool>>>);\n+    pub struct Waiter(Arc<Parker>);\n \n     impl Waiter {\n         /// Wait for a notification. If `Notifier::notify()` has already been\n         /// called, this will return immediately, otherwise the current thread\n         /// is blocked until notified.\n         pub fn wait(self) {\n-            let guard = self.0.lock();\n-            if *guard.lock_var() {\n-                return;\n-            }\n-            WaitQueue::wait(guard, || {});\n+            // This is not actually `unsafe`, but it uses the `Parker` API,\n+            // which needs `unsafe` on some platforms.\n+            unsafe { Pin::new(&*self.0).park() }\n         }\n     }\n \n     pub fn new() -> (Notifier, Waiter) {\n-        let inner = Arc::new(SpinMutex::new(WaitVariable::new(false)));\n+        let inner = Arc::new(Parker::new_internal());\n         (Notifier(inner.clone()), Waiter(inner))\n     }\n }"}, {"sha": "1c55bcffb1e8c2dc3650e918177026d9b7cc2250", "filename": "library/std/src/sys/sgx/thread_parker.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ae8794ce6a7180aa81c718172321ac704e94f342/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8794ce6a7180aa81c718172321ac704e94f342/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs?ref=ae8794ce6a7180aa81c718172321ac704e94f342", "patch": "@@ -0,0 +1,107 @@\n+//! Thread parking based on SGX events.\n+\n+use super::abi::{thread, usercalls};\n+use crate::io::ErrorKind;\n+use crate::pin::Pin;\n+use crate::ptr::{self, NonNull};\n+use crate::sync::atomic::AtomicPtr;\n+use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n+use crate::time::Duration;\n+use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n+\n+// The TCS structure must be page-aligned (this is checked by EENTER), so these cannot\n+// be valid pointers\n+const EMPTY: *mut u8 = ptr::invalid_mut(1);\n+const NOTIFIED: *mut u8 = ptr::invalid_mut(2);\n+\n+pub struct Parker {\n+    /// The park state. One of EMPTY, NOTIFIED or a TCS address.\n+    /// A state change to NOTIFIED must be done with release ordering\n+    /// and be observed with acquire ordering so that operations after\n+    /// `thread::park` returns will not occur before the unpark message\n+    /// was sent.\n+    state: AtomicPtr<u8>,\n+}\n+\n+impl Parker {\n+    /// Construct the thread parker. The UNIX parker implementation\n+    /// requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        unsafe { parker.write(Parker::new_internal()) }\n+    }\n+\n+    pub(super) fn new_internal() -> Parker {\n+        Parker { state: AtomicPtr::new(EMPTY) }\n+    }\n+\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        if self.state.load(Acquire) != NOTIFIED {\n+            let mut prev = EMPTY;\n+            loop {\n+                // Guard against changing TCS addresses by always setting the state to\n+                // the current value.\n+                let tcs = thread::current().as_ptr();\n+                if self.state.compare_exchange(prev, tcs, Relaxed, Acquire).is_ok() {\n+                    let event = usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n+                    assert!(event & EV_UNPARK == EV_UNPARK);\n+                    prev = tcs;\n+                } else {\n+                    // The state was definitely changed by another thread at this point.\n+                    // The only time this occurs is when the state is changed to NOTIFIED.\n+                    // We observed this change with acquire ordering, so we can simply\n+                    // change the state to EMPTY with a relaxed store.\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // At this point, the token was definately read with acquire ordering,\n+        // so this can be a relaxed store.\n+        self.state.store(EMPTY, Relaxed);\n+    }\n+\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        let timeout = u128::min(dur.as_nanos(), WAIT_INDEFINITE as u128 - 1) as u64;\n+        let tcs = thread::current().as_ptr();\n+\n+        if self.state.load(Acquire) != NOTIFIED {\n+            if self.state.compare_exchange(EMPTY, tcs, Relaxed, Acquire).is_ok() {\n+                match usercalls::wait(EV_UNPARK, timeout) {\n+                    Ok(event) => assert!(event & EV_UNPARK == EV_UNPARK),\n+                    Err(e) => {\n+                        assert!(matches!(e.kind(), ErrorKind::TimedOut | ErrorKind::WouldBlock))\n+                    }\n+                }\n+\n+                // Swap to provide acquire ordering even if the timeout occurred\n+                // before the token was set. This situation can result in spurious\n+                // wakeups on the next call to `park_timeout`, but it is better to let\n+                // those be handled by the user than do some perhaps unnecessary, but\n+                // always expensive guarding.\n+                self.state.swap(EMPTY, Acquire);\n+                return;\n+            }\n+        }\n+\n+        // The token was already read with `acquire` ordering, this can be a store.\n+        self.state.store(EMPTY, Relaxed);\n+    }\n+\n+    // This implementation doesn't require `Pin`, but other implementations do.\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+\n+        if !matches!(state, EMPTY | NOTIFIED) {\n+            // There is a thread waiting, wake it up.\n+            let tcs = NonNull::new(state).unwrap();\n+            // This will fail if the thread has already terminated or its TCS is destroyed\n+            // by the time the signal is sent, but that is fine. If another thread receives\n+            // the same TCS, it will receive this notification as a spurious wakeup, but\n+            // all users of `wait` should and (internally) do guard against those where\n+            // necessary.\n+            let _ = usercalls::send(EV_UNPARK, Some(tcs));\n+        }\n+    }\n+}"}, {"sha": "08a2bdd82298b9f622e5589ff2550d20ccd0658a", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae8794ce6a7180aa81c718172321ac704e94f342/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8794ce6a7180aa81c718172321ac704e94f342/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=ae8794ce6a7180aa81c718172321ac704e94f342", "patch": "@@ -16,6 +16,8 @@ cfg_if::cfg_if! {\n         pub use wait_flag::Parker;\n     } else if #[cfg(any(windows, target_family = \"unix\"))] {\n         pub use crate::sys::thread_parker::Parker;\n+    } else if #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] {\n+        pub use crate::sys::thread_parker::Parker;\n     } else {\n         mod generic;\n         pub use generic::Parker;"}]}