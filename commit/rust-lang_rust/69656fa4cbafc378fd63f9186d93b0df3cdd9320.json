{"sha": "69656fa4cbafc378fd63f9186d93b0df3cdd9320", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NjU2ZmE0Y2JhZmMzNzhmZDYzZjkxODZkOTNiMGRmM2NkZDkzMjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-13T17:11:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-13T17:11:36Z"}, "message": "Auto merge of #62659 - Centril:rollup-90oz643, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #62577 (Add an AtomicCell abstraction)\n - #62585 (Make struct_tail normalize when possible)\n - #62604 (Handle errors during error recovery gracefully)\n - #62636 (rustbuild: Improve assert about building tools once)\n - #62651 (Make some rustc macros more hygienic)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "690b6c3c570374a457a346b7462c8c7c9061d6c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/690b6c3c570374a457a346b7462c8c7c9061d6c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69656fa4cbafc378fd63f9186d93b0df3cdd9320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69656fa4cbafc378fd63f9186d93b0df3cdd9320", "html_url": "https://github.com/rust-lang/rust/commit/69656fa4cbafc378fd63f9186d93b0df3cdd9320", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69656fa4cbafc378fd63f9186d93b0df3cdd9320/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec30876f30082a7b32876bd78a8da01f11dcde1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec30876f30082a7b32876bd78a8da01f11dcde1e", "html_url": "https://github.com/rust-lang/rust/commit/ec30876f30082a7b32876bd78a8da01f11dcde1e"}, {"sha": "791ceb6a9c5dfeeeb5fc6098db2022a99c2eec18", "url": "https://api.github.com/repos/rust-lang/rust/commits/791ceb6a9c5dfeeeb5fc6098db2022a99c2eec18", "html_url": "https://github.com/rust-lang/rust/commit/791ceb6a9c5dfeeeb5fc6098db2022a99c2eec18"}], "stats": {"total": 401, "additions": 313, "deletions": 88}, "files": [{"sha": "9a9c89cd9c19923060416d6b3304515c8108c8f7", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -3018,6 +3018,7 @@ name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "a9269a7ad24aba7a9f65808b4937bc0605e77690", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -109,36 +109,63 @@ impl Step for ToolBuild {\n                     continue\n                 }\n \n-                // Don't worry about libs that turn out to be host dependencies\n-                // or build scripts, we only care about target dependencies that\n-                // are in `deps`.\n-                if let Some(maybe_target) = val.1\n-                    .parent()                   // chop off file name\n-                    .and_then(|p| p.parent())   // chop off `deps`\n-                    .and_then(|p| p.parent())   // chop off `release`\n-                    .and_then(|p| p.file_name())\n-                    .and_then(|p| p.to_str())\n-                {\n-                    if maybe_target != &*target {\n-                        continue\n+                // Don't worry about compiles that turn out to be host\n+                // dependencies or build scripts. To skip these we look for\n+                // anything that goes in `.../release/deps` but *doesn't* go in\n+                // `$target/release/deps`. This ensure that outputs in\n+                // `$target/release` are still considered candidates for\n+                // deduplication.\n+                if let Some(parent) = val.1.parent() {\n+                    if parent.ends_with(\"release/deps\") {\n+                        let maybe_target = parent\n+                            .parent()\n+                            .and_then(|p| p.parent())\n+                            .and_then(|p| p.file_name())\n+                            .and_then(|p| p.to_str())\n+                            .unwrap();\n+                        if maybe_target != &*target {\n+                            continue;\n+                        }\n                     }\n                 }\n \n+                // Record that we've built an artifact for `id`, and if one was\n+                // already listed then we need to see if we reused the same\n+                // artifact or produced a duplicate.\n                 let mut artifacts = builder.tool_artifacts.borrow_mut();\n                 let prev_artifacts = artifacts\n                     .entry(target)\n                     .or_default();\n-                if let Some(prev) = prev_artifacts.get(&*id) {\n-                    if prev.1 != val.1 {\n-                        duplicates.push((\n-                            id.to_string(),\n-                            val,\n-                            prev.clone(),\n-                        ));\n+                let prev = match prev_artifacts.get(&*id) {\n+                    Some(prev) => prev,\n+                    None => {\n+                        prev_artifacts.insert(id.to_string(), val);\n+                        continue;\n                     }\n-                    return\n+                };\n+                if prev.1 == val.1 {\n+                    return; // same path, same artifact\n                 }\n-                prev_artifacts.insert(id.to_string(), val);\n+\n+                // If the paths are different and one of them *isn't* inside of\n+                // `release/deps`, then it means it's probably in\n+                // `$target/release`, or it's some final artifact like\n+                // `libcargo.rlib`. In these situations Cargo probably just\n+                // copied it up from `$target/release/deps/libcargo-xxxx.rlib`,\n+                // so if the features are equal we can just skip it.\n+                let prev_no_hash = prev.1.parent().unwrap().ends_with(\"release/deps\");\n+                let val_no_hash = val.1.parent().unwrap().ends_with(\"release/deps\");\n+                if prev.2 == val.2 || !prev_no_hash || !val_no_hash {\n+                    return;\n+                }\n+\n+                // ... and otherwise this looks like we duplicated some sort of\n+                // compilation, so record it to generate an error later.\n+                duplicates.push((\n+                    id.to_string(),\n+                    val,\n+                    prev.clone(),\n+                ));\n             }\n         });\n "}, {"sha": "63e0107a4d882b8504e4333c8397716d231eb3e2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -49,15 +49,13 @@\n #![feature(optin_builtin_traits)]\n #![feature(range_is_empty)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(rustc_attrs)]\n #![feature(slice_patterns)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n #![feature(thread_local)]\n #![feature(trace_macros)]\n #![feature(trusted_len)]\n #![feature(vec_remove_item)]\n-#![feature(step_trait)]\n #![feature(stmt_expr_attributes)]\n #![feature(integer_atomics)]\n #![feature(test)]"}, {"sha": "4ed52a1e96638a88059d59b2fbd27bdd128f5748", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -543,7 +543,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n                 }\n \n-                let unsized_part = tcx.struct_tail(pointee);\n+                let unsized_part = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 let metadata = match unsized_part.sty {\n                     ty::Foreign(..) => {\n                         return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n@@ -1664,7 +1664,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n             ty::Ref(_, pointee, _) |\n             ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let non_zero = !ty.is_unsafe_ptr();\n-                let tail = tcx.struct_tail(pointee);\n+                let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.sty {\n                     ty::Param(_) | ty::Projection(_) => {\n                         debug_assert!(tail.has_param_types() || tail.has_self_ty());\n@@ -2015,7 +2015,7 @@ where\n                     }));\n                 }\n \n-                match tcx.struct_tail(pointee).sty {\n+                match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).sty {\n                     ty::Slice(_) |\n                     ty::Str => tcx.types.usize,\n                     ty::Dynamic(_, _) => {"}, {"sha": "c3ecc04b12e0144e2bc0cc311de656bcb8561e71", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 94, "deletions": 8, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -257,10 +257,46 @@ impl<'tcx> TyCtxt<'tcx> {\n         false\n     }\n \n-    /// Returns the deeply last field of nested structures, or the same type,\n-    /// if not a structure at all. Corresponds to the only possible unsized\n-    /// field, and its type can be used to determine unsizing strategy.\n-    pub fn struct_tail(self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+    /// Attempts to returns the deeply last field of nested structures, but\n+    /// does not apply any normalization in its search. Returns the same type\n+    /// if input `ty` is not a structure at all.\n+    pub fn struct_tail_without_normalization(self, ty: Ty<'tcx>) -> Ty<'tcx>\n+    {\n+        let tcx = self;\n+        tcx.struct_tail_with_normalize(ty, |ty| ty)\n+    }\n+\n+    /// Returns the deeply last field of nested structures, or the same type if\n+    /// not a structure at all. Corresponds to the only possible unsized field,\n+    /// and its type can be used to determine unsizing strategy.\n+    ///\n+    /// Should only be called if `ty` has no inference variables and does not\n+    /// need its lifetimes preserved (e.g. as part of codegen); otherwise\n+    /// normalization attempt may cause compiler bugs.\n+    pub fn struct_tail_erasing_lifetimes(self,\n+                                         ty: Ty<'tcx>,\n+                                         param_env: ty::ParamEnv<'tcx>)\n+                                         -> Ty<'tcx>\n+    {\n+        let tcx = self;\n+        tcx.struct_tail_with_normalize(ty, |ty| tcx.normalize_erasing_regions(param_env, ty))\n+    }\n+\n+    /// Returns the deeply last field of nested structures, or the same type if\n+    /// not a structure at all. Corresponds to the only possible unsized field,\n+    /// and its type can be used to determine unsizing strategy.\n+    ///\n+    /// This is parameterized over the normalization strategy (i.e. how to\n+    /// handle `<T as Trait>::Assoc` and `impl Trait`); pass the identity\n+    /// function to indicate no normalization should take place.\n+    ///\n+    /// See also `struct_tail_erasing_lifetimes`, which is suitable for use\n+    /// during codegen.\n+    pub fn struct_tail_with_normalize(self,\n+                                      mut ty: Ty<'tcx>,\n+                                      normalize: impl Fn(Ty<'tcx>) -> Ty<'tcx>)\n+                                      -> Ty<'tcx>\n+    {\n         loop {\n             match ty.sty {\n                 ty::Adt(def, substs) => {\n@@ -281,6 +317,15 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n \n+                ty::Projection(_) | ty::Opaque(..) => {\n+                    let normalized = normalize(ty);\n+                    if ty == normalized {\n+                        return ty;\n+                    } else {\n+                        ty = normalized;\n+                    }\n+                }\n+\n                 _ => {\n                     break;\n                 }\n@@ -294,10 +339,35 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// structure definitions.\n     /// For `(Foo<Foo<T>>, Foo<dyn Trait>)`, the result will be `(Foo<T>, Trait)`,\n     /// whereas struct_tail produces `T`, and `Trait`, respectively.\n-    pub fn struct_lockstep_tails(self,\n-                                 source: Ty<'tcx>,\n-                                 target: Ty<'tcx>)\n-                                 -> (Ty<'tcx>, Ty<'tcx>) {\n+    ///\n+    /// Should only be called if the types have no inference variables and do\n+    /// not need their lifetimes preserved (e.g. as part of codegen); otherwise\n+    /// normalization attempt may cause compiler bugs.\n+    pub fn struct_lockstep_tails_erasing_lifetimes(self,\n+                                                   source: Ty<'tcx>,\n+                                                   target: Ty<'tcx>,\n+                                                   param_env: ty::ParamEnv<'tcx>)\n+                                                   -> (Ty<'tcx>, Ty<'tcx>)\n+    {\n+        let tcx = self;\n+        tcx.struct_lockstep_tails_with_normalize(\n+            source, target, |ty| tcx.normalize_erasing_regions(param_env, ty))\n+    }\n+\n+    /// Same as applying struct_tail on `source` and `target`, but only\n+    /// keeps going as long as the two types are instances of the same\n+    /// structure definitions.\n+    /// For `(Foo<Foo<T>>, Foo<dyn Trait>)`, the result will be `(Foo<T>, Trait)`,\n+    /// whereas struct_tail produces `T`, and `Trait`, respectively.\n+    ///\n+    /// See also `struct_lockstep_tails_erasing_lifetimes`, which is suitable for use\n+    /// during codegen.\n+    pub fn struct_lockstep_tails_with_normalize(self,\n+                                                source: Ty<'tcx>,\n+                                                target: Ty<'tcx>,\n+                                                normalize: impl Fn(Ty<'tcx>) -> Ty<'tcx>)\n+                                                -> (Ty<'tcx>, Ty<'tcx>)\n+    {\n         let (mut a, mut b) = (source, target);\n         loop {\n             match (&a.sty, &b.sty) {\n@@ -319,6 +389,22 @@ impl<'tcx> TyCtxt<'tcx> {\n                         break;\n                     }\n                 },\n+                (ty::Projection(_), _) | (ty::Opaque(..), _) |\n+                (_, ty::Projection(_)) | (_, ty::Opaque(..)) => {\n+                    // If either side is a projection, attempt to\n+                    // progress via normalization. (Should be safe to\n+                    // apply to both sides as normalization is\n+                    // idempotent.)\n+                    let a_norm = normalize(a);\n+                    let b_norm = normalize(b);\n+                    if a == a_norm && b == b_norm {\n+                        break;\n+                    } else {\n+                        a = a_norm;\n+                        b = b_norm;\n+                    }\n+                }\n+\n                 _ => break,\n             }\n         }"}, {"sha": "00471095f2f3517efcba016c7b74307bfe4fdba7", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -128,7 +128,8 @@ pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n     target: Ty<'tcx>,\n     old_info: Option<Cx::Value>,\n ) -> Cx::Value {\n-    let (source, target) = cx.tcx().struct_lockstep_tails(source, target);\n+    let (source, target) =\n+        cx.tcx().struct_lockstep_tails_erasing_lifetimes(source, target, cx.param_env());\n     match (&source.sty, &target.sty) {\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n             cx.const_usize(len.unwrap_usize(cx.tcx()))"}, {"sha": "13f72e23819a1ac9b62df9b4141225ee7acaaa6c", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -77,11 +77,12 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n     }\n \n     fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n-        if ty.is_sized(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all()) {\n+        let param_env = ty::ParamEnv::reveal_all();\n+        if ty.is_sized(self.tcx().at(DUMMY_SP), param_env) {\n             return false;\n         }\n \n-        let tail = self.tcx().struct_tail(ty);\n+        let tail = self.tcx().struct_tail_erasing_lifetimes(ty, param_env);\n         match tail.sty {\n             ty::Foreign(..) => false,\n             ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,"}, {"sha": "79cbe26e73e836f36c75f20b85b1659b8d6798a8", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -18,6 +18,7 @@ lazy_static = \"1\"\n serialize = { path = \"../libserialize\" }\n graphviz = { path = \"../libgraphviz\" }\n cfg-if = \"0.1.2\"\n+crossbeam-utils = { version = \"0.6.5\", features = [\"nightly\"] }\n stable_deref_trait = \"1.0.0\"\n rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n rayon-core = { version = \"0.2.0\", package = \"rustc-rayon-core\" }"}, {"sha": "c3c76e81606157979557cd3b935c64a8adb7dccd", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -57,12 +57,13 @@ impl Idx for u32 {\n /// `u32::MAX`. You can also customize things like the `Debug` impl,\n /// what traits are derived, and so forth via the macro.\n #[macro_export]\n+#[allow_internal_unstable(step_trait, rustc_attrs)]\n macro_rules! newtype_index {\n     // ---- public rules ----\n \n     // Use default constants\n     ($(#[$attrs:meta])* $v:vis struct $name:ident { .. }) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             // Leave out derives marker so we can use its absence to ensure it comes first\n             @attrs        [$(#[$attrs])*]\n             @type         [$name]\n@@ -74,7 +75,7 @@ macro_rules! newtype_index {\n \n     // Define any constants\n     ($(#[$attrs:meta])* $v:vis struct $name:ident { $($tokens:tt)+ }) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             // Leave out derives marker so we can use its absence to ensure it comes first\n             @attrs        [$(#[$attrs])*]\n             @type         [$name]\n@@ -258,7 +259,7 @@ macro_rules! newtype_index {\n             }\n         }\n \n-        newtype_index!(\n+        $crate::newtype_index!(\n             @handle_debug\n             @derives      [$($derives,)*]\n             @type         [$type]\n@@ -294,7 +295,7 @@ macro_rules! newtype_index {\n      @derives      [$_derive:ident, $($derives:ident,)*]\n      @type         [$type:ident]\n      @debug_format [$debug_format:tt]) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             @handle_debug\n             @derives      [$($derives,)*]\n             @type         [$type]\n@@ -309,7 +310,7 @@ macro_rules! newtype_index {\n      @debug_format [$debug_format:tt]\n                    derive [$($derives:ident),*]\n                    $($tokens:tt)*) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n@@ -329,7 +330,7 @@ macro_rules! newtype_index {\n                    derive [$($derives:ident,)+]\n                    ENCODABLE = custom\n                    $($tokens:tt)*) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             @attrs        [$(#[$attrs])*]\n             @derives      [$($derives,)+]\n             @type         [$type]\n@@ -348,15 +349,15 @@ macro_rules! newtype_index {\n      @debug_format [$debug_format:tt]\n                    derive [$($derives:ident,)+]\n                    $($tokens:tt)*) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             @derives      [$($derives,)+ RustcEncodable,]\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n             @debug_format [$debug_format]\n                           $($tokens)*);\n-        newtype_index!(@decodable $type);\n+        $crate::newtype_index!(@decodable $type);\n     );\n \n     // The case where no derives are added, but encodable is overridden. Don't\n@@ -368,7 +369,7 @@ macro_rules! newtype_index {\n      @debug_format [$debug_format:tt]\n                    ENCODABLE = custom\n                    $($tokens:tt)*) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             @derives      []\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n@@ -385,15 +386,15 @@ macro_rules! newtype_index {\n      @vis          [$v:vis]\n      @debug_format [$debug_format:tt]\n                    $($tokens:tt)*) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             @derives      [RustcEncodable,]\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n             @debug_format [$debug_format]\n                           $($tokens)*);\n-        newtype_index!(@decodable $type);\n+        $crate::newtype_index!(@decodable $type);\n     );\n \n     (@decodable $type:ident) => (\n@@ -420,7 +421,7 @@ macro_rules! newtype_index {\n      @vis          [$v:vis]\n      @debug_format [$debug_format:tt]\n                    $name:ident = $constant:expr) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             @derives      [$($derives,)*]\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n@@ -439,7 +440,7 @@ macro_rules! newtype_index {\n      @debug_format [$debug_format:tt]\n                    $(#[doc = $doc:expr])*\n                    const $name:ident = $constant:expr) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             @derives      [$($derives,)*]\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n@@ -458,7 +459,7 @@ macro_rules! newtype_index {\n      @debug_format [$debug_format:tt]\n                    MAX = $max:expr,\n                    $($tokens:tt)*) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             @derives      [$($derives,)*]\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n@@ -477,7 +478,7 @@ macro_rules! newtype_index {\n      @debug_format [$_debug_format:tt]\n                    DEBUG_FORMAT = $debug_format:tt,\n                    $($tokens:tt)*) => (\n-        newtype_index!(\n+        $crate::newtype_index!(\n             @derives      [$($derives,)*]\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n@@ -499,7 +500,7 @@ macro_rules! newtype_index {\n                    $($tokens:tt)*) => (\n         $(#[doc = $doc])*\n         pub const $name: $type = $type::from_u32_const($constant);\n-        newtype_index!(\n+        $crate::newtype_index!(\n             @derives      [$($derives,)*]\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]"}, {"sha": "3277b85c281443278329629b81c1d6d7f859acae", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -67,6 +67,51 @@ cfg_if! {\n         use std::ops::Add;\n         use std::panic::{resume_unwind, catch_unwind, AssertUnwindSafe};\n \n+        /// This is a single threaded variant of AtomicCell provided by crossbeam.\n+        /// Unlike `Atomic` this is intended for all `Copy` types,\n+        /// but it lacks the explicit ordering arguments.\n+        #[derive(Debug)]\n+        pub struct AtomicCell<T: Copy>(Cell<T>);\n+\n+        impl<T: Copy> AtomicCell<T> {\n+            #[inline]\n+            pub fn new(v: T) -> Self {\n+                AtomicCell(Cell::new(v))\n+            }\n+\n+            #[inline]\n+            pub fn get_mut(&mut self) -> &mut T {\n+                self.0.get_mut()\n+            }\n+        }\n+\n+        impl<T: Copy> AtomicCell<T> {\n+            #[inline]\n+            pub fn into_inner(self) -> T {\n+                self.0.into_inner()\n+            }\n+\n+            #[inline]\n+            pub fn load(&self) -> T {\n+                self.0.get()\n+            }\n+\n+            #[inline]\n+            pub fn store(&self, val: T) {\n+                self.0.set(val)\n+            }\n+\n+            #[inline]\n+            pub fn swap(&self, val: T) -> T {\n+                self.0.replace(val)\n+            }\n+        }\n+\n+        /// This is a single threaded variant of `AtomicU64`, `AtomicUsize`, etc.\n+        /// It differs from `AtomicCell` in that it has explicit ordering arguments\n+        /// and is only intended for use with the native atomic types.\n+        /// You should use this type through the `AtomicU64`, `AtomicUsize`, etc, type aliases\n+        /// as it's not intended to be used separately.\n         #[derive(Debug)]\n         pub struct Atomic<T: Copy>(Cell<T>);\n \n@@ -77,7 +122,8 @@ cfg_if! {\n             }\n         }\n \n-        impl<T: Copy + PartialEq> Atomic<T> {\n+        impl<T: Copy> Atomic<T> {\n+            #[inline]\n             pub fn into_inner(self) -> T {\n                 self.0.into_inner()\n             }\n@@ -92,10 +138,14 @@ cfg_if! {\n                 self.0.set(val)\n             }\n \n+            #[inline]\n             pub fn swap(&self, val: T, _: Ordering) -> T {\n                 self.0.replace(val)\n             }\n+        }\n \n+        impl<T: Copy + PartialEq> Atomic<T> {\n+            #[inline]\n             pub fn compare_exchange(&self,\n                                     current: T,\n                                     new: T,\n@@ -113,6 +163,7 @@ cfg_if! {\n         }\n \n         impl<T: Add<Output=T> + Copy> Atomic<T> {\n+            #[inline]\n             pub fn fetch_add(&self, val: T, _: Ordering) -> T {\n                 let old = self.0.get();\n                 self.0.set(old + val);\n@@ -271,6 +322,8 @@ cfg_if! {\n \n         pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU32, AtomicU64};\n \n+        pub use crossbeam_utils::atomic::AtomicCell;\n+\n         pub use std::sync::Arc as Lrc;\n         pub use std::sync::Weak as Weak;\n "}, {"sha": "d7c39b780bfdf1a7870ffcc6548849a7c25c0f92", "filename": "src/librustc_lint/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_lint%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_lint%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ferror_codes.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -1,4 +1,4 @@\n-use syntax::{register_diagnostic, register_diagnostics};\n+use syntax::register_diagnostics;\n \n register_diagnostics! {\n     E0721, // `await` keyword"}, {"sha": "7c6317365913573b0a0e4aab1f3b4db65d8bf925", "filename": "src/librustc_metadata/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_metadata%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_metadata%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ferror_codes.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -1,6 +1,6 @@\n #![allow(non_snake_case)]\n \n-use syntax::{register_diagnostic, register_diagnostics, register_long_diagnostics};\n+use syntax::{register_diagnostics, register_long_diagnostics};\n \n register_long_diagnostics! {\n E0454: r##\""}, {"sha": "980697360eb7574e95778f7dca4374f89323f723", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -270,7 +270,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         dty: Ty<'tcx>,\n     ) -> InterpResult<'tcx> {\n         // A<Struct> -> A<Trait> conversion\n-        let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n+        let (src_pointee_ty, dest_pointee_ty) =\n+            self.tcx.struct_lockstep_tails_erasing_lifetimes(sty, dty, self.param_env);\n \n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {"}, {"sha": "bcd36ac547c730525d2e0c5a13d7acee428362a5", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -146,7 +146,9 @@ for\n             let value = self.ecx.read_immediate(mplace.into())?;\n             // Handle trait object vtables\n             if let Ok(meta) = value.to_meta() {\n-                if let ty::Dynamic(..) = self.ecx.tcx.struct_tail(referenced_ty).sty {\n+                if let ty::Dynamic(..) =\n+                    self.ecx.tcx.struct_tail_erasing_lifetimes(referenced_ty, self.param_env).sty\n+                {\n                     if let Ok(vtable) = meta.unwrap().to_ptr() {\n                         // explitly choose `Immutable` here, since vtables are immutable, even\n                         // if the reference of the fat pointer is mutable"}, {"sha": "b1b8e9751381add0f0a89d9d11613ea8b4549bd4", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -361,7 +361,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     \"uninitialized data in fat pointer metadata\", self.path);\n                 let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n                 if layout.is_unsized() {\n-                    let tail = self.ecx.tcx.struct_tail(layout.ty);\n+                    let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(layout.ty,\n+                                                                          self.ecx.param_env);\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n                             let vtable = meta.unwrap();"}, {"sha": "f5e4661afa6b1812c2801cee030282a3888e1592", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -15,12 +15,10 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(decl_macro)]\n #![feature(exhaustive_patterns)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(rustc_attrs)]\n #![feature(never_type)]\n #![feature(specialization)]\n #![feature(try_trait)]\n #![feature(unicode_internals)]\n-#![feature(step_trait)]\n #![feature(slice_concat_ext)]\n #![feature(trusted_len)]\n #![feature(try_blocks)]"}, {"sha": "6e9390f77508bc4a2499636dccd9c7c2bbf37a45", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -851,12 +851,13 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     target_ty: Ty<'tcx>,\n ) -> (Ty<'tcx>, Ty<'tcx>) {\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n+        let param_env = ty::ParamEnv::reveal_all();\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n             use syntax_pos::DUMMY_SP;\n-            if ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::reveal_all()) {\n+            if ty.is_sized(tcx.at(DUMMY_SP), param_env) {\n                 return false;\n             }\n-            let tail = tcx.struct_tail(ty);\n+            let tail = tcx.struct_tail_erasing_lifetimes(ty, param_env);\n             match tail.sty {\n                 ty::Foreign(..) => false,\n                 ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n@@ -866,7 +867,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n         if type_has_metadata(inner_source) {\n             (inner_source, inner_target)\n         } else {\n-            tcx.struct_lockstep_tails(inner_source, inner_target)\n+            tcx.struct_lockstep_tails_erasing_lifetimes(inner_source, inner_target, param_env)\n         }\n     };\n "}, {"sha": "36ebe5cf455ff6a46e677767e98f0f09b3d4a909", "filename": "src/librustc_passes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_passes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_passes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Ferror_codes.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -1,6 +1,6 @@\n #![allow(non_snake_case)]\n \n-use syntax::{register_diagnostic, register_diagnostics, register_long_diagnostics};\n+use syntax::{register_diagnostics, register_long_diagnostics};\n \n register_long_diagnostics! {\n /*"}, {"sha": "9e76f52a111b57e02a345947a598524e5f067ba1", "filename": "src/librustc_plugin/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_plugin%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_plugin%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Ferror_codes.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -1,6 +1,6 @@\n #![allow(non_snake_case)]\n \n-use syntax::{register_diagnostic, register_diagnostics, register_long_diagnostics};\n+use syntax::{register_diagnostics, register_long_diagnostics};\n \n register_long_diagnostics! {\n "}, {"sha": "15194a5d1463bea2c4afa02d9f4e31693766abe0", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -1,6 +1,6 @@\n #![allow(non_snake_case)]\n \n-use syntax::{register_diagnostic, register_diagnostics, register_long_diagnostics};\n+use syntax::{register_diagnostics, register_long_diagnostics};\n \n // Error messages for EXXXX errors.  Each message should start and end with a\n // new line, and be wrapped to 80 characters.  In vim you can `:set tw=80` and"}, {"sha": "01586e92aeb1ce2096f100dede06db484c7961ff", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -6,6 +6,7 @@ use crate::spec::Target;\n use std::fmt;\n use std::ops::{Add, Deref, Sub, Mul, AddAssign, Range, RangeInclusive};\n \n+use rustc_data_structures::newtype_index;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use syntax_pos::symbol::{sym, Symbol};\n "}, {"sha": "dcd1eb5acdc8500e401dc8dc36bd0b7373abed6f", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -11,9 +11,7 @@\n \n #![feature(box_syntax)]\n #![feature(nll)]\n-#![feature(rustc_attrs)]\n #![feature(slice_patterns)]\n-#![feature(step_trait)]\n \n #![deny(rust_2018_idioms)]\n #![deny(unused_lifetimes)]\n@@ -23,8 +21,5 @@\n #[allow(unused_extern_crates)]\n extern crate serialize as rustc_serialize; // used by deriving\n \n-#[macro_use]\n-extern crate rustc_data_structures;\n-\n pub mod abi;\n pub mod spec;"}, {"sha": "77d45cfa63c10ed0c07dc4b486bedfe2377faaab", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -315,7 +315,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// See the test case `test/run-pass/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n     fn rvalue_hint(fcx: &FnCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n-        match fcx.tcx.struct_tail(ty).sty {\n+        match fcx.tcx.struct_tail_without_normalization(ty).sty {\n             ty::Slice(_) | ty::Str | ty::Dynamic(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n             }"}, {"sha": "68e5e7d4fd2454176bf54c1d014ceaa02846b31c", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -366,7 +366,8 @@ fn check_item_type(\n \n         let mut forbid_unsized = true;\n         if allow_foreign_ty {\n-            if let ty::Foreign(_) = fcx.tcx.struct_tail(item_ty).sty {\n+            let tail = fcx.tcx.struct_tail_erasing_lifetimes(item_ty, fcx.param_env);\n+            if let ty::Foreign(_) = tail.sty {\n                 forbid_unsized = false;\n             }\n         }"}, {"sha": "b754d0833761e2a86360bcc6b053828c1db0d8be", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -170,19 +170,19 @@ macro_rules! help {\n #[macro_export]\n macro_rules! register_diagnostics {\n     ($($code:tt),*) => (\n-        $(register_diagnostic! { $code })*\n+        $($crate::register_diagnostic! { $code })*\n     );\n     ($($code:tt),*,) => (\n-        $(register_diagnostic! { $code })*\n+        $($crate::register_diagnostic! { $code })*\n     )\n }\n \n #[macro_export]\n macro_rules! register_long_diagnostics {\n     ($($code:tt: $description:tt),*) => (\n-        $(register_diagnostic! { $code, $description })*\n+        $($crate::register_diagnostic! { $code, $description })*\n     );\n     ($($code:tt: $description:tt),*,) => (\n-        $(register_diagnostic! { $code, $description })*\n+        $($crate::register_diagnostic! { $code, $description })*\n     )\n }"}, {"sha": "591f2fb599be3efa1e601509e255e3160a06a9b1", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -18,9 +18,7 @@\n #![feature(label_break_value)]\n #![feature(mem_take)]\n #![feature(nll)]\n-#![feature(rustc_attrs)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(step_trait)]\n #![feature(try_trait)]\n #![feature(unicode_internals)]\n "}, {"sha": "83030e89af3105b060f9fc7f29d409cc98138f48", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -7410,10 +7410,13 @@ impl<'a> Parser<'a> {\n             } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n                 let ident = self.parse_ident().unwrap();\n                 self.bump();  // `(`\n-                let kw_name = if let Ok(Some(_)) = self.parse_self_arg_with_attrs() {\n-                    \"method\"\n-                } else {\n-                    \"function\"\n+                let kw_name = match self.parse_self_arg_with_attrs() {\n+                    Ok(Some(_)) => \"method\",\n+                    Ok(None) => \"function\",\n+                    Err(mut err) => {\n+                        err.cancel();\n+                        \"function\"\n+                    }\n                 };\n                 self.consume_block(token::Paren);\n                 let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {"}, {"sha": "9ec551b439529b0d35a69b11669601a0b9942992", "filename": "src/libsyntax_ext/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibsyntax_ext%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Flibsyntax_ext%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ferror_codes.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -1,6 +1,6 @@\n #![allow(non_snake_case)]\n \n-use syntax::{register_diagnostic, register_long_diagnostics};\n+use syntax::register_long_diagnostics;\n \n // Error messages for EXXXX errors.\n // Each message should start and end with a new line, and be wrapped to 80 characters."}, {"sha": "1192a44a6eecfd9537f82a48a56ca99ef657ff30", "filename": "src/test/run-pass-fulldeps/newtype_index.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -1,9 +1,9 @@\n-#![feature(rustc_attrs, rustc_private, step_trait)]\n+#![feature(rustc_private)]\n \n-#[macro_use] extern crate rustc_data_structures;\n+extern crate rustc_data_structures;\n extern crate serialize as rustc_serialize;\n \n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::{newtype_index, indexed_vec::Idx};\n \n newtype_index!(struct MyIdx { MAX = 0xFFFF_FFFA });\n "}, {"sha": "65845d2c9fece9094789d7c46a3dbfefde8c757a", "filename": "src/test/ui/layout/issue-60431-unsized-tail-behind-projection.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Ftest%2Fui%2Flayout%2Fissue-60431-unsized-tail-behind-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Ftest%2Fui%2Flayout%2Fissue-60431-unsized-tail-behind-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fissue-60431-unsized-tail-behind-projection.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -0,0 +1,35 @@\n+// rust-lang/rust#60431: This is a scenario where to determine the size of\n+// `&Ref<Obstack>`, we need to know the concrete type of the last field in\n+// `Ref<Obstack>` (i.e. its \"struct tail\"), and determining that concrete type\n+// requires normalizing `Obstack::Dyn`.\n+//\n+// The old \"struct tail\" computation did not perform such normalization, and so\n+// the compiler would ICE when trying to figure out if `Ref<Obstack>` is a\n+// dynamically-sized type (DST).\n+\n+// run-pass\n+\n+use std::mem;\n+\n+pub trait Arena {\n+    type Dyn : ?Sized;\n+}\n+\n+pub struct DynRef {\n+    _dummy: [()],\n+}\n+\n+pub struct Ref<A: Arena> {\n+    _value: u8,\n+    _dyn_arena: A::Dyn,\n+}\n+\n+pub struct Obstack;\n+\n+impl Arena for Obstack {\n+    type Dyn = DynRef;\n+}\n+\n+fn main() {\n+    assert_eq!(mem::size_of::<&Ref<Obstack>>(), mem::size_of::<&[()]>());\n+}"}, {"sha": "75b95e740730201d460af9c27586c53a60f44c74", "filename": "src/test/ui/parser/issue-62546.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Ftest%2Fui%2Fparser%2Fissue-62546.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Ftest%2Fui%2Fparser%2Fissue-62546.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62546.rs?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -0,0 +1,3 @@\n+pub t(#\n+//~^ ERROR missing `fn` or `struct` for function or struct definition\n+//~ ERROR this file contains an un-closed delimiter"}, {"sha": "631aac9550585444821e682a9111ce3a83455a9d", "filename": "src/test/ui/parser/issue-62546.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Ftest%2Fui%2Fparser%2Fissue-62546.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69656fa4cbafc378fd63f9186d93b0df3cdd9320/src%2Ftest%2Fui%2Fparser%2Fissue-62546.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62546.stderr?ref=69656fa4cbafc378fd63f9186d93b0df3cdd9320", "patch": "@@ -0,0 +1,17 @@\n+error: this file contains an un-closed delimiter\n+  --> $DIR/issue-62546.rs:3:53\n+   |\n+LL | pub t(#\n+   |      - un-closed delimiter\n+LL |\n+LL |\n+   |                                                     ^\n+\n+error: missing `fn` or `struct` for function or struct definition\n+  --> $DIR/issue-62546.rs:1:4\n+   |\n+LL | pub t(#\n+   | ---^- help: if you meant to call a macro, try: `t!`\n+\n+error: aborting due to 2 previous errors\n+"}]}