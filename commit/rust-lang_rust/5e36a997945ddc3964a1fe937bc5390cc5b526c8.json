{"sha": "5e36a997945ddc3964a1fe937bc5390cc5b526c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMzZhOTk3OTQ1ZGRjMzk2NGExZmU5MzdiYzUzOTBjYzViNTI2Yzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-28T22:54:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-06T13:11:12Z"}, "message": "Refactor trans to replace lvalue and friends with Datum.\n\nAlso:\n- report illegal move/ref combos whether or not ref comes first\n- commented out fix for #3387, too restrictive and causes an ICE", "tree": {"sha": "0c37dfa0d20004d0098e0bbb620744a1ad4a81d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c37dfa0d20004d0098e0bbb620744a1ad4a81d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e36a997945ddc3964a1fe937bc5390cc5b526c8", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e36a997945ddc3964a1fe937bc5390cc5b526c8", "html_url": "https://github.com/rust-lang/rust/commit/5e36a997945ddc3964a1fe937bc5390cc5b526c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e36a997945ddc3964a1fe937bc5390cc5b526c8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adc1427282b4da8f963550e87cdbe512157958b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc1427282b4da8f963550e87cdbe512157958b4", "html_url": "https://github.com/rust-lang/rust/commit/adc1427282b4da8f963550e87cdbe512157958b4"}], "stats": {"total": 11566, "additions": 6456, "deletions": 5110}, "files": [{"sha": "75d3bd4d5eb1be006bb2b2a20fbd9b9f14d001b2", "filename": "Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -100,6 +100,9 @@ endif\n ifdef TIME_LLVM_PASSES\n   CFG_RUSTC_FLAGS += -Z time-llvm-passes\n endif\n+ifdef TRACE\n+  CFG_RUSTC_FLAGS += -Z trace\n+endif\n \n # platform-specific auto-configuration\n include $(CFG_SRC_DIR)mk/platform.mk"}, {"sha": "a27b8fe86bc6842df0a5ed5b0933b13c89272408", "filename": "src/libcore/util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -65,7 +65,9 @@ mod tests {\n     fn identity_crisis() {\n         // Writing a test for the identity function. How did it come to this?\n         let x = ~[(5, false)];\n-        assert x.eq(id(copy x));\n+        //FIXME #3387 assert x.eq(id(copy x));\n+        let y = copy x;\n+        assert x.eq(id(y));\n     }\n     #[test]\n     fn test_swap() {"}, {"sha": "50bad1e748a2f1eaea421b83eb5ce6368912e1d8", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -800,10 +800,11 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(m) => {\n-            assert (opt_present(m, ~\"test\"));\n-            assert (opt_str(m, ~\"test\") == ~\"20\");\n-            assert (opt_strs(m, ~\"test\")[0] == ~\"20\");\n-            assert (opt_strs(m, ~\"test\")[1] == ~\"30\");\n+              assert (opt_present(m, ~\"test\"));\n+              assert (opt_str(m, ~\"test\") == ~\"20\");\n+              let pair = opt_strs(m, ~\"test\");\n+              assert (pair[0] == ~\"20\");\n+              assert (pair[1] == ~\"30\");\n           }\n           _ => fail\n         }\n@@ -854,8 +855,9 @@ mod tests {\n           Ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n-            assert (opt_strs(m, ~\"t\")[0] == ~\"20\");\n-            assert (opt_strs(m, ~\"t\")[1] == ~\"30\");\n+            let pair = opt_strs(m, ~\"t\");\n+            assert (pair[0] == ~\"20\");\n+            assert (pair[1] == ~\"30\");\n           }\n           _ => fail\n         }\n@@ -903,10 +905,12 @@ mod tests {\n             assert (opt_present(m, ~\"flag\"));\n             assert (opt_str(m, ~\"long\") == ~\"30\");\n             assert (opt_present(m, ~\"f\"));\n-            assert (opt_strs(m, ~\"m\")[0] == ~\"40\");\n-            assert (opt_strs(m, ~\"m\")[1] == ~\"50\");\n-            assert (opt_strs(m, ~\"n\")[0] == ~\"-A B\");\n-            assert (opt_strs(m, ~\"n\")[1] == ~\"-60 70\");\n+            let pair = opt_strs(m, ~\"m\");\n+            assert (pair[0] == ~\"40\");\n+            assert (pair[1] == ~\"50\");\n+            let pair = opt_strs(m, ~\"n\");\n+            assert (pair[0] == ~\"-A B\");\n+            assert (pair[1] == ~\"-60 70\");\n             assert (!opt_present(m, ~\"notpresent\"));\n           }\n           _ => fail"}, {"sha": "1735765a474a8a22a7a61f59a74f8b09be910d98", "filename": "src/libstd/par.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -19,7 +19,7 @@ const min_granularity : uint = 1024u;\n  * like map or alli.\n  */\n fn map_slices<A: copy send, B: copy send>(\n-    xs: ~[A],\n+    xs: &[A],\n     f: fn() -> fn~(uint, v: &[A]) -> B)\n     -> ~[B] {\n \n@@ -104,7 +104,7 @@ fn mapi<A: copy send, B: copy send>(xs: ~[A],\n  * inner elements. This is to skirt the need for copy constructors.\n  */\n fn mapi_factory<A: copy send, B: copy send>(\n-    xs: ~[A], f: fn() -> fn~(uint, A) -> B) -> ~[B] {\n+    xs: &[A], f: fn() -> fn~(uint, A) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n         let f = f();\n         fn~(base: uint, slice : &[A], move f) -> ~[B] {"}, {"sha": "8b17760c7f2fc48b5829d2b4140a7bde55601c05", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -1169,29 +1169,38 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n               None => ()\n             }\n             word_space(s, ~\"=>\");\n+\n             // Extract the expression from the extra block the parser adds\n-            assert arm.body.node.view_items.is_empty();\n-            assert arm.body.node.stmts.is_empty();\n-            assert arm.body.node.rules == ast::default_blk;\n-            match arm.body.node.expr {\n-              Some(expr) => {\n-                match expr.node {\n-                  ast::expr_block(blk) => {\n-                    // the block will close the pattern's ibox\n-                    print_block_unclosed_indent(s, blk, alt_indent_unit);\n-                  }\n-                  _ => {\n-                    end(s); // close the ibox for the pattern\n-                    print_expr(s, expr);\n-                  }\n-                }\n-                if !expr_is_simple_block(expr)\n-                    && i < len - 1 {\n-                    word(s.s, ~\",\");\n+            // in the case of foo => expr\n+            if arm.body.node.view_items.is_empty() &&\n+                arm.body.node.stmts.is_empty() &&\n+                arm.body.node.rules == ast::default_blk &&\n+                arm.body.node.expr.is_some()\n+            {\n+                match arm.body.node.expr {\n+                    Some(expr) => {\n+                        match expr.node {\n+                            ast::expr_block(blk) => {\n+                                // the block will close the pattern's ibox\n+                                print_block_unclosed_indent(\n+                                    s, blk, alt_indent_unit);\n+                            }\n+                            _ => {\n+                                end(s); // close the ibox for the pattern\n+                                print_expr(s, expr);\n+                            }\n+                        }\n+                        if !expr_is_simple_block(expr)\n+                            && i < len - 1 {\n+                            word(s.s, ~\",\");\n+                        }\n+                        end(s); // close enclosing cbox\n+                    }\n+                    None => fail\n                 }\n-                end(s); // close enclosing cbox\n-              }\n-              None => fail\n+            } else {\n+                // the block will close the pattern's ibox\n+                print_block_unclosed_indent(s, arm.body, alt_indent_unit);\n             }\n         }\n         bclose_(s, expr.span, alt_indent_unit);"}, {"sha": "e59c1b2b8c7c87b27ecfe57bdbac60bb1f5448ad", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -147,7 +147,6 @@ extern \"C\" CDECL void\n upcall_s_exchange_malloc(s_exchange_malloc_args *args) {\n     rust_task *task = args->task;\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, mem, \"upcall exchange malloc(0x%\" PRIxPTR \")\", args->td);\n \n     size_t total_size = get_box_size(args->size, args->td->align);\n     // FIXME--does this have to be calloc? (Issue #2682)\n@@ -159,6 +158,9 @@ upcall_s_exchange_malloc(s_exchange_malloc_args *args) {\n     header->prev = 0;\n     header->next = 0;\n \n+    LOG(task, mem, \"exchange malloced %p of size %\" PRIuPTR,\n+        header, args->size);\n+\n     args->retval = (uintptr_t)header;\n }\n \n@@ -187,6 +189,7 @@ extern \"C\" CDECL void\n upcall_s_exchange_free(s_exchange_free_args *args) {\n     rust_task *task = args->task;\n     LOG_UPCALL_ENTRY(task);\n+    LOG(task, mem, \"exchange freed %p\", args->ptr);\n     task->kernel->free(args->ptr);\n }\n "}, {"sha": "fe737442bd0563c627c30d9d8a242403f57d76f5", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -456,9 +456,11 @@ extern mod llvm {\n        ValueRef;\n     fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n        ValueRef;\n-    fn LLVMConstGEP(ConstantVal: ValueRef, ConstantIndices: *uint,\n+    fn LLVMConstGEP(ConstantVal: ValueRef,\n+                    ConstantIndices: *ValueRef,\n                     NumIndices: c_uint) -> ValueRef;\n-    fn LLVMConstInBoundsGEP(ConstantVal: ValueRef, ConstantIndices: *uint,\n+    fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n+                            ConstantIndices: *ValueRef,\n                             NumIndices: c_uint) -> ValueRef;\n     fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n     fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n@@ -493,10 +495,10 @@ extern mod llvm {\n     fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n                               VectorBConstant: ValueRef,\n                               MaskConstant: ValueRef) -> ValueRef;\n-    fn LLVMConstExtractValue(AggConstant: ValueRef, IdxList: *uint,\n+    fn LLVMConstExtractValue(AggConstant: ValueRef, IdxList: *c_uint,\n                              NumIdx: c_uint) -> ValueRef;\n     fn LLVMConstInsertValue(AggConstant: ValueRef,\n-                            ElementValueConstant: ValueRef, IdxList: *uint,\n+                            ElementValueConstant: ValueRef, IdxList: *c_uint,\n                             NumIdx: c_uint) -> ValueRef;\n     fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: *c_char,\n                           Constraints: *c_char, HasSideEffects: Bool,"}, {"sha": "176e133529ca6de8301d63ddb82efb1a76d23340", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -220,7 +220,8 @@ use syntax::visit;\n use syntax::ast_util;\n use syntax::ast_map;\n use syntax::codemap::span;\n-use util::ppaux::{ty_to_str, region_to_str, explain_region};\n+use util::ppaux::{ty_to_str, region_to_str, explain_region,\n+                  note_and_explain_region};\n use std::map::{int_hash, hashmap, set};\n use std::list;\n use std::list::{List, Cons, Nil};\n@@ -464,6 +465,7 @@ impl borrowck_ctxt {\n             err.cmt.span,\n             fmt!(\"illegal borrow: %s\",\n                  self.bckerr_code_to_str(err.code)));\n+        self.note_and_explain_bckerr(err.code);\n     }\n \n     fn span_err(s: span, m: ~str) {\n@@ -488,37 +490,65 @@ impl borrowck_ctxt {\n \n     fn bckerr_code_to_str(code: bckerr_code) -> ~str {\n         match code {\n-          err_mutbl(req, act) => {\n-            fmt!(\"creating %s alias to aliasable, %s memory\",\n-                 self.mut_to_str(req), self.mut_to_str(act))\n-          }\n-          err_mut_uniq => {\n-            ~\"unique value in aliasable, mutable location\"\n-          }\n-          err_mut_variant => {\n-            ~\"enum variant in aliasable, mutable location\"\n-          }\n-          err_root_not_permitted => {\n-            // note: I don't expect users to ever see this error\n-            // message, reasons are discussed in attempt_root() in\n-            // preserve.rs.\n-            ~\"rooting is not permitted\"\n-          }\n-          err_out_of_root_scope(super_scope, sub_scope) => {\n-            fmt!(\"managed value would have to be rooted for %s, \\\n-                  but can only be rooted for %s\",\n-                  explain_region(self.tcx, sub_scope),\n-                  explain_region(self.tcx, super_scope))\n-          }\n-          err_out_of_scope(super_scope, sub_scope) => {\n-            fmt!(\"borrowed pointer must be valid for %s, \\\n-                  but the borrowed value is only valid for %s\",\n-                  explain_region(self.tcx, sub_scope),\n-                  explain_region(self.tcx, super_scope))\n+            err_mutbl(req, act) => {\n+                fmt!(\"creating %s alias to aliasable, %s memory\",\n+                     self.mut_to_str(req), self.mut_to_str(act))\n+            }\n+            err_mut_uniq => {\n+                ~\"unique value in aliasable, mutable location\"\n+            }\n+            err_mut_variant => {\n+                ~\"enum variant in aliasable, mutable location\"\n+            }\n+            err_root_not_permitted => {\n+                // note: I don't expect users to ever see this error\n+                // message, reasons are discussed in attempt_root() in\n+                // preserve.rs.\n+                ~\"rooting is not permitted\"\n+            }\n+            err_out_of_root_scope(*) => {\n+                ~\"cannot root managed value long enough\"\n+            }\n+            err_out_of_scope(*) => {\n+                ~\"borrowed value does not live long enough\"\n+            }\n+        }\n+    }\n+\n+    fn note_and_explain_bckerr(code: bckerr_code) {\n+        match code {\n+            err_mutbl(*) | err_mut_uniq | err_mut_variant |\n+            err_root_not_permitted => {}\n+\n+            err_out_of_root_scope(super_scope, sub_scope) => {\n+                note_and_explain_region(\n+                    self.tcx,\n+                    ~\"managed value would have to be rooted for \",\n+                    sub_scope,\n+                    ~\"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    ~\"...but can only be rooted for \",\n+                    super_scope,\n+                    ~\"\");\n+            }\n+\n+            err_out_of_scope(super_scope, sub_scope) => {\n+                note_and_explain_region(\n+                    self.tcx,\n+                    ~\"borrowed pointer must be valid for \",\n+                    sub_scope,\n+                    ~\"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    ~\"...but borrowed value is only valid for \",\n+                    super_scope,\n+                    ~\"\");\n           }\n         }\n     }\n \n+\n     fn cmt_to_str(cmt: cmt) -> ~str {\n         let mc = &mem_categorization_ctxt {tcx: self.tcx,\n                                            method_map: self.method_map};"}, {"sha": "7f2964181d8d0ab470b9758a45cc5405644da6f8", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -423,6 +423,7 @@ impl check_loan_ctxt {\n                     e.cmt.span,\n                     fmt!(\"illegal borrow unless pure: %s\",\n                          self.bccx.bckerr_code_to_str(e.code)));\n+                self.bccx.note_and_explain_bckerr(e.code);\n                 self.tcx().sess.span_note(\n                     sp,\n                     fmt!(\"impure due to %s\", msg));\n@@ -484,10 +485,14 @@ impl check_loan_ctxt {\n     // when there is an outstanding loan.  In that case, it is not\n     // safe to consider the use a last_use.\n     fn check_last_use(expr: @ast::expr) {\n+        debug!(\"Checking last use of expr %?\", expr.id);\n         let cmt = self.bccx.cat_expr(expr);\n         let lp = match cmt.lp {\n-          None => return,\n-          Some(lp) => lp\n+            None => {\n+                debug!(\"Not a loanable expression\");\n+                return;\n+            }\n+            Some(lp) => lp\n         };\n         for self.walk_loans_of(cmt.id, lp) |_loan| {\n             debug!(\"Removing last use entry %? due to outstanding loan\",\n@@ -592,6 +597,9 @@ fn check_loans_in_local(local: @ast::local,\n fn check_loans_in_expr(expr: @ast::expr,\n                        &&self: check_loan_ctxt,\n                        vt: visit::vt<check_loan_ctxt>) {\n+    debug!(\"check_loans_in_expr(expr=%?/%s)\",\n+           expr.id, pprust::expr_to_str(expr, self.tcx().sess.intr()));\n+\n     self.check_for_conflicting_loans(expr.id);\n \n     match expr.node {"}, {"sha": "18e27e79fd1688a78e03dbcff607352d8df8ca54", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -90,8 +90,8 @@ fn req_loans_in_expr(ex: @ast::expr,\n     let tcx = bccx.tcx;\n     let old_root_ub = self.root_ub;\n \n-    debug!(\"req_loans_in_expr(ex=%s)\",\n-           pprust::expr_to_str(ex, tcx.sess.intr()));\n+    debug!(\"req_loans_in_expr(expr=%?/%s)\",\n+           ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     for tcx.borrowings.find(ex.id).each |borrow| {\n@@ -200,6 +200,21 @@ fn req_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, self, vt);\n       }\n \n+      // FIXME--#3387\n+      // ast::expr_binary(_, lhs, rhs) => {\n+      //     // Universal comparison operators like ==, >=, etc\n+      //     // take their arguments by reference.\n+      //     let lhs_ty = ty::expr_ty(self.tcx(), lhs);\n+      //     if !ty::type_is_scalar(lhs_ty) {\n+      //         let scope_r = ty::re_scope(ex.id);\n+      //         let lhs_cmt = self.bccx.cat_expr(lhs);\n+      //         self.guarantee_valid(lhs_cmt, m_imm, scope_r);\n+      //         let rhs_cmt = self.bccx.cat_expr(rhs);\n+      //         self.guarantee_valid(rhs_cmt, m_imm, scope_r);\n+      //     }\n+      //     visit::visit_expr(ex, self, vt);\n+      // }\n+\n       ast::expr_field(rcvr, _, _)\n       if self.bccx.method_map.contains_key(ex.id) => {\n         // Receivers in method calls are always passed by ref.\n@@ -395,14 +410,15 @@ impl gather_loan_ctxt {\n     }\n \n     fn add_loans(scope_id: ast::node_id, loans: @DVec<loan>) {\n+        debug!(\"adding %u loans to scope_id %?\", loans.len(), scope_id);\n         match self.req_maps.req_loan_map.find(scope_id) {\n-          Some(l) => {\n-            (*l).push(loans);\n-          }\n-          None => {\n-            self.req_maps.req_loan_map.insert(\n-                scope_id, @dvec::from_vec(~[mut loans]));\n-          }\n+            Some(l) => {\n+                l.push(loans);\n+            }\n+            None => {\n+                self.req_maps.req_loan_map.insert(\n+                    scope_id, @dvec::from_vec(~[mut loans]));\n+            }\n         }\n     }\n "}, {"sha": "b1396472d86f259ee353c8811295b047b23967cb", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -419,7 +419,7 @@ fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n \n fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool,\n                  why: Option<(&str,&str)>) {\n-    if ty::expr_is_lval(cx.method_map, ex) &&\n+    if ty::expr_is_lval(cx.tcx, cx.method_map, ex) &&\n \n         // this is a move\n         !cx.last_use_map.contains_key(ex.id) &&"}, {"sha": "f3459aa8cb3d6afe254d0206d2715f7625cda05f", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -1572,17 +1572,16 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n \n       expr_call(f, args, _) => {\n         let targs = ty::ty_fn_args(ty::expr_ty(self.tcx, f));\n-        vt.visit_expr(f, self, vt);\n         do vec::iter2(args, targs) |arg_expr, arg_ty| {\n             match ty::resolved_mode(self.tcx, arg_ty.mode) {\n-              by_val | by_copy | by_ref | by_mutbl_ref => {\n-                vt.visit_expr(arg_expr, self, vt);\n-              }\n-              by_move => {\n-                self.check_move_from_expr(arg_expr, vt);\n-              }\n+                by_val | by_copy | by_ref | by_mutbl_ref => {}\n+                by_move => {\n+                    self.check_move_from_expr(arg_expr, vt);\n+                }\n             }\n         }\n+\n+        visit::visit_expr(expr, self, vt);\n       }\n \n       // no correctness conditions related to liveness\n@@ -1670,6 +1669,9 @@ impl @Liveness {\n     }\n \n     fn consider_last_use(expr: @expr, ln: LiveNode, var: Variable) {\n+        debug!(\"consider_last_use(expr.id=%?, ln=%s, var=%s)\",\n+               expr.id, ln.to_str(), var.to_str());\n+\n         match self.live_on_exit(ln, var) {\n           Some(_) => {}\n           None => (*self.ir).add_last_use(expr.id, var)\n@@ -1682,7 +1684,7 @@ impl @Liveness {\n \n         if self.ir.method_map.contains_key(expr.id) {\n             // actually an rvalue, since this calls a method\n-            return vt.visit_expr(expr, self, vt);\n+            return;\n         }\n \n         match expr.node {\n@@ -1703,18 +1705,16 @@ impl @Liveness {\n             self.check_move_from_expr(base, vt);\n           }\n \n-          expr_index(base, idx) => {\n+          expr_index(base, _) => {\n             // Moving from x[y] is allowed if x is never used later.\n             // (Note that the borrowck guarantees that anything\n             //  being moved from is uniquely tied to the stack frame)\n             self.check_move_from_expr(base, vt);\n-            vt.visit_expr(idx, self, vt);\n           }\n \n           _ => {\n             // For other kinds of lvalues, no checks are required,\n             // and any embedded expressions are actually rvalues\n-            vt.visit_expr(expr, self, vt);\n           }\n        }\n     }"}, {"sha": "579c096e6349dd8058ada14b50025b3d305b95d7", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -254,6 +254,10 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n     let mut new_cx = cx;\n     match expr.node {\n+      // Calls or overloadable operators\n+      // FIXME #3387\n+      // ast::expr_index(*) | ast::expr_binary(*) |\n+      // ast::expr_unary(*) |\n       ast::expr_call(*) => {\n         debug!(\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n                                                            cx.sess.intr()));"}, {"sha": "643e385cd17b0b24ddab5c2d0d1cd4445841ff4c", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 190, "deletions": 258, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -14,8 +14,11 @@ use middle::resolve::DefMap;\n use back::abi;\n use std::map::hashmap;\n use dvec::DVec;\n-\n+use datum::*;\n use common::*;\n+use expr::Dest;\n+\n+fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n \n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n@@ -37,38 +40,25 @@ fn opt_eq(tcx: ty::ctxt, a: opt, b: opt) -> bool {\n }\n \n enum opt_result {\n-    single_result(result),\n-    range_result(result, result),\n+    single_result(Result),\n+    range_result(Result, Result),\n }\n fn trans_opt(bcx: block, o: opt) -> opt_result {\n     let _icx = bcx.insn_ctxt(\"alt::trans_opt\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     match o {\n-      lit(l) => {\n-        match l.node {\n-          ast::expr_vstore(@{node: ast::expr_lit(\n-              @{node: ast::lit_str(s), _}), _},\n-                           ast::vstore_uniq) => {\n-            let strty = ty::mk_estr(bcx.tcx(), ty::vstore_uniq);\n-            let cell = empty_dest_cell();\n-            bcx = tvec::trans_estr(bcx, s, Some(ast::vstore_uniq),\n-                                   by_val(cell));\n-            add_clean_temp_immediate(bcx, *cell, strty);\n-            return single_result(rslt(bcx, *cell));\n-          }\n-          _ => {\n-            return single_result(trans_temp_expr(bcx, l));\n-          }\n+        lit(lit_expr) => {\n+            let datumblock = expr::trans_to_datum(bcx, lit_expr);\n+            return single_result(datumblock.to_result());\n+        }\n+        var(disr_val, _) => {\n+            return single_result(rslt(bcx, C_int(ccx, disr_val)));\n+        }\n+        range(l1, l2) => {\n+            return range_result(rslt(bcx, consts::const_expr(ccx, l1)),\n+                                rslt(bcx, consts::const_expr(ccx, l2)));\n         }\n-      }\n-      var(disr_val, _) => {\n-        return single_result(rslt(bcx, C_int(ccx, disr_val)));\n-      }\n-      range(l1, l2) => {\n-        return range_result(rslt(bcx, consts::const_expr(ccx, l1)),\n-                         rslt(bcx, consts::const_expr(ccx, l2)));\n-      }\n     }\n }\n \n@@ -140,7 +130,7 @@ fn expand_nested_bindings(bcx: block, m: match_, col: uint, val: ValueRef)\n                                             ty: node_id_type(bcx,\n                                                              br.pats[col].id)\n                                          }}]),\n-                                .. *br});\n+                        ..*br});\n           }\n           _ => vec::push(result, br)\n         }\n@@ -173,7 +163,7 @@ fn enter_match(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef,\n               }\n               _ => br.bound\n             };\n-            vec::push(result, @{pats: pats, bound: bound,.. *br});\n+            vec::push(result, @{pats: pats, bound: bound, ..*br});\n           }\n           None => ()\n         }\n@@ -229,11 +219,10 @@ fn enter_rec_or_struct(bcx: block, dm: DefMap, m: match_, col: uint,\n           ast::pat_rec(fpats, _) | ast::pat_struct(_, fpats, _) => {\n             let mut pats = ~[];\n             for vec::each(fields) |fname| {\n-                let mut pat = dummy;\n-                for vec::each(fpats) |fpat| {\n-                    if fpat.ident == fname { pat = fpat.pat; break; }\n+                match fpats.find(|p| p.ident == fname) {\n+                    None => vec::push(pats, dummy),\n+                    Some(pat) => vec::push(pats, pat.pat)\n                 }\n-                vec::push(pats, pat);\n             }\n             Some(pats)\n           }\n@@ -327,56 +316,43 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     return {vals: args, bcx: bcx};\n }\n \n-fn collect_record_fields(m: match_, col: uint) -> ~[ast::ident] {\n+fn collect_record_or_struct_fields(m: match_, col: uint) -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n     for vec::each(m) |br| {\n         match br.pats[col].node {\n-          ast::pat_rec(fs, _) => {\n-            for vec::each(fs) |f| {\n-                if !vec::any(fields, |x| f.ident == x) {\n-                    vec::push(fields, f.ident);\n-                }\n-            }\n-          }\n+          ast::pat_rec(fs, _) => extend(&mut fields, fs),\n+          ast::pat_struct(_, fs, _) => extend(&mut fields, fs),\n           _ => ()\n         }\n     }\n     return fields;\n-}\n \n-fn collect_struct_fields(m: match_, col: uint) -> ~[ast::ident] {\n-    let mut fields: ~[ast::ident] = ~[];\n-    for vec::each(m) |br| {\n-        match br.pats[col].node {\n-          ast::pat_struct(_, fs, _) => {\n-            for vec::each(fs) |f| {\n-                if !vec::any(fields, |x| f.ident == x) {\n-                    vec::push(fields, f.ident);\n-                }\n+    fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n+        for field_pats.each |field_pat| {\n+            let field_ident = field_pat.ident;\n+            if !vec::any(*idents, |x| x == field_ident) {\n+                vec::push(*idents, field_ident);\n             }\n-          }\n-          _ => ()\n         }\n     }\n-    return fields;\n }\n \n fn root_pats_as_necessary(bcx: block, m: match_, col: uint, val: ValueRef) {\n     for vec::each(m) |br| {\n         let pat_id = br.pats[col].id;\n \n         match bcx.ccx().maps.root_map.find({id:pat_id, derefs:0u}) {\n-          None => (),\n-          Some(scope_id) => {\n-            // Note: the scope_id will always be the id of the alt.  See the\n-            // extended comment in rustc::middle::borrowck::preserve() for\n-            // details (look for the case covering cat_discr).\n-\n-            let ty = node_id_type(bcx, pat_id);\n-            let val = load_if_immediate(bcx, val, ty);\n-            root_value(bcx, val, ty, scope_id);\n-            return; // if we kept going, we'd only be rooting same value again\n-          }\n+            None => (),\n+            Some(scope_id) => {\n+                // Note: the scope_id will always be the id of the alt.  See\n+                // the extended comment in rustc::middle::borrowck::preserve()\n+                // for details (look for the case covering cat_discr).\n+\n+                let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n+                                   mode: ByRef, source: FromLvalue};\n+                datum.root(bcx, scope_id);\n+                return; // if we kept going, we'd only re-root the same value\n+            }\n         }\n     }\n }\n@@ -459,7 +435,10 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n     let _icx = bcx.insn_ctxt(\"alt::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx(), dm = tcx.def_map;\n-    if m.len() == 0u { Br(bcx, option::get(chk)()); return; }\n+    if m.len() == 0u {\n+        Br(bcx, option::get(chk)());\n+        return;\n+    }\n     if m[0].pats.len() == 0u {\n         let data = m[0].data;\n         match data.guard {\n@@ -471,27 +450,28 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n \n             for data.id_map.each |key, val| {\n                 let binding = assoc(key, m[0].bound).get();\n-                let (llval, mode) = (binding.val, binding.mode);\n-                let ty = binding.ty;\n+                let datum = Datum {val: binding.val, ty: binding.ty,\n+                                   mode: ByRef, source: FromLvalue};\n \n-                if mode == ast::bind_by_value {\n-                    let llty = type_of::type_of(bcx.fcx.ccx, ty);\n+                if binding.mode == ast::bind_by_value {\n+                    let llty = type_of::type_of(bcx.fcx.ccx, binding.ty);\n                     let alloc = alloca(bcx, llty);\n-                    bcx = copy_val(bcx, INIT, alloc,\n-                                   load_if_immediate(bcx, llval, ty), ty);\n+                    bcx = datum.copy_to(bcx, INIT, alloc);\n                     bcx.fcx.lllocals.insert(val, local_mem(alloc));\n-                    add_clean(bcx, alloc, ty);\n-                } else if mode == ast::bind_by_move {\n+                    add_clean(bcx, alloc, binding.ty);\n+                } else if binding.mode == ast::bind_by_move {\n                     fail ~\"can't translate bind_by_move into a pattern guard\";\n                 } else {\n-                    bcx.fcx.lllocals.insert(val, local_mem(llval));\n+                    bcx.fcx.lllocals.insert(val, local_mem(datum.val));\n                 }\n             };\n-            let {bcx: guard_cx, val} = {\n+\n+            let Result {bcx: guard_cx, val} = {\n                 do with_scope_result(bcx, e.info(), ~\"guard\") |bcx| {\n-                    trans_temp_expr(bcx, e)\n+                    expr::trans_to_appropriate_llval(bcx, e)\n                 }\n             };\n+\n             bcx = do with_cond(guard_cx, Not(guard_cx, val)) |bcx| {\n                 compile_submatch(bcx, vec::tail(m), vals, chk, exits);\n                 bcx\n@@ -525,58 +505,22 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n \n     root_pats_as_necessary(bcx, m, col, val);\n \n-    let rec_fields = collect_record_fields(m, col);\n-    // Separate path for extracting and binding record fields\n+    let rec_fields = collect_record_or_struct_fields(m, col);\n     if rec_fields.len() > 0 {\n-        let fields = ty::get_fields(node_id_type(bcx, pat_id));\n-        let mut rec_vals = ~[];\n-        for vec::each(rec_fields) |field_name| {\n-            let ix = option::get(ty::field_idx(field_name, fields));\n-            vec::push(rec_vals, GEPi(bcx, val, [0u, ix]));\n-        }\n-        compile_submatch(bcx,\n-                         enter_rec_or_struct(bcx, dm, m, col, rec_fields,\n-                                             val),\n-                         vec::append(rec_vals, vals_left),\n-                         chk,\n-                         exits);\n-        return;\n-    }\n-\n-    // Separate path for extracting and binding struct fields.\n-    let struct_fields = collect_struct_fields(m, col);\n-    if struct_fields.len() > 0 {\n-        let class_id, class_fields;\n-        match ty::get(node_id_type(bcx, pat_id)).struct {\n-            ty::ty_class(cid, _) => {\n-                class_id = cid;\n-                class_fields = ty::lookup_class_fields(ccx.tcx, class_id);\n-            }\n-            _ => {\n-                ccx.tcx.sess.bug(~\"struct pattern didn't resolve to a \\\n-                                   struct\");\n+        let pat_ty = node_id_type(bcx, pat_id);\n+        do expr::with_field_tys(tcx, pat_ty) |_has_dtor, field_tys| {\n+            let mut rec_vals = ~[];\n+            for vec::each(rec_fields) |field_name| {\n+                let ix = ty::field_idx_strict(tcx, field_name, field_tys);\n+                vec::push(rec_vals, GEPi(bcx, val, struct_field(ix)));\n             }\n+            compile_submatch(\n+                bcx,\n+                enter_rec_or_struct(bcx, dm, m, col, rec_fields, val),\n+                vec::append(rec_vals, vals_left),\n+                chk,\n+                exits);\n         }\n-\n-        // Index the class fields.\n-        let field_map = std::map::uint_hash();\n-        for class_fields.eachi |i, class_field| {\n-            field_map.insert(class_field.ident, i);\n-        }\n-\n-        // Fetch each field.\n-        let mut struct_vals = ~[];\n-        for struct_fields.each |field_name| {\n-            let index = field_map.get(field_name);\n-            let fldptr = base::get_struct_field(bcx, val, class_id, index);\n-            vec::push(struct_vals, fldptr);\n-        }\n-        compile_submatch(bcx,\n-                         enter_rec_or_struct(bcx, dm, m, col, struct_fields,\n-                                             val),\n-                         vec::append(struct_vals, vals_left),\n-                         chk,\n-                         exits);\n         return;\n     }\n \n@@ -641,8 +585,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n                    else { compare };\n           }\n           range(_, _) => {\n-            let pty = node_id_type(bcx, pat_id);\n-            test_val = load_if_immediate(bcx, val, pty);\n+            test_val = Load(bcx, val);\n             kind = compare;\n           }\n         }\n@@ -665,6 +608,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n     let exhaustive = option::is_none(chk) && defaults.len() == 0u;\n     let len = opts.len();\n     let mut i = 0u;\n+\n     // Compile subtrees for each option\n     for vec::each(opts) |opt| {\n         i += 1u;\n@@ -685,20 +629,25 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n               }\n               compare => {\n                 let t = node_id_type(bcx, pat_id);\n-                let {bcx: after_cx, val: matches} = {\n+                let Result {bcx: after_cx, val: matches} = {\n                     do with_scope_result(bcx, None, ~\"compare_scope\") |bcx| {\n                         match trans_opt(bcx, opt) {\n-                          single_result({bcx, val}) => {\n-                            trans_compare(bcx, ast::eq, test_val, t, val, t)\n-                          }\n-                          range_result(\n-                              {val: vbegin, _}, {bcx, val: vend}) => {\n-                            let {bcx, val: llge} = trans_compare(\n-                                bcx, ast::ge, test_val, t, vbegin, t);\n-                            let {bcx, val: llle} = trans_compare(\n-                                bcx, ast::le, test_val, t, vend, t);\n-                            {bcx: bcx, val: And(bcx, llge, llle)}\n-                          }\n+                            single_result(\n+                                Result {bcx, val}) =>\n+                            {\n+                                trans_compare(bcx, ast::eq, test_val,\n+                                              t, val, t)\n+                            }\n+                            range_result(\n+                                Result {val: vbegin, _},\n+                                Result {bcx, val: vend}) =>\n+                            {\n+                                let Result {bcx, val: llge} = trans_compare(\n+                                    bcx, ast::ge, test_val, t, vbegin, t);\n+                                let Result {bcx, val: llle} = trans_compare(\n+                                    bcx, ast::le, test_val, t, vend, t);\n+                                rslt(bcx, And(bcx, llge, llle))\n+                            }\n                         }\n                     }\n                 };\n@@ -805,19 +754,17 @@ fn make_pattern_bindings(bcx: block, phi_bindings: phi_bindings_list)\n             }\n             ast::bind_by_value | ast::bind_by_move => {\n                 // by value: make a new temporary and copy the value out\n-                let lltype = type_of::type_of(bcx.fcx.ccx, binding.ty);\n-                let allocation = alloca(bcx, lltype);\n-                let ty = binding.ty;\n-                bcx = if binding.mode == ast::bind_by_value {\n-                    copy_val(bcx, INIT, allocation,\n-                             load_if_immediate(bcx, phi_val, ty), ty)\n+                let phi_datum = Datum {val: phi_val, ty: binding.ty,\n+                                       mode: ByRef, source: FromLvalue};\n+                let scratch = scratch_datum(bcx, binding.ty, false);\n+                if binding.mode == ast::bind_by_value {\n+                    phi_datum.copy_to_datum(bcx, INIT, scratch);\n                 } else {\n-                    move_val(bcx, INIT, allocation,\n-                             {bcx: bcx, val: phi_val, kind: lv_owned}, ty)\n-                };\n+                    phi_datum.move_to_datum(bcx, INIT, scratch);\n+                }\n                 bcx.fcx.lllocals.insert(binding.pat_id,\n-                                        local_mem(allocation));\n-                add_clean(bcx, allocation, ty);\n+                                        local_mem(scratch.val));\n+                add_clean(bcx, scratch.val, binding.ty);\n             }\n         }\n     }\n@@ -827,24 +774,31 @@ fn make_pattern_bindings(bcx: block, phi_bindings: phi_bindings_list)\n \n fn trans_alt(bcx: block,\n              alt_expr: @ast::expr,\n-             expr: @ast::expr,\n+             discr_expr: @ast::expr,\n              arms: ~[ast::arm],\n-             dest: dest) -> block {\n+             dest: Dest) -> block {\n     let _icx = bcx.insn_ctxt(\"alt::trans_alt\");\n     do with_scope(bcx, alt_expr.info(), ~\"alt\") |bcx| {\n-        trans_alt_inner(bcx, expr, arms, dest)\n+        trans_alt_inner(bcx, discr_expr, arms, dest)\n     }\n }\n \n-fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n-                   dest: dest) -> block {\n+fn trans_alt_inner(scope_cx: block,\n+                   discr_expr: @ast::expr,\n+                   arms: ~[ast::arm],\n+                   dest: Dest) -> block {\n     let _icx = scope_cx.insn_ctxt(\"alt::trans_alt_inner\");\n-    let bcx = scope_cx, tcx = bcx.tcx();\n-    let mut bodies = ~[], matches = ~[];\n+    let mut bcx = scope_cx;\n+    let tcx = bcx.tcx();\n \n-    let {bcx, val, _} = trans_temp_expr(bcx, expr);\n-    if bcx.unreachable { return bcx; }\n+    let discr_datum = unpack_datum!(bcx, {\n+        expr::trans_to_datum(bcx, discr_expr)\n+    });\n+    if bcx.unreachable {\n+        return bcx;\n+    }\n \n+    let mut bodies = ~[], matches = ~[];\n     for vec::each(arms) |a| {\n         let body = scope_block(bcx, a.body.info(), ~\"case_body\");\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n@@ -857,48 +811,48 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n         }\n     }\n \n-    fn mk_fail(bcx: block, sp: span, msg: ~str,\n-                   done: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n-            match *done { Some(bb) => return bb, _ => () }\n-            let fail_cx = sub_block(bcx, ~\"case_fallthrough\");\n-            trans_fail(fail_cx, Some(sp), msg);\n-            *done = Some(fail_cx.llbb);\n-            return fail_cx.llbb;\n-    }\n-    let t = node_id_type(bcx, expr.id);\n-    let mk_fail = { let fail_cx = @mut None;\n-          // special case for uninhabited type\n-          if ty::type_is_empty(tcx, t) {\n-                  Some(|| mk_fail(scope_cx, expr.span,\n+    let t = node_id_type(bcx, discr_expr.id);\n+    let chk = {\n+        if ty::type_is_empty(tcx, t) {\n+            // Special case for empty types\n+            let fail_cx = @mut None;\n+            Some(|| mk_fail(scope_cx, discr_expr.span,\n                             ~\"scrutinizing value that can't exist\", fail_cx))\n-          }\n-          else {\n-              None\n-          }\n+        } else {\n+            None\n+        }\n     };\n     let mut exit_map = ~[];\n-    let spilled = spill_if_immediate(bcx, val, t);\n-    compile_submatch(bcx, matches, ~[spilled], mk_fail, exit_map);\n+    let lldiscr = discr_datum.to_ref_llval(bcx);\n+    compile_submatch(bcx, matches, ~[lldiscr], chk, exit_map);\n \n-    let mut arm_cxs = ~[], arm_dests = ~[], i = 0u;\n+    let mut arm_cxs = ~[], i = 0u;\n     for vec::each(arms) |a| {\n         let body_cx = bodies[i];\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         match make_phi_bindings(body_cx, exit_map, id_map) {\n             None => {}\n             Some(phi_bindings) => {\n                 let body_cx = make_pattern_bindings(body_cx, phi_bindings);\n-                let arm_dest = dup_for_join(dest);\n-                vec::push(arm_dests, arm_dest);\n-                let mut arm_cx = trans_block(body_cx, a.body, arm_dest);\n+                let mut arm_cx =\n+                    controlflow::trans_block(body_cx, a.body, dest);\n                 arm_cx = trans_block_cleanups(arm_cx,\n                                               block_cleanups(body_cx));\n                 vec::push(arm_cxs, arm_cx);\n             }\n         }\n         i += 1u;\n     }\n-    join_returns(scope_cx, arm_cxs, arm_dests, dest)\n+    return controlflow::join_blocks(scope_cx, arm_cxs);\n+\n+    fn mk_fail(bcx: block, sp: span, msg: ~str,\n+               done: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n+        match *done { Some(bb) => return bb, _ => () }\n+        let fail_cx = sub_block(bcx, ~\"case_fallthrough\");\n+        controlflow::trans_fail(fail_cx, Some(sp), msg);\n+        *done = Some(fail_cx.llbb);\n+        return fail_cx.llbb;\n+    }\n }\n \n // Not alt-related, but similar to the pattern-munging code above\n@@ -910,88 +864,66 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n \n     // Necessary since bind_irrefutable_pat is called outside trans_alt\n     match pat.node {\n-      ast::pat_ident(_, _,inner) => {\n-        if pat_is_variant(bcx.tcx().def_map, pat) { return bcx; }\n-        if make_copy {\n-            let ty = node_id_type(bcx, pat.id);\n-            let llty = type_of::type_of(ccx, ty);\n-            let alloc = alloca(bcx, llty);\n-            bcx = copy_val(bcx, INIT, alloc,\n-                                  load_if_immediate(bcx, val, ty), ty);\n-            bcx.fcx.lllocals.insert(pat.id, local_mem(alloc));\n-            add_clean(bcx, alloc, ty);\n-        } else { bcx.fcx.lllocals.insert(pat.id, local_mem(val)); }\n-        match inner {\n-          Some(pat) => { bcx = bind_irrefutable_pat(bcx, pat, val, true); }\n-          _ => ()\n-        }\n-      }\n-      ast::pat_enum(_, sub) => {\n-        let vdefs = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n-        let args = extract_variant_args(bcx, pat.id, vdefs, val);\n-        let mut i = 0;\n-        do option::iter(sub) |sub| { for vec::each(args.vals) |argval| {\n-            bcx = bind_irrefutable_pat(bcx, sub[i], argval, make_copy);\n-            i += 1;\n-        }}\n-      }\n-      ast::pat_rec(fields, _) => {\n-        let rec_fields = ty::get_fields(node_id_type(bcx, pat.id));\n-        for vec::each(fields) |f| {\n-            let ix = option::get(ty::field_idx(f.ident, rec_fields));\n-            let fldptr = GEPi(bcx, val, [0u, ix]);\n-            bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, make_copy);\n-        }\n+        ast::pat_ident(_, _,inner) => {\n+            if pat_is_variant(bcx.tcx().def_map, pat) {\n+                return bcx;\n+            }\n+\n+            if make_copy {\n+                let binding_ty = node_id_type(bcx, pat.id);\n+                let datum = Datum {val: val, ty: binding_ty,\n+                                   mode: ByRef, source: FromRvalue};\n+                let scratch = scratch_datum(bcx, binding_ty, false);\n+                datum.copy_to_datum(bcx, INIT, scratch);\n+                bcx.fcx.lllocals.insert(pat.id, local_mem(scratch.val));\n+                add_clean(bcx, scratch.val, binding_ty);\n+            } else {\n+                bcx.fcx.lllocals.insert(pat.id, local_mem(val));\n+            }\n+\n+            for inner.each |inner_pat| {\n+                bcx = bind_irrefutable_pat(bcx, inner_pat, val, true);\n+            }\n       }\n-      ast::pat_struct(_, fields, _) => {\n-        // Grab the class data that we care about.\n-        let class_fields, class_id;\n-        match ty::get(node_id_type(bcx, pat.id)).struct {\n-            ty::ty_class(cid, _) => {\n-                class_id = cid;\n-                class_fields = ty::lookup_class_fields(ccx.tcx, class_id);\n+        ast::pat_enum(_, sub_pats) => {\n+            let pat_def = ccx.tcx.def_map.get(pat.id);\n+            let vdefs = ast_util::variant_def_ids(pat_def);\n+            let args = extract_variant_args(bcx, pat.id, vdefs, val);\n+            for sub_pats.each |sub_pat| {\n+                for vec::eachi(args.vals) |i, argval| {\n+                    bcx = bind_irrefutable_pat(bcx, sub_pat[i],\n+                                               argval, make_copy);\n+                }\n             }\n-            _ => {\n-                ccx.tcx.sess.span_bug(pat.span, ~\"struct pattern didn't \\\n-                                                  resolve to a struct\");\n+        }\n+        ast::pat_rec(fields, _) | ast::pat_struct(_, fields, _) => {\n+            let tcx = bcx.tcx();\n+            let pat_ty = node_id_type(bcx, pat.id);\n+            do expr::with_field_tys(tcx, pat_ty) |_has_dtor, field_tys| {\n+                for vec::each(fields) |f| {\n+                    let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n+                    let fldptr = GEPi(bcx, val, struct_field(ix));\n+                    bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, make_copy);\n+                }\n             }\n         }\n-\n-        // Index the class fields.\n-        let field_map = std::map::uint_hash();\n-        for class_fields.eachi |i, class_field| {\n-            field_map.insert(class_field.ident, i);\n+        ast::pat_tup(elems) => {\n+            for vec::eachi(elems) |i, elem| {\n+                let fldptr = GEPi(bcx, val, [0u, i]);\n+                bcx = bind_irrefutable_pat(bcx, elem, fldptr, make_copy);\n+            }\n         }\n-\n-        // Fetch each field.\n-        for fields.each |supplied_field| {\n-            let index = field_map.get(supplied_field.ident);\n-            let fldptr = base::get_struct_field(bcx, val, class_id, index);\n-            bcx = bind_irrefutable_pat(bcx, supplied_field.pat, fldptr,\n-                                       make_copy);\n+        ast::pat_box(inner) => {\n+            let llbox = Load(bcx, val);\n+            let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+            bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n         }\n-      }\n-      ast::pat_tup(elems) => {\n-        let mut i = 0u;\n-        for vec::each(elems) |elem| {\n-            let fldptr = GEPi(bcx, val, [0u, i]);\n-            bcx = bind_irrefutable_pat(bcx, elem, fldptr, make_copy);\n-            i += 1u;\n+        ast::pat_uniq(inner) => {\n+            let llbox = Load(bcx, val);\n+            let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+            bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n         }\n-      }\n-      ast::pat_box(inner) => {\n-        let llbox = Load(bcx, val);\n-        let unboxed =\n-            GEPi(bcx, llbox, [0u, abi::box_field_body]);\n-        bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n-      }\n-      ast::pat_uniq(inner) => {\n-        let llbox = Load(bcx, val);\n-        let unboxed =\n-            GEPi(bcx, llbox, [0u, abi::box_field_body]);\n-        bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n-      }\n-      ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) => ()\n+        ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) => ()\n     }\n     return bcx;\n }"}, {"sha": "b74d89dc46594bf3b1ffcf01cd3e3261b77e494d", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 350, "deletions": 3744, "changes": 4094, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/rustc/middle/trans/block.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fblock.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8"}, {"sha": "21ced9f58139393b2a05c83cedb54a8cc71165ea", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -6,8 +6,8 @@ use codemap::span;\n use lib::llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, ModuleRef};\n use lib::llvm::{Opcode, IntPredicate, RealPredicate, True, False,\n         CallConv, TypeKind, AtomicBinOp, AtomicOrdering};\n-use common::*;\n use driver::session::session;\n+use common::*;\n \n fn B(cx: block) -> BuilderRef {\n     let b = cx.fcx.ccx.builder.B;\n@@ -670,7 +670,7 @@ fn add_comment(bcx: block, text: ~str) {\n     }\n }\n \n-fn Call(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n+fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, \"call\");\n@@ -679,8 +679,9 @@ fn Call(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n                val_str(cx.ccx().tn, Fn),\n                Args.map(|arg| val_str(cx.ccx().tn, arg)));\n \n-        return llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n-                                Args.len() as c_uint, noname());\n+        do vec::as_buf(Args) |ptr, len| {\n+            llvm::LLVMBuildCall(B(cx), Fn, ptr, len as c_uint, noname())\n+        }\n     }\n }\n "}, {"sha": "db6e9832ffdb965a185e95af5a43625523fd8dbc", "filename": "src/rustc/middle/trans/callee.rs", "status": "added", "additions": 665, "deletions": 0, "changes": 665, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,665 @@\n+//!\n+//\n+// Handles translation of callees as well as other call-related\n+// things.  Callees are a superset of normal rust values and sometimes\n+// have different representations.  In particular, top-level fn items\n+// and methods are represented as just a fn ptr and not a full\n+// closure.\n+\n+use lib::llvm::ValueRef;\n+use syntax::ast;\n+use datum::Datum;\n+use common::{block, node_id_type_params};\n+use build::*;\n+use base::{get_item_val, trans_external_path};\n+use syntax::visit;\n+use syntax::print::pprust::{expr_to_str, stmt_to_str, path_to_str};\n+use datum::*;\n+use util::common::indenter;\n+\n+// Represents a (possibly monomorphized) top-level fn item or method\n+// item.  Note that this is just the fn-ptr and is not a Rust closure\n+// value (which is a pair).\n+struct FnData {\n+    llfn: ValueRef;\n+}\n+\n+struct MethodData {\n+    llfn: ValueRef;\n+    llself: ValueRef;\n+    self_ty: ty::t;\n+    self_mode: ast::rmode;\n+}\n+\n+enum CalleeData {\n+    Closure(Datum),\n+    Fn(FnData),\n+    Method(MethodData)\n+}\n+\n+struct Callee {\n+    bcx: block;\n+    data: CalleeData;\n+}\n+\n+fn trans(bcx: block, expr: @ast::expr) -> Callee {\n+    let _icx = bcx.insn_ctxt(\"trans_callee\");\n+\n+    // pick out special kinds of expressions that can be called:\n+    match expr.node {\n+        ast::expr_path(_) => {\n+            return trans_def(bcx, bcx.def(expr.id), expr);\n+        }\n+        ast::expr_field(base, _, _) => {\n+            match bcx.ccx().maps.method_map.find(expr.id) {\n+                Some(origin) => { // An impl method\n+                    return impl::trans_method_callee(bcx, expr.id,\n+                                                     base, origin);\n+                }\n+                None => {} // not a method, just a field\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    // any other expressions are closures:\n+    return closure_callee(&expr::trans_to_datum(bcx, expr));\n+\n+    fn closure_callee(db: &DatumBlock) -> Callee {\n+        return Callee {bcx: db.bcx, data: Closure(db.datum)};\n+    }\n+\n+    fn fn_callee(bcx: block, fd: FnData) -> Callee {\n+        return Callee {bcx: bcx, data: Fn(fd)};\n+    }\n+\n+    fn trans_def(bcx: block, def: ast::def, ref_expr: @ast::expr) -> Callee {\n+        match def {\n+            ast::def_fn(did, _) => {\n+                fn_callee(bcx, trans_fn_ref(bcx, did, ref_expr.id))\n+            }\n+            ast::def_static_method(did, _) => {\n+                fn_callee(bcx, impl::trans_static_method_callee(bcx, did,\n+                                                                ref_expr.id))\n+            }\n+            ast::def_variant(tid, vid) => {\n+                // nullary variants are not callable\n+                assert ty::enum_variant_with_id(bcx.tcx(),\n+                                                tid,\n+                                                vid).args.len() > 0u;\n+                fn_callee(bcx, trans_fn_ref(bcx, vid, ref_expr.id))\n+            }\n+            ast::def_arg(*) |\n+            ast::def_local(*) |\n+            ast::def_binding(*) |\n+            ast::def_upvar(*) |\n+            ast::def_self(*) => {\n+                closure_callee(&expr::trans_to_datum(bcx, ref_expr))\n+            }\n+            ast::def_mod(*) | ast::def_foreign_mod(*) |\n+            ast::def_const(*) | ast::def_ty(*) | ast::def_prim_ty(*) |\n+            ast::def_use(*) | ast::def_class(*) | ast::def_typaram_binder(*) |\n+            ast::def_region(*) | ast::def_label(*) | ast::def_ty_param(*) => {\n+                bcx.tcx().sess.span_bug(\n+                    ref_expr.span,\n+                    fmt!(\"Cannot translate def %? \\\n+                          to a callable thing!\", def));\n+            }\n+        }\n+    }\n+}\n+\n+fn trans_fn_ref_to_callee(bcx: block,\n+                          def_id: ast::def_id,\n+                          ref_id: ast::node_id) -> Callee\n+{\n+    Callee {bcx: bcx,\n+            data: Fn(trans_fn_ref(bcx, def_id, ref_id))}\n+}\n+\n+fn trans_fn_ref(bcx: block,\n+                def_id: ast::def_id,\n+                ref_id: ast::node_id) -> FnData {\n+    //!\n+    //\n+    // Translates a reference (with id `ref_id`) to the fn/method\n+    // with id `def_id` into a function pointer.  This may require\n+    // monomorphization or inlining.\n+\n+    let _icx = bcx.insn_ctxt(\"trans_fn\");\n+\n+    let type_params = node_id_type_params(bcx, ref_id);\n+\n+    let raw_vtables = bcx.ccx().maps.vtable_map.find(ref_id);\n+    let resolved_vtables = raw_vtables.map(\n+        |vts| impl::resolve_vtables_in_fn_ctxt(bcx.fcx, vts));\n+    trans_fn_ref_with_vtables(bcx, def_id, ref_id, type_params,\n+                              resolved_vtables)\n+}\n+\n+fn trans_fn_ref_with_vtables_to_callee(bcx: block,\n+                                       def_id: ast::def_id,\n+                                       ref_id: ast::node_id,\n+                                       type_params: ~[ty::t],\n+                                       vtables: Option<typeck::vtable_res>)\n+    -> Callee\n+{\n+    Callee {bcx: bcx,\n+            data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ref_id,\n+                                               type_params, vtables))}\n+}\n+\n+fn trans_fn_ref_with_vtables(\n+    bcx: block,            //\n+    def_id: ast::def_id,   // def id of fn\n+    ref_id: ast::node_id,  // node id of use of fn\n+    type_params: ~[ty::t], // values for fn's ty params\n+    vtables: Option<typeck::vtable_res>)\n+    -> FnData\n+{\n+    //!\n+    //\n+    // Translates a reference to a fn/method item, monomorphizing and\n+    // inlining as it goes.\n+    //\n+    // # Parameters\n+    //\n+    // - `bcx`: the current block where the reference to the fn occurs\n+    // - `def_id`: def id of the fn or method item being referenced\n+    // - `ref_id`: node id of the reference to the fn/method\n+    // - `type_params`: values for each of the fn/method's type parameters\n+    // - `vtables`: values for each bound on each of the type parameters\n+\n+    let _icx = bcx.insn_ctxt(\"trans_fn_with_vtables\");\n+    let ccx = bcx.ccx();\n+    let tcx = ccx.tcx;\n+\n+    // Polytype of the function item (may have type params)\n+    let fn_tpt = ty::lookup_item_type(tcx, def_id);\n+\n+    // Check whether this fn has an inlined copy and, if so, redirect\n+    // def_id to the local id of the inlined copy.\n+    let def_id = {\n+        if def_id.crate != ast::local_crate {\n+            inline::maybe_instantiate_inline(ccx, def_id)\n+        } else {\n+            def_id\n+        }\n+    };\n+\n+    // We must monomorphise if the fn has type parameters or is a rust\n+    // intrinsic.  In particular, if we see an intrinsic that is\n+    // inlined from a different crate, we want to reemit the intrinsic\n+    // instead of trying to call it in the other crate.\n+    let must_monomorphise = type_params.len() > 0 || {\n+        if def_id.crate == ast::local_crate {\n+            let map_node = session::expect(\n+                ccx.sess,\n+                ccx.tcx.items.find(def_id.node),\n+                || fmt!(\"local item should be in ast map\"));\n+\n+            match map_node {\n+              ast_map::node_foreign_item(\n+                  _, ast::foreign_abi_rust_intrinsic, _) => true,\n+              _ => false\n+            }\n+        } else {\n+            false\n+        }\n+    };\n+\n+    // Create a monomorphic verison of generic functions\n+    if must_monomorphise {\n+        // Should be either intra-crate or inlined.\n+        assert def_id.crate == ast::local_crate;\n+\n+        let mut {val, must_cast} =\n+            monomorphize::monomorphic_fn(ccx, def_id, type_params,\n+                                         vtables, Some(ref_id));\n+        if must_cast {\n+            // Monotype of the REFERENCE to the function (type params\n+            // are subst'd)\n+            let ref_ty = common::node_id_type(bcx, ref_id);\n+\n+            val = PointerCast(\n+                bcx, val, T_ptr(type_of::type_of_fn_from_ty(ccx, ref_ty)));\n+        }\n+        return FnData {llfn: val};\n+    }\n+\n+    // Find the actual function pointer.\n+    let mut val = {\n+        if def_id.crate == ast::local_crate {\n+            // Internal reference.\n+            get_item_val(ccx, def_id.node)\n+        } else {\n+            // External reference.\n+            trans_external_path(ccx, def_id, fn_tpt.ty)\n+        }\n+    };\n+\n+    //NDM I think this is dead. Commenting out to be sure!\n+    //NDM\n+    //NDM if tys.len() > 0u {\n+    //NDM     val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n+    //NDM         ccx, node_id_type(bcx, id))));\n+    //NDM }\n+\n+    return FnData {llfn: val};\n+}\n+\n+// ______________________________________________________________________\n+// Translating calls\n+\n+fn trans_call(in_cx: block,\n+              call_ex: @ast::expr,\n+              f: @ast::expr,\n+              args: CallArgs,\n+              id: ast::node_id,\n+              dest: expr::Dest)\n+    -> block\n+{\n+    let _icx = in_cx.insn_ctxt(\"trans_call\");\n+    trans_call_inner(\n+        in_cx, call_ex.info(), expr_ty(in_cx, f), node_id_type(in_cx, id),\n+        |cx| trans(cx, f), args, dest)\n+}\n+\n+fn trans_rtcall(bcx: block, name: ~str, args: ~[ValueRef], dest: expr::Dest)\n+    -> block\n+{\n+    let did = bcx.ccx().rtcalls[name];\n+    let fty = if did.crate == ast::local_crate {\n+        ty::node_id_to_type(bcx.ccx().tcx, did.node)\n+    } else {\n+        csearch::get_type(bcx.ccx().tcx, did).ty\n+    };\n+    let rty = ty::ty_fn_ret(fty);\n+    return callee::trans_call_inner(\n+        bcx, None, fty, rty,\n+        |bcx| trans_fn_ref_with_vtables_to_callee(bcx, did, 0, ~[], None),\n+        ArgVals(args), dest);\n+}\n+\n+fn body_contains_ret(body: ast::blk) -> bool {\n+    let cx = {mut found: false};\n+    visit::visit_block(body, cx, visit::mk_vt(@{\n+        visit_item: |_i, _cx, _v| { },\n+        visit_expr: |e: @ast::expr, cx: {mut found: bool}, v| {\n+            if !cx.found {\n+                match e.node {\n+                  ast::expr_ret(_) => cx.found = true,\n+                  _ => visit::visit_expr(e, cx, v),\n+                }\n+            }\n+        },\n+        ..*visit::default_visitor()\n+    }));\n+    cx.found\n+}\n+\n+// See [Note-arg-mode]\n+fn trans_call_inner(\n+    ++in_cx: block,\n+    call_info: Option<node_info>,\n+    fn_expr_ty: ty::t,\n+    ret_ty: ty::t,\n+    get_callee: fn(block) -> Callee,\n+    args: CallArgs,\n+    dest: expr::Dest) -> block\n+{\n+    do base::with_scope(in_cx, call_info, ~\"call\") |cx| {\n+        let ret_in_loop = match args {\n+          ArgExprs(args) => {\n+            args.len() > 0u && match vec::last(args).node {\n+              ast::expr_loop_body(@{\n+                node: ast::expr_fn_block(_, body, _),\n+                _\n+              }) =>  body_contains_ret(body),\n+              _ => false\n+            }\n+          }\n+          _ => false\n+        };\n+\n+        let callee = get_callee(cx);\n+        let mut bcx = callee.bcx;\n+        let ccx = cx.ccx();\n+        let ret_flag = if ret_in_loop {\n+            let flag = alloca(bcx, T_bool());\n+            Store(bcx, C_bool(false), flag);\n+            Some(flag)\n+        } else { None };\n+\n+        let (llfn, llenv) = match callee.data {\n+            Fn(d) => {\n+                (d.llfn, llvm::LLVMGetUndef(T_opaque_box_ptr(ccx)))\n+            }\n+            Method(d) => {\n+                // Weird but true: we pass self in the *environment* slot!\n+                let llself = PointerCast(bcx, d.llself,\n+                                         T_opaque_box_ptr(ccx));\n+                (d.llfn, llself)\n+            }\n+            Closure(d) => {\n+                // Closures are represented as (llfn, llclosure) pair:\n+                // load the requisite values out.\n+                let pair = d.to_ref_llval(bcx);\n+                let llfn = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n+                let llfn = Load(bcx, llfn);\n+                let llenv = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n+                let llenv = Load(bcx, llenv);\n+                (llfn, llenv)\n+            }\n+        };\n+\n+        let args_res = trans_args(bcx, llenv, args, fn_expr_ty,\n+                                  dest, ret_flag);\n+        bcx = args_res.bcx;\n+        let mut llargs = args_res.args;\n+\n+        let llretslot = args_res.retslot;\n+\n+        // Now that the arguments have finished evaluating, we need to revoke\n+        // the cleanup for the self argument, if it exists\n+        match callee.data {\n+            Method(d) if d.self_mode == ast::by_copy => {\n+                revoke_clean(bcx, d.llself);\n+            }\n+            _ => {}\n+        }\n+\n+        // If the block is terminated, then one or more of the args\n+        // has type _|_. Since that means it diverges, the code for\n+        // the call itself is unreachable.\n+        bcx = base::invoke(bcx, llfn, llargs);\n+        match dest { // drop the value if it is not being saved.\n+            expr::Ignore => {\n+                if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n+                    bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n+                }\n+            }\n+            expr::SaveIn(_) => { }\n+        }\n+        if ty::type_is_bot(ret_ty) {\n+            Unreachable(bcx);\n+        } else if ret_in_loop {\n+            bcx = do with_cond(bcx, Load(bcx, option::get(ret_flag))) |bcx| {\n+                do option::iter(copy bcx.fcx.loop_ret) |lret| {\n+                    Store(bcx, C_bool(true), lret.flagptr);\n+                    Store(bcx, C_bool(false), bcx.fcx.llretptr);\n+                }\n+                base::cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n+                Unreachable(bcx);\n+                bcx\n+            }\n+        }\n+        bcx\n+    }\n+}\n+\n+\n+enum CallArgs {\n+    ArgExprs(~[@ast::expr]),\n+    ArgVals(~[ValueRef])\n+}\n+\n+fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n+              dest: expr::Dest, ret_flag: Option<ValueRef>)\n+    -> {bcx: block, args: ~[ValueRef], retslot: ValueRef}\n+{\n+    let _icx = cx.insn_ctxt(\"trans_args\");\n+    let mut temp_cleanups = ~[];\n+    let arg_tys = ty::ty_fn_args(fn_ty);\n+    let mut llargs: ~[ValueRef] = ~[];\n+\n+    let mut bcx = cx;\n+\n+    let retty = ty::ty_fn_ret(fn_ty);\n+\n+    // Arg 0: Output pointer.\n+    let llretslot = match dest {\n+        expr::SaveIn(dst) => dst,\n+        expr::Ignore => {\n+            if ty::type_is_nil(retty) {\n+                llvm::LLVMGetUndef(T_ptr(T_nil()))\n+            } else {\n+                alloc_ty(bcx, retty)\n+            }\n+        }\n+    };\n+    vec::push(llargs, llretslot);\n+\n+    // Arg 1: Env (closure-bindings / self value)\n+    vec::push(llargs, llenv);\n+\n+    // ... then explicit args.\n+\n+    // First we figure out the caller's view of the types of the arguments.\n+    // This will be needed if this is a generic call, because the callee has\n+    // to cast her view of the arguments to the caller's view.\n+    match args {\n+      ArgExprs(arg_exprs) => {\n+        let last = arg_exprs.len() - 1u;\n+        do vec::iteri(arg_exprs) |i, arg_expr| {\n+            let arg_val = unpack_result!(bcx, {\n+                trans_arg_expr(bcx, arg_tys[i], arg_expr, &mut temp_cleanups,\n+                               if i == last { ret_flag } else { None },\n+                               0u)\n+            });\n+            vec::push(llargs, arg_val);\n+        }\n+      }\n+      ArgVals(vs) => {\n+        vec::push_all(llargs, vs);\n+      }\n+    }\n+\n+    // now that all arguments have been successfully built, we can revoke any\n+    // temporary cleanups, as they are only needed if argument construction\n+    // should fail (for example, cleanup of copy mode args).\n+    do vec::iter(temp_cleanups) |c| {\n+        revoke_clean(bcx, c)\n+    }\n+\n+    return {bcx: bcx, args: llargs, retslot: llretslot};\n+}\n+\n+// temp_cleanups: cleanups that should run only if failure occurs before the\n+// call takes place:\n+fn trans_arg_expr(bcx: block,\n+                  formal_ty: ty::arg,\n+                  arg_expr: @ast::expr,\n+                  temp_cleanups: &mut ~[ValueRef],\n+                  ret_flag: Option<ValueRef>,\n+                  derefs: uint)\n+    -> Result\n+{\n+    let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n+    let ccx = bcx.ccx();\n+\n+    debug!(\"trans_arg_expr(formal_ty=(%?,%s), arg_expr=%s, \\\n+            ret_flag=%?, derefs=%?)\",\n+           formal_ty.mode, bcx.ty_to_str(formal_ty.ty),\n+           bcx.expr_to_str(arg_expr),\n+           ret_flag.map(|v| bcx.val_str(v)), derefs);\n+    let _indenter = indenter();\n+\n+    // translate the arg expr to a datum\n+    let arg_datumblock = match ret_flag {\n+        None => expr::trans_to_datum(bcx, arg_expr),\n+\n+        // If there is a ret_flag, this *must* be a loop body\n+        Some(_) => {\n+            match arg_expr.node {\n+                ast::expr_loop_body(\n+                    blk @ @{node:ast::expr_fn_block(decl, body, cap), _}) =>\n+                {\n+                    let scratch_ty = expr_ty(bcx, blk);\n+                    let scratch = alloc_ty(bcx, scratch_ty);\n+                    let arg_ty = expr_ty(bcx, arg_expr);\n+                    let proto = ty::ty_fn_proto(arg_ty);\n+                    let bcx = closure::trans_expr_fn(\n+                        bcx, proto, decl, body, blk.id,\n+                        cap, Some(ret_flag), expr::SaveIn(scratch));\n+                    DatumBlock {bcx: bcx,\n+                                datum: Datum {val: scratch,\n+                                              ty: scratch_ty,\n+                                              mode: ByRef,\n+                                              source: FromRvalue}}\n+                }\n+                _ => {\n+                    bcx.sess().impossible_case(\n+                        arg_expr.span, ~\"ret_flag with non-loop-\\\n+                                         body expr\");\n+                }\n+            }\n+        }\n+    };\n+    let mut arg_datum = arg_datumblock.datum;\n+    let mut bcx = arg_datumblock.bcx;\n+\n+    debug!(\"   initial value: %s\", arg_datum.to_str(bcx.ccx()));\n+\n+    // auto-deref value as required (this only applies to method\n+    // call receivers) of method\n+    if derefs != 0 {\n+        arg_datum = arg_datum.autoderef(bcx, arg_expr.id, derefs);\n+        debug!(\"   deref'd value: %s\", arg_datum.to_str(bcx.ccx()));\n+    };\n+\n+    // borrow value (convert from @T to &T and so forth)\n+    let arg_datum = unpack_datum!(bcx, {\n+        adapt_borrowed_value(bcx, arg_datum, arg_expr)\n+    });\n+    debug!(\"   borrowed value: %s\", arg_datum.to_str(bcx.ccx()));\n+\n+    // finally, deal with the various modes\n+    let arg_mode = ty::resolved_mode(ccx.tcx, formal_ty.mode);\n+    let mut val;\n+    if ty::type_is_bot(arg_datum.ty) {\n+        // For values of type _|_, we generate an\n+        // \"undef\" value, as such a value should never\n+        // be inspected. It's important for the value\n+        // to have type lldestty (the callee's expected type).\n+        let llformal_ty = type_of::type_of(ccx, formal_ty.ty);\n+        val = llvm::LLVMGetUndef(llformal_ty);\n+    } else {\n+        match arg_mode {\n+            ast::by_ref | ast::by_mutbl_ref => {\n+                val = arg_datum.to_ref_llval(bcx);\n+            }\n+\n+            ast::by_val => {\n+                // NB: avoid running the take glue.\n+                val = arg_datum.to_value_llval(bcx);\n+            }\n+\n+            ast::by_copy | ast::by_move => {\n+                let scratch = scratch_datum(bcx, arg_datum.ty, false);\n+\n+                if arg_mode == ast::by_move {\n+                    // NDM---Doesn't seem like this should be necessary\n+                    if !arg_datum.store_will_move() {\n+                        bcx.sess().span_err(\n+                            arg_expr.span,\n+                            fmt!(\"move mode but datum will not store: %s\",\n+                                 arg_datum.to_str(bcx.ccx())));\n+                    }\n+                }\n+\n+                arg_datum.store_to_datum(bcx, INIT, scratch);\n+\n+                // Technically, ownership of val passes to the callee.\n+                // However, we must cleanup should we fail before the\n+                // callee is actually invoked.\n+                scratch.add_clean(bcx);\n+                vec::push(*temp_cleanups, scratch.val);\n+                val = scratch.val;\n+          }\n+        }\n+\n+        if formal_ty.ty != arg_datum.ty {\n+            // this could happen due to e.g. subtyping\n+            let llformal_ty = type_of::type_of_explicit_arg(ccx, formal_ty);\n+            debug!(\"casting actual type (%s) to match formal (%s)\",\n+                   bcx.val_str(val), bcx.llty_str(llformal_ty));\n+            val = PointerCast(bcx, val, llformal_ty);\n+        }\n+    }\n+\n+    debug!(\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val));\n+    return rslt(bcx, val);\n+}\n+\n+// when invoking a method, an argument of type @T or ~T can be implicltly\n+// converted to an argument of type &T. Similarly, ~[T] can be converted to\n+// &[T] and so on.  If such a conversion (called borrowing) is necessary,\n+// then the borrowings table will have an appropriate entry inserted.  This\n+// routine consults this table and performs these adaptations.  It returns a\n+// new location for the borrowed result as well as a new type for the argument\n+// that reflects the borrowed value and not the original.\n+fn adapt_borrowed_value(bcx: block,\n+                        datum: Datum,\n+                        expr: @ast::expr) -> DatumBlock\n+{\n+    if !expr_is_borrowed(bcx, expr) {\n+        return DatumBlock {bcx: bcx, datum: datum};\n+    }\n+\n+    debug!(\"adapt_borrowed_value(datum=%s, expr=%s)\",\n+           datum.to_str(bcx.ccx()),\n+           bcx.expr_to_str(expr));\n+\n+    match ty::get(datum.ty).struct {\n+        ty::ty_uniq(_) | ty::ty_box(_) => {\n+            let body_datum = datum.box_body(bcx);\n+            let rptr_datum = body_datum.to_rptr(bcx);\n+            return DatumBlock {bcx: bcx, datum: rptr_datum};\n+        }\n+\n+        ty::ty_estr(_) | ty::ty_evec(_, _) => {\n+            let ccx = bcx.ccx();\n+            let val = datum.to_appropriate_llval(bcx);\n+\n+            let unit_ty = ty::sequence_element_type(ccx.tcx, datum.ty);\n+            let llunit_ty = type_of::type_of(ccx, unit_ty);\n+            let (base, len) = datum.get_base_and_len(bcx);\n+            let p = alloca(bcx, T_struct(~[T_ptr(llunit_ty), ccx.int_type]));\n+\n+            debug!(\"adapt_borrowed_value: adapting %s to %s\",\n+                   val_str(bcx.ccx().tn, val),\n+                   val_str(bcx.ccx().tn, p));\n+\n+            Store(bcx, base, GEPi(bcx, p, [0u, abi::slice_elt_base]));\n+            Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]));\n+\n+            // this isn't necessarily the type that rust would assign\n+            // but it's close enough for trans purposes, as it will\n+            // have the same runtime representation\n+            let slice_ty = ty::mk_evec(bcx.tcx(),\n+                                       {ty: unit_ty, mutbl: ast::m_imm},\n+                                       ty::vstore_slice(ty::re_static));\n+\n+            return DatumBlock {bcx: bcx,\n+                               datum: Datum {val: p,\n+                                             mode: ByRef,\n+                                             ty: slice_ty,\n+                                             source: FromRvalue}};\n+        }\n+\n+        _ => {\n+            // Just take a reference. This is basically like trans_addr_of.\n+            //\n+            // NDM---this code is almost certainly wrong.  I presume its\n+            // purpose is auto-ref? What if an @T is autoref'd? No good.\n+            let rptr_datum = datum.to_rptr(bcx);\n+            return DatumBlock {bcx: bcx, datum: rptr_datum};\n+        }\n+    }\n+\n+    fn expr_is_borrowed(bcx: block, e: @ast::expr) -> bool {\n+        bcx.tcx().borrowings.contains_key(e.id)\n+    }\n+}\n+"}, {"sha": "9cf4393346b774aa98218d2ff877b18d21599d90", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 157, "deletions": 149, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -17,6 +17,7 @@ use util::ppaux::ty_to_str;\n use syntax::ast_map::{path, path_mod, path_name};\n use driver::session::session;\n use std::map::hashmap;\n+use datum::{Datum, INIT, ByRef, ByValue, FromLvalue};\n \n // ___Good to know (tm)__________________________________________________\n //\n@@ -87,25 +88,35 @@ use std::map::hashmap;\n //\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-enum environment_value {\n-    // Copy the value from this llvm ValueRef into the environment.\n-    env_copy(ValueRef, ty::t, lval_kind),\n+enum EnvAction {\n+    /// Copy the value from this llvm ValueRef into the environment.\n+    EnvStore,\n \n-    // Move the value from this llvm ValueRef into the environment.\n-    env_move(ValueRef, ty::t, lval_kind),\n+    /// Move the value from this llvm ValueRef into the environment.\n+    EnvMove,\n \n-    // Access by reference (used for blocks).\n-    env_ref(ValueRef, ty::t, lval_kind),\n+    /// Access by reference (used for stack closures).\n+    EnvRef\n }\n \n-fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> ~str {\n-    match ev {\n-      env_copy(v, t, _) => fmt!(\"copy(%s,%s)\", val_str(ccx.tn, v),\n-                                ty_to_str(ccx.tcx, t)),\n-      env_move(v, t, _) => fmt!(\"move(%s,%s)\", val_str(ccx.tn, v),\n-                                ty_to_str(ccx.tcx, t)),\n-      env_ref(v, t, _) => fmt!(\"ref(%s,%s)\", val_str(ccx.tn, v),\n-                               ty_to_str(ccx.tcx, t))\n+struct EnvValue {\n+    action: EnvAction;\n+    datum: Datum;\n+}\n+\n+impl EnvAction {\n+    fn to_str() -> ~str {\n+        match self {\n+            EnvStore => ~\"EnvStore\",\n+            EnvMove => ~\"EnvMove\",\n+            EnvRef => ~\"EnvRef\"\n+        }\n+    }\n+}\n+\n+impl EnvValue {\n+    fn to_str(ccx: @crate_ctxt) -> ~str {\n+        fmt!(\"%s(%s)\", self.action.to_str(), self.datum.to_str(ccx))\n     }\n }\n \n@@ -116,18 +127,18 @@ fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n \n // Given a closure ty, emits a corresponding tuple ty\n fn mk_closure_tys(tcx: ty::ctxt,\n-                  bound_values: ~[environment_value])\n+                  bound_values: ~[EnvValue])\n     -> ty::t {\n-    let mut bound_tys = ~[];\n-\n-    // Compute the closed over data\n-    for vec::each(bound_values) |bv| {\n-        vec::push(bound_tys, match bv {\n-            env_copy(_, t, _) => t,\n-            env_move(_, t, _) => t,\n-            env_ref(_, t, _) => t\n-        });\n-    }\n+    // determine the types of the values in the env.  Note that this\n+    // is the actual types that will be stored in the map, not the\n+    // logical types as the user sees them, so by-ref upvars must be\n+    // converted to ptrs.\n+    let bound_tys = bound_values.map(|bv| {\n+        match bv.action {\n+            EnvStore | EnvMove => bv.datum.ty,\n+            EnvRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n+        }\n+    });\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n     debug!(\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty));\n     return cdata_ty;\n@@ -136,7 +147,8 @@ fn mk_closure_tys(tcx: ty::ctxt,\n fn allocate_cbox(bcx: block,\n                  ck: ty::closure_kind,\n                  cdata_ty: ty::t)\n-    -> result {\n+    -> Result\n+{\n     let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n@@ -151,18 +163,16 @@ fn allocate_cbox(bcx: block,\n     }\n \n     // Allocate and initialize the box:\n-    let {bcx, val} = match ck {\n+    match ck {\n       ty::ck_box => malloc_raw(bcx, cdata_ty, heap_shared),\n       ty::ck_uniq => malloc_raw(bcx, cdata_ty, heap_exchange),\n       ty::ck_block => {\n-        let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-        let llbox = base::alloc_ty(bcx, cbox_ty);\n-        nuke_ref_count(bcx, llbox);\n-        {bcx: bcx, val: llbox}\n+          let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n+          let llbox = base::alloc_ty(bcx, cbox_ty);\n+          nuke_ref_count(bcx, llbox);\n+          rslt(bcx, llbox)\n       }\n-    };\n-\n-    return {bcx: bcx, val: val};\n+    }\n }\n \n type closure_result = {\n@@ -176,7 +186,7 @@ type closure_result = {\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n fn store_environment(bcx: block,\n-                     bound_values: ~[environment_value],\n+                     bound_values: ~[EnvValue],\n                      ck: ty::closure_kind) -> closure_result {\n     let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n@@ -185,7 +195,7 @@ fn store_environment(bcx: block,\n     let cdata_ty = mk_closure_tys(tcx, bound_values);\n \n     // allocate closure in the heap\n-    let {bcx: bcx, val: llbox} = allocate_cbox(bcx, ck, cdata_ty);\n+    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, ck, cdata_ty);\n     let mut temp_cleanups = ~[];\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n@@ -200,43 +210,27 @@ fn store_environment(bcx: block,\n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n     do vec::iteri(bound_values) |i, bv| {\n-        debug!(\"Copy %s into closure\", ev_to_str(ccx, bv));\n+        debug!(\"Copy %s into closure\", bv.to_str(ccx));\n \n         if !ccx.sess.no_asm_comments() {\n             add_comment(bcx, fmt!(\"Copy %s into closure\",\n-                                  ev_to_str(ccx, bv)));\n+                                  bv.to_str(ccx)));\n         }\n \n         let bound_data = GEPi(bcx, llbox, [0u, abi::box_field_body, i]);\n-        match bv {\n-          env_copy(val, ty, lv_owned) => {\n-            let val1 = load_if_immediate(bcx, val, ty);\n-            bcx = base::copy_val(bcx, INIT, bound_data, val1, ty);\n-          }\n-          env_copy(val, ty, lv_owned_imm) => {\n-            bcx = base::copy_val(bcx, INIT, bound_data, val, ty);\n-          }\n-          env_copy(_, _, lv_temporary) => {\n-            fail ~\"cannot capture temporary upvar\";\n-          }\n-          env_move(val, ty, kind) => {\n-            let src = {bcx:bcx, val:val, kind:kind};\n-            bcx = move_val(bcx, INIT, bound_data, src, ty);\n-          }\n-          env_ref(val, _, lv_owned) => {\n-            debug!(\"> storing %s into %s\",\n-                   val_str(bcx.ccx().tn, val),\n-                   val_str(bcx.ccx().tn, bound_data));\n-            Store(bcx, val, bound_data);\n-          }\n-          env_ref(val, _, lv_owned_imm) => {\n-            let addr = do_spill_noroot(bcx, val);\n-            Store(bcx, addr, bound_data);\n-          }\n-          env_ref(_, _, lv_temporary) => {\n-            fail ~\"cannot capture temporary upvar\";\n-          }\n+\n+        match bv.action {\n+            EnvStore => {\n+                bcx = bv.datum.store_to(bcx, INIT, bound_data);\n+            }\n+            EnvMove => {\n+                bcx = bv.datum.move_to(bcx, INIT, bound_data);\n+            }\n+            EnvRef => {\n+                Store(bcx, bv.datum.to_ref_llval(bcx), bound_data);\n+            }\n         }\n+\n     }\n     for vec::each(temp_cleanups) |cleanup| { revoke_clean(bcx, cleanup); }\n \n@@ -252,56 +246,57 @@ fn build_closure(bcx0: block,\n                  include_ret_handle: Option<ValueRef>) -> closure_result {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n-    let mut env_vals = ~[];\n-    let mut bcx = bcx0;\n+    let mut bcx = bcx0;;\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // Package up the captured upvars\n+    let mut env_vals = ~[];\n     do vec::iter(cap_vars) |cap_var| {\n         debug!(\"Building closure: captured variable %?\", cap_var);\n-        let lv = trans_local_var(bcx, cap_var.def);\n-        let nid = ast_util::def_id_of_def(cap_var.def).node;\n-        debug!(\"Node id is %s\",\n-               syntax::ast_map::node_id_to_str\n-                   (bcx.ccx().tcx.items, nid,\n-                    bcx.ccx().sess.parse_sess.interner));\n-        let mut ty = node_id_type(bcx, nid);\n+        let datum = expr::trans_local_var(bcx, id, cap_var.def);\n         match cap_var.mode {\n-          capture::cap_ref => {\n-            assert ck == ty::ck_block;\n-            ty = ty::mk_mut_ptr(tcx, ty);\n-            vec::push(env_vals, env_ref(lv.val, ty, lv.kind));\n-          }\n-          capture::cap_copy => {\n-            let mv = match ccx.maps.last_use_map.find(id) {\n-              None => false,\n-              Some(vars) => (*vars).contains(nid)\n-            };\n-            if mv { vec::push(env_vals, env_move(lv.val, ty, lv.kind)); }\n-            else { vec::push(env_vals, env_copy(lv.val, ty, lv.kind)); }\n-          }\n-          capture::cap_move => {\n-            vec::push(env_vals, env_move(lv.val, ty, lv.kind));\n-          }\n-          capture::cap_drop => {\n-            assert lv.kind == lv_owned;\n-            bcx = drop_ty(bcx, lv.val, ty);\n-            bcx = zero_mem(bcx, lv.val, ty);\n-          }\n+            capture::cap_ref => {\n+                assert ck == ty::ck_block;\n+                vec::push(env_vals, EnvValue {action: EnvRef,\n+                                              datum: datum});\n+            }\n+            capture::cap_copy => {\n+                vec::push(env_vals, EnvValue {action: EnvStore,\n+                                              datum: datum});\n+            }\n+            capture::cap_move => {\n+                vec::push(env_vals, EnvValue {action: EnvMove,\n+                                              datum: datum});\n+            }\n+            capture::cap_drop => {\n+                bcx = datum.drop_val(bcx);\n+                datum.cancel_clean(bcx);\n+            }\n         }\n     }\n+\n+    // If this is a `for` loop body, add two special environment\n+    // variables:\n     do option::iter(include_ret_handle) |flagptr| {\n-        let our_ret = match bcx.fcx.loop_ret {\n-          Some({retptr, _}) => retptr,\n-          None => bcx.fcx.llretptr\n+        // Flag indicating we have returned (a by-ref bool):\n+        let flag_datum = Datum {val: flagptr, ty: ty::mk_bool(tcx),\n+                                mode: ByRef, source: FromLvalue};\n+        vec::push(env_vals, EnvValue {action: EnvRef,\n+                                      datum: flag_datum});\n+\n+        // Return value (we just pass a by-ref () and cast it later to\n+        // the right thing):\n+        let ret_true = match bcx.fcx.loop_ret {\n+            Some({retptr, _}) => retptr,\n+            None => bcx.fcx.llretptr\n         };\n-        let nil_ret = PointerCast(bcx, our_ret, T_ptr(T_nil()));\n-        vec::push(env_vals,\n-                  env_ref(flagptr,\n-                          ty::mk_mut_ptr(tcx, ty::mk_bool(tcx)), lv_owned));\n-        vec::push(env_vals,\n-                  env_ref(nil_ret, ty::mk_nil_ptr(tcx), lv_owned));\n+        let ret_casted = PointerCast(bcx, ret_true, T_ptr(T_nil()));\n+        let ret_datum = Datum {val: ret_casted, ty: ty::mk_nil(tcx),\n+                               mode: ByRef, source: FromLvalue};\n+        vec::push(env_vals, EnvValue {action: EnvRef,\n+                                      datum: ret_datum});\n     }\n+\n     return store_environment(bcx, env_vals, ck);\n }\n \n@@ -351,9 +346,16 @@ fn trans_expr_fn(bcx: block,\n                  id: ast::node_id,\n                  cap_clause: ast::capture_clause,\n                  is_loop_body: Option<Option<ValueRef>>,\n-                 dest: dest) -> block {\n+                 dest: expr::Dest) -> block {\n     let _icx = bcx.insn_ctxt(\"closure::trans_expr_fn\");\n-    if dest == ignore { return bcx; }\n+\n+    let dest_addr = match dest {\n+        expr::SaveIn(p) => p,\n+        expr::Ignore => {\n+            return bcx; // closure construction is non-side-effecting\n+        }\n+    };\n+\n     let ccx = bcx.ccx();\n     let fty = node_id_type(bcx, id);\n     let llfnty = type_of_fn_from_ty(ccx, fty);\n@@ -362,7 +364,7 @@ fn trans_expr_fn(bcx: block,\n     let s = mangle_internal_name_by_path(ccx, sub_path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n-    let trans_closure_env = fn@(ck: ty::closure_kind) -> result {\n+    let trans_closure_env = fn@(ck: ty::closure_kind) -> Result {\n         let cap_vars = capture::compute_capture_vars(ccx.tcx, id, proto,\n                                                      cap_clause);\n         let ret_handle = match is_loop_body { Some(x) => x, None => None };\n@@ -377,25 +379,29 @@ fn trans_expr_fn(bcx: block,\n                 Store(bcx, C_bool(true), bcx.fcx.llretptr);\n             }\n         });\n-        {bcx: bcx, val: llbox}\n+        rslt(bcx, llbox)\n     };\n \n-    let {bcx: bcx, val: closure} = match proto {\n-      ty::proto_vstore(ty::vstore_slice(_)) =>\n-        trans_closure_env(ty::ck_block),\n-      ty::proto_vstore(ty::vstore_box) =>\n-        trans_closure_env(ty::ck_box),\n-      ty::proto_vstore(ty::vstore_uniq) =>\n-        trans_closure_env(ty::ck_uniq),\n-      ty::proto_bare => {\n-        trans_closure(ccx, sub_path, decl, body, llfn, no_self, None,\n-                      id, |_fcx| { }, |_bcx| { });\n-        {bcx: bcx, val: C_null(T_opaque_box_ptr(ccx))}\n-      }\n-      ty::proto_vstore(ty::vstore_fixed(_)) =>\n-        fail ~\"vstore_fixed unexpected\"\n+    let Result {bcx: bcx, val: closure} = match proto {\n+        ty::proto_vstore(ty::vstore_slice(_)) => {\n+            trans_closure_env(ty::ck_block)\n+        }\n+        ty::proto_vstore(ty::vstore_box) => {\n+            trans_closure_env(ty::ck_box)\n+        }\n+        ty::proto_vstore(ty::vstore_uniq) => {\n+            trans_closure_env(ty::ck_uniq)\n+        }\n+        ty::proto_bare => {\n+            trans_closure(ccx, sub_path, decl, body, llfn, no_self, None,\n+                          id, |_fcx| { }, |_bcx| { });\n+            rslt(bcx, C_null(T_opaque_box_ptr(ccx)))\n+        }\n+        ty::proto_vstore(ty::vstore_fixed(_)) => {\n+            fail ~\"vstore_fixed unexpected\"\n+        }\n     };\n-    fill_fn_pair(bcx, get_dest_addr(dest), llfn, closure);\n+    fill_fn_pair(bcx, dest_addr, llfn, closure);\n \n     return bcx;\n }\n@@ -440,12 +446,12 @@ fn make_opaque_cbox_take_glue(\n     // Easy cases:\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_take_glue\");\n     match ck {\n-      ty::ck_block => return bcx,\n-      ty::ck_box => {\n-        incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr));\n-        return bcx;\n-      }\n-      ty::ck_uniq => { /* hard case: */ }\n+        ty::ck_block => return bcx,\n+        ty::ck_box => {\n+            glue::incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr));\n+            return bcx;\n+        }\n+        ty::ck_uniq => { /* hard case: */ }\n     }\n \n     // Hard case, a deep copy:\n@@ -467,20 +473,20 @@ fn make_opaque_cbox_take_glue(\n         let malloc = ~\"exchange_malloc\";\n         let opaque_tydesc = PointerCast(bcx, tydesc, T_ptr(T_i8()));\n         let rval = alloca_zeroed(bcx, T_ptr(T_i8()));\n-        let bcx = trans_rtcall(bcx, malloc, ~[opaque_tydesc, sz],\n-                               save_in(rval));\n+        let bcx = callee::trans_rtcall(bcx, malloc, ~[opaque_tydesc, sz],\n+                                       expr::SaveIn(rval));\n         let cbox_out = PointerCast(bcx, Load(bcx, rval), llopaquecboxty);\n         call_memmove(bcx, cbox_out, cbox_in, sz);\n         Store(bcx, cbox_out, cboxptr);\n \n         // Take the (deeply cloned) type descriptor\n         let tydesc_out = GEPi(bcx, cbox_out, [0u, abi::box_field_tydesc]);\n-        let bcx = take_ty(bcx, tydesc_out, ty::mk_type(tcx));\n+        let bcx = glue::take_ty(bcx, tydesc_out, ty::mk_type(tcx));\n \n         // Take the data in the tuple\n         let cdata_out = GEPi(bcx, cbox_out, [0u, abi::box_field_body]);\n-        call_tydesc_glue_full(bcx, cdata_out, tydesc,\n-                              abi::tydesc_field_take_glue, None);\n+        glue::call_tydesc_glue_full(bcx, cdata_out, tydesc,\n+                                    abi::tydesc_field_take_glue, None);\n         bcx\n     }\n }\n@@ -492,15 +498,17 @@ fn make_opaque_cbox_drop_glue(\n     -> block {\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n     match ck {\n-      ty::ck_block => bcx,\n-      ty::ck_box => {\n-        decr_refcnt_maybe_free(bcx, Load(bcx, cboxptr),\n-                               ty::mk_opaque_closure_ptr(bcx.tcx(), ck))\n-      }\n-      ty::ck_uniq => {\n-        free_ty(bcx, cboxptr,\n+        ty::ck_block => bcx,\n+        ty::ck_box => {\n+            glue::decr_refcnt_maybe_free(\n+                bcx, Load(bcx, cboxptr),\n                 ty::mk_opaque_closure_ptr(bcx.tcx(), ck))\n-      }\n+        }\n+        ty::ck_uniq => {\n+            glue::free_ty(\n+                bcx, cboxptr,\n+                ty::mk_opaque_closure_ptr(bcx.tcx(), ck))\n+        }\n     }\n }\n \n@@ -526,14 +534,14 @@ fn make_opaque_cbox_free_glue(\n \n         // Drop the tuple data then free the descriptor\n         let cdata = GEPi(bcx, cbox, [0u, abi::box_field_body]);\n-        call_tydesc_glue_full(bcx, cdata, tydesc,\n-                              abi::tydesc_field_drop_glue, None);\n+        glue::call_tydesc_glue_full(bcx, cdata, tydesc,\n+                                    abi::tydesc_field_drop_glue, None);\n \n         // Free the ty descr (if necc) and the box itself\n         match ck {\n-          ty::ck_block => fail ~\"Impossible\",\n-          ty::ck_box => trans_free(bcx, cbox),\n-          ty::ck_uniq => trans_unique_free(bcx, cbox)\n+            ty::ck_block => fail ~\"Impossible\",\n+            ty::ck_box => glue::trans_free(bcx, cbox),\n+            ty::ck_uniq => glue::trans_unique_free(bcx, cbox)\n         }\n     }\n }"}, {"sha": "6fb547d757dd3333a70ecce6ab07997f3e4ed3d3", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 114, "deletions": 58, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -20,6 +20,7 @@ use metadata::{csearch};\n use metadata::common::link_meta;\n use syntax::ast_map::path;\n use util::ppaux::ty_to_str;\n+use syntax::print::pprust::expr_to_str;\n use syntax::parse::token::ident_interner;\n use syntax::ast::ident;\n \n@@ -165,7 +166,11 @@ type crate_ctxt = {\n      mut do_not_commit_warning_issued: bool};\n \n // Types used for llself.\n-type val_self_data = {v: ValueRef, t: ty::t, is_owned: bool};\n+struct ValSelfData {\n+    v: ValueRef;\n+    t: ty::t;\n+    is_owned: bool;\n+}\n \n enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n \n@@ -201,7 +206,7 @@ type fn_ctxt = @{\n     mut llreturn: BasicBlockRef,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n-    mut llself: Option<val_self_data>,\n+    mut llself: Option<ValSelfData>,\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n     mut personality: Option<ValueRef>,\n@@ -257,6 +262,25 @@ enum cleanup {\n     clean_temp(ValueRef, fn@(block) -> block, cleantype),\n }\n \n+impl cleantype : cmp::Eq {\n+    pure fn eq(&&other: cleantype) -> bool {\n+        match self {\n+            normal_exit_only => {\n+                match other {\n+                    normal_exit_only => true,\n+                    _ => false\n+                }\n+            }\n+            normal_exit_and_unwind => {\n+                match other {\n+                    normal_exit_and_unwind => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // Used to remember and reuse existing cleanup paths\n // target: none means the path ends in an resume instruction\n type cleanup_path = {target: Option<BasicBlockRef>,\n@@ -275,12 +299,12 @@ fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n     }\n }\n \n-// This is not the same as base::root_value, which appears to be the vestigial\n-// remains of the previous GC regime. In the new GC, we can identify\n-// immediates on the stack without difficulty, but have trouble knowing where\n-// non-immediates are on the stack. For non-immediates, we must add an\n-// additional level of indirection, which allows us to alloca a pointer with\n-// the right addrspace.\n+// This is not the same as datum::Datum::root(), which is used to keep copies\n+// of @ values live for as long as a borrowed pointer to the interior exists.\n+// In the new GC, we can identify immediates on the stack without difficulty,\n+// but have trouble knowing where non-immediates are on the stack. For\n+// non-immediates, we must add an additional level of indirection, which\n+// allows us to alloca a pointer with the right addrspace.\n fn root_for_cleanup(bcx: block, v: ValueRef, t: ty::t)\n     -> {root: ValueRef, rooted: bool} {\n     let ccx = bcx.ccx();\n@@ -305,11 +329,12 @@ fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |info| {\n         vec::push(info.cleanups,\n-                  clean(|a| base::drop_ty_root(a, root, rooted, t),\n+                  clean(|a| glue::drop_ty_root(a, root, rooted, t),\n                         cleanup_type));\n         scope_clean_changed(info);\n     }\n }\n+\n fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n     debug!(\"add_clean_temp_immediate(%s, %s, %s)\",\n@@ -318,7 +343,7 @@ fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     do in_scope_cx(cx) |info| {\n         vec::push(info.cleanups,\n-                  clean_temp(val, |a| base::drop_ty_immediate(a, val, ty),\n+                  clean_temp(val, |a| glue::drop_ty_immediate(a, val, ty),\n                              cleanup_type));\n         scope_clean_changed(info);\n     }\n@@ -332,15 +357,15 @@ fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |info| {\n         vec::push(info.cleanups,\n-                  clean_temp(val, |a| base::drop_ty_root(a, root, rooted, t),\n+                  clean_temp(val, |a| glue::drop_ty_root(a, root, rooted, t),\n                              cleanup_type));\n         scope_clean_changed(info);\n     }\n }\n fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n-      heap_shared => |a| base::trans_free(a, ptr),\n-      heap_exchange => |a| base::trans_unique_free(a, ptr)\n+      heap_shared => |a| glue::trans_free(a, ptr),\n+      heap_exchange => |a| glue::trans_unique_free(a, ptr)\n     };\n     do in_scope_cx(cx) |info| {\n         vec::push(info.cleanups, clean_temp(ptr, free_fn,\n@@ -355,12 +380,13 @@ fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n // drop glue checks whether it is zero.\n fn revoke_clean(cx: block, val: ValueRef) {\n     do in_scope_cx(cx) |info| {\n-        do option::iter(vec::position(info.cleanups, |cu| {\n-            match cu {\n-              clean_temp(v, _, _) if v == val => true,\n-              _ => false\n-            }\n-        })) |i| {\n+        let cleanup_pos = vec::position(\n+            info.cleanups,\n+            |cu| match cu {\n+                clean_temp(v, _, _) if v == val => true,\n+                _ => false\n+            });\n+        for cleanup_pos.each |i| {\n             info.cleanups =\n                 vec::append(vec::slice(info.cleanups, 0u, i),\n                             vec::view(info.cleanups,\n@@ -384,6 +410,7 @@ enum block_kind {\n     // to an implicit scope, for example, calls introduce an implicit scope in\n     // which the arguments are evaluated and cleaned up.\n     block_scope(scope_info),\n+\n     // A non-scope block is a basic block created as a translation artifact\n     // from translating code that expresses conditional logic rather than by\n     // explicit { ... } block structure in the source language.  It's called a\n@@ -480,11 +507,20 @@ fn mk_block(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n // First two args are retptr, env\n const first_real_arg: uint = 2u;\n \n-type result = {bcx: block, val: ValueRef};\n-type result_t = {bcx: block, val: ValueRef, ty: ty::t};\n+struct Result {\n+    bcx: block;\n+    val: ValueRef;\n+}\n+\n+fn rslt(bcx: block, val: ValueRef) -> Result {\n+    Result {bcx: bcx, val: val}\n+}\n \n-fn rslt(bcx: block, val: ValueRef) -> result {\n-    {bcx: bcx, val: val}\n+impl Result {\n+    fn unpack(bcx: &mut block) -> ValueRef {\n+        *bcx = self.bcx;\n+        return self.val;\n+    }\n }\n \n fn ty_str(tn: type_names, t: TypeRef) -> ~str {\n@@ -510,7 +546,12 @@ fn in_scope_cx(cx: block, f: fn(scope_info)) {\n     let mut cur = cx;\n     loop {\n         match cur.kind {\n-          block_scope(inf) => { f(inf); return; }\n+          block_scope(inf) => {\n+              debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                     cur.to_str(), cx.to_str());\n+              f(inf);\n+              return;\n+          }\n           _ => ()\n         }\n         cur = block_parent(cur);\n@@ -532,9 +573,40 @@ impl block {\n     pure fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n     pure fn sess() -> session { self.fcx.ccx.sess }\n \n+    fn node_id_to_str(id: ast::node_id) -> ~str {\n+        ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n+    }\n+\n+    fn expr_to_str(e: @ast::expr) -> ~str {\n+        fmt!(\"expr(%d: %s)\", e.id, expr_to_str(e, self.sess().intr()))\n+    }\n+\n+    fn expr_is_lval(e: @ast::expr) -> bool {\n+        ty::expr_is_lval(self.tcx(), self.ccx().maps.method_map, e)\n+    }\n+\n+    fn expr_kind(e: @ast::expr) -> ty::ExprKind {\n+        ty::expr_kind(self.tcx(), self.ccx().maps.method_map, e)\n+    }\n+\n+    fn def(nid: ast::node_id) -> ast::def {\n+        match self.tcx().def_map.find(nid) {\n+            Some(v) => v,\n+            None => {\n+                self.tcx().sess.bug(fmt!(\n+                    \"No def associated with node id %?\", nid));\n+            }\n+        }\n+    }\n+\n     fn val_str(val: ValueRef) -> ~str {\n         val_str(self.ccx().tn, val)\n     }\n+\n+    fn llty_str(llty: TypeRef) -> ~str {\n+        ty_str(self.ccx().tn, llty)\n+    }\n+\n     fn ty_to_str(t: ty::t) -> ~str {\n         ty_to_str(self.tcx(), t)\n     }\n@@ -954,14 +1026,16 @@ fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n                              elts.len() as c_uint);\n }\n \n-fn C_struct(elts: ~[ValueRef]) -> ValueRef unsafe {\n-    return llvm::LLVMConstStruct(vec::unsafe::to_ptr(elts),\n-                              elts.len() as c_uint, False);\n+fn C_struct(elts: &[ValueRef]) -> ValueRef {\n+    do vec::as_buf(elts) |ptr, len| {\n+        llvm::LLVMConstStruct(ptr, len as c_uint, False)\n+    }\n }\n \n-fn C_named_struct(T: TypeRef, elts: ~[ValueRef]) -> ValueRef unsafe {\n-    return llvm::LLVMConstNamedStruct(T, vec::unsafe::to_ptr(elts),\n-                                   elts.len() as c_uint);\n+fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n+    do vec::as_buf(elts) |ptr, len| {\n+        llvm::LLVMConstNamedStruct(T, ptr, len as c_uint)\n+    }\n }\n \n fn C_array(ty: TypeRef, elts: ~[ValueRef]) -> ValueRef unsafe {\n@@ -1100,40 +1174,22 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     }\n }\n \n-fn field_idx_strict(cx: ty::ctxt, sp: span, ident: ast::ident,\n-                    fields: ~[ty::field])\n-    -> uint {\n-    match ty::field_idx(ident, fields) {\n-       None => cx.sess.span_bug(\n-           sp, fmt!(\"base expr doesn't appear to \\\n-                         have a field named %s\", cx.sess.str_of(ident))),\n-       Some(i) => i\n-    }\n-}\n-\n fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n     {self_r: Some(ty::re_bound(ty::br_self)),\n      self_ty: None,\n      tps: tps}\n }\n \n-impl cleantype : cmp::Eq {\n-    pure fn eq(&&other: cleantype) -> bool {\n-        match self {\n-            normal_exit_only => {\n-                match other {\n-                    normal_exit_only => true,\n-                    _ => false\n-                }\n-            }\n-            normal_exit_and_unwind => {\n-                match other {\n-                    normal_exit_and_unwind => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n+fn struct_field(index: uint) -> [uint]/3 {\n+    //! The GEPi sequence to access a field of a record/struct.\n+\n+    [0, 0, index]\n+}\n+\n+fn struct_dtor() -> [uint]/2 {\n+    //! The GEPi sequence to access the dtor of a struct.\n+\n+    [0, 1]\n }\n \n //"}, {"sha": "f877a5a24b2c3dd1aacc766a816ccb6c10de8e7f", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -59,9 +59,15 @@ fn const_deref(cx: @crate_ctxt, v: ValueRef) -> ValueRef {\n     v\n }\n \n-fn const_get_elt(v: ValueRef, u: uint) -> ValueRef {\n-    let u = u;\n-    llvm::LLVMConstExtractValue(v, ptr::addr_of(u), 1 as c_uint)\n+fn const_get_elt(cx: @crate_ctxt, v: ValueRef, us: &[c_uint]) -> ValueRef {\n+    let r = do vec::as_buf(us) |p, len| {\n+        llvm::LLVMConstExtractValue(v, p, len as c_uint)\n+    };\n+\n+    debug!(\"const_get_elt(v=%s, us=%?, r=%s)\",\n+           val_str(cx.tn, v), us, val_str(cx.tn, r));\n+\n+    return r;\n }\n \n fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n@@ -83,7 +89,7 @@ fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n \n fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"const_expr\");\n-    match e.node {\n+    return match e.node {\n       ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n       ast::expr_binary(b, e1, e2) => {\n         let te1 = const_expr(cx, e1);\n@@ -156,15 +162,15 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n           let bt = ty::expr_ty(cx.tcx, base);\n           let bv = const_expr(cx, base);\n           let (bt, bv) = const_autoderef(cx, bt, bv);\n-          let fields = match ty::get(bt).struct {\n-              ty::ty_rec(fs) => fs,\n-              ty::ty_class(did, ref substs) =>\n-                  ty::class_items_as_mutable_fields(cx.tcx, did, substs),\n-              _ => cx.sess.span_bug(e.span,\n-                                    ~\"field access on unknown type in const\"),\n-          };\n-          let ix = field_idx_strict(cx.tcx, e.span, field, fields);\n-          const_get_elt(bv, ix)\n+          do expr::with_field_tys(cx.tcx, bt) |_has_dtor, field_tys| {\n+              let ix = ty::field_idx_strict(cx.tcx, field, field_tys);\n+\n+              // Note: ideally, we'd use `struct_field()` here instead\n+              // of hardcoding [0, ix], but we can't because it yields\n+              // the wrong type and also inserts an extra 0 that is\n+              // not needed in the constant variety:\n+              const_get_elt(cx, bv, [0, ix as c_uint])\n+          }\n       }\n \n       ast::expr_index(base, index) => {\n@@ -189,8 +195,8 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n                       let llunitty = type_of::type_of(cx, unit_ty);\n                       let unit_sz = shape::llsize_of(cx, llunitty);\n \n-                      (const_deref(cx, const_get_elt(bv, 0)),\n-                       llvm::LLVMConstUDiv(const_get_elt(bv, 1),\n+                      (const_deref(cx, const_get_elt(cx, bv, [0])),\n+                       llvm::LLVMConstUDiv(const_get_elt(cx, bv, [1]),\n                                            unit_sz))\n                   },\n                   _ => cx.sess.span_bug(base.span,\n@@ -240,27 +246,27 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n               cx.sess.span_err(e.span,\n                                ~\"const index-expr is out of bounds\");\n           }\n-          const_get_elt(arr, iv as uint)\n+          const_get_elt(cx, arr, [iv as c_uint])\n       }\n       ast::expr_cast(base, _) => {\n         let ety = ty::expr_ty(cx.tcx, e), llty = type_of::type_of(cx, ety);\n         let basety = ty::expr_ty(cx.tcx, base);\n         let v = const_expr(cx, base);\n-        match (base::cast_type_kind(basety),\n-                     base::cast_type_kind(ety)) {\n+        match (expr::cast_type_kind(basety),\n+               expr::cast_type_kind(ety)) {\n \n-          (base::cast_integral, base::cast_integral) => {\n+          (expr::cast_integral, expr::cast_integral) => {\n             let s = if ty::type_is_signed(basety) { True } else { False };\n             llvm::LLVMConstIntCast(v, llty, s)\n           }\n-          (base::cast_integral, base::cast_float) => {\n+          (expr::cast_integral, expr::cast_float) => {\n             if ty::type_is_signed(basety) { llvm::LLVMConstSIToFP(v, llty) }\n             else { llvm::LLVMConstUIToFP(v, llty) }\n           }\n-          (base::cast_float, base::cast_float) => {\n+          (expr::cast_float, expr::cast_float) => {\n             llvm::LLVMConstFPCast(v, llty)\n           }\n-          (base::cast_float, base::cast_integral) => {\n+          (expr::cast_float, expr::cast_integral) => {\n             if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty) }\n             else { llvm::LLVMConstFPToUI(v, llty) }\n           }\n@@ -282,34 +288,25 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n       ast::expr_tup(es) => {\n         C_struct(es.map(|e| const_expr(cx, e)))\n       }\n-      ast::expr_struct(_, fs, _) => {\n+      ast::expr_rec(fs, None) => {\n+          C_struct([C_struct(\n+              fs.map(|f| const_expr(cx, f.node.expr)))])\n+      }\n+      ast::expr_struct(_, ref fs, _) => {\n           let ety = ty::expr_ty(cx.tcx, e);\n-          let llty = type_of::type_of(cx, ety);\n-          let class_fields =\n-              match ty::get(ety).struct {\n-              ty::ty_class(clsid, _) =>\n-                  ty::lookup_class_fields(cx.tcx, clsid),\n-              _ =>\n-                  cx.tcx.sess.span_bug(e.span,\n-                                       ~\"didn't resolve to a struct\")\n-          };\n-          let mut cs = ~[];\n-          for class_fields.each |class_field| {\n-              let mut found = false;\n-              for fs.each |field| {\n-                  if class_field.ident == field.node.ident  {\n-                      found = true;\n-                      vec::push(cs, const_expr(cx, field.node.expr));\n+          let cs = do expr::with_field_tys(cx.tcx, ety) |_hd, field_tys| {\n+              field_tys.map(|field_ty| {\n+                  match fs.find(|f| field_ty.ident == f.node.ident) {\n+                      Some(f) => const_expr(cx, f.node.expr),\n+                      None => {\n+                          cx.tcx.sess.span_bug(\n+                              e.span, ~\"missing struct field\");\n+                      }\n                   }\n-              }\n-              if !found {\n-                  cx.tcx.sess.span_bug(e.span, ~\"missing struct field\");\n-              }\n-          }\n-          C_named_struct(llty, cs)\n-      }\n-      ast::expr_rec(fs, None) => {\n-        C_struct(fs.map(|f| const_expr(cx, f.node.expr)))\n+              })\n+          };\n+          let llty = type_of::type_of(cx, ety);\n+          C_named_struct(llty, [C_struct(cs)])\n       }\n       ast::expr_vec(es, ast::m_imm) => {\n         let (v, _, _) = const_vec(cx, e, es);\n@@ -364,7 +361,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n       }\n       _ => cx.sess.span_bug(e.span,\n             ~\"bad constant expression type in consts::const_expr\")\n-    }\n+    };\n }\n \n fn trans_const(ccx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {"}, {"sha": "83c5eb5f5f3c6448f403613febfa83c14028634e", "filename": "src/rustc/middle/trans/controlflow.rs", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,346 @@\n+use lib::llvm::ValueRef;\n+use common::*;\n+use datum::*;\n+use base::*;\n+\n+fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n+\n+fn trans_block(bcx: block, b: ast::blk, dest: expr::Dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_block\");\n+    let mut bcx = bcx;\n+    do block_locals(b) |local| {\n+        bcx = alloc_local(bcx, local);\n+    };\n+    for vec::each(b.node.stmts) |s| {\n+        debuginfo::update_source_pos(bcx, b.span);\n+        bcx = trans_stmt(bcx, *s);\n+    }\n+    match b.node.expr {\n+        Some(e) => {\n+            debuginfo::update_source_pos(bcx, e.span);\n+            bcx = expr::trans_into(bcx, e, dest);\n+        }\n+        None => {\n+            assert dest == expr::Ignore || bcx.unreachable;\n+        }\n+    }\n+    return bcx;\n+}\n+\n+fn trans_if(bcx: block,\n+            cond: @ast::expr,\n+            thn: ast::blk,\n+            els: Option<@ast::expr>,\n+            dest: expr::Dest)\n+    -> block\n+{\n+    debug!(\"trans_if(bcx=%s, cond=%s, thn=%?, dest=%s)\",\n+           bcx.to_str(), bcx.expr_to_str(cond), thn.node.id,\n+           dest.to_str(bcx.ccx()));\n+    let _indenter = indenter();\n+\n+    let _icx = bcx.insn_ctxt(\"trans_if\");\n+    let Result {bcx, val: cond_val} =\n+        expr::trans_to_appropriate_llval(bcx, cond);\n+\n+    let then_bcx_in = scope_block(bcx, thn.info(), ~\"then\");\n+    let else_bcx_in = scope_block(bcx, els.info(), ~\"else\");\n+    CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n+\n+    debug!(\"then_bcx_in=%s, else_bcx_in=%s\",\n+           then_bcx_in.to_str(), else_bcx_in.to_str());\n+\n+    let then_bcx_out = trans_block(then_bcx_in, thn, dest);\n+    let then_bcx_out = trans_block_cleanups(then_bcx_out,\n+                                            block_cleanups(then_bcx_in));\n+\n+    // Calling trans_block directly instead of trans_expr\n+    // because trans_expr will create another scope block\n+    // context for the block, but we've already got the\n+    // 'else' context\n+    let else_bcx_out = match els {\n+      Some(elexpr) => {\n+        match elexpr.node {\n+          ast::expr_if(_, _, _) => {\n+            let elseif_blk = ast_util::block_from_expr(elexpr);\n+            trans_block(else_bcx_in, elseif_blk, dest)\n+          }\n+          ast::expr_block(blk) => {\n+            trans_block(else_bcx_in, blk, dest)\n+          }\n+          // would be nice to have a constraint on ifs\n+          _ => bcx.tcx().sess.bug(~\"strange alternative in if\")\n+        }\n+      }\n+      _ => else_bcx_in\n+    };\n+    let else_bcx_out = trans_block_cleanups(else_bcx_out,\n+                                            block_cleanups(else_bcx_in));\n+    return join_blocks(bcx, ~[then_bcx_out, else_bcx_out]);\n+\n+}\n+\n+fn join_blocks(parent_bcx: block, in_cxs: ~[block]) -> block {\n+    let out = sub_block(parent_bcx, ~\"join\");\n+    let mut reachable = false;\n+    for vec::each(in_cxs) |bcx| {\n+        if !bcx.unreachable {\n+            Br(bcx, out.llbb);\n+            reachable = true;\n+        }\n+    }\n+    if !reachable {\n+        Unreachable(out);\n+    }\n+    return out;\n+}\n+\n+fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk)\n+    -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_while\");\n+    let next_bcx = sub_block(bcx, ~\"while next\");\n+\n+    //            bcx\n+    //             |\n+    //          loop_bcx\n+    //             |\n+    //         cond_bcx_in  <--------+\n+    //             |                 |\n+    //         cond_bcx_out          |\n+    //           |      |            |\n+    //           |    body_bcx_in    |\n+    //    +------+      |            |\n+    //    |           body_bcx_out --+\n+    // next_bcx\n+\n+    let loop_bcx = loop_scope_block(bcx, next_bcx, ~\"`while`\", body.info());\n+    let cond_bcx_in = scope_block(loop_bcx, cond.info(), ~\"while loop cond\");\n+    let body_bcx_in = scope_block(loop_bcx, body.info(), ~\"while loop body\");\n+    Br(bcx, loop_bcx.llbb);\n+    Br(loop_bcx, cond_bcx_in.llbb);\n+\n+    // compile the condition\n+    let Result {bcx: cond_bcx_out, val: cond_val} =\n+        expr::trans_to_appropriate_llval(cond_bcx_in, cond);\n+    let cond_bcx_out =\n+        trans_block_cleanups(cond_bcx_out, block_cleanups(cond_bcx_in));\n+    CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, next_bcx.llbb);\n+\n+    // loop body:\n+    let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n+    cleanup_and_Br(body_bcx_out, body_bcx_in, cond_bcx_in.llbb);\n+\n+    return next_bcx;\n+}\n+\n+fn trans_loop(bcx:block, body: ast::blk) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_loop\");\n+    let next_bcx = sub_block(bcx, ~\"next\");\n+    let body_bcx_in = loop_scope_block(bcx, next_bcx, ~\"`loop`\", body.info());\n+    Br(bcx, body_bcx_in.llbb);\n+    let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n+    cleanup_and_Br(body_bcx_out, body_bcx_in, body_bcx_in.llbb);\n+    return next_bcx;\n+}\n+\n+fn trans_log(log_ex: @ast::expr,\n+             lvl: @ast::expr,\n+             bcx: block,\n+             e: @ast::expr) -> block\n+{\n+    let _icx = bcx.insn_ctxt(\"trans_log\");\n+    let ccx = bcx.ccx();\n+    let mut bcx = bcx;\n+    if ty::type_is_bot(expr_ty(bcx, lvl)) {\n+       return expr::trans_into(bcx, lvl, expr::Ignore);\n+    }\n+\n+    let modpath = vec::append(\n+        ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))],\n+        vec::filter(bcx.fcx.path, |e|\n+            match e { path_mod(_) => true, _ => false }\n+        ));\n+    let modname = path_str(ccx.sess, modpath);\n+\n+    let global = if ccx.module_data.contains_key(modname) {\n+        ccx.module_data.get(modname)\n+    } else {\n+        let s = link::mangle_internal_name_by_path_and_seq(\n+            ccx, modpath, ~\"loglevel\");\n+        let global = str::as_c_str(s, |buf| {\n+            llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n+        });\n+        llvm::LLVMSetGlobalConstant(global, False);\n+        llvm::LLVMSetInitializer(global, C_null(T_i32()));\n+        lib::llvm::SetLinkage(global, lib::llvm::InternalLinkage);\n+        ccx.module_data.insert(modname, global);\n+        global\n+    };\n+    let current_level = Load(bcx, global);\n+    let level = unpack_result!(bcx, {\n+        do with_scope_result(bcx, lvl.info(), ~\"level\") |bcx| {\n+            expr::trans_to_appropriate_llval(bcx, lvl)\n+        }\n+    });\n+\n+    let llenabled = ICmp(bcx, lib::llvm::IntUGE, current_level, level);\n+    do with_cond(bcx, llenabled) |bcx| {\n+        do with_scope(bcx, log_ex.info(), ~\"log\") |bcx| {\n+            let mut bcx = bcx;\n+\n+            // Translate the value to be logged\n+            let val_datum = unpack_datum!(bcx, expr::trans_to_datum(bcx, e));\n+            let tydesc = get_tydesc_simple(ccx, val_datum.ty);\n+\n+            // Call the polymorphic log function\n+            let val = val_datum.to_ref_llval(bcx);\n+            let val = PointerCast(bcx, val, T_ptr(T_i8()));\n+            Call(bcx, ccx.upcalls.log_type, [tydesc, val, level]);\n+            bcx\n+        }\n+    }\n+}\n+\n+fn trans_break_cont(bcx: block, to_end: bool)\n+    -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_break_cont\");\n+    // Locate closest loop block, outputting cleanup as we go.\n+    let mut unwind = bcx;\n+    let mut target;\n+    loop {\n+        match unwind.kind {\n+          block_scope({loop_break: Some(brk), _}) => {\n+            target = if to_end {\n+                brk\n+            } else {\n+                unwind\n+            };\n+            break;\n+          }\n+          _ => ()\n+        }\n+        unwind = match unwind.parent {\n+          Some(bcx) => bcx,\n+          // This is a return from a loop body block\n+          None => {\n+            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr);\n+            cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n+            Unreachable(bcx);\n+            return bcx;\n+          }\n+        };\n+    }\n+    cleanup_and_Br(bcx, unwind, target.llbb);\n+    Unreachable(bcx);\n+    return bcx;\n+}\n+\n+fn trans_break(bcx: block) -> block {\n+    return trans_break_cont(bcx, true);\n+}\n+\n+fn trans_cont(bcx: block) -> block {\n+    return trans_break_cont(bcx, false);\n+}\n+\n+fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_ret\");\n+    let mut bcx = bcx;\n+    let retptr = match copy bcx.fcx.loop_ret {\n+      Some({flagptr, retptr}) => {\n+        // This is a loop body return. Must set continue flag (our retptr)\n+        // to false, return flag to true, and then store the value in the\n+        // parent's retptr.\n+        Store(bcx, C_bool(true), flagptr);\n+        Store(bcx, C_bool(false), bcx.fcx.llretptr);\n+        match e {\n+          Some(x) => PointerCast(bcx, retptr,\n+                                 T_ptr(type_of(bcx.ccx(), expr_ty(bcx, x)))),\n+          None => retptr\n+        }\n+      }\n+      None => bcx.fcx.llretptr\n+    };\n+    match e {\n+      Some(x) => {\n+        bcx = expr::trans_into(bcx, x, expr::SaveIn(retptr));\n+      }\n+      _ => ()\n+    }\n+    cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n+    Unreachable(bcx);\n+    return bcx;\n+}\n+fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n+                    pred_expr: @ast::expr, s: ~str) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n+    let expr_str = s + ~\" \" + expr_to_str(pred_expr, bcx.ccx().sess.intr())\n+        + ~\" failed\";\n+    let Result {bcx, val} = {\n+        do with_scope_result(bcx, chk_expr.info(), ~\"check\") |bcx| {\n+            expr::trans_to_appropriate_llval(bcx, pred_expr)\n+        }\n+    };\n+    do with_cond(bcx, Not(bcx, val)) |bcx| {\n+        trans_fail(bcx, Some(pred_expr.span), expr_str)\n+    }\n+}\n+\n+fn trans_fail_expr(bcx: block,\n+                   sp_opt: Option<span>,\n+                   fail_expr: Option<@ast::expr>) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_fail_expr\");\n+    let mut bcx = bcx;\n+    match fail_expr {\n+        Some(arg_expr) => {\n+            let ccx = bcx.ccx(), tcx = ccx.tcx;\n+            let arg_datum = unpack_datum!(\n+                bcx, expr::trans_to_datum(bcx, arg_expr));\n+\n+            if ty::type_is_str(arg_datum.ty) {\n+                let (lldata, _lllen) = arg_datum.get_base_and_len(bcx);\n+                return trans_fail_value(bcx, sp_opt, lldata);\n+            } else if bcx.unreachable || ty::type_is_bot(arg_datum.ty) {\n+                return bcx;\n+            } else {\n+                bcx.sess().span_bug(\n+                    arg_expr.span, ~\"fail called with unsupported type \" +\n+                    ppaux::ty_to_str(tcx, arg_datum.ty));\n+            }\n+        }\n+        _ => return trans_fail(bcx, sp_opt, ~\"explicit failure\")\n+    }\n+}\n+\n+fn trans_fail(bcx: block, sp_opt: Option<span>, fail_str: ~str)\n+    -> block\n+{\n+    let _icx = bcx.insn_ctxt(\"trans_fail\");\n+    let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n+    return trans_fail_value(bcx, sp_opt, V_fail_str);\n+}\n+\n+fn trans_fail_value(bcx: block, sp_opt: Option<span>, V_fail_str: ValueRef)\n+    -> block\n+{\n+    let _icx = bcx.insn_ctxt(\"trans_fail_value\");\n+    let ccx = bcx.ccx();\n+    let {V_filename, V_line} = match sp_opt {\n+      Some(sp) => {\n+        let sess = bcx.sess();\n+        let loc = codemap::lookup_char_pos(sess.parse_sess.cm, sp.lo);\n+        {V_filename: C_cstr(bcx.ccx(), loc.file.name),\n+         V_line: loc.line as int}\n+      }\n+      None => {\n+        {V_filename: C_cstr(bcx.ccx(), ~\"<runtime>\"),\n+         V_line: 0}\n+      }\n+    };\n+    let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));\n+    let V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n+    let args = ~[V_str, V_filename, C_int(ccx, V_line)];\n+    let bcx = callee::trans_rtcall(bcx, ~\"fail\", args, expr::Ignore);\n+    Unreachable(bcx);\n+    return bcx;\n+}"}, {"sha": "4f3591d99cac06febaa33e38a525140f2f8fc350", "filename": "src/rustc/middle/trans/datum.rs", "status": "added", "additions": 703, "deletions": 0, "changes": 703, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,703 @@\n+/*!\n+ *\n+ * A `Datum` contains all the information you need to describe the LLVM\n+ * translation of a Rust value.  It describes where the value is stored,\n+ * what Rust type the value has, whether it is addressed by reference,\n+ * and so forth.\n+ *\n+ * The idea of a datum is that, to the extent possible, you should not\n+ * care about these details, but rather use the methods on the Datum\n+ * type to \"do what you want to do\".  For example, you can simply call\n+ * `copy_to()` or `move_to()` to copy or move the value into a new\n+ * home.\n+ *\n+ * # Datum location\n+ *\n+ * The primary two fields of a datum are the `val` and the `mode`.\n+ * The `val` is an LLVM value ref.  It may either *be the value* that\n+ * is being tracked, or it may be a *pointer to the value being\n+ * tracked*.  This is specified in the `mode` field, which can either\n+ * be `ByValue` or `ByRef`, respectively.  The (Rust) type of the\n+ * value stored in the datum is indicated in the field `ty`.\n+ *\n+ * Generally speaking, you probably do not want to access the `val` field\n+ * unless you know what mode the value is in.  Intead you should use one\n+ * of the following accessors:\n+ *\n+ * - `to_value_llval()` converts to by-value\n+ * - `to_ref_llval()` converts to by-ref, allocating a stack slot if necessary\n+ * - `to_appropriate_llval()` converts to by-value if this is an\n+ *   immediate type, by-ref otherwise.  This is particularly\n+ *   convenient for interfacing with the various code floating around\n+ *   that predates datums.\n+ *\n+ * # Datum sources\n+ *\n+ * Each datum carries with it an idea of its \"source\".  This indicates\n+ * the kind of expression from which the datum originated.  The source\n+ * affects what happens when the datum is stored or moved.\n+ *\n+ * There are three options:\n+ *\n+ * 1. `FromRvalue`: This value originates from some temporary rvalue.\n+ *    This is therefore the owning reference to the datum.  If the\n+ *    datum is stored, then, it will be *moved* into its new home.\n+ *    Furthermore, we will not zero out the datum but rather use\n+ *    `revoke_clean()` to cancel any cleanup.\n+ *\n+ * 2. `FromLvalue`: This value originates from an lvalue.  If the datum\n+ *    is stored, it will be *copied* into its new home.  If the datum\n+ *    is moved, it will be zeroed out.\n+ *\n+ * 3. `FromLastUseLvalue`: The same as FromLvalue, except that it\n+ *    originates from the *last use* of an lvalue.  If the datum is\n+ *    stored, then, it will be moved (and zeroed out).\n+ *\n+ * # Storing, copying, and moving\n+ *\n+ * There are three kinds of methods for moving the value into a new\n+ * location.  *Storing* a datum is probably the one you want to reach\n+ * for first: it is used when you will no longer use the datum and\n+ * would like to place it somewhere.  It may translate to a copy or a\n+ * move, depending on the source of the datum.  After a store, the\n+ * datum may or may not be usable anymore, so you must assume it is\n+ * not.\n+ *\n+ * Sometimes, though, you want to use an explicit copy or move.  A\n+ * copy copies the data from the datum into a new location and\n+ * executes the take glue on that location, thus leaving the datum\n+ * valid for further use.  Moving, in contrast, copies the data into\n+ * the new location and then cancels any cleanups on the current datum\n+ * (as appropriate for the source).  No glue code is executed.  After\n+ * a move, the datum is no longer usable.\n+ *\n+ * # Scratch datum\n+ *\n+ * Sometimes you just need some temporary scratch space.  The\n+ * `scratch_datum()` function will yield you up a by-ref datum that\n+ * points into the stack.  It's your responsibility to ensure that\n+ * whatever you put in there gets cleaned up etc.\n+ *\n+ * # Other actions\n+ *\n+ * There are various other helper methods on Datum, such as `deref()`,\n+ * `get_base_and_len()` and so forth.  These are documented on the\n+ * methods themselves.  Most are only suitable for some types of\n+ * values. */\n+\n+use lib::llvm::ValueRef;\n+use base::*;\n+use common::*;\n+use build::*;\n+use util::ppaux::ty_to_str;\n+use util::common::indenter;\n+\n+enum CopyAction {\n+    INIT,\n+    DROP_EXISTING\n+}\n+\n+struct Datum {\n+    /// The llvm value.  This is either a pointer to the Rust value or\n+    /// the value itself, depending on `mode` below.\n+    val: ValueRef;\n+\n+    /// The rust type of the value.\n+    ty: ty::t;\n+\n+    /// Indicates whether this is by-ref or by-value.\n+    mode: DatumMode;\n+\n+    /// How did this value originate?  This is particularly important\n+    /// if the value is MOVED or prematurely DROPPED, because it\n+    /// describes how to cancel the cleanup that was scheduled before.\n+    /// See the def'n of the `DatumSource` type.\n+    source: DatumSource;\n+}\n+\n+struct DatumBlock {\n+    bcx: block;\n+    datum: Datum;\n+}\n+\n+enum DatumMode {\n+    /// `val` is a pointer to the actual value (and thus has type *T)\n+    ByRef,\n+\n+    /// `val` is the actual value (*only used for immediates* like ints, ptrs)\n+    ByValue,\n+}\n+\n+impl DatumMode {\n+    fn is_by_ref() -> bool {\n+        match self { ByRef => true, ByValue => false }\n+    }\n+\n+    fn is_by_value() -> bool {\n+        match self { ByRef => false, ByValue => true }\n+    }\n+}\n+\n+/// See `Datum Sources` section at the head of this module.\n+enum DatumSource {\n+    FromRvalue,\n+    FromLvalue,\n+    FromLastUseLvalue,\n+}\n+\n+impl DatumSource {\n+    fn is_rvalue() -> bool {\n+        match self {\n+            FromRvalue => true,\n+            FromLvalue | FromLastUseLvalue => false\n+        }\n+    }\n+\n+    fn is_any_lvalue() -> bool {\n+        match self {\n+            FromRvalue => false,\n+            FromLvalue | FromLastUseLvalue => true\n+        }\n+    }\n+}\n+\n+fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum {\n+    return Datum {val: val, ty: ty,\n+                  mode: ByValue, source: FromRvalue};\n+}\n+\n+fn immediate_rvalue_bcx(bcx: block, val: ValueRef, ty: ty::t) -> DatumBlock {\n+    return DatumBlock {bcx: bcx, datum: immediate_rvalue(val, ty)};\n+}\n+\n+fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n+    /*!\n+     *\n+     * Allocates temporary space on the stack using alloca() and\n+     * returns a by-ref Datum pointing to it.  You must arrange\n+     * any cleanups etc yourself! */\n+\n+    let scratch = alloc_ty(bcx, ty);\n+    if zero { zero_mem(bcx, scratch, ty); }\n+    Datum { val: scratch, ty: ty, mode: ByRef, source: FromRvalue }\n+}\n+\n+impl Datum {\n+    fn store_will_move() -> bool {\n+        match self.source {\n+            FromRvalue | FromLastUseLvalue => true,\n+            FromLvalue => false\n+        }\n+    }\n+\n+    fn store_to(bcx: block, action: CopyAction, dst: ValueRef) -> block {\n+        /*!\n+         *\n+         * Stores this value into its final home.  This moves if\n+         * possible, but copies otherwise. */\n+\n+        if self.store_will_move() {\n+            self.move_to(bcx, action, dst)\n+        } else {\n+            self.copy_to(bcx, action, dst)\n+        }\n+    }\n+\n+    fn store_to_dest(bcx: block, dest: expr::Dest) -> block {\n+        match dest {\n+            expr::Ignore => {\n+                return bcx;\n+            }\n+            expr::SaveIn(addr) => {\n+                return self.store_to(bcx, INIT, addr);\n+            }\n+        }\n+    }\n+\n+    fn store_to_datum(bcx: block, action: CopyAction, datum: Datum) -> block {\n+        debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n+               self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n+        assert datum.mode.is_by_ref();\n+        self.store_to(bcx, action, datum.val)\n+    }\n+\n+    fn move_to_datum(bcx: block, action: CopyAction, datum: Datum) -> block {\n+        assert datum.mode.is_by_ref();\n+        self.move_to(bcx, action, datum.val)\n+    }\n+\n+    fn copy_to_datum(bcx: block, action: CopyAction, datum: Datum) -> block {\n+        assert datum.mode.is_by_ref();\n+        self.copy_to(bcx, action, datum.val)\n+    }\n+\n+    fn copy_to(bcx: block, action: CopyAction, dst: ValueRef) -> block {\n+        /*!\n+         *\n+         * Copies the value into `dst`, which should be a pointer to a\n+         * memory location suitable for `self.ty`.  You PROBABLY want\n+         * `store_to()` instead, which will move if possible but copy if\n+         * neccessary. */\n+\n+        let _icx = bcx.insn_ctxt(\"copy_to\");\n+\n+        debug!(\"copy_to(self=%s, action=%?, dst=%s)\",\n+               self.to_str(bcx.ccx()), action, bcx.val_str(dst));\n+\n+        // Watch out for the case where we are writing the copying the\n+        // value into the same location we read it out from.  We want\n+        // to avoid the case where we drop the existing value, which\n+        // frees it, and then overwrite it with itself (which has been\n+        // freed).\n+        if action == DROP_EXISTING &&\n+            ty::type_needs_drop(bcx.tcx(), self.ty)\n+        {\n+            match self.mode {\n+                ByRef => {\n+                    let cast = PointerCast(bcx, dst, val_ty(self.val));\n+                    let cmp = ICmp(bcx, lib::llvm::IntNE, cast, self.val);\n+                    do with_cond(bcx, cmp) |bcx| {\n+                        self.copy_to_no_check(bcx, action, dst)\n+                    }\n+                }\n+                ByValue => {\n+                    self.copy_to_no_check(bcx, action, dst)\n+                }\n+            }\n+        } else {\n+            self.copy_to_no_check(bcx, action, dst)\n+        }\n+    }\n+\n+    fn copy_to_no_check(bcx: block, action: CopyAction,\n+                        dst: ValueRef) -> block\n+    {\n+        /*!\n+         *\n+         * A helper for `copy_to()` which does not check to see if we\n+         * are copying to/from the same value. */\n+\n+        let _icx = bcx.insn_ctxt(\"copy_to_no_check\");\n+        let mut bcx = bcx;\n+\n+        if action == DROP_EXISTING {\n+            bcx = glue::drop_ty(bcx, dst, self.ty);\n+        }\n+\n+        match self.mode {\n+            ByValue => {\n+                Store(bcx, self.val, dst);\n+            }\n+            ByRef => {\n+                memmove_ty(bcx, dst, self.val, self.ty);\n+            }\n+        }\n+\n+        return glue::take_ty(bcx, dst, self.ty);\n+    }\n+\n+    // This works like copy_val, except that it deinitializes the source.\n+    // Since it needs to zero out the source, src also needs to be an lval.\n+    //\n+    // FIXME (#839): We always zero out the source. Ideally we would\n+    // detect the case where a variable is always deinitialized by\n+    // block exit and thus doesn't need to be dropped.\n+    fn move_to(bcx: block, action: CopyAction, dst: ValueRef) -> block {\n+        let _icx = bcx.insn_ctxt(\"move_to\");\n+        let mut bcx = bcx;\n+\n+        debug!(\"move_to(self=%s, action=%?, dst=%s)\",\n+               self.to_str(bcx.ccx()), action, bcx.val_str(dst));\n+\n+        if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n+            return bcx;\n+        }\n+\n+        if action == DROP_EXISTING {\n+            bcx = glue::drop_ty(bcx, dst, self.ty);\n+        }\n+\n+        match self.mode {\n+            ByRef => {\n+                glue::memmove_ty(bcx, dst, self.val, self.ty);\n+            }\n+            ByValue => {\n+                Store(bcx, self.val, dst);\n+            }\n+        }\n+\n+        self.cancel_clean(bcx);\n+\n+        return bcx;\n+    }\n+\n+    fn add_clean(bcx: block) {\n+        /*!\n+         *\n+         * Schedules this datum for cleanup in `bcx`.  The datum\n+         * must be an rvalue. */\n+\n+        assert self.source.is_rvalue();\n+        match self.mode {\n+            ByValue => {\n+                add_clean_temp_immediate(bcx, self.val, self.ty);\n+            }\n+            ByRef => {\n+                add_clean_temp_mem(bcx, self.val, self.ty);\n+            }\n+        }\n+    }\n+\n+    fn cancel_clean(bcx: block) {\n+        if ty::type_needs_drop(bcx.tcx(), self.ty) {\n+            match self.source {\n+                FromRvalue => {\n+                    revoke_clean(bcx, self.val);\n+                }\n+                FromLvalue | FromLastUseLvalue => {\n+                    // Lvalues which potentially need to be dropped\n+                    // must be passed by ref, so that we can zero them\n+                    // out.\n+                    assert self.mode.is_by_ref();\n+                    zero_mem(bcx, self.val, self.ty);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn to_str(ccx: &crate_ctxt) -> ~str {\n+        fmt!(\"Datum { val=%s, ty=%s, mode=%?, source=%? }\",\n+             val_str(ccx.tn, self.val),\n+             ty_to_str(ccx.tcx, self.ty),\n+             self.mode,\n+             self.source)\n+    }\n+\n+    fn to_value_llval(bcx: block) -> ValueRef {\n+        /*!\n+         *\n+         * Yields the value itself. */\n+\n+        match self.mode {\n+            ByValue => self.val,\n+            ByRef => Load(bcx, self.val)\n+        }\n+    }\n+\n+    fn to_ref(bcx: block) -> Datum {\n+        /*!\n+         *\n+         * Yields a by-ref form of this datum.  This may involve\n+         * creation of a temporary stack slot.  The value returned by\n+         * this function is not separately rooted from this datum, so\n+         * it will not live longer than the current datum. */\n+\n+        match self.mode {\n+            ByRef => self,\n+            ByValue => {\n+                Datum {val: self.to_ref_llval(bcx), mode: ByRef,\n+                       ty: self.ty, source: FromRvalue}\n+            }\n+        }\n+    }\n+\n+    fn to_ref_llval(bcx: block) -> ValueRef {\n+        match self.mode {\n+            ByRef => self.val,\n+            ByValue => {\n+                let slot = alloc_ty(bcx, self.ty);\n+                Store(bcx, self.val, slot);\n+                slot\n+            }\n+        }\n+    }\n+\n+    fn to_appropriate_llval(bcx: block) -> ValueRef {\n+        /*!\n+         *\n+         * Yields something that is by value if the type is immediate\n+         * and by ref otherwise. */\n+\n+        if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n+            self.to_value_llval(bcx)\n+        } else if ty::type_is_immediate(self.ty) {\n+            self.to_value_llval(bcx)\n+        } else {\n+            self.to_ref_llval(bcx)\n+        }\n+    }\n+\n+    fn GEPi(bcx: block, ixs: &[uint], ty: ty::t) -> Datum {\n+        let base_val = self.to_ref_llval(bcx);\n+        Datum {\n+            val: GEPi(bcx, base_val, ixs),\n+            mode: ByRef,\n+            ty: ty,\n+            source: FromLvalue\n+        }\n+    }\n+\n+    fn root(bcx: block, scope_id: ast::node_id) {\n+        /*!\n+         *\n+         * In some cases, borrowck will decide that an @T/@[]/@str\n+         * value must be rooted for the program to be safe.  In that\n+         * case, we will call this function, which will stash a copy\n+         * away until we exit the scope `scope_id`. */\n+\n+        debug!(\"root(scope_id=%?, self=%?)\",\n+               scope_id, self.to_str(bcx.ccx()));\n+\n+        if bcx.sess().trace() {\n+            trans_trace(\n+                bcx, None,\n+                fmt!(\"preserving until end of scope %d\", scope_id));\n+        }\n+\n+        let scratch = scratch_datum(bcx, self.ty, true);\n+        self.copy_to_datum(bcx, INIT, scratch);\n+        base::add_root_cleanup(bcx, scope_id, scratch.val, scratch.ty);\n+    }\n+\n+    fn drop_val(bcx: block) -> block {\n+        if !ty::type_needs_drop(bcx.tcx(), self.ty) {\n+            return bcx;\n+        }\n+\n+        return match self.mode {\n+            ByRef => glue::drop_ty(bcx, self.val, self.ty),\n+            ByValue => glue::drop_ty_immediate(bcx, self.val, self.ty)\n+        };\n+    }\n+\n+    fn box_body(bcx: block) -> Datum {\n+        /*!\n+         *\n+         * This datum must represent an @T or ~T box.  Returns a new\n+         * by-ref datum of type T, pointing at the contents. */\n+\n+        let content_ty = match ty::get(self.ty).struct {\n+            ty::ty_box(mt) | ty::ty_uniq(mt) => mt.ty,\n+            _ => {\n+                bcx.tcx().sess.bug(fmt!(\n+                    \"box_body() invoked on non-box type %s\",\n+                    ty_to_str(bcx.tcx(), self.ty)));\n+            }\n+        };\n+\n+        let ptr = self.to_value_llval(bcx);\n+        let body = opaque_box_body(bcx, content_ty, ptr);\n+        Datum {val: body, ty: content_ty, mode: ByRef, source: FromLvalue}\n+    }\n+\n+    fn to_rptr(bcx: block) -> Datum {\n+        //!\n+        //\n+        // Returns a new datum of region-pointer type containing the\n+        // the same ptr as this datum (after converting to by-ref\n+        // using `to_ref_llval()`).\n+\n+        // Convert to ref, yielding lltype *T.  Then create a Rust\n+        // type &static/T (which translates to *T).  Construct new\n+        // result (which will be by-value).  Note that it is not\n+        // significant *which* region we pick here.\n+        let llval = self.to_ref_llval(bcx);\n+        let rptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::re_static,\n+                                      self.ty);\n+        Datum {val: llval, ty: rptr_ty,\n+               mode: ByValue, source: FromRvalue}\n+    }\n+\n+    fn try_deref(\n+        bcx: block,            // block wherein to generate insn's\n+        expr_id: ast::node_id, // id of expr being deref'd\n+        derefs: uint,          // number of times deref'd already\n+        is_auto: bool)         // if true, only deref if auto-derefable\n+        -> Option<Datum>\n+    {\n+        let ccx = bcx.ccx();\n+\n+        debug!(\"try_deref(expr_id=%d, derefs=%?, is_auto=%b, self=%?)\",\n+               expr_id, derefs, is_auto, self.to_str(bcx.ccx()));\n+        let _indenter = indenter();\n+\n+        // root the autoderef'd value, if necessary:\n+        //\n+        // (Note: root'd values are always boxes)\n+        match ccx.maps.root_map.find({id:expr_id, derefs:derefs}) {\n+            None => (),\n+            Some(scope_id) => {\n+                self.root(bcx, scope_id);\n+            }\n+        }\n+\n+        match ty::get(self.ty).struct {\n+            ty::ty_box(_) | ty::ty_uniq(_) => {\n+                return Some(self.box_body(bcx));\n+            }\n+            ty::ty_ptr(mt) => {\n+                if is_auto { // unsafe ptrs are not AUTO-derefable\n+                    return None;\n+                } else {\n+                    return Some(deref_ptr(bcx, &self, mt.ty));\n+                }\n+            }\n+            ty::ty_rptr(_, mt) => {\n+                return Some(deref_ptr(bcx, &self, mt.ty));\n+            }\n+            ty::ty_enum(did, ref substs) => {\n+                // Check whether this enum is a newtype enum:\n+                let variants = ty::enum_variants(ccx.tcx, did);\n+                if (*variants).len() != 1u || variants[0].args.len() != 1u {\n+                    return None;\n+                }\n+\n+                let ty = ty::subst(ccx.tcx, substs, variants[0].args[0]);\n+                return match self.mode {\n+                    ByRef => {\n+                        // Recast lv.val as a pointer to the newtype\n+                        // rather than a ptr to the enum type.\n+                        let llty = T_ptr(type_of::type_of(ccx, ty));\n+                        Some(Datum {\n+                            val: PointerCast(bcx, self.val, llty),\n+                            ty: ty,\n+                            mode: ByRef,\n+                            source: FromLvalue\n+                        })\n+                    }\n+                    ByValue => {\n+                        // Actually, this case cannot happen right\n+                        // now, because enums are never immediate.\n+                        // But in principle newtype'd immediate\n+                        // values should be immediate, and in that\n+                        // case the * would be a no-op except for\n+                        // changing the type, so I am putting this\n+                        // code in place here to do the right\n+                        // thing if this change ever goes through.\n+                        assert ty::type_is_immediate(ty);\n+                        Some(Datum {ty: ty, ..self})\n+                    }\n+                };\n+            }\n+            _ => { // not derefable.\n+                return None;\n+            }\n+        }\n+\n+        fn deref_ptr(bcx: block, lv: &Datum, ty: ty::t) -> Datum {\n+            Datum {\n+                val: lv.to_value_llval(bcx),\n+                ty: ty,\n+                mode: ByRef,\n+                source: FromLvalue // *p is an lvalue\n+            }\n+        }\n+    }\n+\n+    fn deref(bcx: block,\n+             expr: @ast::expr,  // the expression whose value is being deref'd\n+             derefs: uint) -> Datum {\n+        match self.try_deref(bcx, expr.id, derefs, false) {\n+            Some(lvres) => lvres,\n+            None => {\n+                bcx.ccx().sess.span_bug(\n+                    expr.span, ~\"Cannot deref this expression\");\n+            }\n+        }\n+    }\n+\n+    fn autoderef(bcx: block,\n+                 expr_id: ast::node_id,\n+                 max: uint) -> Datum {\n+        let _icx = bcx.insn_ctxt(\"autoderef\");\n+\n+        debug!(\"autoderef(expr_id=%d, max=%?, self=%?)\",\n+               expr_id, max, self.to_str(bcx.ccx()));\n+        let _indenter = indenter();\n+\n+        let mut datum = self;\n+        let mut derefs = 0u;\n+        while derefs < max {\n+            derefs += 1u;\n+            match datum.try_deref(bcx, expr_id, derefs, true) {\n+                None => break,\n+                Some(datum_deref) => {\n+                    datum = datum_deref;\n+                }\n+            }\n+        }\n+\n+        // either we were asked to deref a specific number of times,\n+        // in which case we should have, or we asked to deref as many\n+        // times as we can\n+        assert derefs == max || max == uint::max_value;\n+        datum\n+    }\n+\n+    fn get_base_and_len(bcx: block) -> (ValueRef, ValueRef) {\n+        tvec::get_base_and_len(bcx, self.to_appropriate_llval(bcx), self.ty)\n+    }\n+\n+    fn to_result(bcx: block) -> common::Result {\n+        rslt(bcx, self.to_appropriate_llval(bcx))\n+    }\n+}\n+\n+impl DatumBlock {\n+    fn unpack(bcx: &mut block) -> Datum {\n+        *bcx = self.bcx;\n+        return self.datum;\n+    }\n+\n+    fn assert_by_ref() -> DatumBlock {\n+        assert self.datum.mode.is_by_ref();\n+        self\n+    }\n+\n+    fn drop_val() -> block {\n+        self.datum.drop_val(self.bcx)\n+    }\n+\n+    fn store_to(action: CopyAction, dst: ValueRef) -> block {\n+        self.datum.store_to(self.bcx, action, dst)\n+    }\n+\n+    fn copy_to(action: CopyAction, dst: ValueRef) -> block {\n+        self.datum.copy_to(self.bcx, action, dst)\n+    }\n+\n+    fn move_to(action: CopyAction, dst: ValueRef) -> block {\n+        self.datum.move_to(self.bcx, action, dst)\n+    }\n+\n+    fn to_value_llval() -> ValueRef {\n+        self.datum.to_value_llval(self.bcx)\n+    }\n+\n+    fn to_result() -> common::Result {\n+        rslt(self.bcx, self.datum.to_appropriate_llval(self.bcx))\n+    }\n+\n+    fn ccx() -> @crate_ctxt {\n+        self.bcx.ccx()\n+    }\n+\n+    fn tcx() -> ty::ctxt {\n+        self.bcx.tcx()\n+    }\n+\n+    fn to_str() -> ~str {\n+        self.datum.to_str(self.ccx())\n+    }\n+}\n+\n+impl CopyAction : cmp::Eq {\n+    pure fn eq(&&other: CopyAction) -> bool {\n+        match (self, other) {\n+            (INIT, INIT) => true,\n+            (DROP_EXISTING, DROP_EXISTING) => true,\n+            (INIT, _) => false,\n+            (DROP_EXISTING, _) => false,\n+        }\n+    }\n+}"}, {"sha": "8b2acf1c0b5aa015f4e6368110dd14c372ed89f7", "filename": "src/rustc/middle/trans/expr.rs", "status": "added", "additions": 1371, "deletions": 0, "changes": 1371, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,1371 @@\n+/*!\n+\n+# Translation of expressions.\n+\n+## User's guide\n+\n+If you wish to translate an expression, there are two basic modes:\n+\n+1. `trans_into(block, expr, Dest) -> block`\n+2. `trans_to_datum(block, expr) -> DatumBlock`\n+\n+`trans_into()` is the preferred form to use whenever possible.  It\n+evaluates the expression and stores its result into `Dest`, which\n+must either be the special flag ignore (throw the result away) or\n+be a pointer to memory of the same type/size as the expression.\n+\n+Sometimes, though, you just want to evaluate the expression into\n+some memory location so you can go and inspect it (e.g., a `match`\n+expression).  In that case, `trans_to_datum()` is your friend.  It\n+will evaluate the expression and return a `Datum` describing where\n+the result is to be found.  This function tries to return its\n+result in the most efficient way possible, without introducing\n+extra copies or sacrificing information.  Therefore, for lvalue\n+expressions, you always get a by-ref `Datum` in return that points\n+at the memory for this lvalue (almost, see [1]).  For rvalue\n+expressions, we will return a by-value `Datum` whenever possible,\n+but it is often necessary to allocate a stack slot, store the\n+result of the rvalue in there, and then return a pointer to the\n+slot (see the discussion later on about the different kinds of\n+rvalues).\n+\n+## More specific functions\n+\n+The two functions above are the most general and can handle any\n+situation, but there are a few other functions that are useful\n+in specific scenarios:\n+\n+- `trans_to_appropriate_llval()` can be used when you just want\n+  an LLVM ValueRef.  It will return by value if the value in\n+  question is immediate, or by ref otherwise.\n+- `trans_lvalue()` is exactly like `trans_to_datum()` but it only\n+  works on lvalues.  This is mostly used as an assertion for those\n+  places where only an lvalue is expected.  It also guarantees that\n+  you will get a by-ref Datum back (almost, see [1]).\n+- `trans_local_var()` can be used to trans a ref to a local variable\n+  that is not an expression.\n+\n+## Ownership and cleanups\n+\n+The current system for cleanups associates required cleanups with\n+block contexts.  Block contexts are structured into a tree that\n+resembles the code itself.  Not every block context has cleanups\n+associated with it, only those blocks that have a kind of\n+`block_scope`.  See `common::block_kind` for more details.\n+\n+If you invoke `trans_into()`, no cleanup is scheduled for you.  The\n+value is written into the given destination and is assumed to be owned\n+by that destination.\n+\n+When you invoke `trans_to_datum()` or `trans_to_appropriate_llval()`\n+on an rvalue, the resulting datum/value will have an appropriate\n+cleanup scheduled for the innermost cleanup scope.  If you later use\n+`move_to()` or `drop_val()`, this cleanup will be canceled.\n+\n+During the evaluation of an expression, temporary cleanups are created\n+and later canceled.  These represent intermediate or partial results\n+which must be cleaned up in the event of task failure.\n+\n+## Implementation details\n+\n+We divide expressions into three categories, based on how they are most\n+naturally implemented:\n+\n+1. Lvalues\n+2. Datum rvalues\n+3. DPS rvalues\n+4. Statement rvalues\n+\n+Lvalues always refer to user-assignable memory locations.\n+Translating those always results in a by-ref datum; this introduces\n+no inefficiencies into the generated code, because all lvalues are\n+naturally addressable.\n+\n+Datum rvalues are rvalues that always generate datums as a result.\n+These are generally scalar results, such as `a+b` where `a` and `b`\n+are integers.\n+\n+DPS rvalues are rvalues that, when translated, must be given a\n+memory location to write into (or the Ignore flag).  These are\n+generally expressions that produce structural results that are\n+larger than one word (e.g., a struct literal), but also expressions\n+(like `if`) that involve control flow (otherwise we'd have to\n+generate phi nodes).\n+\n+Finally, statement rvalues are rvalues that always produce a nil\n+return type, such as `while` loops or assignments (`a = b`).\n+\n+## Caveats\n+\n+[1] Actually, some lvalues are only stored by value and not by\n+reference.  An example (as of this writing) would be immutable\n+arguments or pattern bindings of immediate type.  However, mutable\n+lvalues are *never* stored by value.\n+\n+*/\n+\n+use ty::class_items_as_mutable_fields;\n+use lib::llvm::ValueRef;\n+use common::*;\n+use datum::*;\n+use base::*;\n+use syntax::print::pprust::{expr_to_str};\n+use util::ppaux::ty_to_str;\n+use util::common::indenter;\n+\n+// The primary two functions for translating expressions:\n+export trans_to_datum, trans_into;\n+export Dest, SaveIn, Ignore;\n+export cast_type_kind;\n+export cast_kind, cast_pointer, cast_integral, cast_float;\n+export cast_enum, cast_other;\n+\n+// More specific variants than trans_to_datum/trans_into that are useful\n+// in some scenarios:\n+export trans_to_appropriate_llval, trans_lvalue, trans_local_var;\n+\n+// Other helpers:\n+export with_field_tys;\n+\n+// Destinations\n+\n+// These are passed around by the code generating functions to track the\n+// destination of a computation's value.\n+\n+fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n+\n+enum Dest {\n+    SaveIn(ValueRef),\n+    Ignore,\n+}\n+\n+impl Dest {\n+    fn to_str(ccx: @crate_ctxt) -> ~str {\n+        match self {\n+            SaveIn(v) => fmt!(\"SaveIn(%s)\", val_str(ccx.tn, v)),\n+            Ignore => ~\"Ignore\"\n+        }\n+    }\n+}\n+\n+impl Dest : cmp::Eq {\n+    pure fn eq(&&other: Dest) -> bool {\n+        match (self, other) {\n+            (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n+            (Ignore, Ignore) => true,\n+            (SaveIn(*), _) => false,\n+            (Ignore, _) => false,\n+        }\n+    }\n+}\n+\n+fn trans_to_appropriate_llval(bcx: block,\n+                              expr: @ast::expr) -> common::Result {\n+    let mut bcx = bcx;\n+    let datum = unpack_datum!(bcx, trans_to_datum(bcx, expr));\n+    debug!(\"trans_to_appropriate_llval(): datum=%s\", datum.to_str(bcx.ccx()));\n+    rslt(bcx, datum.to_appropriate_llval(bcx))\n+}\n+\n+fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n+    /*!\n+     *\n+     * Translates an expression into a datum.  If this expression\n+     * is an rvalue, this will result in a temporary value being\n+     * created.  If you already know where the result should be stored,\n+     * you should use `trans_into()` instead. */\n+\n+    let mut bcx = bcx;\n+\n+    debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n+    let _indenter = indenter();\n+\n+    debuginfo::update_source_pos(bcx, expr.span);\n+\n+    match ty::expr_kind(bcx.tcx(), bcx.ccx().maps.method_map, expr) {\n+        ty::LvalueExpr => {\n+            return trans_lvalue(bcx, expr);\n+        }\n+\n+        ty::RvalueDatumExpr => {\n+            let datum = unpack_datum!(bcx, trans_rvalue_datum(bcx, expr));\n+            datum.add_clean(bcx);\n+            return DatumBlock {bcx: bcx, datum: datum};\n+        }\n+\n+        ty::RvalueStmtExpr => {\n+            bcx = trans_rvalue_stmt(bcx, expr);\n+            return nil(bcx, expr_ty(bcx, expr));\n+        }\n+\n+        ty::RvalueDpsExpr => {\n+            let ty = expr_ty(bcx, expr);\n+            if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n+                bcx = trans_rvalue_dps(bcx, expr, Ignore);\n+                return nil(bcx, ty);\n+            } else {\n+                let scratch = scratch_datum(bcx, ty, false);\n+                bcx = trans_rvalue_dps(bcx, expr, SaveIn(scratch.val));\n+                scratch.add_clean(bcx);\n+                return DatumBlock {bcx: bcx, datum: scratch};\n+            }\n+        }\n+    }\n+\n+    fn nil(bcx: block, ty: ty::t) -> DatumBlock {\n+        let datum = immediate_rvalue(C_nil(), ty);\n+        DatumBlock {bcx: bcx, datum: datum}\n+    }\n+}\n+\n+fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n+    let ty = expr_ty(bcx, expr);\n+\n+    debug!(\"trans_into(expr=%s, dest=%s)\",\n+           bcx.expr_to_str(expr),\n+           dest.to_str(bcx.ccx()));\n+    let _indenter = indenter();\n+\n+    debuginfo::update_source_pos(bcx, expr.span);\n+\n+    let dest = {\n+        if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n+            Ignore\n+        } else {\n+            dest\n+        }\n+    };\n+\n+    let kind = bcx.expr_kind(expr);\n+    debug!(\"expr kind = %?\", kind);\n+    match kind {\n+        ty::LvalueExpr => {\n+            let datumblock = trans_lvalue(bcx, expr);\n+            match dest {\n+                Ignore => datumblock.bcx,\n+                SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n+            }\n+        }\n+        ty::RvalueDatumExpr => {\n+            let datumblock = trans_rvalue_datum(bcx, expr);\n+            match dest {\n+                Ignore => datumblock.drop_val(),\n+                SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n+            }\n+        }\n+        ty::RvalueDpsExpr => {\n+            return trans_rvalue_dps(bcx, expr, dest);\n+        }\n+        ty::RvalueStmtExpr => {\n+            return trans_rvalue_stmt(bcx, expr);\n+        }\n+    }\n+}\n+\n+fn trans_rvalue_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n+    let _icx = bcx.insn_ctxt(\"trans_rvalue_datum\");\n+\n+    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n+\n+    match expr.node {\n+        ast::expr_vstore(contents, ast::vstore_box) => {\n+            return tvec::trans_uniq_or_managed_vstore(bcx, heap_shared,\n+                                                      expr, contents);\n+        }\n+        ast::expr_vstore(contents, ast::vstore_uniq) => {\n+            return tvec::trans_uniq_or_managed_vstore(bcx, heap_exchange,\n+                                                      expr, contents);\n+        }\n+        ast::expr_lit(lit) => {\n+            return trans_immediate_lit(bcx, expr, *lit);\n+        }\n+        ast::expr_binary(op, lhs, rhs) => {\n+            // if overloaded, would be RvalueDpsExpr\n+            assert !bcx.ccx().maps.method_map.contains_key(expr.id);\n+\n+            return trans_binary(bcx, expr, op, lhs, rhs);\n+        }\n+        ast::expr_unary(op, x) => {\n+            return trans_unary_datum(bcx, expr, op, x);\n+        }\n+        ast::expr_addr_of(_, x) => {\n+            return trans_addr_of(bcx, expr, x);\n+        }\n+        ast::expr_cast(val, _) => {\n+            return trans_imm_cast(bcx, val, expr.id);\n+        }\n+        _ => {\n+            bcx.tcx().sess.span_bug(\n+                expr.span,\n+                fmt!(\"trans_rvalue_datum reached fall-through case: %?\",\n+                     expr.node));\n+        }\n+    }\n+}\n+\n+fn trans_rvalue_stmt(bcx: block, expr: @ast::expr) -> block {\n+    let mut bcx = bcx;\n+    let _icx = bcx.insn_ctxt(\"trans_rvalue_stmt\");\n+\n+    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n+\n+    match expr.node {\n+        ast::expr_break(label_opt) => {\n+            if label_opt.is_some() {\n+                bcx.tcx().sess.span_unimpl(expr.span, ~\"labeled break\");\n+            }\n+            return controlflow::trans_break(bcx);\n+        }\n+        ast::expr_again(label_opt) => {\n+            if label_opt.is_some() {\n+                bcx.tcx().sess.span_unimpl(expr.span, ~\"labeled again\");\n+            }\n+            return controlflow::trans_cont(bcx);\n+        }\n+        ast::expr_ret(ex) => {\n+            return controlflow::trans_ret(bcx, ex);\n+        }\n+        ast::expr_fail(why) => {\n+            return controlflow::trans_fail_expr(bcx, Some(expr.span), why);\n+        }\n+        ast::expr_log(_, lvl, a) => {\n+            return controlflow::trans_log(expr, lvl, bcx, a);\n+        }\n+        ast::expr_assert(a) => {\n+            return controlflow::trans_check_expr(bcx, expr, a, ~\"Assertion\");\n+        }\n+        ast::expr_while(cond, body) => {\n+            return controlflow::trans_while(bcx, cond, body);\n+        }\n+        ast::expr_loop(body, _) => {\n+            return controlflow::trans_loop(bcx, body);\n+        }\n+        ast::expr_assign(dst, src) => {\n+            let src_datum = unpack_datum!(bcx, trans_to_datum(bcx, src));\n+            let dst_datum = unpack_datum!(bcx, trans_lvalue(bcx, dst));\n+            return src_datum.store_to_datum(bcx, DROP_EXISTING, dst_datum);\n+        }\n+        ast::expr_move(dst, src) => {\n+            let src_datum = unpack_datum!(bcx, trans_to_datum(bcx, src));\n+            let dst_datum = unpack_datum!(bcx, trans_lvalue(bcx, dst));\n+            return src_datum.move_to_datum(bcx, DROP_EXISTING, dst_datum);\n+        }\n+        ast::expr_swap(dst, src) => {\n+            let dst_datum = unpack_datum!(bcx, trans_lvalue(bcx, dst));\n+            let src_datum = unpack_datum!(bcx, trans_lvalue(bcx, src));\n+            let scratch = scratch_datum(bcx, dst_datum.ty, false);\n+\n+            let bcx = dst_datum.move_to_datum(bcx, INIT, scratch);\n+            let bcx = src_datum.move_to_datum(bcx, INIT, dst_datum);\n+            return scratch.move_to_datum(bcx, INIT, src_datum);\n+        }\n+        ast::expr_assign_op(op, dst, src) => {\n+            return trans_assign_op(bcx, expr, op, dst, src);\n+        }\n+        _ => {\n+            bcx.tcx().sess.span_bug(\n+                expr.span,\n+                fmt!(\"trans_rvalue_stmt reached fall-through case: %?\",\n+                     expr.node));\n+        }\n+    };\n+}\n+\n+fn trans_rvalue_dps(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n+    let mut bcx = bcx;\n+    let _icx = bcx.insn_ctxt(\"trans_rvalue_dps\");\n+    let tcx = bcx.tcx();\n+\n+    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n+\n+    match expr.node {\n+        ast::expr_path(_) => {\n+            return trans_def_dps(bcx, expr, bcx.def(expr.id), dest);\n+        }\n+        ast::expr_if(cond, thn, els) => {\n+            return controlflow::trans_if(bcx, cond, thn, els, dest);\n+        }\n+        ast::expr_match(discr, arms) => {\n+            return alt::trans_alt(bcx, expr, discr, arms, dest);\n+        }\n+        ast::expr_block(blk) => {\n+            return do base::with_scope(bcx, blk.info(),\n+                                       ~\"block-expr body\") |bcx| {\n+                controlflow::trans_block(bcx, blk, dest)\n+            };\n+        }\n+        ast::expr_rec(fields, base) | ast::expr_struct(_, fields, base) => {\n+            return trans_rec_or_struct(bcx, fields, base, expr.id, dest);\n+        }\n+        ast::expr_tup(args) => {\n+            return trans_tup(bcx, args, dest);\n+        }\n+        ast::expr_lit(@{node: ast::lit_str(s), _}) => {\n+            return tvec::trans_lit_str(bcx, expr, s, dest);\n+        }\n+        ast::expr_vstore(contents, ast::vstore_slice(_)) => {\n+            return tvec::trans_slice_vstore(bcx, expr, contents, dest);\n+        }\n+        ast::expr_vstore(contents, ast::vstore_fixed(_)) => {\n+            return tvec::trans_fixed_vstore(bcx, expr, contents, dest);\n+        }\n+        ast::expr_vec(*) | ast::expr_repeat(*) => {\n+            return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n+        }\n+        ast::expr_fn(proto, decl, body, cap_clause) => {\n+            // Don't use this function for anything real. Use the one in\n+            // astconv instead.\n+            fn ast_proto_to_proto_simple(ast_proto: ast::proto)\n+                -> ty::fn_proto {\n+                match ast_proto {\n+                    ast::proto_bare => ty::proto_bare,\n+                    ast::proto_uniq => ty::proto_vstore(ty::vstore_uniq),\n+                    ast::proto_box => ty::proto_vstore(ty::vstore_box),\n+                    ast::proto_block => {\n+                        ty::proto_vstore(ty::vstore_slice(ty::re_static))\n+                    }\n+                }\n+            }\n+\n+            return closure::trans_expr_fn(bcx,\n+                                          ast_proto_to_proto_simple(proto),\n+                                          decl, body, expr.id, cap_clause,\n+                                          None, dest);\n+        }\n+        ast::expr_fn_block(decl, body, cap_clause) => {\n+            let expr_ty = expr_ty(bcx, expr);\n+            match ty::get(expr_ty).struct {\n+                ty::ty_fn({proto, _}) => {\n+                    debug!(\"translating fn_block %s with type %s\",\n+                           expr_to_str(expr, tcx.sess.intr()),\n+                           ty_to_str(tcx, expr_ty));\n+                    return closure::trans_expr_fn(bcx, proto, decl, body,\n+                                                  expr.id, cap_clause, None,\n+                                                  dest);\n+                }\n+                _ => {\n+                    bcx.sess().impossible_case(\n+                        expr.span, \"fn_block has body with a non-fn type\");\n+                }\n+            }\n+        }\n+        ast::expr_loop_body(blk) => {\n+            match ty::get(expr_ty(bcx, expr)).struct {\n+                ty::ty_fn({proto, _}) => {\n+                    match blk.node {\n+                        ast::expr_fn_block(decl, body, cap) => {\n+                            return closure::trans_expr_fn(\n+                                bcx, proto, decl, body, blk.id,\n+                                cap, Some(None), dest);\n+                        }\n+                        _ => {\n+                            bcx.sess().impossible_case(\n+                                expr.span,\n+                                \"loop_body has the wrong kind of contents\")\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    bcx.sess().impossible_case(\n+                        expr.span, \"loop_body has body with a non-fn type\")\n+                }\n+            }\n+        }\n+        ast::expr_do_body(blk) => {\n+            return trans_into(bcx, blk, dest);\n+        }\n+        ast::expr_copy(a) => {\n+            return trans_into(bcx, a, dest);\n+        }\n+        ast::expr_unary_move(a) => {\n+            if bcx.expr_is_lval(a) {\n+                let datum = unpack_datum!(bcx, trans_to_datum(bcx, a));\n+                return match dest {\n+                    Ignore => datum.drop_val(bcx),\n+                    SaveIn(addr) => datum.move_to(bcx, INIT, addr)\n+                };\n+            } else {\n+                return trans_into(bcx, a, dest);\n+            }\n+        }\n+        ast::expr_call(f, args, _) => {\n+            return callee::trans_call(\n+                bcx, expr, f, callee::ArgExprs(args), expr.id, dest);\n+        }\n+        ast::expr_binary(_, lhs, rhs) => {\n+            // if not overloaded, would be RvalueDatumExpr\n+            return trans_overloaded_op(bcx, expr, lhs, ~[rhs], dest);\n+        }\n+        ast::expr_unary(_, subexpr) => {\n+            // if not overloaded, would be RvalueDatumExpr\n+            return trans_overloaded_op(bcx, expr, subexpr, ~[], dest);\n+        }\n+        ast::expr_index(base, idx) => {\n+            // if not overloaded, would be RvalueDatumExpr\n+            return trans_overloaded_op(bcx, expr, base, ~[idx], dest);\n+        }\n+        ast::expr_cast(val, _) => {\n+            return impl::trans_trait_cast(bcx, val, expr.id, dest);\n+        }\n+        ast::expr_assign_op(op, dst, src) => {\n+            return trans_assign_op(bcx, expr, op, dst, src);\n+        }\n+        _ => {\n+            bcx.tcx().sess.span_bug(\n+                expr.span,\n+                fmt!(\"trans_rvalue_dps reached fall-through case: %?\",\n+                     expr.node));\n+        }\n+    }\n+}\n+\n+fn trans_def_dps(bcx: block, ref_expr: @ast::expr,\n+                 def: ast::def, dest: Dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_def_dps\");\n+    let ccx = bcx.ccx();\n+\n+    let lldest = match dest {\n+        SaveIn(lldest) => lldest,\n+        Ignore => { return bcx; }\n+    };\n+\n+    match def {\n+        ast::def_fn(did, _) => {\n+            let fn_data = callee::trans_fn_ref(bcx, did, ref_expr.id);\n+            return fn_data_to_datum(bcx, did, fn_data, lldest);\n+        }\n+        ast::def_static_method(did, _) => {\n+            let fn_data = impl::trans_static_method_callee(bcx, did,\n+                                                           ref_expr.id);\n+            return fn_data_to_datum(bcx, did, fn_data, lldest);\n+        }\n+        ast::def_variant(tid, vid) => {\n+            if ty::enum_variant_with_id(ccx.tcx, tid, vid).args.len() > 0u {\n+                // N-ary variant.\n+                let fn_data = callee::trans_fn_ref(bcx, vid, ref_expr.id);\n+                return fn_data_to_datum(bcx, vid, fn_data, lldest);\n+            } else {\n+                // Nullary variant.\n+                let lldiscrimptr = GEPi(bcx, lldest, [0u, 0u]);\n+                let lldiscrim_gv = base::lookup_discriminant(ccx, vid);\n+                let lldiscrim = Load(bcx, lldiscrim_gv);\n+                Store(bcx, lldiscrim, lldiscrimptr);\n+                return bcx;\n+            }\n+        }\n+        _ => {\n+            bcx.tcx().sess.span_bug(ref_expr.span, fmt!(\n+                \"Non-DPS def %? referened by %s\",\n+                def, bcx.node_id_to_str(ref_expr.id)));\n+        }\n+    }\n+}\n+\n+fn trans_lvalue(bcx: block, expr: @ast::expr) -> DatumBlock {\n+    //!\n+    //\n+    // Translates an lvalue expression, always yielding a by-ref\n+    // datum.  Generally speaking you should call trans_to_datum()\n+    // instead, but sometimes we call trans_lvalue() directly as a\n+    // means of asserting that a particular expression is an lvalue.\n+\n+    let _icx = bcx.insn_ctxt(\"trans_lval\");\n+    let mut bcx = bcx;\n+\n+    debug!(\"trans_lvalue(expr=%s)\", bcx.expr_to_str(expr));\n+    let _indenter = indenter();\n+\n+    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n+\n+    let unrooted_datum = unpack_datum!(bcx, unrooted(bcx, expr));\n+\n+    // If the lvalue must remain rooted, create a scratch datum, copy\n+    // the lvalue in there, and then arrange for it to be cleaned up\n+    // at the end of the scope with id `scope_id`:\n+    let root_key = {id:expr.id, derefs:0u};\n+    for bcx.ccx().maps.root_map.find(root_key).each |scope_id| {\n+        unrooted_datum.root(bcx, scope_id);\n+    }\n+\n+    return DatumBlock {bcx: bcx, datum: unrooted_datum};\n+\n+    fn unrooted(bcx: block, expr: @ast::expr) -> DatumBlock {\n+        let mut bcx = bcx;\n+\n+        match expr.node {\n+            ast::expr_path(_) => {\n+                return trans_def_lvalue(bcx, expr, bcx.def(expr.id));\n+            }\n+            ast::expr_field(base, ident, _) => {\n+                return trans_rec_field(bcx, base, ident);\n+            }\n+            ast::expr_index(base, idx) => {\n+                return trans_index(bcx, expr, base, idx);\n+            }\n+            ast::expr_unary(ast::deref, base) => {\n+                let basedatum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n+                let derefdatum = basedatum.deref(bcx, base, 0);\n+                return DatumBlock {bcx: bcx, datum: derefdatum};\n+            }\n+            _ => {\n+                bcx.tcx().sess.span_bug(\n+                    expr.span,\n+                    fmt!(\"trans_lvalue reached fall-through case: %?\",\n+                         expr.node));\n+            }\n+        }\n+    }\n+}\n+\n+fn trans_def_lvalue(bcx: block, ref_expr: @ast::expr,\n+                    def: ast::def) -> DatumBlock {\n+    let _icx = bcx.insn_ctxt(\"trans_def_lvalue\");\n+    let ccx = bcx.ccx();\n+    match def {\n+        ast::def_const(did) => {\n+            let const_ty = expr_ty(bcx, ref_expr);\n+            let val = if did.crate == ast::local_crate {\n+                base::get_item_val(ccx, did.node)\n+            } else {\n+                base::trans_external_path(ccx, did, const_ty)\n+            };\n+            DatumBlock {\n+                bcx: bcx,\n+                datum: Datum {val: val,\n+                              ty: const_ty,\n+                              mode: ByRef,\n+                              source: FromLvalue}\n+            }\n+        }\n+        _ => {\n+            DatumBlock {\n+                bcx: bcx,\n+                datum: trans_local_var(bcx, ref_expr.id, def)\n+            }\n+        }\n+    }\n+}\n+\n+fn trans_local_var(bcx: block, ref_id: ast::node_id, def: ast::def) -> Datum {\n+    let _icx = bcx.insn_ctxt(\"trans_local_var\");\n+\n+    return match def {\n+        ast::def_upvar(nid, _, _, _) => {\n+            let local_ty = node_id_type(bcx, nid);\n+            match bcx.fcx.llupvars.find(nid) {\n+                Some(val) => {\n+                    Datum {\n+                        val: val,\n+                        ty: local_ty,\n+                        mode: ByRef,\n+                        source: FromLvalue\n+                    }\n+                }\n+                None => {\n+                    bcx.sess().bug(fmt!(\n+                        \"trans_local_var: no llval for upvar %? found\", nid));\n+                }\n+            }\n+        }\n+        ast::def_arg(nid, _) => {\n+            take_local(bcx, ref_id, bcx.fcx.llargs, nid)\n+        }\n+        ast::def_local(nid, _) | ast::def_binding(nid, _) => {\n+            take_local(bcx, ref_id, bcx.fcx.lllocals, nid)\n+        }\n+        ast::def_self(nid) => {\n+            let self_info: ValSelfData = match bcx.fcx.llself {\n+                Some(ref self_info) => *self_info,\n+                None => {\n+                    bcx.sess().bug(fmt!(\n+                        \"trans_local_var: reference to self \\\n+                         out of context with id %?\", nid));\n+                }\n+            };\n+\n+            // This cast should not be necessary. We should cast self *once*,\n+            // but right now this conflicts with default methods.\n+            let llselfty = T_ptr(type_of::type_of(bcx.ccx(), self_info.t));\n+            let casted_val = PointerCast(bcx, self_info.v, llselfty);\n+            Datum {\n+                val: casted_val,\n+                ty: self_info.t,\n+                mode: ByRef,\n+                source: FromLvalue\n+            }\n+        }\n+        _ => {\n+            bcx.sess().unimpl(fmt!(\n+                \"unsupported def type in trans_local_var: %?\", def));\n+        }\n+    };\n+\n+    fn take_local(bcx: block,\n+                  ref_id: ast::node_id,\n+                  table: hashmap<ast::node_id, local_val>,\n+                  nid: ast::node_id) -> Datum {\n+        let is_last_use = match bcx.ccx().maps.last_use_map.find(ref_id) {\n+            None => false,\n+            Some(vars) => (*vars).contains(nid)\n+        };\n+\n+        let source = if is_last_use {FromLastUseLvalue} else {FromLvalue};\n+\n+        let (v, mode) = match table.find(nid) {\n+            Some(local_mem(v)) => (v, ByRef),\n+            Some(local_imm(v)) => (v, ByValue),\n+            None => {\n+                bcx.sess().bug(fmt!(\n+                    \"trans_local_var: no llval for local/arg %? found\", nid));\n+            }\n+        };\n+        let ty = node_id_type(bcx, nid);\n+\n+        debug!(\"take_local(nid=%?, last_use=%b, v=%s, mode=%?, ty=%s)\",\n+               nid, is_last_use, bcx.val_str(v), mode, bcx.ty_to_str(ty));\n+\n+        Datum { val: v, ty: ty, mode: mode, source: source }\n+    }\n+}\n+\n+fn fn_data_to_datum(bcx: block,\n+                    def_id: ast::def_id,\n+                    fn_data: callee::FnData,\n+                    lldest: ValueRef) -> block {\n+    //!\n+    //\n+    // Translates a reference to a top-level fn item into a rust\n+    // value.  This is generally a Rust closure pair: (fn ptr, env)\n+    // where the environment is NULL.  However, extern functions for\n+    // interfacing with C are represted as just the fn ptr with type\n+    // *u8.\n+    //\n+    // Strictly speaking, references to extern fns ought to be\n+    // RvalueDatumExprs, but it's not worth the complexity to avoid the\n+    // extra stack slot that LLVM probably optimizes away anyhow.\n+\n+    let fn_tpt = ty::lookup_item_type(bcx.tcx(), def_id);\n+    if ty::ty_fn_purity(fn_tpt.ty) == ast::extern_fn {\n+        let val = PointerCast(bcx, fn_data.llfn, T_ptr(T_i8()));\n+        Store(bcx, val, lldest);\n+        return bcx;\n+    }\n+\n+    let llfn = GEPi(bcx, lldest, [0u, abi::fn_field_code]);\n+    Store(bcx, fn_data.llfn, llfn);\n+    let llenv = GEPi(bcx, lldest, [0u, abi::fn_field_box]);\n+    Store(bcx, base::null_env_ptr(bcx), llenv);\n+    return bcx;\n+}\n+\n+fn with_field_tys<R>(tcx: ty::ctxt, ty: ty::t,\n+                     op: fn(bool, (&[ty::field])) -> R) -> R {\n+    match ty::get(ty).struct {\n+        ty::ty_rec(ref fields) => {\n+            op(false, *fields)\n+        }\n+\n+        ty::ty_class(did, ref substs) => {\n+            let has_dtor = ty::ty_dtor(tcx, did).is_some();\n+            op(has_dtor, class_items_as_mutable_fields(tcx, did, substs))\n+        }\n+\n+        _ => {\n+            tcx.sess.bug(fmt!(\n+                \"cannot get field types from the type %s\",\n+                ty_to_str(tcx, ty)));\n+        }\n+    }\n+}\n+\n+fn trans_rec_field(bcx: block,\n+                   base: @ast::expr,\n+                   field: ast::ident) -> DatumBlock {\n+    let mut bcx = bcx;\n+    let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n+\n+    // Translate and autoderef the base expression.  We should have a\n+    // record or a struct when we're done, both of which are currently\n+    // non-immediate and hence always tracked by reference.\n+    let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n+    let base_datum = base_datum.autoderef(bcx, base.id, uint::max_value);\n+\n+    do with_field_tys(bcx.tcx(), base_datum.ty) |_has_dtor, field_tys| {\n+        let ix = ty::field_idx_strict(bcx.tcx(), field, field_tys);\n+        DatumBlock {\n+            datum: base_datum.GEPi(bcx, [0u, 0u, ix], field_tys[ix].mt.ty),\n+            bcx: bcx\n+        }\n+    }\n+}\n+\n+fn trans_index(bcx: block,\n+               index_expr: @ast::expr,\n+               base: @ast::expr,\n+               idx: @ast::expr) -> DatumBlock {\n+    let _icx = bcx.insn_ctxt(\"trans_index\");\n+    let ccx = bcx.ccx();\n+    let base_ty = expr_ty(bcx, base);\n+    let mut bcx = bcx;\n+\n+    // Translate and autoderef the base expression.  We should have some sort\n+    // of vector (@[], &[], ~[], []/_, etc) when we're done.\n+    let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n+    let base_datum = base_datum.autoderef(bcx, base.id, uint::max_value);\n+\n+    // Translate index expression and cast to a suitable LLVM integer.\n+    // Rust is less strict than LLVM in this regard.\n+    let Result {bcx, val: ix_val} = trans_to_appropriate_llval(bcx, idx);\n+    let ix_size = shape::llsize_of_real(bcx.ccx(), val_ty(ix_val));\n+    let int_size = shape::llsize_of_real(bcx.ccx(), ccx.int_type);\n+    let ix_val = {\n+        if ix_size < int_size {\n+            if ty::type_is_signed(expr_ty(bcx, idx)) {\n+                SExt(bcx, ix_val, ccx.int_type)\n+            } else { ZExt(bcx, ix_val, ccx.int_type) }\n+        } else if ix_size > int_size {\n+            Trunc(bcx, ix_val, ccx.int_type)\n+        } else {\n+            ix_val\n+        }\n+    };\n+\n+    let vt = tvec::vec_types(bcx, base_datum.ty);\n+    base::maybe_name_value(bcx.ccx(), vt.llunit_size, ~\"unit_sz\");\n+    let scaled_ix = Mul(bcx, ix_val, vt.llunit_size);\n+    base::maybe_name_value(bcx.ccx(), scaled_ix, ~\"scaled_ix\");\n+\n+    let mut (base, len) = base_datum.get_base_and_len(bcx);\n+\n+    if ty::type_is_str(base_ty) {\n+        // acccount for null terminator in the case of string\n+        len = Sub(bcx, len, C_uint(bcx.ccx(), 1u));\n+    }\n+\n+    debug!(\"trans_index: base %s\", val_str(bcx.ccx().tn, base));\n+    debug!(\"trans_index: len %s\", val_str(bcx.ccx().tn, len));\n+\n+    let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n+    let bcx = do with_cond(bcx, bounds_check) |bcx| {\n+        controlflow::trans_fail(bcx, Some(index_expr.span), ~\"bounds check\")\n+    };\n+    let elt = InBoundsGEP(bcx, base, ~[ix_val]);\n+    let elt = PointerCast(bcx, elt, T_ptr(vt.llunit_ty));\n+    return DatumBlock {\n+        bcx: bcx,\n+        datum: Datum {val: elt, ty: vt.unit_ty,\n+                      mode: ByRef, source: FromLvalue}\n+    };\n+}\n+\n+fn trans_rec_or_struct(bcx: block,\n+                       fields: &[ast::field],\n+                       base: Option<@ast::expr>,\n+                       id: ast::node_id,\n+                       dest: Dest) -> block\n+{\n+    let _icx = bcx.insn_ctxt(\"trans_rec\");\n+    let mut bcx = bcx;\n+\n+    // Handle the case where the result is ignored.\n+    let addr;\n+    match dest {\n+        SaveIn(p) => {\n+            addr = p;\n+        }\n+        Ignore => {\n+            // just evaluate the values for each field and drop them\n+            // on the floor\n+            for vec::each(fields) |fld| {\n+                bcx = trans_into(bcx, fld.node.expr, Ignore);\n+            }\n+            return bcx;\n+        }\n+    }\n+\n+    let ty = node_id_type(bcx, id);\n+    let tcx = bcx.tcx();\n+    do with_field_tys(tcx, ty) |has_dtor, field_tys| {\n+        // evaluate each of the fields and store them into their\n+        // correct locations\n+        let mut temp_cleanups = ~[];\n+        for fields.each |field| {\n+            let ix = ty::field_idx_strict(tcx, field.node.ident, field_tys);\n+            let dest = GEPi(bcx, addr, struct_field(ix));\n+            bcx = trans_into(bcx, field.node.expr, SaveIn(dest));\n+            add_clean_temp_mem(bcx, dest, field_tys[ix].mt.ty);\n+            vec::push(temp_cleanups, dest);\n+        }\n+\n+        // copy over any remaining fields from the base (for\n+        // functional record update)\n+        for base.each |base_expr| {\n+            let base_datum = unpack_datum!(\n+                bcx, trans_to_datum(bcx, base_expr));\n+\n+            // Copy over inherited fields\n+            for field_tys.eachi |i, field_ty| {\n+                if !fields.any(|f| f.node.ident == field_ty.ident) {\n+                    let dest = GEPi(bcx, addr, struct_field(i));\n+                    let base_field =\n+                        base_datum.GEPi(bcx, struct_field(i), field_ty.mt.ty);\n+                    bcx = base_field.store_to(bcx, INIT, dest);\n+                }\n+            }\n+        }\n+\n+        // Add the drop flag if necessary.\n+        if has_dtor {\n+            let dest = GEPi(bcx, addr, struct_dtor());\n+            Store(bcx, C_u8(1), dest);\n+        }\n+\n+        // Now revoke the cleanups as we pass responsibility for the data\n+        // structure on to the caller\n+        for temp_cleanups.each |cleanup| { revoke_clean(bcx, cleanup); }\n+        bcx\n+    }\n+}\n+\n+fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: Dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_tup\");\n+    let mut bcx = bcx;\n+    let addr = match dest {\n+        Ignore => {\n+            for vec::each(elts) |ex| { bcx = trans_into(bcx, ex, Ignore); }\n+            return bcx;\n+        }\n+        SaveIn(pos) => pos,\n+    };\n+    let mut temp_cleanups = ~[];\n+    for vec::eachi(elts) |i, e| {\n+        let dest = GEPi(bcx, addr, [0u, i]);\n+        let e_ty = expr_ty(bcx, e);\n+        bcx = trans_into(bcx, e, SaveIn(dest));\n+        add_clean_temp_mem(bcx, dest, e_ty);\n+        vec::push(temp_cleanups, dest);\n+    }\n+    for vec::each(temp_cleanups) |cleanup| { revoke_clean(bcx, cleanup); }\n+    return bcx;\n+}\n+\n+fn trans_immediate_lit(bcx: block, expr: @ast::expr,\n+                       lit: ast::lit) -> DatumBlock {\n+    // must not be a string constant, that is a RvalueDpsExpr\n+    let _icx = bcx.insn_ctxt(\"trans_immediate_lit\");\n+    let ty = expr_ty(bcx, expr);\n+    immediate_rvalue_bcx(bcx, consts::const_lit(bcx.ccx(), expr, lit), ty)\n+}\n+\n+fn trans_unary_datum(bcx: block,\n+                     un_expr: @ast::expr,\n+                     op: ast::unop,\n+                     sub_expr: @ast::expr) -> DatumBlock {\n+\n+    let _icx = bcx.insn_ctxt(\"trans_unary_datum\");\n+\n+    // if deref, would be LvalueExpr\n+    assert op != ast::deref;\n+\n+    // if overloaded, would be RvalueDpsExpr\n+    assert !bcx.ccx().maps.method_map.contains_key(un_expr.id);\n+\n+    let un_ty = expr_ty(bcx, un_expr);\n+    let sub_ty = expr_ty(bcx, sub_expr);\n+\n+    return match op {\n+        ast::not => {\n+            let Result {bcx, val} = trans_to_appropriate_llval(bcx, sub_expr);\n+            immediate_rvalue_bcx(bcx, Not(bcx, val), un_ty)\n+        }\n+        ast::neg => {\n+            let Result {bcx, val} = trans_to_appropriate_llval(bcx, sub_expr);\n+            let llneg = {\n+                if ty::type_is_fp(un_ty) {\n+                    FNeg(bcx, val)\n+                } else {\n+                    Neg(bcx, val)\n+                }\n+            };\n+            immediate_rvalue_bcx(bcx, llneg, un_ty)\n+        }\n+        ast::box(_) => {\n+            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap_shared)\n+        }\n+        ast::uniq(_) => {\n+            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap_exchange)\n+        }\n+        ast::deref => {\n+            bcx.sess().bug(~\"deref expressions should have been \\\n+                             translated using trans_lvalue(), not \\\n+                             trans_unary_datum()\")\n+        }\n+    };\n+\n+    fn trans_boxed_expr(bcx: block,\n+                        box_ty: ty::t,\n+                        contents: @ast::expr,\n+                        contents_ty: ty::t,\n+                        heap: heap) -> DatumBlock {\n+        let _icx = bcx.insn_ctxt(\"trans_boxed_expr\");\n+        let {bcx, box, body} =\n+            base::malloc_general(bcx, contents_ty, heap);\n+        add_clean_free(bcx, box, heap);\n+        let bcx = trans_into(bcx, contents, SaveIn(body));\n+        revoke_clean(bcx, box);\n+        return immediate_rvalue_bcx(bcx, box, box_ty);\n+    }\n+}\n+\n+fn trans_addr_of(bcx: block, expr: @ast::expr,\n+                 subexpr: @ast::expr) -> DatumBlock {\n+    let _icx = bcx.insn_ctxt(\"trans_addr_of\");\n+    let mut bcx = bcx;\n+    let sub_datum = unpack_datum!(bcx, trans_to_datum(bcx, subexpr));\n+    let llval = sub_datum.to_ref_llval(bcx);\n+    return immediate_rvalue_bcx(bcx, llval, expr_ty(bcx, expr));\n+}\n+\n+// Important to get types for both lhs and rhs, because one might be _|_\n+// and the other not.\n+fn trans_eager_binop(bcx: block,\n+                     binop_expr: @ast::expr,\n+                     binop_ty: ty::t,\n+                     op: ast::binop,\n+                     lhs_datum: &Datum,\n+                     rhs_datum: &Datum) -> DatumBlock\n+{\n+    let mut bcx = bcx;\n+    let _icx = bcx.insn_ctxt(\"trans_eager_binop\");\n+\n+    let lhs = lhs_datum.to_appropriate_llval(bcx);\n+    let lhs_t = lhs_datum.ty;\n+\n+    let rhs = rhs_datum.to_appropriate_llval(bcx);\n+    let rhs_t = rhs_datum.ty;\n+\n+    let intype = {\n+        if ty::type_is_bot(lhs_t) { rhs_t }\n+        else { lhs_t }\n+    };\n+    let is_float = ty::type_is_fp(intype);\n+\n+    let rhs = base::cast_shift_expr_rhs(bcx, op, lhs, rhs);\n+\n+    let mut bcx = bcx;\n+    let val = match op {\n+      ast::add => {\n+        if is_float { FAdd(bcx, lhs, rhs) }\n+        else { Add(bcx, lhs, rhs) }\n+      }\n+      ast::subtract => {\n+        if is_float { FSub(bcx, lhs, rhs) }\n+        else { Sub(bcx, lhs, rhs) }\n+      }\n+      ast::mul => {\n+        if is_float { FMul(bcx, lhs, rhs) }\n+        else { Mul(bcx, lhs, rhs) }\n+      }\n+      ast::div => {\n+        if is_float {\n+            FDiv(bcx, lhs, rhs)\n+        } else {\n+            // Only zero-check integers; fp /0 is NaN\n+            bcx = base::fail_if_zero(bcx, binop_expr.span,\n+                                     op, rhs, rhs_t);\n+            if ty::type_is_signed(intype) {\n+                SDiv(bcx, lhs, rhs)\n+            } else {\n+                UDiv(bcx, lhs, rhs)\n+            }\n+        }\n+      }\n+      ast::rem => {\n+        if is_float {\n+            FRem(bcx, lhs, rhs)\n+        } else {\n+            // Only zero-check integers; fp %0 is NaN\n+            bcx = base::fail_if_zero(bcx, binop_expr.span,\n+                                     op, rhs, rhs_t);\n+            if ty::type_is_signed(intype) {\n+                SRem(bcx, lhs, rhs)\n+            } else {\n+                URem(bcx, lhs, rhs)\n+            }\n+        }\n+      }\n+      ast::bitor => Or(bcx, lhs, rhs),\n+      ast::bitand => And(bcx, lhs, rhs),\n+      ast::bitxor => Xor(bcx, lhs, rhs),\n+      ast::shl => Shl(bcx, lhs, rhs),\n+      ast::shr => {\n+        if ty::type_is_signed(intype) {\n+            AShr(bcx, lhs, rhs)\n+        } else { LShr(bcx, lhs, rhs) }\n+      }\n+      _ => {\n+        let cmpr = base::trans_compare(bcx, op,\n+                                       lhs, lhs_t,\n+                                       rhs, rhs_t);\n+        bcx = cmpr.bcx;\n+        cmpr.val\n+      }\n+    };\n+\n+    return immediate_rvalue_bcx(bcx, val, binop_ty);\n+}\n+\n+// refinement types would obviate the need for this\n+enum lazy_binop_ty { lazy_and, lazy_or }\n+\n+fn trans_lazy_binop(bcx: block,\n+                    binop_expr: @ast::expr,\n+                    op: lazy_binop_ty,\n+                    a: @ast::expr,\n+                    b: @ast::expr) -> DatumBlock\n+{\n+    let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n+    let binop_ty = expr_ty(bcx, binop_expr);\n+    let mut bcx = bcx;\n+\n+    let Result {bcx: past_lhs, val: lhs} = {\n+        do base::with_scope_result(bcx, a.info(), ~\"lhs\") |bcx| {\n+            trans_to_appropriate_llval(bcx, a)\n+        }\n+    };\n+\n+    if past_lhs.unreachable {\n+        return immediate_rvalue_bcx(past_lhs, lhs, binop_ty);\n+    }\n+\n+    let join = base::sub_block(bcx, ~\"join\");\n+    let before_rhs = base::sub_block(bcx, ~\"rhs\");\n+\n+    match op {\n+      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb),\n+      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb)\n+    }\n+    let Result {bcx: past_rhs, val: rhs} = {\n+        do base::with_scope_result(before_rhs, b.info(), ~\"rhs\") |bcx| {\n+            trans_to_appropriate_llval(bcx, b)\n+        }\n+    };\n+\n+    if past_rhs.unreachable {\n+        return immediate_rvalue_bcx(join, lhs, binop_ty);\n+    }\n+\n+    Br(past_rhs, join.llbb);\n+    let phi = Phi(join, T_bool(), ~[lhs, rhs], ~[past_lhs.llbb,\n+                                                 past_rhs.llbb]);\n+\n+    return immediate_rvalue_bcx(join, phi, binop_ty);\n+}\n+\n+fn trans_binary(bcx: block,\n+                binop_expr: @ast::expr,\n+                op: ast::binop,\n+                lhs: @ast::expr,\n+                rhs: @ast::expr) -> DatumBlock\n+{\n+    let _icx = bcx.insn_ctxt(\"trans_binary\");\n+\n+    match op {\n+        ast::and => {\n+            trans_lazy_binop(bcx, binop_expr, lazy_and, lhs, rhs)\n+        }\n+        ast::or => {\n+            trans_lazy_binop(bcx, binop_expr, lazy_or, lhs, rhs)\n+        }\n+        _ => {\n+            let mut bcx = bcx;\n+            let lhs_datum = unpack_datum!(bcx, trans_to_datum(bcx, lhs));\n+            let rhs_datum = unpack_datum!(bcx, trans_to_datum(bcx, rhs));\n+            let binop_ty = expr_ty(bcx, binop_expr);\n+            trans_eager_binop(bcx, binop_expr, binop_ty, op,\n+                              &lhs_datum, &rhs_datum)\n+        }\n+    }\n+}\n+\n+fn trans_overloaded_op(bcx: block,\n+                       expr: @ast::expr,\n+                       rcvr: @ast::expr,\n+                       +args: ~[@ast::expr],\n+                       dest: Dest) -> block\n+{\n+    let origin = bcx.ccx().maps.method_map.get(expr.id);\n+    let fty = node_id_type(bcx, expr.callee_id);\n+    return callee::trans_call_inner(\n+        bcx, expr.info(), fty,\n+        expr_ty(bcx, expr),\n+        |bcx| impl::trans_method_callee(bcx, expr.callee_id, rcvr, origin),\n+        callee::ArgExprs(args), dest);\n+}\n+\n+fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n+            llsrc: ValueRef, signed: bool) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"int_cast\");\n+    let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n+    let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n+    return if dstsz == srcsz {\n+        BitCast(bcx, llsrc, lldsttype)\n+    } else if srcsz > dstsz {\n+        TruncOrBitCast(bcx, llsrc, lldsttype)\n+    } else if signed {\n+        SExtOrBitCast(bcx, llsrc, lldsttype)\n+    } else { ZExtOrBitCast(bcx, llsrc, lldsttype) };\n+}\n+\n+fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n+              llsrc: ValueRef) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"float_cast\");\n+    let srcsz = lib::llvm::float_width(llsrctype);\n+    let dstsz = lib::llvm::float_width(lldsttype);\n+    return if dstsz > srcsz {\n+        FPExt(bcx, llsrc, lldsttype)\n+    } else if srcsz > dstsz {\n+        FPTrunc(bcx, llsrc, lldsttype)\n+    } else { llsrc };\n+}\n+\n+enum cast_kind {\n+    cast_pointer,\n+    cast_integral,\n+    cast_float,\n+    cast_enum,\n+    cast_other,\n+}\n+\n+impl cast_kind : cmp::Eq {\n+    pure fn eq(&&other: cast_kind) -> bool {\n+        match (self, other) {\n+            (cast_pointer, cast_pointer) => true,\n+            (cast_integral, cast_integral) => true,\n+            (cast_float, cast_float) => true,\n+            (cast_enum, cast_enum) => true,\n+            (cast_other, cast_other) => true,\n+            (cast_pointer, _) => false,\n+            (cast_integral, _) => false,\n+            (cast_float, _) => false,\n+            (cast_enum, _) => false,\n+            (cast_other, _) => false,\n+        }\n+    }\n+}\n+\n+fn cast_type_kind(t: ty::t) -> cast_kind {\n+    match ty::get(t).struct {\n+        ty::ty_float(*)   => cast_float,\n+        ty::ty_ptr(*)     => cast_pointer,\n+        ty::ty_rptr(*)    => cast_pointer,\n+        ty::ty_int(*)     => cast_integral,\n+        ty::ty_uint(*)    => cast_integral,\n+        ty::ty_bool       => cast_integral,\n+        ty::ty_enum(*)    => cast_enum,\n+        _                 => cast_other\n+    }\n+}\n+\n+fn trans_imm_cast(bcx: block, expr: @ast::expr,\n+                  id: ast::node_id) -> DatumBlock {\n+    let _icx = bcx.insn_ctxt(\"trans_cast\");\n+    let ccx = bcx.ccx();\n+\n+    let t_out = node_id_type(bcx, id);\n+\n+    let mut bcx = bcx;\n+    let llexpr = unpack_result!(bcx, trans_to_appropriate_llval(bcx, expr));\n+    let ll_t_in = val_ty(llexpr);\n+    let t_in = expr_ty(bcx, expr);\n+    let ll_t_out = type_of::type_of(ccx, t_out);\n+\n+    let k_in = cast_type_kind(t_in);\n+    let k_out = cast_type_kind(t_out);\n+    let s_in = k_in == cast_integral && ty::type_is_signed(t_in);\n+\n+    let newval =\n+        match {in: k_in, out: k_out} {\n+            {in: cast_integral, out: cast_integral} => {\n+                int_cast(bcx, ll_t_out, ll_t_in, llexpr, s_in)\n+            }\n+            {in: cast_float, out: cast_float} => {\n+                float_cast(bcx, ll_t_out, ll_t_in, llexpr)\n+            }\n+            {in: cast_integral, out: cast_float} => {\n+                if s_in {\n+                    SIToFP(bcx, llexpr, ll_t_out)\n+                } else { UIToFP(bcx, llexpr, ll_t_out) }\n+            }\n+            {in: cast_float, out: cast_integral} => {\n+                if ty::type_is_signed(t_out) {\n+                    FPToSI(bcx, llexpr, ll_t_out)\n+                } else { FPToUI(bcx, llexpr, ll_t_out) }\n+            }\n+            {in: cast_integral, out: cast_pointer} => {\n+                IntToPtr(bcx, llexpr, ll_t_out)\n+            }\n+            {in: cast_pointer, out: cast_integral} => {\n+                PtrToInt(bcx, llexpr, ll_t_out)\n+            }\n+            {in: cast_pointer, out: cast_pointer} => {\n+                PointerCast(bcx, llexpr, ll_t_out)\n+            }\n+            {in: cast_enum, out: cast_integral} |\n+            {in: cast_enum, out: cast_float} => {\n+                let bcx = bcx;\n+                let llenumty = T_opaque_enum_ptr(ccx);\n+                let av_enum = PointerCast(bcx, llexpr, llenumty);\n+                let lldiscrim_a_ptr = GEPi(bcx, av_enum, [0u, 0u]);\n+                let lldiscrim_a = Load(bcx, lldiscrim_a_ptr);\n+                match k_out {\n+                    cast_integral => int_cast(bcx, ll_t_out,\n+                                              val_ty(lldiscrim_a),\n+                                              lldiscrim_a, true),\n+                    cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n+                    _ => ccx.sess.bug(~\"translating unsupported cast.\")\n+                }\n+            }\n+            _ => ccx.sess.bug(~\"translating unsupported cast.\")\n+        };\n+    return immediate_rvalue_bcx(bcx, newval, t_out);\n+}\n+\n+fn trans_assign_op(bcx: block,\n+                   expr: @ast::expr,\n+                   op: ast::binop,\n+                   dst: @ast::expr,\n+                   src: @ast::expr) -> block\n+{\n+    let _icx = bcx.insn_ctxt(\"trans_assign_op\");\n+    let mut bcx = bcx;\n+\n+    debug!(\"trans_assign_op(expr=%s)\", bcx.expr_to_str(expr));\n+\n+    // Evaluate LHS (destination), which should be an lvalue\n+    let dst_datum = unpack_datum!(bcx, trans_lvalue(bcx, dst));\n+\n+    // A user-defined operator method\n+    if bcx.ccx().maps.method_map.find(expr.id).is_some() {\n+        // FIXME(#2582) evaluates the receiver twice!!\n+        let scratch = scratch_datum(bcx, dst_datum.ty, false);\n+        let bcx = trans_overloaded_op(bcx, expr, dst, ~[src],\n+                                      SaveIn(scratch.val));\n+        return scratch.move_to_datum(bcx, DROP_EXISTING, dst_datum);\n+    }\n+\n+    // Evaluate RHS (source)\n+    let src_datum = unpack_datum!(bcx, trans_to_datum(bcx, src));\n+\n+    // Perform computation and store the result\n+    let result_datum =\n+        unpack_datum!(bcx,\n+                      trans_eager_binop(\n+                          bcx, expr, dst_datum.ty, op,\n+                          &dst_datum, &src_datum));\n+    return result_datum.store_to_datum(bcx, DROP_EXISTING, dst_datum);\n+}\n+\n+fn shorten(+x: ~str) -> ~str {\n+    if x.len() > 60 { x.substr(0, 60) } else { x }\n+}\n\\ No newline at end of file"}, {"sha": "cd2be09517867c419c4d72edc34385dc77736bce", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 200, "deletions": 198, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -17,6 +17,9 @@ use base::*;\n use type_of::*;\n use std::map::hashmap;\n use util::ppaux::ty_to_str;\n+use datum::*;\n+use callee::*;\n+use expr::{Dest, Ignore};\n \n export link_name, trans_foreign_mod, register_foreign_fn, trans_foreign_fn,\n        trans_intrinsic;\n@@ -87,8 +90,8 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n             Double => 8,\n             Struct => {\n               do vec::foldl(0, struct_tys(ty)) |a, t| {\n-                    uint::max(a, ty_align(t))\n-                }\n+                  uint::max(a, ty_align(t))\n+              }\n             }\n             Array => {\n                 let elt = llvm::LLVMGetElementType(ty);\n@@ -785,210 +788,209 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n \n fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n                    path: ast_map::path, substs: param_substs,\n-                   ref_id: Option<ast::node_id>) {\n+                   ref_id: Option<ast::node_id>)\n+{\n+    debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n+\n     let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id,\n                                Some(substs), Some(item.span));\n     let mut bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n     match ccx.sess.str_of(item.ident) {\n-      ~\"atomic_xchg\" => {\n-        let old = AtomicRMW(bcx, Xchg,\n-                  get_param(decl, first_real_arg),\n-                  get_param(decl, first_real_arg + 1u),\n-                  SequentiallyConsistent);\n-        Store(bcx, old, fcx.llretptr);\n-      }\n-      ~\"atomic_xchg_acq\" => {\n-        let old = AtomicRMW(bcx, Xchg,\n-                  get_param(decl, first_real_arg),\n-                  get_param(decl, first_real_arg + 1u),\n-                  Acquire);\n-        Store(bcx, old, fcx.llretptr);\n-      }\n-      ~\"atomic_xchg_rel\" => {\n-        let old = AtomicRMW(bcx, Xchg,\n-                  get_param(decl, first_real_arg),\n-                  get_param(decl, first_real_arg + 1u),\n-                  Release);\n-        Store(bcx, old, fcx.llretptr);\n-      }\n-      ~\"atomic_xadd\" => {\n-        let old = AtomicRMW(bcx, lib::llvm::Add,\n-                  get_param(decl, first_real_arg),\n-                  get_param(decl, first_real_arg + 1u),\n-                  SequentiallyConsistent);\n-        Store(bcx, old, fcx.llretptr);\n-      }\n-      ~\"atomic_xadd_acq\" => {\n-        let old = AtomicRMW(bcx, lib::llvm::Add,\n-                  get_param(decl, first_real_arg),\n-                  get_param(decl, first_real_arg + 1u),\n-                  Acquire);\n-        Store(bcx, old, fcx.llretptr);\n-      }\n-      ~\"atomic_xadd_rel\" => {\n-        let old = AtomicRMW(bcx, lib::llvm::Add,\n-                  get_param(decl, first_real_arg),\n-                  get_param(decl, first_real_arg + 1u),\n-                  Release);\n-        Store(bcx, old, fcx.llretptr);\n-      }\n-      ~\"atomic_xsub\" => {\n-        let old = AtomicRMW(bcx, lib::llvm::Sub,\n-                  get_param(decl, first_real_arg),\n-                  get_param(decl, first_real_arg + 1u),\n-                  SequentiallyConsistent);\n-        Store(bcx, old, fcx.llretptr);\n-      }\n-      ~\"atomic_xsub_acq\" => {\n-        let old = AtomicRMW(bcx, lib::llvm::Sub,\n-                  get_param(decl, first_real_arg),\n-                  get_param(decl, first_real_arg + 1u),\n-                  Acquire);\n-        Store(bcx, old, fcx.llretptr);\n-      }\n-      ~\"atomic_xsub_rel\" => {\n-        let old = AtomicRMW(bcx, lib::llvm::Sub,\n-                  get_param(decl, first_real_arg),\n-                  get_param(decl, first_real_arg + 1u),\n-                  Release);\n-        Store(bcx, old, fcx.llretptr);\n-      }\n-      ~\"size_of\" => {\n-        let tp_ty = substs.tys[0];\n-        let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        Store(bcx, C_uint(ccx, shape::llsize_of_real(ccx, lltp_ty)),\n-              fcx.llretptr);\n-      }\n-      ~\"move_val\" => {\n-        let tp_ty = substs.tys[0];\n-        let src = {bcx: bcx,\n-                   val: get_param(decl, first_real_arg + 1u),\n-                   kind: lv_owned};\n-        bcx = move_val(bcx, DROP_EXISTING,\n-                       get_param(decl, first_real_arg),\n-                       src,\n-                       tp_ty);\n-      }\n-      ~\"move_val_init\" => {\n-        let tp_ty = substs.tys[0];\n-        let src = {bcx: bcx,\n-                   val: get_param(decl, first_real_arg + 1u),\n-                   kind: lv_owned};\n-        bcx = move_val(bcx, INIT,\n-                       get_param(decl, first_real_arg),\n-                       src,\n-                       tp_ty);\n-      }\n-      ~\"min_align_of\" => {\n-        let tp_ty = substs.tys[0];\n-        let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        Store(bcx, C_uint(ccx, shape::llalign_of_min(ccx, lltp_ty)),\n-              fcx.llretptr);\n-      }\n-      ~\"pref_align_of\"=> {\n-        let tp_ty = substs.tys[0];\n-        let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        Store(bcx, C_uint(ccx, shape::llalign_of_pref(ccx, lltp_ty)),\n-              fcx.llretptr);\n-      }\n-      ~\"get_tydesc\" => {\n-        let tp_ty = substs.tys[0];\n-        let static_ti = get_tydesc(ccx, tp_ty);\n-        lazily_emit_all_tydesc_glue(ccx, static_ti);\n-        // FIXME (#2712): change this to T_ptr(ccx.tydesc_ty) when the\n-        // core::sys copy of the get_tydesc interface dies off.\n-        let td = PointerCast(bcx, static_ti.tydesc, T_ptr(T_nil()));\n-        Store(bcx, td, fcx.llretptr);\n-      }\n-      ~\"init\" => {\n-        let tp_ty = substs.tys[0];\n-        let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        if !ty::type_is_nil(tp_ty) {\n-            Store(bcx, C_null(lltp_ty), fcx.llretptr);\n+        ~\"atomic_xchg\" => {\n+            let old = AtomicRMW(bcx, Xchg,\n+                                get_param(decl, first_real_arg),\n+                                get_param(decl, first_real_arg + 1u),\n+                                SequentiallyConsistent);\n+            Store(bcx, old, fcx.llretptr);\n         }\n-      }\n-      ~\"forget\" => {}\n-      ~\"reinterpret_cast\" => {\n-        let tp_ty = substs.tys[0];\n-        let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        let llout_ty = type_of::type_of(ccx, substs.tys[1]);\n-        let tp_sz = shape::llsize_of_real(ccx, lltp_ty),\n-            out_sz = shape::llsize_of_real(ccx, llout_ty);\n-        if tp_sz != out_sz {\n-            let sp = match ccx.tcx.items.get(option::get(ref_id)) {\n-              ast_map::node_expr(e) => e.span,\n-              _ => fail ~\"reinterpret_cast or forget has non-expr arg\"\n-            };\n-            ccx.sess.span_fatal(\n-                sp, fmt!(\"reinterpret_cast called on types \\\n-                          with different size: %s (%u) to %s (%u)\",\n-                         ty_to_str(ccx.tcx, tp_ty), tp_sz,\n-                         ty_to_str(ccx.tcx, substs.tys[1]), out_sz));\n+        ~\"atomic_xchg_acq\" => {\n+            let old = AtomicRMW(bcx, Xchg,\n+                                get_param(decl, first_real_arg),\n+                                get_param(decl, first_real_arg + 1u),\n+                                Acquire);\n+            Store(bcx, old, fcx.llretptr);\n         }\n-        if !ty::type_is_nil(substs.tys[1]) {\n-            // NB: Do not use a Load and Store here. This causes massive code\n-            // bloat when reinterpret_cast is used on large structural types.\n-            let llretptr = PointerCast(bcx, fcx.llretptr, T_ptr(T_i8()));\n-            let llcast = get_param(decl, first_real_arg);\n-            let llcast = PointerCast(bcx, llcast, T_ptr(T_i8()));\n-            call_memmove(bcx, llretptr, llcast, llsize_of(ccx, lltp_ty));\n+        ~\"atomic_xchg_rel\" => {\n+            let old = AtomicRMW(bcx, Xchg,\n+                                get_param(decl, first_real_arg),\n+                                get_param(decl, first_real_arg + 1u),\n+                                Release);\n+            Store(bcx, old, fcx.llretptr);\n         }\n+        ~\"atomic_xadd\" => {\n+            let old = AtomicRMW(bcx, lib::llvm::Add,\n+                                get_param(decl, first_real_arg),\n+                                get_param(decl, first_real_arg + 1u),\n+                                SequentiallyConsistent);\n+            Store(bcx, old, fcx.llretptr);\n+        }\n+        ~\"atomic_xadd_acq\" => {\n+            let old = AtomicRMW(bcx, lib::llvm::Add,\n+                                get_param(decl, first_real_arg),\n+                                get_param(decl, first_real_arg + 1u),\n+                                Acquire);\n+            Store(bcx, old, fcx.llretptr);\n+        }\n+        ~\"atomic_xadd_rel\" => {\n+            let old = AtomicRMW(bcx, lib::llvm::Add,\n+                                get_param(decl, first_real_arg),\n+                                get_param(decl, first_real_arg + 1u),\n+                                Release);\n+            Store(bcx, old, fcx.llretptr);\n+        }\n+        ~\"atomic_xsub\" => {\n+            let old = AtomicRMW(bcx, lib::llvm::Sub,\n+                                get_param(decl, first_real_arg),\n+                                get_param(decl, first_real_arg + 1u),\n+                                SequentiallyConsistent);\n+            Store(bcx, old, fcx.llretptr);\n+        }\n+        ~\"atomic_xsub_acq\" => {\n+            let old = AtomicRMW(bcx, lib::llvm::Sub,\n+                                get_param(decl, first_real_arg),\n+                                get_param(decl, first_real_arg + 1u),\n+                                Acquire);\n+            Store(bcx, old, fcx.llretptr);\n+        }\n+        ~\"atomic_xsub_rel\" => {\n+            let old = AtomicRMW(bcx, lib::llvm::Sub,\n+                                get_param(decl, first_real_arg),\n+                                get_param(decl, first_real_arg + 1u),\n+                                Release);\n+            Store(bcx, old, fcx.llretptr);\n+        }\n+        ~\"size_of\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            Store(bcx, C_uint(ccx, shape::llsize_of_real(ccx, lltp_ty)),\n+                  fcx.llretptr);\n+        }\n+        ~\"move_val\" => {\n+            let tp_ty = substs.tys[0];\n+            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n+                             ty: tp_ty, mode: ByRef, source: FromLvalue};\n+            bcx = src.move_to(bcx, DROP_EXISTING,\n+                              get_param(decl, first_real_arg));\n+        }\n+        ~\"move_val_init\" => {\n+            let tp_ty = substs.tys[0];\n+            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n+                             ty: tp_ty, mode: ByRef, source: FromLvalue};\n+            bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n+        }\n+        ~\"min_align_of\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            Store(bcx, C_uint(ccx, shape::llalign_of_min(ccx, lltp_ty)),\n+                  fcx.llretptr);\n+        }\n+        ~\"pref_align_of\"=> {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            Store(bcx, C_uint(ccx, shape::llalign_of_pref(ccx, lltp_ty)),\n+                  fcx.llretptr);\n+        }\n+        ~\"get_tydesc\" => {\n+            let tp_ty = substs.tys[0];\n+            let static_ti = get_tydesc(ccx, tp_ty);\n+            glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n+\n+            // FIXME (#2712): change this to T_ptr(ccx.tydesc_ty) when the\n+            // core::sys copy of the get_tydesc interface dies off.\n+            let td = PointerCast(bcx, static_ti.tydesc, T_ptr(T_nil()));\n+            Store(bcx, td, fcx.llretptr);\n+        }\n+        ~\"init\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            if !ty::type_is_nil(tp_ty) {\n+                Store(bcx, C_null(lltp_ty), fcx.llretptr);\n+            }\n+        }\n+        ~\"forget\" => {}\n+        ~\"reinterpret_cast\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let llout_ty = type_of::type_of(ccx, substs.tys[1]);\n+            let tp_sz = shape::llsize_of_real(ccx, lltp_ty),\n+            out_sz = shape::llsize_of_real(ccx, llout_ty);\n+          if tp_sz != out_sz {\n+              let sp = match ccx.tcx.items.get(option::get(ref_id)) {\n+                  ast_map::node_expr(e) => e.span,\n+                  _ => fail ~\"reinterpret_cast or forget has non-expr arg\"\n+              };\n+              ccx.sess.span_fatal(\n+                  sp, fmt!(\"reinterpret_cast called on types \\\n+                            with different size: %s (%u) to %s (%u)\",\n+                           ty_to_str(ccx.tcx, tp_ty), tp_sz,\n+                           ty_to_str(ccx.tcx, substs.tys[1]), out_sz));\n+          }\n+          if !ty::type_is_nil(substs.tys[1]) {\n+              // NB: Do not use a Load and Store here. This causes\n+              // massive code bloat when reinterpret_cast is used on\n+              // large structural types.\n+              let llretptr = PointerCast(bcx, fcx.llretptr, T_ptr(T_i8()));\n+              let llcast = get_param(decl, first_real_arg);\n+              let llcast = PointerCast(bcx, llcast, T_ptr(T_i8()));\n+              call_memmove(bcx, llretptr, llcast, llsize_of(ccx, lltp_ty));\n+          }\n       }\n-      ~\"addr_of\" => {\n-        Store(bcx, get_param(decl, first_real_arg), fcx.llretptr);\n-      }\n-      ~\"needs_drop\" => {\n-        let tp_ty = substs.tys[0];\n-        Store(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n-              fcx.llretptr);\n-      }\n-      ~\"visit_tydesc\" => {\n-        let td = get_param(decl, first_real_arg);\n-        let visitor = get_param(decl, first_real_arg + 1u);\n-        let td = PointerCast(bcx, td, T_ptr(ccx.tydesc_type));\n-        call_tydesc_glue_full(bcx, visitor, td,\n-                              abi::tydesc_field_visit_glue, None);\n-      }\n-      ~\"frame_address\" => {\n-        let frameaddress = ccx.intrinsics.get(~\"llvm.frameaddress\");\n-        let frameaddress_val = Call(bcx, frameaddress, ~[C_i32(0i32)]);\n-        let fty = ty::mk_fn(bcx.tcx(), {\n-            purity: ast::impure_fn,\n-            proto:\n-                ty::proto_vstore(ty::vstore_slice(\n-                    ty::re_bound(ty::br_anon(0)))),\n-            bounds: @~[],\n-            inputs: ~[{\n-                mode: ast::expl(ast::by_val),\n-                ty: ty::mk_imm_ptr(\n-                    bcx.tcx(),\n-                    ty::mk_mach_uint(bcx.tcx(), ast::ty_u8))\n-            }],\n-            output: ty::mk_nil(bcx.tcx()),\n-            ret_style: ast::return_val\n-        });\n-        bcx = trans_call_inner(bcx, None, fty, ty::mk_nil(bcx.tcx()),\n-                               |bcx| lval_no_env(\n-                                   bcx,\n-                                   get_param(decl, first_real_arg),\n-                                   lv_temporary),\n-                               arg_vals(~[frameaddress_val]), ignore);\n-      }\n-      ~\"morestack_addr\" => {\n-        // XXX This is a hack to grab the address of this particular\n-        // native function. There should be a general in-language\n-        // way to do this\n-        let llfty = type_of_fn(bcx.ccx(), ~[], ty::mk_nil(bcx.tcx()));\n-        let morestack_addr = decl_cdecl_fn(\n-            bcx.ccx().llmod, ~\"__morestack\", llfty);\n-        let morestack_addr = PointerCast(bcx, morestack_addr, T_ptr(T_nil()));\n-        Store(bcx, morestack_addr, fcx.llretptr);\n-      }\n-      _ => {\n-      // Could we make this an enum rather than a string? does it get\n-      // checked earlier?\n-          ccx.sess.span_bug(item.span, ~\"unknown intrinsic\");\n-      }\n+        ~\"addr_of\" => {\n+            Store(bcx, get_param(decl, first_real_arg), fcx.llretptr);\n+        }\n+        ~\"needs_drop\" => {\n+            let tp_ty = substs.tys[0];\n+            Store(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n+                  fcx.llretptr);\n+        }\n+        ~\"visit_tydesc\" => {\n+            let td = get_param(decl, first_real_arg);\n+            let visitor = get_param(decl, first_real_arg + 1u);\n+            let td = PointerCast(bcx, td, T_ptr(ccx.tydesc_type));\n+            glue::call_tydesc_glue_full(bcx, visitor, td,\n+                                        abi::tydesc_field_visit_glue, None);\n+        }\n+        ~\"frame_address\" => {\n+            let frameaddress = ccx.intrinsics.get(~\"llvm.frameaddress\");\n+            let frameaddress_val = Call(bcx, frameaddress, ~[C_i32(0i32)]);\n+            let fty = ty::mk_fn(bcx.tcx(), {\n+                purity: ast::impure_fn,\n+                proto:\n+                    ty::proto_vstore(ty::vstore_slice(\n+                        ty::re_bound(ty::br_anon(0)))),\n+                bounds: @~[],\n+                inputs: ~[{\n+                    mode: ast::expl(ast::by_val),\n+                    ty: ty::mk_imm_ptr(\n+                        bcx.tcx(),\n+                        ty::mk_mach_uint(bcx.tcx(), ast::ty_u8))\n+                }],\n+                output: ty::mk_nil(bcx.tcx()),\n+                ret_style: ast::return_val\n+            });\n+            let datum = Datum {val: get_param(decl, first_real_arg),\n+                               mode: ByRef, ty: fty, source: FromLvalue};\n+            bcx = trans_call_inner(\n+                bcx, None, fty, ty::mk_nil(bcx.tcx()),\n+                |bcx| Callee {bcx: bcx, data: Closure(datum)},\n+                ArgVals(~[frameaddress_val]), Ignore);\n+        }\n+        ~\"morestack_addr\" => {\n+            // XXX This is a hack to grab the address of this particular\n+            // native function. There should be a general in-language\n+            // way to do this\n+            let llfty = type_of_fn(bcx.ccx(), ~[], ty::mk_nil(bcx.tcx()));\n+            let morestack_addr = decl_cdecl_fn(\n+                bcx.ccx().llmod, ~\"__morestack\", llfty);\n+            let morestack_addr = PointerCast(bcx, morestack_addr,\n+                                             T_ptr(T_nil()));\n+            Store(bcx, morestack_addr, fcx.llretptr);\n+        }\n+        _ => {\n+            // Could we make this an enum rather than a string? does it get\n+            // checked earlier?\n+            ccx.sess.span_bug(item.span, ~\"unknown intrinsic\");\n+        }\n     }\n     build_return(bcx);\n     finish_fn(fcx, lltop);"}, {"sha": "3aee04755f086ce998af1ecc39f2c8deca51dcad", "filename": "src/rustc/middle/trans/glue.rs", "status": "added", "additions": 681, "deletions": 0, "changes": 681, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,681 @@\n+//!\n+//\n+// Code relating to taking, dropping, etc as well as type descriptors.\n+\n+use lib::llvm::{ValueRef, TypeRef};\n+use base::*;\n+use common::*;\n+use build::*;\n+use type_of::type_of;\n+\n+fn trans_free(cx: block, v: ValueRef) -> block {\n+    let _icx = cx.insn_ctxt(\"trans_free\");\n+    callee::trans_rtcall(cx, ~\"free\", ~[PointerCast(cx, v, T_ptr(T_i8()))],\n+                         expr::Ignore)\n+}\n+\n+fn trans_unique_free(cx: block, v: ValueRef) -> block {\n+    let _icx = cx.insn_ctxt(\"trans_unique_free\");\n+    callee::trans_rtcall(\n+        cx, ~\"exchange_free\", ~[PointerCast(cx, v, T_ptr(T_i8()))],\n+        expr::Ignore)\n+}\n+\n+fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+    // NB: v is an *alias* of type t here, not a direct value.\n+    let _icx = cx.insn_ctxt(\"take_ty\");\n+    if ty::type_needs_drop(cx.tcx(), t) {\n+        return call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n+    }\n+    return cx;\n+}\n+\n+fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+    // NB: v is an *alias* of type t here, not a direct value.\n+    let _icx = cx.insn_ctxt(\"drop_ty\");\n+    if ty::type_needs_drop(cx.tcx(), t) {\n+        return call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n+    }\n+    return cx;\n+}\n+\n+fn drop_ty_root(bcx: block, v: ValueRef, rooted: bool, t: ty::t) -> block {\n+    if rooted {\n+        // NB: v is a raw ptr to an addrspace'd ptr to the value.\n+        let v = PointerCast(bcx, Load(bcx, v), T_ptr(type_of(bcx.ccx(), t)));\n+        drop_ty(bcx, v, t)\n+    } else {\n+        drop_ty(bcx, v, t)\n+    }\n+}\n+\n+fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n+    let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n+    match ty::get(t).struct {\n+      ty::ty_uniq(_) |\n+      ty::ty_evec(_, ty::vstore_uniq) |\n+      ty::ty_estr(ty::vstore_uniq) => {\n+        free_ty_immediate(bcx, v, t)\n+      }\n+      ty::ty_box(_) | ty::ty_opaque_box |\n+      ty::ty_evec(_, ty::vstore_box) |\n+      ty::ty_estr(ty::vstore_box) => {\n+        decr_refcnt_maybe_free(bcx, v, t)\n+      }\n+      _ => bcx.tcx().sess.bug(~\"drop_ty_immediate: non-box ty\")\n+    }\n+}\n+\n+fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> Result {\n+    let _icx = bcx.insn_ctxt(\"take_ty_immediate\");\n+    match ty::get(t).struct {\n+      ty::ty_box(_) | ty::ty_opaque_box |\n+      ty::ty_evec(_, ty::vstore_box) |\n+      ty::ty_estr(ty::vstore_box) => {\n+        incr_refcnt_of_boxed(bcx, v);\n+        rslt(bcx, v)\n+      }\n+      ty::ty_uniq(_) => {\n+        uniq::duplicate(bcx, v, t)\n+      }\n+      ty::ty_evec(_, ty::vstore_uniq) |\n+      ty::ty_estr(ty::vstore_uniq) => {\n+        tvec::duplicate_uniq(bcx, v, t)\n+      }\n+      _ => rslt(bcx, v)\n+    }\n+}\n+\n+fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+    // NB: v is an *alias* of type t here, not a direct value.\n+    let _icx = cx.insn_ctxt(\"free_ty\");\n+    if ty::type_needs_drop(cx.tcx(), t) {\n+        return call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n+    }\n+    return cx;\n+}\n+\n+fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n+    let _icx = bcx.insn_ctxt(\"free_ty_immediate\");\n+    match ty::get(t).struct {\n+      ty::ty_uniq(_) |\n+      ty::ty_evec(_, ty::vstore_uniq) |\n+      ty::ty_estr(ty::vstore_uniq) |\n+      ty::ty_box(_) | ty::ty_opaque_box |\n+      ty::ty_evec(_, ty::vstore_box) |\n+      ty::ty_estr(ty::vstore_box) |\n+      ty::ty_opaque_closure_ptr(_) => {\n+        let vp = alloca_zeroed(bcx, type_of(bcx.ccx(), t));\n+        Store(bcx, v, vp);\n+        free_ty(bcx, vp, t)\n+      }\n+      _ => bcx.tcx().sess.bug(~\"free_ty_immediate: non-box ty\")\n+    }\n+}\n+\n+fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n+                               static_ti: @tydesc_info) {\n+    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n+    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n+    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, static_ti);\n+    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_visit_glue, static_ti);\n+}\n+\n+fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n+                           ti: @tydesc_info) {\n+    let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n+    let llfnty = type_of_glue_fn(ccx, ti.ty);\n+    if field == abi::tydesc_field_take_glue {\n+        match ti.take_glue {\n+          Some(_) => (),\n+          None => {\n+            debug!(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"take\");\n+            ti.take_glue = Some(glue_fn);\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_take_glue, ~\"take\");\n+            debug!(\"--- lazily_emit_tydesc_glue TAKE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+          }\n+        }\n+    } else if field == abi::tydesc_field_drop_glue {\n+        match ti.drop_glue {\n+          Some(_) => (),\n+          None => {\n+            debug!(\"+++ lazily_emit_tydesc_glue DROP %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"drop\");\n+            ti.drop_glue = Some(glue_fn);\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, ~\"drop\");\n+            debug!(\"--- lazily_emit_tydesc_glue DROP %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+          }\n+        }\n+    } else if field == abi::tydesc_field_free_glue {\n+        match ti.free_glue {\n+          Some(_) => (),\n+          None => {\n+            debug!(\"+++ lazily_emit_tydesc_glue FREE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"free\");\n+            ti.free_glue = Some(glue_fn);\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, ~\"free\");\n+            debug!(\"--- lazily_emit_tydesc_glue FREE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+          }\n+        }\n+    } else if field == abi::tydesc_field_visit_glue {\n+        match ti.visit_glue {\n+          Some(_) => (),\n+          None => {\n+            debug!(\"+++ lazily_emit_tydesc_glue VISIT %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"visit\");\n+            ti.visit_glue = Some(glue_fn);\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, ~\"visit\");\n+            debug!(\"--- lazily_emit_tydesc_glue VISIT %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+          }\n+        }\n+    }\n+}\n+\n+// See [Note-arg-mode]\n+fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n+                         field: uint, static_ti: Option<@tydesc_info>) {\n+    let _icx = bcx.insn_ctxt(\"call_tydesc_glue_full\");\n+    let ccx = bcx.ccx();\n+    // NB: Don't short-circuit even if this block is unreachable because\n+    // GC-based cleanup needs to the see that the roots are live.\n+    let no_lpads =\n+        ccx.sess.opts.debugging_opts & session::no_landing_pads != 0;\n+    if bcx.unreachable && !no_lpads { return; }\n+\n+    let static_glue_fn = match static_ti {\n+      None => None,\n+      Some(sti) => {\n+        lazily_emit_tydesc_glue(ccx, field, sti);\n+        if field == abi::tydesc_field_take_glue {\n+            sti.take_glue\n+        } else if field == abi::tydesc_field_drop_glue {\n+            sti.drop_glue\n+        } else if field == abi::tydesc_field_free_glue {\n+            sti.free_glue\n+        } else if field == abi::tydesc_field_visit_glue {\n+            sti.visit_glue\n+        } else {\n+            None\n+        }\n+      }\n+    };\n+\n+    // When available, use static type info to give glue the right type.\n+    let static_glue_fn = match static_ti {\n+      None => None,\n+      Some(sti) => {\n+        match static_glue_fn {\n+          None => None,\n+          Some(sgf) => Some(\n+              PointerCast(bcx, sgf, T_ptr(type_of_glue_fn(ccx, sti.ty))))\n+        }\n+      }\n+    };\n+\n+    // When static type info is available, avoid casting parameter because the\n+    // function already has the right type. Otherwise cast to generic pointer.\n+    let llrawptr = if is_none(static_ti) || is_none(static_glue_fn) {\n+        PointerCast(bcx, v, T_ptr(T_i8()))\n+    } else {\n+        v\n+    };\n+\n+    let llfn = {\n+        match static_glue_fn {\n+          None => {\n+            // Select out the glue function to call from the tydesc\n+            let llfnptr = GEPi(bcx, tydesc, [0u, field]);\n+            Load(bcx, llfnptr)\n+          }\n+          Some(sgf) => sgf\n+        }\n+    };\n+\n+    Call(bcx, llfn, ~[C_null(T_ptr(T_nil())), C_null(T_ptr(T_nil())),\n+                      C_null(T_ptr(T_ptr(bcx.ccx().tydesc_type))), llrawptr]);\n+}\n+\n+// See [Note-arg-mode]\n+fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n+    -> block {\n+    let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n+    let ti = get_tydesc(cx.ccx(), t);\n+    call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n+    return cx;\n+}\n+\n+fn call_cmp_glue(bcx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n+                 llop: ValueRef) -> ValueRef {\n+    // We can't use call_tydesc_glue_full() and friends here because compare\n+    // glue has a special signature.\n+    let _icx = bcx.insn_ctxt(\"call_cmp_glue\");\n+\n+    let lllhs = spill_if_immediate(bcx, lhs, t);\n+    let llrhs = spill_if_immediate(bcx, rhs, t);\n+\n+    let llrawlhsptr = BitCast(bcx, lllhs, T_ptr(T_i8()));\n+    let llrawrhsptr = BitCast(bcx, llrhs, T_ptr(T_i8()));\n+    let lltydesc = get_tydesc_simple(bcx.ccx(), t);\n+\n+    let llfn = bcx.ccx().upcalls.cmp_type;\n+\n+    let llcmpresultptr = alloca(bcx, T_i1());\n+    Call(bcx, llfn, ~[llcmpresultptr, lltydesc,\n+                      llrawlhsptr, llrawrhsptr, llop]);\n+    return Load(bcx, llcmpresultptr);\n+}\n+\n+fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n+    let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n+    let mut bcx = bcx;\n+    let ty_visitor_name = special_idents::ty_visitor;\n+    assert bcx.ccx().tcx.intrinsic_defs.contains_key(ty_visitor_name);\n+    let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(ty_visitor_name);\n+    let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n+    bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, trait_id);\n+    build_return(bcx);\n+}\n+\n+fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n+    // NB: v0 is an *alias* of type t here, not a direct value.\n+    let _icx = bcx.insn_ctxt(\"make_free_glue\");\n+    let ccx = bcx.ccx();\n+    let bcx = match ty::get(t).struct {\n+      ty::ty_box(body_mt) => {\n+        let v = Load(bcx, v);\n+        let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n+        // Cast away the addrspace of the box pointer.\n+        let body = PointerCast(bcx, body, T_ptr(type_of(ccx, body_mt.ty)));\n+        let bcx = drop_ty(bcx, body, body_mt.ty);\n+        trans_free(bcx, v)\n+      }\n+      ty::ty_opaque_box => {\n+        let v = Load(bcx, v);\n+        let td = Load(bcx, GEPi(bcx, v, [0u, abi::box_field_tydesc]));\n+        let valptr = GEPi(bcx, v, [0u, abi::box_field_body]);\n+        // Generate code that, dynamically, indexes into the\n+        // tydesc and calls the drop glue that got set dynamically\n+        call_tydesc_glue_full(bcx, valptr, td, abi::tydesc_field_drop_glue,\n+                              None);\n+        trans_free(bcx, v)\n+      }\n+      ty::ty_uniq(*) => {\n+        uniq::make_free_glue(bcx, v, t)\n+      }\n+      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n+      ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n+        make_free_glue(bcx, v,\n+                       tvec::expand_boxed_vec_ty(bcx.tcx(), t));\n+        return;\n+      }\n+      ty::ty_fn(_) => {\n+        closure::make_fn_glue(bcx, v, t, free_ty)\n+      }\n+      ty::ty_opaque_closure_ptr(ck) => {\n+        closure::make_opaque_cbox_free_glue(bcx, ck, v)\n+      }\n+      ty::ty_class(did, ref substs) => {\n+        // Call the dtor if there is one\n+        do option::map_default(ty::ty_dtor(bcx.tcx(), did), bcx) |dt_id| {\n+            trans_class_drop(bcx, v, dt_id, did, substs)\n+        }\n+      }\n+      _ => bcx\n+    };\n+    build_return(bcx);\n+}\n+\n+fn trans_class_drop(bcx: block,\n+                    v0: ValueRef,\n+                    dtor_did: ast::def_id,\n+                    class_did: ast::def_id,\n+                    substs: &ty::substs) -> block {\n+    let drop_flag = GEPi(bcx, v0, struct_dtor());\n+    do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n+        let mut bcx = cx;\n+\n+        // Find and call the actual destructor\n+        let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did,\n+                                     class_did, substs.tps);\n+\n+        // The second argument is the \"self\" argument for drop\n+        let params = lib::llvm::fn_ty_param_tys(\n+            llvm::LLVMGetElementType(llvm::LLVMTypeOf(dtor_addr)));\n+\n+        // Class dtors have no explicit args, so the params should\n+        // just consist of the output pointer and the environment\n+        // (self)\n+        assert(params.len() == 2u);\n+        let self_arg = PointerCast(bcx, v0, params[1u]);\n+        let args = ~[bcx.fcx.llretptr, self_arg];\n+        Call(bcx, dtor_addr, args);\n+\n+        // Drop the fields\n+        let field_tys =\n+            ty::class_items_as_mutable_fields(bcx.tcx(), class_did,\n+                                              substs);\n+        for vec::eachi(field_tys) |i, fld| {\n+            let llfld_a = GEPi(bcx, v0, struct_field(i));\n+            bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n+        }\n+\n+        Store(bcx, C_u8(0u), drop_flag);\n+        bcx\n+    }\n+}\n+\n+\n+fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n+    // NB: v0 is an *alias* of type t here, not a direct value.\n+    let _icx = bcx.insn_ctxt(\"make_drop_glue\");\n+    let ccx = bcx.ccx();\n+    let bcx = match ty::get(t).struct {\n+      ty::ty_box(_) | ty::ty_opaque_box |\n+      ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n+        decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n+      }\n+      ty::ty_uniq(_) |\n+      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n+        free_ty(bcx, v0, t)\n+      }\n+      ty::ty_unboxed_vec(_) => {\n+        tvec::make_drop_glue_unboxed(bcx, v0, t)\n+      }\n+      ty::ty_class(did, ref substs) => {\n+        let tcx = bcx.tcx();\n+        match ty::ty_dtor(tcx, did) {\n+          Some(dtor) => {\n+            trans_class_drop(bcx, v0, dtor, did, substs)\n+          }\n+          None => {\n+            // No dtor? Just the default case\n+            iter_structural_ty(bcx, v0, t, drop_ty)\n+          }\n+        }\n+      }\n+      ty::ty_fn(_) => {\n+        closure::make_fn_glue(bcx, v0, t, drop_ty)\n+      }\n+      ty::ty_trait(_, _, _) => {\n+        let llbox = Load(bcx, GEPi(bcx, v0, [0u, 1u]));\n+        decr_refcnt_maybe_free(bcx, llbox, ty::mk_opaque_box(ccx.tcx))\n+      }\n+      ty::ty_opaque_closure_ptr(ck) => {\n+        closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n+      }\n+      _ => {\n+        if ty::type_needs_drop(ccx.tcx, t) &&\n+            ty::type_is_structural(t) {\n+            iter_structural_ty(bcx, v0, t, drop_ty)\n+        } else { bcx }\n+      }\n+    };\n+    build_return(bcx);\n+}\n+\n+fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n+    let _icx = bcx.insn_ctxt(\"decr_refcnt_maybe_free\");\n+    let ccx = bcx.ccx();\n+\n+    do with_cond(bcx, IsNotNull(bcx, box_ptr)) |bcx| {\n+        let rc_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_refcnt]);\n+        let rc = Sub(bcx, Load(bcx, rc_ptr), C_int(ccx, 1));\n+        Store(bcx, rc, rc_ptr);\n+        let zero_test = ICmp(bcx, lib::llvm::IntEQ, C_int(ccx, 0), rc);\n+        with_cond(bcx, zero_test, |bcx| free_ty_immediate(bcx, box_ptr, t))\n+    }\n+}\n+\n+\n+fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n+    let _icx = bcx.insn_ctxt(\"make_take_glue\");\n+    // NB: v is a *pointer* to type t here, not a direct value.\n+    let bcx = match ty::get(t).struct {\n+      ty::ty_box(_) | ty::ty_opaque_box |\n+      ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n+        incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n+      }\n+      ty::ty_uniq(_) => {\n+        let Result {bcx, val} = uniq::duplicate(bcx, Load(bcx, v), t);\n+        Store(bcx, val, v);\n+        bcx\n+      }\n+      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n+        let Result {bcx, val} = tvec::duplicate_uniq(bcx, Load(bcx, v), t);\n+        Store(bcx, val, v);\n+        bcx\n+      }\n+      ty::ty_evec(_, ty::vstore_slice(_))\n+      | ty::ty_estr(ty::vstore_slice(_)) => {\n+        bcx\n+      }\n+      ty::ty_fn(_) => {\n+        closure::make_fn_glue(bcx, v, t, take_ty)\n+      }\n+      ty::ty_trait(_, _, _) => {\n+        let llbox = Load(bcx, GEPi(bcx, v, [0u, 1u]));\n+        incr_refcnt_of_boxed(bcx, llbox);\n+        bcx\n+      }\n+      ty::ty_opaque_closure_ptr(ck) => {\n+        closure::make_opaque_cbox_take_glue(bcx, ck, v)\n+      }\n+      _ if ty::type_is_structural(t) => {\n+        iter_structural_ty(bcx, v, t, take_ty)\n+      }\n+      _ => bcx\n+    };\n+\n+    build_return(bcx);\n+}\n+\n+fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n+    let _icx = cx.insn_ctxt(\"incr_refcnt_of_boxed\");\n+    let ccx = cx.ccx();\n+    let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n+    let rc = Load(cx, rc_ptr);\n+    let rc = Add(cx, rc, C_int(ccx, 1));\n+    Store(cx, rc, rc_ptr);\n+}\n+\n+\n+// Chooses the addrspace for newly declared types.\n+fn declare_tydesc_addrspace(ccx: @crate_ctxt, t: ty::t) -> addrspace {\n+    if !ty::type_needs_drop(ccx.tcx, t) {\n+        return default_addrspace;\n+    } else if ty::type_is_immediate(t) {\n+        // For immediate types, we don't actually need an addrspace, because\n+        // e.g. boxed types include pointers to their contents which are\n+        // already correctly tagged with addrspaces.\n+        return default_addrspace;\n+    } else {\n+        return ccx.next_addrspace();\n+    }\n+}\n+\n+// Generates the declaration for (but doesn't emit) a type descriptor.\n+fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n+    let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n+    // If emit_tydescs already ran, then we shouldn't be creating any new\n+    // tydescs.\n+    assert !ccx.finished_tydescs;\n+\n+    let llty = type_of(ccx, t);\n+\n+    if ccx.sess.count_type_sizes() {\n+        io::println(fmt!(\"%u\\t%s\",\n+                         llsize_of_real(ccx, llty),\n+                         ty_to_str(ccx.tcx, t)));\n+    }\n+\n+    let llsize = llsize_of(ccx, llty);\n+    let llalign = llalign_of(ccx, llty);\n+    let addrspace = declare_tydesc_addrspace(ccx, t);\n+    //XXX this triggers duplicate LLVM symbols\n+    let name = if false /*ccx.sess.opts.debuginfo*/ {\n+        mangle_internal_name_by_type_only(ccx, t, ~\"tydesc\")\n+    } else { mangle_internal_name_by_seq(ccx, ~\"tydesc\") };\n+    note_unique_llvm_symbol(ccx, name);\n+    log(debug, fmt!(\"+++ declare_tydesc %s %s\", ty_to_str(ccx.tcx, t), name));\n+    let gvar = str::as_c_str(name, |buf| {\n+        llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n+    });\n+    let inf =\n+        @{ty: t,\n+          tydesc: gvar,\n+          size: llsize,\n+          align: llalign,\n+          addrspace: addrspace,\n+          mut take_glue: None,\n+          mut drop_glue: None,\n+          mut free_glue: None,\n+          mut visit_glue: None};\n+    log(debug, ~\"--- declare_tydesc \" + ppaux::ty_to_str(ccx.tcx, t));\n+    return inf;\n+}\n+\n+type glue_helper = fn@(block, ValueRef, ty::t);\n+\n+fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n+                        name: ~str) -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n+    let name = name;\n+    let mut fn_nm;\n+    //XXX this triggers duplicate LLVM symbols\n+    if false /*ccx.sess.opts.debuginfo*/ {\n+        fn_nm = mangle_internal_name_by_type_only(ccx, t, (~\"glue_\" + name));\n+    } else {\n+        fn_nm = mangle_internal_name_by_seq(ccx, (~\"glue_\" + name));\n+    }\n+    note_unique_llvm_symbol(ccx, fn_nm);\n+    let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n+    set_glue_inlining(llfn, t);\n+    return llfn;\n+}\n+\n+fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n+                           llfn: ValueRef, helper: glue_helper) -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n+    let fcx = new_fn_ctxt(ccx, ~[], llfn, None);\n+    lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n+    ccx.stats.n_glues_created += 1u;\n+    // All glue functions take values passed *by alias*; this is a\n+    // requirement since in many contexts glue is invoked indirectly and\n+    // the caller has no idea if it's dealing with something that can be\n+    // passed by value.\n+    //\n+    // llfn is expected be declared to take a parameter of the appropriate\n+    // type, so we don't need to explicitly cast the function parameter.\n+\n+    let bcx = top_scope_block(fcx, None);\n+    let lltop = bcx.llbb;\n+    let llrawptr0 = llvm::LLVMGetParam(llfn, 3u as c_uint);\n+    helper(bcx, llrawptr0, t);\n+    finish_fn(fcx, lltop);\n+    return llfn;\n+}\n+\n+fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n+                     helper: glue_helper, name: ~str)\n+    -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"make_generic_glue\");\n+    if !ccx.sess.trans_stats() {\n+        return make_generic_glue_inner(ccx, t, llfn, helper);\n+    }\n+\n+    let start = time::get_time();\n+    let llval = make_generic_glue_inner(ccx, t, llfn, helper);\n+    let end = time::get_time();\n+    log_fn_time(ccx, ~\"glue \" + name + ~\" \" + ty_to_short_str(ccx.tcx, t),\n+                start, end);\n+    return llval;\n+}\n+\n+fn emit_tydescs(ccx: @crate_ctxt) {\n+    let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n+    // As of this point, allow no more tydescs to be created.\n+    ccx.finished_tydescs = true;\n+    for ccx.tydescs.each |key, val| {\n+        let glue_fn_ty = T_ptr(T_generic_glue_fn(ccx));\n+        let ti = val;\n+\n+        // Each of the glue functions needs to be cast to a generic type\n+        // before being put into the tydesc because we only have a singleton\n+        // tydesc type. Then we'll recast each function to its real type when\n+        // calling it.\n+        let take_glue =\n+            match copy ti.take_glue {\n+              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+              Some(v) => {\n+                ccx.stats.n_real_glues += 1u;\n+                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+              }\n+            };\n+        let drop_glue =\n+            match copy ti.drop_glue {\n+              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+              Some(v) => {\n+                ccx.stats.n_real_glues += 1u;\n+                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+              }\n+            };\n+        let free_glue =\n+            match copy ti.free_glue {\n+              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+              Some(v) => {\n+                ccx.stats.n_real_glues += 1u;\n+                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+              }\n+            };\n+        let visit_glue =\n+            match copy ti.visit_glue {\n+              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+              Some(v) => {\n+                ccx.stats.n_real_glues += 1u;\n+                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+              }\n+            };\n+\n+        let shape = shape_of(ccx, key);\n+        let shape_tables =\n+            llvm::LLVMConstPointerCast(ccx.shape_cx.llshapetables,\n+                                       T_ptr(T_i8()));\n+\n+        let tydesc =\n+            C_named_struct(ccx.tydesc_type,\n+                           ~[ti.size, // size\n+                             ti.align, // align\n+                             take_glue, // take_glue\n+                             drop_glue, // drop_glue\n+                             free_glue, // free_glue\n+                             visit_glue, // visit_glue\n+                             C_shape(ccx, shape), // shape\n+                             shape_tables]); // shape_tables\n+\n+        let gvar = ti.tydesc;\n+        llvm::LLVMSetInitializer(gvar, tydesc);\n+        llvm::LLVMSetGlobalConstant(gvar, True);\n+        lib::llvm::SetLinkage(gvar, lib::llvm::InternalLinkage);\n+\n+        // Index tydesc by addrspace.\n+        if ti.addrspace > gc_box_addrspace {\n+            let llty = T_ptr(ccx.tydesc_type);\n+            let addrspace_name = #fmt(\"_gc_addrspace_metadata_%u\",\n+                                      ti.addrspace as uint);\n+            let addrspace_gvar = str::as_c_str(addrspace_name, |buf| {\n+                llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n+            });\n+            lib::llvm::SetLinkage(addrspace_gvar, lib::llvm::InternalLinkage);\n+            llvm::LLVMSetInitializer(addrspace_gvar, gvar);\n+        }\n+    };\n+}"}, {"sha": "ae128a10f7cb3ccafb6a01415c22b5de613f8177", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 228, "deletions": 128, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -3,10 +3,9 @@ use base::*;\n use common::*;\n use type_of::*;\n use build::*;\n-use driver::session::session;\n+use driver::session::{session, expect};\n use syntax::{ast, ast_map};\n use ast_map::{path, path_mod, path_name, node_id_to_str};\n-use driver::session::expect;\n use syntax::ast_util::local_def;\n use metadata::csearch;\n use back::{link, abi};\n@@ -15,8 +14,11 @@ use lib::llvm::{ValueRef, TypeRef};\n use lib::llvm::llvm::LLVMGetParam;\n use std::map::hashmap;\n use util::ppaux::{ty_to_str, tys_to_str};\n-\n+use callee::*;\n use syntax::print::pprust::expr_to_str;\n+use expr::{SaveIn, Ignore};\n+\n+fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n \n /**\n The main \"translation\" pass for methods.  Generates code\n@@ -91,14 +93,13 @@ fn trans_method(ccx: @crate_ctxt,\n }\n \n fn trans_self_arg(bcx: block, base: @ast::expr,\n-                  mentry: typeck::method_map_entry) -> result {\n+                  mentry: typeck::method_map_entry) -> Result {\n     let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n     let basety = expr_ty(bcx, base);\n     let mode = ast::expl(mentry.self_mode);\n     let mut temp_cleanups = ~[];\n-    let result = trans_arg_expr(bcx, {mode: mode, ty: basety},\n-                                T_ptr(type_of::type_of(bcx.ccx(), basety)),\n-                                base, temp_cleanups, None, mentry.derefs);\n+    let result = trans_arg_expr(bcx, {mode: mode, ty: basety}, base,\n+                                &mut temp_cleanups, None, mentry.derefs);\n \n     // by-ref self argument should not require cleanup in the case of\n     // other arguments failing:\n@@ -112,57 +113,61 @@ fn trans_self_arg(bcx: block, base: @ast::expr,\n \n fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n                        self: @ast::expr, mentry: typeck::method_map_entry)\n-    -> lval_maybe_callee {\n+    -> Callee\n+{\n     let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n     match mentry.origin {\n-      typeck::method_static(did) => {\n-\n-\n-        let {bcx, val} = trans_self_arg(bcx, self, mentry);\n-        {env: self_env(val, node_id_type(bcx, self.id), None,\n-                       mentry.self_mode),\n-         .. lval_static_fn(bcx, did, callee_id)}\n-      }\n-      typeck::method_param({trait_id:trait_id, method_num:off,\n-                            param_num:p, bound_num:b}) => {\n-        match bcx.fcx.param_substs {\n-          Some(substs) => {\n-            let vtbl = find_vtable_in_fn_ctxt(substs, p, b);\n-            trans_monomorphized_callee(bcx, callee_id, self, mentry,\n-                                       trait_id, off, vtbl)\n-          }\n-          // how to get rid of this?\n-          None => fail ~\"trans_method_callee: missing param_substs\"\n+        typeck::method_static(did) => {\n+            let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n+            let Result {bcx, val} = trans_self_arg(bcx, self, mentry);\n+\n+            Callee {\n+                bcx: bcx,\n+                data: Method(MethodData {\n+                    llfn: callee_fn.llfn,\n+                    llself: val,\n+                    self_ty: node_id_type(bcx, self.id),\n+                    self_mode: mentry.self_mode\n+                })\n+            }\n+        }\n+        typeck::method_param({trait_id:trait_id, method_num:off,\n+                              param_num:p, bound_num:b}) => {\n+            match bcx.fcx.param_substs {\n+                Some(substs) => {\n+                    let vtbl = find_vtable_in_fn_ctxt(substs, p, b);\n+                    trans_monomorphized_callee(bcx, callee_id, self, mentry,\n+                                               trait_id, off, vtbl)\n+                }\n+                // how to get rid of this?\n+                None => fail ~\"trans_method_callee: missing param_substs\"\n+            }\n+        }\n+        typeck::method_trait(_, off) => {\n+            trans_trait_callee(bcx, callee_id, off, self, mentry.derefs)\n         }\n-      }\n-      typeck::method_trait(_, off) => {\n-        let {bcx, val} = trans_temp_expr(bcx, self);\n-        let fty = node_id_type(bcx, callee_id);\n-        let self_ty = node_id_type(bcx, self.id);\n-        let {bcx, val, _} = autoderef(bcx, self.id, val, self_ty,\n-                                      uint::max_value);\n-        trans_trait_callee(bcx, val, fty, off)\n-      }\n     }\n }\n \n-fn trans_static_method_callee(bcx: block, method_id: ast::def_id,\n-                              callee_id: ast::node_id) -> lval_maybe_callee {\n+fn trans_static_method_callee(bcx: block,\n+                              method_id: ast::def_id,\n+                              callee_id: ast::node_id) -> FnData\n+{\n     let _icx = bcx.insn_ctxt(\"impl::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n     let mname = if method_id.crate == ast::local_crate {\n         match bcx.tcx().items.get(method_id.node) {\n-          ast_map::node_trait_method(trait_method, _, _) => {\n-            ast_util::trait_method_to_ty_method(*trait_method).ident\n-          }\n-          _ => fail ~\"callee is not a trait method\"\n+            ast_map::node_trait_method(trait_method, _, _) => {\n+                ast_util::trait_method_to_ty_method(*trait_method).ident\n+            }\n+            _ => fail ~\"callee is not a trait method\"\n         }\n     } else {\n         let path = csearch::get_item_path(bcx.tcx(), method_id);\n         match path[path.len()-1] {\n-          path_name(s) => { s }\n-          path_mod(_) => { fail ~\"path doesn't have a name?\" }\n+            path_name(s) => { s }\n+            path_mod(_) => { fail ~\"path doesn't have a name?\" }\n         }\n     };\n     debug!(\"trans_static_method_callee: method_id=%?, callee_id=%?, \\\n@@ -172,26 +177,28 @@ fn trans_static_method_callee(bcx: block, method_id: ast::def_id,\n         bcx.fcx, ccx.maps.vtable_map.get(callee_id));\n \n     match vtbls[0] { // is index 0 always the one we want?\n-      typeck::vtable_static(impl_did, impl_substs, sub_origins) => {\n-\n-        let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n-        let n_m_tps = method_ty_param_count(ccx, mth_id, impl_did);\n-        let node_substs = node_id_type_params(bcx, callee_id);\n-        let ty_substs\n-            = vec::append(impl_substs,\n-                          vec::tailn(node_substs,\n-                                     node_substs.len() - n_m_tps));\n-\n-        let lval = lval_static_fn_inner(bcx, mth_id, callee_id, ty_substs,\n-                                        Some(sub_origins));\n-        {env: null_env,\n-         val: PointerCast(bcx, lval.val, T_ptr(type_of_fn_from_ty(\n-             ccx, node_id_type(bcx, callee_id)))),\n-         .. lval}\n-      }\n-      _ => {\n-        fail ~\"vtable_param left in monomorphized function's vtable substs\";\n-      }\n+        typeck::vtable_static(impl_did, impl_substs, sub_origins) => {\n+\n+            let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n+            let n_m_tps = method_ty_param_count(ccx, mth_id, impl_did);\n+            let node_substs = node_id_type_params(bcx, callee_id);\n+            let ty_substs\n+                = vec::append(impl_substs,\n+                              vec::tailn(node_substs,\n+                                         node_substs.len() - n_m_tps));\n+\n+            let FnData {llfn: lval} =\n+                trans_fn_ref_with_vtables(bcx, mth_id, callee_id,\n+                                          ty_substs, Some(sub_origins));\n+\n+            let callee_ty = node_id_type(bcx, callee_id);\n+            let llty = T_ptr(type_of_fn_from_ty(ccx, callee_ty));\n+            FnData {llfn: PointerCast(bcx, lval, llty)}\n+        }\n+        _ => {\n+            fail ~\"vtable_param left in monomorphized \\\n+                   function's vtable substs\";\n+        }\n     }\n }\n \n@@ -231,67 +238,138 @@ fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n     }\n }\n \n-fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n+fn trans_monomorphized_callee(bcx: block,\n+                              callee_id: ast::node_id,\n                               base: @ast::expr,\n                               mentry: typeck::method_map_entry,\n-                              trait_id: ast::def_id, n_method: uint,\n+                              trait_id: ast::def_id,\n+                              n_method: uint,\n                               vtbl: typeck::vtable_origin)\n-    -> lval_maybe_callee {\n+    -> Callee\n+{\n     let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     match vtbl {\n       typeck::vtable_static(impl_did, impl_substs, sub_origins) => {\n-        let ccx = bcx.ccx();\n-        let mname = ty::trait_methods(ccx.tcx, trait_id)[n_method].ident;\n-        let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n-        let n_m_tps = method_ty_param_count(ccx, mth_id, impl_did);\n-        let node_substs = node_id_type_params(bcx, callee_id);\n-        let ty_substs\n-            = vec::append(impl_substs,\n-                          vec::tailn(node_substs,\n-                                     node_substs.len() - n_m_tps));\n-        let {bcx, val} = trans_self_arg(bcx, base, mentry);\n-        let lval = lval_static_fn_inner(bcx, mth_id, callee_id, ty_substs,\n-                                        Some(sub_origins));\n-        {env: self_env(val, node_id_type(bcx, base.id),\n-                       None, mentry.self_mode),\n-         val: PointerCast(bcx, lval.val, T_ptr(type_of_fn_from_ty(\n-             ccx, node_id_type(bcx, callee_id)))),\n-         .. lval}\n+          let ccx = bcx.ccx();\n+          let mname = ty::trait_methods(ccx.tcx, trait_id)[n_method].ident;\n+          let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n+\n+          // obtain the `self` value:\n+          let Result {bcx, val: llself_val} =\n+              trans_self_arg(bcx, base, mentry);\n+\n+          // create a concatenated set of substitutions which includes\n+          // those from the impl and those from the method:\n+          let n_m_tps = method_ty_param_count(ccx, mth_id, impl_did);\n+          let node_substs = node_id_type_params(bcx, callee_id);\n+          let ty_substs\n+              = vec::append(impl_substs,\n+                            vec::tailn(node_substs,\n+                                       node_substs.len() - n_m_tps));\n+          debug!(\"n_m_tps=%?\", n_m_tps);\n+          debug!(\"impl_substs=%?\", impl_substs.map(|t| bcx.ty_to_str(t)));\n+          debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(t)));\n+          debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(t)));\n+\n+          // translate the function\n+          let callee = trans_fn_ref_with_vtables(\n+              bcx, mth_id, callee_id, ty_substs, Some(sub_origins));\n+\n+          // create a llvalue that represents the fn ptr\n+          let fn_ty = node_id_type(bcx, callee_id);\n+          let llfn_ty = T_ptr(type_of_fn_from_ty(ccx, fn_ty));\n+          let llfn_val = PointerCast(bcx, callee.llfn, llfn_ty);\n+\n+          // combine the self environment with the rest\n+          Callee {\n+              bcx: bcx,\n+              data: Method(MethodData {\n+                  llfn: llfn_val,\n+                  llself: llself_val,\n+                  self_ty: node_id_type(bcx, base.id),\n+                  self_mode: mentry.self_mode\n+              })\n+          }\n       }\n       typeck::vtable_trait(*) => {\n-        let {bcx, val} = trans_temp_expr(bcx, base);\n-        let fty = node_id_type(bcx, callee_id);\n-        trans_trait_callee(bcx, val, fty, n_method)\n+          trans_trait_callee(bcx, callee_id, n_method, base, mentry.derefs)\n       }\n       typeck::vtable_param(*) => {\n-        fail ~\"vtable_param left in monomorphized function's vtable substs\";\n+          fail ~\"vtable_param left in monomorphized function's vtable substs\";\n       }\n     }\n }\n \n-// Method callee where the vtable comes from a boxed trait\n-fn trans_trait_callee(bcx: block, val: ValueRef,\n-                      callee_ty: ty::t, n_method: uint)\n-    -> lval_maybe_callee {\n+fn trans_trait_callee(bcx: block,\n+                      callee_id: ast::node_id,\n+                      n_method: uint,\n+                      self_expr: @ast::expr,\n+                      autoderefs: uint)\n+    -> Callee\n+{\n+    //!\n+    //\n+    // Create a method callee where the method is coming from a trait\n+    // instance (e.g., @Trait type).  In this case, we must pull the\n+    // fn pointer out of the vtable that is packaged up with the\n+    // @Trait instance.  @Traits are represented as a pair, so we first\n+    // evaluate the self expression (expected a by-ref result) and then\n+    // extract the self data and vtable out of the pair.\n+\n+    let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n+    let mut bcx = bcx;\n+    let self_datum = unpack_datum!(bcx, expr::trans_to_datum(bcx, self_expr));\n+    let self_datum = self_datum.autoderef(bcx, self_expr.id, autoderefs);\n+    let llpair = self_datum.to_ref_llval(bcx);\n+    let callee_ty = node_id_type(bcx, callee_id);\n+    trans_trait_callee_from_llval(bcx, callee_ty, n_method, llpair)\n+}\n+\n+fn trans_trait_callee_from_llval(bcx: block,\n+                                 callee_ty: ty::t,\n+                                 n_method: uint,\n+                                 llpair: ValueRef)\n+    -> Callee\n+{\n+    //!\n+    //\n+    // Same as `trans_trait_callee()` above, except that it is given\n+    // a by-ref pointer to the @Trait pair.\n+\n     let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n-    let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0u, 0u]),\n-                                       T_ptr(T_ptr(T_vtable()))));\n-    let llbox = Load(bcx, GEPi(bcx, val, [0u, 1u]));\n-    // FIXME[impl] I doubt this is alignment-safe (#2534)\n-    let self = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n-    let env = self_env(self, ty::mk_opaque_box(bcx.tcx()), Some(llbox),\n-                       // XXX: is this bogosity?\n-                       ast::by_ref);\n-    let llfty = type_of::type_of_fn_from_ty(ccx, callee_ty);\n-    let vtable = PointerCast(bcx, vtable,\n-                             T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n-    let mptr = Load(bcx, GEPi(bcx, vtable, [0u, n_method]));\n-    {bcx: bcx, val: mptr, kind: lv_owned, env: env}\n+    let mut bcx = bcx;\n+\n+    // Load the vtable from the @Trait pair\n+    let llvtable = Load(bcx,\n+                      PointerCast(bcx,\n+                                  GEPi(bcx, llpair, [0u, 0u]),\n+                                  T_ptr(T_ptr(T_vtable()))));\n+\n+    // Load the box from the @Trait pair and GEP over the box header:\n+    let llbox = Load(bcx, GEPi(bcx, llpair, [0u, 1u]));\n+    let llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+\n+    // Load the function from the vtable and cast it to the expected type.\n+    let llcallee_ty = type_of::type_of_fn_from_ty(ccx, callee_ty);\n+    let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method]));\n+    let mptr = PointerCast(bcx, mptr, T_ptr(llcallee_ty));\n+\n+    return Callee {\n+        bcx: bcx,\n+        data: Method(MethodData {\n+            llfn: mptr,\n+            llself: llself,\n+            self_ty: ty::mk_opaque_box(bcx.tcx()),\n+            self_mode: ast::by_ref, // XXX: is this bogosity?\n+            /* XXX: Some(llbox) */\n+        })\n+    };\n }\n \n fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n-    -> typeck::vtable_origin {\n+    -> typeck::vtable_origin\n+{\n     let mut vtable_off = n_bound, i = 0u;\n     // Vtables are stored in a flat array, finding the right one is\n     // somewhat awkward\n@@ -339,17 +417,18 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n \n fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n     match origin {\n-      typeck::vtable_static(impl_id, substs, sub_vtables) => {\n-        make_mono_id(ccx, impl_id, substs,\n-                     if (*sub_vtables).len() == 0u { None }\n-                     else { Some(sub_vtables) }, None)\n-      }\n-      typeck::vtable_trait(trait_id, substs) => {\n-        @{def: trait_id,\n-          params: vec::map(substs, |t| mono_precise(t, None))}\n-      }\n-      // can't this be checked at the callee?\n-      _ => fail ~\"vtable_id\"\n+        typeck::vtable_static(impl_id, substs, sub_vtables) => {\n+            monomorphize::make_mono_id(\n+                ccx, impl_id, substs,\n+                if (*sub_vtables).len() == 0u { None }\n+                else { Some(sub_vtables) }, None)\n+        }\n+        typeck::vtable_trait(trait_id, substs) => {\n+            @{def: trait_id,\n+              params: vec::map(substs, |t| mono_precise(t, None))}\n+        }\n+        // can't this be checked at the callee?\n+        _ => fail ~\"vtable_id\"\n     }\n }\n \n@@ -385,9 +464,10 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n     let tcx = ccx.tcx;\n \n     // XXX: This should support multiple traits.\n-    let trt_id = expect(ccx.sess,\n-                        ty::ty_to_def_id(ty::impl_traits(tcx, impl_id)[0]),\n-                        || ~\"make_impl_vtable: non-trait-type implemented\");\n+    let trt_id = driver::session::expect(\n+        tcx.sess,\n+        ty::ty_to_def_id(ty::impl_traits(tcx, impl_id)[0]),\n+        || ~\"make_impl_vtable: non-trait-type implemented\");\n \n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n     make_vtable(ccx, vec::map(*ty::trait_methods(tcx, trt_id), |im| {\n@@ -400,9 +480,10 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n                 // If the method is in another crate, need to make an inlined\n                 // copy first\n                 if m_id.crate != ast::local_crate {\n-                    m_id = maybe_instantiate_inline(ccx, m_id);\n+                    m_id = inline::maybe_instantiate_inline(ccx, m_id);\n                 }\n-                monomorphic_fn(ccx, m_id, substs, Some(vtables), None).val\n+                monomorphize::monomorphic_fn(ccx, m_id, substs,\n+                                             Some(vtables), None).val\n             } else if m_id.crate == ast::local_crate {\n                 get_item_val(ccx, m_id.node)\n             } else {\n@@ -412,23 +493,42 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n     }))\n }\n \n-fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n-    -> block {\n+fn trans_trait_cast(bcx: block,\n+                    val: @ast::expr,\n+                    id: ast::node_id,\n+                    dest: expr::Dest)\n+    -> block\n+{\n     let _icx = bcx.insn_ctxt(\"impl::trans_cast\");\n-    if dest == ignore { return trans_expr(bcx, val, ignore); }\n+\n+    let lldest = match dest {\n+        Ignore => {\n+            return expr::trans_into(bcx, val, Ignore);\n+        }\n+        SaveIn(dest) => dest\n+    };\n+\n     let ccx = bcx.ccx();\n     let v_ty = expr_ty(bcx, val);\n+\n+    // Allocate an @ box and store the value into it\n     let {bcx: bcx, box: llbox, body: body} = malloc_boxed(bcx, v_ty);\n     add_clean_free(bcx, llbox, heap_shared);\n-    let bcx = trans_expr_save_in(bcx, val, body);\n+    let bcx = expr::trans_into(bcx, val, SaveIn(body));\n     revoke_clean(bcx, llbox);\n-    let result = get_dest_addr(dest);\n-    Store(bcx, llbox, PointerCast(bcx, GEPi(bcx, result, [0u, 1u]),\n+\n+    // Store the @ box into the pair\n+    Store(bcx, llbox, PointerCast(bcx,\n+                                  GEPi(bcx, lldest, [0u, 1u]),\n                                   T_ptr(val_ty(llbox))));\n+\n+    // Store the vtable into the pair\n     let orig = ccx.maps.vtable_map.get(id)[0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx.ccx(), orig);\n-    Store(bcx, vtable, PointerCast(bcx, GEPi(bcx, result, [0u, 0u]),\n+    Store(bcx, vtable, PointerCast(bcx,\n+                                   GEPi(bcx, lldest, [0u, 0u]),\n                                    T_ptr(val_ty(vtable))));\n+\n     bcx\n }"}, {"sha": "6de7e77a394643d010e3ad3b1305d92195f822a4", "filename": "src/rustc/middle/trans/inline.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,87 @@\n+use common::*;\n+use syntax::ast;\n+use syntax::ast_util::local_def;\n+use syntax::ast_map::{path, path_mod, path_name};\n+use base::{trans_item, get_item_val, self_arg, trans_fn,\n+              impl_self, get_insn_ctxt};\n+\n+fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n+    -> ast::def_id\n+{\n+    let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n+    match ccx.external.find(fn_id) {\n+      Some(Some(node_id)) => {\n+        // Already inline\n+        debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\",\n+               ty::item_path_str(ccx.tcx, fn_id), node_id);\n+        local_def(node_id)\n+      }\n+      Some(None) => fn_id, // Not inlinable\n+      None => { // Not seen yet\n+        match csearch::maybe_get_item_ast(\n+            ccx.tcx, fn_id,\n+            |a,b,c,d| {\n+                astencode::decode_inlined_item(a, b, ccx.maps, c, d)\n+            }) {\n+\n+          csearch::not_found => {\n+            ccx.external.insert(fn_id, None);\n+            fn_id\n+          }\n+          csearch::found(ast::ii_item(item)) => {\n+            ccx.external.insert(fn_id, Some(item.id));\n+            trans_item(ccx, *item);\n+            local_def(item.id)\n+          }\n+          csearch::found(ast::ii_ctor(ctor, _, _, _)) => {\n+            ccx.external.insert(fn_id, Some(ctor.node.id));\n+            local_def(ctor.node.id)\n+          }\n+          csearch::found(ast::ii_foreign(item)) => {\n+            ccx.external.insert(fn_id, Some(item.id));\n+            local_def(item.id)\n+          }\n+          csearch::found_parent(parent_id, ast::ii_item(item)) => {\n+            ccx.external.insert(parent_id, Some(item.id));\n+            let mut my_id = 0;\n+            match item.node {\n+              ast::item_enum(_, _) => {\n+                let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n+                let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n+                do vec::iter2(*vs_here, *vs_there) |here, there| {\n+                    if there.id == fn_id { my_id = here.id.node; }\n+                    ccx.external.insert(there.id, Some(here.id.node));\n+                }\n+              }\n+              _ => ccx.sess.bug(~\"maybe_instantiate_inline: item has a \\\n+                    non-enum parent\")\n+            }\n+            trans_item(ccx, *item);\n+            local_def(my_id)\n+          }\n+          csearch::found_parent(_, _) => {\n+              ccx.sess.bug(~\"maybe_get_item_ast returned a found_parent \\\n+               with a non-item parent\");\n+          }\n+          csearch::found(ast::ii_method(impl_did, mth)) => {\n+            ccx.external.insert(fn_id, Some(mth.id));\n+            let {bounds: impl_bnds, region_param: _, ty: impl_ty} =\n+                ty::lookup_item_type(ccx.tcx, impl_did);\n+            if (*impl_bnds).len() + mth.tps.len() == 0u {\n+                let llfn = get_item_val(ccx, mth.id);\n+                let path = vec::append(\n+                    ty::item_path(ccx.tcx, impl_did),\n+                    ~[path_name(mth.ident)]);\n+                trans_fn(ccx, path, mth.decl, mth.body,\n+                         llfn, impl_self(impl_ty), None, mth.id);\n+            }\n+            local_def(mth.id)\n+          }\n+          csearch::found(ast::ii_dtor(dtor, _, _, _)) => {\n+              ccx.external.insert(fn_id, Some(dtor.node.id));\n+              local_def(dtor.node.id)\n+          }\n+        }\n+      }\n+    }\n+}"}, {"sha": "6a813b7c1b2444911fcc4084d7ff8d06d9b14ad8", "filename": "src/rustc/middle/trans/macros.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmacros.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,45 @@\n+{\n+\n+macro_rules! unpack_datum(\n+    ($bcx: ident, $inp: expr) => (\n+        {\n+            let db = $inp;\n+            $bcx = db.bcx;\n+            db.datum\n+        }\n+    )\n+);\n+\n+macro_rules! unpack_result(\n+    ($bcx: ident, $inp: expr) => (\n+        {\n+            let db = $inp;\n+            $bcx = db.bcx;\n+            db.val\n+        }\n+    )\n+);\n+\n+macro_rules! trace_span(\n+    ($bcx: ident, $sp: expr, $str: expr) => (\n+        {\n+            let bcx = $bcx;\n+            if bcx.sess().trace() {\n+                trans_trace(bcx, Some($sp), $str);\n+            }\n+        }\n+    )\n+);\n+\n+macro_rules! trace(\n+    ($bcx: ident, $str: expr) => (\n+        {\n+            let bcx = $bcx;\n+            if bcx.sess().trace() {\n+                trans_trace(bcx, None, $str);\n+            }\n+        }\n+    )\n+);\n+\n+}\n\\ No newline at end of file"}, {"sha": "962aed37ff1f92c8980daa3369760fff1fd236c6", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,276 @@\n+use common::*;\n+use syntax::ast;\n+use syntax::ast_util::local_def;\n+use syntax::ast_map::{path, path_mod, path_name};\n+use base::{trans_item, get_item_val, no_self, self_arg, trans_fn,\n+              impl_self, decl_internal_cdecl_fn,\n+              set_inline_hint_if_appr, set_inline_hint,\n+              trans_enum_variant, trans_class_ctor, trans_class_dtor,\n+              get_insn_ctxt};\n+use syntax::parse::token::special_idents;\n+use type_of::type_of_fn_from_ty;\n+use back::link::mangle_exported_name;\n+\n+fn monomorphic_fn(ccx: @crate_ctxt,\n+                  fn_id: ast::def_id,\n+                  real_substs: ~[ty::t],\n+                  vtables: Option<typeck::vtable_res>,\n+                  ref_id: Option<ast::node_id>)\n+    -> {val: ValueRef, must_cast: bool}\n+{\n+    let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n+    let mut must_cast = false;\n+    let substs = vec::map(real_substs, |t| {\n+        match normalize_for_monomorphization(ccx.tcx, t) {\n+          Some(t) => { must_cast = true; t }\n+          None => t\n+        }\n+    });\n+\n+    for real_substs.each() |s| { assert !ty::type_has_params(s); }\n+    for substs.each() |s| { assert !ty::type_has_params(s); }\n+    let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n+    let hash_id = make_mono_id(ccx, fn_id, substs, vtables, Some(param_uses));\n+    if vec::any(hash_id.params,\n+                |p| match p { mono_precise(_, _) => false, _ => true }) {\n+        must_cast = true;\n+    }\n+\n+    #debug[\"monomorphic_fn(fn_id=%? (%s), real_substs=%?, substs=%?, \\\n+           hash_id = %?\",\n+           fn_id, ty::item_path_str(ccx.tcx, fn_id),\n+           real_substs.map(|s| ty_to_str(ccx.tcx, s)),\n+           substs.map(|s| ty_to_str(ccx.tcx, s)), hash_id];\n+\n+    match ccx.monomorphized.find(hash_id) {\n+      Some(val) => {\n+        debug!(\"leaving monomorphic fn %s\",\n+               ty::item_path_str(ccx.tcx, fn_id));\n+        return {val: val, must_cast: must_cast};\n+      }\n+      None => ()\n+    }\n+\n+    let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n+    let mut llitem_ty = tpt.ty;\n+\n+    let map_node = session::expect(ccx.sess, ccx.tcx.items.find(fn_id.node),\n+     || fmt!(\"While monomorphizing %?, couldn't find it in the item map \\\n+        (may have attempted to monomorphize an item defined in a different \\\n+        crate?)\", fn_id));\n+    // Get the path so that we can create a symbol\n+    let (pt, name, span) = match map_node {\n+      ast_map::node_item(i, pt) => (pt, i.ident, i.span),\n+      ast_map::node_variant(v, enm, pt) => (pt, v.node.name, enm.span),\n+      ast_map::node_method(m, _, pt) => (pt, m.ident, m.span),\n+      ast_map::node_foreign_item(i, ast::foreign_abi_rust_intrinsic, pt)\n+      => (pt, i.ident, i.span),\n+      ast_map::node_foreign_item(*) => {\n+        // Foreign externs don't have to be monomorphized.\n+        return {val: get_item_val(ccx, fn_id.node),\n+                must_cast: true};\n+      }\n+      ast_map::node_ctor(nm, _, ct, _, pt) => (pt, nm, ct.span),\n+      ast_map::node_dtor(_, dtor, _, pt) =>\n+          (pt, special_idents::dtor, dtor.span),\n+      ast_map::node_trait_method(*) => {\n+        ccx.tcx.sess.bug(~\"Can't monomorphize a trait method\")\n+      }\n+      ast_map::node_expr(*) => {\n+        ccx.tcx.sess.bug(~\"Can't monomorphize an expr\")\n+      }\n+      ast_map::node_stmt(*) => {\n+        ccx.tcx.sess.bug(~\"Can't monomorphize a stmt\")\n+      }\n+      ast_map::node_export(*) => {\n+          ccx.tcx.sess.bug(~\"Can't monomorphize an export\")\n+      }\n+      ast_map::node_arg(*) => ccx.tcx.sess.bug(~\"Can't monomorphize an arg\"),\n+      ast_map::node_block(*) => {\n+          ccx.tcx.sess.bug(~\"Can't monomorphize a block\")\n+      }\n+      ast_map::node_local(*) => {\n+          ccx.tcx.sess.bug(~\"Can't monomorphize a local\")\n+      }\n+    };\n+    let mono_ty = ty::subst_tps(ccx.tcx, substs, llitem_ty);\n+    let llfty = type_of_fn_from_ty(ccx, mono_ty);\n+\n+    let depth = option::get_default(ccx.monomorphizing.find(fn_id), 0u);\n+    // Random cut-off -- code that needs to instantiate the same function\n+    // recursively more than ten times can probably safely be assumed to be\n+    // causing an infinite expansion.\n+    if depth > 10u {\n+        ccx.sess.span_fatal(\n+            span, ~\"overly deep expansion of inlined function\");\n+    }\n+    ccx.monomorphizing.insert(fn_id, depth + 1u);\n+\n+    let pt = vec::append(*pt,\n+                         ~[path_name(ccx.names(ccx.sess.str_of(name)))]);\n+    let s = mangle_exported_name(ccx, pt, mono_ty);\n+\n+    let mk_lldecl = || {\n+        let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, llfty);\n+        ccx.monomorphized.insert(hash_id, lldecl);\n+        lldecl\n+    };\n+\n+    let psubsts = Some({tys: substs, vtables: vtables, bounds: tpt.bounds});\n+    let lldecl = match map_node {\n+      ast_map::node_item(i@@{node: ast::item_fn(decl, _, _, body), _}, _) => {\n+        let d = mk_lldecl();\n+        set_inline_hint_if_appr(i.attrs, d);\n+        trans_fn(ccx, pt, decl, body, d, no_self, psubsts, fn_id.node);\n+        d\n+      }\n+      ast_map::node_item(*) => {\n+          ccx.tcx.sess.bug(~\"Can't monomorphize this kind of item\")\n+      }\n+      ast_map::node_foreign_item(i, _, _) => {\n+          let d = mk_lldecl();\n+          foreign::trans_intrinsic(ccx, d, i, pt, option::get(psubsts),\n+                                ref_id);\n+          d\n+      }\n+      ast_map::node_variant(v, enum_item, _) => {\n+        let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n+        let this_tv = option::get(vec::find(*tvs, |tv| {\n+            tv.id.node == fn_id.node}));\n+        let d = mk_lldecl();\n+        set_inline_hint(d);\n+        match v.node.kind {\n+            ast::tuple_variant_kind(args) => {\n+                trans_enum_variant(ccx, enum_item.id, v, args,\n+                                   this_tv.disr_val, (*tvs).len() == 1u,\n+                                   psubsts, d);\n+            }\n+            ast::struct_variant_kind(_) =>\n+                ccx.tcx.sess.bug(~\"can't monomorphize struct variants\"),\n+            ast::enum_variant_kind(_) =>\n+                ccx.tcx.sess.bug(~\"can't monomorphize enum variants\")\n+        }\n+        d\n+      }\n+      ast_map::node_method(mth, _, _) => {\n+        let d = mk_lldecl();\n+        set_inline_hint_if_appr(mth.attrs, d);\n+        impl::trans_method(ccx, pt, mth, psubsts, d);\n+        d\n+      }\n+      ast_map::node_ctor(_, tps, ctor, parent_id, _) => {\n+        // ctors don't have attrs, at least not right now\n+        let d = mk_lldecl();\n+        let tp_tys = ty::ty_params_to_tys(ccx.tcx, tps);\n+        trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, d,\n+               option::get_default(psubsts,\n+                        {tys:tp_tys, vtables: None, bounds: @~[]}),\n+                         fn_id.node, parent_id, ctor.span);\n+        d\n+      }\n+      ast_map::node_dtor(_, dtor, _, pt) => {\n+        let parent_id = match ty::ty_to_def_id(ty::node_id_to_type(ccx.tcx,\n+                                              dtor.node.self_id)) {\n+                Some(did) => did,\n+                None      => ccx.sess.span_bug(dtor.span, ~\"Bad self ty in \\\n+                                                            dtor\")\n+        };\n+        trans_class_dtor(ccx, *pt, dtor.node.body,\n+          dtor.node.id, psubsts, Some(hash_id), parent_id)\n+      }\n+      // Ugh -- but this ensures any new variants won't be forgotten\n+      ast_map::node_expr(*) |\n+      ast_map::node_stmt(*) |\n+      ast_map::node_trait_method(*) |\n+      ast_map::node_export(*) |\n+      ast_map::node_arg(*) |\n+      ast_map::node_block(*) |\n+      ast_map::node_local(*) => {\n+        ccx.tcx.sess.bug(fmt!(\"Can't monomorphize a %?\", map_node))\n+      }\n+    };\n+    ccx.monomorphizing.insert(fn_id, depth);\n+\n+    debug!(\"leaving monomorphic fn %s\", ty::item_path_str(ccx.tcx, fn_id));\n+    {val: lldecl, must_cast: must_cast}\n+}\n+\n+fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> Option<ty::t> {\n+    // FIXME[mono] could do this recursively. is that worthwhile? (#2529)\n+    match ty::get(ty).struct {\n+      ty::ty_box(*) => {\n+        Some(ty::mk_opaque_box(tcx))\n+      }\n+      ty::ty_fn(ref fty) => {\n+        Some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n+                             proto: fty.proto,\n+                             bounds: @~[],\n+                             inputs: ~[],\n+                             output: ty::mk_nil(tcx),\n+                             ret_style: ast::return_val}))\n+      }\n+      ty::ty_trait(_, _, _) => {\n+        Some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n+                             proto: ty::proto_vstore(ty::vstore_box),\n+                             bounds: @~[],\n+                             inputs: ~[],\n+                             output: ty::mk_nil(tcx),\n+                             ret_style: ast::return_val}))\n+      }\n+      ty::ty_ptr(_) => Some(ty::mk_uint(tcx)),\n+      _ => None\n+    }\n+}\n+\n+fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n+                vtables: Option<typeck::vtable_res>,\n+                param_uses: Option<~[type_use::type_uses]>) -> mono_id {\n+    let precise_param_ids = match vtables {\n+      Some(vts) => {\n+        let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;\n+        let mut i = 0u;\n+        vec::map2(*bounds, substs, |bounds, subst| {\n+            let mut v = ~[];\n+            for vec::each(*bounds) |bound| {\n+                match bound {\n+                  ty::bound_trait(_) => {\n+                    vec::push(v, impl::vtable_id(ccx, vts[i]));\n+                    i += 1u;\n+                  }\n+                  _ => ()\n+                }\n+            }\n+            (subst, if v.len() > 0u { Some(v) } else { None })\n+        })\n+      }\n+      None => {\n+        vec::map(substs, |subst| (subst, None))\n+      }\n+    };\n+    let param_ids = match param_uses {\n+      Some(uses) => {\n+        vec::map2(precise_param_ids, uses, |id, uses| {\n+            match id {\n+                (a, b@Some(_)) => mono_precise(a, b),\n+              (subst, None) => {\n+                if uses == 0u { mono_any }\n+                else if uses == type_use::use_repr &&\n+                        !ty::type_needs_drop(ccx.tcx, subst) {\n+                    let llty = type_of::type_of(ccx, subst);\n+                    let size = shape::llsize_of_real(ccx, llty);\n+                    let align = shape::llalign_of_pref(ccx, llty);\n+                    // Special value for nil to prevent problems with undef\n+                    // return pointers.\n+                    if size == 1u && ty::type_is_nil(subst) {\n+                        mono_repr(0u, 0u)\n+                    } else { mono_repr(size, align) }\n+                } else { mono_precise(subst, None) }\n+              }\n+            }\n+        })\n+      }\n+      None => precise_param_ids.map(|x| { let (a, b) = x;\n+                mono_precise(a, b) })\n+    };\n+    @{def: item, params: param_ids}\n+}"}, {"sha": "a9a7f4e4e9f335723a2985ad8621400f2cb9cfc1", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -144,7 +144,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n }\n \n fn mk_ty_visitor() -> visit::vt<ctx> {\n-    visit::mk_vt(@{visit_ty: traverse_ty,.. *visit::default_visitor()})\n+    visit::mk_vt(@{visit_ty: traverse_ty, ..*visit::default_visitor()})\n }\n \n fn traverse_ty(ty: @ty, cx: ctx, v: visit::vt<ctx>) {\n@@ -200,7 +200,7 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n      visit::visit_block(body, cx, visit::mk_vt(@{\n         visit_expr: traverse_expr,\n         visit_item: traverse_item,\n-        .. *visit::default_visitor()\n+         ..*visit::default_visitor()\n     }));\n }\n \n@@ -219,7 +219,7 @@ fn traverse_all_resources_and_impls(cx: ctx, crate_mod: _mod) {\n               _ => ()\n             }\n         },\n-        .. *visit::default_visitor()\n+        ..*visit::default_visitor()\n     }));\n }\n "}, {"sha": "c6d35e858267535745ee79d3b43db37e9abf8b51", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -9,6 +9,9 @@ use base::*;\n use type_of::*;\n use ast::def_id;\n use util::ppaux::ty_to_str;\n+use datum::*;\n+use callee::ArgVals;\n+use expr::SaveIn;\n \n enum reflector = {\n     visitor_val: ValueRef,\n@@ -44,7 +47,7 @@ impl reflector {\n     fn c_tydesc(t: ty::t) -> ValueRef {\n         let bcx = self.bcx;\n         let static_ti = get_tydesc(bcx.ccx(), t);\n-        lazily_emit_all_tydesc_glue(bcx.ccx(), static_ti);\n+        glue::lazily_emit_all_tydesc_glue(bcx.ccx(), static_ti);\n         PointerCast(bcx, static_ti.tydesc, T_ptr(self.tydesc_ty))\n     }\n \n@@ -60,25 +63,21 @@ impl reflector {\n             *self.visitor_methods));\n         let mth_ty = ty::mk_fn(tcx, self.visitor_methods[mth_idx].fty);\n         let v = self.visitor_val;\n-        let get_lval = |bcx| {\n-            let callee =\n-                impl::trans_trait_callee(bcx, v, mth_ty, mth_idx);\n-            debug!(\"calling mth ty %s, lltype %s\",\n-                   ty_to_str(bcx.ccx().tcx, mth_ty),\n-                   val_str(bcx.ccx().tn, callee.val));\n-            callee\n-        };\n         debug!(\"passing %u args:\", vec::len(args));\n         let bcx = self.bcx;\n         for args.eachi |i, a| {\n             debug!(\"arg %u: %s\", i, val_str(bcx.ccx().tn, a));\n         }\n-        let d = empty_dest_cell();\n-        let bcx =\n-            trans_call_inner(self.bcx, None, mth_ty, ty::mk_bool(tcx),\n-                             get_lval, arg_vals(args), by_val(d));\n+        let bool_ty = ty::mk_bool(tcx);\n+        let scratch = scratch_datum(bcx, bool_ty, false);\n+        let bcx = callee::trans_call_inner(\n+            self.bcx, None, mth_ty, bool_ty,\n+            |bcx| impl::trans_trait_callee_from_llval(bcx, mth_ty,\n+                                                      mth_idx, v),\n+            ArgVals(args), SaveIn(scratch.val));\n+        let result = scratch.to_value_llval(bcx);\n         let next_bcx = sub_block(bcx, ~\"next\");\n-        CondBr(bcx, *d, next_bcx.llbb, self.final_bcx.llbb);\n+        CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);\n         self.bcx = next_bcx\n     }\n "}, {"sha": "33072f87db9ef4caded42e252e2e372591e4842b", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 336, "deletions": 237, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -2,15 +2,15 @@ use syntax::ast;\n use driver::session::session;\n use lib::llvm::{ValueRef, TypeRef};\n use back::abi;\n-use base::{call_memmove,\n-              INIT, copy_val, load_if_immediate, get_tydesc,\n-              sub_block, do_spill_noroot,\n-              dest, non_gc_box_cast, move_val, lval_owned};\n use syntax::codemap::span;\n use shape::llsize_of;\n use build::*;\n use common::*;\n use util::ppaux::ty_to_str;\n+use expr::{Dest, SaveIn, Ignore};\n+use datum::*;\n+use syntax::print::pprust::{expr_to_str};\n+use util::common::indenter;\n \n // Boxed vector types are in some sense currently a \"shorthand\" for a box\n // containing an unboxed vector. This expands a boxed vector type into such an\n@@ -43,11 +43,10 @@ fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n }\n \n fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n-    non_gc_box_cast(bcx, GEPi(bcx, vptr, [0u, abi::box_field_body]))\n+    base::non_gc_box_cast(bcx, GEPi(bcx, vptr, [0u, abi::box_field_body]))\n }\n \n-fn get_dataptr(bcx: block, vptr: ValueRef)\n-    -> ValueRef {\n+fn get_dataptr(bcx: block, vptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n@@ -60,7 +59,7 @@ fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n }\n \n fn alloc_raw(bcx: block, unit_ty: ty::t,\n-              fill: ValueRef, alloc: ValueRef, heap: heap) -> result {\n+              fill: ValueRef, alloc: ValueRef, heap: heap) -> Result {\n     let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n \n@@ -71,14 +70,14 @@ fn alloc_raw(bcx: block, unit_ty: ty::t,\n         base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n     Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n     Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n-    return {bcx: bcx, val: box};\n+    return rslt(bcx, box);\n }\n fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n-                  fill: ValueRef, alloc: ValueRef) -> result {\n+                  fill: ValueRef, alloc: ValueRef) -> Result {\n     alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange)\n }\n \n-fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> result {\n+fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> Result {\n     let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n     let llunitty = type_of::type_of(ccx, unit_ty);\n@@ -87,23 +86,24 @@ fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> result {\n     let fill = Mul(bcx, C_uint(ccx, elts), unit_sz);\n     let alloc = if elts < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n                 else { fill };\n-    let {bcx: bcx, val: vptr} = alloc_raw(bcx, unit_ty, fill, alloc, heap);\n-    return {bcx: bcx, val: vptr};\n+    let Result {bcx: bcx, val: vptr} =\n+        alloc_raw(bcx, unit_ty, fill, alloc, heap);\n+    return rslt(bcx, vptr);\n }\n \n-fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n+fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n     let _icx = bcx.insn_ctxt(\"tvec::duplicate_uniq\");\n \n     let fill = get_fill(bcx, get_bodyptr(bcx, vptr));\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let {bcx, val: newptr} = alloc_uniq_raw(bcx, unit_ty, fill, fill);\n+    let Result {bcx, val: newptr} = alloc_uniq_raw(bcx, unit_ty, fill, fill);\n \n     let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr));\n     let new_data_ptr = get_dataptr(bcx, get_bodyptr(bcx, newptr));\n-    call_memmove(bcx, new_data_ptr, data_ptr, fill);\n+    base::call_memmove(bcx, new_data_ptr, data_ptr, fill);\n \n     let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n-        iter_vec_raw(bcx, new_data_ptr, vec_ty, fill, base::take_ty)\n+        iter_vec_raw(bcx, new_data_ptr, vec_ty, fill, glue::take_ty)\n     } else { bcx };\n     return rslt(bcx, newptr);\n }\n@@ -113,250 +113,349 @@ fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n     let _icx = bcx.insn_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx(), unit_ty = ty::sequence_element_type(tcx, vec_ty);\n     if ty::type_needs_drop(tcx, unit_ty) {\n-        iter_vec_unboxed(bcx, vptr, vec_ty, base::drop_ty)\n+        iter_vec_unboxed(bcx, vptr, vec_ty, glue::drop_ty)\n     } else { bcx }\n }\n \n-enum evec_elements {\n-    individual_evec(~[@ast::expr]),\n-    repeating_evec(@ast::expr, uint)\n+struct VecTypes {\n+    vec_ty: ty::t;\n+    unit_ty: ty::t;\n+    llunit_ty: TypeRef;\n+    llunit_size: ValueRef;\n }\n \n-fn trans_evec(bcx: block, elements: evec_elements,\n-              vst: ast::vstore, id: ast::node_id, dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::trans_evec\");\n+impl VecTypes {\n+    fn to_str(ccx: @crate_ctxt) -> ~str {\n+        fmt!(\"VecTypes {vec_ty=%s, unit_ty=%s, llunit_ty=%s, llunit_size=%s}\",\n+             ty_to_str(ccx.tcx, self.vec_ty),\n+             ty_to_str(ccx.tcx, self.unit_ty),\n+             ty_str(ccx.tn, self.llunit_ty),\n+             val_str(ccx.tn, self.llunit_size))\n+    }\n+}\n+\n+fn trans_fixed_vstore(bcx: block,\n+                      vstore_expr: @ast::expr,\n+                      content_expr: @ast::expr,\n+                      dest: expr::Dest) -> block\n+{\n+    //!\n+    //\n+    // [...]/_ allocates a fixed-size array and moves it around \"by value\".\n+    // In this case, it means that the caller has already given us a location\n+    // to store the array of the suitable size, so all we have to do is\n+    // generate the content.\n+\n+    debug!(\"trans_fixed_vstore(vstore_expr=%s, dest=%?)\",\n+           bcx.expr_to_str(vstore_expr), dest.to_str(bcx.ccx()));\n+    let _indenter = indenter();\n+\n+    let vt = vec_types_from_expr(bcx, vstore_expr);\n+\n+    return match dest {\n+        Ignore => write_content(bcx, &vt, vstore_expr, content_expr, dest),\n+        SaveIn(lldest) => {\n+            // lldest will have type *[T x N], but we want the type *T,\n+            // so use GEP to convert:\n+            let lldest = GEPi(bcx, lldest, [0, 0]);\n+            write_content(bcx, &vt, vstore_expr, content_expr, SaveIn(lldest))\n+        }\n+    };\n+}\n+\n+fn trans_slice_vstore(bcx: block,\n+                      vstore_expr: @ast::expr,\n+                      content_expr: @ast::expr,\n+                      dest: expr::Dest) -> block\n+{\n+    //!\n+    //\n+    // &[...] allocates memory on the stack and writes the values into it,\n+    // returning a slice (pair of ptr, len).  &\"...\" is similar except that\n+    // the memory can be statically allocated.\n+\n     let ccx = bcx.ccx();\n-    let mut bcx = bcx;\n \n-    // Handle the ignored case.\n-    if dest == base::ignore {\n-        match elements {\n-            individual_evec(args) => {\n-                for vec::each(args) |arg| {\n-                    bcx = base::trans_expr(bcx, arg, base::ignore);\n-                }\n-            }\n-            repeating_evec(element, _) => {\n-                bcx = base::trans_expr(bcx, element, base::ignore);\n-            }\n+    debug!(\"trans_slice_vstore(vstore_expr=%s, dest=%s)\",\n+           bcx.expr_to_str(vstore_expr), dest.to_str(ccx));\n+    let _indenter = indenter();\n+\n+    // Handle the &\"...\" case:\n+    match content_expr.node {\n+        ast::expr_lit(@{node: ast::lit_str(s), span: _}) => {\n+            return trans_lit_str(bcx, content_expr, s, dest);\n         }\n-        return bcx;\n+        _ => {}\n     }\n \n-    // Figure out the number of elements we need.\n-    let count;\n-    match elements {\n-        individual_evec(args) => count = args.len(),\n-        repeating_evec(_, len) => count = len\n+    // Handle the &[...] case:\n+    let vt = vec_types_from_expr(bcx, vstore_expr);\n+    let count = elements_required(bcx, content_expr);\n+    debug!(\"vt=%s, count=%?\", vt.to_str(ccx), count);\n+\n+    // Make a fixed-length backing array and allocate it on the stack.\n+    let llcount = C_uint(ccx, count);\n+    let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n+\n+    // Arrange for the backing array to be cleaned up.\n+    let fixed_ty = ty::mk_evec(bcx.tcx(),\n+                               {ty: vt.unit_ty, mutbl: ast::m_mutbl},\n+                               ty::vstore_fixed(count));\n+    let llfixed_ty = T_ptr(type_of::type_of(bcx.ccx(), fixed_ty));\n+    let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n+    add_clean(bcx, llfixed_casted, fixed_ty);\n+\n+    // Generate the content into the backing array.\n+    let bcx = write_content(bcx, &vt, vstore_expr,\n+                            content_expr, SaveIn(llfixed));\n+\n+    // Finally, create the slice pair itself.\n+    match dest {\n+        Ignore => {}\n+        SaveIn(lldest) => {\n+            Store(bcx, llfixed, GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n+            let lllen = Mul(bcx, llcount, vt.llunit_size);\n+            Store(bcx, lllen, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n+        }\n     }\n \n-    let vec_ty = node_id_type(bcx, id);\n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n-    let unit_sz = llsize_of(ccx, llunitty);\n+    return bcx;\n+}\n+\n+fn trans_lit_str(bcx: block,\n+                 lit_expr: @ast::expr,\n+                 lit_str: @~str,\n+                 dest: Dest) -> block\n+{\n+    //!\n+    //\n+    // Literal strings translate to slices into static memory.  This is\n+    // different from trans_slice_vstore() above because it does need to copy\n+    // the content anywhere.\n+\n+    debug!(\"trans_lit_str(lit_expr=%s, dest=%s)\",\n+           bcx.expr_to_str(lit_expr),\n+           dest.to_str(bcx.ccx()));\n+    let _indenter = indenter();\n+\n+    match dest {\n+        Ignore => bcx,\n+        SaveIn(lldest) => {\n+            let bytes = lit_str.len() + 1; // count null-terminator too\n+            let llbytes = C_uint(bcx.ccx(), bytes);\n+            let llcstr = C_cstr(bcx.ccx(), *lit_str);\n+            let llcstr = llvm::LLVMConstPointerCast(llcstr, T_ptr(T_i8()));\n+            Store(bcx, llcstr, GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n+            Store(bcx, llbytes, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n+            bcx\n+        }\n+    }\n+}\n+\n+\n+fn trans_uniq_or_managed_vstore(bcx: block,\n+                            heap: heap,\n+                            vstore_expr: @ast::expr,\n+                            content_expr: @ast::expr) -> DatumBlock\n+{\n+    //!\n+    //\n+    // @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n+    // appropriate heap and write the array elements into them.\n+\n+    debug!(\"trans_uniq_or_managed_vstore(vstore_expr=%s, heap=%?)\",\n+           bcx.expr_to_str(vstore_expr), heap);\n+    let _indenter = indenter();\n+\n+    let vt = vec_types_from_expr(bcx, vstore_expr);\n+    let count = elements_required(bcx, content_expr);\n+\n+    let Result {bcx, val} = alloc_vec(bcx, vt.unit_ty, count, heap);\n+    add_clean_free(bcx, val, heap);\n+    let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n+\n+    debug!(\"alloc_vec() returned val=%s, dataptr=%s\",\n+           bcx.val_str(val), bcx.val_str(dataptr));\n+\n+    let bcx = write_content(bcx, &vt, vstore_expr,\n+                            content_expr, SaveIn(dataptr));\n+\n+    revoke_clean(bcx, val);\n \n-    let mut {bcx, val, dataptr} =\n-        match vst {\n-          ast::vstore_fixed(_) => {\n-            // Destination should be pre-allocated for us.\n-            let v = match dest {\n-              base::save_in(v) => {\n-                PointerCast(bcx, v, T_ptr(llunitty))\n-              }\n-              _ => {\n-                bcx.ccx().sess.bug(~\"bad dest for vstore_fixed \\\n-                                    in tvec::trans_evec\");\n-              }\n-            };\n-            {bcx: bcx, val: v, dataptr: v}\n-          }\n-          ast::vstore_slice(_) => {\n-            // Make a fake type to use for the cleanup\n-            let ty = ty::mk_evec(bcx.tcx(),\n-                                 {ty: unit_ty, mutbl: ast::m_mutbl},\n-                                 ty::vstore_fixed(count));\n-            let llty = T_ptr(type_of::type_of(bcx.ccx(), ty));\n-\n-            let n = C_uint(ccx, count);\n-            let vp = base::arrayalloca(bcx, llunitty, n);\n-            // Cast to the fake type we told cleanup to expect.\n-            let vp0 = BitCast(bcx, vp, llty);\n-            add_clean(bcx, vp0, ty);\n-\n-            let len = Mul(bcx, n, unit_sz);\n-\n-            let p = base::alloca(bcx, T_struct(~[T_ptr(llunitty),\n-                                                ccx.int_type]));\n-            Store(bcx, vp, GEPi(bcx, p, [0u, abi::slice_elt_base]));\n-            Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]));\n-\n-            {bcx: bcx, val: p, dataptr: vp}\n-          }\n-          ast::vstore_uniq => {\n-            let {bcx, val} = alloc_vec(bcx, unit_ty, count, heap_exchange);\n-            add_clean_free(bcx, val, heap_exchange);\n-            let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n-            {bcx: bcx, val: val, dataptr: dataptr}\n-          }\n-          ast::vstore_box => {\n-            let {bcx, val} = alloc_vec(bcx, unit_ty, count, heap_shared);\n-            add_clean_free(bcx, val, heap_shared);\n-            let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n-            {bcx: bcx, val: val, dataptr: dataptr}\n-          }\n-        };\n-\n-\n-    // Store the individual elements.\n-    let mut i = 0u, temp_cleanups = ~[val];\n-    debug!(\"trans_evec: v: %s, dataptr: %s\",\n-           val_str(ccx.tn, val),\n-           val_str(ccx.tn, dataptr));\n-    match elements {\n-        individual_evec(args) => {\n-            for vec::each(args) |e| {\n-                let lleltptr = InBoundsGEP(bcx, dataptr, ~[C_uint(ccx, i)]);\n-                bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n-                add_clean_temp_mem(bcx, lleltptr, unit_ty);\n-                vec::push(temp_cleanups, lleltptr);\n-                i += 1u;\n+    return immediate_rvalue_bcx(bcx, val, vt.vec_ty);\n+}\n+\n+fn write_content(bcx: block,\n+                 vt: &VecTypes,\n+                 vstore_expr: @ast::expr,\n+                 content_expr: @ast::expr,\n+                 dest: Dest) -> block\n+{\n+    let _icx = bcx.insn_ctxt(\"tvec::write_content\");\n+    let mut bcx = bcx;\n+\n+    debug!(\"write_content(vt=%s, dest=%s, vstore_expr=%?)\",\n+           vt.to_str(bcx.ccx()),\n+           dest.to_str(bcx.ccx()),\n+           bcx.expr_to_str(vstore_expr));\n+    let _indenter = indenter();\n+\n+    match content_expr.node {\n+        ast::expr_lit(@{node: ast::lit_str(s), span: _}) => {\n+            match dest {\n+                Ignore => {\n+                    return bcx;\n+                }\n+                SaveIn(lldest) => {\n+                    let bytes = s.len() + 1; // copy null-terminator too\n+                    let llbytes = C_uint(bcx.ccx(), bytes);\n+                    let llcstr = C_cstr(bcx.ccx(), *s);\n+                    base::call_memmove(bcx, lldest, llcstr, llbytes);\n+                    return bcx;\n+                }\n             }\n         }\n-        repeating_evec(e, len) => {\n-            // We make temporary space in the hope that this will be\n-            // friendlier to LLVM alias analysis.\n-            let lltmpspace = base::alloca(bcx, llunitty);\n-            bcx = base::trans_expr_save_in(bcx, e, lltmpspace);\n-            add_clean_temp_mem(bcx, lltmpspace, unit_ty);\n-            vec::push(temp_cleanups, lltmpspace);\n-            for len.timesi |i| {\n-                let lleltptr = InBoundsGEP(bcx, dataptr, ~[C_uint(ccx, i)]);\n-                if i == len - 1 {\n-                    // Move the last one in.\n-                    bcx = move_val(bcx, INIT, lleltptr,\n-                                   lval_owned(bcx, lltmpspace), unit_ty);\n-                } else {\n-                    // Copy all but the last one in.\n-                    let llval = load_if_immediate(bcx, lltmpspace, unit_ty);\n-                    bcx = copy_val(bcx, INIT, lleltptr, llval, unit_ty);\n+        ast::expr_vec(elements, _) => {\n+            match dest {\n+                Ignore => {\n+                    for elements.each |element| {\n+                        bcx = expr::trans_into(bcx, element, Ignore);\n+                    }\n+                }\n+\n+                SaveIn(lldest) => {\n+                    let mut temp_cleanups = ~[];\n+                    for elements.eachi |i, element| {\n+                        let lleltptr = GEPi(bcx, lldest, [i]);\n+                        debug!(\"writing index %? with lleltptr=%?\",\n+                               i, bcx.val_str(lleltptr));\n+                        bcx = expr::trans_into(bcx, element,\n+                                               SaveIn(lleltptr));\n+                        add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n+                        vec::push(temp_cleanups, lleltptr);\n+                    }\n+                    for vec::each(temp_cleanups) |cleanup| {\n+                        revoke_clean(bcx, cleanup);\n+                    }\n                 }\n-                add_clean_temp_mem(bcx, lleltptr, unit_ty);\n-                vec::push(temp_cleanups, lleltptr);\n             }\n+            return bcx;\n+        }\n+        ast::expr_repeat(element, count_expr, _) => {\n+            match dest {\n+                Ignore => {\n+                    return expr::trans_into(bcx, element, Ignore);\n+                }\n+                SaveIn(lldest) => {\n+                    let count = ty::eval_repeat_count(bcx.tcx(), count_expr,\n+                                                      count_expr.span);\n+                    if count == 0 {\n+                        return bcx;\n+                    }\n+\n+                    let tmpdatum = unpack_datum!(bcx, {\n+                        expr::trans_to_datum(bcx, element)\n+                    });\n+\n+                    let mut temp_cleanups = ~[];\n+\n+                    for uint::range(0, count) |i| {\n+                        let lleltptr = GEPi(bcx, lldest, [i]);\n+                        if i < count - 1 {\n+                            // Copy all but the last one in.\n+                            bcx = tmpdatum.copy_to(bcx, INIT, lleltptr);\n+                        } else {\n+                            // Move the last one in.\n+                            bcx = tmpdatum.move_to(bcx, INIT, lleltptr);\n+                        }\n+                        add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n+                        vec::push(temp_cleanups, lleltptr);\n+                    }\n+\n+                    for vec::each(temp_cleanups) |cleanup| {\n+                        revoke_clean(bcx, cleanup);\n+                    }\n+\n+                    return bcx;\n+                }\n+            }\n+        }\n+        _ => {\n+            bcx.tcx().sess.span_bug(content_expr.span,\n+                                    ~\"Unexpected evec content\");\n         }\n     }\n+}\n \n-    for vec::each(temp_cleanups) |cln| { revoke_clean(bcx, cln); }\n+fn vec_types_from_expr(bcx: block, vec_expr: @ast::expr) -> VecTypes {\n+    let vec_ty = node_id_type(bcx, vec_expr.id);\n+    vec_types(bcx, vec_ty)\n+}\n \n-    match vst {\n-      ast::vstore_fixed(_) => {\n-        // We wrote into the destination in the fixed case.\n-        return bcx;\n-      }\n-      ast::vstore_slice(_) => {\n-        return base::store_in_dest(bcx, Load(bcx, val), dest);\n-      }\n-      _ => {\n-        return base::store_in_dest(bcx, val, dest);\n-      }\n-    }\n+fn vec_types(bcx: block, vec_ty: ty::t) -> VecTypes {\n+    let ccx = bcx.ccx();\n+    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n+    let llunit_ty = type_of::type_of(ccx, unit_ty);\n+    let llunit_size = llsize_of(ccx, llunit_ty);\n+    VecTypes {vec_ty: vec_ty,\n+              unit_ty: unit_ty,\n+              llunit_ty: llunit_ty,\n+              llunit_size: llunit_size}\n }\n \n-fn trans_vstore(bcx: block, e: @ast::expr,\n-                v: ast::vstore, dest: dest) -> block {\n-    match e.node {\n-      ast::expr_lit(@{node: ast::lit_str(s), span: _}) => {\n-        return trans_estr(bcx, s, Some(v), dest);\n-      }\n-      ast::expr_vec(es, _) => {\n-        return trans_evec(bcx, individual_evec(es), v, e.id, dest);\n-      }\n-      ast::expr_repeat(element, count_expr, _) => {\n-        let count = ty::eval_repeat_count(bcx.tcx(), count_expr, e.span);\n-        return trans_evec(bcx, repeating_evec(element, count), v, e.id, dest);\n-      }\n-      _ => {\n-        bcx.sess().span_bug(e.span, ~\"vstore on non-sequence type\");\n-      }\n+fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n+    //! Figure out the number of elements we need to store this content\n+\n+    match content_expr.node {\n+        ast::expr_lit(@{node: ast::lit_str(s), span: _}) => s.len() + 1,\n+        ast::expr_vec(es, _) => es.len(),\n+        ast::expr_repeat(_, count_expr, _) => {\n+            ty::eval_repeat_count(bcx.tcx(), count_expr, content_expr.span)\n+        }\n+        _ => bcx.tcx().sess.span_bug(content_expr.span,\n+                                     ~\"Unexpected evec content\")\n     }\n }\n \n-fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n-    -> (ValueRef, ValueRef) {\n+fn get_base_and_len(bcx: block,\n+                    llval: ValueRef,\n+                    vec_ty: ty::t) -> (ValueRef, ValueRef) {\n+    //!\n+    //\n+    // Converts a vector into the slice pair.  The vector should be stored in\n+    // `llval` which should be either immediate or by-ref as appropriate for\n+    // the vector type.  If you have a datum, you would probably prefer to\n+    // call `Datum::get_base_and_len()` which will handle any conversions for\n+    // you.\n \n-    let ccx = cx.ccx();\n-    let tcx = ccx.tcx;\n-    let vec_ty = ty::type_autoderef(tcx, e_ty);\n-    let unit_ty = ty::sequence_element_type(tcx, vec_ty);\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n-    let unit_sz = llsize_of(ccx, llunitty);\n+    let ccx = bcx.ccx();\n+    let vt = vec_types(bcx, vec_ty);\n \n-    let vstore = match ty::get(vec_ty).struct {\n+    let vstore = match ty::get(vt.vec_ty).struct {\n       ty::ty_estr(vst) | ty::ty_evec(_, vst) => vst,\n       _ => ty::vstore_uniq\n     };\n \n     match vstore {\n-      ty::vstore_fixed(n) => {\n-        let base = GEPi(cx, v, [0u, 0u]);\n-        let n = if ty::type_is_str(e_ty) { n + 1u } else { n };\n-        let len = Mul(cx, C_uint(ccx, n), unit_sz);\n-        (base, len)\n-      }\n-      ty::vstore_slice(_) => {\n-        let base = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_base]));\n-        let len = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_len]));\n-        (base, len)\n-      }\n-      ty::vstore_uniq | ty::vstore_box => {\n-        debug!(\"get_base_and_len: %s\", val_str(ccx.tn, v));\n-        let body = tvec::get_bodyptr(cx, v);\n-        (tvec::get_dataptr(cx, body), tvec::get_fill(cx, body))\n-      }\n+        ty::vstore_fixed(n) => {\n+            let base = GEPi(bcx, llval, [0u, 0u]);\n+            let n = if ty::type_is_str(vec_ty) { n + 1u } else { n };\n+            let len = Mul(bcx, C_uint(ccx, n), vt.llunit_size);\n+            (base, len)\n+        }\n+        ty::vstore_slice(_) => {\n+            let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n+            let len = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n+            (base, len)\n+        }\n+        ty::vstore_uniq | ty::vstore_box => {\n+            let body = tvec::get_bodyptr(bcx, llval);\n+            (tvec::get_dataptr(bcx, body), tvec::get_fill(bcx, body))\n+        }\n     }\n }\n \n-fn trans_estr(bcx: block, s: @~str, vstore: Option<ast::vstore>,\n-              dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::trans_estr\");\n-    if dest == base::ignore { return bcx; }\n-    let ccx = bcx.ccx();\n-\n-    let c = match vstore {\n-      Some(ast::vstore_fixed(_)) => {\n-        // \"hello\"/_  =>  \"hello\"/5  =>  ~[i8 x 6] in llvm\n-        debug!(\"trans_estr: fixed: %s\", *s);\n-        C_postr(*s)\n-      }\n-\n-      Some(ast::vstore_slice(_)) | None => {\n-        // \"hello\"  =>  (*i8, 6u) in llvm\n-        debug!(\"trans_estr: slice '%s'\", *s);\n-        C_estr_slice(ccx, *s)\n-      }\n-\n-      Some(ast::vstore_uniq) => {\n-        let cs = PointerCast(bcx, C_cstr(ccx, *s), T_ptr(T_i8()));\n-        let len = C_uint(ccx, str::len(*s));\n-        let c = Call(bcx, ccx.upcalls.str_new_uniq, ~[cs, len]);\n-        PointerCast(bcx, c,\n-                    T_unique_ptr(T_unique(ccx, T_vec(ccx, T_i8()))))\n-      }\n-\n-      Some(ast::vstore_box) => {\n-        let cs = PointerCast(bcx, C_cstr(ccx, *s), T_ptr(T_i8()));\n-        let len = C_uint(ccx, str::len(*s));\n-        let c = Call(bcx, ccx.upcalls.str_new_shared, ~[cs, len]);\n-        PointerCast(bcx, c,\n-                    T_box_ptr(T_box(ccx, T_vec(ccx, T_i8()))))\n-      }\n-    };\n-\n-    debug!(\"trans_estr: type: %s\", val_str(ccx.tn, c));\n-    base::store_in_dest(bcx, c, dest)\n-}\n-\n-type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> result;\n+type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> Result;\n \n type iter_vec_block = fn(block, ValueRef, ty::t) -> block;\n \n@@ -373,21 +472,21 @@ fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n     let data_end_ptr = pointer_add(bcx, data_ptr, fill);\n \n     // Now perform the iteration.\n-    let header_cx = sub_block(bcx, ~\"iter_vec_loop_header\");\n-    Br(bcx, header_cx.llbb);\n+    let header_bcx = base::sub_block(bcx, ~\"iter_vec_loop_header\");\n+    Br(bcx, header_bcx.llbb);\n     let data_ptr =\n-        Phi(header_cx, val_ty(data_ptr), ~[data_ptr], ~[bcx.llbb]);\n+        Phi(header_bcx, val_ty(data_ptr), ~[data_ptr], ~[bcx.llbb]);\n     let not_yet_at_end =\n-        ICmp(header_cx, lib::llvm::IntULT, data_ptr, data_end_ptr);\n-    let body_cx = sub_block(header_cx, ~\"iter_vec_loop_body\");\n-    let next_cx = sub_block(header_cx, ~\"iter_vec_next\");\n-    CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n-    let body_cx = f(body_cx, data_ptr, unit_ty);\n-    AddIncomingToPhi(data_ptr, InBoundsGEP(body_cx, data_ptr,\n+        ICmp(header_bcx, lib::llvm::IntULT, data_ptr, data_end_ptr);\n+    let body_bcx = base::sub_block(header_bcx, ~\"iter_vec_loop_body\");\n+    let next_bcx = base::sub_block(header_bcx, ~\"iter_vec_next\");\n+    CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n+    let body_bcx = f(body_bcx, data_ptr, unit_ty);\n+    AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n                                            ~[C_int(bcx.ccx(), 1)]),\n-                     body_cx.llbb);\n-    Br(body_cx, header_cx.llbb);\n-    return next_cx;\n+                     body_bcx.llbb);\n+    Br(body_bcx, header_bcx.llbb);\n+    return next_bcx;\n \n }\n "}, {"sha": "40bf644c6266f63a58b582c2e7354728d792dbc6", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -7,25 +7,27 @@ use std::map::hashmap;\n \n export type_of;\n export type_of_dtor;\n+export type_of_explicit_arg;\n export type_of_explicit_args;\n export type_of_fn_from_ty;\n export type_of_fn;\n export type_of_glue_fn;\n export type_of_non_gc_box;\n export type_of_rooted;\n \n-fn type_of_explicit_args(cx: @crate_ctxt,\n-                         inputs: ~[ty::arg]) -> ~[TypeRef] {\n-    do vec::map(inputs) |arg| {\n-        let arg_ty = arg.ty;\n-        let llty = type_of(cx, arg_ty);\n-        match ty::resolved_mode(cx.tcx, arg.mode) {\n-          ast::by_val => llty,\n-          _ => T_ptr(llty)\n-        }\n+fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n+    let arg_ty = arg.ty;\n+    let llty = type_of(ccx, arg_ty);\n+    match ty::resolved_mode(ccx.tcx, arg.mode) {\n+        ast::by_val => llty,\n+        _ => T_ptr(llty)\n     }\n }\n \n+fn type_of_explicit_args(ccx: @crate_ctxt, inputs: ~[ty::arg]) -> ~[TypeRef] {\n+    inputs.map(|arg| type_of_explicit_arg(ccx, arg))\n+}\n+\n fn type_of_fn(cx: @crate_ctxt, inputs: ~[ty::arg],\n               output: ty::t) -> TypeRef {\n     let mut atys: ~[TypeRef] = ~[];\n@@ -145,7 +147,10 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n             let mt_ty = f.mt.ty;\n             vec::push(tys, type_of(cx, mt_ty));\n         }\n-        T_struct(tys)\n+\n+        // n.b.: introduce an extra layer of indirection to match\n+        // structs\n+        T_struct(~[T_struct(tys)])\n       }\n       ty::ty_fn(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n       ty::ty_trait(_, _, _) => T_opaque_trait(cx),\n@@ -188,12 +193,13 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n             type_of(cx, t)\n         };\n \n+        // include a byte flag if there is a dtor so that we know when we've\n+        // been dropped\n         if ty::ty_dtor(cx.tcx, did) != None {\n-            // resource type\n-            tys = ~[T_i8(), T_struct(tys)];\n+            common::set_struct_body(llty, ~[T_struct(tys), T_i8()]);\n+        } else {\n+            common::set_struct_body(llty, ~[T_struct(tys)]);\n         }\n-\n-        common::set_struct_body(llty, tys);\n       }\n       _ => ()\n     }"}, {"sha": "8048a34c219d1a7d379045501f252ecd50212170", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -40,7 +40,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       None => ()\n     }\n     let fn_id_loc = if fn_id.crate == local_crate { fn_id }\n-                    else { base::maybe_instantiate_inline(ccx, fn_id) };\n+                    else { inline::maybe_instantiate_inline(ccx, fn_id) };\n     // Conservatively assume full use for recursive loops\n     ccx.type_use_cache.insert(fn_id, vec::from_elem(n_tps, 3u));\n \n@@ -82,25 +82,23 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n                                  abi, _) => {\n         if abi == foreign_abi_rust_intrinsic {\n             let flags = match cx.ccx.sess.str_of(i.ident) {\n-              ~\"size_of\" |  ~\"pref_align_of\" | ~\"min_align_of\" |\n-              ~\"init\" |  ~\"reinterpret_cast\" |\n-              ~\"move_val\" | ~\"move_val_init\" => {\n-                use_repr\n-              }\n-              ~\"get_tydesc\" | ~\"needs_drop\" => {\n-                use_tydesc\n-              }\n-              ~\"atomic_xchg\"     | ~\"atomic_xadd\"     | ~\"atomic_xsub\" |\n-              ~\"atomic_xchg_acq\" | ~\"atomic_xadd_acq\" | ~\"atomic_xsub_acq\" |\n-              ~\"atomic_xchg_rel\" | ~\"atomic_xadd_rel\" | ~\"atomic_xsub_rel\" =>\n-              { 0u }\n-              ~\"visit_tydesc\" | ~\"forget\" | ~\"addr_of\" |\n-              ~\"frame_address\" | ~\"morestack_addr\" => {\n-                0u\n-              }\n-              // would be cool to make these an enum instead of strings!\n-              _ => fail fmt!(\"unknown intrinsic in type_use %?\",\n-                             cx.ccx.sess.str_of(i.ident))\n+                ~\"size_of\"  | ~\"pref_align_of\"    | ~\"min_align_of\" |\n+                ~\"init\"     | ~\"reinterpret_cast\" |\n+                ~\"move_val\" | ~\"move_val_init\" => use_repr,\n+\n+                ~\"get_tydesc\" | ~\"needs_drop\" => use_tydesc,\n+\n+                ~\"atomic_xchg\"     | ~\"atomic_xadd\"     |\n+                ~\"atomic_xsub\"     | ~\"atomic_xchg_acq\" |\n+                ~\"atomic_xadd_acq\" | ~\"atomic_xsub_acq\" |\n+                ~\"atomic_xchg_rel\" | ~\"atomic_xadd_rel\" |\n+                ~\"atomic_xsub_rel\" => 0,\n+\n+                ~\"visit_tydesc\"  | ~\"forget\" | ~\"addr_of\" |\n+                ~\"frame_address\" | ~\"morestack_addr\" => 0,\n+\n+                // would be cool to make these an enum instead of strings!\n+                _ => fail ~\"unknown intrinsic in type_use\"\n             };\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }\n@@ -288,7 +286,7 @@ fn handle_body(cx: ctx, body: blk) {\n             }\n         },\n         visit_item: |_i, _cx, _v| { },\n-        .. *visit::default_visitor()\n+        ..*visit::default_visitor()\n     });\n     v.visit_block(body, cx, v);\n }"}, {"sha": "6ab91c4a1d79727f0f5679676cb1ff86144addbe", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -4,52 +4,41 @@ use common::*;\n use build::*;\n use base::*;\n use shape::llsize_of;\n+use datum::immediate_rvalue;\n \n export make_free_glue, autoderef, duplicate;\n \n-fn make_free_glue(bcx: block, vptrptr: ValueRef, t: ty::t)\n+fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n     -> block {\n     let _icx = bcx.insn_ctxt(\"uniq::make_free_glue\");\n-    let vptr = Load(bcx, vptrptr);\n-    do with_cond(bcx, IsNotNull(bcx, vptr)) |bcx| {\n-        let content_ty = content_ty(t);\n-        let body_ptr = opaque_box_body(bcx, content_ty, vptr);\n-        let bcx = drop_ty(bcx, body_ptr, content_ty);\n-        trans_unique_free(bcx, vptr)\n+    let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n+\n+    let not_null = IsNotNull(bcx, box_datum.val);\n+    do with_cond(bcx, not_null) |bcx| {\n+        let body_datum = box_datum.box_body(bcx);\n+        let bcx = glue::drop_ty(bcx, body_datum.to_ref_llval(bcx),\n+                                body_datum.ty);\n+        glue::trans_unique_free(bcx, box_datum.val)\n     }\n }\n \n-fn content_ty(t: ty::t) -> ty::t {\n-    match ty::get(t).struct {\n-      ty::ty_uniq({ty: ct, _}) => ct,\n-      _ => core::unreachable()\n-    }\n-}\n+fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n+    let _icx = bcx.insn_ctxt(\"uniq::duplicate\");\n \n-fn autoderef(bcx: block, v: ValueRef, t: ty::t) -> {v: ValueRef, t: ty::t} {\n-    let content_ty = content_ty(t);\n-    let v = opaque_box_body(bcx, content_ty, v);\n-    return {v: v, t: content_ty};\n-}\n+    // Load the body of the source (*src)\n+    let src_datum = immediate_rvalue(src_box, src_ty);\n+    let body_datum = src_datum.box_body(bcx);\n \n-fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n-    let _icx = bcx.insn_ctxt(\"uniq::duplicate\");\n-    let content_ty = content_ty(t);\n+    // Malloc space in exchange heap and copy src into it\n     let {bcx: bcx, box: dst_box, body: dst_body} =\n-        malloc_unique(bcx, content_ty);\n-\n-    let src_box = v;\n-    let src_body = opaque_box_body(bcx, content_ty, src_box);\n-    let src_body = load_if_immediate(bcx, src_body, content_ty);\n-    debug!(\"ST: %?\", val_str(bcx.ccx().tn, src_body));\n-    debug!(\"DT: %?\", val_str(bcx.ccx().tn, dst_body));\n-    let bcx = copy_val(bcx, INIT, dst_body, src_body, content_ty);\n+        malloc_unique(bcx, body_datum.ty);\n+    body_datum.copy_to(bcx, datum::INIT, dst_body);\n \n+    // Copy the type descriptor\n     let src_tydesc_ptr = GEPi(bcx, src_box,\n                               [0u, back::abi::box_field_tydesc]);\n     let dst_tydesc_ptr = GEPi(bcx, dst_box,\n                               [0u, back::abi::box_field_tydesc]);\n-\n     let td = Load(bcx, src_tydesc_ptr);\n     Store(bcx, td, dst_tydesc_ptr);\n "}, {"sha": "85ef0797437ea68c271fb1fae4ea2e9b8d8264df", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 203, "deletions": 25, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -11,7 +11,8 @@ use syntax::ast_util;\n use syntax::ast_util::{is_local, local_def, new_def_hash};\n use syntax::codemap::span;\n use metadata::csearch;\n-use util::ppaux::{region_to_str, explain_region, vstore_to_str};\n+use util::ppaux::{region_to_str, explain_region, vstore_to_str,\n+                  note_and_explain_region};\n use middle::lint;\n use middle::lint::{get_lint_level, allow};\n use syntax::ast::*;\n@@ -36,12 +37,13 @@ export def_has_ty_params;\n export expr_has_ty_params;\n export expr_ty;\n export expr_ty_params_and_ty;\n-export expr_is_lval;\n+export expr_is_lval, expr_kind;\n+export ExprKind, LvalueExpr, RvalueDatumExpr, RvalueDpsExpr, RvalueStmtExpr;\n export field_ty;\n export fold_ty, fold_sty_to_ty, fold_region, fold_regions;\n export fold_regions_and_ty, walk_regions_and_ty;\n export field;\n-export field_idx;\n+export field_idx, field_idx_strict;\n export get_field;\n export get_fields;\n export get_element_type;\n@@ -120,7 +122,7 @@ export kind_is_owned;\n export proto_kind, kind_lteq, type_kind;\n export operators;\n export type_err, terr_vstore_kind;\n-export type_err_to_str;\n+export type_err_to_str, note_and_explain_type_err;\n export expected_found;\n export type_needs_drop;\n export type_is_empty;\n@@ -2382,7 +2384,7 @@ fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     match smallintmap::find(*cx.node_types, id as uint) {\n        Some(t) => t,\n        None => cx.sess.bug(\n-           fmt!(\"node_id_to_type: unbound node ID %s\",\n+           fmt!(\"node_id_to_type: no type for node `%s`\",\n                 ast_map::node_id_to_str(cx.items, id,\n                                         cx.sess.parse_sess.interner)))\n     }\n@@ -2535,13 +2537,156 @@ fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n     }\n }\n \n-fn expr_is_lval(method_map: typeck::method_map, e: @ast::expr) -> bool {\n-    match e.node {\n-      ast::expr_path(_) | ast::expr_unary(ast::deref, _) => true,\n-      ast::expr_field(_, _, _) | ast::expr_index(_, _) => {\n-        !method_map.contains_key(e.id)\n-      }\n-      _ => false\n+fn resolve_expr(tcx: ctxt, expr: @ast::expr) -> ast::def {\n+    match tcx.def_map.find(expr.id) {\n+        Some(def) => def,\n+        None => {\n+            tcx.sess.span_bug(expr.span, fmt!(\n+                \"No def-map entry for expr %?\", expr.id));\n+        }\n+    }\n+}\n+\n+fn expr_is_lval(tcx: ctxt,\n+                method_map: typeck::method_map,\n+                e: @ast::expr) -> bool {\n+    match expr_kind(tcx, method_map, e) {\n+        LvalueExpr => true,\n+        RvalueDpsExpr | RvalueDatumExpr | RvalueStmtExpr => false\n+    }\n+}\n+\n+/// We categorize expressions into three kinds.  The distinction between\n+/// lvalue/rvalue is fundamental to the language.  The distinction between the\n+/// two kinds of rvalues is an artifact of trans which reflects how we will\n+/// generate code for that kind of expression.  See trans/expr.rs for more\n+/// information.\n+enum ExprKind {\n+    LvalueExpr,\n+    RvalueDpsExpr,\n+    RvalueDatumExpr,\n+    RvalueStmtExpr\n+}\n+\n+fn expr_kind(tcx: ctxt,\n+             method_map: typeck::method_map,\n+             expr: @ast::expr) -> ExprKind {\n+    if method_map.contains_key(expr.id) {\n+        // Overloaded operations are generally calls, and hence they are\n+        // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n+        // exception, as its result is always unit.\n+        return match expr.node {\n+            ast::expr_assign_op(*) => RvalueStmtExpr,\n+            _ => RvalueDpsExpr\n+        };\n+    }\n+\n+    match expr.node {\n+        ast::expr_path(*) => {\n+            match resolve_expr(tcx, expr) {\n+                ast::def_fn(*) | ast::def_static_method(*) |\n+                ast::def_variant(*) => RvalueDpsExpr,\n+\n+                // Note: there is actually a good case to be made that\n+                // def_args, particularly those of immediate type, ought to\n+                // considered rvalues.\n+                ast::def_const(*) |\n+                ast::def_binding(*) |\n+                ast::def_upvar(*) |\n+                ast::def_arg(*) |\n+                ast::def_local(*) |\n+                ast::def_self(*) => LvalueExpr,\n+\n+                move def => {\n+                    tcx.sess.span_bug(expr.span, fmt!(\n+                        \"Uncategorized def for expr %?: %?\",\n+                        expr.id, def));\n+                }\n+            }\n+        }\n+\n+        ast::expr_unary(ast::deref, _) |\n+        ast::expr_field(*) |\n+        ast::expr_index(*) => {\n+            LvalueExpr\n+        }\n+\n+        ast::expr_call(*) |\n+        ast::expr_rec(*) |\n+        ast::expr_struct(*) |\n+        ast::expr_tup(*) |\n+        ast::expr_if(*) |\n+        ast::expr_match(*) |\n+        ast::expr_fn(*) |\n+        ast::expr_fn_block(*) |\n+        ast::expr_loop_body(*) |\n+        ast::expr_do_body(*) |\n+        ast::expr_block(*) |\n+        ast::expr_copy(*) |\n+        ast::expr_unary_move(*) |\n+        ast::expr_repeat(*) |\n+        ast::expr_lit(@{node: lit_str(_), _}) |\n+        ast::expr_vstore(_, ast::vstore_slice(_)) |\n+        ast::expr_vstore(_, ast::vstore_fixed(_)) |\n+        ast::expr_vec(*) => {\n+            RvalueDpsExpr\n+        }\n+\n+        ast::expr_cast(*) => {\n+            match smallintmap::find(*tcx.node_types, expr.id as uint) {\n+                Some(t) => {\n+                    if ty::type_is_immediate(t) {\n+                        RvalueDatumExpr\n+                    } else {\n+                        RvalueDpsExpr\n+                    }\n+                }\n+                None => {\n+                    // Technically, it should not happen that the expr is not\n+                    // present within the table.  However, it DOES happen\n+                    // during type check, because the final types from the\n+                    // expressions are not yet recorded in the tcx.  At that\n+                    // time, though, we are only interested in knowing lvalue\n+                    // vs rvalue.  It would be better to base this decision on\n+                    // the AST type in cast node---but (at the time of this\n+                    // writing) it's not easy to distinguish casts to traits\n+                    // from other casts based on the AST.  This should be\n+                    // easier in the future, when casts to traits would like\n+                    // like @Foo, ~Foo, or &Foo.\n+                    RvalueDatumExpr\n+                }\n+            }\n+        }\n+\n+        ast::expr_break(*) |\n+        ast::expr_again(*) |\n+        ast::expr_ret(*) |\n+        ast::expr_log(*) |\n+        ast::expr_fail(*) |\n+        ast::expr_assert(*) |\n+        ast::expr_while(*) |\n+        ast::expr_loop(*) |\n+        ast::expr_assign(*) |\n+        ast::expr_move(*) |\n+        ast::expr_swap(*) |\n+        ast::expr_assign_op(*) => {\n+            RvalueStmtExpr\n+        }\n+\n+        ast::expr_lit(_) | // Note: lit_str is carved out above\n+        ast::expr_unary(*) |\n+        ast::expr_addr_of(*) |\n+        ast::expr_binary(*) |\n+        ast::expr_vstore(_, ast::vstore_box) |\n+        ast::expr_vstore(_, ast::vstore_uniq) => {\n+            RvalueDatumExpr\n+        }\n+\n+        ast::expr_mac(*) => {\n+            tcx.sess.span_bug(\n+                expr.span,\n+                ~\"macro expression remains after expansion\");\n+        }\n     }\n }\n \n@@ -2553,12 +2698,21 @@ fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n     }\n }\n \n-fn field_idx(id: ast::ident, fields: ~[field]) -> Option<uint> {\n+fn field_idx(id: ast::ident, fields: &[field]) -> Option<uint> {\n     let mut i = 0u;\n     for fields.each |f| { if f.ident == id { return Some(i); } i += 1u; }\n     return None;\n }\n \n+fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field]) -> uint {\n+    let mut i = 0u;\n+    for fields.each |f| { if f.ident == id { return i; } i += 1u; }\n+    tcx.sess.bug(fmt!(\n+        \"No field named `%s` found in the list of fields `%?`\",\n+        tcx.sess.str_of(id),\n+        fields.map(|f| tcx.sess.str_of(f.ident))));\n+}\n+\n fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n     match vec::find(get_fields(rec_ty), |f| f.ident == id) {\n       Some(f) => f,\n@@ -2730,6 +2884,15 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n }\n \n fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n+    /*!\n+     *\n+     * Explains the source of a type err in a short,\n+     * human readable way.  This is meant to be placed in\n+     * parentheses after some larger message.  You should\n+     * also invoke `note_and_explain_type_err()` afterwards\n+     * to present additional details, particularly when\n+     * it comes to lifetime-related errors. */\n+\n     fn terr_vstore_kind_to_str(k: terr_vstore_kind) -> ~str {\n         match k {\n             terr_vec => ~\"[]\",\n@@ -2795,20 +2958,14 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         fmt!(\"expected argument mode %s, but found %s\",\n              mode_to_str(values.expected), mode_to_str(values.found))\n       }\n-      terr_regions_does_not_outlive(subregion, superregion) => {\n-        fmt!(\"%s does not necessarily outlive %s\",\n-                    explain_region(cx, superregion),\n-                    explain_region(cx, subregion))\n+      terr_regions_does_not_outlive(*) => {\n+        fmt!(\"lifetime mismatch\")\n       }\n-      terr_regions_not_same(region1, region2) => {\n-        fmt!(\"%s is not the same as %s\",\n-                    explain_region(cx, region1),\n-                    explain_region(cx, region2))\n+      terr_regions_not_same(*) => {\n+        fmt!(\"lifetimes are not the same\")\n       }\n-      terr_regions_no_overlap(region1, region2) => {\n-        fmt!(\"%s does not intersect %s\",\n-                    explain_region(cx, region1),\n-                    explain_region(cx, region2))\n+      terr_regions_no_overlap(*) => {\n+        fmt!(\"lifetimes do not intersect\")\n       }\n       terr_vstores_differ(k, values) => {\n         fmt!(\"%s storage differs: expected %s but found %s\",\n@@ -2835,6 +2992,27 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n     }\n }\n \n+fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n+    match *err {\n+        terr_regions_does_not_outlive(subregion, superregion) => {\n+            note_and_explain_region(cx, ~\"\", subregion, ~\"...\");\n+            note_and_explain_region(cx, ~\"...does not necessarily outlive \",\n+                                    superregion, ~\"\");\n+        }\n+        terr_regions_not_same(region1, region2) => {\n+            note_and_explain_region(cx, ~\"\", region1, ~\"...\");\n+            note_and_explain_region(cx, ~\"...is not the same lifetime as \",\n+                                    region2, ~\"\");\n+        }\n+        terr_regions_no_overlap(region1, region2) => {\n+            note_and_explain_region(cx, ~\"\", region1, ~\"...\");\n+            note_and_explain_region(cx, ~\"...does not overlap \",\n+                                    region2, ~\"\");\n+        }\n+        _ => {}\n+    }\n+}\n+\n fn def_has_ty_params(def: ast::def) -> bool {\n     match def {\n       ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_class(_, _)"}, {"sha": "3f4ec2616988c3c38399d0cda191029cf37f8709", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -225,12 +225,13 @@ fn require_same_types(\n     }\n \n     match infer::mk_eqty(l_infcx, t1_is_expected, span, t1, t2) {\n-      result::Ok(()) => true,\n-      result::Err(ref terr) => {\n-        l_tcx.sess.span_err(span, msg() + ~\": \" +\n-            ty::type_err_to_str(l_tcx, terr));\n-        false\n-      }\n+        result::Ok(()) => true,\n+        result::Err(ref terr) => {\n+            l_tcx.sess.span_err(span, msg() + ~\": \" +\n+                                ty::type_err_to_str(l_tcx, terr));\n+            ty::note_and_explain_type_err(l_tcx, terr);\n+            false\n+        }\n     }\n }\n "}, {"sha": "d74bf4f208ef964d19b9f881c7ac2eaeb5a226cc", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -667,6 +667,7 @@ impl @fn_ctxt {\n                  self.infcx().ty_to_str(e),\n                  self.infcx().ty_to_str(a),\n                  ty::type_err_to_str(self.ccx.tcx, err)));\n+        ty::note_and_explain_type_err(self.ccx.tcx, err);\n     }\n \n     fn mk_subty(a_is_expected: bool, span: span,\n@@ -2049,29 +2050,36 @@ fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n \n fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     let mut bot = false;\n+    let tcx = fcx.ccx.tcx;\n \n-    let t = ty::mk_var(fcx.ccx.tcx, fcx.inh.locals.get(local.node.id));\n+    let t = ty::mk_var(tcx, fcx.inh.locals.get(local.node.id));\n     fcx.write_ty(local.node.id, t);\n+\n+    let is_lvalue;\n     match local.node.init {\n-      Some(init) => {\n-        bot = check_decl_initializer(fcx, local.node.id, init);\n-      }\n-      _ => {/* fall through */ }\n+        Some(init) => {\n+            bot = check_decl_initializer(fcx, local.node.id, init);\n+            is_lvalue = ty::expr_is_lval(tcx, fcx.ccx.method_map, init.expr);\n+        }\n+        _ => {\n+            is_lvalue = true;\n+        }\n     }\n \n     let region =\n-        ty::re_scope(fcx.ccx.tcx.region_map.get(local.node.id));\n+        ty::re_scope(tcx.region_map.get(local.node.id));\n     let pcx = {\n         fcx: fcx,\n-        map: pat_id_map(fcx.ccx.tcx.def_map, local.node.pat),\n+        map: pat_id_map(tcx.def_map, local.node.pat),\n         alt_region: region,\n         block_region: region,\n-        pat_region: region,\n-        matching_lvalue: true, // FIXME(#3235) Make this more flexible\n-        has_guard: false,\n-        mut ever_bound_by_ref: false,\n     };\n     alt::check_pat(pcx, local.node.pat, t);\n+    let has_guard = false;\n+    alt::check_legality_of_move_bindings(fcx,\n+                                         is_lvalue,\n+                                         has_guard,\n+                                         [local.node.pat]);\n     return bot;\n }\n "}, {"sha": "0282a9d78c4dfd7c20edfa38458ed2d59493cfc5", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 72, "deletions": 38, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -1,4 +1,6 @@\n use syntax::print::pprust;\n+use syntax::ast_util::{walk_pat};\n+use pat_util::{pat_is_variant};\n \n fn check_alt(fcx: @fn_ctxt,\n              expr: @ast::expr,\n@@ -9,7 +11,7 @@ fn check_alt(fcx: @fn_ctxt,\n \n     let pattern_ty = fcx.infcx().next_ty_var();\n     bot = check_expr_with(fcx, discrim, pattern_ty);\n-    let is_lvalue = ty::expr_is_lval(fcx.ccx.method_map, discrim);\n+    let is_lvalue = ty::expr_is_lval(tcx, fcx.ccx.method_map, discrim);\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n@@ -18,17 +20,16 @@ fn check_alt(fcx: @fn_ctxt,\n             fcx: fcx,\n             map: pat_id_map(tcx.def_map, arm.pats[0]),\n             alt_region: ty::re_scope(expr.id),\n-            block_region: ty::re_scope(arm.body.node.id),\n-            pat_region: ty::re_scope(expr.id),\n-            // The following three fields determine whether 'move' is allowed.\n-            matching_lvalue: is_lvalue,\n-            has_guard: arm.guard.is_some(),\n-            // Each arm is freshly allowed to decide whether it can 'move'.\n-            mut ever_bound_by_ref: false,\n+            block_region: ty::re_scope(arm.body.node.id)\n         };\n \n         for arm.pats.each |p| { check_pat(pcx, p, pattern_ty);}\n+        check_legality_of_move_bindings(fcx,\n+                                        is_lvalue,\n+                                        arm.guard.is_some(),\n+                                        arm.pats);\n     }\n+\n     // Now typecheck the blocks.\n     let mut result_ty = fcx.infcx().next_ty_var();\n     let mut arm_non_bot = false;\n@@ -47,20 +48,72 @@ fn check_alt(fcx: @fn_ctxt,\n     return bot;\n }\n \n+fn check_legality_of_move_bindings(fcx: @fn_ctxt,\n+                                   is_lvalue: bool,\n+                                   has_guard: bool,\n+                                   pats: &[@ast::pat])\n+{\n+    let tcx = fcx.tcx();\n+    let def_map = tcx.def_map;\n+    let mut by_ref = None;\n+    let mut any_by_move = false;\n+    for pats.each |pat| {\n+        do pat_util::pat_bindings(def_map, pat) |bm, _id, span, _path| {\n+            match bm {\n+                ast::bind_by_ref(_) | ast::bind_by_implicit_ref => {\n+                    by_ref = Some(span);\n+                }\n+                ast::bind_by_move => {\n+                    any_by_move = true;\n+                }\n+                _ => { }\n+            }\n+        }\n+    }\n+\n+    if !any_by_move { return; } // pointless micro-optimization\n+    for pats.each |pat| {\n+        do walk_pat(pat) |p| {\n+            if !pat_is_variant(def_map, p) {\n+                match p.node {\n+                    ast::pat_ident(ast::bind_by_move, _, sub) => {\n+                        // check legality of moving out of the enum\n+                        if sub.is_some() {\n+                            tcx.sess.span_err(\n+                                p.span,\n+                                ~\"cannot bind by-move with sub-bindings\");\n+                        } else if has_guard {\n+                            tcx.sess.span_err(\n+                                p.span,\n+                                ~\"cannot bind by-move into a pattern guard\");\n+                        } else if by_ref.is_some() {\n+                            tcx.sess.span_err(\n+                                p.span,\n+                                ~\"cannot bind by-move and by-ref \\\n+                                  in the same pattern\");\n+                            tcx.sess.span_note(\n+                                by_ref.get(),\n+                                ~\"by-ref binding occurs here\");\n+                        } else if is_lvalue {\n+                            tcx.sess.span_err(\n+                                p.span,\n+                                ~\"cannot bind by-move when \\\n+                                  matching an lvalue\");\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n type pat_ctxt = {\n     fcx: @fn_ctxt,\n     map: pat_id_map,\n-    alt_region: ty::region,\n-    block_region: ty::region,\n-    /* Equal to either alt_region or block_region. */\n-    pat_region: ty::region,\n-    /* Moving out is only permitted when matching rvalues. */\n-    matching_lvalue: bool,\n-    /* Moving out is not permitted with guards. */\n-    has_guard: bool,\n-    /* If a pattern binding binds by-reference ever, then binding by-move in\n-     * the same arm is disallowed (no \"ref x @ some(move y)\", etc etc). */\n-    mut ever_bound_by_ref: bool,\n+    alt_region: ty::region,   // Region for the alt as a whole\n+    block_region: ty::region, // Region for the block of the arm\n };\n \n fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n@@ -175,7 +228,6 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n \n         match bm {\n           ast::bind_by_ref(mutbl) => {\n-            pcx.ever_bound_by_ref = true;\n             // if the binding is like\n             //    ref x | ref const x | ref mut x\n             // then the type of x is &M T where M is the mutability\n@@ -193,26 +245,8 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           }\n           ast::bind_by_move => {\n             demand::eqtype(fcx, pat.span, expected, typ);\n-            // check legality of moving out of the enum\n-            if sub.is_some() {\n-                tcx.sess.span_err(pat.span,\n-                    ~\"cannot bind by-move with sub-bindings\");\n-            }\n-            if pcx.has_guard {\n-                tcx.sess.span_err(pat.span,\n-                    ~\"cannot bind by-move into a pattern guard\");\n-            }\n-            if pcx.ever_bound_by_ref {\n-                tcx.sess.span_err(pat.span,\n-                    ~\"cannot bind by-move and by-ref in the same pattern\");\n-            }\n-            if pcx.matching_lvalue {\n-                tcx.sess.span_err(pat.span,\n-                    ~\"cannot bind by-move when matching an lvalue\");\n-            }\n           }\n           ast::bind_by_implicit_ref => {\n-            pcx.ever_bound_by_ref = true;\n             demand::eqtype(fcx, pat.span, expected, typ);\n           }\n         }"}, {"sha": "6b7a8b4e40278f750d07e5e2b73cf109c4e2f6ef", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -286,12 +286,14 @@ fn constrain_free_variables(\n                 ~\"captured variable does not outlive the enclosing closure\");\n             note_and_explain_region(\n                 tcx,\n-                ~\"captured variable is valid for\",\n-                en_region);\n+                ~\"captured variable is valid for \",\n+                en_region,\n+                ~\"\");\n             note_and_explain_region(\n                 tcx,\n-                ~\"closure is valid for\",\n-                region);\n+                ~\"closure is valid for \",\n+                region,\n+                ~\"\");\n           }\n         }\n     }\n@@ -337,8 +339,9 @@ fn constrain_regions_in_type(\n                 fmt!(\"reference is not valid outside of its lifetime\"));\n             note_and_explain_region(\n                 tcx,\n-                ~\"the reference is only valid for\",\n-                region);\n+                ~\"the reference is only valid for \",\n+                region,\n+                ~\"\");\n             rcx.errors_reported += 1u;\n           }\n           result::Ok(()) => {"}, {"sha": "70dd5777e3deb45982915a31793f2422dc146c99", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -1104,21 +1104,23 @@ impl RegionVarBindings {\n \n                     note_and_explain_region(\n                         self.tcx,\n-                        ~\"first, the lifetime cannot outlive\",\n-                        upper_bound.region);\n+                        ~\"first, the lifetime cannot outlive \",\n+                        upper_bound.region,\n+                        ~\"...\");\n \n                     self.tcx.sess.span_note(\n                         upper_bound.span,\n-                        fmt!(\"due to the following expression\"));\n+                        fmt!(\"...due to the following expression\"));\n \n                     note_and_explain_region(\n                         self.tcx,\n-                        ~\"but, the lifetime must be valid for\",\n-                        lower_bound.region);\n+                        ~\"but, the lifetime must be valid for \",\n+                        lower_bound.region,\n+                        ~\"...\");\n \n                     self.tcx.sess.span_note(\n                         lower_bound.span,\n-                        fmt!(\"due to the following expression\"));\n+                        fmt!(\"...due to the following expression\"));\n \n                     return;\n                 }\n@@ -1154,21 +1156,23 @@ impl RegionVarBindings {\n \n                     note_and_explain_region(\n                         self.tcx,\n-                        ~\"first, the lifetime must be contained by\",\n-                        upper_bound_1.region);\n+                        ~\"first, the lifetime must be contained by \",\n+                        upper_bound_1.region,\n+                        ~\"...\");\n \n                     self.tcx.sess.span_note(\n                         upper_bound_1.span,\n-                        fmt!(\"due to the following expression\"));\n+                        fmt!(\"...due to the following expression\"));\n \n                     note_and_explain_region(\n                         self.tcx,\n-                        ~\"but, the lifetime must also be contained by\",\n-                        upper_bound_2.region);\n+                        ~\"but, the lifetime must also be contained by \",\n+                        upper_bound_2.region,\n+                        ~\"...\");\n \n                     self.tcx.sess.span_note(\n                         upper_bound_2.span,\n-                        fmt!(\"due to the following expression\"));\n+                        fmt!(\"...due to the following expression\"));\n \n                     return;\n                   }"}, {"sha": "70f617fe4a56af81cb3643772a36d75e6f032c90", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -35,6 +35,13 @@ use back_ = back;\n \n mod middle {\n     mod trans {\n+        mod inline;\n+        mod monomorphize;\n+        mod controlflow;\n+        mod glue;\n+        mod datum;\n+        mod callee;\n+        mod expr;\n         mod common;\n         mod consts;\n         mod type_of;"}, {"sha": "ba7b9ffa478a4f1134ef6f361c9f55a6b7413832", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -21,16 +21,19 @@ use syntax::{ast, ast_util};\n use syntax::ast_map;\n use driver::session::session;\n \n-fn note_and_explain_region(cx: ctxt, prefix: ~str, region: ty::region) {\n+fn note_and_explain_region(cx: ctxt,\n+                           prefix: ~str,\n+                           region: ty::region,\n+                           suffix: ~str) {\n     match explain_region_and_span(cx, region) {\n       (str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            fmt!(\"%s %s\", prefix, str));\n+            fmt!(\"%s%s%s\", prefix, str, suffix));\n       }\n       (str, None) => {\n         cx.sess.note(\n-            fmt!(\"%s %s\", prefix, str));\n+            fmt!(\"%s%s%s\", prefix, str, suffix));\n       }\n     }\n }\n@@ -55,7 +58,7 @@ fn explain_region_and_span(cx: ctxt, region: ty::region)\n           Some(ast_map::node_expr(expr)) => {\n             match expr.node {\n               ast::expr_call(*) => explain_span(cx, ~\"call\", expr.span),\n-              ast::expr_match(*) => explain_span(cx, ~\"alt\", expr.span),\n+              ast::expr_match(*) => explain_span(cx, ~\"match\", expr.span),\n               _ => explain_span(cx, ~\"expression\", expr.span)\n             }\n           }"}, {"sha": "1402c9e860476519eb616cea69cc5e440c6ec7e7", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -174,9 +174,9 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n             match c {\n               white => {\n                 let i = i as node_id;\n-                \n+\n                 let neighbors = graph[i];\n-                \n+\n                 let mut color = white;\n \n                 do neighbors.each() |k| {\n@@ -217,7 +217,8 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         black(node_id)\n     };\n \n-    let mut colors = do vec::from_fn((*arc::get(&graph)).len()) |i| {\n+    let graph_vec = arc::get(&graph); // FIXME #3387 requires this temp\n+    let mut colors = do vec::from_fn(graph_vec.len()) |i| {\n         if i as node_id == key {\n             gray(key)\n         }\n@@ -243,7 +244,8 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n \n         let color = arc::ARC(colors);\n \n-        colors = do par::mapi_factory(*arc::get(&color)) {\n+        let color_vec = arc::get(&color); // FIXME #3387 requires this temp\n+        colors = do par::mapi_factory(*color_vec) {\n             let colors = arc::clone(&color);\n             let graph = arc::clone(&graph);\n             fn~(i: uint, c: color) -> color {\n@@ -253,11 +255,11 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n                 match c {\n                   white => {\n                     let i = i as node_id;\n-                    \n+\n                     let neighbors = graph[i];\n-                    \n+\n                     let mut color = white;\n-                    \n+\n                     do neighbors.each() |k| {\n                         if is_gray(colors[k]) {\n                             color = gray(k);"}, {"sha": "71f4934effd37a61c9c2d4524dc5cd5513b056e2", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-4.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,9 @@\n+struct X { x: (); drop { error!(\"destructor runs\"); } }\n+\n+fn main() {\n+    let x = Some((X { x: () }, X { x: () }));\n+    match move x {\n+        Some((move _y, ref _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n+        None => fail\n+    }\n+}"}, {"sha": "a320cfae1b0983788823a3f7fc5c8c102d4acbfc", "filename": "src/test/compile-fail/borrowck-confuse-region.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Fcompile-fail%2Fborrowck-confuse-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Fcompile-fail%2Fborrowck-confuse-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-confuse-region.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -6,9 +6,11 @@\n \n \n fn get() -> &int {\n+    //~^ NOTE borrowed pointer must be valid for the anonymous lifetime #1 defined on\n+    //~^^ NOTE ...but borrowed value is only valid for the block at\n     let x = 3;\n     return &x;\n-    //~^ ERROR illegal borrow: borrowed pointer must be valid for the anonymous lifetime #1 defined on the block at 8:17, but the borrowed value is only valid for the block at 8:17\n+    //~^ ERROR illegal borrow\n }\n \n fn main() {}"}, {"sha": "ef7c8da4b1921bf66e38b0dff1855cbc006f95e6", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,15 @@\n+// xfail-test #3387\n+\n+enum foo = ~uint;\n+\n+impl foo: Add<foo, foo> {\n+    pure fn add(f: foo) -> foo {\n+        foo(~(**self + **f))\n+    }\n+}\n+\n+fn main() {\n+    let x = foo(~3);\n+    let _y = x + move x;\n+    //~^ ERROR moving out of immutable local variable prohibited due to outstanding loan\n+}"}, {"sha": "b2852784e18ed72fc72aa6fa36083627ad4bba6e", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -7,7 +7,7 @@ fn foo(cond: fn() -> bool, box: fn() -> @int) {\n \n \t// Here we complain because the resulting region\n \t// of this borrow is the fn body as a whole.\n-        y = borrow(x); //~ ERROR illegal borrow: managed value would have to be rooted\n+        y = borrow(x); //~ ERROR illegal borrow: cannot root managed value long enough\n \n         assert *x == *y;\n         if cond() { break; }"}, {"sha": "85868f44cfd5064e37c8474b089bfe4131603734", "filename": "src/test/run-pass/autoderef-method-on-trait-monomorphized.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait-monomorphized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait-monomorphized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait-monomorphized.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,16 @@\n+trait double {\n+    fn double() -> uint;\n+}\n+\n+impl uint: double {\n+    fn double() -> uint { self * 2u }\n+}\n+\n+fn is_equal<D: double>(x: @D, exp: uint) {\n+    assert x.double() == exp;\n+}\n+\n+fn main() {\n+    let x = @(3u as double);\n+    is_equal(x, 6);\n+}"}, {"sha": "68dde1e25a53810c7b4ae2754aaeb7072f7834bb", "filename": "src/test/run-pass/autoderef-method-on-trait.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -0,0 +1,12 @@\n+trait double {\n+    fn double() -> uint;\n+}\n+\n+impl uint: double {\n+    fn double() -> uint { self * 2u }\n+}\n+\n+fn main() {\n+    let x = @(3u as double);\n+    assert x.double() == 6u;\n+}"}, {"sha": "387ca032f6a742ebeeb2059e71e6b5ae3b661991", "filename": "src/test/run-pass/const-fields-and-indexing.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -6,6 +6,10 @@ const q : int = y[2];\n const s : {a: int, b: int} = {a: 10, b: 20};\n const t : int = s.b;\n \n+const k : {a: int, b: int, c: {d: int, e: int}} = {a: 10, b: 20, c: {d: 30,\n+                                                                     e: 40}};\n+const m : int = k.c.e;\n+\n fn main() {\n     io::println(fmt!(\"%?\", p));\n     io::println(fmt!(\"%?\", q));"}, {"sha": "cf34c44d5000eb328805842e5c4653cb49cd404e", "filename": "src/test/run-pass/pipe-presentation-examples.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e36a997945ddc3964a1fe937bc5390cc5b526c8/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs?ref=5e36a997945ddc3964a1fe937bc5390cc5b526c8", "patch": "@@ -23,8 +23,8 @@ macro_rules! select_if (\n     } => {\n         if $index == $count {\n             match move pipes::try_recv($port) {\n-              $(Some($message($($(move $x,)+)* next)) => {\n-                let $next = unsafe { let x <- *ptr::addr_of(next); x };\n+              $(Some($message($($(move $x,)+)* move next)) => {\n+                let $next = next;\n                 $e\n               })+\n               _ => fail"}]}