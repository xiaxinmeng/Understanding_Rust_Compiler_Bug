{"sha": "e092a170528c964dddb0ed9764e8593d9ac8b370", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwOTJhMTcwNTI4Yzk2NGRkZGIwZWQ5NzY0ZTg1OTNkOWFjOGIzNzA=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-05T17:57:55Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-05T17:58:57Z"}, "message": "Add special variable-length slice constructor", "tree": {"sha": "5dd44aabacc38d4f7fe7392d8f2be8233a34a051", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dd44aabacc38d4f7fe7392d8f2be8233a34a051"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e092a170528c964dddb0ed9764e8593d9ac8b370", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e092a170528c964dddb0ed9764e8593d9ac8b370", "html_url": "https://github.com/rust-lang/rust/commit/e092a170528c964dddb0ed9764e8593d9ac8b370", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e092a170528c964dddb0ed9764e8593d9ac8b370/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2b7711e8e955649e532d0e78279876178a51983", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b7711e8e955649e532d0e78279876178a51983", "html_url": "https://github.com/rust-lang/rust/commit/d2b7711e8e955649e532d0e78279876178a51983"}], "stats": {"total": 98, "additions": 72, "deletions": 26}, "files": [{"sha": "d0597817d32f554df06b07e47f6665cafbbd99b2", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 72, "deletions": 26, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e092a170528c964dddb0ed9764e8593d9ac8b370/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e092a170528c964dddb0ed9764e8593d9ac8b370/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=e092a170528c964dddb0ed9764e8593d9ac8b370", "patch": "@@ -588,6 +588,8 @@ enum Constructor<'tcx> {\n     ConstantRange(u128, u128, Ty<'tcx>, RangeEnd, Span),\n     /// Array patterns of length n.\n     FixedLenSlice(u64),\n+    /// Slice patterns. Stands for any array constructor of length >= n.\n+    VarLenSlice(u64),\n }\n \n // Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n@@ -602,6 +604,7 @@ impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n                 Constructor::ConstantRange(b_start, b_end, b_ty, b_range_end, _),\n             ) => a_start == b_start && a_end == b_end && a_ty == b_ty && a_range_end == b_range_end,\n             (Constructor::FixedLenSlice(a), Constructor::FixedLenSlice(b)) => a == b,\n+            (Constructor::VarLenSlice(a), Constructor::VarLenSlice(b)) => a == b,\n             _ => false,\n         }\n     }\n@@ -611,6 +614,7 @@ impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n             FixedLenSlice { .. } => true,\n+            VarLenSlice { .. } => true,\n             _ => false,\n         }\n     }\n@@ -645,6 +649,7 @@ impl<'tcx> Constructor<'tcx> {\n                 )\n             }\n             Constructor::FixedLenSlice(val) => format!(\"[{}]\", val),\n+            Constructor::VarLenSlice(val) => format!(\"[{}, ..]\", val),\n             _ => bug!(\"bad constructor being displayed: `{:?}\", self),\n         }\n     }\n@@ -653,19 +658,59 @@ impl<'tcx> Constructor<'tcx> {\n     // anything in `other_ctors`.\n     fn subtract_ctors(\n         &self,\n+        pcx: PatCtxt<'tcx>,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         other_ctors: &Vec<Constructor<'tcx>>,\n     ) -> Vec<Constructor<'tcx>> {\n         match self {\n             // Those constructors can only match themselves.\n-            Single | Variant(_) | FixedLenSlice(_) => {\n+            Single | Variant(_) => {\n                 if other_ctors.iter().any(|c| c == self) {\n                     vec![]\n                 } else {\n                     vec![self.clone()]\n                 }\n             }\n+            FixedLenSlice(_) | VarLenSlice(_) => {\n+                let mut remaining_ctors = if let VarLenSlice(len) = self {\n+                    (*len..pcx.max_slice_length + 1).map(FixedLenSlice).collect()\n+                } else {\n+                    vec![self.clone()]\n+                };\n+\n+                // For each used ctor, subtract from the current set of constructors.\n+                // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n+                // Remember, VarLenSlice(n) covers the union of FixedLenSlice from\n+                // n to infinity.\n+                for neg_ctor in other_ctors {\n+                    remaining_ctors = remaining_ctors\n+                        .into_iter()\n+                        .flat_map(|pos_ctor| -> SmallVec<[Constructor<'tcx>; 1]> {\n+                            // Compute pos_ctor \\ neg_ctor\n+                            match (&pos_ctor, neg_ctor) {\n+                                (FixedLenSlice(pos_len), VarLenSlice(neg_len)) => {\n+                                    if neg_len <= pos_len {\n+                                        smallvec![]\n+                                    } else {\n+                                        smallvec![pos_ctor]\n+                                    }\n+                                }\n+                                _ if pos_ctor == *neg_ctor => smallvec![],\n+                                _ => smallvec![pos_ctor],\n+                            }\n+                        })\n+                        .collect();\n+\n+                    // If the constructors that have been considered so far already cover\n+                    // the entire range of `self`, no need to look at more constructors.\n+                    if remaining_ctors.is_empty() {\n+                        break;\n+                    }\n+                }\n+\n+                remaining_ctors\n+            }\n             ConstantRange(..) | ConstantValue(..) => {\n                 let mut remaining_ctors = vec![self.clone()];\n                 for other_ctor in other_ctors {\n@@ -719,7 +764,7 @@ impl<'tcx> Constructor<'tcx> {\n         match ty.kind {\n             ty::Tuple(ref fs) => fs.len() as u64,\n             ty::Slice(..) | ty::Array(..) => match *self {\n-                FixedLenSlice(length) => length,\n+                FixedLenSlice(length) | VarLenSlice(length) => length,\n                 ConstantValue(..) => 0,\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n             },\n@@ -999,7 +1044,7 @@ fn all_constructors<'a, 'tcx>(\n             if cx.is_uninhabited(sub_ty) {\n                 vec![FixedLenSlice(0)]\n             } else {\n-                (0..pcx.max_slice_length + 1).map(|length| FixedLenSlice(length)).collect()\n+                vec![VarLenSlice(0)]\n             }\n         }\n         ty::Adt(def, substs) if def.is_enum() => def\n@@ -1403,6 +1448,7 @@ impl<'tcx> IntRange<'tcx> {\n \n // A struct to compute a set of constructors equivalent to `all_ctors \\ used_ctors`.\n struct MissingConstructors<'tcx> {\n+    pcx: PatCtxt<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     all_ctors: Vec<Constructor<'tcx>>,\n@@ -1411,12 +1457,13 @@ struct MissingConstructors<'tcx> {\n \n impl<'tcx> MissingConstructors<'tcx> {\n     fn new(\n+        pcx: PatCtxt<'tcx>,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         all_ctors: Vec<Constructor<'tcx>>,\n         used_ctors: Vec<Constructor<'tcx>>,\n     ) -> Self {\n-        MissingConstructors { tcx, param_env, all_ctors, used_ctors }\n+        MissingConstructors { pcx, tcx, param_env, all_ctors, used_ctors }\n     }\n \n     fn into_inner(self) -> (Vec<Constructor<'tcx>>, Vec<Constructor<'tcx>>) {\n@@ -1435,7 +1482,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n     /// Iterate over all_ctors \\ used_ctors\n     fn iter<'a>(&'a self) -> impl Iterator<Item = Constructor<'tcx>> + Captures<'a> {\n         self.all_ctors.iter().flat_map(move |req_ctor| {\n-            req_ctor.subtract_ctors(self.tcx, self.param_env, &self.used_ctors)\n+            req_ctor.subtract_ctors(self.pcx, self.tcx, self.param_env, &self.used_ctors)\n         })\n     }\n }\n@@ -1531,9 +1578,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         split_grouped_constructors(\n             cx.tcx,\n             cx.param_env,\n+            pcx,\n             constructors,\n             matrix,\n-            pcx.ty,\n             pcx.span,\n             Some(hir_id),\n         )\n@@ -1578,7 +1625,8 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // non-wildcard patterns in the current column. To determine if\n         // the set is empty, we can check that `.peek().is_none()`, so\n         // we only fully construct them on-demand, because they're rarely used and can be big.\n-        let missing_ctors = MissingConstructors::new(cx.tcx, cx.param_env, all_ctors, used_ctors);\n+        let missing_ctors =\n+            MissingConstructors::new(pcx, cx.tcx, cx.param_env, all_ctors, used_ctors);\n \n         debug!(\n             \"missing_ctors.empty()={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n@@ -1595,19 +1643,13 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n         if missing_ctors.is_empty() && !is_non_exhaustive {\n             let (all_ctors, _) = missing_ctors.into_inner();\n-            split_grouped_constructors(\n-                cx.tcx,\n-                cx.param_env,\n-                all_ctors,\n-                matrix,\n-                pcx.ty,\n-                DUMMY_SP,\n-                None,\n-            )\n-            .into_iter()\n-            .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness_preference, hir_id))\n-            .find(|result| result.is_useful())\n-            .unwrap_or(NotUseful)\n+            split_grouped_constructors(cx.tcx, cx.param_env, pcx, all_ctors, matrix, DUMMY_SP, None)\n+                .into_iter()\n+                .map(|c| {\n+                    is_useful_specialized(cx, matrix, v, c, pcx.ty, witness_preference, hir_id)\n+                })\n+                .find(|result| result.is_useful())\n+                .unwrap_or(NotUseful)\n         } else {\n             let matrix = matrix.specialize_wildcard();\n             let v = v.to_tail();\n@@ -1731,7 +1773,7 @@ fn pat_constructors<'tcx>(\n         PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n             let pat_len = prefix.len() as u64 + suffix.len() as u64;\n             if slice.is_some() {\n-                Some((pat_len..pcx.max_slice_length + 1).map(FixedLenSlice).collect())\n+                Some(vec![VarLenSlice(pat_len)])\n             } else {\n                 Some(vec![FixedLenSlice(pat_len)])\n             }\n@@ -1755,7 +1797,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n     match ty.kind {\n         ty::Tuple(ref fs) => fs.into_iter().map(|t| t.expect_ty()).collect(),\n         ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n-            FixedLenSlice(length) => (0..length).map(|_| ty).collect(),\n+            FixedLenSlice(length) | VarLenSlice(length) => (0..length).map(|_| ty).collect(),\n             ConstantValue(..) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty),\n         },\n@@ -1914,21 +1956,22 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>)\n ///\n /// `hir_id` is `None` when we're evaluating the wildcard pattern, do not lint for overlapping in\n /// ranges that case.\n+///\n+/// This also splits variable-length slices into fixed-length slices.\n fn split_grouped_constructors<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n+    pcx: PatCtxt<'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n     matrix: &Matrix<'p, 'tcx>,\n-    ty: Ty<'tcx>,\n     span: Span,\n     hir_id: Option<HirId>,\n ) -> Vec<Constructor<'tcx>> {\n+    let ty = pcx.ty;\n     let mut split_ctors = Vec::with_capacity(ctors.len());\n \n     for ctor in ctors.into_iter() {\n         match ctor {\n-            // For now, only ranges may denote groups of \"subconstructors\", so we only need to\n-            // special-case constant ranges.\n             ConstantRange(..) if should_treat_range_exhaustively(tcx, &ctor) => {\n                 // We only care about finding all the subranges within the range of the constructor\n                 // range. Anything else is irrelevant, because it is guaranteed to result in\n@@ -2010,6 +2053,9 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n                 }\n             }\n+            VarLenSlice(len) => {\n+                split_ctors.extend((len..pcx.max_slice_length + 1).map(FixedLenSlice))\n+            }\n             // Any other constructor can be used unchanged.\n             _ => split_ctors.push(ctor),\n         }\n@@ -2252,7 +2298,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n \n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n-            FixedLenSlice(..) => {\n+            FixedLenSlice(..) | VarLenSlice(..) => {\n                 let pat_len = prefix.len() + suffix.len();\n                 if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n                     if slice_count == 0 || slice.is_some() {"}]}