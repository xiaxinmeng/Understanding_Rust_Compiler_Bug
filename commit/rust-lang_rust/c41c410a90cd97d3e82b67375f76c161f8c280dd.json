{"sha": "c41c410a90cd97d3e82b67375f76c161f8c280dd", "node_id": "C_kwDOAAsO6NoAKGM0MWM0MTBhOTBjZDk3ZDNlODJiNjczNzVmNzZjMTYxZjhjMjgwZGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-24T20:47:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-24T20:47:34Z"}, "message": "Auto merge of #8786 - Alexendoo:identity-op-suggestions, r=dswij,xFrednet\n\n`identity_op`: add parenthesis to suggestions where required\n\nchangelog: [`identity_op`]: add parenthesis to suggestions where required\n\nFollow up to #8730, wraps the cases we can't lint as-is in parenthesis rather than ignoring them\n\nCatches a couple new FPs with mixed operator precedences and `as` casts\n\n```rust\n// such as\n0 + { a } * 2;\n0 + a as usize;\n```\n\nThe suggestions are now applied using `span_lint_and_sugg` rather than appearing in just the message and have a `run-rustfix` test", "tree": {"sha": "1ce698c2f90e723c8dbe45c59a9994a95c9d7412", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ce698c2f90e723c8dbe45c59a9994a95c9d7412"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c41c410a90cd97d3e82b67375f76c161f8c280dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c41c410a90cd97d3e82b67375f76c161f8c280dd", "html_url": "https://github.com/rust-lang/rust/commit/c41c410a90cd97d3e82b67375f76c161f8c280dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c41c410a90cd97d3e82b67375f76c161f8c280dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6269ab1eec7a84a66cf61d6231d6db1def1f1947", "url": "https://api.github.com/repos/rust-lang/rust/commits/6269ab1eec7a84a66cf61d6231d6db1def1f1947", "html_url": "https://github.com/rust-lang/rust/commit/6269ab1eec7a84a66cf61d6231d6db1def1f1947"}, {"sha": "ee8fae3f5d4aac2bcbea8936e39d3027aade8e32", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee8fae3f5d4aac2bcbea8936e39d3027aade8e32", "html_url": "https://github.com/rust-lang/rust/commit/ee8fae3f5d4aac2bcbea8936e39d3027aade8e32"}], "stats": {"total": 579, "additions": 377, "deletions": 202}, "files": [{"sha": "419ea5a6811b87884acd5822d0e3fb979b7803ca", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 72, "deletions": 53, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c41c410a90cd97d3e82b67375f76c161f8c280dd/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c41c410a90cd97d3e82b67375f76c161f8c280dd/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=c41c410a90cd97d3e82b67375f76c161f8c280dd", "patch": "@@ -1,15 +1,14 @@\n-use clippy_utils::get_parent_expr;\n-use clippy_utils::source::snippet;\n-use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind};\n+use clippy_utils::consts::{constant_full_int, constant_simple, Constant, FullInt};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{clip, unsext};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n-use clippy_utils::consts::{constant_full_int, constant_simple, Constant, FullInt};\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{clip, unsext};\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for identity operations, e.g., `x + 0`.\n@@ -23,11 +22,6 @@ declare_clippy_lint! {\n     /// # let x = 1;\n     /// x / 1 + 0 * 1 - 0 | 0;\n     /// ```\n-    ///\n-    /// ### Known problems\n-    /// False negatives: `f(0 + if b { 1 } else { 2 } + 3);` is reducible to\n-    /// `f(if b { 1 } else { 2 } + 3);`. But the lint doesn't trigger for the code.\n-    /// See [#8724](https://github.com/rust-lang/rust-clippy/issues/8724)\n     #[clippy::version = \"pre 1.29.0\"]\n     pub IDENTITY_OP,\n     complexity,\n@@ -45,56 +39,73 @@ impl<'tcx> LateLintPass<'tcx> for IdentityOp {\n             if !is_allowed(cx, *cmp, left, right) {\n                 match cmp.node {\n                     BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n-                        if reducible_to_right(cx, expr, right) {\n-                            check(cx, left, 0, expr.span, right.span);\n-                        }\n-                        check(cx, right, 0, expr.span, left.span);\n+                        check(cx, left, 0, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                        check(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n                     },\n                     BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => {\n-                        check(cx, right, 0, expr.span, left.span);\n+                        check(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n                     },\n                     BinOpKind::Mul => {\n-                        if reducible_to_right(cx, expr, right) {\n-                            check(cx, left, 1, expr.span, right.span);\n-                        }\n-                        check(cx, right, 1, expr.span, left.span);\n+                        check(cx, left, 1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                        check(cx, right, 1, expr.span, left.span, Parens::Unneeded);\n                     },\n-                    BinOpKind::Div => check(cx, right, 1, expr.span, left.span),\n+                    BinOpKind::Div => check(cx, right, 1, expr.span, left.span, Parens::Unneeded),\n                     BinOpKind::BitAnd => {\n-                        if reducible_to_right(cx, expr, right) {\n-                            check(cx, left, -1, expr.span, right.span);\n-                        }\n-                        check(cx, right, -1, expr.span, left.span);\n-                    },\n-                    BinOpKind::Rem => {\n-                        // Don't call reducible_to_right because N % N is always reducible to 1\n-                        check_remainder(cx, left, right, expr.span, left.span);\n+                        check(cx, left, -1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                        check(cx, right, -1, expr.span, left.span, Parens::Unneeded);\n                     },\n+                    BinOpKind::Rem => check_remainder(cx, left, right, expr.span, left.span),\n                     _ => (),\n                 }\n             }\n         }\n     }\n }\n \n-/// Checks if `left op ..right` can be actually reduced to `right`\n-/// e.g. `0 + if b { 1 } else { 2 } + if b { 3 } else { 4 }`\n-/// cannot be reduced to `if b { 1 } else { 2 } +  if b { 3 } else { 4 }`\n+#[derive(Copy, Clone)]\n+enum Parens {\n+    Needed,\n+    Unneeded,\n+}\n+\n+/// Checks if `left op right` needs parenthesis when reduced to `right`\n+/// e.g. `0 + if b { 1 } else { 2 } + if b { 3 } else { 4 }` cannot be reduced\n+/// to `if b { 1 } else { 2 } + if b { 3 } else { 4 }` where the `if` could be\n+/// interpreted as a statement\n+///\n /// See #8724\n-fn reducible_to_right(cx: &LateContext<'_>, binary: &Expr<'_>, right: &Expr<'_>) -> bool {\n-    if let ExprKind::If(..) | ExprKind::Match(..) | ExprKind::Block(..) | ExprKind::Loop(..) = right.kind {\n-        is_toplevel_binary(cx, binary)\n-    } else {\n-        true\n+fn needs_parenthesis(cx: &LateContext<'_>, binary: &Expr<'_>, right: &Expr<'_>) -> Parens {\n+    match right.kind {\n+        ExprKind::Binary(_, lhs, _) | ExprKind::Cast(lhs, _) => {\n+            // ensure we're checking against the leftmost expression of `right`\n+            //\n+            //     ~~~ `lhs`\n+            // 0 + {4} * 2\n+            //     ~~~~~~~ `right`\n+            return needs_parenthesis(cx, binary, lhs);\n+        },\n+        ExprKind::If(..) | ExprKind::Match(..) | ExprKind::Block(..) | ExprKind::Loop(..) => {},\n+        _ => return Parens::Unneeded,\n     }\n-}\n \n-fn is_toplevel_binary(cx: &LateContext<'_>, must_be_binary: &Expr<'_>) -> bool {\n-    if let Some(parent) = get_parent_expr(cx, must_be_binary) && let ExprKind::Binary(..) = &parent.kind {\n-        false\n-    } else {\n-        true\n+    let mut prev_id = binary.hir_id;\n+    for (_, node) in cx.tcx.hir().parent_iter(binary.hir_id) {\n+        if let Node::Expr(expr) = node\n+            && let ExprKind::Binary(_, lhs, _) | ExprKind::Cast(lhs, _) = expr.kind\n+            && lhs.hir_id == prev_id\n+        {\n+            // keep going until we find a node that encompasses left of `binary`\n+            prev_id = expr.hir_id;\n+            continue;\n+        }\n+\n+        match node {\n+            Node::Block(_) | Node::Stmt(_) => break,\n+            _ => return Parens::Unneeded,\n+        };\n     }\n+\n+    Parens::Needed\n }\n \n fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n@@ -115,11 +126,11 @@ fn check_remainder(cx: &LateContext<'_>, left: &Expr<'_>, right: &Expr<'_>, span\n         (Some(FullInt::U(lv)), Some(FullInt::U(rv))) => lv < rv,\n         _ => return,\n     } {\n-        span_ineffective_operation(cx, span, arg);\n+        span_ineffective_operation(cx, span, arg, Parens::Unneeded);\n     }\n }\n \n-fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n+fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span, parens: Parens) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.typeck_results(), e).map(Constant::peel_refs) {\n         let check = match *cx.typeck_results().expr_ty(e).peel_refs().kind() {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),\n@@ -132,19 +143,27 @@ fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n             1 => v == 1,\n             _ => unreachable!(),\n         } {\n-            span_ineffective_operation(cx, span, arg);\n+            span_ineffective_operation(cx, span, arg, parens);\n         }\n     }\n }\n \n-fn span_ineffective_operation(cx: &LateContext<'_>, span: Span, arg: Span) {\n-    span_lint(\n+fn span_ineffective_operation(cx: &LateContext<'_>, span: Span, arg: Span, parens: Parens) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    let expr_snippet = snippet_with_applicability(cx, arg, \"..\", &mut applicability);\n+\n+    let suggestion = match parens {\n+        Parens::Needed => format!(\"({expr_snippet})\"),\n+        Parens::Unneeded => expr_snippet.into_owned(),\n+    };\n+\n+    span_lint_and_sugg(\n         cx,\n         IDENTITY_OP,\n         span,\n-        &format!(\n-            \"the operation is ineffective. Consider reducing it to `{}`\",\n-            snippet(cx, arg, \"..\")\n-        ),\n+        \"this operation has no effect\",\n+        \"consider reducing it to\",\n+        suggestion,\n+        applicability,\n     );\n }"}, {"sha": "5f9cebe212abd89844733156582e3c64771c0524", "filename": "tests/ui/identity_op.fixed", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c41c410a90cd97d3e82b67375f76c161f8c280dd/tests%2Fui%2Fidentity_op.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c41c410a90cd97d3e82b67375f76c161f8c280dd/tests%2Fui%2Fidentity_op.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_op.fixed?ref=c41c410a90cd97d3e82b67375f76c161f8c280dd", "patch": "@@ -0,0 +1,119 @@\n+// run-rustfix\n+\n+#![warn(clippy::identity_op)]\n+#![allow(\n+    clippy::eq_op,\n+    clippy::no_effect,\n+    clippy::unnecessary_operation,\n+    clippy::op_ref,\n+    clippy::double_parens,\n+    unused\n+)]\n+\n+use std::fmt::Write as _;\n+\n+const ONE: i64 = 1;\n+const NEG_ONE: i64 = -1;\n+const ZERO: i64 = 0;\n+\n+struct A(String);\n+\n+impl std::ops::Shl<i32> for A {\n+    type Output = A;\n+    fn shl(mut self, other: i32) -> Self {\n+        let _ = write!(self.0, \"{}\", other);\n+        self\n+    }\n+}\n+\n+struct Length(u8);\n+struct Meter;\n+\n+impl core::ops::Mul<Meter> for u8 {\n+    type Output = Length;\n+    fn mul(self, _: Meter) -> Length {\n+        Length(self)\n+    }\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    let x = 0;\n+\n+    x;\n+    x;\n+    x + 1;\n+    x;\n+    1 + x;\n+    x - ZERO; //no error, as we skip lookups (for now)\n+    x;\n+    ((ZERO)) | x; //no error, as we skip lookups (for now)\n+\n+    x;\n+    x;\n+    x / ONE; //no error, as we skip lookups (for now)\n+\n+    x / 2; //no false positive\n+\n+    x & NEG_ONE; //no error, as we skip lookups (for now)\n+    x;\n+\n+    let u: u8 = 0;\n+    u;\n+\n+    1 << 0; // no error, this case is allowed, see issue 3430\n+    42;\n+    1;\n+    42;\n+    &x;\n+    x;\n+\n+    let mut a = A(\"\".into());\n+    let b = a << 0; // no error: non-integer\n+\n+    1 * Meter; // no error: non-integer\n+\n+    2;\n+    -2;\n+    2 + x;\n+    -2 + x;\n+    x + 1;\n+    (x + 1) % 3; // no error\n+    4 % 3; // no error\n+    4 % -3; // no error\n+\n+    // See #8724\n+    let a = 0;\n+    let b = true;\n+    (if b { 1 } else { 2 });\n+    (if b { 1 } else { 2 }) + if b { 3 } else { 4 };\n+    (match a { 0 => 10, _ => 20 });\n+    (match a { 0 => 10, _ => 20 }) + match a { 0 => 30, _ => 40 };\n+    (if b { 1 } else { 2 }) + match a { 0 => 30, _ => 40 };\n+    (match a { 0 => 10, _ => 20 }) + if b { 3 } else { 4 };\n+    (if b { 1 } else { 2 });\n+\n+    ({ a }) + 3;\n+    ({ a } * 2);\n+    (loop { let mut c = 0; if c == 10 { break c; } c += 1; }) + { a * 2 };\n+\n+    fn f(_: i32) {\n+        todo!();\n+    }\n+    f(a + { 8 * 5 });\n+    f(if b { 1 } else { 2 } + 3);\n+    const _: i32 = { 2 * 4 } + 3;\n+    const _: i32 = { 1 + 2 * 3 } + 3;\n+\n+    a as usize;\n+    let _ = a as usize;\n+    ({ a } as usize);\n+\n+    2 * { a };\n+    (({ a } + 4));\n+    1;\n+}\n+\n+pub fn decide(a: bool, b: bool) -> u32 {\n+    (if a { 1 } else { 2 }) + if b { 3 } else { 5 }\n+}"}, {"sha": "ca799c9cfac0f8a4c7e82c24d2e605d770fec561", "filename": "tests/ui/identity_op.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c41c410a90cd97d3e82b67375f76c161f8c280dd/tests%2Fui%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c41c410a90cd97d3e82b67375f76c161f8c280dd/tests%2Fui%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_op.rs?ref=c41c410a90cd97d3e82b67375f76c161f8c280dd", "patch": "@@ -1,3 +1,15 @@\n+// run-rustfix\n+\n+#![warn(clippy::identity_op)]\n+#![allow(\n+    clippy::eq_op,\n+    clippy::no_effect,\n+    clippy::unnecessary_operation,\n+    clippy::op_ref,\n+    clippy::double_parens,\n+    unused\n+)]\n+\n use std::fmt::Write as _;\n \n const ONE: i64 = 1;\n@@ -24,14 +36,6 @@ impl core::ops::Mul<Meter> for u8 {\n     }\n }\n \n-#[allow(\n-    clippy::eq_op,\n-    clippy::no_effect,\n-    clippy::unnecessary_operation,\n-    clippy::op_ref,\n-    clippy::double_parens\n-)]\n-#[warn(clippy::identity_op)]\n #[rustfmt::skip]\n fn main() {\n     let x = 0;\n@@ -82,29 +86,34 @@ fn main() {\n     let a = 0;\n     let b = true;\n     0 + if b { 1 } else { 2 };\n-    0 + if b { 1 } else { 2 } + if b { 3 } else { 4 }; // no error\n+    0 + if b { 1 } else { 2 } + if b { 3 } else { 4 };\n     0 + match a { 0 => 10, _ => 20 };\n-    0 + match a { 0 => 10, _ => 20 } + match a { 0 => 30, _ => 40 }; // no error\n-    0 + if b { 1 } else { 2 } + match a { 0 => 30, _ => 40 }; // no error\n-    0 + match a { 0 => 10, _ => 20 } + if b { 3 } else { 4 }; // no error\n-    \n-    0 + if b { 0 + 1 } else { 2 };\n-    0 + match a { 0 =>  0 + 10, _ => 20 };\n-    0 + if b { 0 + 1 } else { 2 } + match a { 0 => 0 + 30, _ => 40 };\n-\n-    let _ = 0 + if 0 + 1 > 0 { 1 } else { 2 } + if 0 + 1 > 0 { 3 } else { 4 };\n-    let _ = 0 + match 0 + 1 { 0 => 10, _ => 20 } + match 0 + 1  { 0 => 30, _ => 40 };\n-\n-    0 + if b { 1 } else { 2 } + if b { 3 } else { 4 } + 0;\n-    \n-    0 + { a } + 3; // no error\n-    0 + loop { let mut c = 0; if c == 10 { break c; } c += 1; } + { a * 2 }; // no error\n-    \n+    0 + match a { 0 => 10, _ => 20 } + match a { 0 => 30, _ => 40 };\n+    0 + if b { 1 } else { 2 } + match a { 0 => 30, _ => 40 };\n+    0 + match a { 0 => 10, _ => 20 } + if b { 3 } else { 4 };\n+    (if b { 1 } else { 2 }) + 0;\n+\n+    0 + { a } + 3;\n+    0 + { a } * 2;\n+    0 + loop { let mut c = 0; if c == 10 { break c; } c += 1; } + { a * 2 };\n+\n     fn f(_: i32) {\n         todo!();\n     }\n     f(1 * a + { 8 * 5 });\n-    f(0 + if b { 1 } else { 2 } + 3); // no error\n+    f(0 + if b { 1 } else { 2 } + 3);\n     const _: i32 = { 2 * 4 } + 0 + 3;\n-    const _: i32 = 0 + { 1 + 2 * 3 } + 3; // no error\n+    const _: i32 = 0 + { 1 + 2 * 3 } + 3;\n+\n+    0 + a as usize;\n+    let _ = 0 + a as usize;\n+    0 + { a } as usize;\n+\n+    2 * (0 + { a });\n+    1 * ({ a } + 4);\n+    1 * 1;\n+}\n+\n+pub fn decide(a: bool, b: bool) -> u32 {\n+    0 + if a { 1 } else { 2 } + if b { 3 } else { 5 }\n }"}, {"sha": "1a104a20b841c1688e9412fffaf261867ef26905", "filename": "tests/ui/identity_op.stderr", "status": "modified", "additions": 148, "deletions": 112, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/c41c410a90cd97d3e82b67375f76c161f8c280dd/tests%2Fui%2Fidentity_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c41c410a90cd97d3e82b67375f76c161f8c280dd/tests%2Fui%2Fidentity_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_op.stderr?ref=c41c410a90cd97d3e82b67375f76c161f8c280dd", "patch": "@@ -1,202 +1,238 @@\n-error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:39:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:43:5\n    |\n LL |     x + 0;\n-   |     ^^^^^\n+   |     ^^^^^ help: consider reducing it to: `x`\n    |\n    = note: `-D clippy::identity-op` implied by `-D warnings`\n \n-error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:40:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:44:5\n    |\n LL |     x + (1 - 1);\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ help: consider reducing it to: `x`\n \n-error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:42:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:46:5\n    |\n LL |     0 + x;\n-   |     ^^^^^\n+   |     ^^^^^ help: consider reducing it to: `x`\n \n-error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:45:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:49:5\n    |\n LL |     x | (0);\n-   |     ^^^^^^^\n+   |     ^^^^^^^ help: consider reducing it to: `x`\n \n-error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:48:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:52:5\n    |\n LL |     x * 1;\n-   |     ^^^^^\n+   |     ^^^^^ help: consider reducing it to: `x`\n \n-error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:49:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:53:5\n    |\n LL |     1 * x;\n-   |     ^^^^^\n+   |     ^^^^^ help: consider reducing it to: `x`\n \n-error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:55:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:59:5\n    |\n LL |     -1 & x;\n-   |     ^^^^^^\n+   |     ^^^^^^ help: consider reducing it to: `x`\n \n-error: the operation is ineffective. Consider reducing it to `u`\n-  --> $DIR/identity_op.rs:58:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:62:5\n    |\n LL |     u & 255;\n-   |     ^^^^^^^\n+   |     ^^^^^^^ help: consider reducing it to: `u`\n \n-error: the operation is ineffective. Consider reducing it to `42`\n-  --> $DIR/identity_op.rs:61:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:65:5\n    |\n LL |     42 << 0;\n-   |     ^^^^^^^\n+   |     ^^^^^^^ help: consider reducing it to: `42`\n \n-error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/identity_op.rs:62:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:66:5\n    |\n LL |     1 >> 0;\n-   |     ^^^^^^\n+   |     ^^^^^^ help: consider reducing it to: `1`\n \n-error: the operation is ineffective. Consider reducing it to `42`\n-  --> $DIR/identity_op.rs:63:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:67:5\n    |\n LL |     42 >> 0;\n-   |     ^^^^^^^\n+   |     ^^^^^^^ help: consider reducing it to: `42`\n \n-error: the operation is ineffective. Consider reducing it to `&x`\n-  --> $DIR/identity_op.rs:64:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:68:5\n    |\n LL |     &x >> 0;\n-   |     ^^^^^^^\n+   |     ^^^^^^^ help: consider reducing it to: `&x`\n \n-error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:65:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:69:5\n    |\n LL |     x >> &0;\n-   |     ^^^^^^^\n+   |     ^^^^^^^ help: consider reducing it to: `x`\n \n-error: the operation is ineffective. Consider reducing it to `2`\n-  --> $DIR/identity_op.rs:72:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:76:5\n    |\n LL |     2 % 3;\n-   |     ^^^^^\n+   |     ^^^^^ help: consider reducing it to: `2`\n \n-error: the operation is ineffective. Consider reducing it to `-2`\n-  --> $DIR/identity_op.rs:73:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:77:5\n    |\n LL |     -2 % 3;\n-   |     ^^^^^^\n+   |     ^^^^^^ help: consider reducing it to: `-2`\n \n-error: the operation is ineffective. Consider reducing it to `2`\n-  --> $DIR/identity_op.rs:74:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:78:5\n    |\n LL |     2 % -3 + x;\n-   |     ^^^^^^\n+   |     ^^^^^^ help: consider reducing it to: `2`\n \n-error: the operation is ineffective. Consider reducing it to `-2`\n-  --> $DIR/identity_op.rs:75:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:79:5\n    |\n LL |     -2 % -3 + x;\n-   |     ^^^^^^^\n+   |     ^^^^^^^ help: consider reducing it to: `-2`\n \n-error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/identity_op.rs:76:9\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:80:9\n    |\n LL |     x + 1 % 3;\n-   |         ^^^^^\n+   |         ^^^^^ help: consider reducing it to: `1`\n \n-error: the operation is ineffective. Consider reducing it to `if b { 1 } else { 2 }`\n-  --> $DIR/identity_op.rs:84:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:88:5\n    |\n LL |     0 + if b { 1 } else { 2 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider reducing it to: `(if b { 1 } else { 2 })`\n \n-error: the operation is ineffective. Consider reducing it to `match a { 0 => 10, _ => 20 }`\n-  --> $DIR/identity_op.rs:86:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:89:5\n+   |\n+LL |     0 + if b { 1 } else { 2 } + if b { 3 } else { 4 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider reducing it to: `(if b { 1 } else { 2 })`\n+\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:90:5\n    |\n LL |     0 + match a { 0 => 10, _ => 20 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider reducing it to: `(match a { 0 => 10, _ => 20 })`\n \n-error: the operation is ineffective. Consider reducing it to `if b { 0 + 1 } else { 2 }`\n+error: this operation has no effect\n   --> $DIR/identity_op.rs:91:5\n    |\n-LL |     0 + if b { 0 + 1 } else { 2 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     0 + match a { 0 => 10, _ => 20 } + match a { 0 => 30, _ => 40 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider reducing it to: `(match a { 0 => 10, _ => 20 })`\n \n-error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/identity_op.rs:91:16\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:92:5\n    |\n-LL |     0 + if b { 0 + 1 } else { 2 };\n-   |                ^^^^^\n+LL |     0 + if b { 1 } else { 2 } + match a { 0 => 30, _ => 40 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider reducing it to: `(if b { 1 } else { 2 })`\n \n-error: the operation is ineffective. Consider reducing it to `match a { 0 =>  0 + 10, _ => 20 }`\n-  --> $DIR/identity_op.rs:92:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:93:5\n+   |\n+LL |     0 + match a { 0 => 10, _ => 20 } + if b { 3 } else { 4 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider reducing it to: `(match a { 0 => 10, _ => 20 })`\n+\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:94:5\n+   |\n+LL |     (if b { 1 } else { 2 }) + 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider reducing it to: `(if b { 1 } else { 2 })`\n+\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:96:5\n    |\n-LL |     0 + match a { 0 =>  0 + 10, _ => 20 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     0 + { a } + 3;\n+   |     ^^^^^^^^^ help: consider reducing it to: `({ a })`\n \n-error: the operation is ineffective. Consider reducing it to `10`\n-  --> $DIR/identity_op.rs:92:25\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:97:5\n    |\n-LL |     0 + match a { 0 =>  0 + 10, _ => 20 };\n-   |                         ^^^^^^\n+LL |     0 + { a } * 2;\n+   |     ^^^^^^^^^^^^^ help: consider reducing it to: `({ a } * 2)`\n \n-error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/identity_op.rs:93:16\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:98:5\n    |\n-LL |     0 + if b { 0 + 1 } else { 2 } + match a { 0 => 0 + 30, _ => 40 };\n-   |                ^^^^^\n+LL |     0 + loop { let mut c = 0; if c == 10 { break c; } c += 1; } + { a * 2 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider reducing it to: `(loop { let mut c = 0; if c == 10 { break c; } c += 1; })`\n \n-error: the operation is ineffective. Consider reducing it to `30`\n-  --> $DIR/identity_op.rs:93:52\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:103:7\n    |\n-LL |     0 + if b { 0 + 1 } else { 2 } + match a { 0 => 0 + 30, _ => 40 };\n-   |                                                    ^^^^^^\n+LL |     f(1 * a + { 8 * 5 });\n+   |       ^^^^^ help: consider reducing it to: `a`\n \n-error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/identity_op.rs:95:20\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:104:7\n    |\n-LL |     let _ = 0 + if 0 + 1 > 0 { 1 } else { 2 } + if 0 + 1 > 0 { 3 } else { 4 };\n-   |                    ^^^^^\n+LL |     f(0 + if b { 1 } else { 2 } + 3);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider reducing it to: `if b { 1 } else { 2 }`\n \n-error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/identity_op.rs:95:52\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:105:20\n    |\n-LL |     let _ = 0 + if 0 + 1 > 0 { 1 } else { 2 } + if 0 + 1 > 0 { 3 } else { 4 };\n-   |                                                    ^^^^^\n+LL |     const _: i32 = { 2 * 4 } + 0 + 3;\n+   |                    ^^^^^^^^^^^^^ help: consider reducing it to: `{ 2 * 4 }`\n \n-error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/identity_op.rs:96:23\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:106:20\n    |\n-LL |     let _ = 0 + match 0 + 1 { 0 => 10, _ => 20 } + match 0 + 1  { 0 => 30, _ => 40 };\n-   |                       ^^^^^\n+LL |     const _: i32 = 0 + { 1 + 2 * 3 } + 3;\n+   |                    ^^^^^^^^^^^^^^^^^ help: consider reducing it to: `{ 1 + 2 * 3 }`\n \n-error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/identity_op.rs:96:58\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:108:5\n    |\n-LL |     let _ = 0 + match 0 + 1 { 0 => 10, _ => 20 } + match 0 + 1  { 0 => 30, _ => 40 };\n-   |                                                          ^^^^^\n+LL |     0 + a as usize;\n+   |     ^^^^^^^^^^^^^^ help: consider reducing it to: `a as usize`\n \n-error: the operation is ineffective. Consider reducing it to `0 + if b { 1 } else { 2 } + if b { 3 } else { 4 }`\n-  --> $DIR/identity_op.rs:98:5\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:109:13\n    |\n-LL |     0 + if b { 1 } else { 2 } + if b { 3 } else { 4 } + 0;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _ = 0 + a as usize;\n+   |             ^^^^^^^^^^^^^^ help: consider reducing it to: `a as usize`\n \n-error: the operation is ineffective. Consider reducing it to `a`\n-  --> $DIR/identity_op.rs:106:7\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:110:5\n    |\n-LL |     f(1 * a + { 8 * 5 });\n-   |       ^^^^^\n+LL |     0 + { a } as usize;\n+   |     ^^^^^^^^^^^^^^^^^^ help: consider reducing it to: `({ a } as usize)`\n \n-error: the operation is ineffective. Consider reducing it to `{ 2 * 4 }`\n-  --> $DIR/identity_op.rs:108:20\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:112:9\n    |\n-LL |     const _: i32 = { 2 * 4 } + 0 + 3;\n-   |                    ^^^^^^^^^^^^^\n+LL |     2 * (0 + { a });\n+   |         ^^^^^^^^^^^ help: consider reducing it to: `{ a }`\n+\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:113:5\n+   |\n+LL |     1 * ({ a } + 4);\n+   |     ^^^^^^^^^^^^^^^ help: consider reducing it to: `(({ a } + 4))`\n+\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:114:5\n+   |\n+LL |     1 * 1;\n+   |     ^^^^^ help: consider reducing it to: `1`\n+\n+error: this operation has no effect\n+  --> $DIR/identity_op.rs:118:5\n+   |\n+LL |     0 + if a { 1 } else { 2 } + if b { 3 } else { 5 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider reducing it to: `(if a { 1 } else { 2 })`\n \n-error: aborting due to 33 previous errors\n+error: aborting due to 39 previous errors\n "}, {"sha": "adff08e5d1e8b206df72074f4ffb4da718b180bd", "filename": "tests/ui/modulo_one.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c41c410a90cd97d3e82b67375f76c161f8c280dd/tests%2Fui%2Fmodulo_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c41c410a90cd97d3e82b67375f76c161f8c280dd/tests%2Fui%2Fmodulo_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmodulo_one.rs?ref=c41c410a90cd97d3e82b67375f76c161f8c280dd", "patch": "@@ -1,5 +1,5 @@\n #![warn(clippy::modulo_one)]\n-#![allow(clippy::no_effect, clippy::unnecessary_operation)]\n+#![allow(clippy::no_effect, clippy::unnecessary_operation, clippy::identity_op)]\n \n static STATIC_ONE: usize = 2 - 1;\n static STATIC_NEG_ONE: i64 = 1 - 2;"}, {"sha": "04ecdef5e994e399002693fa0b08b9004159a2e0", "filename": "tests/ui/modulo_one.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c41c410a90cd97d3e82b67375f76c161f8c280dd/tests%2Fui%2Fmodulo_one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c41c410a90cd97d3e82b67375f76c161f8c280dd/tests%2Fui%2Fmodulo_one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmodulo_one.stderr?ref=c41c410a90cd97d3e82b67375f76c161f8c280dd", "patch": "@@ -38,14 +38,6 @@ error: any number modulo -1 will panic/overflow or result in 0\n LL |     i32::MIN % (-1); // also caught by rustc\n    |     ^^^^^^^^^^^^^^^\n \n-error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/modulo_one.rs:13:22\n-   |\n-LL |     const ONE: u32 = 1 * 1;\n-   |                      ^^^^^\n-   |\n-   = note: `-D clippy::identity-op` implied by `-D warnings`\n-\n error: any number modulo 1 will be 0\n   --> $DIR/modulo_one.rs:17:5\n    |\n@@ -64,5 +56,5 @@ error: any number modulo -1 will panic/overflow or result in 0\n LL |     INT_MIN % NEG_ONE; // also caught by rustc\n    |     ^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 9 previous errors\n "}]}