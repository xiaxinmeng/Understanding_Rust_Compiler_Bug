{"sha": "eaaee238472f36d664be0e0769590a8be374cd4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhYWVlMjM4NDcyZjM2ZDY2NGJlMGUwNzY5NTkwYThiZTM3NGNkNGQ=", "commit": {"author": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2019-01-02T06:23:00Z"}, "committer": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2019-01-02T06:23:00Z"}, "message": "UI test cleanup: Extract lint from methods.rs test", "tree": {"sha": "addfed8c5f69dc5c2aa528506d5ca099a8e606c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/addfed8c5f69dc5c2aa528506d5ca099a8e606c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eaaee238472f36d664be0e0769590a8be374cd4d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEvUKv4zqIn2RHUgCKtvoGpuDiZlsFAlwsWRoACgkQtvoGpuDi\nZltffw/+Ni/WqOnOA9ncdeA6KaQ/yLHUhDSGYS8Iy/9X4JR5CAtHMupGtQ6IRlPn\nsPhoqR0EMUqoKXbfkwxgopvV887R3OVVrUIJSkuxe0v6AAfihahTD8bH/xBtjVDT\nG1CWBiHCtUnxQsIz7O1hDEYfI3vfDS/s/uq8tye1bpFsDsP3h+Un/NSLwEuy5ZDV\nAT5/WtOU3HeqBHZ2hXqhq3KW6HnIhlsHAqHa1LZeMqIa2wcktMXe1AH+Qbx4C7/p\naMZlLaHeyEFowmpOLVUOMZedVx91UMg/9L7pCzhbTSY0WZfgkPj0iDFODtCsrCTx\n9trihb227EAnQ9A8v5u8mSBwwWcFimqTkX8KgtBPY0KD/vaz3Nx1agMlENor5pLR\nVhcclKmRA3B+girRQulYQjhRoZkz4rAivJWxK+TWWxeG2dPylKnsr4RWZEUVVURL\n5dvkCOH9FP/r6otO93rP3jXgm5hxjE/pLVjIt4EPz/Hpa+WF+XDlWaH0eEWw+uTT\nb+lWiFNddbZ7OGkCiEz2zRZvJ82ZpzhVC8gJPPRkJonef84s/sGwI2GFk67Rku9r\n2kdkn154TVR81U/KxEdnpkmhwGCplUnwQCJK2YLOA4HD+zSbb3H0CYVPhpjgq0qx\n10YW4t3VRBTNxJAxzFUh58W43BUWBzE6P9Bidz8nZZNlSgTTVIU=\n=bQ3K\n-----END PGP SIGNATURE-----", "payload": "tree addfed8c5f69dc5c2aa528506d5ca099a8e606c3\nparent 85ba5f0f17f71e5010e136cf1e7c7b6266188c42\nauthor Philipp Hansch <dev@phansch.net> 1546410180 +0100\ncommitter Philipp Hansch <dev@phansch.net> 1546410180 +0100\n\nUI test cleanup: Extract lint from methods.rs test\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eaaee238472f36d664be0e0769590a8be374cd4d", "html_url": "https://github.com/rust-lang/rust/commit/eaaee238472f36d664be0e0769590a8be374cd4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eaaee238472f36d664be0e0769590a8be374cd4d/comments", "author": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85ba5f0f17f71e5010e136cf1e7c7b6266188c42", "url": "https://api.github.com/repos/rust-lang/rust/commits/85ba5f0f17f71e5010e136cf1e7c7b6266188c42", "html_url": "https://github.com/rust-lang/rust/commit/85ba5f0f17f71e5010e136cf1e7c7b6266188c42"}], "stats": {"total": 229, "additions": 123, "deletions": 106}, "files": [{"sha": "f8ce6ba3160c4183293d6be9ecc479cca6e64bc4", "filename": "tests/auxiliary/option_helpers.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eaaee238472f36d664be0e0769590a8be374cd4d/tests%2Fauxiliary%2Foption_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaaee238472f36d664be0e0769590a8be374cd4d/tests%2Fauxiliary%2Foption_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fauxiliary%2Foption_helpers.rs?ref=eaaee238472f36d664be0e0769590a8be374cd4d", "patch": "@@ -0,0 +1,6 @@\n+/// Utility macro to test linting behavior in `option_methods()`\n+/// The lints included in `option_methods()` should not lint if the call to map is partially\n+/// within a macro\n+macro_rules! opt_map {\n+    ($opt:expr, $map:expr) => {($opt).map($map)};\n+}"}, {"sha": "b653d941fc148ddb247e3fbebc9230d0119aa85f", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eaaee238472f36d664be0e0769590a8be374cd4d/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaaee238472f36d664be0e0769590a8be374cd4d/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=eaaee238472f36d664be0e0769590a8be374cd4d", "patch": "@@ -31,6 +31,8 @@ use std::iter::FromIterator;\n use std::rc::{self, Rc};\n use std::sync::{self, Arc};\n \n+include!(\"../auxiliary/option_helpers.rs\");\n+\n pub struct T;\n \n impl T {\n@@ -101,13 +103,6 @@ impl Mul<T> for T {\n     fn mul(self, other: T) -> T { self } // no error, obviously\n }\n \n-/// Utility macro to test linting behavior in `option_methods()`\n-/// The lints included in `option_methods()` should not lint if the call to map is partially\n-/// within a macro\n-macro_rules! opt_map {\n-    ($opt:expr, $map:expr) => {($opt).map($map)};\n-}\n-\n /// Checks implementation of the following lints:\n /// * `OPTION_MAP_UNWRAP_OR`\n /// * `OPTION_MAP_UNWRAP_OR_ELSE`\n@@ -169,29 +164,6 @@ fn option_methods() {\n                 );\n }\n \n-/// Checks implementation of the following lints:\n-/// * `RESULT_MAP_UNWRAP_OR_ELSE`\n-fn result_methods() {\n-    let res: Result<i32, ()> = Ok(1);\n-\n-    // Check RESULT_MAP_UNWRAP_OR_ELSE\n-    // single line case\n-    let _ = res.map(|x| x + 1)\n-\n-               .unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-    // multi line cases\n-    let _ = res.map(|x| {\n-                        x + 1\n-                    }\n-              ).unwrap_or_else(|e| 0);\n-    let _ = res.map(|x| x + 1)\n-               .unwrap_or_else(|e|\n-                    0\n-                );\n-    // macro case\n-    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|e| 0); // should not lint\n-}\n-\n /// Struct to generate false positives for things with .iter()\n #[derive(Copy, Clone)]\n struct HasIter;"}, {"sha": "dc446ecf135984f84775678ea848536532ca459c", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 44, "deletions": 76, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/eaaee238472f36d664be0e0769590a8be374cd4d/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eaaee238472f36d664be0e0769590a8be374cd4d/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=eaaee238472f36d664be0e0769590a8be374cd4d", "patch": "@@ -1,33 +1,33 @@\n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:37:5\n+  --> $DIR/methods.rs:39:5\n    |\n LL |     pub fn add(self, other: T) -> T { self }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:48:17\n+  --> $DIR/methods.rs:50:17\n    |\n LL |     fn into_u16(&self) -> u16 { 0 }\n    |                 ^^^^^\n    |\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:50:21\n+  --> $DIR/methods.rs:52:21\n    |\n LL |     fn to_something(self) -> u32 { 0 }\n    |                     ^^^^\n \n error: methods called `new` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:52:12\n+  --> $DIR/methods.rs:54:12\n    |\n LL |     fn new(self) -> Self { unimplemented!(); }\n    |            ^^^^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:120:13\n+  --> $DIR/methods.rs:115:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -39,7 +39,7 @@ LL | |                .unwrap_or(0); // should lint even though this call is on\n    = note: replace `map(|x| x + 1).unwrap_or(0)` with `map_or(0, |x| x + 1)`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:124:13\n+  --> $DIR/methods.rs:119:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -49,7 +49,7 @@ LL | |               ).unwrap_or(0);\n    | |____________________________^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:128:13\n+  --> $DIR/methods.rs:123:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -59,15 +59,15 @@ LL | |                 });\n    | |__________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:133:13\n+  --> $DIR/methods.rs:128:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:135:13\n+  --> $DIR/methods.rs:130:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -77,7 +77,7 @@ LL | |     ).unwrap_or(None);\n    | |_____________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:139:13\n+  --> $DIR/methods.rs:134:13\n    |\n LL |       let _ = opt\n    |  _____________^\n@@ -88,7 +88,7 @@ LL | |         .unwrap_or(None);\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:147:13\n+  --> $DIR/methods.rs:142:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -100,7 +100,7 @@ LL | |                .unwrap_or_else(|| 0); // should lint even though this cal\n    = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:151:13\n+  --> $DIR/methods.rs:146:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -110,7 +110,7 @@ LL | |               ).unwrap_or_else(|| 0);\n    | |____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:155:13\n+  --> $DIR/methods.rs:150:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -120,15 +120,15 @@ LL | |                 );\n    | |_________________^\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:164:13\n+  --> $DIR/methods.rs:159:13\n    |\n LL |     let _ = opt.map_or(None, |x| Some(x + 1));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using and_then instead: `opt.and_then(|x| Some(x + 1))`\n    |\n    = note: `-D clippy::option-map-or-none` implied by `-D warnings`\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:166:13\n+  --> $DIR/methods.rs:161:13\n    |\n LL |       let _ = opt.map_or(None, |x| {\n    |  _____________^\n@@ -143,40 +143,8 @@ LL |                         Some(x + 1)\n LL |                        });\n    |\n \n-error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:179:13\n-   |\n-LL |       let _ = res.map(|x| x + 1)\n-   |  _____________^\n-LL | |\n-LL | |                .unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-   | |_____________________________________^\n-   |\n-   = note: `-D clippy::result-map-unwrap-or-else` implied by `-D warnings`\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `ok().map_or_else(|e| 0, |x| x + 1)`\n-\n-error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:183:13\n-   |\n-LL |       let _ = res.map(|x| {\n-   |  _____________^\n-LL | |                         x + 1\n-LL | |                     }\n-LL | |               ).unwrap_or_else(|e| 0);\n-   | |_____________________________________^\n-\n-error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:187:13\n-   |\n-LL |       let _ = res.map(|x| x + 1)\n-   |  _____________^\n-LL | |                .unwrap_or_else(|e|\n-LL | |                     0\n-LL | |                 );\n-   | |_________________^\n-\n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:250:13\n+  --> $DIR/methods.rs:222:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -185,7 +153,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:253:13\n+  --> $DIR/methods.rs:225:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -195,7 +163,7 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:268:13\n+  --> $DIR/methods.rs:240:13\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -204,7 +172,7 @@ LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    = note: replace `find(|&x| *x < 0).is_some()` with `any(|&x| *x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:271:13\n+  --> $DIR/methods.rs:243:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -214,15 +182,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:277:13\n+  --> $DIR/methods.rs:249:13\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `position(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:280:13\n+  --> $DIR/methods.rs:252:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -232,15 +200,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:286:13\n+  --> $DIR/methods.rs:258:13\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `rposition(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:289:13\n+  --> $DIR/methods.rs:261:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -250,130 +218,130 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:324:22\n+  --> $DIR/methods.rs:296:22\n    |\n LL |     with_constructor.unwrap_or(make());\n    |                      ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(make)`\n    |\n    = note: `-D clippy::or-fun-call` implied by `-D warnings`\n \n error: use of `unwrap_or` followed by a call to `new`\n-  --> $DIR/methods.rs:327:5\n+  --> $DIR/methods.rs:299:5\n    |\n LL |     with_new.unwrap_or(Vec::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_new.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:330:21\n+  --> $DIR/methods.rs:302:21\n    |\n LL |     with_const_args.unwrap_or(Vec::with_capacity(12));\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:333:14\n+  --> $DIR/methods.rs:305:14\n    |\n LL |     with_err.unwrap_or(make());\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| make())`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:336:19\n+  --> $DIR/methods.rs:308:19\n    |\n LL |     with_err_args.unwrap_or(Vec::with_capacity(12));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/methods.rs:339:5\n+  --> $DIR/methods.rs:311:5\n    |\n LL |     with_default_trait.unwrap_or(Default::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_trait.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/methods.rs:342:5\n+  --> $DIR/methods.rs:314:5\n    |\n LL |     with_default_type.unwrap_or(u64::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_type.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:345:14\n+  --> $DIR/methods.rs:317:14\n    |\n LL |     with_vec.unwrap_or(vec![]);\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| vec![])`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:350:21\n+  --> $DIR/methods.rs:322:21\n    |\n LL |     without_default.unwrap_or(Foo::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(Foo::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/methods.rs:353:19\n+  --> $DIR/methods.rs:325:19\n    |\n LL |     map.entry(42).or_insert(String::new());\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/methods.rs:356:21\n+  --> $DIR/methods.rs:328:21\n    |\n LL |     btree.entry(42).or_insert(String::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:359:21\n+  --> $DIR/methods.rs:331:21\n    |\n LL |     let _ = stringy.unwrap_or(\"\".to_owned());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n error: called `.iter().nth()` on a Vec. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:370:23\n+  --> $DIR/methods.rs:342:23\n    |\n LL |         let bad_vec = some_vec.iter().nth(3);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::iter-nth` implied by `-D warnings`\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:371:26\n+  --> $DIR/methods.rs:343:26\n    |\n LL |         let bad_slice = &some_vec[..].iter().nth(3);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:372:31\n+  --> $DIR/methods.rs:344:31\n    |\n LL |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a VecDeque. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:373:29\n+  --> $DIR/methods.rs:345:29\n    |\n LL |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a Vec. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:378:23\n+  --> $DIR/methods.rs:350:23\n    |\n LL |         let bad_vec = some_vec.iter_mut().nth(3);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a slice. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:381:26\n+  --> $DIR/methods.rs:353:26\n    |\n LL |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a VecDeque. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:384:29\n+  --> $DIR/methods.rs:356:29\n    |\n LL |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-  --> $DIR/methods.rs:396:13\n+  --> $DIR/methods.rs:368:13\n    |\n LL |     let _ = opt.unwrap();\n    |             ^^^^^^^^^^^^\n    |\n    = note: `-D clippy::option-unwrap-used` implied by `-D warnings`\n \n-error: aborting due to 46 previous errors\n+error: aborting due to 43 previous errors\n "}, {"sha": "2995babe30c1f42cfb02b1af7f435698c8b588d9", "filename": "tests/ui/result_map_unwrap_or_else.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/eaaee238472f36d664be0e0769590a8be374cd4d/tests%2Fui%2Fresult_map_unwrap_or_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaaee238472f36d664be0e0769590a8be374cd4d/tests%2Fui%2Fresult_map_unwrap_or_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unwrap_or_else.rs?ref=eaaee238472f36d664be0e0769590a8be374cd4d", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014-2019 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Checks implementation of `RESULT_MAP_UNWRAP_OR_ELSE`\n+\n+#![warn(clippy::result_map_unwrap_or_else)]\n+\n+include!(\"../auxiliary/option_helpers.rs\");\n+\n+fn result_methods() {\n+    let res: Result<i32, ()> = Ok(1);\n+\n+    // Check RESULT_MAP_UNWRAP_OR_ELSE\n+    // single line case\n+    let _ = res.map(|x| x + 1)\n+\n+               .unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n+    // multi line cases\n+    let _ = res.map(|x| {\n+                        x + 1\n+                    }\n+              ).unwrap_or_else(|e| 0);\n+    let _ = res.map(|x| x + 1)\n+               .unwrap_or_else(|e|\n+                    0\n+                );\n+    // macro case\n+    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|e| 0); // should not lint\n+}\n+\n+fn main() {}"}, {"sha": "fb1555b4f6ea9289a0cf0d32528c15efc7109345", "filename": "tests/ui/result_map_unwrap_or_else.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eaaee238472f36d664be0e0769590a8be374cd4d/tests%2Fui%2Fresult_map_unwrap_or_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eaaee238472f36d664be0e0769590a8be374cd4d/tests%2Fui%2Fresult_map_unwrap_or_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unwrap_or_else.stderr?ref=eaaee238472f36d664be0e0769590a8be374cd4d", "patch": "@@ -0,0 +1,34 @@\n+error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n+  --> $DIR/result_map_unwrap_or_else.rs:21:13\n+   |\n+LL |       let _ = res.map(|x| x + 1)\n+   |  _____________^\n+LL | |\n+LL | |                .unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n+   | |_____________________________________^\n+   |\n+   = note: `-D clippy::result-map-unwrap-or-else` implied by `-D warnings`\n+   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `ok().map_or_else(|e| 0, |x| x + 1)`\n+\n+error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n+  --> $DIR/result_map_unwrap_or_else.rs:25:13\n+   |\n+LL |       let _ = res.map(|x| {\n+   |  _____________^\n+LL | |                         x + 1\n+LL | |                     }\n+LL | |               ).unwrap_or_else(|e| 0);\n+   | |_____________________________________^\n+\n+error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n+  --> $DIR/result_map_unwrap_or_else.rs:29:13\n+   |\n+LL |       let _ = res.map(|x| x + 1)\n+   |  _____________^\n+LL | |                .unwrap_or_else(|e|\n+LL | |                     0\n+LL | |                 );\n+   | |_________________^\n+\n+error: aborting due to 3 previous errors\n+"}]}