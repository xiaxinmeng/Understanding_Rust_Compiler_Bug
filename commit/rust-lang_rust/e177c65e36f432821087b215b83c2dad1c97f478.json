{"sha": "e177c65e36f432821087b215b83c2dad1c97f478", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNzdjNjVlMzZmNDMyODIxMDg3YjIxNWI4M2MyZGFkMWM5N2Y0Nzg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-13T08:40:51Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-13T08:54:21Z"}, "message": "Use strongly-typed ast building for early-return assist", "tree": {"sha": "1f49b178983c1c409de123af8f09d07363aa040a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f49b178983c1c409de123af8f09d07363aa040a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e177c65e36f432821087b215b83c2dad1c97f478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e177c65e36f432821087b215b83c2dad1c97f478", "html_url": "https://github.com/rust-lang/rust/commit/e177c65e36f432821087b215b83c2dad1c97f478", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e177c65e36f432821087b215b83c2dad1c97f478/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a69d584d6afc842d6dc8503f3fd3a0a691ea385", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a69d584d6afc842d6dc8503f3fd3a0a691ea385", "html_url": "https://github.com/rust-lang/rust/commit/2a69d584d6afc842d6dc8503f3fd3a0a691ea385"}], "stats": {"total": 147, "additions": 102, "deletions": 45}, "files": [{"sha": "26441252662b97c015386bf040f7ebbf4d102918", "filename": "crates/ra_assists/src/assists/early_return.rs", "status": "modified", "additions": 71, "deletions": 24, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e177c65e36f432821087b215b83c2dad1c97f478/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e177c65e36f432821087b215b83c2dad1c97f478/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs?ref=e177c65e36f432821087b215b83c2dad1c97f478", "patch": "@@ -1,4 +1,4 @@\n-use std::ops::RangeInclusive;\n+use std::{iter::once, ops::RangeInclusive};\n \n use hir::db::HirDatabase;\n use ra_syntax::{\n@@ -45,19 +45,22 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n     let cond = if_expr.condition()?;\n \n     // Check if there is an IfLet that we can handle.\n-    let bound_ident = match cond.pat() {\n+    let if_let_pat = match cond.pat() {\n         None => None, // No IfLet, supported.\n         Some(TupleStructPat(pat)) if pat.args().count() == 1 => {\n             let path = pat.path()?;\n             match path.qualifier() {\n-                None => Some(path.segment()?.name_ref()?),\n+                None => {\n+                    let bound_ident = pat.args().next().unwrap();\n+                    Some((path, bound_ident))\n+                }\n                 Some(_) => return None,\n             }\n         }\n         Some(_) => return None, // Unsupported IfLet.\n     };\n \n-    let expr = cond.expr()?;\n+    let cond_expr = cond.expr()?;\n     let then_block = if_expr.then_branch()?.block()?;\n \n     let parent_block = if_expr.syntax().parent()?.ancestors().find_map(ast::Block::cast)?;\n@@ -79,11 +82,11 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n     let parent_container = parent_block.syntax().parent()?.parent()?;\n \n-    let early_expression = match parent_container.kind() {\n-        WHILE_EXPR | LOOP_EXPR => Some(\"continue\"),\n-        FN_DEF => Some(\"return\"),\n-        _ => None,\n-    }?;\n+    let early_expression: ast::Expr = match parent_container.kind() {\n+        WHILE_EXPR | LOOP_EXPR => make::expr_continue().into(),\n+        FN_DEF => make::expr_return().into(),\n+        _ => return None,\n+    };\n \n     if then_block.syntax().first_child_or_token().map(|t| t.kind() == L_CURLY).is_none() {\n         return None;\n@@ -94,22 +97,43 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n     ctx.add_assist(AssistId(\"convert_to_guarded_return\"), \"convert to guarded return\", |edit| {\n         let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n-        let new_block = match bound_ident {\n+        let new_block = match if_let_pat {\n             None => {\n                 // If.\n-                let early_expression = &(early_expression.to_owned() + \";\");\n-                let new_expr =\n-                    if_indent_level.increase_indent(make::if_expression(&expr, early_expression));\n+                let early_expression = &(early_expression.syntax().to_string() + \";\");\n+                let new_expr = if_indent_level\n+                    .increase_indent(make::if_expression(&cond_expr, early_expression));\n                 replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n             }\n-            Some(bound_ident) => {\n+            Some((path, bound_ident)) => {\n                 // If-let.\n-                let new_expr = if_indent_level.increase_indent(make::let_match_early(\n-                    expr,\n-                    &bound_ident.syntax().to_string(),\n-                    early_expression,\n-                ));\n-                replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n+                let match_expr = {\n+                    let happy_arm = make::match_arm(\n+                        once(\n+                            make::tuple_struct_pat(\n+                                path,\n+                                once(make::bind_pat(make::name(\"it\")).into()),\n+                            )\n+                            .into(),\n+                        ),\n+                        make::expr_path(make::path_from_name_ref(make::name_ref(\"it\"))).into(),\n+                    );\n+\n+                    let sad_arm = make::match_arm(\n+                        // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n+                        once(make::placeholder_pat().into()),\n+                        early_expression.into(),\n+                    );\n+\n+                    make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n+                };\n+\n+                let let_stmt = make::let_stmt(\n+                    make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n+                    Some(match_expr.into()),\n+                );\n+                let let_stmt = if_indent_level.increase_indent(let_stmt);\n+                replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n             }\n         };\n         edit.target(if_expr.syntax().text_range());\n@@ -205,7 +229,7 @@ mod tests {\n                 bar();\n                 le<|>t n = match n {\n                     Some(it) => it,\n-                    None => return,\n+                    _ => return,\n                 };\n                 foo(n);\n \n@@ -216,6 +240,29 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_if_let_result() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main() {\n+                if<|> let Ok(x) = Err(92) {\n+                    foo(x);\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                le<|>t x = match Err(92) {\n+                    Ok(it) => it,\n+                    _ => return,\n+                };\n+                foo(x);\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn convert_let_ok_inside_fn() {\n         check_assist(\n@@ -236,7 +283,7 @@ mod tests {\n                 bar();\n                 le<|>t n = match n {\n                     Ok(it) => it,\n-                    None => return,\n+                    _ => return,\n                 };\n                 foo(n);\n \n@@ -294,7 +341,7 @@ mod tests {\n                 while true {\n                     le<|>t n = match n {\n                         Some(it) => it,\n-                        None => continue,\n+                        _ => continue,\n                     };\n                     foo(n);\n                     bar();\n@@ -351,7 +398,7 @@ mod tests {\n                 loop {\n                     le<|>t n = match n {\n                         Some(it) => it,\n-                        None => continue,\n+                        _ => continue,\n                     };\n                     foo(n);\n                     bar();"}, {"sha": "6c903ca641f207df1cf551cb9263e28cd2cbbbb4", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e177c65e36f432821087b215b83c2dad1c97f478/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e177c65e36f432821087b215b83c2dad1c97f478/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=e177c65e36f432821087b215b83c2dad1c97f478", "patch": "@@ -4,6 +4,10 @@ use itertools::Itertools;\n \n use crate::{ast, AstNode, SourceFile};\n \n+pub fn name(text: &str) -> ast::Name {\n+    ast_from_text(&format!(\"mod {};\", text))\n+}\n+\n pub fn name_ref(text: &str) -> ast::NameRef {\n     ast_from_text(&format!(\"fn f() {{ {}; }}\", text))\n }\n@@ -43,6 +47,21 @@ pub fn expr_unit() -> ast::Expr {\n pub fn expr_unimplemented() -> ast::Expr {\n     expr_from_text(\"unimplemented!()\")\n }\n+pub fn expr_path(path: ast::Path) -> ast::Expr {\n+    expr_from_text(&path.syntax().to_string())\n+}\n+pub fn expr_continue() -> ast::Expr {\n+    expr_from_text(\"continue\")\n+}\n+pub fn expr_break() -> ast::Expr {\n+    expr_from_text(\"break\")\n+}\n+pub fn expr_return() -> ast::Expr {\n+    expr_from_text(\"return\")\n+}\n+pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Expr {\n+    expr_from_text(&format!(\"match {} {}\", expr.syntax(), match_arm_list.syntax()))\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }\n@@ -92,41 +111,24 @@ pub fn path_pat(path: ast::Path) -> ast::PathPat {\n     }\n }\n \n-pub fn match_arm(pats: impl Iterator<Item = ast::Pat>, expr: ast::Expr) -> ast::MatchArm {\n-    let pats_str = pats.map(|p| p.syntax().to_string()).join(\" | \");\n+pub fn match_arm(pats: impl IntoIterator<Item = ast::Pat>, expr: ast::Expr) -> ast::MatchArm {\n+    let pats_str = pats.into_iter().map(|p| p.syntax().to_string()).join(\" | \");\n     return from_text(&format!(\"{} => {}\", pats_str, expr.syntax()));\n \n     fn from_text(text: &str) -> ast::MatchArm {\n         ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n     }\n }\n \n-pub fn match_arm_list(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n-    let arms_str = arms.map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n+pub fn match_arm_list(arms: impl IntoIterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n+    let arms_str = arms.into_iter().map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n     return from_text(&format!(\"{},\\n\", arms_str));\n \n     fn from_text(text: &str) -> ast::MatchArmList {\n         ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n     }\n }\n \n-pub fn let_match_early(expr: ast::Expr, path: &str, early_expression: &str) -> ast::LetStmt {\n-    return from_text(&format!(\n-        r#\"let {} = match {} {{\n-    {}(it) => it,\n-    None => {},\n-}};\"#,\n-        expr.syntax().text(),\n-        expr.syntax().text(),\n-        path,\n-        early_expression\n-    ));\n-\n-    fn from_text(text: &str) -> ast::LetStmt {\n-        ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n-    }\n-}\n-\n pub fn where_pred(path: ast::Path, bounds: impl Iterator<Item = ast::TypeBound>) -> ast::WherePred {\n     let bounds = bounds.map(|b| b.syntax().to_string()).join(\" + \");\n     return from_text(&format!(\"{}: {}\", path.syntax(), bounds));\n@@ -153,6 +155,14 @@ pub fn if_expression(condition: &ast::Expr, statement: &str) -> ast::IfExpr {\n     ))\n }\n \n+pub fn let_stmt(pattern: ast::Pat, initializer: Option<ast::Expr>) -> ast::LetStmt {\n+    let text = match initializer {\n+        Some(it) => format!(\"let {} = {};\", pattern.syntax(), it.syntax()),\n+        None => format!(\"let {};\", pattern.syntax()),\n+    };\n+    ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n+}\n+\n fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     let res = parse.tree().syntax().descendants().find_map(N::cast).unwrap();"}]}