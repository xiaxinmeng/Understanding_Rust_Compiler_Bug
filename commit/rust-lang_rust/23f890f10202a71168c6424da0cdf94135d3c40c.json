{"sha": "23f890f10202a71168c6424da0cdf94135d3c40c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzZjg5MGYxMDIwMmE3MTE2OGM2NDI0ZGEwY2RmOTQxMzVkM2M0MGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-25T11:13:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-25T11:13:30Z"}, "message": "Auto merge of #65804 - Centril:rollup-arlxgch, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #64639 (Stabilize `#[non_exhaustive]` (RFC 2008))\n - #65074 (Fix the start/end byte positions in the compiler JSON output)\n - #65315 (Intern place projection)\n - #65685 (Fix check of `statx` and handle EPERM)\n - #65731 (Prevent unnecessary allocation in PathBuf::set_extension.)\n - #65740 (Fix default \"disable-shortcuts\" feature value)\n - #65787 (move panictry! to where it is used.)\n - #65789 (move Attribute::with_desugared_doc to librustdoc)\n - #65790 (move report_invalid_macro_expansion_item to item.rs)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8d77ecdc401e9ae082a217c707d933ecd197708b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d77ecdc401e9ae082a217c707d933ecd197708b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23f890f10202a71168c6424da0cdf94135d3c40c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23f890f10202a71168c6424da0cdf94135d3c40c", "html_url": "https://github.com/rust-lang/rust/commit/23f890f10202a71168c6424da0cdf94135d3c40c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23f890f10202a71168c6424da0cdf94135d3c40c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85943fd7c88ddf870b03afdd6cd6782721c348e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/85943fd7c88ddf870b03afdd6cd6782721c348e1", "html_url": "https://github.com/rust-lang/rust/commit/85943fd7c88ddf870b03afdd6cd6782721c348e1"}, {"sha": "c0bbb4bcdce880711c13b535fc4d9cd369741782", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0bbb4bcdce880711c13b535fc4d9cd369741782", "html_url": "https://github.com/rust-lang/rust/commit/c0bbb4bcdce880711c13b535fc4d9cd369741782"}], "stats": {"total": 3214, "additions": 1859, "deletions": 1355}, "files": [{"sha": "907147c17ef8e500260577c1c637d7260bc7bd5b", "filename": "src/doc/unstable-book/src/language-features/non-exhaustive.md", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/85943fd7c88ddf870b03afdd6cd6782721c348e1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md", "raw_url": "https://github.com/rust-lang/rust/raw/85943fd7c88ddf870b03afdd6cd6782721c348e1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md?ref=85943fd7c88ddf870b03afdd6cd6782721c348e1", "patch": "@@ -1,76 +0,0 @@\n-# `non_exhaustive`\n-\n-The tracking issue for this feature is: [#44109]\n-\n-[#44109]: https://github.com/rust-lang/rust/issues/44109\n-\n-------------------------\n-\n-The `non_exhaustive` gate allows you to use the `#[non_exhaustive]` attribute\n-on structs, enums and enum variants. When applied within a crate, users of the\n-crate will need to use the `_` pattern when matching enums and use the `..`\n-pattern when matching structs. Enum variants cannot be matched against.\n-Structs and enum variants marked as `non_exhaustive` will not be able to\n-be created normally outside of the defining crate. This is demonstrated\n-below:\n-\n-```rust,ignore (pseudo-Rust)\n-use std::error::Error as StdError;\n-\n-#[non_exhaustive]\n-pub enum Error {\n-    Message(String),\n-    Other,\n-}\n-impl StdError for Error {\n-    fn description(&self) -> &str {\n-        // This will not error, despite being marked as non_exhaustive, as this\n-        // enum is defined within the current crate, it can be matched\n-        // exhaustively.\n-        match *self {\n-            Message(ref s) => s,\n-            Other => \"other or unknown error\",\n-        }\n-    }\n-}\n-```\n-\n-```rust,ignore (pseudo-Rust)\n-use mycrate::Error;\n-\n-// This will not error as the non_exhaustive Error enum has been matched with\n-// a wildcard.\n-match error {\n-    Message(ref s) => ...,\n-    Other => ...,\n-    _ => ...,\n-}\n-```\n-\n-```rust,ignore (pseudo-Rust)\n-#[non_exhaustive]\n-pub struct Config {\n-    pub window_width: u16,\n-    pub window_height: u16,\n-}\n-\n-// We can create structs as normal within the defining crate when marked as\n-// non_exhaustive.\n-let config = Config { window_width: 640, window_height: 480 };\n-\n-// We can match structs exhaustively when within the defining crate.\n-if let Ok(Config { window_width, window_height }) = load_config() {\n-    // ...\n-}\n-```\n-\n-```rust,ignore (pseudo-Rust)\n-use mycrate::Config;\n-\n-// We cannot create a struct like normal if it has been marked as\n-// non_exhaustive.\n-let config = Config { window_width: 640, window_height: 480 };\n-// By adding the `..` we can match the config as below outside of the crate\n-// when marked non_exhaustive.\n-let &Config { window_width, window_height, .. } = config;\n-```"}, {"sha": "0819969b9336088b700d32aa800430e3d5a9ab89", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -121,7 +121,7 @@\n #![feature(hexagon_target_feature)]\n #![feature(const_int_conversion)]\n #![feature(const_transmute)]\n-#![feature(non_exhaustive)]\n+#![cfg_attr(bootstrap, feature(non_exhaustive))]\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]"}, {"sha": "6166561d87f15a8ef4075a2338a49cd79ab091b3", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -25,7 +25,7 @@\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n-#![feature(non_exhaustive)]\n+#![cfg_attr(bootstrap, feature(non_exhaustive))]\n #![feature(rustc_attrs)]\n #![feature(specialization)]\n "}, {"sha": "cf268078a2c5dcb3b2c2fbb60a11889e09721672", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -2105,8 +2105,6 @@ on something other than a struct or enum.\n Examples of erroneous code:\n \n ```compile_fail,E0701\n-# #![feature(non_exhaustive)]\n-\n #[non_exhaustive]\n trait Foo { }\n ```"}, {"sha": "2510d7efb59e7eac876a753925dc54a4c8f355ba", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -425,6 +425,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n             ref lines,\n             ref multibyte_chars,\n             ref non_narrow_chars,\n+            ref normalized_pos,\n         } = *self;\n \n         (name_hash as u64).hash_stable(hcx, hasher);\n@@ -453,6 +454,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n         for &char_pos in non_narrow_chars.iter() {\n             stable_non_narrow_char(char_pos, start_pos).hash_stable(hcx, hasher);\n         }\n+\n+        normalized_pos.len().hash_stable(hcx, hasher);\n+        for &char_pos in normalized_pos.iter() {\n+            stable_normalized_pos(char_pos, start_pos).hash_stable(hcx, hasher);\n+        }\n+\n     }\n }\n \n@@ -482,6 +489,18 @@ fn stable_non_narrow_char(swc: ::syntax_pos::NonNarrowChar,\n     (pos.0 - source_file_start.0, width as u32)\n }\n \n+fn stable_normalized_pos(np: ::syntax_pos::NormalizedPos,\n+                         source_file_start: ::syntax_pos::BytePos)\n+                         -> (u32, u32) {\n+    let ::syntax_pos::NormalizedPos {\n+        pos,\n+        diff\n+    } = np;\n+\n+    (pos.0 - source_file_start.0, diff)\n+}\n+\n+\n impl<'tcx> HashStable<StableHashingContext<'tcx>> for feature_gate::Features {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         // Unfortunately we cannot exhaustively list fields here, since the"}, {"sha": "996f5b1241263e7397e29ee93cc2c95c0e5a9aac", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -41,7 +41,7 @@\n #![feature(overlapping_marker_traits)]\n #![feature(extern_types)]\n #![feature(nll)]\n-#![feature(non_exhaustive)]\n+#![cfg_attr(bootstrap, feature(non_exhaustive))]\n #![feature(optin_builtin_traits)]\n #![feature(option_expect_none)]\n #![feature(range_is_empty)]"}, {"sha": "fb9c95724c955e90e1225c6a5d9db99147c33dca", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 39, "deletions": 58, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -15,8 +15,7 @@ use crate::ty::layout::VariantIdx;\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{\n-    self, AdtDef, CanonicalUserTypeAnnotations, Region, Ty, TyCtxt,\n-    UserTypeAnnotationIndex,\n+    self, AdtDef, CanonicalUserTypeAnnotations, List, Region, Ty, TyCtxt, UserTypeAnnotationIndex,\n };\n \n use polonius_engine::Atom;\n@@ -1712,15 +1711,17 @@ impl Debug for Statement<'_> {\n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n #[derive(\n-    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n+    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, HashStable,\n )]\n pub struct Place<'tcx> {\n     pub base: PlaceBase<'tcx>,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n-    pub projection: Box<[PlaceElem<'tcx>]>,\n+    pub projection: &'tcx List<PlaceElem<'tcx>>,\n }\n \n+impl<'tcx> rustc_serialize::UseSpecializedDecodable for Place<'tcx> {}\n+\n #[derive(\n     Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n )]\n@@ -1824,6 +1825,8 @@ impl<V, T> ProjectionElem<V, T> {\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n \n+impl<'tcx> Copy for PlaceElem<'tcx> { }\n+\n // At least on 64 bit systems, `PlaceElem` should not be larger than two pointers.\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PlaceElem<'_>, 16);\n@@ -1846,50 +1849,11 @@ pub struct PlaceRef<'a, 'tcx> {\n }\n \n impl<'tcx> Place<'tcx> {\n-    // FIXME change this back to a const when projection is a shared slice.\n-    //\n-    // pub const RETURN_PLACE: Place<'tcx> = Place {\n-    //     base: PlaceBase::Local(RETURN_PLACE),\n-    //     projection: &[],\n-    // };\n+    // FIXME change this to a const fn by also making List::empty a const fn.\n     pub fn return_place() -> Place<'tcx> {\n         Place {\n             base: PlaceBase::Local(RETURN_PLACE),\n-            projection: Box::new([]),\n-        }\n-    }\n-\n-    pub fn field(self, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Field(f, ty))\n-    }\n-\n-    pub fn deref(self) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Deref)\n-    }\n-\n-    pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Downcast(\n-            Some(adt_def.variants[variant_index].ident.name),\n-            variant_index,\n-        ))\n-    }\n-\n-    pub fn downcast_unnamed(self, variant_index: VariantIdx) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Downcast(None, variant_index))\n-    }\n-\n-    pub fn index(self, index: Local) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Index(index))\n-    }\n-\n-    pub fn elem(self, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n-        // FIXME(spastorino): revisit this again once projection is not a Box<[T]> anymore\n-        let mut projection = self.projection.into_vec();\n-        projection.push(elem);\n-\n-        Place {\n-            base: self.base,\n-            projection: projection.into_boxed_slice(),\n+            projection: List::empty(),\n         }\n     }\n \n@@ -1906,26 +1870,23 @@ impl<'tcx> Place<'tcx> {\n     //\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n-        match self {\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n+        match self.as_ref() {\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[],\n             } |\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [ProjectionElem::Deref],\n-            } => Some(*local),\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[ProjectionElem::Deref],\n+            } => Some(local),\n             _ => None,\n         }\n     }\n \n     /// If this place represents a local variable like `_X` with no\n     /// projections, return `Some(_X)`.\n     pub fn as_local(&self) -> Option<Local> {\n-        match self {\n-            Place { projection: box [], base: PlaceBase::Local(l) } => Some(*l),\n-            _ => None,\n-        }\n+        self.as_ref().as_local()\n     }\n \n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n@@ -1940,7 +1901,7 @@ impl From<Local> for Place<'_> {\n     fn from(local: Local) -> Self {\n         Place {\n             base: local.into(),\n-            projection: Box::new([]),\n+            projection: List::empty(),\n         }\n     }\n }\n@@ -1969,6 +1930,15 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n             _ => None,\n         }\n     }\n+\n+    /// If this place represents a local variable like `_X` with no\n+    /// projections, return `Some(_X)`.\n+    pub fn as_local(&self) -> Option<Local> {\n+        match self {\n+            PlaceRef { base: PlaceBase::Local(l), projection: [] } => Some(*l),\n+            _ => None,\n+        }\n+    }\n }\n \n impl Debug for Place<'_> {\n@@ -3182,6 +3152,17 @@ impl<'tcx> TypeFoldable<'tcx> for PlaceBase<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>();\n+        folder.tcx().intern_place_elems(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Static<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Static {"}, {"sha": "6a41b843e5794dd2ee0b2eadd57b75cfb8112379", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -784,6 +784,8 @@ macro_rules! make_mir_visitor {\n \n macro_rules! visit_place_fns {\n     (mut) => (\n+        fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n+\n         fn super_place(\n             &mut self,\n             place: &mut Place<'tcx>,\n@@ -793,19 +795,21 @@ macro_rules! visit_place_fns {\n             self.visit_place_base(&mut place.base, context, location);\n \n             if let Some(new_projection) = self.process_projection(&place.projection) {\n-                place.projection = new_projection;\n+                place.projection = self.tcx().intern_place_elems(&new_projection);\n             }\n         }\n \n         fn process_projection(\n             &mut self,\n             projection: &'a [PlaceElem<'tcx>],\n-        ) -> Option<Box<[PlaceElem<'tcx>]>> {\n+        ) -> Option<Vec<PlaceElem<'tcx>>> {\n             let mut projection = Cow::Borrowed(projection);\n \n             for i in 0..projection.len() {\n                 if let Some(elem) = projection.get(i) {\n                     if let Some(elem) = self.process_projection_elem(elem) {\n+                        // This converts the borrowed projection into `Cow::Owned(_)` and returns a\n+                        // clone of the projection so we can mutate and reintern later.\n                         let vec = projection.to_mut();\n                         vec[i] = elem;\n                     }\n@@ -814,7 +818,7 @@ macro_rules! visit_place_fns {\n \n             match projection {\n                 Cow::Borrowed(_) => None,\n-                Cow::Owned(vec) => Some(vec.into_boxed_slice()),\n+                Cow::Owned(vec) => Some(vec),\n             }\n         }\n "}, {"sha": "d5e7ac19263a0c13f2080b3d3a93f7619f790eb1", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -13,9 +13,9 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_serialize::{Decodable, Decoder, Encoder, Encodable, opaque};\n use std::hash::Hash;\n use std::intrinsics;\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, List, Ty, TyCtxt};\n use crate::ty::subst::SubstsRef;\n-use crate::mir::interpret::Allocation;\n+use crate::mir::{self, interpret::Allocation};\n use syntax_pos::Span;\n \n /// The shorthand encoding uses an enum's variant index `usize`\n@@ -218,6 +218,18 @@ where\n     Ok(tcx.mk_substs((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n+#[inline]\n+pub fn decode_place<D>(decoder: &mut D) -> Result<mir::Place<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n+{\n+    let base: mir::PlaceBase<'tcx> = Decodable::decode(decoder)?;\n+    let len = decoder.read_usize()?;\n+    let projection: &'tcx List<mir::PlaceElem<'tcx>> =\n+        decoder.tcx().mk_place_elems((0..len).map(|_| Decodable::decode(decoder)))?;\n+    Ok(mir::Place { base, projection })\n+}\n+\n #[inline]\n pub fn decode_region<D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D::Error>\n where\n@@ -413,6 +425,15 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n+            impl<$($typaram),*> SpecializedDecoder<$crate::mir::Place<'tcx>>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(\n+                    &mut self\n+                ) -> Result<$crate::mir::Place<'tcx>, Self::Error> {\n+                    decode_place(self)\n+                }\n+            }\n+\n             impl<$($typaram),*> SpecializedDecoder<ty::Region<'tcx>>\n             for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(&mut self) -> Result<ty::Region<'tcx>, Self::Error> {"}, {"sha": "f958a7e357b398736682d5de5a904e98ef826797", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 68, "deletions": 2, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n@@ -21,7 +22,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{Body, interpret, ProjectionKind, Promoted};\n+use crate::mir::{Body, Field, interpret, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n@@ -106,6 +107,7 @@ pub struct CtxtInterners<'tcx> {\n     goal: InternedSet<'tcx, GoalKind<'tcx>>,\n     goal_list: InternedSet<'tcx, List<Goal<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n+    place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n }\n \n@@ -124,6 +126,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             goal: Default::default(),\n             goal_list: Default::default(),\n             projs: Default::default(),\n+            place_elems: Default::default(),\n             const_: Default::default(),\n         }\n     }\n@@ -2142,6 +2145,13 @@ impl<'tcx> Borrow<[ProjectionKind]>\n     }\n }\n \n+impl<'tcx> Borrow<[PlaceElem<'tcx>]>\n+    for Interned<'tcx, List<PlaceElem<'tcx>>> {\n+    fn borrow(&self) -> &[PlaceElem<'tcx>] {\n+        &self.0[..]\n+    }\n+}\n+\n impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n     fn borrow(&self) -> &RegionKind {\n         &self.0\n@@ -2242,7 +2252,8 @@ slice_interners!(\n     predicates: _intern_predicates(Predicate<'tcx>),\n     clauses: _intern_clauses(Clause<'tcx>),\n     goal_list: _intern_goals(Goal<'tcx>),\n-    projs: _intern_projs(ProjectionKind)\n+    projs: _intern_projs(ProjectionKind),\n+    place_elems: _intern_place_elems(PlaceElem<'tcx>)\n );\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -2584,6 +2595,48 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(Opaque(def_id, substs))\n     }\n \n+    pub fn mk_place_field(self, place: Place<'tcx>, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Field(f, ty))\n+    }\n+\n+    pub fn mk_place_deref(self, place: Place<'tcx>) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Deref)\n+    }\n+\n+    pub fn mk_place_downcast(\n+        self,\n+        place: Place<'tcx>,\n+        adt_def: &'tcx AdtDef,\n+        variant_index: VariantIdx,\n+    ) -> Place<'tcx> {\n+        self.mk_place_elem(\n+            place,\n+            PlaceElem::Downcast(Some(adt_def.variants[variant_index].ident.name), variant_index),\n+        )\n+    }\n+\n+    pub fn mk_place_downcast_unnamed(\n+        self,\n+        place: Place<'tcx>,\n+        variant_index: VariantIdx,\n+    ) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Downcast(None, variant_index))\n+    }\n+\n+    pub fn mk_place_index(self, place: Place<'tcx>, index: Local) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Index(index))\n+    }\n+\n+    /// This method copies `Place`'s projection, add an element and reintern it. Should not be used\n+    /// to build a full `Place` it's just a convenient way to grab a projection and modify it in\n+    /// flight.\n+    pub fn mk_place_elem(self, place: Place<'tcx>, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n+        let mut projection = place.projection.to_vec();\n+        projection.push(elem);\n+\n+        Place { base: place.base, projection: self.intern_place_elems(&projection) }\n+    }\n+\n     pub fn intern_existential_predicates(self, eps: &[ExistentialPredicate<'tcx>])\n         -> &'tcx List<ExistentialPredicate<'tcx>> {\n         assert!(!eps.is_empty());\n@@ -2628,6 +2681,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    pub fn intern_place_elems(self, ts: &[PlaceElem<'tcx>]) -> &'tcx List<PlaceElem<'tcx>> {\n+        if ts.len() == 0 {\n+            List::empty()\n+        } else {\n+            self._intern_place_elems(ts)\n+        }\n+    }\n+\n     pub fn intern_canonical_var_infos(self, ts: &[CanonicalVarInfo]) -> CanonicalVarInfos<'tcx> {\n         if ts.len() == 0 {\n             List::empty()\n@@ -2690,6 +2751,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_substs(xs))\n     }\n \n+    pub fn mk_place_elems<I: InternAs<[PlaceElem<'tcx>],\n+                          &'tcx List<PlaceElem<'tcx>>>>(self, iter: I) -> I::Output {\n+        iter.intern_with(|xs| self.intern_place_elems(xs))\n+    }\n+\n     pub fn mk_substs_trait(self,\n                      self_ty: Ty<'tcx>,\n                      rest: &[GenericArg<'tcx>])"}, {"sha": "604deffcf949bd7ffad5df2bc583f34ccb310f04", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -191,10 +191,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                     location: Location) {\n         debug!(\"visit_assign(place={:?}, rvalue={:?})\", place, rvalue);\n \n-        if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *place {\n+        if let Some(index) = place.as_local() {\n             self.assign(index, location);\n             let decl_span = self.fx.mir.local_decls[index].source_info.span;\n             if !self.fx.rvalue_creates_operand(rvalue, decl_span) {"}, {"sha": "28441cae26e3fb3025bd085071b2374d05995690", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 34, "deletions": 50, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -2,7 +2,7 @@ use rustc_index::vec::Idx;\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, FnTypeExt};\n-use rustc::mir::{self, Place, PlaceBase, Static, StaticKind};\n+use rustc::mir::{self, PlaceBase, Static, StaticKind};\n use rustc::mir::interpret::PanicInfo;\n use rustc_target::abi::call::{ArgType, FnType, PassMode};\n use rustc_target::spec::abi::Abi;\n@@ -630,53 +630,43 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // checked by const-qualification, which also\n                 // promotes any complex rvalues to constants.\n                 if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n-                    match *arg {\n+                    match arg {\n                         // The shuffle array argument is usually not an explicit constant,\n                         // but specified directly in the code. This means it gets promoted\n                         // and we can then extract the value by evaluating the promoted.\n-                        mir::Operand::Copy(\n-                            Place {\n-                                base: PlaceBase::Static(box Static {\n-                                    kind: StaticKind::Promoted(promoted, _),\n+                        mir::Operand::Copy(place) | mir::Operand::Move(place) => {\n+                            if let mir::PlaceRef {\n+                                base:\n+                                    &PlaceBase::Static(box Static {\n+                                        kind: StaticKind::Promoted(promoted, _),\n+                                        ty,\n+                                        def_id: _,\n+                                    }),\n+                                projection: &[],\n+                            } = place.as_ref()\n+                            {\n+                                let param_env = ty::ParamEnv::reveal_all();\n+                                let cid = mir::interpret::GlobalId {\n+                                    instance: self.instance,\n+                                    promoted: Some(promoted),\n+                                };\n+                                let c = bx.tcx().const_eval(param_env.and(cid));\n+                                let (llval, ty) = self.simd_shuffle_indices(\n+                                    &bx,\n+                                    terminator.source_info.span,\n                                     ty,\n-                                    def_id: _,\n-                                }),\n-                                projection: box [],\n+                                    c,\n+                                );\n+                                return OperandRef {\n+                                    val: Immediate(llval),\n+                                    layout: bx.layout_of(ty),\n+                                };\n+                            } else {\n+                                span_bug!(span, \"shuffle indices must be constant\");\n                             }\n-                        ) |\n-                        mir::Operand::Move(\n-                            Place {\n-                                base: PlaceBase::Static(box Static {\n-                                    kind: StaticKind::Promoted(promoted, _),\n-                                    ty,\n-                                    def_id: _,\n-                                }),\n-                                projection: box [],\n-                            }\n-                        ) => {\n-                            let param_env = ty::ParamEnv::reveal_all();\n-                            let cid = mir::interpret::GlobalId {\n-                                instance: self.instance,\n-                                promoted: Some(promoted),\n-                            };\n-                            let c = bx.tcx().const_eval(param_env.and(cid));\n-                            let (llval, ty) = self.simd_shuffle_indices(\n-                                &bx,\n-                                terminator.source_info.span,\n-                                ty,\n-                                c,\n-                            );\n-                            return OperandRef {\n-                                val: Immediate(llval),\n-                                layout: bx.layout_of(ty),\n-                            };\n-\n-                        }\n-                        mir::Operand::Copy(_) |\n-                        mir::Operand::Move(_) => {\n-                            span_bug!(span, \"shuffle indices must be constant\");\n                         }\n-                        mir::Operand::Constant(ref constant) => {\n+\n+                        mir::Operand::Constant(constant) => {\n                             let c = self.eval_mir_constant(constant);\n                             let (llval, ty) = self.simd_shuffle_indices(\n                                 &bx,\n@@ -1117,10 +1107,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n-        let dest = if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *dest {\n+        let dest = if let Some(index) = dest.as_local() {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n                 LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n@@ -1178,10 +1165,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         src: &mir::Operand<'tcx>,\n         dst: &mir::Place<'tcx>\n     ) {\n-        if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *dst {\n+        if let Some(index) = dst.as_local() {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),"}, {"sha": "1608f222bc614f6de0606052719af0bc00427c05", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -530,10 +530,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Bx::Value {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n-        if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *place {\n+        if let Some(index) = place.as_local() {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.kind {\n                     let n = n.eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());"}, {"sha": "43d5c2570b705e4f66cd4a68deec17679bd90c84", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -17,11 +17,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.set_debug_loc(&mut bx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(box(ref place, ref rvalue)) => {\n-                if let mir::Place {\n-                    base: mir::PlaceBase::Local(index),\n-                    projection: box [],\n-                } = place {\n-                    match self.locals[*index] {\n+                if let Some(index) = place.as_local() {\n+                    match self.locals[index] {\n                         LocalRef::Place(cg_dest) => {\n                             self.codegen_rvalue(bx, cg_dest, rvalue)\n                         }\n@@ -30,7 +27,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                         LocalRef::Operand(None) => {\n                             let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n-                            if let Some(name) = self.mir.local_decls[*index].name {\n+                            if let Some(name) = self.mir.local_decls[index].name {\n                                 match operand.val {\n                                     OperandValue::Ref(x, ..) |\n                                     OperandValue::Immediate(x) => {\n@@ -44,7 +41,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     }\n                                 }\n                             }\n-                            self.locals[*index] = LocalRef::Operand(Some(operand));\n+                            self.locals[index] = LocalRef::Operand(Some(operand));\n                             bx\n                         }\n                         LocalRef::Operand(Some(op)) => {"}, {"sha": "09ff7891a9debce40b602f16bf7db5a0bbdcf4e9", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1319,6 +1319,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                       mut lines,\n                                       mut multibyte_chars,\n                                       mut non_narrow_chars,\n+                                      mut normalized_pos,\n                                       name_hash,\n                                       .. } = source_file_to_import;\n \n@@ -1338,6 +1339,9 @@ impl<'a, 'tcx> CrateMetadata {\n             for swc in &mut non_narrow_chars {\n                 *swc = *swc - start_pos;\n             }\n+            for np in &mut normalized_pos {\n+                np.pos = np.pos - start_pos;\n+            }\n \n             let local_version = local_source_map.new_imported_source_file(name,\n                                                                    name_was_remapped,\n@@ -1347,7 +1351,8 @@ impl<'a, 'tcx> CrateMetadata {\n                                                                    source_length,\n                                                                    lines,\n                                                                    multibyte_chars,\n-                                                                   non_narrow_chars);\n+                                                                   non_narrow_chars,\n+                                                                   normalized_pos);\n             debug!(\"CrateMetaData::imported_source_files alloc \\\n                     source_file {:?} original (start_pos {:?} end_pos {:?}) \\\n                     translated (start_pos {:?} end_pos {:?})\","}, {"sha": "98641031c1787514ca2e461d5bf8b36f3cf5e588", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -315,10 +315,7 @@ impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n         //    TEMP = &foo\n         //\n         // so extract `temp`.\n-        let temp = if let &mir::Place {\n-            base: mir::PlaceBase::Local(temp),\n-            projection: box [],\n-        } = assigned_place {\n+        let temp = if let Some(temp) = assigned_place.as_local() {\n             temp\n         } else {\n             span_bug!("}, {"sha": "36db68a3372eb9ef9a4afdfcb5498c3432637a32", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 151, "deletions": 168, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -239,11 +239,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         );\n                     }\n                 }\n-                let span = if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = place {\n-                    let decl = &self.body.local_decls[*local];\n+                let span = if let Some(local) = place.as_local() {\n+                    let decl = &self.body.local_decls[local];\n                     Some(decl.source_info.span)\n                 } else {\n                     None\n@@ -611,7 +608,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = first_borrowed_place;\n \n-                let mut cursor = &**projection;\n+                let mut cursor = projection.as_ref();\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n@@ -635,7 +632,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = second_borrowed_place;\n \n-                let mut cursor = &**projection;\n+                let mut cursor = projection.as_ref();\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n@@ -710,10 +707,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             _ => drop_span,\n         };\n \n+        let root_place_projection = self.infcx.tcx.intern_place_elems(root_place.projection);\n+\n         if self.access_place_error_reported\n             .contains(&(Place {\n                 base: root_place.base.clone(),\n-                projection: root_place.projection.to_vec().into_boxed_slice(),\n+                projection: root_place_projection,\n             }, borrow_span))\n         {\n             debug!(\n@@ -726,7 +725,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.access_place_error_reported\n             .insert((Place {\n                 base: root_place.base.clone(),\n-                projection: root_place.projection.to_vec().into_boxed_slice(),\n+                projection: root_place_projection,\n             }, borrow_span));\n \n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n@@ -1124,26 +1123,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n-            let local_kind = match borrow.borrowed_place {\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } => {\n-                    match self.body.local_kind(local) {\n-                        LocalKind::ReturnPointer\n-                        | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n-                        LocalKind::Var => \"local variable \",\n-                        LocalKind::Arg\n-                        if !self.upvars.is_empty()\n-                            && local == Local::new(1) => {\n-                            \"variable captured by `move` \"\n-                        }\n-                        LocalKind::Arg => {\n-                            \"function parameter \"\n-                        }\n+            let local_kind = if let Some(local) = borrow.borrowed_place.as_local() {\n+                match self.body.local_kind(local) {\n+                    LocalKind::ReturnPointer\n+                    | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n+                    LocalKind::Var => \"local variable \",\n+                    LocalKind::Arg\n+                    if !self.upvars.is_empty()\n+                        && local == Local::new(1) => {\n+                        \"variable captured by `move` \"\n+                    }\n+                    LocalKind::Arg => {\n+                        \"function parameter \"\n                     }\n                 }\n-                _ => \"local data \",\n+            } else {\n+                \"local data \"\n             };\n             (\n                 format!(\"{}`{}`\", local_kind, place_desc),\n@@ -1480,10 +1475,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         assigned_span: Span,\n         err_place: &Place<'tcx>,\n     ) {\n-        let (from_arg, local_decl) = if let Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        } = *err_place {\n+        let (from_arg, local_decl) = if let Some(local) = err_place.as_local() {\n             if let LocalKind::Arg = self.body.local_kind(local) {\n                 (true, Some(&self.body.local_decls[local]))\n             } else {\n@@ -1643,11 +1635,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 reservation\n             );\n             // Check that the initial assignment of the reserve location is into a temporary.\n-            let mut target = *match reservation {\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } if self.body.local_kind(*local) == LocalKind::Temp => local,\n+            let mut target = match reservation.as_local() {\n+                Some(local) if self.body.local_kind(local) == LocalKind::Temp => local,\n                 _ => return None,\n             };\n \n@@ -1659,127 +1648,122 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n                     target, stmt\n                 );\n-                if let StatementKind::Assign(\n-                    box(\n-                        Place {\n-                            base: PlaceBase::Local(assigned_to),\n-                            projection: box [],\n-                        },\n-                        rvalue\n-                    )\n-                ) = &stmt.kind {\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n-                         rvalue={:?}\",\n-                        assigned_to, rvalue\n-                    );\n-                    // Check if our `target` was captured by a closure.\n-                    if let Rvalue::Aggregate(\n-                        box AggregateKind::Closure(def_id, substs),\n-                        operands,\n-                    ) = rvalue\n-                    {\n-                        for operand in operands {\n-                            let assigned_from = match operand {\n-                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                if let StatementKind::Assign(box(place, rvalue)) = &stmt.kind {\n+                    if let Some(assigned_to) = place.as_local() {\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n+                             rvalue={:?}\",\n+                            assigned_to, rvalue\n+                        );\n+                        // Check if our `target` was captured by a closure.\n+                        if let Rvalue::Aggregate(\n+                            box AggregateKind::Closure(def_id, substs),\n+                            operands,\n+                        ) = rvalue\n+                        {\n+                            for operand in operands {\n+                                let assigned_from = match operand {\n+                                    Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                        assigned_from\n+                                    }\n+                                    _ => continue,\n+                                };\n+                                debug!(\n+                                    \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n                                     assigned_from\n-                                }\n-                                _ => continue,\n-                            };\n-                            debug!(\n-                                \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n-                                assigned_from\n-                            );\n+                                );\n \n-                            // Find the local from the operand.\n-                            let assigned_from_local = match assigned_from.local_or_deref_local() {\n-                                Some(local) => local,\n-                                None => continue,\n-                            };\n+                                // Find the local from the operand.\n+                                let assigned_from_local = match assigned_from.local_or_deref_local()\n+                                {\n+                                    Some(local) => local,\n+                                    None => continue,\n+                                };\n \n-                            if assigned_from_local != target {\n-                                continue;\n-                            }\n-\n-                            // If a closure captured our `target` and then assigned\n-                            // into a place then we should annotate the closure in\n-                            // case it ends up being assigned into the return place.\n-                            annotated_closure = self.annotate_fn_sig(\n-                                *def_id,\n-                                self.infcx.closure_sig(*def_id, *substs),\n-                            );\n-                            debug!(\n-                                \"annotate_argument_and_return_for_borrow: \\\n-                                 annotated_closure={:?} assigned_from_local={:?} \\\n-                                 assigned_to={:?}\",\n-                                annotated_closure, assigned_from_local, assigned_to\n-                            );\n+                                if assigned_from_local != target {\n+                                    continue;\n+                                }\n \n-                            if *assigned_to == mir::RETURN_PLACE {\n-                                // If it was assigned directly into the return place, then\n-                                // return now.\n-                                return annotated_closure;\n-                            } else {\n-                                // Otherwise, update the target.\n-                                target = *assigned_to;\n+                                // If a closure captured our `target` and then assigned\n+                                // into a place then we should annotate the closure in\n+                                // case it ends up being assigned into the return place.\n+                                annotated_closure = self.annotate_fn_sig(\n+                                    *def_id,\n+                                    self.infcx.closure_sig(*def_id, *substs),\n+                                );\n+                                debug!(\n+                                    \"annotate_argument_and_return_for_borrow: \\\n+                                     annotated_closure={:?} assigned_from_local={:?} \\\n+                                     assigned_to={:?}\",\n+                                    annotated_closure, assigned_from_local, assigned_to\n+                                );\n+\n+                                if assigned_to == mir::RETURN_PLACE {\n+                                    // If it was assigned directly into the return place, then\n+                                    // return now.\n+                                    return annotated_closure;\n+                                } else {\n+                                    // Otherwise, update the target.\n+                                    target = assigned_to;\n+                                }\n                             }\n-                        }\n \n-                        // If none of our closure's operands matched, then skip to the next\n-                        // statement.\n-                        continue;\n-                    }\n+                            // If none of our closure's operands matched, then skip to the next\n+                            // statement.\n+                            continue;\n+                        }\n \n-                    // Otherwise, look at other types of assignment.\n-                    let assigned_from = match rvalue {\n-                        Rvalue::Ref(_, _, assigned_from) => assigned_from,\n-                        Rvalue::Use(operand) => match operand {\n-                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                assigned_from\n-                            }\n+                        // Otherwise, look at other types of assignment.\n+                        let assigned_from = match rvalue {\n+                            Rvalue::Ref(_, _, assigned_from) => assigned_from,\n+                            Rvalue::Use(operand) => match operand {\n+                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                    assigned_from\n+                                }\n+                                _ => continue,\n+                            },\n                             _ => continue,\n-                        },\n-                        _ => continue,\n-                    };\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from={:?}\",\n-                        assigned_from,\n-                    );\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from={:?}\",\n+                            assigned_from,\n+                        );\n \n-                    // Find the local from the rvalue.\n-                    let assigned_from_local = match assigned_from.local_or_deref_local() {\n-                        Some(local) => local,\n-                        None => continue,\n-                    };\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from_local={:?}\",\n-                        assigned_from_local,\n-                    );\n+                        // Find the local from the rvalue.\n+                        let assigned_from_local = match assigned_from.local_or_deref_local() {\n+                            Some(local) => local,\n+                            None => continue,\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from_local={:?}\",\n+                            assigned_from_local,\n+                        );\n \n-                    // Check if our local matches the target - if so, we've assigned our\n-                    // borrow to a new place.\n-                    if assigned_from_local != target {\n-                        continue;\n-                    }\n+                        // Check if our local matches the target - if so, we've assigned our\n+                        // borrow to a new place.\n+                        if assigned_from_local != target {\n+                            continue;\n+                        }\n \n-                    // If we assigned our `target` into a new place, then we should\n-                    // check if it was the return place.\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from_local={:?} assigned_to={:?}\",\n-                        assigned_from_local, assigned_to\n-                    );\n-                    if *assigned_to == mir::RETURN_PLACE {\n-                        // If it was then return the annotated closure if there was one,\n-                        // else, annotate this function.\n-                        return annotated_closure.or_else(fallback);\n-                    }\n+                        // If we assigned our `target` into a new place, then we should\n+                        // check if it was the return place.\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from_local={:?} assigned_to={:?}\",\n+                            assigned_from_local, assigned_to\n+                        );\n+                        if assigned_to == mir::RETURN_PLACE {\n+                            // If it was then return the annotated closure if there was one,\n+                            // else, annotate this function.\n+                            return annotated_closure.or_else(fallback);\n+                        }\n \n-                    // If we didn't assign into the return place, then we just update\n-                    // the target.\n-                    target = *assigned_to;\n+                        // If we didn't assign into the return place, then we just update\n+                        // the target.\n+                        target = assigned_to;\n+                    }\n                 }\n             }\n \n@@ -1790,38 +1774,37 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 target, terminator\n             );\n             if let TerminatorKind::Call {\n-                destination: Some((Place {\n-                    base: PlaceBase::Local(assigned_to),\n-                    projection: box [],\n-                }, _)),\n+                destination: Some((place, _)),\n                 args,\n                 ..\n             } = &terminator.kind\n             {\n-                debug!(\n-                    \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n-                    assigned_to, args\n-                );\n-                for operand in args {\n-                    let assigned_from = match operand {\n-                        Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                            assigned_from\n-                        }\n-                        _ => continue,\n-                    };\n+                if let Some(assigned_to) = place.as_local() {\n                     debug!(\n-                        \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n-                        assigned_from,\n+                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n+                        assigned_to, args\n                     );\n-\n-                    if let Some(assigned_from_local) = assigned_from.local_or_deref_local() {\n+                    for operand in args {\n+                        let assigned_from = match operand {\n+                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                assigned_from\n+                            }\n+                            _ => continue,\n+                        };\n                         debug!(\n-                            \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n-                            assigned_from_local,\n+                            \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                            assigned_from,\n                         );\n \n-                        if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n-                            return annotated_closure.or_else(fallback);\n+                        if let Some(assigned_from_local) = assigned_from.local_or_deref_local() {\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n+                                assigned_from_local,\n+                            );\n+\n+                            if assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n+                                return annotated_closure.or_else(fallback);\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "4036e9db33b34ca7cadad224c5407279b10634d3", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -838,12 +838,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .get(location.statement_index)\n         {\n             Some(&Statement {\n-                kind: StatementKind::Assign(box(Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                }, _)),\n+                kind: StatementKind::Assign(box(ref place, _)),\n                 ..\n-            }) => local,\n+            }) => {\n+                if let Some(local) = place.as_local() {\n+                    local\n+                } else {\n+                    return OtherUse(use_span);\n+                }\n+            }\n             _ => return OtherUse(use_span),\n         };\n "}, {"sha": "c3369e872151a1b7e6d4c524b5dfc43fd5107454", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1133,15 +1133,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Special case: you can assign a immutable local variable\n         // (e.g., `x = ...`) so long as it has never been initialized\n         // before (at this point in the flow).\n-        if let Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        } = place_span.0 {\n-            if let Mutability::Not = self.body.local_decls[*local].mutability {\n+        if let Some(local) = place_span.0.as_local() {\n+            if let Mutability::Not = self.body.local_decls[local].mutability {\n                 // check for reassignments to immutable local variables\n                 self.check_if_reassignment_to_immutable_state(\n                     location,\n-                    *local,\n+                    local,\n                     place_span,\n                     flow_state,\n                 );\n@@ -1288,60 +1285,58 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // captures of a closure are copied/moved directly\n         // when generating MIR.\n         match *operand {\n-            Operand::Move(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) |\n-            Operand::Copy(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) if self.body.local_decls[local].is_user_variable.is_none() => {\n-                if self.body.local_decls[local].ty.is_mutable_ptr() {\n-                    // The variable will be marked as mutable by the borrow.\n-                    return;\n-                }\n-                // This is an edge case where we have a `move` closure\n-                // inside a non-move closure, and the inner closure\n-                // contains a mutation:\n-                //\n-                // let mut i = 0;\n-                // || { move || { i += 1; }; };\n-                //\n-                // In this case our usual strategy of assuming that the\n-                // variable will be captured by mutable reference is\n-                // wrong, since `i` can be copied into the inner\n-                // closure from a shared reference.\n-                //\n-                // As such we have to search for the local that this\n-                // capture comes from and mark it as being used as mut.\n-\n-                let temp_mpi = self.move_data.rev_lookup.find_local(local);\n-                let init = if let [init_index] = *self.move_data.init_path_map[temp_mpi] {\n-                    &self.move_data.inits[init_index]\n-                } else {\n-                    bug!(\"temporary should be initialized exactly once\")\n-                };\n-\n-                let loc = match init.location {\n-                    InitLocation::Statement(stmt) => stmt,\n-                    _ => bug!(\"temporary initialized in arguments\"),\n-                };\n-\n-                let bbd = &self.body[loc.block];\n-                let stmt = &bbd.statements[loc.statement_index];\n-                debug!(\"temporary assigned in: stmt={:?}\", stmt);\n-\n-                if let StatementKind::Assign(box(_, Rvalue::Ref(_, _, ref source))) = stmt.kind {\n-                    propagate_closure_used_mut_place(self, source);\n-                } else {\n-                    bug!(\"closures should only capture user variables \\\n-                        or references to user variables\");\n+            Operand::Move(ref place) | Operand::Copy(ref place) => {\n+                match place.as_local() {\n+                    Some(local) if self.body.local_decls[local].is_user_variable.is_none() => {\n+                        if self.body.local_decls[local].ty.is_mutable_ptr() {\n+                            // The variable will be marked as mutable by the borrow.\n+                            return;\n+                        }\n+                        // This is an edge case where we have a `move` closure\n+                        // inside a non-move closure, and the inner closure\n+                        // contains a mutation:\n+                        //\n+                        // let mut i = 0;\n+                        // || { move || { i += 1; }; };\n+                        //\n+                        // In this case our usual strategy of assuming that the\n+                        // variable will be captured by mutable reference is\n+                        // wrong, since `i` can be copied into the inner\n+                        // closure from a shared reference.\n+                        //\n+                        // As such we have to search for the local that this\n+                        // capture comes from and mark it as being used as mut.\n+\n+                        let temp_mpi = self.move_data.rev_lookup.find_local(local);\n+                        let init = if let [init_index] = *self.move_data.init_path_map[temp_mpi] {\n+                            &self.move_data.inits[init_index]\n+                        } else {\n+                            bug!(\"temporary should be initialized exactly once\")\n+                        };\n+\n+                        let loc = match init.location {\n+                            InitLocation::Statement(stmt) => stmt,\n+                            _ => bug!(\"temporary initialized in arguments\"),\n+                        };\n+\n+                        let bbd = &self.body[loc.block];\n+                        let stmt = &bbd.statements[loc.statement_index];\n+                        debug!(\"temporary assigned in: stmt={:?}\", stmt);\n+\n+                        if let StatementKind::Assign(box (_, Rvalue::Ref(_, _, ref source))) =\n+                            stmt.kind\n+                        {\n+                            propagate_closure_used_mut_place(self, source);\n+                        } else {\n+                            bug!(\n+                                \"closures should only capture user variables \\\n+                                 or references to user variables\"\n+                            );\n+                        }\n+                    }\n+                    _ => propagate_closure_used_mut_place(self, place),\n                 }\n             }\n-            Operand::Move(ref place)\n-            | Operand::Copy(ref place) => {\n-                propagate_closure_used_mut_place(self, place);\n-            }\n             Operand::Constant(..) => {}\n         }\n     }\n@@ -1702,7 +1697,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n \n         // None case => assigning to `x` does not require `x` be initialized.\n-        let mut cursor = &*place.projection;\n+        let mut cursor = &*place.projection.as_ref();\n         while let [proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n "}, {"sha": "d9e958d9450017fec5973fab06b1e5844aea54f8", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -89,45 +89,41 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 // If that ever stops being the case, then the ever initialized\n                 // flow could be used.\n                 if let Some(StatementKind::Assign(\n-                    box(\n-                        Place {\n-                            base: PlaceBase::Local(local),\n-                            projection: box [],\n-                        },\n-                        Rvalue::Use(Operand::Move(move_from))\n-                    )\n+                    box(place, Rvalue::Use(Operand::Move(move_from)))\n                 )) = self.body.basic_blocks()[location.block]\n                     .statements\n                     .get(location.statement_index)\n                     .map(|stmt| &stmt.kind)\n                 {\n-                    let local_decl = &self.body.local_decls[*local];\n-                    // opt_match_place is the\n-                    // match_span is the span of the expression being matched on\n-                    // match *x.y { ... }        match_place is Some(*x.y)\n-                    //       ^^^^                match_span is the span of *x.y\n-                    //\n-                    // opt_match_place is None for let [mut] x = ... statements,\n-                    // whether or not the right-hand side is a place expression\n-                    if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                        opt_match_place: Some((ref opt_match_place, match_span)),\n-                        binding_mode: _,\n-                        opt_ty_info: _,\n-                        pat_span: _,\n-                    }))) = local_decl.is_user_variable\n-                    {\n-                        let stmt_source_info = self.body.source_info(location);\n-                        self.append_binding_error(\n-                            grouped_errors,\n-                            kind,\n-                            original_path,\n-                            move_from,\n-                            *local,\n-                            opt_match_place,\n-                            match_span,\n-                            stmt_source_info.span,\n-                        );\n-                        return;\n+                    if let Some(local) = place.as_local() {\n+                        let local_decl = &self.body.local_decls[local];\n+                        // opt_match_place is the\n+                        // match_span is the span of the expression being matched on\n+                        // match *x.y { ... }        match_place is Some(*x.y)\n+                        //       ^^^^                match_span is the span of *x.y\n+                        //\n+                        // opt_match_place is None for let [mut] x = ... statements,\n+                        // whether or not the right-hand side is a place expression\n+                        if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                            opt_match_place: Some((ref opt_match_place, match_span)),\n+                            binding_mode: _,\n+                            opt_ty_info: _,\n+                            pat_span: _,\n+                        }))) = local_decl.is_user_variable\n+                        {\n+                            let stmt_source_info = self.body.source_info(location);\n+                            self.append_binding_error(\n+                                grouped_errors,\n+                                kind,\n+                                original_path,\n+                                move_from,\n+                                local,\n+                                opt_match_place,\n+                                match_span,\n+                                stmt_source_info.span,\n+                            );\n+                            return;\n+                        }\n                     }\n                 }\n \n@@ -307,11 +303,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let upvar_field = self.prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n-        let deref_base = match &deref_target_place.projection {\n-            box [proj_base @ .., ProjectionElem::Deref] => {\n+        let deref_base = match deref_target_place.projection.as_ref() {\n+            &[ref proj_base @ .., ProjectionElem::Deref] => {\n                 PlaceRef {\n                     base: &deref_target_place.base,\n-                    projection: proj_base,\n+                    projection: &proj_base,\n                 }\n             }\n             _ => bug!(\"deref_target_place is not a deref projection\"),"}, {"sha": "68b33331a1ffbfa64bce4b197ea65338c68c8ba1", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -49,10 +49,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [],\n             } => {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if let Place {\n-                    base: PlaceBase::Local(_),\n-                    projection: box [],\n-                } = access_place {\n+                if access_place.as_local().is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n                     let name = self.body.local_decls[*local]\n@@ -153,10 +150,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }),\n                 projection: [],\n             } => {\n-                if let Place {\n-                    base: PlaceBase::Static(_),\n-                    projection: box [],\n-                } = access_place {\n+                if let PlaceRef {\n+                    base: &PlaceBase::Static(_),\n+                    projection: &[],\n+                } = access_place.as_ref() {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n                 } else {"}, {"sha": "cae303039a19430e5f371da8de73e362d4ced40e", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -8,8 +8,8 @@ use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, ProjectionElem, Rvalue,\n-    SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n+    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, PlaceRef, ProjectionElem,\n+    Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n };\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, RegionVid, Ty};\n@@ -211,14 +211,14 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n             // - if it's a deeper projection, we have to filter which\n             //   of the borrows are killed: the ones whose `borrowed_place`\n             //   conflicts with the `place`.\n-            match place {\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n+            match place.as_ref() {\n+                PlaceRef {\n+                    base: &PlaceBase::Local(local),\n+                    projection: &[],\n                 } |\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [ProjectionElem::Deref],\n+                PlaceRef {\n+                    base: &PlaceBase::Local(local),\n+                    projection: &[ProjectionElem::Deref],\n                 } => {\n                     debug!(\n                         \"Recording `killed` facts for borrows of local={:?} at location={:?}\",\n@@ -229,21 +229,21 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         all_facts,\n                         self.borrow_set,\n                         self.location_table,\n-                        local,\n+                        &local,\n                         location,\n                     );\n                 }\n \n-                Place {\n-                    base: PlaceBase::Static(_),\n+                PlaceRef {\n+                    base: &PlaceBase::Static(_),\n                     ..\n                 } => {\n                     // Ignore kills of static or static mut variables.\n                 }\n \n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [.., _],\n+                PlaceRef {\n+                    base: &PlaceBase::Local(local),\n+                    projection: &[.., _],\n                 } => {\n                     // Kill conflicting borrows of the innermost local.\n                     debug!(\n@@ -252,7 +252,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         local, location\n                     );\n \n-                    if let Some(borrow_indices) = self.borrow_set.local_map.get(local) {\n+                    if let Some(borrow_indices) = self.borrow_set.local_map.get(&local) {\n                         for &borrow_index in borrow_indices {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,"}, {"sha": "26bead3047d5d3ce62bde8df861e120f94256182", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 71, "deletions": 85, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -6,8 +6,8 @@ use crate::borrow_check::nll::region_infer::{Cause, RegionName};\n use crate::borrow_check::nll::ConstraintDescription;\n use crate::borrow_check::{MirBorrowckCtxt, WriteKind};\n use rustc::mir::{\n-    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Body, Operand, Place, PlaceBase,\n-    Rvalue, Statement, StatementKind, TerminatorKind,\n+    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Body, Operand, Place, Rvalue,\n+    Statement, StatementKind, TerminatorKind,\n };\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::adjustment::{PointerCast};\n@@ -273,12 +273,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mut should_note_order = false;\n                 if body.local_decls[local].name.is_some() {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n-                        if let Place {\n-                            base: PlaceBase::Local(borrowed_local),\n-                            projection: box [],\n-                        } = place {\n-                             if body.local_decls[*borrowed_local].name.is_some()\n-                                && local != *borrowed_local\n+                        if let Some(borrowed_local) = place.as_local() {\n+                             if body.local_decls[borrowed_local].name.is_some()\n+                                && local != borrowed_local\n                             {\n                                 should_note_order = true;\n                             }\n@@ -494,22 +491,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Just point to the function, to reduce the chance of overlapping spans.\n                         let function_span = match func {\n                             Operand::Constant(c) => c.span,\n-                            Operand::Copy(Place {\n-                                base: PlaceBase::Local(l),\n-                                projection: box [],\n-                            }) |\n-                            Operand::Move(Place {\n-                                base: PlaceBase::Local(l),\n-                                projection: box [],\n-                            }) => {\n-                                let local_decl = &self.body.local_decls[*l];\n-                                if local_decl.name.is_none() {\n-                                    local_decl.source_info.span\n+                            Operand::Copy(place) |\n+                            Operand::Move(place) => {\n+                                if let Some(l) = place.as_local() {\n+                                    let local_decl = &self.body.local_decls[l];\n+                                    if local_decl.name.is_none() {\n+                                        local_decl.source_info.span\n+                                    } else {\n+                                        span\n+                                    }\n                                 } else {\n                                     span\n                                 }\n                             }\n-                            _ => span,\n                         };\n                         return (LaterUseKind::Call, function_span);\n                     } else {\n@@ -542,14 +536,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // it which simplifies the termination logic.\n         let mut queue = vec![location];\n         let mut target = if let Some(&Statement {\n-            kind: StatementKind::Assign(box(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }, _)),\n+            kind: StatementKind::Assign(box(ref place, _)),\n             ..\n-        }) = stmt\n-        {\n-            local\n+        }) = stmt {\n+            if let Some(local) = place.as_local() {\n+                local\n+            } else {\n+                return false;\n+            }\n         } else {\n             return false;\n         };\n@@ -582,17 +576,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // If we see a use, we should check whether it is our data, and if so\n                         // update the place that we're looking for to that new place.\n                         Rvalue::Use(operand) => match operand {\n-                            Operand::Copy(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                            | Operand::Move(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                                if *from == target =>\n-                            {\n-                                target = into;\n+                            Operand::Copy(place)\n+                            | Operand::Move(place) => {\n+                                if let Some(from) = place.as_local() {\n+                                    if from == target {\n+                                        target = into;\n+                                    }\n+                                }\n                             }\n                             _ => {}\n                         },\n@@ -601,28 +591,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         Rvalue::Cast(\n                             CastKind::Pointer(PointerCast::Unsize), operand, ty\n                         ) => match operand {\n-                            Operand::Copy(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                            | Operand::Move(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                                if *from == target =>\n-                            {\n-                                debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n-                                // Check the type for a trait object.\n-                                return match ty.kind {\n-                                    // `&dyn Trait`\n-                                    ty::Ref(_, ty, _) if ty.is_trait() => true,\n-                                    // `Box<dyn Trait>`\n-                                    _ if ty.is_box() && ty.boxed_ty().is_trait() => true,\n-                                    // `dyn Trait`\n-                                    _ if ty.is_trait() => true,\n-                                    // Anything else.\n-                                    _ => false,\n-                                };\n+                            Operand::Copy(place)\n+                            | Operand::Move(place) => {\n+                                if let Some(from) = place.as_local() {\n+                                    if from == target {\n+                                        debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n+                                        // Check the type for a trait object.\n+                                        return match ty.kind {\n+                                            // `&dyn Trait`\n+                                            ty::Ref(_, ty, _) if ty.is_trait() => true,\n+                                            // `Box<dyn Trait>`\n+                                            _ if ty.is_box() && ty.boxed_ty().is_trait() => true,\n+                                            // `dyn Trait`\n+                                            _ if ty.is_trait() => true,\n+                                            // Anything else.\n+                                            _ => false,\n+                                        };\n+                                    }\n+                                }\n+                                return false;\n                             }\n                             _ => return false,\n                         },\n@@ -638,34 +625,33 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 debug!(\"was_captured_by_trait_object: terminator={:?}\", terminator);\n \n                 if let TerminatorKind::Call {\n-                    destination: Some((Place {\n-                        base: PlaceBase::Local(dest),\n-                        projection: box [],\n-                    }, block)),\n+                    destination: Some((place, block)),\n                     args,\n                     ..\n-                } = &terminator.kind\n-                {\n-                    debug!(\n-                        \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n-                        target, dest, args\n-                    );\n-                    // Check if one of the arguments to this function is the target place.\n-                    let found_target = args.iter().any(|arg| {\n-                        if let Operand::Move(Place {\n-                            base: PlaceBase::Local(potential),\n-                            projection: box [],\n-                        }) = arg {\n-                            *potential == target\n-                        } else {\n-                            false\n-                        }\n-                    });\n+                } = &terminator.kind {\n+                    if let Some(dest) = place.as_local() {\n+                        debug!(\n+                            \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n+                            target, dest, args\n+                        );\n+                        // Check if one of the arguments to this function is the target place.\n+                        let found_target = args.iter().any(|arg| {\n+                            if let Operand::Move(place) = arg {\n+                                if let Some(potential) = place.as_local() {\n+                                    potential == target\n+                                } else {\n+                                    false\n+                                }\n+                            } else {\n+                                false\n+                            }\n+                        });\n \n-                    // If it is, follow this to the next block and update the target.\n-                    if found_target {\n-                        target = *dest;\n-                        queue.push(block.start_location());\n+                        // If it is, follow this to the next block and update the target.\n+                        if found_target {\n+                            target = dest;\n+                            queue.push(block.start_location());\n+                        }\n                     }\n                 }\n             }"}, {"sha": "d949c7e01aab730447d91c3c88b41463fbb92e23", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,5 @@\n use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::mir::{Body, Location, PlaceElem, Promoted};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n@@ -54,6 +54,10 @@ impl<'a, 'tcx> NLLVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n         debug!(\"visit_ty(ty={:?}, ty_context={:?})\", ty, ty_context);\n "}, {"sha": "b5560fe6751bd9be3120baa66a030578f139a2b4", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -480,13 +480,13 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         if place.projection.is_empty() {\n             if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-                let is_promoted = match place {\n-                    Place {\n-                        base: PlaceBase::Static(box Static {\n+                let is_promoted = match place.as_ref() {\n+                    PlaceRef {\n+                        base: &PlaceBase::Static(box Static {\n                             kind: StaticKind::Promoted(..),\n                             ..\n                         }),\n-                        projection: box [],\n+                        projection: &[],\n                     } => true,\n                     _ => false,\n                 };\n@@ -1366,11 +1366,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n-                let category = match *place {\n-                    Place {\n-                        base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: box [],\n-                    } => if let BorrowCheckContext {\n+                let category = match place.as_local() {\n+                    Some(RETURN_PLACE) => if let BorrowCheckContext {\n                         universal_regions:\n                             UniversalRegions {\n                                 defining_ty: DefiningTy::Const(def_id, _),\n@@ -1386,10 +1383,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     } else {\n                         ConstraintCategory::Return\n                     },\n-                    Place {\n-                        base: PlaceBase::Local(l),\n-                        projection: box [],\n-                    } if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -1675,11 +1669,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(body, tcx).ty;\n                 let dest_ty = self.normalize(dest_ty, term_location);\n-                let category = match *dest {\n-                    Place {\n-                        base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: box [],\n-                    } => {\n+                let category = match dest.as_local() {\n+                    Some(RETURN_PLACE) => {\n                         if let BorrowCheckContext {\n                             universal_regions:\n                                 UniversalRegions {\n@@ -1698,10 +1689,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             ConstraintCategory::Return\n                         }\n                     }\n-                    Place {\n-                        base: PlaceBase::Local(l),\n-                        projection: box [],\n-                    } if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -2432,7 +2420,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             location, borrow_region, borrowed_place\n         );\n \n-        let mut cursor = &*borrowed_place.projection;\n+        let mut cursor = borrowed_place.projection.as_ref();\n         while let [proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n "}, {"sha": "264e4807af07e9c9e8056a296035c722ff0ef5fb", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -64,14 +64,8 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n \n     // This Local/Local case is handled by the more general code below, but\n     // it's so common that it's a speed win to check for it first.\n-    if let Place {\n-        base: PlaceBase::Local(l1),\n-        projection: box [],\n-    } = borrow_place {\n-        if let PlaceRef {\n-            base: PlaceBase::Local(l2),\n-            projection: [],\n-        } = access_place {\n+    if let Some(l1) = borrow_place.as_local() {\n+        if let Some(l2) = access_place.as_local() {\n             return l1 == l2;\n         }\n     }"}, {"sha": "95471afb7884f74d06c8cb67450b01b5b22086ba", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,7 +1,5 @@\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{\n-    Local, Location, Place, PlaceBase, Statement, StatementKind, TerminatorKind\n-};\n+use rustc::mir::{Local, Location, Place, PlaceBase, Statement, StatementKind, TerminatorKind};\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -118,10 +116,7 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n                     \"assignment of {:?} to {:?}, adding {:?} to used mutable set\",\n                     path.place, local, path.place\n                 );\n-                if let Place {\n-                    base: PlaceBase::Local(user_local),\n-                    projection: box [],\n-                } = path.place {\n+                if let Some(user_local) = path.place.as_local() {\n                     self.mbcx.used_mut.insert(user_local);\n                 }\n             }"}, {"sha": "8d2bef39bed4269fd65b0c8ed90a625c2bafe674", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -6,7 +6,7 @@ use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n use rustc::mir::interpret::{PanicInfo::BoundsCheck};\n use rustc::mir::*;\n-use rustc::ty::{CanonicalUserTypeAnnotation, Ty, Variance};\n+use rustc::ty::{CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n \n use rustc_index::vec::Idx;\n \n@@ -23,10 +23,10 @@ struct PlaceBuilder<'tcx> {\n }\n \n impl PlaceBuilder<'tcx> {\n-    fn into_place(self) -> Place<'tcx> {\n+    fn into_place(self, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n         Place {\n             base: self.base,\n-            projection: self.projection.into_boxed_slice(),\n+            projection: tcx.intern_place_elems(&self.projection),\n         }\n     }\n \n@@ -73,7 +73,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place())\n+        block.and(place_builder.into_place(self.hir.tcx()))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place())\n+        block.and(place_builder.into_place(self.hir.tcx()))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Mutability::Not,\n                 ));\n \n-                let slice = place_builder.clone().into_place();\n+                let slice = place_builder.clone().into_place(this.hir.tcx());\n                 // bounds check:\n                 let (len, lt) = (\n                     this.temp(usize_ty.clone(), expr_span),\n@@ -225,7 +225,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                     );\n \n-                    let place = place_builder.clone().into_place();\n+                    let place = place_builder.clone().into_place(this.hir.tcx());\n                     this.cfg.push(\n                         block,\n                         Statement {"}, {"sha": "4f1ac8e51dc208e14c8d6c22ebb2f1368b8caccd", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // initialize the box contents:\n                 unpack!(\n                     block = this.into(\n-                        &Place::from(result).deref(),\n+                        &this.hir.tcx().mk_place_deref(Place::from(result)),\n                         block, value\n                     )\n                 );\n@@ -296,8 +296,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         .zip(field_types.into_iter())\n                         .map(|(n, ty)| match fields_map.get(&n) {\n                             Some(v) => v.clone(),\n-                            None => this.consume_by_copy_or_move(base.clone().field(n, ty)),\n-                        }).collect()\n+                            None => this.consume_by_copy_or_move(this.hir.tcx().mk_place_field(\n+                                base.clone(),\n+                                n,\n+                                ty,\n+                            )),\n+                        })\n+                        .collect()\n                 } else {\n                     field_names\n                         .iter()\n@@ -397,8 +402,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let val_fld = Field::new(0);\n             let of_fld = Field::new(1);\n \n-            let val = result_value.clone().field(val_fld, ty);\n-            let of = result_value.field(of_fld, bool_ty);\n+            let tcx = self.hir.tcx();\n+            let val = tcx.mk_place_field(result_value.clone(), val_fld, ty);\n+            let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n \n             let err = PanicInfo::Overflow(op);\n \n@@ -496,28 +502,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let arg_place = unpack!(block = this.as_place(block, arg));\n \n-        let mutability = match arg_place {\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n+        let mutability = match arg_place.as_ref() {\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[],\n             } => this.local_decls[local].mutability,\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [ProjectionElem::Deref],\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[ProjectionElem::Deref],\n             } => {\n                 debug_assert!(\n                     this.local_decls[local].is_ref_for_guard(),\n                     \"Unexpected capture place\",\n                 );\n                 this.local_decls[local].mutability\n             }\n-            Place {\n+            PlaceRef {\n                 ref base,\n-                projection: box [ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n+                projection: &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             }\n-            | Place {\n+            | PlaceRef {\n                 ref base,\n-                projection: box [\n+                projection: &[\n                     ref proj_base @ ..,\n                     ProjectionElem::Field(upvar_index, _),\n                     ProjectionElem::Deref"}, {"sha": "e7388b920548b731bdb603a0f72d782d65efd52d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     });\n                     let ptr_temp = Place::from(ptr_temp);\n                     let block = unpack!(this.into(&ptr_temp, block, ptr));\n-                    this.into(&ptr_temp.deref(), block, val)\n+                    this.into(&this.hir.tcx().mk_place_deref(ptr_temp), block, val)\n                 } else {\n                     let args: Vec<_> = args\n                         .into_iter()"}, {"sha": "667b37bbd80c83bf991f5120017c92f900cf34ba", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -948,7 +948,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     fake_borrows.insert(Place {\n                         base: source.base.clone(),\n-                        projection: proj_base.to_vec().into_boxed_slice(),\n+                        projection: self.hir.tcx().intern_place_elems(proj_base),\n                     });\n                 }\n             }\n@@ -1293,7 +1293,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Insert a Shallow borrow of the prefixes of any fake borrows.\n         for place in fake_borrows\n         {\n-            let mut cursor = &*place.projection;\n+            let mut cursor = place.projection.as_ref();\n             while let [proj_base @ .., elem] = cursor {\n                 cursor = proj_base;\n \n@@ -1488,7 +1488,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     BorrowKind::Shallow,\n                     Place {\n                         base: place.base.clone(),\n-                        projection: place.projection.to_vec().into_boxed_slice(),\n+                        projection: tcx.intern_place_elems(place.projection),\n                     },\n                 );\n                 self.cfg.push_assign("}, {"sha": "9b7bccca2ddf3268aaac4602d48d15dd0e2c557a", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -166,7 +166,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                 });\n                 if irrefutable {\n-                    let place = match_pair.place.downcast(adt_def, variant_index);\n+                    let place = tcx.mk_place_downcast(match_pair.place, adt_def, variant_index);\n                     candidate.match_pairs.extend(self.field_match_pairs(place, subpatterns));\n                     Ok(())\n                 } else {\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatKind::Deref { ref subpattern } => {\n-                let place = match_pair.place.deref();\n+                let place = tcx.mk_place_deref(match_pair.place);\n                 candidate.match_pairs.push(MatchPair::new(place, subpattern));\n                 Ok(())\n             }"}, {"sha": "5c2f72c0a061fec79401d4fde1d5d964b42c025a", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -743,22 +743,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) {\n         let match_pair = candidate.match_pairs.remove(match_pair_index);\n+        let tcx = self.hir.tcx();\n \n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n         let elem = ProjectionElem::Downcast(\n             Some(adt_def.variants[variant_index].ident.name), variant_index);\n-        let downcast_place = match_pair.place.elem(elem); // `(x as Variant)`\n-        let consequent_match_pairs =\n-            subpatterns.iter()\n-                       .map(|subpattern| {\n-                           // e.g., `(x as Variant).0`\n-                           let place = downcast_place.clone().field(subpattern.field,\n-                                                                      subpattern.pattern.ty);\n-                           // e.g., `(x as Variant).0 @ P1`\n-                           MatchPair::new(place, &subpattern.pattern)\n-                       });\n+        let downcast_place = tcx.mk_place_elem(match_pair.place, elem); // `(x as Variant)`\n+        let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n+            // e.g., `(x as Variant).0`\n+            let place =\n+                tcx.mk_place_field(downcast_place.clone(), subpattern.field, subpattern.pattern.ty);\n+            // e.g., `(x as Variant).0 @ P1`\n+            MatchPair::new(place, &subpattern.pattern)\n+        });\n \n         candidate.match_pairs.extend(consequent_match_pairs);\n     }"}, {"sha": "917535f31dc4b06eda62d08dc7361b7f7e8b6fbf", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -6,17 +6,22 @@ use std::u32;\n use std::convert::TryInto;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn field_match_pairs<'pat>(&mut self,\n-                                   place: Place<'tcx>,\n-                                   subpatterns: &'pat [FieldPat<'tcx>])\n-                                   -> Vec<MatchPair<'pat, 'tcx>> {\n-        subpatterns.iter()\n-                   .map(|fieldpat| {\n-                       let place = place.clone().field(fieldpat.field,\n-                                                       fieldpat.pattern.ty);\n-                       MatchPair::new(place, &fieldpat.pattern)\n-                   })\n-                   .collect()\n+    pub fn field_match_pairs<'pat>(\n+        &mut self,\n+        place: Place<'tcx>,\n+        subpatterns: &'pat [FieldPat<'tcx>],\n+    ) -> Vec<MatchPair<'pat, 'tcx>> {\n+        subpatterns\n+            .iter()\n+            .map(|fieldpat| {\n+                let place = self.hir.tcx().mk_place_field(\n+                    place.clone(),\n+                    fieldpat.field,\n+                    fieldpat.pattern.ty,\n+                );\n+                MatchPair::new(place, &fieldpat.pattern)\n+            })\n+            .collect()\n     }\n \n     pub fn prefix_slice_suffix<'pat>(&mut self,\n@@ -27,6 +32,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                      suffix: &'pat [Pat<'tcx>]) {\n         let min_length = prefix.len() + suffix.len();\n         let min_length = min_length.try_into().unwrap();\n+        let tcx = self.hir.tcx();\n \n         match_pairs.extend(\n             prefix.iter()\n@@ -37,13 +43,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                           min_length,\n                           from_end: false,\n                       };\n-                      let place = place.clone().elem(elem);\n+                      let place = tcx.mk_place_elem(place.clone(), elem);\n                       MatchPair::new(place, subpattern)\n                   })\n         );\n \n         if let Some(subslice_pat) = opt_slice {\n-            let subslice = place.clone().elem(ProjectionElem::Subslice {\n+            let subslice = tcx.mk_place_elem(place.clone(),ProjectionElem::Subslice {\n                 from: prefix.len() as u32,\n                 to: suffix.len() as u32\n             });\n@@ -60,7 +66,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                           min_length,\n                           from_end: true,\n                       };\n-                      let place = place.clone().elem(elem);\n+                      let place = tcx.mk_place_elem(place.clone(), elem);\n                       MatchPair::new(place, subpattern)\n                   })\n         );"}, {"sha": "1b3d8641f204e32cb25786f4ba2cd2b5f588ee05", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -926,46 +926,43 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // If constants and statics, we don't generate StorageLive for this\n             // temporary, so don't try to generate StorageDead for it either.\n             _ if self.local_scope().is_none() => (),\n-            Operand::Copy(Place {\n-                base: PlaceBase::Local(cond_temp),\n-                projection: box [],\n-            })\n-            | Operand::Move(Place {\n-                base: PlaceBase::Local(cond_temp),\n-                projection: box [],\n-            }) => {\n-                // Manually drop the condition on both branches.\n-                let top_scope = self.scopes.scopes.last_mut().unwrap();\n-                let top_drop_data = top_scope.drops.pop().unwrap();\n-\n-                match top_drop_data.kind {\n-                    DropKind::Value { .. } => {\n-                        bug!(\"Drop scheduled on top of condition variable\")\n-                    }\n-                    DropKind::Storage => {\n-                        let source_info = top_scope.source_info(top_drop_data.span);\n-                        let local = top_drop_data.local;\n-                        assert_eq!(local, cond_temp, \"Drop scheduled on top of condition\");\n-                        self.cfg.push(\n-                            true_block,\n-                            Statement {\n-                                source_info,\n-                                kind: StatementKind::StorageDead(local)\n-                            },\n-                        );\n-                        self.cfg.push(\n-                            false_block,\n-                            Statement {\n-                                source_info,\n-                                kind: StatementKind::StorageDead(local)\n-                            },\n-                        );\n+            Operand::Copy(place)\n+            | Operand::Move(place) => {\n+                if let Some(cond_temp) = place.as_local() {\n+                    // Manually drop the condition on both branches.\n+                    let top_scope = self.scopes.scopes.last_mut().unwrap();\n+                    let top_drop_data = top_scope.drops.pop().unwrap();\n+\n+                    match top_drop_data.kind {\n+                        DropKind::Value { .. } => {\n+                            bug!(\"Drop scheduled on top of condition variable\")\n+                        }\n+                        DropKind::Storage => {\n+                            let source_info = top_scope.source_info(top_drop_data.span);\n+                            let local = top_drop_data.local;\n+                            assert_eq!(local, cond_temp, \"Drop scheduled on top of condition\");\n+                            self.cfg.push(\n+                                true_block,\n+                                Statement {\n+                                    source_info,\n+                                    kind: StatementKind::StorageDead(local)\n+                                },\n+                            );\n+                            self.cfg.push(\n+                                false_block,\n+                                Statement {\n+                                    source_info,\n+                                    kind: StatementKind::StorageDead(local)\n+                                },\n+                            );\n+                        }\n                     }\n-                }\n \n-                top_scope.invalidate_cache(true, self.is_generator, true);\n+                    top_scope.invalidate_cache(true, self.is_generator, true);\n+                } else {\n+                    bug!(\"Expected as_local_operand to produce a temporary\");\n+                }\n             }\n-            _ => bug!(\"Expected as_local_operand to produce a temporary\"),\n         }\n \n         (true_block, false_block)"}, {"sha": "1b81032bfe62fd62306bf7c4df629013cc1ce09d", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -157,10 +157,12 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         // Since `propagate_call_unwind` doesn't exist, we have to kill the\n         // destination here, and then gen it again in `propagate_call_return`.\n         if let TerminatorKind::Call {\n-            destination: Some((Place { base: PlaceBase::Local(local), projection: box [] }, _)),\n+            destination: Some((ref place, _)),\n             ..\n         } = self.body[loc.block].terminator().kind {\n-            sets.kill(local);\n+            if let Some(local) = place.as_local() {\n+                sets.kill(local);\n+            }\n         }\n         self.check_for_move(sets, loc);\n     }"}, {"sha": "52016d4c9363ab55768b70983359a1391e483975", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -114,7 +114,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                         BorrowedContent {\n                             target_place: Place {\n                                 base: place.base.clone(),\n-                                projection: proj.to_vec().into_boxed_slice(),\n+                                projection: tcx.intern_place_elems(proj),\n                             },\n                         },\n                     ));\n@@ -172,7 +172,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                             Some(base),\n                             Place {\n                                 base: place.base.clone(),\n-                                projection: proj.to_vec().into_boxed_slice(),\n+                                projection: tcx.intern_place_elems(proj),\n                             },\n                         );\n                         ent.insert(path);\n@@ -274,7 +274,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                     // Box starts out uninitialized - need to create a separate\n                     // move-path for the interior so it will be separate from\n                     // the exterior.\n-                    self.create_move_path(&place.clone().deref());\n+                    self.create_move_path(&self.builder.tcx.mk_place_deref(place.clone()));\n                     self.gather_init(place.as_ref(), InitKind::Shallow);\n                 } else {\n                     self.gather_init(place.as_ref(), InitKind::Deep);"}, {"sha": "b599f4799446df4669651f91f306004ac1cac176", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -327,7 +327,7 @@ impl<'tcx> MoveData<'tcx> {\n     pub fn base_local(&self, mut mpi: MovePathIndex) -> Option<Local> {\n         loop {\n             let path = &self.move_paths[mpi];\n-            if let Place { base: PlaceBase::Local(l), projection: box [] } = path.place {\n+            if let Some(l) = path.place.as_local() {\n                 return Some(l);\n             }\n             if let Some(parent) = path.parent {"}, {"sha": "177639956f7175ff8645f5daaf28ee46d905151e", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -117,7 +117,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n \n     run_passes(tcx, &mut result, instance, None, MirPhase::Const, &[\n         &add_moves_for_packed_drops::AddMovesForPackedDrops,\n-        &no_landing_pads::NoLandingPads,\n+        &no_landing_pads::NoLandingPads::new(tcx),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &simplify::SimplifyCfg::new(\"make_shim\"),\n         &add_call_guards::CriticalCallEdges,\n@@ -231,7 +231,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n                 tcx,\n                 param_env\n             };\n-            let dropee = dropee_ptr.deref();\n+            let dropee = tcx.mk_place_deref(dropee_ptr);\n             let resume_block = elaborator.patch.resume_block();\n             elaborate_drops::elaborate_drop(\n                 &mut elaborator,\n@@ -312,7 +312,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n     let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env, builder.span);\n \n     let dest = Place::return_place();\n-    let src = Place::from(Local::new(1+0)).deref();\n+    let src = tcx.mk_place_deref(Place::from(Local::new(1+0)));\n \n     match self_ty.kind {\n         _ if is_copy => builder.copy_shim(),\n@@ -415,7 +415,7 @@ impl CloneShimBuilder<'tcx> {\n     }\n \n     fn copy_shim(&mut self) {\n-        let rcvr = Place::from(Local::new(1+0)).deref();\n+        let rcvr = self.tcx.mk_place_deref(Place::from(Local::new(1+0)));\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n                 box(\n@@ -561,8 +561,8 @@ impl CloneShimBuilder<'tcx> {\n         // BB #2\n         // `dest[i] = Clone::clone(src[beg])`;\n         // Goto #3 if ok, #5 if unwinding happens.\n-        let dest_field = dest.clone().index(beg);\n-        let src_field = src.index(beg);\n+        let dest_field = self.tcx.mk_place_index(dest.clone(), beg);\n+        let src_field = self.tcx.mk_place_index(src, beg);\n         self.make_clone_call(dest_field, src_field, ty, BasicBlock::new(3),\n                              BasicBlock::new(5));\n \n@@ -616,7 +616,7 @@ impl CloneShimBuilder<'tcx> {\n         // BB #7 (cleanup)\n         // `drop(dest[beg])`;\n         self.block(vec![], TerminatorKind::Drop {\n-            location: dest.index(beg),\n+            location: self.tcx.mk_place_index(dest, beg),\n             target: BasicBlock::new(8),\n             unwind: None,\n         }, true);\n@@ -648,9 +648,9 @@ impl CloneShimBuilder<'tcx> {\n         let mut previous_field = None;\n         for (i, ity) in tys.enumerate() {\n             let field = Field::new(i);\n-            let src_field = src.clone().field(field, ity);\n+            let src_field = self.tcx.mk_place_field(src.clone(), field, ity);\n \n-            let dest_field = dest.clone().field(field, ity);\n+            let dest_field = self.tcx.mk_place_field(dest.clone(), field, ity);\n \n             // #(2i + 1) is the cleanup block for the previous clone operation\n             let cleanup_block = self.block_index_offset(1);\n@@ -721,14 +721,14 @@ fn build_call_shim<'tcx>(\n \n     let rcvr = match rcvr_adjustment {\n         Adjustment::Identity => Operand::Move(rcvr_l),\n-        Adjustment::Deref => Operand::Copy(rcvr_l.deref()),\n+        Adjustment::Deref => Operand::Copy(tcx.mk_place_deref(rcvr_l)),\n         Adjustment::DerefMove => {\n             // fn(Self, ...) -> fn(*mut Self, ...)\n             let arg_ty = local_decls[rcvr_arg].ty;\n             debug_assert!(tcx.generics_of(def_id).has_self && arg_ty == tcx.types.self_param);\n             local_decls[rcvr_arg].ty = tcx.mk_mut_ptr(arg_ty);\n \n-            Operand::Move(rcvr_l.deref())\n+            Operand::Move(tcx.mk_place_deref(rcvr_l))\n         }\n         Adjustment::RefMut => {\n             // let rcvr = &mut rcvr;\n@@ -772,7 +772,7 @@ fn build_call_shim<'tcx>(\n     if let Some(untuple_args) = untuple_args {\n         args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n             let arg_place = Place::from(Local::new(1+1));\n-            Operand::Move(arg_place.field(Field::new(i), *ity))\n+            Operand::Move(tcx.mk_place_field(arg_place, Field::new(i), *ity))\n         }));\n     } else {\n         args.extend((1..sig.inputs().len()).map(|i| {\n@@ -901,6 +901,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n             )),\n         AggregateKind::Adt(adt_def, variant_index, substs, None, None),\n         source_info,\n+        tcx,\n     ).collect();\n \n     let start_block = BasicBlockData {"}, {"sha": "c8605e22e1084b2b445c663671177c3f4776ff5c", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -164,8 +164,8 @@ pub trait Qualif {\n \n             Rvalue::Ref(_, _, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n-                if let box [proj_base @ .., elem] = &place.projection {\n-                    if ProjectionElem::Deref == *elem {\n+                if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                    if ProjectionElem::Deref == elem {\n                         let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, per_local, PlaceRef {"}, {"sha": "fc9290d638018372d89578686a83ac0c13493c3a", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -56,16 +56,16 @@ where\n     fn assign_qualif_direct(&mut self, place: &mir::Place<'tcx>, value: bool) {\n         debug_assert!(!place.is_indirect());\n \n-        match (value, place) {\n-            (true, mir::Place { base: mir::PlaceBase::Local(local), .. }) => {\n-                self.qualifs_per_local.insert(*local);\n+        match (value, place.as_ref()) {\n+            (true, mir::PlaceRef { base: &mir::PlaceBase::Local(local), .. }) => {\n+                self.qualifs_per_local.insert(local);\n             }\n \n             // For now, we do not clear the qualif if a local is overwritten in full by\n             // an unqualified rvalue (e.g. `y = 5`). This is to be consistent\n             // with aggregates where we overwrite all fields with assignments, which would not\n             // get this feature.\n-            (false, mir::Place { base: mir::PlaceBase::Local(_local), projection: box [] }) => {\n+            (false, mir::PlaceRef { base: &mir::PlaceBase::Local(_local), projection: &[] }) => {\n                 // self.qualifs_per_local.remove(*local);\n             }\n \n@@ -101,11 +101,10 @@ where\n \n         // If a local with no projections is moved from (e.g. `x` in `y = x`), record that\n         // it no longer needs to be dropped.\n-        if let mir::Operand::Move(mir::Place {\n-            base: mir::PlaceBase::Local(local),\n-            projection: box [],\n-        }) = *operand {\n-            self.qualifs_per_local.remove(local);\n+        if let mir::Operand::Move(place) = operand {\n+            if let Some(local) = place.as_local() {\n+                self.qualifs_per_local.remove(local);\n+            }\n         }\n     }\n "}, {"sha": "76a73adf03836368e96935659505a089016ffe31", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -244,8 +244,8 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n             // Special-case reborrows to be more like a copy of a reference.\n             let mut reborrow_place = None;\n-            if let box [proj_base @ .., elem] = &place.projection {\n-                if *elem == ProjectionElem::Deref {\n+            if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                if elem == ProjectionElem::Deref {\n                     let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         reborrow_place = Some(proj_base);\n@@ -376,12 +376,15 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             );\n \n             if rvalue_has_mut_interior {\n-                let is_derived_from_illegal_borrow = match *borrowed_place {\n+                let is_derived_from_illegal_borrow = match borrowed_place.as_local() {\n                     // If an unprojected local was borrowed and its value was the result of an\n                     // illegal borrow, suppress this error and mark the result of this borrow as\n                     // illegal as well.\n-                    Place { base: PlaceBase::Local(borrowed_local), projection: box [] }\n-                        if self.derived_from_illegal_borrow.contains(borrowed_local) => true,\n+                    Some(borrowed_local)\n+                        if self.derived_from_illegal_borrow.contains(borrowed_local) =>\n+                    {\n+                        true\n+                    }\n \n                     // Otherwise proceed normally: check the legality of a mutable borrow in this\n                     // context.\n@@ -394,7 +397,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 // FIXME: should we also clear `derived_from_illegal_borrow` when a local is\n                 // assigned a new value?\n                 if is_derived_from_illegal_borrow {\n-                    if let Place { base: PlaceBase::Local(dest), projection: box [] } = *dest {\n+                    if let Some(dest) = dest.as_local() {\n                         self.derived_from_illegal_borrow.insert(dest);\n                     }\n                 }\n@@ -571,10 +574,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                     return;\n                 }\n \n-                let needs_drop = if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *dropped_place {\n+                let needs_drop = if let Some(local) = dropped_place.as_local() {\n                     // Use the span where the local was declared as the span of the drop error.\n                     err_span = self.body.local_decls[local].source_info.span;\n                     self.qualifs.needs_drop.contains(local)"}, {"sha": "d9b983ab790c2b5d74f15804a43db6b4ba86af9b", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -406,8 +406,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         place: &Place<'tcx>,\n         is_mut_use: bool,\n     ) {\n-        let mut cursor = &*place.projection;\n-        while let [proj_base @ .., elem] = cursor {\n+        let mut cursor = place.projection.as_ref();\n+        while let &[ref proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n \n             match elem {"}, {"sha": "4fd4fe45cd4f135cb1f1161e34cb9a7c8670538a", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -24,16 +24,22 @@ use crate::transform::{MirPass, MirSource};\n \n pub struct CleanupNonCodegenStatements;\n \n-pub struct DeleteNonCodegenStatements;\n+pub struct DeleteNonCodegenStatements<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n \n impl<'tcx> MirPass<'tcx> for CleanupNonCodegenStatements {\n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let mut delete = DeleteNonCodegenStatements;\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        let mut delete = DeleteNonCodegenStatements { tcx };\n         delete.visit_body(body);\n     }\n }\n \n-impl<'tcx> MutVisitor<'tcx> for DeleteNonCodegenStatements {\n+impl<'tcx> MutVisitor<'tcx> for DeleteNonCodegenStatements<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_statement(&mut self,\n                        statement: &mut Statement<'tcx>,\n                        location: Location) {"}, {"sha": "13097a2156167475e6a95fa8094da1d238631f6a", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -7,10 +7,9 @@ use std::cell::Cell;\n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n-    AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue,\n-    Local, UnOp, StatementKind, Statement, LocalKind,\n-    TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo, BinOp,\n-    SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock,\n+    AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue, Local, UnOp,\n+    StatementKind, Statement, LocalKind, TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo,\n+    BinOp, SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock,\n };\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n@@ -525,18 +524,21 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // (e.g. for CTFE) it can never happen. But here in const_prop\n             // unknown data is uninitialized, so if e.g. a function argument is unsized\n             // and has a reference taken, we get an ICE.\n-            Rvalue::Ref(_, _, Place { base: PlaceBase::Local(local), projection: box [] }) => {\n-                trace!(\"checking Ref({:?})\", place);\n-                let alive =\n-                    if let LocalValue::Live(_) = self.ecx.frame().locals[*local].value {\n-                        true\n-                    } else {\n-                        false\n-                    };\n+            Rvalue::Ref(_, _, place_ref) => {\n+                trace!(\"checking Ref({:?})\", place_ref);\n \n-                if !alive {\n-                    trace!(\"skipping Ref({:?}) to uninitialized local\", place);\n-                    return None;\n+                if let Some(local) = place_ref.as_local() {\n+                    let alive =\n+                        if let LocalValue::Live(_) = self.ecx.frame().locals[local].value {\n+                            true\n+                        } else {\n+                            false\n+                        };\n+\n+                    if !alive {\n+                        trace!(\"skipping Ref({:?}) to uninitialized local\", place);\n+                        return None;\n+                    }\n                 }\n             }\n \n@@ -685,6 +687,10 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n }\n \n impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_constant(\n         &mut self,\n         constant: &mut Constant<'tcx>,\n@@ -706,10 +712,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 .ty(&self.local_decls, self.tcx)\n                 .ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n-                if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *place {\n+                if let Some(local) = place.as_local() {\n                     let source = statement.source_info;\n                     if let Some(()) = self.const_prop(rval, place_layout, source, place) {\n                         if self.can_const_prop[local] {"}, {"sha": "4c26feac4af79f1e5fe432cad92f50cd6fdcd21e", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -19,9 +19,7 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use rustc::mir::{\n-    Constant, Local, LocalKind, Location, Place, PlaceBase, Body, Operand, Rvalue, StatementKind\n-};\n+use rustc::mir::{Constant, Local, LocalKind, Location, Place, Body, Operand, Rvalue, StatementKind};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use crate::transform::{MirPass, MirSource};\n@@ -92,28 +90,32 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     };\n \n                     // That use of the source must be an assignment.\n-                    match statement.kind {\n-                        StatementKind::Assign(\n-                            box(\n-                                Place {\n-                                    base: PlaceBase::Local(local),\n-                                    projection: box [],\n-                                },\n-                                Rvalue::Use(ref operand)\n-                            )\n-                        ) if local == dest_local => {\n-                            let maybe_action = match *operand {\n-                                Operand::Copy(ref src_place) |\n-                                Operand::Move(ref src_place) => {\n-                                    Action::local_copy(&body, &def_use_analysis, src_place)\n-                                }\n-                                Operand::Constant(ref src_constant) => {\n-                                    Action::constant(src_constant)\n+                    match &statement.kind {\n+                        StatementKind::Assign(box(place, Rvalue::Use(operand))) => {\n+                            if let Some(local) = place.as_local() {\n+                                if local == dest_local {\n+                                    let maybe_action = match operand {\n+                                        Operand::Copy(ref src_place) |\n+                                        Operand::Move(ref src_place) => {\n+                                            Action::local_copy(&body, &def_use_analysis, src_place)\n+                                        }\n+                                        Operand::Constant(ref src_constant) => {\n+                                            Action::constant(src_constant)\n+                                        }\n+                                    };\n+                                    match maybe_action {\n+                                        Some(this_action) => action = this_action,\n+                                        None => continue,\n+                                    }\n+                                } else {\n+                                    debug!(\"  Can't copy-propagate local: source use is not an \\\n+                                    assignment\");\n+                                    continue\n                                 }\n-                            };\n-                            match maybe_action {\n-                                Some(this_action) => action = this_action,\n-                                None => continue,\n+                            } else {\n+                                debug!(\"  Can't copy-propagate local: source use is not an \\\n+                                    assignment\");\n+                                continue\n                             }\n                         }\n                         _ => {\n@@ -124,7 +126,8 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     }\n                 }\n \n-                changed = action.perform(body, &def_use_analysis, dest_local, location) || changed;\n+                changed =\n+                    action.perform(body, &def_use_analysis, dest_local, location, tcx) || changed;\n                 // FIXME(pcwalton): Update the use-def chains to delete the instructions instead of\n                 // regenerating the chains.\n                 break\n@@ -148,31 +151,20 @@ fn eliminate_self_assignments(\n         for def in dest_use_info.defs_not_including_drop() {\n             let location = def.location;\n             if let Some(stmt) = body[location.block].statements.get(location.statement_index) {\n-                match stmt.kind {\n-                    StatementKind::Assign(\n-                        box(\n-                            Place {\n-                                base: PlaceBase::Local(local),\n-                                projection: box [],\n-                            },\n-                            Rvalue::Use(Operand::Copy(Place {\n-                                base: PlaceBase::Local(src_local),\n-                                projection: box [],\n-                            })),\n-                        )\n-                    ) |\n-                    StatementKind::Assign(\n-                        box(\n-                            Place {\n-                                base: PlaceBase::Local(local),\n-                                projection: box [],\n-                            },\n-                            Rvalue::Use(Operand::Move(Place {\n-                                base: PlaceBase::Local(src_local),\n-                                projection: box [],\n-                            })),\n-                        )\n-                    ) if local == dest_local && dest_local == src_local => {}\n+                match &stmt.kind {\n+                    StatementKind::Assign(box (place, Rvalue::Use(Operand::Copy(src_place))))\n+                    | StatementKind::Assign(box (place, Rvalue::Use(Operand::Move(src_place)))) => {\n+                        if let (Some(local), Some(src_local)) =\n+                            (place.as_local(), src_place.as_local())\n+                        {\n+                            if local == dest_local && dest_local == src_local {\n+                            } else {\n+                                continue;\n+                            }\n+                        } else {\n+                            continue;\n+                        }\n+                    }\n                     _ => {\n                         continue;\n                     }\n@@ -198,10 +190,7 @@ impl<'tcx> Action<'tcx> {\n     fn local_copy(body: &Body<'tcx>, def_use_analysis: &DefUseAnalysis, src_place: &Place<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n-        let src_local = if let Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        } = *src_place {\n+        let src_local = if let Some(local) = src_place.as_local() {\n             local\n         } else {\n             debug!(\"  Can't copy-propagate local: source is not a local\");\n@@ -256,7 +245,8 @@ impl<'tcx> Action<'tcx> {\n                body: &mut Body<'tcx>,\n                def_use_analysis: &DefUseAnalysis,\n                dest_local: Local,\n-               location: Location)\n+               location: Location,\n+               tcx: TyCtxt<'tcx>)\n                -> bool {\n         match self {\n             Action::PropagateLocalCopy(src_local) => {\n@@ -280,7 +270,7 @@ impl<'tcx> Action<'tcx> {\n                 }\n \n                 // Replace all uses of the destination local with the source local.\n-                def_use_analysis.replace_all_defs_and_uses_with(dest_local, body, src_local);\n+                def_use_analysis.replace_all_defs_and_uses_with(dest_local, body, src_local, tcx);\n \n                 // Finally, zap the now-useless assignment instruction.\n                 debug!(\"  Deleting assignment\");\n@@ -304,7 +294,8 @@ impl<'tcx> Action<'tcx> {\n \n                 // Replace all uses of the destination local with the constant.\n                 let mut visitor = ConstantPropagationVisitor::new(dest_local,\n-                                                                  src_constant);\n+                                                                  src_constant,\n+                                                                  tcx);\n                 for dest_place_use in &dest_local_info.defs_and_uses {\n                     visitor.visit_location(body, dest_place_use.location)\n                 }\n@@ -336,33 +327,42 @@ impl<'tcx> Action<'tcx> {\n struct ConstantPropagationVisitor<'tcx> {\n     dest_local: Local,\n     constant: Constant<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     uses_replaced: usize,\n }\n \n impl<'tcx> ConstantPropagationVisitor<'tcx> {\n-    fn new(dest_local: Local, constant: Constant<'tcx>)\n+    fn new(dest_local: Local, constant: Constant<'tcx>, tcx: TyCtxt<'tcx>)\n            -> ConstantPropagationVisitor<'tcx> {\n         ConstantPropagationVisitor {\n             dest_local,\n             constant,\n+            tcx,\n             uses_replaced: 0,\n         }\n     }\n }\n \n impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_operand(&mut self, operand: &mut Operand<'tcx>, location: Location) {\n         self.super_operand(operand, location);\n \n-        match *operand {\n-            Operand::Copy(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) |\n-            Operand::Move(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) if local == self.dest_local => {}\n+        match operand {\n+            Operand::Copy(place) |\n+            Operand::Move(place) => {\n+                if let Some(local) = place.as_local() {\n+                    if local == self.dest_local {\n+                    } else {\n+                        return;\n+                    }\n+                } else {\n+                    return;\n+                }\n+            }\n             _ => return,\n         }\n "}, {"sha": "cdde9e12edcbb37097aec269ba46714bd46c0714", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -45,6 +45,7 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n                     }),\n                     *kind,\n                     source_info,\n+                    tcx,\n                 ))\n             });\n         }"}, {"sha": "b30e2de4ca0bcaa525084ae96edfca706e8dbfaa", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -23,6 +23,10 @@ impl EraseRegionsVisitor<'tcx> {\n }\n \n impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n         *ty = self.tcx.erase_regions(ty);\n     }"}, {"sha": "911901be36b242f4562d600ce18da3b72c92b41b", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 63, "deletions": 30, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -74,12 +74,17 @@ use crate::util::liveness;\n \n pub struct StateTransform;\n \n-struct RenameLocalVisitor {\n+struct RenameLocalVisitor<'tcx> {\n     from: Local,\n     to: Local,\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n+impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n@@ -102,9 +107,15 @@ impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n     }\n }\n \n-struct DerefArgVisitor;\n+struct DerefArgVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n \n-impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n@@ -119,8 +130,8 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n         if place.base == PlaceBase::Local(self_arg()) {\n             replace_base(place, Place {\n                 base: PlaceBase::Local(self_arg()),\n-                projection: Box::new([ProjectionElem::Deref]),\n-            });\n+                projection: self.tcx().intern_place_elems(&vec![ProjectionElem::Deref]),\n+            }, self.tcx);\n         } else {\n             self.visit_place_base(&mut place.base, context, location);\n \n@@ -135,25 +146,34 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n \n struct PinArgVisitor<'tcx> {\n     ref_gen_ty: Ty<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n                    _: Location) {\n         assert_ne!(*local, self_arg());\n     }\n \n-    fn visit_place(&mut self,\n-                    place: &mut Place<'tcx>,\n-                    context: PlaceContext,\n-                    location: Location) {\n+    fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n         if place.base == PlaceBase::Local(self_arg()) {\n-            replace_base(place, Place {\n-                base: PlaceBase::Local(self_arg()),\n-                projection: Box::new([ProjectionElem::Field(Field::new(0), self.ref_gen_ty)]),\n-            });\n+            replace_base(\n+                place,\n+                Place {\n+                    base: PlaceBase::Local(self_arg()),\n+                    projection: self.tcx().intern_place_elems(&vec![ProjectionElem::Field(\n+                            Field::new(0),\n+                            self.ref_gen_ty,\n+                    )]),\n+                },\n+                self.tcx,\n+            );\n         } else {\n             self.visit_place_base(&mut place.base, context, location);\n \n@@ -166,13 +186,13 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n     }\n }\n \n-fn replace_base(place: &mut Place<'tcx>, new_base: Place<'tcx>) {\n+fn replace_base<'tcx>(place: &mut Place<'tcx>, new_base: Place<'tcx>, tcx: TyCtxt<'tcx>) {\n     place.base = new_base.base;\n \n     let mut new_projection = new_base.projection.to_vec();\n     new_projection.append(&mut place.projection.to_vec());\n \n-    place.projection = new_projection.into_boxed_slice();\n+    place.projection = tcx.intern_place_elems(&new_projection);\n }\n \n fn self_arg() -> Local {\n@@ -226,13 +246,13 @@ impl TransformVisitor<'tcx> {\n     // Create a Place referencing a generator struct field\n     fn make_field(&self, variant_index: VariantIdx, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n         let self_place = Place::from(self_arg());\n-        let base = self_place.downcast_unnamed(variant_index);\n+        let base = self.tcx.mk_place_downcast_unnamed(self_place, variant_index);\n         let mut projection = base.projection.to_vec();\n         projection.push(ProjectionElem::Field(Field::new(idx), ty));\n \n         Place {\n             base: base.base,\n-            projection: projection.into_boxed_slice(),\n+            projection: self.tcx.intern_place_elems(&projection),\n         }\n     }\n \n@@ -264,6 +284,10 @@ impl TransformVisitor<'tcx> {\n }\n \n impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n@@ -280,7 +304,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n         if let PlaceBase::Local(l) = place.base {\n             // Replace an Local in the remap with a generator struct access\n             if let Some(&(ty, variant_index, idx)) = self.remap.get(&l) {\n-                replace_base(place, self.make_field(variant_index, idx, ty));\n+                replace_base(place, self.make_field(variant_index, idx, ty), self.tcx);\n             }\n         } else {\n             self.visit_place_base(&mut place.base, context, location);\n@@ -375,7 +399,7 @@ fn make_generator_state_argument_indirect<'tcx>(\n     body.local_decls.raw[1].ty = ref_gen_ty;\n \n     // Add a deref to accesses of the generator state\n-    DerefArgVisitor.visit_body(body);\n+    DerefArgVisitor { tcx }.visit_body(body);\n }\n \n fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n@@ -390,12 +414,13 @@ fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body\n     body.local_decls.raw[1].ty = pin_ref_gen_ty;\n \n     // Add the Pin field access to accesses of the generator state\n-    PinArgVisitor { ref_gen_ty }.visit_body(body);\n+    PinArgVisitor { ref_gen_ty, tcx }.visit_body(body);\n }\n \n fn replace_result_variable<'tcx>(\n     ret_ty: Ty<'tcx>,\n     body: &mut Body<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n ) -> Local {\n     let source_info = source_info(body);\n     let new_ret = LocalDecl {\n@@ -416,6 +441,7 @@ fn replace_result_variable<'tcx>(\n     RenameLocalVisitor {\n         from: RETURN_PLACE,\n         to: new_ret_local,\n+        tcx,\n     }.visit_body(body);\n \n     new_ret_local\n@@ -864,17 +890,24 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n \n     for (block, block_data) in body.basic_blocks().iter_enumerated() {\n         let (target, unwind, source_info) = match block_data.terminator() {\n-            &Terminator {\n+            Terminator {\n                 source_info,\n                 kind: TerminatorKind::Drop {\n-                    location: Place {\n-                        base: PlaceBase::Local(local),\n-                        projection: box [],\n-                    },\n+                    location,\n                     target,\n                     unwind\n                 }\n-            } if local == gen => (target, unwind, source_info),\n+            } => {\n+                if let Some(local) = location.as_local() {\n+                    if local == gen {\n+                        (target, unwind, source_info)\n+                    } else {\n+                        continue;\n+                    }\n+                } else {\n+                    continue;\n+                }\n+            }\n             _ => continue,\n         };\n         let unwind = if block_data.is_cleanup {\n@@ -884,10 +917,10 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n         };\n         elaborate_drop(\n             &mut elaborator,\n-            source_info,\n+            *source_info,\n             &Place::from(gen),\n             (),\n-            target,\n+            *target,\n             unwind,\n             block,\n         );\n@@ -1175,7 +1208,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local\n         // RETURN_PLACE then is a fresh unused local with type ret_ty.\n-        let new_ret_local = replace_result_variable(ret_ty, body);\n+        let new_ret_local = replace_result_variable(ret_ty, body, tcx);\n \n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices"}, {"sha": "5a34e3f471f666dc426f653029901cc7deb82d99", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -461,7 +461,7 @@ impl Inliner<'tcx> {\n                     };\n                     caller_body[callsite.bb]\n                         .statements.push(stmt);\n-                    tmp.deref()\n+                    self.tcx.mk_place_deref(tmp)\n                 } else {\n                     destination.0\n                 };\n@@ -481,6 +481,7 @@ impl Inliner<'tcx> {\n                     return_block,\n                     cleanup_block: cleanup,\n                     in_cleanup_block: false,\n+                    tcx: self.tcx,\n                 };\n \n \n@@ -559,7 +560,8 @@ impl Inliner<'tcx> {\n             let tuple_tmp_args =\n                 tuple_tys.iter().enumerate().map(|(i, ty)| {\n                     // This is e.g., `tuple_tmp.0` in our example above.\n-                    let tuple_field = Operand::Move(tuple.clone().field(\n+                    let tuple_field = Operand::Move(tcx.mk_place_field(\n+                        tuple.clone(),\n                         Field::new(i),\n                         ty.expect_ty(),\n                     ));\n@@ -587,13 +589,12 @@ impl Inliner<'tcx> {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n \n-        if let Operand::Move(Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        }) = arg {\n-            if caller_body.local_kind(local) == LocalKind::Temp {\n-                // Reuse the operand if it's a temporary already\n-                return local;\n+        if let Operand::Move(place) = &arg {\n+            if let Some(local) = place.as_local() {\n+                if caller_body.local_kind(local) == LocalKind::Temp {\n+                    // Reuse the operand if it's a temporary already\n+                    return local;\n+                }\n             }\n         }\n \n@@ -639,6 +640,7 @@ struct Integrator<'a, 'tcx> {\n     return_block: BasicBlock,\n     cleanup_block: Option<BasicBlock>,\n     in_cleanup_block: bool,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> Integrator<'a, 'tcx> {\n@@ -650,14 +652,9 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n \n     fn make_integrate_local(&self, local: &Local) -> Local {\n         if *local == RETURN_PLACE {\n-            match self.destination {\n-                Place {\n-                    base: PlaceBase::Local(l),\n-                    projection: box [],\n-                } => {\n-                    return l;\n-                },\n-                ref place => bug!(\"Return place is {:?}, not local\", place)\n+            match self.destination.as_local() {\n+                Some(l) => return l,\n+                ref place => bug!(\"Return place is {:?}, not local\", place),\n             }\n         }\n \n@@ -671,6 +668,10 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(\n         &mut self,\n         local: &mut Local,\n@@ -686,17 +687,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         context: PlaceContext,\n         location: Location,\n     ) {\n-        match place {\n-            Place {\n-                base: PlaceBase::Local(RETURN_PLACE),\n-                projection: box [],\n-            } => {\n-                // Return pointer; update the place itself\n-                *place = self.destination.clone();\n-            },\n-            _ => {\n-                self.super_place(place, context, location);\n-            }\n+        if let Some(RETURN_PLACE) = place.as_local() {\n+            // Return pointer; update the place itself\n+            *place = self.destination.clone();\n+        } else {\n+            self.super_place(place, context, location);\n         }\n     }\n "}, {"sha": "a567ed668bfa584058c0472aa612ae980d745c3f", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,7 +1,8 @@\n //! Performs various peephole optimizations.\n \n-use rustc::mir::{Constant, Location, Place, PlaceBase, Body, Operand, ProjectionElem, Rvalue,\n-    Local};\n+use rustc::mir::{\n+    Constant, Location, Place, PlaceBase, PlaceRef, Body, Operand, ProjectionElem, Rvalue, Local\n+};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -28,32 +29,33 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n         };\n \n         // Then carry out those optimizations.\n-        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations }, body);\n+        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations, tcx }, body);\n     }\n }\n \n pub struct InstCombineVisitor<'tcx> {\n     optimizations: OptimizationList<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         if self.optimizations.and_stars.remove(&location) {\n             debug!(\"replacing `&*`: {:?}\", rvalue);\n-            let new_place = match *rvalue {\n-                Rvalue::Ref(_, _, Place {\n-                    ref mut base,\n-                    projection: ref mut projection @ box [.., _],\n-                }) => {\n-                    if let box [proj_l @ .., proj_r] = projection {\n-                        let place = Place {\n-                            // Replace with dummy\n-                            base: mem::replace(base, PlaceBase::Local(Local::new(0))),\n-                            projection: proj_l.to_vec().into_boxed_slice(),\n-                        };\n-                        *projection = vec![proj_r.clone()].into_boxed_slice();\n+            let new_place = match rvalue {\n+                Rvalue::Ref(_, _, place) => {\n+                    if let &[ref proj_l @ .., proj_r] = place.projection.as_ref() {\n+                        place.projection = self.tcx().intern_place_elems(&vec![proj_r.clone()]);\n \n-                        place\n+                        Place {\n+                            // Replace with dummy\n+                            base: mem::replace(&mut place.base, PlaceBase::Local(Local::new(0))),\n+                            projection: self.tcx().intern_place_elems(proj_l),\n+                        }\n                     } else {\n                         unreachable!();\n                     }\n@@ -91,12 +93,14 @@ impl OptimizationFinder<'b, 'tcx> {\n \n impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        if let Rvalue::Ref(_, _, Place {\n-            base,\n-            projection: box [proj_base @ .., ProjectionElem::Deref],\n-        }) = rvalue {\n-            if Place::ty_from(base, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n-                self.optimizations.and_stars.insert(location);\n+        if let Rvalue::Ref(_, _, place) = rvalue {\n+            if let PlaceRef {\n+                base,\n+                projection: &[ref proj_base @ .., ProjectionElem::Deref],\n+            } = place.as_ref() {\n+                if Place::ty_from(base, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n+                    self.optimizations.and_stars.insert(location);\n+                }\n             }\n         }\n "}, {"sha": "dbe6c7845926dcbe39097d3f5458be25b1ae3fa4", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -228,7 +228,7 @@ fn run_optimization_passes<'tcx>(\n ) {\n     run_passes(tcx, body, InstanceDef::Item(def_id), promoted, MirPhase::Optimized, &[\n         // Remove all things only needed by analysis\n-        &no_landing_pads::NoLandingPads,\n+        &no_landing_pads::NoLandingPads::new(tcx),\n         &simplify_branches::SimplifyBranches::new(\"initial\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &cleanup_post_borrowck::CleanupNonCodegenStatements,\n@@ -238,7 +238,7 @@ fn run_optimization_passes<'tcx>(\n         // These next passes must be executed together\n         &add_call_guards::CriticalCallEdges,\n         &elaborate_drops::ElaborateDrops,\n-        &no_landing_pads::NoLandingPads,\n+        &no_landing_pads::NoLandingPads::new(tcx),\n         // AddMovesForPackedDrops needs to run after drop\n         // elaboration.\n         &add_moves_for_packed_drops::AddMovesForPackedDrops,\n@@ -257,7 +257,7 @@ fn run_optimization_passes<'tcx>(\n \n \n         // Optimizations begin.\n-        &uniform_array_move_out::RestoreSubsliceArrayMoveOut,\n+        &uniform_array_move_out::RestoreSubsliceArrayMoveOut::new(tcx),\n         &inline::Inline,\n \n         // Lowering generator control-flow and variables"}, {"sha": "fbd14d9ef61704006fe9c3f6258992c0e086c4d0", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -6,21 +6,33 @@ use rustc::mir::*;\n use rustc::mir::visit::MutVisitor;\n use crate::transform::{MirPass, MirSource};\n \n-pub struct NoLandingPads;\n+pub struct NoLandingPads<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> NoLandingPads<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        NoLandingPads { tcx }\n+    }\n+}\n \n-impl<'tcx> MirPass<'tcx> for NoLandingPads {\n+impl<'tcx> MirPass<'tcx> for NoLandingPads<'tcx> {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         no_landing_pads(tcx, body)\n     }\n }\n \n pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n-        NoLandingPads.visit_body(body);\n+        NoLandingPads::new(tcx).visit_body(body);\n     }\n }\n \n-impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n+impl<'tcx> MutVisitor<'tcx> for NoLandingPads<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_terminator_kind(&mut self,\n                         kind: &mut TerminatorKind<'tcx>,\n                         location: Location) {"}, {"sha": "7a9c489fa791e3faf1606ded4e5163e68a3ff3eb", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, MutatingUseContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n use rustc::ty::subst::InternalSubsts;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{List, TyCtxt};\n use syntax_pos::Span;\n \n use rustc_index::vec::{IndexVec, Idx};\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         ty,\n                         def_id,\n                     }),\n-                    projection: box [],\n+                    projection: List::empty(),\n                 }\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n@@ -339,7 +339,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                                     &mut place.base,\n                                     promoted_place(ty, span).base,\n                                 ),\n-                                projection: box [],\n+                                projection: List::empty(),\n                             })\n                         }\n                         _ => bug!()\n@@ -396,6 +396,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n /// Replaces all temporaries with their promoted counterparts.\n impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n@@ -434,14 +438,13 @@ pub fn promote_candidates<'tcx>(\n         match candidate {\n             Candidate::Repeat(Location { block, statement_index }) |\n             Candidate::Ref(Location { block, statement_index }) => {\n-                match body[block].statements[statement_index].kind {\n-                    StatementKind::Assign(box(Place {\n-                        base: PlaceBase::Local(local),\n-                        projection: box [],\n-                    }, _)) => {\n-                        if temps[local] == TempState::PromotedOut {\n-                            // Already promoted.\n-                            continue;\n+                match &body[block].statements[statement_index].kind {\n+                    StatementKind::Assign(box(place, _)) => {\n+                        if let Some(local) = place.as_local() {\n+                            if temps[local] == TempState::PromotedOut {\n+                                // Already promoted.\n+                                continue;\n+                            }\n                         }\n                     }\n                     _ => {}\n@@ -487,28 +490,30 @@ pub fn promote_candidates<'tcx>(\n     let promoted = |index: Local| temps[index] == TempState::PromotedOut;\n     for block in body.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n-            match statement.kind {\n-                StatementKind::Assign(box(Place {\n-                    base: PlaceBase::Local(index),\n-                    projection: box [],\n-                }, _)) |\n+            match &statement.kind {\n+                StatementKind::Assign(box(place, _)) => {\n+                    if let Some(index) = place.as_local() {\n+                        !promoted(index)\n+                    } else {\n+                        true\n+                    }\n+                }\n                 StatementKind::StorageLive(index) |\n                 StatementKind::StorageDead(index) => {\n-                    !promoted(index)\n+                    !promoted(*index)\n                 }\n                 _ => true\n             }\n         });\n         let terminator = block.terminator_mut();\n-        match terminator.kind {\n-            TerminatorKind::Drop { location: Place {\n-                base: PlaceBase::Local(index),\n-                projection: box [],\n-            }, target, .. } => {\n-                if promoted(index) {\n-                    terminator.kind = TerminatorKind::Goto {\n-                        target,\n-                    };\n+        match &terminator.kind {\n+            TerminatorKind::Drop { location: place, target, .. } => {\n+                if let Some(index) = place.as_local() {\n+                    if promoted(index) {\n+                        terminator.kind = TerminatorKind::Goto {\n+                            target: *target,\n+                        };\n+                    }\n                 }\n             }\n             _ => {}"}, {"sha": "6aba91f416299ebc3743592b1838b511f8b34d95", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -292,8 +292,8 @@ trait Qualif {\n \n             Rvalue::Ref(_, _, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n-                if let box [proj_base @ .., elem] = &place.projection {\n-                    if ProjectionElem::Deref == *elem {\n+                if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                    if ProjectionElem::Deref == elem {\n                         let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, PlaceRef {\n@@ -1041,26 +1041,24 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             match *candidate {\n                 Candidate::Repeat(Location { block: bb, statement_index: stmt_idx }) => {\n                     if let StatementKind::Assign(box(_, Rvalue::Repeat(\n-                        Operand::Move(Place {\n-                            base: PlaceBase::Local(index),\n-                            projection: box [],\n-                        }),\n+                        Operand::Move(place),\n                         _\n-                    ))) = self.body[bb].statements[stmt_idx].kind {\n-                        promoted_temps.insert(index);\n+                    ))) = &self.body[bb].statements[stmt_idx].kind {\n+                        if let Some(index) = place.as_local() {\n+                            promoted_temps.insert(index);\n+                        }\n                     }\n                 }\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n                     if let StatementKind::Assign(\n                         box(\n                             _,\n-                            Rvalue::Ref(_, _, Place {\n-                                base: PlaceBase::Local(index),\n-                                projection: box [],\n-                            })\n+                            Rvalue::Ref(_, _, place)\n                         )\n-                    ) = self.body[bb].statements[stmt_idx].kind {\n-                        promoted_temps.insert(index);\n+                    ) = &self.body[bb].statements[stmt_idx].kind {\n+                        if let Some(index) = place.as_local() {\n+                            promoted_temps.insert(index);\n+                        }\n                     }\n                 }\n                 Candidate::Argument { .. } => {}\n@@ -1237,10 +1235,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         match *operand {\n             Operand::Move(ref place) => {\n                 // Mark the consumed locals to indicate later drops are noops.\n-                if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *place {\n+                if let Some(local) = place.as_local() {\n                     self.cx.per_local[NeedsDrop].remove(local);\n                 }\n             }\n@@ -1256,8 +1251,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n             // Special-case reborrows.\n             let mut reborrow_place = None;\n-            if let box [proj_base @ .., elem] = &place.projection {\n-                if *elem == ProjectionElem::Deref {\n+            if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                if elem == ProjectionElem::Deref {\n                     let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         reborrow_place = Some(proj_base);\n@@ -1568,10 +1563,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 unleash_miri!(self);\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n-                let needs_drop = if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *place {\n+                let needs_drop = if let Some(local) = place.as_local() {\n                     if NeedsDrop::in_local(self, local) {\n                         Some(self.body.local_decls[local].source_info.span)\n                     } else {\n@@ -1817,16 +1809,17 @@ fn remove_drop_and_storage_dead_on_promoted_locals(\n             }\n         });\n         let terminator = block.terminator_mut();\n-        match terminator.kind {\n+        match &terminator.kind {\n             TerminatorKind::Drop {\n-                location: Place {\n-                    base: PlaceBase::Local(index),\n-                    projection: box [],\n-                },\n+                location,\n                 target,\n                 ..\n-            } if promoted_temps.contains(index) => {\n-                terminator.kind = TerminatorKind::Goto { target };\n+            } => {\n+                if let Some(index) = location.as_local() {\n+                    if promoted_temps.contains(index) {\n+                        terminator.kind = TerminatorKind::Goto { target: *target };\n+                    }\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "c4e44091bc90d8f0049e3911ac751616768c4b03", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -259,8 +259,8 @@ fn check_place(\n     def_id: DefId,\n     body: &Body<'tcx>\n ) -> McfResult {\n-    let mut cursor = &*place.projection;\n-    while let [proj_base @ .., elem] = cursor {\n+    let mut cursor = place.projection.as_ref();\n+    while let &[ref proj_base @ .., elem] = cursor {\n         cursor = proj_base;\n         match elem {\n             ProjectionElem::Downcast(..) => {"}, {"sha": "130393e2c4c865f359586ca96cf75f88374ce139", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -32,7 +32,7 @@ impl RemoveNoopLandingPads {\n         nop_landing_pads: &BitSet<BasicBlock>,\n     ) -> bool {\n         for stmt in &body[bb].statements {\n-            match stmt.kind {\n+            match &stmt.kind {\n                 StatementKind::FakeRead(..) |\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) |\n@@ -41,12 +41,13 @@ impl RemoveNoopLandingPads {\n                     // These are all nops in a landing pad\n                 }\n \n-                StatementKind::Assign(box(Place {\n-                    base: PlaceBase::Local(_),\n-                    projection: box [],\n-                }, Rvalue::Use(_))) => {\n-                    // Writing to a local (e.g., a drop flag) does not\n-                    // turn a landing pad to a non-nop\n+                StatementKind::Assign(box(place, Rvalue::Use(_))) => {\n+                    if place.as_local().is_some() {\n+                        // Writing to a local (e.g., a drop flag) does not\n+                        // turn a landing pad to a non-nop\n+                    } else {\n+                        return false;\n+                    }\n                 }\n \n                 StatementKind::Assign { .. } |"}, {"sha": "aada7641df67ac616b712585a8fb489e4a41e7f5", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -155,8 +155,8 @@ fn value_assigned_to_local<'a, 'tcx>(\n     local: Local,\n ) -> Option<&'a mir::Rvalue<'tcx>> {\n     if let mir::StatementKind::Assign(box (place, rvalue)) = &stmt.kind {\n-        if let mir::Place { base: mir::PlaceBase::Local(l), projection: box [] } = place {\n-            if local == *l {\n+        if let Some(l) = place.as_local() {\n+            if local == l {\n                 return Some(&*rvalue);\n             }\n         }\n@@ -192,7 +192,7 @@ impl PeekCall {\n         tcx: TyCtxt<'tcx>,\n         terminator: &mir::Terminator<'tcx>,\n     ) -> Option<Self> {\n-        use mir::{Operand, Place, PlaceBase};\n+        use mir::Operand;\n \n         let span = terminator.source_info.span;\n         if let mir::TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n@@ -207,14 +207,23 @@ impl PeekCall {\n \n                 assert_eq!(args.len(), 1);\n                 let kind = PeekCallKind::from_arg_ty(substs.type_at(0));\n-                let arg = match args[0] {\n-                    | Operand::Copy(Place { base: PlaceBase::Local(local), projection: box [] })\n-                    | Operand::Move(Place { base: PlaceBase::Local(local), projection: box [] })\n-                    => local,\n-\n+                let arg = match &args[0] {\n+                    Operand::Copy(place) | Operand::Move(place) => {\n+                        if let Some(local) = place.as_local() {\n+                            local\n+                        } else {\n+                            tcx.sess.diagnostic().span_err(\n+                                span,\n+                                \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\",\n+                            );\n+                            return None;\n+                        }\n+                    }\n                     _ => {\n                         tcx.sess.diagnostic().span_err(\n-                            span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n+                            span,\n+                            \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\",\n+                        );\n                         return None;\n                     }\n                 };\n@@ -277,12 +286,11 @@ impl<'tcx> RustcPeekAt<'tcx> for IndirectlyMutableLocals<'_, 'tcx> {\n         call: PeekCall,\n     ) {\n         warn!(\"peek_at: place={:?}\", place);\n-        let local = match place {\n-            mir::Place { base: mir::PlaceBase::Local(l), projection: box [] } => *l,\n-            _ => {\n-                tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n-                return;\n-            }\n+        let local = if let Some(l) = place.as_local() {\n+            l\n+        } else {\n+            tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n+            return;\n         };\n \n         if !flow_state.contains(local) {"}, {"sha": "1b90ea78c6450c353c996f01b2e11579a8417bc6", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -319,7 +319,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n \n         let map = make_local_map(&mut body.local_decls, locals);\n         // Update references to all vars and tmps now\n-        LocalUpdater { map }.visit_body(body);\n+        LocalUpdater { map, tcx }.visit_body(body);\n         body.local_decls.shrink_to_fit();\n     }\n }\n@@ -374,11 +374,16 @@ impl<'a, 'tcx> Visitor<'tcx> for DeclMarker<'a, 'tcx> {\n     }\n }\n \n-struct LocalUpdater {\n+struct LocalUpdater<'tcx> {\n     map: IndexVec<Local, Option<Local>>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n+impl<'tcx> MutVisitor<'tcx> for LocalUpdater<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n         // Remove unnecessary StorageLive and StorageDead annotations.\n         data.statements.retain(|stmt| {"}, {"sha": "e4c2f7d389b502d1a5f7f61cbcff7271ea47e634", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 66, "deletions": 70, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n         if let Rvalue::Use(Operand::Move(ref src_place)) = rvalue {\n-            if let box [proj_base @ .., elem] = &src_place.projection {\n+            if let &[ref proj_base @ .., elem] = src_place.projection.as_ref() {\n                 if let ProjectionElem::ConstantIndex{offset: _,\n                                                      min_length: _,\n                                                      from_end: false} = elem {\n@@ -116,16 +116,13 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                             min_length: size,\n                             from_end: false,\n                         });\n-                        self.patch.add_assign(location,\n-                                              Place::from(temp),\n-                                              Rvalue::Use(\n-                                                  Operand::Move(\n-                                                      Place {\n-                                                          base: base.clone(),\n-                                                          projection: projection.into_boxed_slice(),\n-                                                      }\n-                                                  )\n-                                              )\n+                        self.patch.add_assign(\n+                            location,\n+                            Place::from(temp),\n+                            Rvalue::Use(Operand::Move(Place {\n+                                base: base.clone(),\n+                                projection: self.tcx.intern_place_elems(&projection),\n+                            })),\n                         );\n                         temp\n                     }).collect();\n@@ -153,16 +150,13 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                         min_length: size,\n                         from_end: false,\n                     });\n-                    self.patch.add_assign(location,\n-                                          dst_place.clone(),\n-                                          Rvalue::Use(\n-                                              Operand::Move(\n-                                                  Place {\n-                                                      base: base.clone(),\n-                                                      projection: projection.into_boxed_slice(),\n-                                                  }\n-                                              )\n-                                          )\n+                    self.patch.add_assign(\n+                        location,\n+                        dst_place.clone(),\n+                        Rvalue::Use(Operand::Move(Place {\n+                            base: base.clone(),\n+                            projection: self.tcx.intern_place_elems(&projection),\n+                        })),\n                     );\n                 }\n                 _ => {}\n@@ -185,9 +179,11 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n //\n // replaced by _10 = move _2[:-1];\n \n-pub struct RestoreSubsliceArrayMoveOut;\n+pub struct RestoreSubsliceArrayMoveOut<'tcx> {\n+    tcx: TyCtxt<'tcx>\n+}\n \n-impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n+impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);\n         let param_env = tcx.param_env(src.def_id());\n@@ -203,18 +199,17 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n                 if let StatementKind::Assign(box(ref dst_place, ref rval)) = statement.kind {\n                     if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = *rval {\n                         let items : Vec<_> = items.iter().map(|item| {\n-                            if let Operand::Move(Place {\n-                                base: PlaceBase::Local(local),\n-                                projection: box [],\n-                            }) = item {\n-                                let local_use = &visitor.locals_use[*local];\n-                                let opt_index_and_place =\n-                                    Self::try_get_item_source(local_use, body);\n-                                // each local should be used twice:\n-                                //  in assign and in aggregate statements\n-                                if local_use.use_count == 2 && opt_index_and_place.is_some() {\n-                                    let (index, src_place) = opt_index_and_place.unwrap();\n-                                    return Some((local_use, index, src_place));\n+                            if let Operand::Move(place) = item {\n+                                if let Some(local) = place.as_local() {\n+                                    let local_use = &visitor.locals_use[local];\n+                                    let opt_index_and_place =\n+                                        Self::try_get_item_source(local_use, body);\n+                                    // each local should be used twice:\n+                                    //  in assign and in aggregate statements\n+                                    if local_use.use_count == 2 && opt_index_and_place.is_some() {\n+                                        let (index, src_place) = opt_index_and_place.unwrap();\n+                                        return Some((local_use, index, src_place));\n+                                    }\n                                 }\n                             }\n                             None\n@@ -230,7 +225,9 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n                                 None\n                             }\n                         });\n-                        Self::check_and_patch(*candidate, &items, opt_size, &mut patch, dst_place);\n+                        let restore_subslice = RestoreSubsliceArrayMoveOut { tcx };\n+                        restore_subslice\n+                            .check_and_patch(*candidate, &items, opt_size, &mut patch, dst_place);\n                     }\n                 }\n             }\n@@ -239,15 +236,20 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n     }\n }\n \n-impl RestoreSubsliceArrayMoveOut {\n+impl RestoreSubsliceArrayMoveOut<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        RestoreSubsliceArrayMoveOut { tcx }\n+    }\n+\n     // Checks that source has size, all locals are inited from same source place and\n     // indices is an integer interval. If all checks pass do the replacent.\n     // items are Vec<Option<LocalUse, index in source array, source place for init local>>\n-    fn check_and_patch<'tcx>(candidate: Location,\n-                             items: &[Option<(&LocalUse, u32, PlaceRef<'_, 'tcx>)>],\n-                             opt_size: Option<u64>,\n-                             patch: &mut MirPatch<'tcx>,\n-                             dst_place: &Place<'tcx>) {\n+    fn check_and_patch(&self,\n+                       candidate: Location,\n+                       items: &[Option<(&LocalUse, u32, PlaceRef<'_, 'tcx>)>],\n+                       opt_size: Option<u64>,\n+                       patch: &mut MirPatch<'tcx>,\n+                       dst_place: &Place<'tcx>) {\n         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n \n         if opt_size.is_some() && items.iter().all(\n@@ -280,46 +282,40 @@ impl RestoreSubsliceArrayMoveOut {\n                 dst_place.clone(),\n                 Rvalue::Use(Operand::Move(Place {\n                     base: src_place.base.clone(),\n-                    projection: projection.into_boxed_slice(),\n+                    projection: self.tcx.intern_place_elems(&projection),\n                 })),\n             );\n         }\n     }\n \n-    fn try_get_item_source<'a, 'tcx>(local_use: &LocalUse,\n-                                     body: &'a Body<'tcx>) -> Option<(u32, PlaceRef<'a, 'tcx>)> {\n+    fn try_get_item_source<'a>(local_use: &LocalUse,\n+                               body: &'a Body<'tcx>) -> Option<(u32, PlaceRef<'a, 'tcx>)> {\n         if let Some(location) = local_use.first_use {\n             let block = &body[location.block];\n             if block.statements.len() > location.statement_index {\n                 let statement = &block.statements[location.statement_index];\n                 if let StatementKind::Assign(\n-                    box(\n-                        Place {\n-                            base: PlaceBase::Local(_),\n-                            projection: box [],\n-                        },\n-                        Rvalue::Use(Operand::Move(Place {\n-                            base: _,\n-                            projection: box [.., ProjectionElem::ConstantIndex {\n-                                offset, min_length: _, from_end: false\n-                            }],\n-                        })),\n-                    )\n+                    box(place, Rvalue::Use(Operand::Move(src_place)))\n                 ) = &statement.kind {\n-                    // FIXME remove once we can use slices patterns\n-                    if let StatementKind::Assign(\n-                        box(\n-                            _,\n-                            Rvalue::Use(Operand::Move(Place {\n+                    if let (Some(_), PlaceRef {\n+                        base: _,\n+                        projection: &[.., ProjectionElem::ConstantIndex {\n+                            offset, min_length: _, from_end: false\n+                        }],\n+                    }) = (place.as_local(), src_place.as_ref()) {\n+                        if let StatementKind::Assign(\n+                            box(_, Rvalue::Use(Operand::Move(place)))\n+                        ) = &statement.kind {\n+                            if let PlaceRef {\n                                 base,\n-                                projection: box [proj_base @ .., _],\n-                            })),\n-                        )\n-                    ) = &statement.kind {\n-                        return Some((*offset, PlaceRef {\n-                            base,\n-                            projection: proj_base,\n-                        }))\n+                                projection: &[ref proj_base @ .., _],\n+                            } = place.as_ref() {\n+                                return Some((offset, PlaceRef {\n+                                    base,\n+                                    projection: proj_base,\n+                                }))\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "e6c3e4384d7aeb189fc5583dbf366d40b02d95d9", "filename": "src/librustc_mir/util/aggregate.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Faggregate.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir::*;\n-use rustc::ty::Ty;\n+use rustc::ty::{Ty, TyCtxt};\n use rustc::ty::layout::VariantIdx;\n use rustc_index::vec::Idx;\n \n@@ -17,6 +17,7 @@ pub fn expand_aggregate<'tcx>(\n     operands: impl Iterator<Item=(Operand<'tcx>, Ty<'tcx>)> + TrustedLen,\n     kind: AggregateKind<'tcx>,\n     source_info: SourceInfo,\n+    tcx: TyCtxt<'tcx>,\n ) -> impl Iterator<Item=Statement<'tcx>> + TrustedLen {\n     let mut set_discriminant = None;\n     let active_field_index = match kind {\n@@ -29,7 +30,7 @@ pub fn expand_aggregate<'tcx>(\n                     },\n                     source_info,\n                 });\n-                lhs = lhs.downcast(adt_def, variant_index);\n+                lhs = tcx.mk_place_downcast(lhs, adt_def, variant_index);\n             }\n             active_field_index\n         }\n@@ -58,15 +59,15 @@ pub fn expand_aggregate<'tcx>(\n             // FIXME(eddyb) `offset` should be u64.\n             let offset = i as u32;\n             assert_eq!(offset as usize, i);\n-            lhs.clone().elem(ProjectionElem::ConstantIndex {\n+            tcx.mk_place_elem(lhs.clone(), ProjectionElem::ConstantIndex {\n                 offset,\n                 // FIXME(eddyb) `min_length` doesn't appear to be used.\n                 min_length: offset + 1,\n                 from_end: false\n             })\n         } else {\n             let field = Field::new(active_field_index.unwrap_or(i));\n-            lhs.clone().field(field, ty)\n+            tcx.mk_place_field(lhs.clone(), field, ty)\n         };\n         Statement {\n             source_info,"}, {"sha": "f949fcf0745f01cf95cb07dd3ec9ffb6268f8481", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -38,8 +38,8 @@ fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: &Place<'\n where\n     L: HasLocalDecls<'tcx>,\n {\n-    let mut cursor = &*place.projection;\n-    while let [proj_base @ .., elem] = cursor {\n+    let mut cursor = place.projection.as_ref();\n+    while let &[ref proj_base @ .., elem] = cursor {\n         cursor = proj_base;\n \n         match elem {"}, {"sha": "725ec84ca62370682bac1276583acf0c7ce11bb6", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -2,6 +2,7 @@\n \n use rustc::mir::{Body, Local, Location, PlaceElem};\n use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n+use rustc::ty::TyCtxt;\n use rustc_index::vec::IndexVec;\n use std::mem;\n \n@@ -47,20 +48,26 @@ impl DefUseAnalysis {\n         &self.info[local]\n     }\n \n-    fn mutate_defs_and_uses(&self, local: Local, body: &mut Body<'_>, new_local: Local) {\n+    fn mutate_defs_and_uses(\n+        &self,\n+        local: Local,\n+        body: &mut Body<'tcx>,\n+        new_local: Local,\n+        tcx: TyCtxt<'tcx>,\n+    ) {\n         for place_use in &self.info[local].defs_and_uses {\n-            MutateUseVisitor::new(local,\n-                                  new_local,\n-                                  body).visit_location(body, place_use.location)\n+            MutateUseVisitor::new(local, new_local, body, tcx)\n+                .visit_location(body, place_use.location)\n         }\n     }\n \n     // FIXME(pcwalton): this should update the def-use chains.\n     pub fn replace_all_defs_and_uses_with(&self,\n                                           local: Local,\n-                                          body: &mut Body<'_>,\n-                                          new_local: Local) {\n-        self.mutate_defs_and_uses(local, body, new_local)\n+                                          body: &mut Body<'tcx>,\n+                                          new_local: Local,\n+                                          tcx: TyCtxt<'tcx>) {\n+        self.mutate_defs_and_uses(local, body, new_local, tcx)\n     }\n }\n \n@@ -114,21 +121,28 @@ impl Info {\n     }\n }\n \n-struct MutateUseVisitor {\n+struct MutateUseVisitor<'tcx> {\n     query: Local,\n     new_local: Local,\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl MutateUseVisitor {\n-    fn new(query: Local, new_local: Local, _: &Body<'_>) -> MutateUseVisitor {\n-        MutateUseVisitor {\n-            query,\n-            new_local,\n-        }\n+impl MutateUseVisitor<'tcx> {\n+    fn new(\n+        query: Local,\n+        new_local: Local,\n+        _: &Body<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> MutateUseVisitor<'tcx> {\n+        MutateUseVisitor { query, new_local, tcx }\n     }\n }\n \n-impl MutVisitor<'_> for MutateUseVisitor {\n+impl MutVisitor<'tcx> for MutateUseVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(&mut self,\n                     local: &mut Local,\n                     _context: PlaceContext,"}, {"sha": "a1846a1fb5eaf594f5ff4e5b8e2a357128cde8a8", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -200,13 +200,14 @@ where\n         variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);\n             let subpath = self.elaborator.field_subpath(variant_path, field);\n+            let tcx = self.tcx();\n \n             assert_eq!(self.elaborator.param_env().reveal, Reveal::All);\n-            let field_ty = self.tcx().normalize_erasing_regions(\n+            let field_ty = tcx.normalize_erasing_regions(\n                 self.elaborator.param_env(),\n-                f.ty(self.tcx(), substs),\n+                f.ty(tcx, substs),\n             );\n-            (base_place.clone().field(field, field_ty), subpath)\n+            (tcx.mk_place_field(base_place.clone(), field, field_ty), subpath)\n         }).collect()\n     }\n \n@@ -323,7 +324,7 @@ where\n         debug!(\"open_drop_for_tuple({:?}, {:?})\", self, tys);\n \n         let fields = tys.iter().enumerate().map(|(i, &ty)| {\n-            (self.place.clone().field(Field::new(i), ty),\n+            (self.tcx().mk_place_field(self.place.clone(), Field::new(i), ty),\n              self.elaborator.field_subpath(self.path, Field::new(i)))\n         }).collect();\n \n@@ -334,7 +335,7 @@ where\n     fn open_drop_for_box(&mut self, adt: &'tcx ty::AdtDef, substs: SubstsRef<'tcx>) -> BasicBlock {\n         debug!(\"open_drop_for_box({:?}, {:?}, {:?})\", self, adt, substs);\n \n-        let interior = self.place.clone().deref();\n+        let interior = self.tcx().mk_place_deref(self.place.clone());\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n         let succ = self.succ; // FIXME(#43234)\n@@ -406,14 +407,19 @@ where\n         };\n \n         let mut have_otherwise = false;\n+        let tcx = self.tcx();\n \n-        for (variant_index, discr) in adt.discriminants(self.tcx()) {\n+        for (variant_index, discr) in adt.discriminants(tcx) {\n             let subpath = self.elaborator.downcast_subpath(\n                 self.path, variant_index);\n             if let Some(variant_path) = subpath {\n-                let base_place = self.place.clone().elem(\n-                    ProjectionElem::Downcast(Some(adt.variants[variant_index].ident.name),\n-                                             variant_index));\n+                let base_place = tcx.mk_place_elem(\n+                    self.place.clone(),\n+                    ProjectionElem::Downcast(\n+                        Some(adt.variants[variant_index].ident.name),\n+                        variant_index,\n+                    ),\n+                );\n                 let fields = self.move_paths_for_fields(\n                     &base_place,\n                     variant_path,\n@@ -586,15 +592,15 @@ where\n                 BorrowKind::Mut { allow_two_phase_borrow: false },\n                 Place {\n                     base: PlaceBase::Local(cur),\n-                    projection: Box::new([ProjectionElem::Deref]),\n+                    projection: tcx.intern_place_elems(&vec![ProjectionElem::Deref]),\n                 }\n              ),\n              Rvalue::BinaryOp(BinOp::Offset, move_(&Place::from(cur)), one))\n         } else {\n             (Rvalue::Ref(\n                  tcx.lifetimes.re_erased,\n                  BorrowKind::Mut { allow_two_phase_borrow: false },\n-                 self.place.clone().index(cur)),\n+                 tcx.mk_place_index(self.place.clone(), cur)),\n              Rvalue::BinaryOp(BinOp::Add, move_(&Place::from(cur)), one))\n         };\n \n@@ -627,7 +633,7 @@ where\n         let loop_block = self.elaborator.patch().new_block(loop_block);\n \n         self.elaborator.patch().patch_terminator(drop_block, TerminatorKind::Drop {\n-            location: ptr.clone().deref(),\n+            location: tcx.mk_place_deref(ptr.clone()),\n             target: loop_block,\n             unwind: unwind.into_option()\n         });\n@@ -644,18 +650,27 @@ where\n         //     ptr_based_loop\n         // }\n \n+        let tcx = self.tcx();\n+\n         if let Some(size) = opt_size {\n             let size: u32 = size.try_into().unwrap_or_else(|_| {\n                 bug!(\"move out check isn't implemented for array sizes bigger than u32::MAX\");\n             });\n-            let fields: Vec<(Place<'tcx>, Option<D::Path>)> = (0..size).map(|i| {\n-                (self.place.clone().elem(ProjectionElem::ConstantIndex{\n-                    offset: i,\n-                    min_length: size,\n-                    from_end: false\n-                }),\n-                 self.elaborator.array_subpath(self.path, i, size))\n-            }).collect();\n+            let fields: Vec<(Place<'tcx>, Option<D::Path>)> = (0..size)\n+                .map(|i| {\n+                    (\n+                        tcx.mk_place_elem(\n+                            self.place.clone(),\n+                            ProjectionElem::ConstantIndex {\n+                                offset: i,\n+                                min_length: size,\n+                                from_end: false,\n+                            },\n+                        ),\n+                        self.elaborator.array_subpath(self.path, i, size),\n+                    )\n+                })\n+                .collect();\n \n             if fields.iter().any(|(_,path)| path.is_some()) {\n                 let (succ, unwind) = self.drop_ladder_bottom();\n@@ -664,7 +679,6 @@ where\n         }\n \n         let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n-        let tcx = self.tcx();\n         let elem_size = &Place::from(self.new_temp(tcx.types.usize));\n         let len = &Place::from(self.new_temp(tcx.types.usize));\n \n@@ -900,8 +914,8 @@ where\n         );\n         let args = adt.variants[VariantIdx::new(0)].fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);\n-            let field_ty = f.ty(self.tcx(), substs);\n-            Operand::Move(self.place.clone().field(field, field_ty))\n+            let field_ty = f.ty(tcx, substs);\n+            Operand::Move(tcx.mk_place_field(self.place.clone(), field, field_ty))\n         }).collect();\n \n         let call = TerminatorKind::Call {"}, {"sha": "a642491b28181145e59f4b4f01b68f3ba9fa9918", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -26,9 +26,10 @@ use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n use rustc::ty::layout::VariantIdx;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use syntax::ast::{self, AttrStyle, Ident};\n+use syntax::ast::{self, Attribute, AttrStyle, AttrItem, Ident};\n use syntax::attr;\n use syntax_expand::base::MacroKind;\n+use syntax::parse::lexer::comments;\n use syntax::source_map::DUMMY_SP;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::{self, Pos, FileName};\n@@ -858,8 +859,31 @@ impl Attributes {\n         let mut cfg = Cfg::True;\n         let mut doc_line = 0;\n \n+        /// Converts `attr` to a normal `#[doc=\"foo\"]` comment, if it is a\n+        /// comment like `///` or `/** */`. (Returns `attr` unchanged for\n+        /// non-sugared doc attributes.)\n+        pub fn with_desugared_doc<T>(attr: &Attribute, f: impl FnOnce(&Attribute) -> T) -> T {\n+            if attr.is_sugared_doc {\n+                let comment = attr.value_str().unwrap();\n+                let meta = attr::mk_name_value_item_str(\n+                    Ident::with_dummy_span(sym::doc),\n+                    Symbol::intern(&comments::strip_doc_comment_decoration(&comment.as_str())),\n+                    DUMMY_SP,\n+                );\n+                f(&Attribute {\n+                    item: AttrItem { path: meta.path, tokens: meta.kind.tokens(meta.span) },\n+                    id: attr.id,\n+                    style: attr.style,\n+                    is_sugared_doc: true,\n+                    span: attr.span,\n+                })\n+            } else {\n+                f(attr)\n+            }\n+        }\n+\n         let other_attrs = attrs.iter().filter_map(|attr| {\n-            attr.with_desugared_doc(|attr| {\n+            with_desugared_doc(attr, |attr| {\n                 if attr.check_name(sym::doc) {\n                     if let Some(mi) = attr.meta() {\n                         if let Some(value) = mi.value_str() {"}, {"sha": "a0e07d58c9da9d25e0ee956746d472a25c2765a4", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -79,7 +79,7 @@ function getSearchElement() {\n                      \"derive\",\n                      \"traitalias\"];\n \n-    var disableShortcuts = getCurrentValue(\"rustdoc-disable-shortcuts\") !== \"true\";\n+    var disableShortcuts = getCurrentValue(\"rustdoc-disable-shortcuts\") === \"true\";\n     var search_input = getSearchInput();\n \n     // On the search screen, so you remain on the last tab you opened."}, {"sha": "c7adad896a51a11d84ecbff51486044a91050225", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -283,7 +283,7 @@\n #![feature(needs_panic_runtime)]\n #![feature(never_type)]\n #![feature(nll)]\n-#![feature(non_exhaustive)]\n+#![cfg_attr(bootstrap, feature(non_exhaustive))]\n #![feature(on_unimplemented)]\n #![feature(optin_builtin_traits)]\n #![feature(panic_info_message)]"}, {"sha": "6d6bc760649e0d315df748e5a9caaefd9130dbb8", "filename": "src/libstd/path.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1363,20 +1363,24 @@ impl PathBuf {\n     }\n \n     fn _set_extension(&mut self, extension: &OsStr) -> bool {\n-        if self.file_name().is_none() {\n-            return false;\n-        }\n-\n-        let mut stem = match self.file_stem() {\n-            Some(stem) => stem.to_os_string(),\n-            None => OsString::new(),\n+        let file_stem = match self.file_stem() {\n+            None => return false,\n+            Some(f) => os_str_as_u8_slice(f),\n         };\n \n-        if !os_str_as_u8_slice(extension).is_empty() {\n-            stem.push(\".\");\n-            stem.push(extension);\n+        // truncate until right after the file stem\n+        let end_file_stem = file_stem[file_stem.len()..].as_ptr() as usize;\n+        let start = os_str_as_u8_slice(&self.inner).as_ptr() as usize;\n+        let v = self.as_mut_vec();\n+        v.truncate(end_file_stem.wrapping_sub(start));\n+\n+        // add the new extension, if any\n+        let new = os_str_as_u8_slice(extension);\n+        if !new.is_empty() {\n+            v.reserve_exact(new.len() + 1);\n+            v.push(b'.');\n+            v.extend_from_slice(new);\n         }\n-        self.set_file_name(&stem);\n \n         true\n     }"}, {"sha": "5e1f10c03ceda583b9145dee6101376d14f6cbfa", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 55, "deletions": 42, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -105,11 +105,14 @@ cfg_has_statx! {{\n         flags: i32,\n         mask: u32,\n     ) -> Option<io::Result<FileAttr>> {\n-        use crate::sync::atomic::{AtomicBool, Ordering};\n+        use crate::sync::atomic::{AtomicU8, Ordering};\n \n         // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n-        // We store the availability in a global to avoid unnecessary syscalls\n-        static HAS_STATX: AtomicBool = AtomicBool::new(true);\n+        // We store the availability in global to avoid unnecessary syscalls.\n+        // 0: Unknown\n+        // 1: Not available\n+        // 2: Available\n+        static STATX_STATE: AtomicU8 = AtomicU8::new(0);\n         syscall! {\n             fn statx(\n                 fd: c_int,\n@@ -120,50 +123,60 @@ cfg_has_statx! {{\n             ) -> c_int\n         }\n \n-        if !HAS_STATX.load(Ordering::Relaxed) {\n-            return None;\n-        }\n-\n-        let mut buf: libc::statx = mem::zeroed();\n-        let ret = cvt(statx(fd, path, flags, mask, &mut buf));\n-        match ret {\n-            Err(err) => match err.raw_os_error() {\n-                Some(libc::ENOSYS) => {\n-                    HAS_STATX.store(false, Ordering::Relaxed);\n+        match STATX_STATE.load(Ordering::Relaxed) {\n+            0 => {\n+                // It is a trick to call `statx` with NULL pointers to check if the syscall\n+                // is available. According to the manual, it is expected to fail with EFAULT.\n+                // We do this mainly for performance, since it is nearly hundreds times\n+                // faster than a normal successfull call.\n+                let err = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n+                    .err()\n+                    .and_then(|e| e.raw_os_error());\n+                // We don't check `err == Some(libc::ENOSYS)` because the syscall may be limited\n+                // and returns `EPERM`. Listing all possible errors seems not a good idea.\n+                // See: https://github.com/rust-lang/rust/issues/65662\n+                if err != Some(libc::EFAULT) {\n+                    STATX_STATE.store(1, Ordering::Relaxed);\n                     return None;\n                 }\n-                _ => return Some(Err(err)),\n+                STATX_STATE.store(2, Ordering::Relaxed);\n             }\n-            Ok(_) => {\n-                // We cannot fill `stat64` exhaustively because of private padding fields.\n-                let mut stat: stat64 = mem::zeroed();\n-                // `c_ulong` on gnu-mips, `dev_t` otherwise\n-                stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor) as _;\n-                stat.st_ino = buf.stx_ino as libc::ino64_t;\n-                stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n-                stat.st_mode = buf.stx_mode as libc::mode_t;\n-                stat.st_uid = buf.stx_uid as libc::uid_t;\n-                stat.st_gid = buf.stx_gid as libc::gid_t;\n-                stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor) as _;\n-                stat.st_size = buf.stx_size as off64_t;\n-                stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n-                stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n-                stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n-                // `i64` on gnu-x86_64-x32, `c_ulong` otherwise.\n-                stat.st_atime_nsec = buf.stx_atime.tv_nsec as _;\n-                stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n-                stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as _;\n-                stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n-                stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as _;\n-\n-                let extra = StatxExtraFields {\n-                    stx_mask: buf.stx_mask,\n-                    stx_btime: buf.stx_btime,\n-                };\n+            1 => return None,\n+            _ => {}\n+        }\n \n-                Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n-            }\n+        let mut buf: libc::statx = mem::zeroed();\n+        if let Err(err) = cvt(statx(fd, path, flags, mask, &mut buf)) {\n+            return Some(Err(err));\n         }\n+\n+        // We cannot fill `stat64` exhaustively because of private padding fields.\n+        let mut stat: stat64 = mem::zeroed();\n+        // `c_ulong` on gnu-mips, `dev_t` otherwise\n+        stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor) as _;\n+        stat.st_ino = buf.stx_ino as libc::ino64_t;\n+        stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n+        stat.st_mode = buf.stx_mode as libc::mode_t;\n+        stat.st_uid = buf.stx_uid as libc::uid_t;\n+        stat.st_gid = buf.stx_gid as libc::gid_t;\n+        stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor) as _;\n+        stat.st_size = buf.stx_size as off64_t;\n+        stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n+        stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n+        stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n+        // `i64` on gnu-x86_64-x32, `c_ulong` otherwise.\n+        stat.st_atime_nsec = buf.stx_atime.tv_nsec as _;\n+        stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n+        stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as _;\n+        stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n+        stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as _;\n+\n+        let extra = StatxExtraFields {\n+            stx_mask: buf.stx_mask,\n+            stx_btime: buf.stx_btime,\n+        };\n+\n+        Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n     }\n \n } else {"}, {"sha": "27de084ae98ca25fc688eddc3d42f261c18721c3", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -13,8 +13,8 @@ use crate::ast::{AttrItem, AttrId, AttrStyle, Name, Ident, Path, PathSegment};\n use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n-use crate::source_map::{BytePos, Spanned, DUMMY_SP};\n-use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n+use crate::source_map::{BytePos, Spanned};\n+use crate::parse::lexer::comments::doc_comment_style;\n use crate::parse::parser::Parser;\n use crate::parse::PResult;\n use crate::parse::token::{self, Token};\n@@ -312,31 +312,6 @@ impl Attribute {\n             span: self.span,\n         })\n     }\n-\n-    /// Converts `self` to a normal `#[doc=\"foo\"]` comment, if it is a\n-    /// comment like `///` or `/** */`. (Returns `self` unchanged for\n-    /// non-sugared doc attributes.)\n-    pub fn with_desugared_doc<T, F>(&self, f: F) -> T where\n-        F: FnOnce(&Attribute) -> T,\n-    {\n-        if self.is_sugared_doc {\n-            let comment = self.value_str().unwrap();\n-            let meta = mk_name_value_item_str(\n-                Ident::with_dummy_span(sym::doc),\n-                Symbol::intern(&strip_doc_comment_decoration(&comment.as_str())),\n-                DUMMY_SP,\n-            );\n-            f(&Attribute {\n-                item: AttrItem { path: meta.path, tokens: meta.kind.tokens(meta.span) },\n-                id: self.id,\n-                style: self.style,\n-                is_sugared_doc: true,\n-                span: self.span,\n-            })\n-        } else {\n-            f(self)\n-        }\n-    }\n }\n \n /* Constructors */"}, {"sha": "36fcab8450b85e9344c2772a4b93ed918a9c8fc9", "filename": "src/libsyntax/feature_gate/accepted.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -245,8 +245,10 @@ declare_features! (\n     (accepted, bind_by_move_pattern_guards, \"1.39.0\", Some(15287), None),\n     /// Allows attributes in formal function parameters.\n     (accepted, param_attrs, \"1.39.0\", Some(60406), None),\n-    // Allows macro invocations in `extern {}` blocks.\n+    /// Allows macro invocations in `extern {}` blocks.\n     (accepted, macros_in_extern, \"1.40.0\", Some(49476), None),\n+    /// Allows future-proofing enums/structs with the `#[non_exhaustive]` attribute (RFC 2008).\n+    (accepted, non_exhaustive, \"1.40.0\", Some(44109), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: accepted features"}, {"sha": "f6e1d6c422499d8fe1ee5842d7edf5ef24a0ac23", "filename": "src/libsyntax/feature_gate/active.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Factive.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -383,9 +383,6 @@ declare_features! (\n     /// Allows `#[doc(include = \"some-file\")]`.\n     (active, external_doc, \"1.22.0\", Some(44732), None),\n \n-    /// Allows future-proofing enums/structs with the `#[non_exhaustive]` attribute (RFC 2008).\n-    (active, non_exhaustive, \"1.22.0\", Some(44109), None),\n-\n     /// Allows using `crate` as visibility modifier, synonymous with `pub(crate)`.\n     (active, crate_visibility_modifier, \"1.23.0\", Some(53120), None),\n "}, {"sha": "efe84238795a5739ab84251cf58b6ec4557f91c0", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -252,6 +252,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(path, Normal, template!(NameValueStr: \"file\")),\n     ungated!(no_std, CrateLevel, template!(Word)),\n     ungated!(no_implicit_prelude, Normal, template!(Word)),\n+    ungated!(non_exhaustive, Whitelisted, template!(Word)),\n \n     // Runtime\n     ungated!(windows_subsystem, Whitelisted, template!(NameValueStr: \"windows|console\")),\n@@ -314,9 +315,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         test_runner, CrateLevel, template!(List: \"path\"), custom_test_frameworks,\n         \"custom test frameworks are an unstable feature\",\n     ),\n-\n-    // RFC #2008\n-    gated!(non_exhaustive, Whitelisted, template!(Word), experimental!(non_exhaustive)),\n     // RFC #1268\n     gated!(marker, Normal, template!(Word), marker_trait_attr, experimental!(marker)),\n     gated!("}, {"sha": "0b157938375e10284db43cf53b1535a7b0230be8", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -25,6 +25,9 @@ use std::sync::{Arc, Mutex};\n \n use rustc_serialize::json::{as_json, as_pretty_json};\n \n+#[cfg(test)]\n+mod tests;\n+\n pub struct JsonEmitter {\n     dst: Box<dyn Write + Send>,\n     registry: Option<Registry>,\n@@ -336,8 +339,8 @@ impl DiagnosticSpan {\n \n         DiagnosticSpan {\n             file_name: start.file.name.to_string(),\n-            byte_start: span.lo().0 - start.file.start_pos.0,\n-            byte_end: span.hi().0 - start.file.start_pos.0,\n+            byte_start: start.file.original_relative_byte_pos(span.lo()).0,\n+            byte_end: start.file.original_relative_byte_pos(span.hi()).0,\n             line_start: start.line,\n             line_end: end.line,\n             column_start: start.col.0 + 1,"}, {"sha": "eb0d9ef3947c8f0d67165b88f66fda212216ec61", "filename": "src/libsyntax/json/tests.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson%2Ftests.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -0,0 +1,186 @@\n+use super::*;\n+\n+use crate::json::JsonEmitter;\n+use crate::source_map::{FilePathMapping, SourceMap};\n+use crate::tests::Shared;\n+use crate::with_default_globals;\n+\n+use errors::emitter::{ColorConfig, HumanReadableErrorType};\n+use errors::Handler;\n+use rustc_serialize::json::decode;\n+use syntax_pos::{BytePos, Span};\n+\n+use std::str;\n+\n+#[derive(RustcDecodable, Debug, PartialEq, Eq)]\n+struct TestData {\n+    spans: Vec<SpanTestData>,\n+}\n+\n+#[derive(RustcDecodable, Debug, PartialEq, Eq)]\n+struct SpanTestData {\n+    pub byte_start: u32,\n+    pub byte_end: u32,\n+    pub line_start: u32,\n+    pub column_start: u32,\n+    pub line_end: u32,\n+    pub column_end: u32,\n+}\n+\n+/// Test the span yields correct positions in JSON.\n+fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n+    let expected_output = TestData { spans: vec![expected_output] };\n+\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        sm.new_source_file(Path::new(\"test.rs\").to_owned().into(), code.to_owned());\n+\n+        let output = Arc::new(Mutex::new(Vec::new()));\n+        let je = JsonEmitter::new(\n+            Box::new(Shared { data: output.clone() }),\n+            None,\n+            sm,\n+            true,\n+            HumanReadableErrorType::Short(ColorConfig::Never),\n+            false,\n+        );\n+\n+        let span = Span::with_root_ctxt(BytePos(span.0), BytePos(span.1));\n+        let handler = Handler::with_emitter(true, None, Box::new(je));\n+        handler.span_err(span, \"foo\");\n+\n+        let bytes = output.lock().unwrap();\n+        let actual_output = str::from_utf8(&bytes).unwrap();\n+        let actual_output: TestData = decode(actual_output).unwrap();\n+\n+        assert_eq!(expected_output, actual_output)\n+    })\n+}\n+\n+#[test]\n+fn empty() {\n+    test_positions(\n+        \" \",\n+        (0, 1),\n+        SpanTestData {\n+            byte_start: 0,\n+            byte_end: 1,\n+            line_start: 1,\n+            column_start: 1,\n+            line_end: 1,\n+            column_end: 2,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn bom() {\n+    test_positions(\n+        \"\\u{feff} \",\n+        (0, 1),\n+        SpanTestData {\n+            byte_start: 3,\n+            byte_end: 4,\n+            line_start: 1,\n+            column_start: 1,\n+            line_end: 1,\n+            column_end: 2,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn lf_newlines() {\n+    test_positions(\n+        \"\\nmod foo;\\nmod bar;\\n\",\n+        (5, 12),\n+        SpanTestData {\n+            byte_start: 5,\n+            byte_end: 12,\n+            line_start: 2,\n+            column_start: 5,\n+            line_end: 3,\n+            column_end: 3,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn crlf_newlines() {\n+    test_positions(\n+        \"\\r\\nmod foo;\\r\\nmod bar;\\r\\n\",\n+        (5, 12),\n+        SpanTestData {\n+            byte_start: 6,\n+            byte_end: 14,\n+            line_start: 2,\n+            column_start: 5,\n+            line_end: 3,\n+            column_end: 3,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn crlf_newlines_with_bom() {\n+    test_positions(\n+        \"\\u{feff}\\r\\nmod foo;\\r\\nmod bar;\\r\\n\",\n+        (5, 12),\n+        SpanTestData {\n+            byte_start: 9,\n+            byte_end: 17,\n+            line_start: 2,\n+            column_start: 5,\n+            line_end: 3,\n+            column_end: 3,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn span_before_crlf() {\n+    test_positions(\n+        \"foo\\r\\nbar\",\n+        (2, 3),\n+        SpanTestData {\n+            byte_start: 2,\n+            byte_end: 3,\n+            line_start: 1,\n+            column_start: 3,\n+            line_end: 1,\n+            column_end: 4,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn span_on_crlf() {\n+    test_positions(\n+        \"foo\\r\\nbar\",\n+        (3, 4),\n+        SpanTestData {\n+            byte_start: 3,\n+            byte_end: 5,\n+            line_start: 1,\n+            column_start: 4,\n+            line_end: 2,\n+            column_end: 1,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn span_after_crlf() {\n+    test_positions(\n+        \"foo\\r\\nbar\",\n+        (4, 5),\n+        SpanTestData {\n+            byte_start: 5,\n+            byte_end: 6,\n+            line_start: 2,\n+            column_start: 1,\n+            line_end: 2,\n+            column_end: 2,\n+        },\n+    )\n+}"}, {"sha": "3a2af96f7db6483bb8bdd84c8dac9dac77df9ede", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -31,23 +31,6 @@ mod tests;\n \n pub const MACRO_ARGUMENTS: Option<&'static str> = Some(\"macro arguments\");\n \n-// A variant of 'panictry!' that works on a Vec<Diagnostic> instead of a single DiagnosticBuilder.\n-macro_rules! panictry_buffer {\n-    ($handler:expr, $e:expr) => ({\n-        use std::result::Result::{Ok, Err};\n-        use errors::FatalError;\n-        match $e {\n-            Ok(e) => e,\n-            Err(errs) => {\n-                for e in errs {\n-                    $handler.emit_diagnostic(&e);\n-                }\n-                FatalError.raise()\n-            }\n-        }\n-    })\n-}\n-\n #[macro_export]\n macro_rules! unwrap_or {\n     ($opt:expr, $default:expr) => {"}, {"sha": "ac79ce323bf97ef36e903f2ec4e31f79ff424722", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -176,7 +176,7 @@ fn split_block_comment_into_lines(\n \n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n-pub fn gather_comments(sess: &ParseSess, path: FileName, src: String) -> Vec<Comment> {\n+crate fn gather_comments(sess: &ParseSess, path: FileName, src: String) -> Vec<Comment> {\n     let cm = SourceMap::new(sess.source_map().path_mapping().clone());\n     let source_file = cm.new_source_file(path, src);\n     let text = (*source_file.src.as_ref().unwrap()).clone();"}, {"sha": "853723de14f44b2b7870f369b5dccedd5c8a26f6", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,8 +1,9 @@\n use rustc_data_structures::fx::FxHashMap;\n use syntax_pos::Span;\n \n+use super::{StringReader, UnmatchedBrace};\n+\n use crate::print::pprust::token_to_string;\n-use crate::parse::lexer::{StringReader, UnmatchedBrace};\n use crate::parse::token::{self, Token};\n use crate::parse::PResult;\n use crate::tokenstream::{DelimSpan, IsJoint::{self, *}, TokenStream, TokenTree, TreeAndJoint};"}, {"sha": "e6ddf8778ccf035dbd8f095f45f8d15a784c081b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -59,6 +59,23 @@ pub enum DirectoryOwnership {\n // uses a HOF to parse anything, and <source> includes file and\n // `source_str`.\n \n+/// A variant of 'panictry!' that works on a Vec<Diagnostic> instead of a single DiagnosticBuilder.\n+macro_rules! panictry_buffer {\n+    ($handler:expr, $e:expr) => ({\n+        use std::result::Result::{Ok, Err};\n+        use errors::FatalError;\n+        match $e {\n+            Ok(e) => e,\n+            Err(errs) => {\n+                for e in errs {\n+                    $handler.emit_diagnostic(&e);\n+                }\n+                FatalError.raise()\n+            }\n+        }\n+    })\n+}\n+\n pub fn parse_crate_from_file<'a>(input: &Path, sess: &'a ParseSess) -> PResult<'a, ast::Crate> {\n     let mut parser = new_parser_from_file(sess, input);\n     parser.parse_crate_mod()"}, {"sha": "6ead1ce811d4956a512a3fda0042fca0cfbedb59", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1368,25 +1368,6 @@ impl<'a> Parser<'a> {\n             }\n         }\n     }\n-\n-    fn report_invalid_macro_expansion_item(&self) {\n-        self.struct_span_err(\n-            self.prev_span,\n-            \"macros that expand to items must be delimited with braces or followed by a semicolon\",\n-        ).multipart_suggestion(\n-            \"change the delimiters to curly braces\",\n-            vec![\n-                (self.prev_span.with_hi(self.prev_span.lo() + BytePos(1)), String::from(\" {\")),\n-                (self.prev_span.with_lo(self.prev_span.hi() - BytePos(1)), '}'.to_string()),\n-            ],\n-            Applicability::MaybeIncorrect,\n-        ).span_suggestion(\n-            self.sess.source_map().next_point(self.prev_span),\n-            \"add a semicolon\",\n-            ';'.to_string(),\n-            Applicability::MaybeIncorrect,\n-        ).emit();\n-    }\n }\n \n pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, handler: &errors::Handler) {"}, {"sha": "506a1a2a27a34f5af1e057cb91ae5a16b0a84d0f", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -19,6 +19,7 @@ use log::debug;\n use std::mem;\n use rustc_target::spec::abi::Abi;\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, StashKey};\n+use syntax_pos::BytePos;\n \n /// Whether the type alias or associated type is a concrete type or an opaque type.\n #[derive(Debug)]\n@@ -1739,6 +1740,25 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn report_invalid_macro_expansion_item(&self) {\n+        self.struct_span_err(\n+            self.prev_span,\n+            \"macros that expand to items must be delimited with braces or followed by a semicolon\",\n+        ).multipart_suggestion(\n+            \"change the delimiters to curly braces\",\n+            vec![\n+                (self.prev_span.with_hi(self.prev_span.lo() + BytePos(1)), String::from(\" {\")),\n+                (self.prev_span.with_lo(self.prev_span.hi() - BytePos(1)), '}'.to_string()),\n+            ],\n+            Applicability::MaybeIncorrect,\n+        ).span_suggestion(\n+            self.sess.source_map().next_point(self.prev_span),\n+            \"add a semicolon\",\n+            ';'.to_string(),\n+            Applicability::MaybeIncorrect,\n+        ).emit();\n+    }\n+\n     fn mk_item(&self, span: Span, ident: Ident, kind: ItemKind, vis: Visibility,\n                attrs: Vec<Attribute>) -> P<Item> {\n         P(Item {"}, {"sha": "d7760e0cf9ee452964d1fdf607a2966a56cd05a4", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -283,6 +283,7 @@ impl SourceMap {\n         mut file_local_lines: Vec<BytePos>,\n         mut file_local_multibyte_chars: Vec<MultiByteChar>,\n         mut file_local_non_narrow_chars: Vec<NonNarrowChar>,\n+        mut file_local_normalized_pos: Vec<NormalizedPos>,\n     ) -> Lrc<SourceFile> {\n         let start_pos = self.next_start_pos();\n \n@@ -301,6 +302,10 @@ impl SourceMap {\n             *swc = *swc + start_pos;\n         }\n \n+        for nc in &mut file_local_normalized_pos {\n+            nc.pos = nc.pos + start_pos;\n+        }\n+\n         let source_file = Lrc::new(SourceFile {\n             name: filename,\n             name_was_remapped,\n@@ -314,6 +319,7 @@ impl SourceMap {\n             lines: file_local_lines,\n             multibyte_chars: file_local_multibyte_chars,\n             non_narrow_chars: file_local_non_narrow_chars,\n+            normalized_pos: file_local_normalized_pos,\n             name_hash,\n         });\n "}, {"sha": "e73c8b43bccbf4d9242db01d0af54466fdc04af1", "filename": "src/libsyntax/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftests.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -111,8 +111,8 @@ struct SpanLabel {\n     label: &'static str,\n }\n \n-struct Shared<T: Write> {\n-    data: Arc<Mutex<T>>,\n+crate struct Shared<T: Write> {\n+    pub data: Arc<Mutex<T>>,\n }\n \n impl<T: Write> Write for Shared<T> {"}, {"sha": "9034f8c1afd1bbe0314341413abe34835bce69d3", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -9,7 +9,7 @@\n #![feature(const_fn)]\n #![feature(crate_visibility_modifier)]\n #![feature(nll)]\n-#![feature(non_exhaustive)]\n+#![cfg_attr(bootstrap, feature(non_exhaustive))]\n #![feature(optin_builtin_traits)]\n #![feature(rustc_attrs)]\n #![cfg_attr(bootstrap, feature(proc_macro_hygiene))]\n@@ -855,6 +855,15 @@ impl Sub<BytePos> for NonNarrowChar {\n     }\n }\n \n+/// Identifies an offset of a character that was normalized away from `SourceFile`.\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n+pub struct NormalizedPos {\n+    /// The absolute offset of the character in the `SourceMap`.\n+    pub pos: BytePos,\n+    /// The difference between original and normalized string at position.\n+    pub diff: u32,\n+}\n+\n /// The state of the lazy external source loading mechanism of a `SourceFile`.\n #[derive(PartialEq, Eq, Clone)]\n pub enum ExternalSource {\n@@ -918,6 +927,8 @@ pub struct SourceFile {\n     pub multibyte_chars: Vec<MultiByteChar>,\n     /// Width of characters that are not narrow in the source code.\n     pub non_narrow_chars: Vec<NonNarrowChar>,\n+    /// Locations of characters removed during normalization.\n+    pub normalized_pos: Vec<NormalizedPos>,\n     /// A hash of the filename, used for speeding up hashing in incremental compilation.\n     pub name_hash: u128,\n }\n@@ -984,6 +995,9 @@ impl Encodable for SourceFile {\n             })?;\n             s.emit_struct_field(\"name_hash\", 8, |s| {\n                 self.name_hash.encode(s)\n+            })?;\n+            s.emit_struct_field(\"normalized_pos\", 9, |s| {\n+                self.normalized_pos.encode(s)\n             })\n         })\n     }\n@@ -1034,6 +1048,8 @@ impl Decodable for SourceFile {\n                 d.read_struct_field(\"non_narrow_chars\", 7, |d| Decodable::decode(d))?;\n             let name_hash: u128 =\n                 d.read_struct_field(\"name_hash\", 8, |d| Decodable::decode(d))?;\n+            let normalized_pos: Vec<NormalizedPos> =\n+                d.read_struct_field(\"normalized_pos\", 9, |d| Decodable::decode(d))?;\n             Ok(SourceFile {\n                 name,\n                 name_was_remapped,\n@@ -1050,6 +1066,7 @@ impl Decodable for SourceFile {\n                 lines,\n                 multibyte_chars,\n                 non_narrow_chars,\n+                normalized_pos,\n                 name_hash,\n             })\n         })\n@@ -1068,8 +1085,7 @@ impl SourceFile {\n                unmapped_path: FileName,\n                mut src: String,\n                start_pos: BytePos) -> Result<SourceFile, OffsetOverflowError> {\n-        remove_bom(&mut src);\n-        normalize_newlines(&mut src);\n+        let normalized_pos = normalize_src(&mut src, start_pos);\n \n         let src_hash = {\n             let mut hasher: StableHasher = StableHasher::new();\n@@ -1102,6 +1118,7 @@ impl SourceFile {\n             lines,\n             multibyte_chars,\n             non_narrow_chars,\n+            normalized_pos,\n             name_hash,\n         })\n     }\n@@ -1228,20 +1245,52 @@ impl SourceFile {\n     pub fn contains(&self, byte_pos: BytePos) -> bool {\n         byte_pos >= self.start_pos && byte_pos <= self.end_pos\n     }\n+\n+    /// Calculates the original byte position relative to the start of the file\n+    /// based on the given byte position.\n+    pub fn original_relative_byte_pos(&self, pos: BytePos) -> BytePos {\n+\n+        // Diff before any records is 0. Otherwise use the previously recorded\n+        // diff as that applies to the following characters until a new diff\n+        // is recorded.\n+        let diff = match self.normalized_pos.binary_search_by(\n+                            |np| np.pos.cmp(&pos)) {\n+            Ok(i) => self.normalized_pos[i].diff,\n+            Err(i) if i == 0 => 0,\n+            Err(i) => self.normalized_pos[i-1].diff,\n+        };\n+\n+        BytePos::from_u32(pos.0 - self.start_pos.0 + diff)\n+    }\n+}\n+\n+/// Normalizes the source code and records the normalizations.\n+fn normalize_src(src: &mut String, start_pos: BytePos) -> Vec<NormalizedPos> {\n+    let mut normalized_pos = vec![];\n+    remove_bom(src, &mut normalized_pos);\n+    normalize_newlines(src, &mut normalized_pos);\n+\n+    // Offset all the positions by start_pos to match the final file positions.\n+    for np in &mut normalized_pos {\n+        np.pos.0 += start_pos.0;\n+    }\n+\n+    normalized_pos\n }\n \n /// Removes UTF-8 BOM, if any.\n-fn remove_bom(src: &mut String) {\n+fn remove_bom(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {\n     if src.starts_with(\"\\u{feff}\") {\n         src.drain(..3);\n+        normalized_pos.push(NormalizedPos { pos: BytePos(0), diff: 3 });\n     }\n }\n \n \n /// Replaces `\\r\\n` with `\\n` in-place in `src`.\n ///\n /// Returns error if there's a lone `\\r` in the string\n-fn normalize_newlines(src: &mut String) {\n+fn normalize_newlines(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {\n     if !src.as_bytes().contains(&b'\\r') {\n         return;\n     }\n@@ -1254,6 +1303,8 @@ fn normalize_newlines(src: &mut String) {\n     let mut buf = std::mem::replace(src, String::new()).into_bytes();\n     let mut gap_len = 0;\n     let mut tail = buf.as_mut_slice();\n+    let mut cursor = 0;\n+    let original_gap = normalized_pos.last().map_or(0, |l| l.diff);\n     loop {\n         let idx = match find_crlf(&tail[gap_len..]) {\n             None => tail.len(),\n@@ -1264,7 +1315,12 @@ fn normalize_newlines(src: &mut String) {\n         if tail.len() == gap_len {\n             break;\n         }\n+        cursor += idx - gap_len;\n         gap_len += 1;\n+        normalized_pos.push(NormalizedPos {\n+            pos: BytePos::from_usize(cursor + 1),\n+            diff: original_gap + gap_len as u32,\n+        });\n     }\n \n     // Account for removed `\\r`."}, {"sha": "87cc3505e389b40a90ac6b798385622889d3e595", "filename": "src/libsyntax_pos/tests.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax_pos%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Flibsyntax_pos%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Ftests.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -19,20 +19,25 @@ fn test_lookup_line() {\n \n #[test]\n fn test_normalize_newlines() {\n-    fn check(before: &str, after: &str) {\n+    fn check(before: &str, after: &str, expected_positions: &[u32]) {\n         let mut actual = before.to_string();\n-        normalize_newlines(&mut actual);\n+        let mut actual_positions = vec![];\n+        normalize_newlines(&mut actual, &mut actual_positions);\n+        let actual_positions : Vec<_> = actual_positions\n+            .into_iter()\n+            .map(|nc| nc.pos.0).collect();\n         assert_eq!(actual.as_str(), after);\n+        assert_eq!(actual_positions, expected_positions);\n     }\n-    check(\"\", \"\");\n-    check(\"\\n\", \"\\n\");\n-    check(\"\\r\", \"\\r\");\n-    check(\"\\r\\r\", \"\\r\\r\");\n-    check(\"\\r\\n\", \"\\n\");\n-    check(\"hello world\", \"hello world\");\n-    check(\"hello\\nworld\", \"hello\\nworld\");\n-    check(\"hello\\r\\nworld\", \"hello\\nworld\");\n-    check(\"\\r\\nhello\\r\\nworld\\r\\n\", \"\\nhello\\nworld\\n\");\n-    check(\"\\r\\r\\n\", \"\\r\\n\");\n-    check(\"hello\\rworld\", \"hello\\rworld\");\n+    check(\"\", \"\", &[]);\n+    check(\"\\n\", \"\\n\", &[]);\n+    check(\"\\r\", \"\\r\", &[]);\n+    check(\"\\r\\r\", \"\\r\\r\", &[]);\n+    check(\"\\r\\n\", \"\\n\", &[1]);\n+    check(\"hello world\", \"hello world\", &[]);\n+    check(\"hello\\nworld\", \"hello\\nworld\", &[]);\n+    check(\"hello\\r\\nworld\", \"hello\\nworld\", &[6]);\n+    check(\"\\r\\nhello\\r\\nworld\\r\\n\", \"\\nhello\\nworld\\n\", &[1, 7, 13]);\n+    check(\"\\r\\r\\n\", \"\\r\\n\", &[2]);\n+    check(\"hello\\rworld\", \"hello\\rworld\", &[]);\n }"}, {"sha": "9ea3d3fb0e1f125038c940d40d0d2235ef8febea", "filename": "src/test/ui/.gitattributes", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2F.gitattributes?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,3 +1,6 @@\n lexer-crlf-line-endings-string-literal-doc-comment.rs -text\n+json-bom-plus-crlf.rs -text\n+json-bom-plus-crlf-multifile.rs -text\n+json-bom-plus-crlf-multifile-aux.rs -text\n trailing-carriage-return-in-string.rs -text\n *.bin -text"}, {"sha": "950f170f4fd4168bb0cfdd6ba52e25623c21b153", "filename": "src/test/ui/feature-gates/feature-gate-non_exhaustive.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85943fd7c88ddf870b03afdd6cd6782721c348e1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85943fd7c88ddf870b03afdd6cd6782721c348e1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.rs?ref=85943fd7c88ddf870b03afdd6cd6782721c348e1", "patch": "@@ -1,10 +0,0 @@\n-//#![feature(non_exhaustive)]\n-\n-#[non_exhaustive] //~ERROR the `#[non_exhaustive]` attribute is an experimental feature\n-pub enum NonExhaustiveEnum {\n-    Unit,\n-    Tuple(u32),\n-    Struct { field: u32 }\n-}\n-\n-fn main() { }"}, {"sha": "482332b8d706c457e731ae7a7c831dc8ad0977d9", "filename": "src/test/ui/feature-gates/feature-gate-non_exhaustive.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/85943fd7c88ddf870b03afdd6cd6782721c348e1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85943fd7c88ddf870b03afdd6cd6782721c348e1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.stderr?ref=85943fd7c88ddf870b03afdd6cd6782721c348e1", "patch": "@@ -1,12 +0,0 @@\n-error[E0658]: the `#[non_exhaustive]` attribute is an experimental feature\n-  --> $DIR/feature-gate-non_exhaustive.rs:3:1\n-   |\n-LL | #[non_exhaustive]\n-   | ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/44109\n-   = help: add `#![feature(non_exhaustive)]` to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "991ea1d85d2ca3d8ae73449e5516524d4e092d6d", "filename": "src/test/ui/json-bom-plus-crlf-multifile-aux.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile-aux.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -0,0 +1,27 @@\n+\ufeff// (This line has BOM so it's ignored by compiletest for directives)\r\n+//\r\n+// ignore-test Not a test. Used by other tests\r\n+// ignore-tidy-cr\r\n+\r\n+// For easier verifying, the byte offsets in this file should match those\r\n+// in the json-bom-plus-crlf.rs - given the actual fn is identical (just with\r\n+// a different, but equally sized name), the easiest way to do this is to\r\n+// ensure the two files are of equal size on disk.\r\n+// Padding............................\r\n+\r\n+// N.B., this file needs CRLF line endings. The .gitattributes file in\r\n+// this directory should enforce it.\r\n+\r\n+pub fn test() {\r\n+\r\n+    let s : String = 1;  // Error in the middle of line.\r\n+\r\n+    let s : String = 1\r\n+    ;  // Error before the newline.\r\n+\r\n+    let s : String =\r\n+1;  // Error after the newline.\r\n+\r\n+    let s : String = (\r\n+    );  // Error spanning the newline.\r\n+}\r"}, {"sha": "c71dd325f4427f107b3a6999a31c57d062b17bd5", "filename": "src/test/ui/json-bom-plus-crlf-multifile.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -0,0 +1,12 @@\n+\ufeff// (This line has BOM so it's ignored by compiletest for directives)\r\n+//\r\n+// build-fail\r\n+// compile-flags: --json=diagnostic-short --error-format=json\r\n+// ignore-tidy-cr\r\n+\r\n+#[path = \"json-bom-plus-crlf-multifile-aux.rs\"]\r\n+mod json_bom_plus_crlf_multifile_aux;\r\n+\r\n+fn main() {\r\n+    json_bom_plus_crlf_multifile_aux::test();\r\n+}\r"}, {"sha": "8472f16108909f0699a671fee0c2db7c37fabeee", "filename": "src/test/ui/json-bom-plus-crlf-multifile.stderr", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -0,0 +1,86 @@\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:17:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:19:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:23:1: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":801,\"byte_end\":809,\"line_start\":25,\"line_end\":26,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found ()\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `()`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:25:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"aborting due to 4 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 4 previous errors\n+\"}"}, {"sha": "ae54a35d4805ce97bd638619cb64af180e42a98e", "filename": "src/test/ui/json-bom-plus-crlf.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -0,0 +1,27 @@\n+\ufeff// (This line has BOM so it's ignored by compiletest for directives)\r\n+//\r\n+// build-fail\r\n+// compile-flags: --json=diagnostic-short --error-format=json\r\n+// ignore-tidy-cr\r\n+\r\n+// For easier verifying, the byte offsets in this file should match those\r\n+// in the json_bom_plus_crlf_multifile_aux.rs - given the actual fn is\r\n+// identical (just with a different, but equally sized name), the easiest way\r\n+// to do this is to ensure the two files are of equal size on disk.\r\n+\r\n+// N.B., this file needs CRLF line endings. The .gitattributes file in\r\n+// this directory should enforce it.\r\n+\r\n+fn main() {\r\n+\r\n+    let s : String = 1;  // Error in the middle of line.\r\n+\r\n+    let s : String = 1\r\n+    ;  // Error before the newline.\r\n+\r\n+    let s : String =\r\n+1;  // Error after the newline.\r\n+\r\n+    let s : String = (\r\n+    );  // Error spanning the newline.\r\n+}\r"}, {"sha": "17775f59fd16f8dc643fa89d0e36f5b1c1e1b57e", "filename": "src/test/ui/json-bom-plus-crlf.stderr", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -0,0 +1,86 @@\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:17:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:19:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:23:1: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":801,\"byte_end\":809,\"line_start\":25,\"line_end\":26,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found ()\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `()`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:25:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"aborting due to 4 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 4 previous errors\n+\"}"}, {"sha": "bbc25d40256ff3caf680c609700d80519dd0161c", "filename": "src/test/ui/rfc-2008-non-exhaustive/auxiliary/enums.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,4 @@\n #![crate_type = \"rlib\"]\n-#![feature(non_exhaustive)]\n \n #[non_exhaustive]\n pub enum NonExhaustiveEnum {"}, {"sha": "6bfe7bf923d0901e2cf5ddb92d31d86fc89d4604", "filename": "src/test/ui/rfc-2008-non-exhaustive/auxiliary/structs.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fstructs.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,3 @@\n-#![feature(non_exhaustive)]\n-\n #[non_exhaustive]\n pub struct NormalStruct {\n     pub first_field: u16,"}, {"sha": "02672d5454e57bf82cdb1c2c5d13852d1e2c90f2", "filename": "src/test/ui/rfc-2008-non-exhaustive/auxiliary/variants.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fvariants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fvariants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fvariants.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,4 @@\n #![crate_type = \"rlib\"]\n-#![feature(non_exhaustive)]\n \n pub enum NonExhaustiveVariants {\n     #[non_exhaustive] Unit,"}, {"sha": "54e42917f52d2357acf8c18c7313df514067a85d", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(non_exhaustive)]\n-\n #[non_exhaustive]\n pub enum NonExhaustiveEnum {\n     Unit,"}, {"sha": "d6251fcb768f400271e8bf54d47964bc076ace6f", "filename": "src/test/ui/rfc-2008-non-exhaustive/improper_ctypes/auxiliary/types.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fimproper_ctypes%2Fauxiliary%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fimproper_ctypes%2Fauxiliary%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fimproper_ctypes%2Fauxiliary%2Ftypes.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,3 @@\n-#![feature(non_exhaustive)]\n-\n #[non_exhaustive]\n #[repr(C)]\n pub enum NonExhaustiveEnum {"}, {"sha": "c09aa256e0e74f241b53fa6705c045140b311890", "filename": "src/test/ui/rfc-2008-non-exhaustive/improper_ctypes/same_crate_proper.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fimproper_ctypes%2Fsame_crate_proper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fimproper_ctypes%2Fsame_crate_proper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fimproper_ctypes%2Fsame_crate_proper.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,4 @@\n // check-pass\n-#![feature(non_exhaustive)]\n #![deny(improper_ctypes)]\n \n // This test checks that non-exhaustive types with `#[repr(C)]` are considered proper within"}, {"sha": "3c4a09fafd2dbc8360979d6d74b91f6d7739a9a0", "filename": "src/test/ui/rfc-2008-non-exhaustive/invalid-attribute.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,3 @@\n-#![feature(non_exhaustive)]\n-\n #[non_exhaustive(anything)]\n //~^ ERROR malformed `non_exhaustive` attribute\n struct Foo;"}, {"sha": "76d9e2d8205b74305431fd218a94718c4ec34638", "filename": "src/test/ui/rfc-2008-non-exhaustive/invalid-attribute.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.stderr?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,11 +1,11 @@\n error: malformed `non_exhaustive` attribute input\n-  --> $DIR/invalid-attribute.rs:3:1\n+  --> $DIR/invalid-attribute.rs:1:1\n    |\n LL | #[non_exhaustive(anything)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[non_exhaustive]`\n \n error[E0701]: attribute can only be applied to a struct or enum\n-  --> $DIR/invalid-attribute.rs:7:1\n+  --> $DIR/invalid-attribute.rs:5:1\n    |\n LL | #[non_exhaustive]\n    | ^^^^^^^^^^^^^^^^^\n@@ -14,7 +14,7 @@ LL | trait Bar { }\n    | ------------- not a struct or enum\n \n error[E0701]: attribute can only be applied to a struct or enum\n-  --> $DIR/invalid-attribute.rs:11:1\n+  --> $DIR/invalid-attribute.rs:9:1\n    |\n LL |   #[non_exhaustive]\n    |   ^^^^^^^^^^^^^^^^^"}, {"sha": "04cfe51cab025776dfa203ba7e82b67edd7cc5cf", "filename": "src/test/ui/rfc-2008-non-exhaustive/struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -16,7 +16,7 @@ error[E0603]: tuple struct constructor `TupleStruct` is private\n LL |     let ts_explicit = structs::TupleStruct(640, 480);\n    |                                ^^^^^^^^^^^\n    | \n-  ::: $DIR/auxiliary/structs.rs:13:24\n+  ::: $DIR/auxiliary/structs.rs:11:24\n    |\n LL | pub struct TupleStruct(pub u16, pub u16);\n    |                        ---------------- a constructor is private if any of the fields is private"}, {"sha": "5f76b0cb2f4b6098f09e9596941baf4df0e556b1", "filename": "src/test/ui/rfc-2008-non-exhaustive/structs_same_crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstructs_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstructs_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstructs_same_crate.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n \n #![allow(unused_variables)]\n-#![feature(non_exhaustive)]\n \n #[non_exhaustive]\n pub struct NormalStruct {"}, {"sha": "a2735d4cbfb2928c1e32eb3bb4a81d73e1411b3a", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/auxiliary/uninhabited.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fauxiliary%2Funinhabited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fauxiliary%2Funinhabited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fauxiliary%2Funinhabited.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,6 +1,5 @@\n #![crate_type = \"rlib\"]\n #![feature(never_type)]\n-#![feature(non_exhaustive)]\n \n #[non_exhaustive]\n pub enum UninhabitedEnum {"}, {"sha": "6b911dd989cc580f89170be9eb9eabdc673d3f37", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/coercions_same_crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,4 @@\n #![feature(never_type)]\n-#![feature(non_exhaustive)]\n \n #[non_exhaustive]\n pub enum UninhabitedEnum {"}, {"sha": "a07473dade22cc4ed56d44c31980bcacb4fb1127", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/coercions_same_crate.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.stderr?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/coercions_same_crate.rs:31:5\n+  --> $DIR/coercions_same_crate.rs:30:5\n    |\n LL | fn cannot_coerce_empty_enum_to_anything(x: UninhabitedEnum) -> A {\n    |                                                                - expected `A` because of return type\n@@ -10,7 +10,7 @@ LL |     x\n               found type `UninhabitedEnum`\n \n error[E0308]: mismatched types\n-  --> $DIR/coercions_same_crate.rs:35:5\n+  --> $DIR/coercions_same_crate.rs:34:5\n    |\n LL | fn cannot_coerce_empty_tuple_struct_to_anything(x: UninhabitedTupleStruct) -> A {\n    |                                                                               - expected `A` because of return type\n@@ -21,7 +21,7 @@ LL |     x\n               found type `UninhabitedTupleStruct`\n \n error[E0308]: mismatched types\n-  --> $DIR/coercions_same_crate.rs:39:5\n+  --> $DIR/coercions_same_crate.rs:38:5\n    |\n LL | fn cannot_coerce_empty_struct_to_anything(x: UninhabitedStruct) -> A {\n    |                                                                    - expected `A` because of return type\n@@ -32,7 +32,7 @@ LL |     x\n               found type `UninhabitedStruct`\n \n error[E0308]: mismatched types\n-  --> $DIR/coercions_same_crate.rs:43:5\n+  --> $DIR/coercions_same_crate.rs:42:5\n    |\n LL | fn cannot_coerce_enum_with_empty_variants_to_anything(x: UninhabitedVariants) -> A {\n    |                                                                                  - expected `A` because of return type"}, {"sha": "8f090fe886a00564ddfb51531fd67b01e747deb3", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_same_crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,4 @@\n #![feature(never_type)]\n-#![feature(non_exhaustive)]\n \n #[non_exhaustive]\n pub enum UninhabitedEnum {"}, {"sha": "c03018a523647c29f0c03276ecfcda6c0a99418a", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_same_crate.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,5 @@\n error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedEnum` of type `IndirectUninhabitedEnum` is not handled\n-  --> $DIR/indirect_match_same_crate.rs:35:11\n+  --> $DIR/indirect_match_same_crate.rs:34:11\n    |\n LL | pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n    | ----------------------------------------------------\n@@ -13,7 +13,7 @@ LL |     match x {}\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedStruct` of type `IndirectUninhabitedStruct` is not handled\n-  --> $DIR/indirect_match_same_crate.rs:39:11\n+  --> $DIR/indirect_match_same_crate.rs:38:11\n    |\n LL | pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n    | --------------------------------------------------------\n@@ -27,7 +27,7 @@ LL |     match x {}\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedTupleStruct` of type `IndirectUninhabitedTupleStruct` is not handled\n-  --> $DIR/indirect_match_same_crate.rs:43:11\n+  --> $DIR/indirect_match_same_crate.rs:42:11\n    |\n LL | pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n    | ------------------------------------------------------------------\n@@ -41,7 +41,7 @@ LL |     match x {}\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedVariants` of type `IndirectUninhabitedVariants` is not handled\n-  --> $DIR/indirect_match_same_crate.rs:49:11\n+  --> $DIR/indirect_match_same_crate.rs:48:11\n    |\n LL | pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n    | ------------------------------------------------------------"}, {"sha": "60289aa7803788be6724e7d4b0fc6f7f380b5aa0", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_with_exhaustive_patterns_same_crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns_same_crate.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -3,7 +3,6 @@\n #![deny(unreachable_patterns)]\n #![feature(exhaustive_patterns)]\n #![feature(never_type)]\n-#![feature(non_exhaustive)]\n \n #[non_exhaustive]\n pub enum UninhabitedEnum {"}, {"sha": "230ac75298e726b850eb9d27c918c4e14bf5bdbe", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/issue-65157-repeated-match-arm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,7 +1,6 @@\n // aux-build:uninhabited.rs\n #![deny(unreachable_patterns)]\n #![feature(never_type)]\n-#![feature(non_exhaustive)]\n \n extern crate uninhabited;\n "}, {"sha": "f2b9983af8602a04b039569b2507cc000e2d4005", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/issue-65157-repeated-match-arm.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,5 @@\n error: unreachable pattern\n-  --> $DIR/issue-65157-repeated-match-arm.rs:16:9\n+  --> $DIR/issue-65157-repeated-match-arm.rs:15:9\n    |\n LL |         PartiallyInhabitedVariants::Struct { .. } => {},\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "ebbdfba15f3a3caf7d745f828dd85feed396dcee", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_same_crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,4 @@\n #![feature(never_type)]\n-#![feature(non_exhaustive)]\n \n #[non_exhaustive]\n pub enum UninhabitedEnum {"}, {"sha": "c39df05a8f74ee8a202fa410121421f42cf8acf1", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_same_crate.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,5 @@\n error[E0004]: non-exhaustive patterns: pattern `UninhabitedStruct` of type `UninhabitedStruct` is not handled\n-  --> $DIR/match_same_crate.rs:31:11\n+  --> $DIR/match_same_crate.rs:30:11\n    |\n LL |   pub struct UninhabitedStruct {\n    |   -          ----------------- variant not covered\n@@ -15,7 +15,7 @@ LL |       match x {}\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: pattern `UninhabitedTupleStruct` of type `UninhabitedTupleStruct` is not handled\n-  --> $DIR/match_same_crate.rs:35:11\n+  --> $DIR/match_same_crate.rs:34:11\n    |\n LL | pub struct UninhabitedTupleStruct(!);\n    | -------------------------------------\n@@ -29,7 +29,7 @@ LL |     match x {}\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: multiple patterns of type `UninhabitedVariants` are not handled\n-  --> $DIR/match_same_crate.rs:39:11\n+  --> $DIR/match_same_crate.rs:38:11\n    |\n LL | / pub enum UninhabitedVariants {\n LL | |     #[non_exhaustive] Tuple(!),"}, {"sha": "de5530485f3e69ea31af2d3a4aa10bc493b57f6b", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns_same_crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns_same_crate.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -3,7 +3,6 @@\n #![deny(unreachable_patterns)]\n #![feature(exhaustive_patterns)]\n #![feature(never_type)]\n-#![feature(non_exhaustive)]\n \n #[non_exhaustive]\n pub enum UninhabitedEnum {"}, {"sha": "ffc496a975ecf00b69f0faee7c7a42d807917243", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/patterns_same_crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,7 +1,6 @@\n #![deny(unreachable_patterns)]\n #![feature(exhaustive_patterns)]\n #![feature(never_type)]\n-#![feature(non_exhaustive)]\n \n #[non_exhaustive]\n pub enum UninhabitedEnum {"}, {"sha": "e3de94be1282e4d2511c262eeef595edb43e1b6e", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/patterns_same_crate.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.stderr?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,5 +1,5 @@\n error: unreachable pattern\n-  --> $DIR/patterns_same_crate.rs:53:9\n+  --> $DIR/patterns_same_crate.rs:52:9\n    |\n LL |         Some(_x) => (),\n    |         ^^^^^^^^\n@@ -11,25 +11,25 @@ LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/patterns_same_crate.rs:58:9\n+  --> $DIR/patterns_same_crate.rs:57:9\n    |\n LL |         Some(_x) => (),\n    |         ^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/patterns_same_crate.rs:62:15\n+  --> $DIR/patterns_same_crate.rs:61:15\n    |\n LL |     while let PartiallyInhabitedVariants::Struct { x } = partially_inhabited_variant() {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/patterns_same_crate.rs:66:15\n+  --> $DIR/patterns_same_crate.rs:65:15\n    |\n LL |     while let Some(_x) = uninhabited_struct() {\n    |               ^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/patterns_same_crate.rs:69:15\n+  --> $DIR/patterns_same_crate.rs:68:15\n    |\n LL |     while let Some(_x) = uninhabited_tuple_struct() {\n    |               ^^^^^^^^"}, {"sha": "5f2816ec621022e6468cdd393f865956c8bb01d2", "filename": "src/test/ui/rfc-2008-non-exhaustive/variants_same_crate.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f890f10202a71168c6424da0cdf94135d3c40c/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariants_same_crate.rs?ref=23f890f10202a71168c6424da0cdf94135d3c40c", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(non_exhaustive)]\n-\n pub enum NonExhaustiveVariants {\n     #[non_exhaustive] Unit,\n     #[non_exhaustive] Tuple(u32),"}]}