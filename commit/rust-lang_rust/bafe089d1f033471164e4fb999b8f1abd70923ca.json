{"sha": "bafe089d1f033471164e4fb999b8f1abd70923ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZmUwODlkMWYwMzM0NzExNjRlNGZiOTk5YjhmMWFiZDcwOTIzY2E=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-01-18T01:28:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-18T01:28:12Z"}, "message": "Rollup merge of #68093 - GuillaumeGomez:fix-deref-impl-typedef, r=oli-obk\n\nFix deref impl typedef\n\nFixes #35295.\n\nr? @kinnison", "tree": {"sha": "9412212665e620c0431834aeb961340c9b9da945", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9412212665e620c0431834aeb961340c9b9da945"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bafe089d1f033471164e4fb999b8f1abd70923ca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeIl8tCRBK7hj4Ov3rIwAAdHIIAGTKW4+9+4NhcW+ZHogAEDzH\n6VN8Ug6ebXs7PaMPFb3VZ1319TqcG5CiMfwUpEUG8o4vpD0qWZY+PLZeQ3v/MpXd\nGi31UmPEpAPz2ZDCTibIJcytBkQxyFni+fyBe6En+0Rn6nij9ylUhu6Z0Hh3OBjo\nt9bocjlnfjCpuPKRcg6MZibqX2Qurrfjx+iXXGcIcaxkxl9ID/zEJx6x/1FnRIYl\nGQB/eusuPKVjlXmHejS43lSliHpm2R9boRF2Ra4Uzap54H7/bdLA4VXF83W8zvzO\nk9aPjU6qNRpcR0QMDkDsJilg2w38x+IPkOLeQJpJ0YsqSpnjhArwOLctPVNoqtY=\n=LEGX\n-----END PGP SIGNATURE-----\n", "payload": "tree 9412212665e620c0431834aeb961340c9b9da945\nparent c854aecd629886be7010b99c17f49e0ebf44055e\nparent 482dc77dee59dd44448973758980806bd63aa5a3\nauthor Tyler Mandry <tmandry@gmail.com> 1579310892 -0800\ncommitter GitHub <noreply@github.com> 1579310892 -0800\n\nRollup merge of #68093 - GuillaumeGomez:fix-deref-impl-typedef, r=oli-obk\n\nFix deref impl typedef\n\nFixes #35295.\n\nr? @kinnison\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bafe089d1f033471164e4fb999b8f1abd70923ca", "html_url": "https://github.com/rust-lang/rust/commit/bafe089d1f033471164e4fb999b8f1abd70923ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bafe089d1f033471164e4fb999b8f1abd70923ca/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c854aecd629886be7010b99c17f49e0ebf44055e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c854aecd629886be7010b99c17f49e0ebf44055e", "html_url": "https://github.com/rust-lang/rust/commit/c854aecd629886be7010b99c17f49e0ebf44055e"}, {"sha": "482dc77dee59dd44448973758980806bd63aa5a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/482dc77dee59dd44448973758980806bd63aa5a3", "html_url": "https://github.com/rust-lang/rust/commit/482dc77dee59dd44448973758980806bd63aa5a3"}], "stats": {"total": 126, "additions": 101, "deletions": 25}, "files": [{"sha": "e54e716e042febf9da6468dcaf21c09847fb4308", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bafe089d1f033471164e4fb999b8f1abd70923ca", "patch": "@@ -273,6 +273,22 @@ fn build_type_alias(cx: &DocContext<'_>, did: DefId) -> clean::Typedef {\n     clean::Typedef {\n         type_: cx.tcx.type_of(did).clean(cx),\n         generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n+        item_type: build_type_alias_type(cx, did),\n+    }\n+}\n+\n+fn build_type_alias_type(cx: &DocContext<'_>, did: DefId) -> Option<clean::Type> {\n+    let type_ = cx.tcx.type_of(did).clean(cx);\n+    type_.def_id().and_then(|did| build_ty(cx, did))\n+}\n+\n+pub fn build_ty(cx: &DocContext, did: DefId) -> Option<clean::Type> {\n+    match cx.tcx.def_kind(did)? {\n+        DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::Const | DefKind::Static => {\n+            Some(cx.tcx.type_of(did).clean(cx))\n+        }\n+        DefKind::TyAlias => build_type_alias_type(cx, did),\n+        _ => None,\n     }\n }\n "}, {"sha": "20a5a6c54984d0bed6dd310df67780dbdd35cc8e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bafe089d1f033471164e4fb999b8f1abd70923ca", "patch": "@@ -1122,7 +1122,9 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                 MethodItem((sig, &self.generics, body, Some(self.defaultness)).clean(cx))\n             }\n             hir::ImplItemKind::TyAlias(ref ty) => {\n-                TypedefItem(Typedef { type_: ty.clean(cx), generics: Generics::default() }, true)\n+                let type_ = ty.clean(cx);\n+                let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n+                TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n             }\n             hir::ImplItemKind::OpaqueTy(ref bounds) => OpaqueTyItem(\n                 OpaqueTy { bounds: bounds.clean(cx), generics: Generics::default() },\n@@ -1282,10 +1284,13 @@ impl Clean<Item> for ty::AssocItem {\n \n                     AssocTypeItem(bounds, ty.clean(cx))\n                 } else {\n+                    let type_ = cx.tcx.type_of(self.def_id).clean(cx);\n+                    let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n                     TypedefItem(\n                         Typedef {\n-                            type_: cx.tcx.type_of(self.def_id).clean(cx),\n+                            type_,\n                             generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n+                            item_type,\n                         },\n                         true,\n                     )\n@@ -1989,6 +1994,8 @@ impl Clean<String> for ast::Name {\n \n impl Clean<Item> for doctree::Typedef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n+        let type_ = self.ty.clean(cx);\n+        let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -1997,10 +2004,7 @@ impl Clean<Item> for doctree::Typedef<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: TypedefItem(\n-                Typedef { type_: self.ty.clean(cx), generics: self.gen.clean(cx) },\n-                false,\n-            ),\n+            inner: TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n         }\n     }\n }\n@@ -2101,7 +2105,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             build_deref_target_impls(cx, &items, &mut ret);\n         }\n \n-        let provided = trait_\n+        let provided: FxHashSet<String> = trait_\n             .def_id()\n             .map(|did| {\n                 cx.tcx\n@@ -2112,7 +2116,12 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             })\n             .unwrap_or_default();\n \n-        ret.push(Item {\n+        let for_ = self.for_.clean(cx);\n+        let type_alias = for_.def_id().and_then(|did| match cx.tcx.def_kind(did) {\n+            Some(DefKind::TyAlias) => Some(cx.tcx.type_of(did).clean(cx)),\n+            _ => None,\n+        });\n+        let make_item = |trait_: Option<Type>, for_: Type, items: Vec<Item>| Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n@@ -2123,15 +2132,19 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             inner: ImplItem(Impl {\n                 unsafety: self.unsafety,\n                 generics: self.generics.clean(cx),\n-                provided_trait_methods: provided,\n+                provided_trait_methods: provided.clone(),\n                 trait_,\n-                for_: self.for_.clean(cx),\n+                for_,\n                 items,\n                 polarity: Some(cx.tcx.impl_polarity(def_id).clean(cx)),\n                 synthetic: false,\n                 blanket_impl: None,\n             }),\n-        });\n+        };\n+        if let Some(type_alias) = type_alias {\n+            ret.push(make_item(trait_.clone(), type_alias, items.clone()));\n+        }\n+        ret.push(make_item(trait_, for_, items));\n         ret\n     }\n }"}, {"sha": "79a078ca7a991abdaf58ccdf8728d6e22b466fbf", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=bafe089d1f033471164e4fb999b8f1abd70923ca", "patch": "@@ -1406,6 +1406,14 @@ pub struct PathSegment {\n pub struct Typedef {\n     pub type_: Type,\n     pub generics: Generics,\n+    // Type of target item.\n+    pub item_type: Option<Type>,\n+}\n+\n+impl GetDefId for Typedef {\n+    fn def_id(&self) -> Option<DefId> {\n+        self.type_.def_id()\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "9406803825350e82abb50b9987f47f73dfc8dbc2", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=bafe089d1f033471164e4fb999b8f1abd70923ca", "patch": "@@ -3469,20 +3469,23 @@ fn render_deref_methods(\n     deref_mut: bool,\n ) {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n-    let target = impl_\n+    let (target, real_target) = impl_\n         .inner_impl()\n         .items\n         .iter()\n         .filter_map(|item| match item.inner {\n-            clean::TypedefItem(ref t, true) => Some(&t.type_),\n+            clean::TypedefItem(ref t, true) => Some(match *t {\n+                clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n+                _ => (&t.type_, &t.type_),\n+            }),\n             _ => None,\n         })\n         .next()\n         .expect(\"Expected associated type binding\");\n     let what =\n-        AssocItemRender::DerefFor { trait_: deref_type, type_: target, deref_mut_: deref_mut };\n+        AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n     if let Some(did) = target.def_id() {\n-        render_assoc_items(w, cx, container_item, did, what)\n+        render_assoc_items(w, cx, container_item, did, what);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n             if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n@@ -4123,12 +4126,15 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                 .filter(|i| i.inner_impl().trait_.is_some())\n                 .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n             {\n-                if let Some(target) = impl_\n+                if let Some((target, real_target)) = impl_\n                     .inner_impl()\n                     .items\n                     .iter()\n                     .filter_map(|item| match item.inner {\n-                        clean::TypedefItem(ref t, true) => Some(&t.type_),\n+                        clean::TypedefItem(ref t, true) => Some(match *t {\n+                            clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n+                            _ => (&t.type_, &t.type_),\n+                        }),\n                         _ => None,\n                     })\n                     .next()\n@@ -4147,7 +4153,7 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                                 \"{:#}\",\n                                 impl_.inner_impl().trait_.as_ref().unwrap().print()\n                             )),\n-                            Escape(&format!(\"{:#}\", target.print()))\n+                            Escape(&format!(\"{:#}\", real_target.print()))\n                         ));\n                         out.push_str(\"</a>\");\n                         let mut ret = impls"}, {"sha": "f1f83acdda59e81cb16f0593ae59ea5b5970a684", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=bafe089d1f033471164e4fb999b8f1abd70923ca", "patch": "@@ -277,7 +277,7 @@ impl DocFolder for Cache {\n                 | clean::StructFieldItem(..)\n                 | clean::VariantItem(..) => (\n                     (\n-                        Some(*self.parent_stack.last().unwrap()),\n+                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n                         Some(&self.stack[..self.stack.len() - 1]),\n                     ),\n                     false,\n@@ -286,7 +286,7 @@ impl DocFolder for Cache {\n                     if self.parent_stack.is_empty() {\n                         ((None, None), false)\n                     } else {\n-                        let last = self.parent_stack.last().unwrap();\n+                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n                         let did = *last;\n                         let path = match self.paths.get(&did) {\n                             // The current stack not necessarily has correlation\n@@ -468,7 +468,7 @@ impl DocFolder for Cache {\n                         self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n                     }\n                 } else {\n-                    let trait_did = impl_item.trait_did().unwrap();\n+                    let trait_did = impl_item.trait_did().expect(\"no trait did\");\n                     self.orphan_trait_impls.push((trait_did, dids, impl_item));\n                 }\n                 None\n@@ -478,10 +478,10 @@ impl DocFolder for Cache {\n         });\n \n         if pushed {\n-            self.stack.pop().unwrap();\n+            self.stack.pop().expect(\"stack already empty\");\n         }\n         if parent_pushed {\n-            self.parent_stack.pop().unwrap();\n+            self.parent_stack.pop().expect(\"parent stack already empty\");\n         }\n         self.stripped_mod = orig_stripped_mod;\n         self.parent_is_trait_impl = orig_parent_is_trait_impl;\n@@ -594,7 +594,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     for item in search_index {\n         item.parent_idx = item.parent.map(|nodeid| {\n             if nodeid_to_pathid.contains_key(&nodeid) {\n-                *nodeid_to_pathid.get(&nodeid).unwrap()\n+                *nodeid_to_pathid.get(&nodeid).expect(\"no pathid\")\n             } else {\n                 let pathid = lastpathid;\n                 nodeid_to_pathid.insert(nodeid, pathid);\n@@ -639,7 +639,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n             items: crate_items,\n             paths: crate_paths,\n         })\n-        .unwrap()\n+        .expect(\"failed serde conversion\")\n     )\n }\n "}, {"sha": "770f8d7289c3bb2ce26a7c3698f6999a9afc7cc3", "filename": "src/test/rustdoc/deref-typedef.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bafe089d1f033471164e4fb999b8f1abd70923ca/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-typedef.rs?ref=bafe089d1f033471164e4fb999b8f1abd70923ca", "patch": "@@ -0,0 +1,33 @@\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/struct.Bar.html'\n+// @has '-' '//*[@id=\"deref-methods\"]' 'Methods from Deref<Target = FooC>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_a\"]' 'pub fn foo_a(&self)'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_b\"]' 'pub fn foo_b(&self)'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_c\"]' 'pub fn foo_c(&self)'\n+// @has '-' '//*[@class=\"sidebar-title\"]' 'Methods from Deref<Target=FooC>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_a\"]' 'foo_a'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_b\"]' 'foo_b'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_c\"]' 'foo_c'\n+\n+pub struct FooA;\n+pub type FooB = FooA;\n+pub type FooC = FooB;\n+\n+impl FooA {\n+    pub fn foo_a(&self) {}\n+}\n+\n+impl FooB {\n+    pub fn foo_b(&self) {}\n+}\n+\n+impl FooC {\n+    pub fn foo_c(&self) {}\n+}\n+\n+pub struct Bar;\n+impl std::ops::Deref for Bar {\n+    type Target = FooC;\n+    fn deref(&self) -> &Self::Target { unimplemented!() }\n+}"}]}