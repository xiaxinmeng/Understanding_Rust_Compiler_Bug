{"sha": "7595aca5e3254d7b0e93f2599ce477984acadfef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1OTVhY2E1ZTMyNTRkN2IwZTkzZjI1OTljZTQ3Nzk4NGFjYWRmZWY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-04T07:27:36Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-04T07:27:36Z"}, "message": "Kill the preallocator, install a sane replacement. Closes #131. And probably a lot of others.", "tree": {"sha": "cd48a904d7fa1a0560765df0a4c12021d9d8e2b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd48a904d7fa1a0560765df0a4c12021d9d8e2b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7595aca5e3254d7b0e93f2599ce477984acadfef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7595aca5e3254d7b0e93f2599ce477984acadfef", "html_url": "https://github.com/rust-lang/rust/commit/7595aca5e3254d7b0e93f2599ce477984acadfef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7595aca5e3254d7b0e93f2599ce477984acadfef/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22c07762470d6f90ba08ae6b5860fe9bd9116ebc", "url": "https://api.github.com/repos/rust-lang/rust/commits/22c07762470d6f90ba08ae6b5860fe9bd9116ebc", "html_url": "https://github.com/rust-lang/rust/commit/22c07762470d6f90ba08ae6b5860fe9bd9116ebc"}], "stats": {"total": 386, "additions": 123, "deletions": 263}, "files": [{"sha": "347d49fc24b4c66896f0eeeaa0841a1aa68fe6bc", "filename": "src/boot/be/abi.ml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7595aca5e3254d7b0e93f2599ce477984acadfef/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/7595aca5e3254d7b0e93f2599ce477984acadfef/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=7595aca5e3254d7b0e93f2599ce477984acadfef", "patch": "@@ -107,14 +107,13 @@ type abi =\n     abi_word_bits: Il.bits;\n     abi_word_ty: Common.ty_mach;\n \n-    abi_is_2addr_machine: bool;\n     abi_has_pcrel_data: bool;\n     abi_has_pcrel_code: bool;\n \n     abi_n_hardregs: int;\n     abi_str_of_hardreg: (int -> string);\n \n-    abi_prealloc_quad: (Il.quad' -> Il.quad');\n+    abi_emit_target_specific: (Il.emitter -> Il.quad -> unit);\n     abi_constrain_vregs: (Il.quad -> Bits.t array -> unit);\n \n     abi_emit_fn_prologue: (Il.emitter"}, {"sha": "792e83e200ad76e3075f11e6ec36af3a6242e124", "filename": "src/boot/be/il.ml", "status": "modified", "additions": 21, "deletions": 212, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/7595aca5e3254d7b0e93f2599ce477984acadfef/src%2Fboot%2Fbe%2Fil.ml", "raw_url": "https://github.com/rust-lang/rust/raw/7595aca5e3254d7b0e93f2599ce477984acadfef/src%2Fboot%2Fbe%2Fil.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fil.ml?ref=7595aca5e3254d7b0e93f2599ce477984acadfef", "patch": "@@ -692,8 +692,7 @@ let string_of_quad (f:hreg_formatter) (q:quad) : string =\n type emitter = { mutable emit_pc: int;\n                  mutable emit_next_vreg: int option;\n                  mutable emit_next_spill: int;\n-                 emit_preallocator: (quad' -> quad');\n-                 emit_is_2addr: bool;\n+                 emit_target_specific: (emitter -> quad -> unit);\n                  mutable emit_quads: quads;\n                  emit_annotations: (int,string) Hashtbl.t;\n                  emit_size_cache: ((size,operand) Hashtbl.t) Stack.t;\n@@ -712,17 +711,15 @@ let deadq = { quad_fixup = None;\n \n \n let new_emitter\n-    (preallocator:quad' -> quad')\n-    (is_2addr:bool)\n+    (emit_target_specific:emitter -> quad -> unit)\n     (vregs_ok:bool)\n     (node:node_id option)\n     : emitter =\n   {\n     emit_pc = 0;\n     emit_next_vreg = (if vregs_ok then Some 0 else None);\n     emit_next_spill = 0;\n-    emit_preallocator = preallocator;\n-    emit_is_2addr = is_2addr;\n+    emit_target_specific = emit_target_specific;\n     emit_quads = Array.create 4 badq;\n     emit_annotations = Hashtbl.create 0;\n     emit_size_cache = Stack.create ();\n@@ -837,218 +834,30 @@ let append_quad\n   e.emit_pc <- e.emit_pc + 1\n ;;\n \n+let default_mov q' =\n+  match q' with\n+      Binary b ->\n+        begin\n+          match b.binary_op with\n+              IDIV | IMUL | IMOD -> IMOV\n+            | _ -> UMOV\n+        end\n+    | Unary u ->\n+        begin\n+          match u.unary_op with\n+              IMOV -> IMOV\n+            | _ -> UMOV\n+        end\n+    | _ -> UMOV\n+;;\n \n let emit_full\n     (e:emitter)\n     (fix:fixup option)\n     (q':quad')\n     : unit =\n-  let fixup = ref fix in\n-  let emit_quad_bottom q' =\n-    append_quad e { quad_body = q';\n-                    quad_fixup = (!fixup) };\n-    fixup := None;\n-  in\n-\n-  let emit_quad (q':quad') : unit =\n-    (* re-decay any freshly generated mem-mem movs. *)\n-    match q' with\n-        Unary { unary_dst = Mem (dst_mem, ScalarTy src_st);\n-                unary_src = Cell (Mem (src_mem, ScalarTy dst_st));\n-                unary_op = op }\n-          when is_mov op ->\n-            let v = next_vreg_cell e dst_st in\n-              emit_quad_bottom\n-                (unary op v (Cell (Mem (src_mem, ScalarTy src_st))));\n-              emit_quad_bottom\n-                (unary op (Mem (dst_mem, ScalarTy dst_st)) (Cell v))\n-      | _ -> emit_quad_bottom q'\n-  in\n-\n-  let default_mov =\n-    match q' with\n-        Binary b ->\n-          begin\n-            match b.binary_op with\n-                IDIV | IMUL | IMOD -> IMOV\n-              | _ -> UMOV\n-          end\n-      | Unary u ->\n-          begin\n-            match u.unary_op with\n-                IMOV -> IMOV\n-              | _ -> UMOV\n-          end\n-      | _ -> UMOV\n-  in\n-\n-  let emit_mov (dst:cell) (src:operand) : unit =\n-    emit_quad (unary default_mov dst src)\n-  in\n-\n-  let mov_if_operands_differ\n-      (old_op:operand) (new_op:operand)\n-      : unit =\n-    if (new_op <> old_op)\n-    then\n-      match new_op with\n-          (Cell new_cell) ->\n-            emit_mov new_cell old_op\n-        | _ -> ()\n-  in\n-\n-  let mov_if_two_operands_differ\n-      (old_lhs_op:operand) (new_lhs_op:operand)\n-      (old_rhs_op:operand) (new_rhs_op:operand)\n-      : unit =\n-    (*\n-     * This is sufficiently obscure that it deserves an explanation.\n-     * \n-     * The main idea here is to do two \"mov_if_operands_differ\" calls,\n-     * such as one might have when setting up a binary quad.\n-     * \n-     * The problem comes when you happen to hit a case like X86 div,\n-     * which preallocates *both* operands. Preallocating both means we\n-     * have to potentially issue two movs into the preallocated regs,\n-     * and the second of those movs might be a problem. Specifically:\n-     * the second mov-to-prealloc might make be moving from a\n-     * register-indirect mem cell based on a vreg, and that vreg may\n-     * wind up being assigned to an hreg that we just loaded with the\n-     * first mov. In other words, the second mov may retask the\n-     * preallocated hreg we set up in the first mov.\n-     * \n-     * You laugh, but of course this actually happens.\n-     * \n-     * So here we do a conservative thing and check to see if either\n-     * operand is memory-indirect at all. If either is, then for either\n-     * of the 'old' operands we're *about* to mov into a prealloc reg,\n-     * we first bounce them off a spill slot. Spill slots, thankfully,\n-     * we can always count on being able to address irrespective of the\n-     * opinions of the RA, as they are all just fp-relative.\n-     * \n-     * A slightly more aggressive version of this would only bounce\n-     * cases that are not fp-relative already, though doing so would\n-     * require threading the notion of what fp *is* through to\n-     * here. Possibly tighten this up in the future (or just\n-     * ... destroy this backend ASAP).\n-     * \n-     *)\n-    let has_reg_indirect op =\n-      match op with\n-          Cell (Mem _) -> true\n-        | _ -> false\n-    in\n-    let either_old_op_has_reg_indirect =\n-      (has_reg_indirect old_lhs_op) || (has_reg_indirect old_rhs_op)\n-    in\n-    let old_lhs_op =\n-      if either_old_op_has_reg_indirect && (new_lhs_op <> old_lhs_op)\n-      then\n-        let tmp =\n-          Mem (next_spill_slot e\n-                 (ScalarTy (operand_scalar_ty old_lhs_op)))\n-        in\n-          emit_mov tmp old_lhs_op;\n-          Cell tmp\n-      else\n-        old_lhs_op\n-    in\n-    let old_rhs_op =\n-      if either_old_op_has_reg_indirect && (new_rhs_op <> old_rhs_op)\n-      then\n-        let tmp =\n-          Mem (next_spill_slot e\n-                 (ScalarTy (operand_scalar_ty old_rhs_op)))\n-        in\n-          emit_mov tmp old_rhs_op;\n-          Cell tmp\n-      else\n-        old_rhs_op\n-    in\n-      mov_if_operands_differ old_lhs_op new_lhs_op;\n-      mov_if_operands_differ old_rhs_op new_rhs_op;\n-  in\n-\n-  let mov_if_cells_differ (old_cell:cell) (new_cell:cell) : unit =\n-    if not (new_cell = old_cell)\n-    then\n-      emit_mov old_cell (Cell new_cell)\n-  in\n-\n-  let emit_decayed_quad q' =\n-    match (q', e.emit_preallocator q') with\n-        (Binary b, Binary b') ->\n-          begin\n-            mov_if_two_operands_differ\n-              b.binary_lhs b'.binary_lhs\n-              b.binary_rhs b'.binary_rhs;\n-            if e.emit_is_2addr &&\n-              (not (b'.binary_lhs = (Cell b'.binary_dst)))\n-            then\n-              begin\n-                emit_mov b'.binary_dst b'.binary_lhs;\n-                emit_quad (Binary { b' with\n-                                      binary_lhs = (Cell b'.binary_dst) })\n-              end\n-            else\n-              emit_quad (Binary b');\n-            mov_if_cells_differ b.binary_dst b'.binary_dst\n-          end\n-\n-      | (Unary u, Unary u') ->\n-          mov_if_operands_differ u.unary_src u'.unary_src;\n-          (* Assume '2addr' means '1addr' for unary ops. *)\n-          if e.emit_is_2addr &&\n-            (u'.unary_op = NEG || u'.unary_op = NOT) &&\n-            (not (u'.unary_src = (Cell u'.unary_dst)))\n-            then\n-              begin\n-                emit_mov u'.unary_dst u'.unary_src;\n-                emit_quad (Unary { u' with unary_src = (Cell u'.unary_dst) })\n-              end\n-            else\n-              emit_quad (Unary u');\n-          mov_if_cells_differ u.unary_dst u'.unary_dst\n-\n-      | (Cmp c, Cmp c') ->\n-          mov_if_two_operands_differ\n-            c.cmp_lhs c'.cmp_lhs\n-            c.cmp_rhs c'.cmp_rhs;\n-          emit_quad (Cmp c');\n-\n-      | (Push op, Push op') ->\n-          mov_if_operands_differ op op';\n-          emit_quad (Push op');\n-\n-      | (Pop c, Pop c') ->\n-          emit_quad (Pop c');\n-          mov_if_cells_differ c c'\n-\n-      | (Call c, Call c') ->\n-          emit_quad (Call c');\n-          mov_if_cells_differ c.call_dst c'.call_dst\n-\n-      | (Lea lea, Lea lea') ->\n-          emit_quad (Lea lea');\n-          mov_if_cells_differ lea.lea_dst lea'.lea_dst\n-\n-      | (x, y) ->\n-          assert (x = y);\n-          emit_quad x\n-  in\n-\n-    (* pre-decay mem-mem movs. *)\n-    match q' with\n-        Unary { unary_dst = Mem (dst_mem, ScalarTy src_st);\n-                unary_src = Cell (Mem (src_mem, ScalarTy dst_st));\n-                unary_op = op }\n-          when is_mov op ->\n-            let v = next_vreg_cell e dst_st in\n-              emit_decayed_quad\n-                (unary op v (Cell (Mem (src_mem, ScalarTy src_st))));\n-              emit_decayed_quad\n-                (unary op (Mem (dst_mem, ScalarTy dst_st)) (Cell v))\n-      | _ -> emit_decayed_quad q'\n+  e.emit_target_specific e { quad_body = q';\n+                             quad_fixup = fix }\n ;;\n \n let emit (e:emitter) (q':quad') : unit ="}, {"sha": "217149c74f3616beaa95cedd07b1ec01c68380f1", "filename": "src/boot/be/x86.ml", "status": "modified", "additions": 93, "deletions": 47, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/7595aca5e3254d7b0e93f2599ce477984acadfef/src%2Fboot%2Fbe%2Fx86.ml", "raw_url": "https://github.com/rust-lang/rust/raw/7595aca5e3254d7b0e93f2599ce477984acadfef/src%2Fboot%2Fbe%2Fx86.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fx86.ml?ref=7595aca5e3254d7b0e93f2599ce477984acadfef", "patch": "@@ -256,63 +256,111 @@ let is_rm8 (c:Il.cell) : bool =\n     | _ -> is_r8 c\n ;;\n \n-let prealloc_quad (quad':Il.quad') : Il.quad' =\n-  let target_cell reg c =\n-    Il.Reg (Il.Hreg reg, Il.cell_scalar_ty c)\n+\n+let emit_target_specific\n+    (e:Il.emitter)\n+    (q:Il.quad)\n+    : unit =\n+  let fixup = ref q.Il.quad_fixup in\n+  let put q' =\n+    Il.append_quad e { Il.quad_body = q';\n+                       Il.quad_fixup = (!fixup) };\n+    fixup := None;\n   in\n-  let target_operand reg op =\n-    Il.Cell (Il.Reg (Il.Hreg reg, Il.operand_scalar_ty op))\n+  let op_vreg op =\n+    Il.next_vreg_cell e (Il.operand_scalar_ty op)\n   in\n-\n-  let target_bin_to_hreg bin dst src =\n-    { bin with\n-        Il.binary_rhs = target_operand src bin.Il.binary_rhs;\n-        Il.binary_lhs = target_operand dst bin.Il.binary_lhs;\n-        Il.binary_dst = target_cell dst bin.Il.binary_dst }\n+  let cell_vreg cell = op_vreg (Il.Cell cell) in\n+  let mem_vreg mem = cell_vreg (Il.Mem mem) in\n+  let movop = Il.default_mov q.Il.quad_body in\n+  let mov dst src =\n+    (* Decay mem-mem moves to use a vreg. *)\n+    match dst, src with\n+        Il.Mem dm, Il.Cell (Il.Mem _) ->\n+          let v = mem_vreg dm in\n+            put (Il.unary movop v src);\n+            put (Il.unary movop dst (Il.Cell v))\n+      | _ -> put (Il.unary movop dst src)\n   in\n \n-  let target_cmp cmp =\n-    match cmp.Il.cmp_lhs with\n-        (* Immediate LHS we force to eax. *)\n-        Il.Imm _ ->\n-          { cmp with\n-              Il.cmp_lhs = target_operand eax cmp.Il.cmp_lhs }\n-      | _ -> cmp\n+  let hr_like_op hr op =\n+    Il.Reg (Il.Hreg hr, Il.operand_scalar_ty op)\n   in\n-\n-    match quad' with\n-        Il.Binary bin ->\n+  let hr_like_cell hr c = hr_like_op hr (Il.Cell c) in\n+  let q = q.Il.quad_body in\n+\n+    match q with\n+        Il.Binary ({ Il.binary_op = op;\n+                     Il.binary_dst = dst;\n+                     Il.binary_lhs = lhs;\n+                     Il.binary_rhs = rhs; } as b) ->\n           begin\n-            Il.Binary\n-              begin\n-                match bin.Il.binary_op with\n-                    Il.IMUL | Il.UMUL\n-                  | Il.IDIV | Il.UDIV -> target_bin_to_hreg bin eax ecx\n-                  | Il.IMOD | Il.UMOD -> target_bin_to_hreg bin eax ecx\n-                  | _ -> bin\n-              end\n+            match op with\n+\n+                Il.IMUL | Il.UMUL\n+              | Il.IDIV | Il.UDIV\n+              | Il.IMOD | Il.UMOD ->\n+                  let dst_eax = hr_like_cell eax dst in\n+                  let lhs_eax = hr_like_op eax lhs in\n+                  let rhs_ecx = hr_like_op ecx lhs in\n+                    if lhs <> (Il.Cell lhs_eax)\n+                    then mov lhs_eax lhs;\n+                    if rhs <> (Il.Cell rhs_ecx)\n+                    then mov rhs_ecx rhs;\n+                    put (Il.Binary\n+                           { b with\n+                               Il.binary_lhs = (Il.Cell lhs_eax);\n+                               Il.binary_rhs = (Il.Cell rhs_ecx);\n+                               Il.binary_dst = dst_eax; });\n+                    if dst <> dst_eax\n+                    then mov dst (Il.Cell dst_eax);\n+\n+              | _ when (Il.Cell dst) <> lhs ->\n+                  mov dst lhs;\n+                  put (Il.Binary\n+                         { b with Il.binary_lhs = Il.Cell dst })\n+\n+              | _ -> put q\n           end\n \n-      | Il.Cmp cmp -> Il.Cmp (target_cmp cmp)\n+      | Il.Unary ({ Il.unary_op = op;\n+                    Il.unary_dst = dst;\n+                    Il.unary_src = src; } as u) ->\n+          begin\n+            match op with\n \n-      | Il.Call c ->\n-          let ty = Il.cell_scalar_ty c.Il.call_dst in\n-            Il.Call { c with\n-                        Il.call_dst = Il.Reg ((Il.Hreg eax), ty) }\n+                Il.UMOV | Il.IMOV ->\n+                  mov dst src\n \n-      | Il.Lea le ->\n-          begin\n-            match (le.Il.lea_dst, le.Il.lea_src) with\n-                (Il.Reg (_, dst_ty), Il.ImmPtr _)\n-                  when is_ty32 dst_ty ->\n-                    Il.Lea { le with\n-                               Il.lea_dst = Il.Reg (Il.Hreg eax, dst_ty) }\n-              | _ -> quad'\n+              (* x86 can only NEG or NOT in-place. *)\n+              | Il.NEG | Il.NOT when (Il.Cell dst) <> src ->\n+                  mov dst src;\n+                  put (Il.Unary { u with Il.unary_src = Il.Cell dst })\n+\n+              | _ -> put q\n           end\n \n-      | x -> x\n+      | Il.Call c ->\n+          let dst_eax = hr_like_cell eax c.Il.call_dst in\n+            put (Il.Call { c with Il.call_dst = dst_eax });\n+            if c.Il.call_dst <> dst_eax\n+            then mov c.Il.call_dst (Il.Cell dst_eax)\n+\n+      (* \n+       * For the get-next-pc thunk hack to work, we need to lea an immptr\n+       * to eax, always.\n+       *)\n+      | Il.Lea ({ Il.lea_dst = dst;\n+                  Il.lea_src = Il.ImmPtr _  } as lea) ->\n+          let eax_dst = hr_like_cell eax dst in\n+            put (Il.Lea { lea with Il.lea_dst = eax_dst });\n+            if dst <> eax_dst\n+            then mov dst (Il.Cell eax_dst);\n+\n+      | q -> put q\n ;;\n \n+\n let constrain_vregs (q:Il.quad) (hregs:Bits.t array) : unit =\n \n   let involves_8bit_cell =\n@@ -1640,13 +1688,12 @@ let (abi:Abi.abi) =\n     Abi.abi_word_bits = word_bits;\n     Abi.abi_word_ty = word_ty;\n \n-    Abi.abi_is_2addr_machine = true;\n     Abi.abi_has_pcrel_data = false;\n     Abi.abi_has_pcrel_code = true;\n \n     Abi.abi_n_hardregs = n_hardregs;\n     Abi.abi_str_of_hardreg = reg_str;\n-    Abi.abi_prealloc_quad = prealloc_quad;\n+    Abi.abi_emit_target_specific = emit_target_specific;\n     Abi.abi_constrain_vregs = constrain_vregs;\n \n     Abi.abi_emit_fn_prologue = fn_prologue;\n@@ -2291,8 +2338,7 @@ let select_insn (q:Il.quad) : Asm.frag =\n \n let new_emitter_without_vregs _ : Il.emitter =\n   Il.new_emitter\n-    abi.Abi.abi_prealloc_quad\n-    abi.Abi.abi_is_2addr_machine\n+    abi.Abi.abi_emit_target_specific\n     false None\n ;;\n "}, {"sha": "f2bb228730933851938378f0959471f98290a2ea", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7595aca5e3254d7b0e93f2599ce477984acadfef/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/7595aca5e3254d7b0e93f2599ce477984acadfef/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=7595aca5e3254d7b0e93f2599ce477984acadfef", "patch": "@@ -160,8 +160,7 @@ let trans_visitor\n   let emitters = Stack.create () in\n   let push_new_emitter (vregs_ok:bool) (fnid:node_id option) =\n     let e = Il.new_emitter\n-         abi.Abi.abi_prealloc_quad\n-         abi.Abi.abi_is_2addr_machine\n+         abi.Abi.abi_emit_target_specific\n          vregs_ok fnid\n     in\n       Stack.push (Hashtbl.create 0) e.Il.emit_size_cache;"}, {"sha": "588148bb81fbfc1eb8ccd6607f745fdbf7aa5e56", "filename": "src/test/run-pass/arithmetic-interference.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7595aca5e3254d7b0e93f2599ce477984acadfef/src%2Ftest%2Frun-pass%2Farithmetic-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7595aca5e3254d7b0e93f2599ce477984acadfef/src%2Ftest%2Frun-pass%2Farithmetic-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farithmetic-interference.rs?ref=7595aca5e3254d7b0e93f2599ce477984acadfef", "patch": "@@ -0,0 +1,7 @@\n+// Testcase for issue #131.\n+\n+fn main() -> () {\n+  let int a = 10;\n+  log a;\n+  check (a * (a - 1) == 90);\n+}"}]}