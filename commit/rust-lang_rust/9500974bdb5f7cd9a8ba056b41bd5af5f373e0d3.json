{"sha": "9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1MDA5NzRiZGI1ZjdjZDlhOGJhMDU2YjQxYmQ1YWY1ZjM3M2UwZDM=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-08-09T18:18:53Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-08-14T23:49:57Z"}, "message": "Fix tracking of which locals would need to be captured in a closure.\n* Captures by sub closures are now considered\n* Copy types are correctly borrowed by reference when their value is used\n* Fields are no longer automatically borrowed by value\n* Bindings in `match` and `let` patterns are now checked to determine how a local is captured", "tree": {"sha": "9dea0dad5176a564bf1a90b02a05f42b49b730bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dea0dad5176a564bf1a90b02a05f42b49b730bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmEYVqoACgkQ2lnoZDo37Qa17AEAjosnQpciYPlm0u+nhX62mVio\ndO0ubF1HLIcZGsYf+lcA+gIMRrbmQ7BZJpi0nPNhSfn06ZHt5YrfzU5e8BN/2NkL\n=oacm\n-----END PGP SIGNATURE-----", "payload": "tree 9dea0dad5176a564bf1a90b02a05f42b49b730bb\nparent 251dd30d77c98cbebd1c68840fce029affe9b6a8\nauthor Jason Newcomb <jsnewcomb@pm.me> 1628533133 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1628984997 -0400\n\nFix tracking of which locals would need to be captured in a closure.\n* Captures by sub closures are now considered\n* Copy types are correctly borrowed by reference when their value is used\n* Fields are no longer automatically borrowed by value\n* Bindings in `match` and `let` patterns are now checked to determine how a local is captured\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3", "html_url": "https://github.com/rust-lang/rust/commit/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "251dd30d77c98cbebd1c68840fce029affe9b6a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/251dd30d77c98cbebd1c68840fce029affe9b6a8", "html_url": "https://github.com/rust-lang/rust/commit/251dd30d77c98cbebd1c68840fce029affe9b6a8"}], "stats": {"total": 189, "additions": 176, "deletions": 13}, "files": [{"sha": "eb9ad04527f425944fd29931c4156742acf03628", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 84, "deletions": 11, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3", "patch": "@@ -62,7 +62,7 @@ use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n \n use if_chain::if_chain;\n-use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind};\n+use rustc_ast::ast::{self, Attribute, LitKind};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -78,9 +78,11 @@ use rustc_hir::{\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::hir::map::Map;\n+use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::ty as rustc_ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n-use rustc_middle::ty::{layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable};\n+use rustc_middle::ty::binding::BindingMode;\n+use rustc_middle::ty::{layout::IntegerExt, BorrowKind, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable, UpvarCapture};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -91,7 +93,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n-use crate::ty::{can_partially_move_ty, is_recursively_primitive_type};\n+use crate::ty::{can_partially_move_ty, is_copy, is_recursively_primitive_type};\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -628,6 +630,11 @@ pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -\n }\n \n /// Checks if the top level expression can be moved into a closure as is.\n+/// Currently checks for:\n+/// * Break/Continue outside the given jump targets\n+/// * Yield/Return statments.\n+/// * Inline assembly\n+/// * Usages of a field of a local where the type of the local can be partially moved.\n pub fn can_move_expr_to_closure_no_visit(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n@@ -699,6 +706,22 @@ impl std::ops::BitOrAssign for CaptureKind {\n /// only be used while making a closure somewhere a value is consumed. e.g. a block, match arm, or\n /// function argument (other than a receiver).\n pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind {\n+    fn pat_capture_kind(cx: &LateContext<'_>, pat: &Pat<'_>) -> CaptureKind {\n+        let mut capture = CaptureKind::Ref(Mutability::Not);\n+        pat.each_binding(|_, id, span, _| {\n+            match cx.typeck_results().extract_binding_mode(cx.sess(), id, span).unwrap() {\n+                BindingMode::BindByValue(_) if !is_copy(cx, cx.typeck_results().node_type(id)) => {\n+                    capture = CaptureKind::Value;\n+                },\n+                BindingMode::BindByReference(Mutability::Mut) if capture != CaptureKind::Value => {\n+                    capture = CaptureKind::Ref(Mutability::Mut);\n+                },\n+                _ => (),\n+            }\n+        });\n+        capture\n+    }\n+\n     debug_assert!(matches!(\n         e.kind,\n         ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(_), .. }))\n@@ -707,6 +730,7 @@ pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind\n     let map = cx.tcx.hir();\n     let mut child_id = e.hir_id;\n     let mut capture = CaptureKind::Value;\n+    let mut capture_expr_ty = e;\n \n     for (parent_id, parent) in map.parent_iter(e.hir_id) {\n         if let [Adjustment {\n@@ -725,23 +749,47 @@ pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind\n             }\n         }\n \n-        if let Node::Expr(e) = parent {\n-            match e.kind {\n+        match parent {\n+            Node::Expr(e) => match e.kind {\n                 ExprKind::AddrOf(_, mutability, _) => return CaptureKind::Ref(mutability),\n                 ExprKind::Index(..) | ExprKind::Unary(UnOp::Deref, _) => capture = CaptureKind::Ref(Mutability::Not),\n                 ExprKind::Assign(lhs, ..) | ExprKind::Assign(_, lhs, _) if lhs.hir_id == child_id => {\n                     return CaptureKind::Ref(Mutability::Mut);\n                 },\n+                ExprKind::Field(..) => {\n+                    if capture == CaptureKind::Value {\n+                        capture_expr_ty = e;\n+                    }\n+                },\n+                ExprKind::Match(_, arms, _) => {\n+                    let mut mutability = Mutability::Not;\n+                    for capture in arms.iter().map(|arm| pat_capture_kind(cx, arm.pat)) {\n+                        match capture {\n+                            CaptureKind::Value => break,\n+                            CaptureKind::Ref(Mutability::Mut) => mutability = Mutability::Mut,\n+                            CaptureKind::Ref(Mutability::Not) => (),\n+                        }\n+                    }\n+                    return CaptureKind::Ref(mutability);\n+                },\n                 _ => break,\n-            }\n-        } else {\n-            break;\n+            },\n+            Node::Local(l) => match pat_capture_kind(cx, l.pat) {\n+                CaptureKind::Value => break,\n+                capture @ CaptureKind::Ref(_) => return capture,\n+            },\n+            _ => break,\n         }\n \n         child_id = parent_id;\n     }\n \n-    capture\n+    if capture == CaptureKind::Value && is_copy(cx, cx.typeck_results().expr_ty(capture_expr_ty)) {\n+        // Copy types are never automatically captured by value.\n+        CaptureKind::Ref(Mutability::Not)\n+    } else {\n+        capture\n+    }\n }\n \n /// Checks if the expression can be moved into a closure as is. This will return a list of captures\n@@ -777,6 +825,31 @@ pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n                         self.captures.entry(l).and_modify(|e| *e |= cap).or_insert(cap);\n                     }\n                 },\n+                ExprKind::Closure(..) => {\n+                    let closure_id = self.cx.tcx.hir().local_def_id(e.hir_id).to_def_id();\n+                    for capture in self.cx.typeck_results().closure_min_captures_flattened(closure_id) {\n+                        let local_id = match capture.place.base {\n+                            PlaceBase::Local(id) => id,\n+                            PlaceBase::Upvar(var) => var.var_path.hir_id,\n+                            _ => continue,\n+                        };\n+                        if !self.locals.contains(&local_id) {\n+                            let capture = match capture.info.capture_kind {\n+                                UpvarCapture::ByValue(_) => CaptureKind::Value,\n+                                UpvarCapture::ByRef(borrow) => match borrow.kind {\n+                                    BorrowKind::ImmBorrow => CaptureKind::Ref(Mutability::Not),\n+                                    BorrowKind::UniqueImmBorrow | BorrowKind::MutBorrow => {\n+                                        CaptureKind::Ref(Mutability::Mut)\n+                                    },\n+                                },\n+                            };\n+                            self.captures\n+                                .entry(local_id)\n+                                .and_modify(|e| *e |= capture)\n+                                .or_insert(capture);\n+                        }\n+                    }\n+                },\n                 ExprKind::Loop(b, ..) => {\n                     self.loops.push(e.hir_id);\n                     self.visit_block(b);\n@@ -1830,7 +1903,7 @@ pub fn peel_hir_expr_while<'tcx>(\n pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n     let mut remaining = count;\n     let e = peel_hir_expr_while(expr, |e| match e.kind {\n-        ExprKind::AddrOf(BorrowKind::Ref, _, e) if remaining != 0 => {\n+        ExprKind::AddrOf(ast::BorrowKind::Ref, _, e) if remaining != 0 => {\n             remaining -= 1;\n             Some(e)\n         },\n@@ -1844,7 +1917,7 @@ pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>,\n pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n     let mut count = 0;\n     let e = peel_hir_expr_while(expr, |e| match e.kind {\n-        ExprKind::AddrOf(BorrowKind::Ref, _, e) => {\n+        ExprKind::AddrOf(ast::BorrowKind::Ref, _, e) => {\n             count += 1;\n             Some(e)\n         },"}, {"sha": "8cc12149403d32aa22aaba2618c187eb65ea5c20", "filename": "tests/ui/manual_map_option_2.fixed", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3/tests%2Fui%2Fmanual_map_option_2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3/tests%2Fui%2Fmanual_map_option_2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.fixed?ref=9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3", "patch": "@@ -1,16 +1,50 @@\n // run-rustfix\n \n #![warn(clippy::manual_map)]\n+#![allow(clippy::toplevel_ref_arg)]\n \n fn main() {\n+    // Lint. `y` is declared within the arm, so it isn't captured by the map closure\n     let _ = Some(0).map(|x| {\n             let y = (String::new(), String::new());\n             (x, y.0)\n         });\n \n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n     let s = Some(String::new());\n     let _ = match &s {\n         Some(x) => Some((x.clone(), s)),\n         None => None,\n     };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let s = || s;\n+            (clone, s())\n+        }),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured as a mutable\n+    // reference by the map closure\n+    let mut s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let ref mut s = s;\n+            (clone, s)\n+        }),\n+        None => None,\n+    };\n+\n+    // Lint. `s` is captured by reference, so no lifetime issues.\n+    let s = Some(String::new());\n+    let _ = s.as_ref().map(|x| {\n+            if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+        });\n }"}, {"sha": "0862b201ead4b7290f600e6b27454a8a1b72dc4a", "filename": "tests/ui/manual_map_option_2.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3/tests%2Fui%2Fmanual_map_option_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3/tests%2Fui%2Fmanual_map_option_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.rs?ref=9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3", "patch": "@@ -1,8 +1,10 @@\n // run-rustfix\n \n #![warn(clippy::manual_map)]\n+#![allow(clippy::toplevel_ref_arg)]\n \n fn main() {\n+    // Lint. `y` is declared within the arm, so it isn't captured by the map closure\n     let _ = match Some(0) {\n         Some(x) => Some({\n             let y = (String::new(), String::new());\n@@ -11,9 +13,44 @@ fn main() {\n         None => None,\n     };\n \n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n     let s = Some(String::new());\n     let _ = match &s {\n         Some(x) => Some((x.clone(), s)),\n         None => None,\n     };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let s = || s;\n+            (clone, s())\n+        }),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured as a mutable\n+    // reference by the map closure\n+    let mut s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let ref mut s = s;\n+            (clone, s)\n+        }),\n+        None => None,\n+    };\n+\n+    // Lint. `s` is captured by reference, so no lifetime issues.\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+        }),\n+        None => None,\n+    };\n }"}, {"sha": "9cfd83f445b151126493e25cab37444352afa6b7", "filename": "tests/ui/manual_map_option_2.stderr", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3/tests%2Fui%2Fmanual_map_option_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3/tests%2Fui%2Fmanual_map_option_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.stderr?ref=9500974bdb5f7cd9a8ba056b41bd5af5f373e0d3", "patch": "@@ -1,5 +1,5 @@\n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option_2.rs:6:13\n+  --> $DIR/manual_map_option_2.rs:8:13\n    |\n LL |       let _ = match Some(0) {\n    |  _____________^\n@@ -20,5 +20,24 @@ LL |             (x, y.0)\n LL |         });\n    |\n \n-error: aborting due to previous error\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:50:13\n+   |\n+LL |       let _ = match &s {\n+   |  _____________^\n+LL | |         Some(x) => Some({\n+LL | |             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+LL | |         }),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     let _ = s.as_ref().map(|x| {\n+LL |             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+LL |         });\n+   |\n+\n+error: aborting due to 2 previous errors\n "}]}