{"sha": "8e966216c7c59c1b1de08561502f0b78589db59a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOTY2MjE2YzdjNTljMWIxZGUwODU2MTUwMmYwYjc4NTg5ZGI1OWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-12T00:34:52Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-14T23:05:16Z"}, "message": "core::rt: Restructure task_from_last_cleanup_job to borrow correctly\n\nWe need a number of mutable references to contexts so name it\n`get_contexts` and return a tuple of all of them.", "tree": {"sha": "4c7a9dfd29902dd6c3aec2f4ad53988b7ed6c717", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c7a9dfd29902dd6c3aec2f4ad53988b7ed6c717"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e966216c7c59c1b1de08561502f0b78589db59a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e966216c7c59c1b1de08561502f0b78589db59a", "html_url": "https://github.com/rust-lang/rust/commit/8e966216c7c59c1b1de08561502f0b78589db59a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e966216c7c59c1b1de08561502f0b78589db59a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf34b31704257ef79cd0f9286314c10fa15b7bf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf34b31704257ef79cd0f9286314c10fa15b7bf9", "html_url": "https://github.com/rust-lang/rust/commit/cf34b31704257ef79cd0f9286314c10fa15b7bf9"}], "stats": {"total": 111, "additions": 63, "deletions": 48}, "files": [{"sha": "eff25d22882de7cda12b2a02f20b215ba7ee8e8a", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 63, "deletions": 48, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/8e966216c7c59c1b1de08561502f0b78589db59a/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e966216c7c59c1b1de08561502f0b78589db59a/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=8e966216c7c59c1b1de08561502f0b78589db59a", "patch": "@@ -151,7 +151,16 @@ pub impl Scheduler {\n \n         // Store the task in the scheduler so it can be grabbed later\n         self.current_task = Some(task);\n-        self.swap_in_task();\n+\n+        // Take pointers to both the task and scheduler's saved registers.\n+        {\n+            let (sched_context, _, next_task_context) = self.get_contexts();\n+            let next_task_context = next_task_context.unwrap();\n+            // Context switch to the task, restoring it's registers\n+            // and saving the scheduler's\n+            Context::swap(sched_context, next_task_context);\n+        }\n+\n         // The running task should have passed ownership elsewhere\n         assert!(self.current_task.is_none());\n \n@@ -171,8 +180,11 @@ pub impl Scheduler {\n \n         let dead_task = self.current_task.swap_unwrap();\n         self.enqueue_cleanup_job(RecycleTask(dead_task));\n-        let dead_task = self.task_from_last_cleanup_job();\n-        self.swap_out_task(dead_task);\n+        {\n+            let (sched_context, last_task_context, _) = self.get_contexts();\n+            let last_task_context = last_task_context.unwrap();\n+            Context::swap(last_task_context, sched_context);\n+        }\n     }\n \n     /// Block a running task, context switch to the scheduler, then pass the\n@@ -194,9 +206,13 @@ pub impl Scheduler {\n         };\n         let f_opaque = HackAroundBorrowCk::from_fn(f_fake_region);\n         self.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n-        let blocked_task = self.task_from_last_cleanup_job();\n+        {\n+            let (sched_context, last_task_context, _) = self.get_contexts();\n+            let last_task_context = last_task_context.unwrap();\n+            Context::swap(last_task_context, sched_context);\n+        }\n \n-        self.swap_out_task(blocked_task);\n+        // XXX: Should probably run cleanup jobs\n     }\n \n     /// Switch directly to another task, without going through the scheduler.\n@@ -209,43 +225,17 @@ pub impl Scheduler {\n \n         let old_running_task = self.current_task.swap_unwrap();\n         self.enqueue_cleanup_job(RescheduleTask(old_running_task));\n-        let old_running_task = self.task_from_last_cleanup_job();\n-\n         self.current_task = Some(next_task);\n-        self.swap_in_task_from_running_task(old_running_task);\n-    }\n-\n-\n-    // * Context switching\n-\n-    // NB: When switching to a task callers are expected to first set\n-    // self.running_task. When switching away from a task likewise move\n-    // out of the self.running_task\n-\n-    priv fn swap_in_task(&mut self) {\n-        // Take pointers to both the task and scheduler's saved registers.\n-        let running_task: &~Task = self.current_task.get_ref();\n-        let task_context = &running_task.saved_context;\n-        let scheduler_context = &mut self.saved_context;\n-\n-        // Context switch to the task, restoring it's registers\n-        // and saving the scheduler's\n-        Context::swap(scheduler_context, task_context);\n-    }\n-\n-    priv fn swap_out_task(&mut self, running_task: &mut Task) {\n-        let task_context = &mut running_task.saved_context;\n-        let scheduler_context = &self.saved_context;\n-        Context::swap(task_context, scheduler_context);\n-    }\n+        {\n+            let (_, last_task_context, next_task_context) = self.get_contexts();\n+            let last_task_context = last_task_context.unwrap();\n+            let next_task_context = next_task_context.unwrap();\n+            Context::swap(last_task_context, next_task_context);\n+        }\n \n-    priv fn swap_in_task_from_running_task(&mut self, running_task: &mut Task) {\n-        let running_task_context = &mut running_task.saved_context;\n-        let next_context = &self.current_task.get_ref().saved_context;\n-        Context::swap(running_task_context, next_context);\n+        // XXX: Should probably run cleanup jobs\n     }\n \n-\n     // * Other stuff\n \n     fn in_task_context(&self) -> bool { self.current_task.is_some() }\n@@ -270,20 +260,42 @@ pub impl Scheduler {\n         }\n     }\n \n-    // XXX: Hack. This should return &'self mut but I don't know how to\n-    // make the borrowcheck happy\n-    fn task_from_last_cleanup_job(&mut self) -> &mut Task {\n-        assert!(!self.cleanup_jobs.is_empty());\n-        let last_job: &'self mut CleanupJob = &mut self.cleanup_jobs[0];\n-        let last_task: &'self Task = match last_job {\n-            &RescheduleTask(~ref task) => task,\n-            &RecycleTask(~ref task) => task,\n-            &GiveTask(~ref task, _) => task,\n+    /// Get mutable references to all the contexts that may be involved in a\n+    /// context switch.\n+    ///\n+    /// Returns (the scheduler context, the optional context of the\n+    /// task in the cleanup list, the optional context of the task in\n+    /// the current task slot).  When context switching to a task,\n+    /// callers should first arrange for that task to be located in the\n+    /// Scheduler's current_task slot and set up the\n+    /// post-context-switch cleanup job.\n+    fn get_contexts(&mut self) -> (&'self mut Context,\n+                                   Option<&'self mut Context>,\n+                                   Option<&'self mut Context>) {\n+        let last_task = if !self.cleanup_jobs.is_empty() {\n+            let last_job: &'self mut CleanupJob = &mut self.cleanup_jobs[0];\n+            let last_task: &'self Task = match last_job {\n+                &RescheduleTask(~ref task) => task,\n+                &RecycleTask(~ref task) => task,\n+                &GiveTask(~ref task, _) => task,\n+            };\n+            Some(last_task)\n+        } else {\n+            None\n         };\n         // XXX: Pattern matching mutable pointers above doesn't work\n         // because borrowck thinks the three patterns are conflicting\n         // borrows\n-        return unsafe { transmute::<&Task, &mut Task>(last_task) };\n+        let last_task = unsafe { transmute::<Option<&Task>, Option<&mut Task>>(last_task) };\n+        let last_task_context = match last_task {\n+            Some(ref t) => Some(&mut t.saved_context), None => None\n+        };\n+        let next_task_context = match self.current_task {\n+            Some(ref mut t) => Some(&mut t.saved_context), None => None\n+        };\n+        return (&mut self.saved_context,\n+                last_task_context,\n+                next_task_context);\n     }\n }\n \n@@ -313,6 +325,9 @@ pub impl Task {\n     priv fn build_start_wrapper(start: ~fn()) -> ~fn() {\n         // XXX: The old code didn't have this extra allocation\n         let wrapper: ~fn() = || {\n+            // XXX: Should probably run scheduler cleanup jobs for situations\n+            // where a task context switches directly to a new task\n+\n             start();\n \n             let mut sched = ThreadLocalScheduler::new();"}]}