{"sha": "f1886680e00850843e2524fba609ddba6a13180b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxODg2NjgwZTAwODUwODQzZTI1MjRmYmE2MDlkZGJhNmExMzE4MGI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-13T15:44:15Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-16T00:50:28Z"}, "message": "std: convert str::to_utf16 to a method.", "tree": {"sha": "bb8ae7af1dab1088058e87436bd429aa4b4ace7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb8ae7af1dab1088058e87436bd429aa4b4ace7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1886680e00850843e2524fba609ddba6a13180b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1886680e00850843e2524fba609ddba6a13180b", "html_url": "https://github.com/rust-lang/rust/commit/f1886680e00850843e2524fba609ddba6a13180b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1886680e00850843e2524fba609ddba6a13180b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "html_url": "https://github.com/rust-lang/rust/commit/4b18fff2be74df9a2db5ee6ab418da322ad6ae18"}], "stats": {"total": 57, "additions": 29, "deletions": 28}, "files": [{"sha": "115729571986ddb2b1dc5e32557d3e4d4f7f3a9f", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1886680e00850843e2524fba609ddba6a13180b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1886680e00850843e2524fba609ddba6a13180b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f1886680e00850843e2524fba609ddba6a13180b", "patch": "@@ -144,7 +144,7 @@ pub mod win32 {\n     }\n \n     pub fn as_utf16_p<T>(s: &str, f: &fn(*u16) -> T) -> T {\n-        let mut t = str::to_utf16(s);\n+        let mut t = s.to_utf16();\n         // Null terminate before passing on.\n         t += [0u16];\n         vec::as_imm_buf(t, |buf, _len| f(buf))"}, {"sha": "d5beb755a27d78b23d56a1db04921a0946ec3937", "filename": "src/libstd/str.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f1886680e00850843e2524fba609ddba6a13180b/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1886680e00850843e2524fba609ddba6a13180b/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=f1886680e00850843e2524fba609ddba6a13180b", "patch": "@@ -759,30 +759,6 @@ pub fn is_utf16(v: &[u16]) -> bool {\n     return true;\n }\n \n-/// Converts to a vector of `u16` encoded as UTF-16\n-pub fn to_utf16(s: &str) -> ~[u16] {\n-    let mut u = ~[];\n-    for s.iter().advance |ch| {\n-        // Arithmetic with u32 literals is easier on the eyes than chars.\n-        let mut ch = ch as u32;\n-\n-        if (ch & 0xFFFF_u32) == ch {\n-            // The BMP falls through (assuming non-surrogate, as it\n-            // should)\n-            assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n-            u.push(ch as u16)\n-        } else {\n-            // Supplementary planes break into surrogates.\n-            assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n-            ch -= 0x1_0000_u32;\n-            let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n-            let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            u.push_all([w1, w2])\n-        }\n-    }\n-    u\n-}\n-\n /// Iterates over the utf-16 characters in the specified slice, yielding each\n /// decoded unicode character to the function provided.\n ///\n@@ -1188,6 +1164,7 @@ pub trait StrSlice<'self> {\n     fn replace(&self, from: &str, to: &str) -> ~str;\n     fn to_owned(&self) -> ~str;\n     fn to_managed(&self) -> @str;\n+    fn to_utf16(&self) -> ~[u16];\n     fn is_char_boundary(&self, index: uint) -> bool;\n     fn char_range_at(&self, start: uint) -> CharRange;\n     fn char_at(&self, i: uint) -> char;\n@@ -1602,6 +1579,30 @@ impl<'self> StrSlice<'self> for &'self str {\n         unsafe { ::cast::transmute(v) }\n     }\n \n+    /// Converts to a vector of `u16` encoded as UTF-16.\n+    fn to_utf16(&self) -> ~[u16] {\n+        let mut u = ~[];\n+        for self.iter().advance |ch| {\n+            // Arithmetic with u32 literals is easier on the eyes than chars.\n+            let mut ch = ch as u32;\n+\n+            if (ch & 0xFFFF_u32) == ch {\n+                // The BMP falls through (assuming non-surrogate, as it\n+                // should)\n+                assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n+                u.push(ch as u16)\n+            } else {\n+                // Supplementary planes break into surrogates.\n+                assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n+                ch -= 0x1_0000_u32;\n+                let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n+                let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n+                u.push_all([w1, w2])\n+            }\n+        }\n+        u\n+    }\n+\n     /**\n      * Returns false if the index points into the middle of a multi-byte\n      * character sequence.\n@@ -3116,10 +3117,10 @@ mod tests {\n \n         for pairs.each |p| {\n             let (s, u) = copy *p;\n-            assert!(to_utf16(s) == u);\n+            assert!(s.to_utf16() == u);\n             assert!(from_utf16(u) == s);\n-            assert!(from_utf16(to_utf16(s)) == s);\n-            assert!(to_utf16(from_utf16(u)) == u);\n+            assert!(from_utf16(s.to_utf16()) == s);\n+            assert!(from_utf16(u).to_utf16() == u);\n         }\n     }\n "}]}