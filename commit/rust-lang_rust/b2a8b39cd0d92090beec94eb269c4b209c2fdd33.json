{"sha": "b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYThiMzljZDBkOTIwOTBiZWVjOTRlYjI2OWM0YjIwOWMyZmRkMzM=", "commit": {"author": {"name": "Hanif Bin Ariffin", "email": "hanif.ariffin.4326@gmail.com", "date": "2020-04-22T07:20:40Z"}, "committer": {"name": "Hanif Bin Ariffin", "email": "hanif.ariffin.4326@gmail.com", "date": "2020-05-07T15:27:29Z"}, "message": "Renamed \"undef\" stuff to \"uninit\"\n\n1. InvalidUndefBytes -> InvalidUninitBytes\n2. ScalarMaybeUndef -> ScalarMaybeUninit\n3. UndefMask -> InitMask\n\nRelated issue  #71193", "tree": {"sha": "03b7ef94cc03c85a04a3eb3148a0019117ad796a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03b7ef94cc03c85a04a3eb3148a0019117ad796a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "html_url": "https://github.com/rust-lang/rust/commit/b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/comments", "author": {"login": "hbina", "id": 6733660, "node_id": "MDQ6VXNlcjY3MzM2NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/6733660?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hbina", "html_url": "https://github.com/hbina", "followers_url": "https://api.github.com/users/hbina/followers", "following_url": "https://api.github.com/users/hbina/following{/other_user}", "gists_url": "https://api.github.com/users/hbina/gists{/gist_id}", "starred_url": "https://api.github.com/users/hbina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hbina/subscriptions", "organizations_url": "https://api.github.com/users/hbina/orgs", "repos_url": "https://api.github.com/users/hbina/repos", "events_url": "https://api.github.com/users/hbina/events{/privacy}", "received_events_url": "https://api.github.com/users/hbina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hbina", "id": 6733660, "node_id": "MDQ6VXNlcjY3MzM2NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/6733660?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hbina", "html_url": "https://github.com/hbina", "followers_url": "https://api.github.com/users/hbina/followers", "following_url": "https://api.github.com/users/hbina/following{/other_user}", "gists_url": "https://api.github.com/users/hbina/gists{/gist_id}", "starred_url": "https://api.github.com/users/hbina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hbina/subscriptions", "organizations_url": "https://api.github.com/users/hbina/orgs", "repos_url": "https://api.github.com/users/hbina/repos", "events_url": "https://api.github.com/users/hbina/events{/privacy}", "received_events_url": "https://api.github.com/users/hbina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63d03779946a07d8c418a361278168a6d3a1f4d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/63d03779946a07d8c418a361278168a6d3a1f4d2", "html_url": "https://github.com/rust-lang/rust/commit/63d03779946a07d8c418a361278168a6d3a1f4d2"}], "stats": {"total": 276, "additions": 138, "deletions": 138}, "files": [{"sha": "2b6cf224e2c1b958a878518ed32d7a65755da81b", "filename": "src/librustc_middle/mir/interpret/allocation.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::sorted_map::SortedMap;\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n-    read_target_uint, write_target_uint, AllocId, InterpResult, Pointer, Scalar, ScalarMaybeUndef,\n+    read_target_uint, write_target_uint, AllocId, InterpResult, Pointer, Scalar, ScalarMaybeUninit,\n };\n \n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n@@ -25,7 +25,7 @@ pub struct Allocation<Tag = (), Extra = ()> {\n     /// at the given offset.\n     relocations: Relocations<Tag>,\n     /// Denotes which part of this allocation is initialized.\n-    undef_mask: UndefMask,\n+    init_mask: InitMask,\n     /// The size of the allocation. Currently, must always equal `bytes.len()`.\n     pub size: Size,\n     /// The alignment of the allocation to detect unaligned reads.\n@@ -92,7 +92,7 @@ impl<Tag> Allocation<Tag> {\n         Self {\n             bytes,\n             relocations: Relocations::new(),\n-            undef_mask: UndefMask::new(size, true),\n+            init_mask: InitMask::new(size, true),\n             size,\n             align,\n             mutability: Mutability::Not,\n@@ -108,7 +108,7 @@ impl<Tag> Allocation<Tag> {\n         Allocation {\n             bytes: vec![0; size.bytes_usize()],\n             relocations: Relocations::new(),\n-            undef_mask: UndefMask::new(size, false),\n+            init_mask: InitMask::new(size, false),\n             size,\n             align,\n             mutability: Mutability::Mut,\n@@ -138,7 +138,7 @@ impl Allocation<(), ()> {\n                     })\n                     .collect(),\n             ),\n-            undef_mask: self.undef_mask,\n+            init_mask: self.init_mask,\n             align: self.align,\n             mutability: self.mutability,\n             extra,\n@@ -160,9 +160,9 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         &self.bytes[range]\n     }\n \n-    /// Returns the undef mask.\n-    pub fn undef_mask(&self) -> &UndefMask {\n-        &self.undef_mask\n+    /// Returns the mask indicating which bytes are initialized.\n+    pub fn init_mask(&self) -> &InitMask {\n+        &self.init_mask\n     }\n \n     /// Returns the relocation list.\n@@ -358,15 +358,15 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         // `get_bytes_unchecked` tests relocation edges.\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n-        // Undef check happens *after* we established that the alignment is correct.\n+        // Uninit check happens *after* we established that the alignment is correct.\n         // We must not return `Ok()` for unaligned pointers!\n         if self.is_defined(ptr, size).is_err() {\n-            // This inflates undefined bytes to the entire scalar, even if only a few\n-            // bytes are undefined.\n-            return Ok(ScalarMaybeUndef::Undef);\n+            // This inflates uninitialized bytes to the entire scalar, even if only a few\n+            // bytes are uninitialized.\n+            return Ok(ScalarMaybeUninit::Uninit);\n         }\n         // Now we do the actual reading.\n         let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n@@ -377,11 +377,11 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         } else {\n             if let Some(&(tag, alloc_id)) = self.relocations.get(&ptr.offset) {\n                 let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits), tag);\n-                return Ok(ScalarMaybeUndef::Scalar(ptr.into()));\n+                return Ok(ScalarMaybeUninit::Scalar(ptr.into()));\n             }\n         }\n         // We don't. Just return the bits.\n-        Ok(ScalarMaybeUndef::Scalar(Scalar::from_uint(bits, size)))\n+        Ok(ScalarMaybeUninit::Scalar(Scalar::from_uint(bits, size)))\n     }\n \n     /// Reads a pointer-sized scalar.\n@@ -392,7 +392,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n     }\n \n@@ -409,12 +409,12 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-        val: ScalarMaybeUndef<Tag>,\n+        val: ScalarMaybeUninit<Tag>,\n         type_size: Size,\n     ) -> InterpResult<'tcx> {\n         let val = match val {\n-            ScalarMaybeUndef::Scalar(scalar) => scalar,\n-            ScalarMaybeUndef::Undef => {\n+            ScalarMaybeUninit::Scalar(scalar) => scalar,\n+            ScalarMaybeUninit::Uninit => {\n                 self.mark_definedness(ptr, type_size, false);\n                 return Ok(());\n             }\n@@ -445,7 +445,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-        val: ScalarMaybeUndef<Tag>,\n+        val: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let ptr_size = cx.data_layout().pointer_size;\n         self.write_scalar(cx, ptr, val, ptr_size)\n@@ -514,10 +514,10 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // Mark parts of the outermost relocations as undefined if they partially fall outside the\n         // given range.\n         if first < start {\n-            self.undef_mask.set_range(first, start, false);\n+            self.init_mask.set_range(first, start, false);\n         }\n         if last > end {\n-            self.undef_mask.set_range(end, last, false);\n+            self.init_mask.set_range(end, last, false);\n         }\n \n         // Forget all the relocations.\n@@ -548,21 +548,21 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Returns `Ok(())` if it's defined. Otherwise returns the index of the byte\n     /// at which the first undefined access begins.\n     fn is_defined(&self, ptr: Pointer<Tag>, size: Size) -> Result<(), Size> {\n-        self.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) // `Size` addition\n+        self.init_mask.is_range_initialized(ptr.offset, ptr.offset + size) // `Size` addition\n     }\n \n     /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n     /// error which will report the first byte which is undefined.\n     fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         self.is_defined(ptr, size)\n-            .or_else(|idx| throw_ub!(InvalidUndefBytes(Some(Pointer::new(ptr.alloc_id, idx)))))\n+            .or_else(|idx| throw_ub!(InvalidUninitBytes(Some(Pointer::new(ptr.alloc_id, idx)))))\n     }\n \n     pub fn mark_definedness(&mut self, ptr: Pointer<Tag>, size: Size, new_state: bool) {\n         if size.bytes() == 0 {\n             return;\n         }\n-        self.undef_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n+        self.init_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n     }\n }\n \n@@ -601,13 +601,13 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         // where each element toggles the state.\n \n         let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n-        let initial = self.undef_mask.get(src.offset);\n+        let initial = self.init_mask.get(src.offset);\n         let mut cur_len = 1;\n         let mut cur = initial;\n \n         for i in 1..size.bytes() {\n             // FIXME: optimize to bitshift the current undef block's bits and read the top bit.\n-            if self.undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n+            if self.init_mask.get(src.offset + Size::from_bytes(i)) == cur {\n                 cur_len += 1;\n             } else {\n                 ranges.push(cur_len);\n@@ -632,7 +632,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         // An optimization where we can just overwrite an entire range of definedness bits if\n         // they are going to be uniformly `1` or `0`.\n         if defined.ranges.len() <= 1 {\n-            self.undef_mask.set_range_inbounds(\n+            self.init_mask.set_range_inbounds(\n                 dest.offset,\n                 dest.offset + size * repeat, // `Size` operations\n                 defined.initial,\n@@ -647,7 +647,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n             for range in &defined.ranges {\n                 let old_j = j;\n                 j += range;\n-                self.undef_mask.set_range_inbounds(\n+                self.init_mask.set_range_inbounds(\n                     Size::from_bytes(old_j),\n                     Size::from_bytes(j),\n                     cur,\n@@ -739,29 +739,29 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n type Block = u64;\n \n /// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n-/// is defined. If it is `false` the byte is undefined.\n+/// is initialized. If it is `false` the byte is uninitialized.\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n #[derive(HashStable)]\n-pub struct UndefMask {\n+pub struct InitMask {\n     blocks: Vec<Block>,\n     len: Size,\n }\n \n-impl UndefMask {\n+impl InitMask {\n     pub const BLOCK_SIZE: u64 = 64;\n \n     pub fn new(size: Size, state: bool) -> Self {\n-        let mut m = UndefMask { blocks: vec![], len: Size::ZERO };\n+        let mut m = InitMask { blocks: vec![], len: Size::ZERO };\n         m.grow(size, state);\n         m\n     }\n \n-    /// Checks whether the range `start..end` (end-exclusive) is entirely defined.\n+    /// Checks whether the range `start..end` (end-exclusive) is entirely initialized.\n     ///\n-    /// Returns `Ok(())` if it's defined. Otherwise returns the index of the byte\n-    /// at which the first undefined access begins.\n+    /// Returns `Ok(())` if it's initialized. Otherwise returns the index of the byte\n+    /// at which the first uninitialized access begins.\n     #[inline]\n-    pub fn is_range_defined(&self, start: Size, end: Size) -> Result<(), Size> {\n+    pub fn is_range_initialized(&self, start: Size, end: Size) -> Result<(), Size> {\n         if end > self.len {\n             return Err(self.len);\n         }\n@@ -870,7 +870,7 @@ impl UndefMask {\n #[inline]\n fn bit_index(bits: Size) -> (usize, usize) {\n     let bits = bits.bytes();\n-    let a = bits / UndefMask::BLOCK_SIZE;\n-    let b = bits % UndefMask::BLOCK_SIZE;\n+    let a = bits / InitMask::BLOCK_SIZE;\n+    let b = bits % InitMask::BLOCK_SIZE;\n     (usize::try_from(a).unwrap(), usize::try_from(b).unwrap())\n }"}, {"sha": "06fe3793b2383aebaf97e1e3c56f10fc383add19", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -1,4 +1,4 @@\n-use super::{AllocId, Pointer, RawConst, ScalarMaybeUndef};\n+use super::{AllocId, Pointer, RawConst, ScalarMaybeUninit};\n \n use crate::mir::interpret::ConstValue;\n use crate::ty::layout::LayoutError;\n@@ -378,13 +378,13 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Using a non-character `u32` as character.\n     InvalidChar(u32),\n     /// An enum discriminant was set to a value which was outside the range of valid values.\n-    InvalidDiscriminant(ScalarMaybeUndef),\n+    InvalidDiscriminant(ScalarMaybeUninit),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n     /// Using a string that is not valid UTF-8,\n     InvalidStr(std::str::Utf8Error),\n     /// Using uninitialized data where it is not allowed.\n-    InvalidUndefBytes(Option<Pointer>),\n+    InvalidUninitBytes(Option<Pointer>),\n     /// Working with a local that is not currently live.\n     DeadLocal,\n     /// Data size is not equal to target size.\n@@ -455,12 +455,12 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n                 write!(f, \"using {} as function pointer but it does not point to a function\", p)\n             }\n             InvalidStr(err) => write!(f, \"this string is not valid UTF-8: {}\", err),\n-            InvalidUndefBytes(Some(p)) => write!(\n+            InvalidUninitBytes(Some(p)) => write!(\n                 f,\n                 \"reading uninitialized memory at {}, but this operation requires initialized memory\",\n                 p\n             ),\n-            InvalidUndefBytes(None) => write!(\n+            InvalidUninitBytes(None) => write!(\n                 f,\n                 \"using uninitialized data, but this operation requires initialized memory\"\n             ),"}, {"sha": "61d7425de7d468b5a69a51239ef61c14c33aaef9", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -122,9 +122,9 @@ pub use self::error::{\n     ResourceExhaustionInfo, UndefinedBehaviorInfo, UnsupportedOpInfo,\n };\n \n-pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUndef};\n+pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUninit};\n \n-pub use self::allocation::{Allocation, AllocationExtra, Relocations, UndefMask};\n+pub use self::allocation::{Allocation, AllocationExtra, InitMask, Relocations};\n \n pub use self::pointer::{Pointer, PointerArithmetic};\n "}, {"sha": "0e913ff58bb4af72999bd8c37142b6909b3ebd0a", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -28,7 +28,7 @@ pub struct RawConst<'tcx> {\n pub enum ConstValue<'tcx> {\n     /// Used only for types with `layout::abi::Scalar` ABI and ZSTs.\n     ///\n-    /// Not using the enum `Value` to encode that this must not be `Undef`.\n+    /// Not using the enum `Value` to encode that this must not be `Uninit`.\n     Scalar(Scalar),\n \n     /// Used only for `&[u8]` and `&str`\n@@ -542,62 +542,62 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n }\n \n #[derive(Clone, Copy, Eq, PartialEq, RustcEncodable, RustcDecodable, HashStable, Hash)]\n-pub enum ScalarMaybeUndef<Tag = ()> {\n+pub enum ScalarMaybeUninit<Tag = ()> {\n     Scalar(Scalar<Tag>),\n-    Undef,\n+    Uninit,\n }\n \n-impl<Tag> From<Scalar<Tag>> for ScalarMaybeUndef<Tag> {\n+impl<Tag> From<Scalar<Tag>> for ScalarMaybeUninit<Tag> {\n     #[inline(always)]\n     fn from(s: Scalar<Tag>) -> Self {\n-        ScalarMaybeUndef::Scalar(s)\n+        ScalarMaybeUninit::Scalar(s)\n     }\n }\n \n-impl<Tag> From<Pointer<Tag>> for ScalarMaybeUndef<Tag> {\n+impl<Tag> From<Pointer<Tag>> for ScalarMaybeUninit<Tag> {\n     #[inline(always)]\n     fn from(s: Pointer<Tag>) -> Self {\n-        ScalarMaybeUndef::Scalar(s.into())\n+        ScalarMaybeUninit::Scalar(s.into())\n     }\n }\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n-impl<Tag: fmt::Debug> fmt::Debug for ScalarMaybeUndef<Tag> {\n+impl<Tag: fmt::Debug> fmt::Debug for ScalarMaybeUninit<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            ScalarMaybeUndef::Undef => write!(f, \"<uninitialized>\"),\n-            ScalarMaybeUndef::Scalar(s) => write!(f, \"{:?}\", s),\n+            ScalarMaybeUninit::Uninit => write!(f, \"<uninitialized>\"),\n+            ScalarMaybeUninit::Scalar(s) => write!(f, \"{:?}\", s),\n         }\n     }\n }\n \n-impl<Tag: fmt::Debug> fmt::Display for ScalarMaybeUndef<Tag> {\n+impl<Tag: fmt::Debug> fmt::Display for ScalarMaybeUninit<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            ScalarMaybeUndef::Undef => write!(f, \"uninitialized bytes\"),\n-            ScalarMaybeUndef::Scalar(s) => write!(f, \"{}\", s),\n+            ScalarMaybeUninit::Uninit => write!(f, \"uninitialized bytes\"),\n+            ScalarMaybeUninit::Scalar(s) => write!(f, \"{}\", s),\n         }\n     }\n }\n \n-impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n+impl<'tcx, Tag> ScalarMaybeUninit<Tag> {\n     /// Erase the tag from the scalar, if any.\n     ///\n     /// Used by error reporting code to avoid having the error type depend on `Tag`.\n     #[inline]\n-    pub fn erase_tag(self) -> ScalarMaybeUndef {\n+    pub fn erase_tag(self) -> ScalarMaybeUninit {\n         match self {\n-            ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.erase_tag()),\n-            ScalarMaybeUndef::Undef => ScalarMaybeUndef::Undef,\n+            ScalarMaybeUninit::Scalar(s) => ScalarMaybeUninit::Scalar(s.erase_tag()),\n+            ScalarMaybeUninit::Uninit => ScalarMaybeUninit::Uninit,\n         }\n     }\n \n     #[inline]\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n-            ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => throw_ub!(InvalidUndefBytes(None)),\n+            ScalarMaybeUninit::Scalar(scalar) => Ok(scalar),\n+            ScalarMaybeUninit::Uninit => throw_ub!(InvalidUninitBytes(None)),\n         }\n     }\n "}, {"sha": "2f635b4a1c17108c9b3d8387f8fc6a2800a5d514", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -3,7 +3,7 @@ use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, Immediate, InternKind,\n     InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar,\n-    ScalarMaybeUndef, StackPopCleanup,\n+    ScalarMaybeUninit, StackPopCleanup,\n };\n use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n@@ -100,9 +100,9 @@ pub(super) fn op_to_const<'tcx>(\n ) -> ConstValue<'tcx> {\n     // We do not have value optimizations for everything.\n     // Only scalars and slices, since they are very common.\n-    // Note that further down we turn scalars of undefined bits back to `ByRef`. These can result\n+    // Note that further down we turn scalars of uninitialized bits back to `ByRef`. These can result\n     // from scalar unions that are initialized with one of their zero sized variants. We could\n-    // instead allow `ConstValue::Scalar` to store `ScalarMaybeUndef`, but that would affect all\n+    // instead allow `ConstValue::Scalar` to store `ScalarMaybeUninit`, but that would affect all\n     // the usual cases of extracting e.g. a `usize`, without there being a real use case for the\n     // `Undef` situation.\n     let try_as_immediate = match op.layout.abi {\n@@ -149,8 +149,8 @@ pub(super) fn op_to_const<'tcx>(\n         // see comment on `let try_as_immediate` above\n         Err(imm) => match *imm {\n             Immediate::Scalar(x) => match x {\n-                ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n-                ScalarMaybeUndef::Undef => to_const_value(op.assert_mem_place(ecx)),\n+                ScalarMaybeUninit::Scalar(s) => ConstValue::Scalar(s),\n+                ScalarMaybeUninit::Uninit => to_const_value(op.assert_mem_place(ecx)),\n             },\n             Immediate::ScalarPair(a, b) => {\n                 let (data, start) = match a.not_undef().unwrap() {"}, {"sha": "9bb7c879505f6614b1d8edeab151a379ed9702ea", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -22,7 +22,7 @@ use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n \n use super::{\n     Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n-    ScalarMaybeUndef, StackPopJump,\n+    ScalarMaybeUninit, StackPopJump,\n };\n use crate::util::storage::AlwaysLiveLocals;\n \n@@ -910,16 +910,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     },\n                     LocalValue::Live(Operand::Immediate(Immediate::Scalar(val))) => {\n                         write!(msg, \" {:?}\", val).unwrap();\n-                        if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val {\n+                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n                         write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n-                        if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val1 {\n+                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val1 {\n                             allocs.push(ptr.alloc_id);\n                         }\n-                        if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val2 {\n+                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val2 {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }"}, {"sha": "81009fd7b98f73716be27632ef7853e4a0e2caeb", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -16,7 +16,7 @@ use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n     from_known_layout, sign_extend, truncate, ConstValue, GlobalId, InterpCx, InterpResult,\n-    MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Scalar, ScalarMaybeUndef,\n+    MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -28,13 +28,13 @@ use super::{\n /// defined on `Immediate`, and do not have to work with a `Place`.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, Hash)]\n pub enum Immediate<Tag = ()> {\n-    Scalar(ScalarMaybeUndef<Tag>),\n-    ScalarPair(ScalarMaybeUndef<Tag>, ScalarMaybeUndef<Tag>),\n+    Scalar(ScalarMaybeUninit<Tag>),\n+    ScalarPair(ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>),\n }\n \n-impl<Tag> From<ScalarMaybeUndef<Tag>> for Immediate<Tag> {\n+impl<Tag> From<ScalarMaybeUninit<Tag>> for Immediate<Tag> {\n     #[inline(always)]\n-    fn from(val: ScalarMaybeUndef<Tag>) -> Self {\n+    fn from(val: ScalarMaybeUninit<Tag>) -> Self {\n         Immediate::Scalar(val)\n     }\n }\n@@ -63,7 +63,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_scalar_or_undef(self) -> ScalarMaybeUndef<Tag> {\n+    pub fn to_scalar_or_undef(self) -> ScalarMaybeUninit<Tag> {\n         match self {\n             Immediate::Scalar(val) => val,\n             Immediate::ScalarPair(..) => bug!(\"Got a wide pointer where a scalar was expected\"),\n@@ -97,14 +97,14 @@ impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n         /// Helper function for printing a scalar to a FmtPrinter\n         fn p<'a, 'tcx, F: std::fmt::Write, Tag>(\n             cx: FmtPrinter<'a, 'tcx, F>,\n-            s: ScalarMaybeUndef<Tag>,\n+            s: ScalarMaybeUninit<Tag>,\n             ty: Ty<'tcx>,\n         ) -> Result<FmtPrinter<'a, 'tcx, F>, std::fmt::Error> {\n             match s {\n-                ScalarMaybeUndef::Scalar(s) => {\n+                ScalarMaybeUninit::Scalar(s) => {\n                     cx.pretty_print_const_scalar(s.erase_tag(), ty, true)\n                 }\n-                ScalarMaybeUndef::Undef => cx.typed_value(\n+                ScalarMaybeUninit::Uninit => cx.typed_value(\n                     |mut this| {\n                         this.write_str(\"{undef \")?;\n                         Ok(this)\n@@ -319,7 +319,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn read_scalar(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<M::PointerTag>> {\n         Ok(self.read_immediate(op)?.to_scalar_or_undef())\n     }\n \n@@ -644,7 +644,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let variants_end = niche_variants.end().as_u32();\n                 let raw_discr = raw_discr\n                     .not_undef()\n-                    .map_err(|_| err_ub!(InvalidDiscriminant(ScalarMaybeUndef::Undef)))?;\n+                    .map_err(|_| err_ub!(InvalidDiscriminant(ScalarMaybeUninit::Uninit)))?;\n                 match raw_discr.to_bits_or_ptr(discr_val.layout.size, self) {\n                     Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)"}, {"sha": "2e8b1e64aedc3e1a307356346647ad8d6e31d350", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -15,7 +15,7 @@ use rustc_target::abi::{HasDataLayout, LayoutOf, Size, VariantIdx, Variants};\n use super::{\n     mir_assign_valid_types, truncate, AllocId, AllocMap, Allocation, AllocationExtra, ImmTy,\n     Immediate, InterpCx, InterpResult, LocalValue, Machine, MemoryKind, OpTy, Operand, Pointer,\n-    PointerArithmetic, RawConst, Scalar, ScalarMaybeUndef,\n+    PointerArithmetic, RawConst, Scalar, ScalarMaybeUninit,\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n@@ -645,7 +645,7 @@ where\n     #[inline(always)]\n     pub fn write_scalar(\n         &mut self,\n-        val: impl Into<ScalarMaybeUndef<M::PointerTag>>,\n+        val: impl Into<ScalarMaybeUninit<M::PointerTag>>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         self.write_immediate(Immediate::Scalar(val.into()), dest)\n@@ -697,19 +697,19 @@ where\n             // This is a very common path, avoid some checks in release mode\n             assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n             match src {\n-                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Ptr(_))) => assert_eq!(\n+                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Ptr(_))) => assert_eq!(\n                     self.pointer_size(),\n                     dest.layout.size,\n                     \"Size mismatch when writing pointer\"\n                 ),\n-                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Raw { size, .. })) => {\n+                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Raw { size, .. })) => {\n                     assert_eq!(\n                         Size::from_bytes(size),\n                         dest.layout.size,\n                         \"Size mismatch when writing bits\"\n                     )\n                 }\n-                Immediate::Scalar(ScalarMaybeUndef::Undef) => {} // undef can have any size\n+                Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // undef can have any size\n                 Immediate::ScalarPair(_, _) => {\n                     // FIXME: Can we check anything here?\n                 }"}, {"sha": "92575855ad6a0b5dd7320d0782eb592ce4b7a714", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -365,7 +365,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let place = try_validation!(\n             self.ecx.ref_to_mplace(value),\n             self.path,\n-            err_ub!(InvalidUndefBytes(..)) => { \"uninitialized {}\", kind },\n+            err_ub!(InvalidUninitBytes(..)) => { \"uninitialized {}\", kind },\n         );\n         if place.layout.is_unsized() {\n             self.check_wide_ptr_meta(place.meta, place.layout)?;\n@@ -513,7 +513,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let place = try_validation!(\n                     self.ecx.ref_to_mplace(self.ecx.read_immediate(value)?),\n                     self.path,\n-                    err_ub!(InvalidUndefBytes(..)) => { \"uninitialized raw pointer\" },\n+                    err_ub!(InvalidUninitBytes(..)) => { \"uninitialized raw pointer\" },\n                 );\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n@@ -592,7 +592,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let value = try_validation!(\n             value.not_undef(),\n             self.path,\n-            err_ub!(InvalidUndefBytes(..)) => { \"{}\", value }\n+            err_ub!(InvalidUninitBytes(..)) => { \"{}\", value }\n                 expected { \"something {}\", wrapping_range_format(valid_range, max_hi) },\n         );\n         let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n@@ -802,7 +802,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                         // For some errors we might be able to provide extra information.\n                         // (This custom logic does not fit the `try_validation!` macro.)\n                         match err.kind {\n-                            err_ub!(InvalidUndefBytes(Some(ptr))) => {\n+                            err_ub!(InvalidUninitBytes(Some(ptr))) => {\n                                 // Some byte was uninitialized, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index."}, {"sha": "4be95b69850dfcb1fd7be7023f1b6c7cac801f10", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -29,7 +29,7 @@ use crate::const_eval::error_to_const_error;\n use crate::interpret::{\n     self, compile_time_machine, intern_const_alloc_recursive, AllocId, Allocation, Frame, ImmTy,\n     Immediate, InternKind, InterpCx, LocalState, LocalValue, Memory, MemoryKind, OpTy,\n-    Operand as InterpOperand, PlaceTy, Pointer, ScalarMaybeUndef, StackPopCleanup,\n+    Operand as InterpOperand, PlaceTy, Pointer, ScalarMaybeUninit, StackPopCleanup,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -633,16 +633,16 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         if let Some(Ok(imm)) = imm {\n             match *imm {\n-                interpret::Immediate::Scalar(ScalarMaybeUndef::Scalar(scalar)) => {\n+                interpret::Immediate::Scalar(ScalarMaybeUninit::Scalar(scalar)) => {\n                     *rval = Rvalue::Use(self.operand_from_scalar(\n                         scalar,\n                         value.layout.ty,\n                         source_info.span,\n                     ));\n                 }\n                 Immediate::ScalarPair(\n-                    ScalarMaybeUndef::Scalar(one),\n-                    ScalarMaybeUndef::Scalar(two),\n+                    ScalarMaybeUninit::Scalar(one),\n+                    ScalarMaybeUninit::Scalar(two),\n                 ) => {\n                     // Found a value represented as a pair. For now only do cont-prop if type of\n                     // Rvalue is also a pair with two scalars. The more general case is more\n@@ -693,12 +693,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         match *op {\n-            interpret::Operand::Immediate(Immediate::Scalar(ScalarMaybeUndef::Scalar(s))) => {\n+            interpret::Operand::Immediate(Immediate::Scalar(ScalarMaybeUninit::Scalar(s))) => {\n                 s.is_bits()\n             }\n             interpret::Operand::Immediate(Immediate::ScalarPair(\n-                ScalarMaybeUndef::Scalar(l),\n-                ScalarMaybeUndef::Scalar(r),\n+                ScalarMaybeUninit::Scalar(l),\n+                ScalarMaybeUninit::Scalar(r),\n             )) => l.is_bits() && r.is_bits(),\n             interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n                 let mplace = op.assert_mem_place(&self.ecx);\n@@ -889,7 +889,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n             TerminatorKind::Assert { expected, ref msg, ref mut cond, .. } => {\n                 if let Some(value) = self.eval_operand(&cond, source_info) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                    let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n+                    let expected = ScalarMaybeUninit::from(Scalar::from_bool(*expected));\n                     let value_const = self.ecx.read_scalar(value).unwrap();\n                     if expected != value_const {\n                         // Poison all places this operand references so that further code\n@@ -936,7 +936,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                         );\n                     } else {\n                         if self.should_const_prop(value) {\n-                            if let ScalarMaybeUndef::Scalar(scalar) = value_const {\n+                            if let ScalarMaybeUninit::Scalar(scalar) = value_const {\n                                 *cond = self.operand_from_scalar(\n                                     scalar,\n                                     self.tcx.types.bool,\n@@ -950,7 +950,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n             TerminatorKind::SwitchInt { ref mut discr, switch_ty, .. } => {\n                 if let Some(value) = self.eval_operand(&discr, source_info) {\n                     if self.should_const_prop(value) {\n-                        if let ScalarMaybeUndef::Scalar(scalar) =\n+                        if let ScalarMaybeUninit::Scalar(scalar) =\n                             self.ecx.read_scalar(value).unwrap()\n                         {\n                             *discr = self.operand_from_scalar(scalar, switch_ty, source_info.span);\n@@ -1003,9 +1003,9 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                                     // and use it to do const-prop here and everywhere else\n                                     // where it makes sense.\n                                     if let interpret::Operand::Immediate(\n-                                        interpret::Immediate::Scalar(\n-                                            interpret::ScalarMaybeUndef::Scalar(scalar),\n-                                        ),\n+                                        interpret::Immediate::Scalar(ScalarMaybeUninit::Scalar(\n+                                            scalar,\n+                                        )),\n                                     ) = *value\n                                     {\n                                         *opr = self.operand_from_scalar("}, {"sha": "5e8515ccddeb18b21f0f7902eecd305037687215", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -774,7 +774,7 @@ fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n                 ascii.push('\u257c');\n                 i += ptr_size;\n             }\n-        } else if alloc.undef_mask().is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n+        } else if alloc.init_mask().is_range_initialized(i, i + Size::from_bytes(1)).is_ok() {\n             let j = i.bytes_usize();\n \n             // Checked definedness (and thus range) and relocations. This access also doesn't"}, {"sha": "b4d1f087391f31e52bfe4123c54215c147c7fbb1", "filename": "src/test/mir-opt/const_prop/control-flow-simplification/rustc.hello.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol-flow-simplification%2Frustc.hello.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol-flow-simplification%2Frustc.hello.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol-flow-simplification%2Frustc.hello.ConstProp.diff?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -51,10 +51,10 @@\n                                            // + literal: Const { ty: fn(&str) -> ! {std::rt::begin_panic::<&str>}, val: Value(Scalar(<ZST>)) }\n                                            // ty::Const\n                                            // + ty: &str\n-                                           // + val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })\n+                                           // + val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/libstd/macros.rs:LL:COL\n-                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }\n+                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }\n       }\n   }\n   "}, {"sha": "40d56c224132494f0a73df651f82c8dea3f04efa", "filename": "src/test/mir-opt/inline/inline-into-box-place/32bit/rustc.main.Inline.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place%2F32bit%2Frustc.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place%2F32bit%2Frustc.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place%2F32bit%2Frustc.main.Inline.diff?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -24,7 +24,7 @@\n -                                          // + ty: fn() -> std::vec::Vec<u32> {std::vec::Vec::<u32>::new}\n -                                          // + val: Value(Scalar(<ZST>))\n +                                          // + ty: alloc::raw_vec::RawVec<u32>\n-+                                          // + val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n++                                          // + val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n                                            // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:33: 8:41\n -                                          // + user_ty: UserType(1)\n@@ -38,7 +38,7 @@\n -     bb2: {\n +                                          // + span: $SRC_DIR/liballoc/vec.rs:LL:COL\n +                                          // + user_ty: UserType(0)\n-+                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n++                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         ((*_4).1: usize) = const 0usize; // scope 2 at $SRC_DIR/liballoc/vec.rs:LL:COL\n +                                          // ty::Const\n +                                          // + ty: usize"}, {"sha": "0b1b3d96cbfaa023882adb97d03a784d056b623a", "filename": "src/test/mir-opt/inline/inline-into-box-place/64bit/rustc.main.Inline.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place%2F64bit%2Frustc.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place%2F64bit%2Frustc.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place%2F64bit%2Frustc.main.Inline.diff?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -24,7 +24,7 @@\n -                                          // + ty: fn() -> std::vec::Vec<u32> {std::vec::Vec::<u32>::new}\n -                                          // + val: Value(Scalar(<ZST>))\n +                                          // + ty: alloc::raw_vec::RawVec<u32>\n-+                                          // + val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [65535], len: Size { raw: 16 } }, size: Size { raw: 16 }, align: Align { pow2: 3 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n++                                          // + val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, size: Size { raw: 16 }, align: Align { pow2: 3 }, mutability: Not, extra: () }, offset: Size { raw: 0 } })\n                                            // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:33: 8:41\n -                                          // + user_ty: UserType(1)\n@@ -38,7 +38,7 @@\n -     bb2: {\n +                                          // + span: $SRC_DIR/liballoc/vec.rs:LL:COL\n +                                          // + user_ty: UserType(0)\n-+                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [65535], len: Size { raw: 16 } }, size: Size { raw: 16 }, align: Align { pow2: 3 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n++                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, size: Size { raw: 16 }, align: Align { pow2: 3 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         ((*_4).1: usize) = const 0usize; // scope 2 at $SRC_DIR/liballoc/vec.rs:LL:COL\n +                                          // ty::Const\n +                                          // + ty: usize"}, {"sha": "eb6911735a59e3d8911453524e70a804f5740fda", "filename": "src/test/mir-opt/no-drop-for-inactive-variant/rustc.unwrap.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Fno-drop-for-inactive-variant%2Frustc.unwrap.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Fno-drop-for-inactive-variant%2Frustc.unwrap.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fno-drop-for-inactive-variant%2Frustc.unwrap.SimplifyCfg-elaborate-drops.after.mir?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -32,10 +32,10 @@ fn unwrap(_1: std::option::Option<T>) -> T {\n                                          // + literal: Const { ty: fn(&str) -> ! {std::rt::begin_panic::<&str>}, val: Value(Scalar(<ZST>)) }\n                                          // ty::Const\n                                          // + ty: &str\n-                                         // + val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })\n+                                         // + val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/libstd/macros.rs:LL:COL\n-                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }\n+                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }\n     }\n \n     bb3: {"}, {"sha": "0af213e425fe453b1a2dbf078fd7cf94ea439f07", "filename": "src/test/mir-opt/no-spurious-drop-after-call/rustc.main.ElaborateDrops.before.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Fno-spurious-drop-after-call%2Frustc.main.ElaborateDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Fno-spurious-drop-after-call%2Frustc.main.ElaborateDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fno-spurious-drop-after-call%2Frustc.main.ElaborateDrops.before.mir?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -15,10 +15,10 @@ fn main() -> () {\n         _4 = const \"\";                   // scope 0 at $DIR/no-spurious-drop-after-call.rs:9:20: 9:22\n                                          // ty::Const\n                                          // + ty: &str\n-                                         // + val: Value(Slice { data: Allocation { bytes: [], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [], len: Size { raw: 0 } }, size: Size { raw: 0 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 0 })\n+                                         // + val: Value(Slice { data: Allocation { bytes: [], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [], len: Size { raw: 0 } }, size: Size { raw: 0 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 0 })\n                                          // mir::Constant\n                                          // + span: $DIR/no-spurious-drop-after-call.rs:9:20: 9:22\n-                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [], len: Size { raw: 0 } }, size: Size { raw: 0 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 0 }) }\n+                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [], len: Size { raw: 0 } }, size: Size { raw: 0 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 0 }) }\n         _3 = &(*_4);                     // scope 0 at $DIR/no-spurious-drop-after-call.rs:9:20: 9:22\n         _2 = const <str as std::string::ToString>::to_string(move _3) -> bb2; // scope 0 at $DIR/no-spurious-drop-after-call.rs:9:20: 9:34\n                                          // ty::Const"}, {"sha": "62b7535f2b57565986bec6bbc77839435ac74e6f", "filename": "src/test/mir-opt/storage_live_dead_in_statics/rustc.XXX.mir_map.0.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics%2Frustc.XXX.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics%2Frustc.XXX.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics%2Frustc.XXX.mir_map.0.mir?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -653,10 +653,10 @@ static XXX: &Foo = {\n         _2 = Foo { tup: const \"hi\", data: move _3 }; // scope 0 at $DIR/storage_live_dead_in_statics.rs:5:29: 23:2\n                                          // ty::Const\n                                          // + ty: &str\n-                                         // + val: Value(Slice { data: Allocation { bytes: [104, 105], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [3], len: Size { raw: 2 } }, size: Size { raw: 2 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 })\n+                                         // + val: Value(Slice { data: Allocation { bytes: [104, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, size: Size { raw: 2 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 })\n                                          // mir::Constant\n                                          // + span: $DIR/storage_live_dead_in_statics.rs:6:10: 6:14\n-                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [104, 105], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [3], len: Size { raw: 2 } }, size: Size { raw: 2 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 }) }\n+                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [104, 105], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [3], len: Size { raw: 2 } }, size: Size { raw: 2 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 2 }) }\n         _1 = &_2;                        // scope 0 at $DIR/storage_live_dead_in_statics.rs:5:28: 23:2\n         _0 = &(*_1);                     // scope 0 at $DIR/storage_live_dead_in_statics.rs:5:28: 23:2\n         StorageDead(_5);                 // scope 0 at $DIR/storage_live_dead_in_statics.rs:23:1: 23:2"}, {"sha": "df6c90fc7fb3757d5284bdceb03a165c518f9d2b", "filename": "src/test/mir-opt/uninhabited_enum_branching/rustc.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching%2Frustc.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching%2Frustc.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching%2Frustc.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -21,10 +21,10 @@ fn main() -> () {\n         _5 = const \"C\";                  // scope 0 at $DIR/uninhabited_enum_branching.rs:23:21: 23:24\n                                          // ty::Const\n                                          // + ty: &str\n-                                         // + val: Value(Slice { data: Allocation { bytes: [67], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n+                                         // + val: Value(Slice { data: Allocation { bytes: [67], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n                                          // mir::Constant\n                                          // + span: $DIR/uninhabited_enum_branching.rs:23:21: 23:24\n-                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [67], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n+                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [67], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n         _1 = &(*_5);                     // scope 0 at $DIR/uninhabited_enum_branching.rs:23:21: 23:24\n         StorageDead(_5);                 // scope 0 at $DIR/uninhabited_enum_branching.rs:23:23: 23:24\n         StorageDead(_2);                 // scope 0 at $DIR/uninhabited_enum_branching.rs:24:6: 24:7\n@@ -41,10 +41,10 @@ fn main() -> () {\n         _9 = const \"E\";                  // scope 0 at $DIR/uninhabited_enum_branching.rs:28:21: 28:24\n                                          // ty::Const\n                                          // + ty: &str\n-                                         // + val: Value(Slice { data: Allocation { bytes: [69], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n+                                         // + val: Value(Slice { data: Allocation { bytes: [69], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n                                          // mir::Constant\n                                          // + span: $DIR/uninhabited_enum_branching.rs:28:21: 28:24\n-                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [69], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n+                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [69], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n         _6 = &(*_9);                     // scope 0 at $DIR/uninhabited_enum_branching.rs:28:21: 28:24\n         StorageDead(_9);                 // scope 0 at $DIR/uninhabited_enum_branching.rs:28:23: 28:24\n         goto -> bb3;                     // scope 0 at $DIR/uninhabited_enum_branching.rs:26:5: 29:6\n@@ -54,10 +54,10 @@ fn main() -> () {\n         _6 = const \"D\";                  // scope 0 at $DIR/uninhabited_enum_branching.rs:27:21: 27:24\n                                          // ty::Const\n                                          // + ty: &str\n-                                         // + val: Value(Slice { data: Allocation { bytes: [68], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n+                                         // + val: Value(Slice { data: Allocation { bytes: [68], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n                                          // mir::Constant\n                                          // + span: $DIR/uninhabited_enum_branching.rs:27:21: 27:24\n-                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [68], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n+                                         // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [68], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n         goto -> bb3;                     // scope 0 at $DIR/uninhabited_enum_branching.rs:26:5: 29:6\n     }\n "}, {"sha": "fa1474aa049de9141518e2fe409812f45a2636fc", "filename": "src/test/mir-opt/uninhabited_enum_branching/rustc.main.UninhabitedEnumBranching.diff", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching%2Frustc.main.UninhabitedEnumBranching.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching%2Frustc.main.UninhabitedEnumBranching.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching%2Frustc.main.UninhabitedEnumBranching.diff?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -27,10 +27,10 @@\n           _5 = const \"C\";                  // scope 0 at $DIR/uninhabited_enum_branching.rs:23:21: 23:24\n                                            // ty::Const\n                                            // + ty: &str\n-                                           // + val: Value(Slice { data: Allocation { bytes: [67], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n+                                           // + val: Value(Slice { data: Allocation { bytes: [67], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n                                            // mir::Constant\n                                            // + span: $DIR/uninhabited_enum_branching.rs:23:21: 23:24\n-                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [67], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n+                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [67], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n           _1 = &(*_5);                     // scope 0 at $DIR/uninhabited_enum_branching.rs:23:21: 23:24\n           StorageDead(_5);                 // scope 0 at $DIR/uninhabited_enum_branching.rs:23:23: 23:24\n           goto -> bb4;                     // scope 0 at $DIR/uninhabited_enum_branching.rs:20:5: 24:6\n@@ -40,10 +40,10 @@\n           _1 = const \"A(Empty)\";           // scope 0 at $DIR/uninhabited_enum_branching.rs:21:24: 21:34\n                                            // ty::Const\n                                            // + ty: &str\n-                                           // + val: Value(Slice { data: Allocation { bytes: [65, 40, 69, 109, 112, 116, 121, 41], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })\n+                                           // + val: Value(Slice { data: Allocation { bytes: [65, 40, 69, 109, 112, 116, 121, 41], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })\n                                            // mir::Constant\n                                            // + span: $DIR/uninhabited_enum_branching.rs:21:24: 21:34\n-                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [65, 40, 69, 109, 112, 116, 121, 41], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }\n+                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [65, 40, 69, 109, 112, 116, 121, 41], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }\n           goto -> bb4;                     // scope 0 at $DIR/uninhabited_enum_branching.rs:20:5: 24:6\n       }\n   \n@@ -52,10 +52,10 @@\n           _4 = const \"B(Empty)\";           // scope 0 at $DIR/uninhabited_enum_branching.rs:22:24: 22:34\n                                            // ty::Const\n                                            // + ty: &str\n-                                           // + val: Value(Slice { data: Allocation { bytes: [66, 40, 69, 109, 112, 116, 121, 41], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })\n+                                           // + val: Value(Slice { data: Allocation { bytes: [66, 40, 69, 109, 112, 116, 121, 41], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 })\n                                            // mir::Constant\n                                            // + span: $DIR/uninhabited_enum_branching.rs:22:24: 22:34\n-                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [66, 40, 69, 109, 112, 116, 121, 41], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }\n+                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [66, 40, 69, 109, 112, 116, 121, 41], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 8 }) }\n           _1 = &(*_4);                     // scope 0 at $DIR/uninhabited_enum_branching.rs:22:24: 22:34\n           StorageDead(_4);                 // scope 0 at $DIR/uninhabited_enum_branching.rs:22:33: 22:34\n           goto -> bb4;                     // scope 0 at $DIR/uninhabited_enum_branching.rs:20:5: 24:6\n@@ -76,10 +76,10 @@\n           _9 = const \"E\";                  // scope 0 at $DIR/uninhabited_enum_branching.rs:28:21: 28:24\n                                            // ty::Const\n                                            // + ty: &str\n-                                           // + val: Value(Slice { data: Allocation { bytes: [69], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n+                                           // + val: Value(Slice { data: Allocation { bytes: [69], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n                                            // mir::Constant\n                                            // + span: $DIR/uninhabited_enum_branching.rs:28:21: 28:24\n-                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [69], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n+                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [69], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n           _6 = &(*_9);                     // scope 0 at $DIR/uninhabited_enum_branching.rs:28:21: 28:24\n           StorageDead(_9);                 // scope 0 at $DIR/uninhabited_enum_branching.rs:28:23: 28:24\n           goto -> bb7;                     // scope 0 at $DIR/uninhabited_enum_branching.rs:26:5: 29:6\n@@ -89,10 +89,10 @@\n           _6 = const \"D\";                  // scope 0 at $DIR/uninhabited_enum_branching.rs:27:21: 27:24\n                                            // ty::Const\n                                            // + ty: &str\n-                                           // + val: Value(Slice { data: Allocation { bytes: [68], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n+                                           // + val: Value(Slice { data: Allocation { bytes: [68], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 })\n                                            // mir::Constant\n                                            // + span: $DIR/uninhabited_enum_branching.rs:27:21: 27:24\n-                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [68], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n+                                           // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [68], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [1], len: Size { raw: 1 } }, size: Size { raw: 1 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 1 }) }\n           goto -> bb7;                     // scope 0 at $DIR/uninhabited_enum_branching.rs:26:5: 29:6\n       }\n   "}, {"sha": "84ce291016aafbeee2d614356b5f0e841b4aeb2c", "filename": "src/test/ui-fulldeps/uninit_mask.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fui-fulldeps%2Funinit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8b39cd0d92090beec94eb269c4b209c2fdd33/src%2Ftest%2Fui-fulldeps%2Funinit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Funinit_mask.rs?ref=b2a8b39cd0d92090beec94eb269c4b209c2fdd33", "patch": "@@ -7,11 +7,11 @@\n extern crate rustc_middle;\n extern crate rustc_target;\n \n-use rustc_middle::mir::interpret::UndefMask;\n+use rustc_middle::mir::interpret::InitMask;\n use rustc_target::abi::Size;\n \n fn main() {\n-    let mut mask = UndefMask::new(Size::from_bytes(500), false);\n+    let mut mask = InitMask::new(Size::from_bytes(500), false);\n     assert!(!mask.get(Size::from_bytes(499)));\n     mask.set(Size::from_bytes(499), true);\n     assert!(mask.get(Size::from_bytes(499)));", "previous_filename": "src/test/ui-fulldeps/undef_mask.rs"}]}