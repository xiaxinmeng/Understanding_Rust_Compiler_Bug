{"sha": "141ef23aa714c9572da6fd616e7bdb96ea40ea07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MWVmMjNhYTcxNGM5NTcyZGE2ZmQ2MTZlN2JkYjk2ZWE0MGVhMDc=", "commit": {"author": {"name": "Tim Chevalier", "email": "catamorphism@gmail.com", "date": "2012-10-18T18:12:32Z"}, "committer": {"name": "Tim Chevalier", "email": "catamorphism@gmail.com", "date": "2012-10-18T18:12:32Z"}, "message": "Merge pull request #3805 from erickt/incoming\n\nVariety of small cleanups", "tree": {"sha": "038b3992d5ffba228128b9c5a1db9dfeddfb6887", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/038b3992d5ffba228128b9c5a1db9dfeddfb6887"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/141ef23aa714c9572da6fd616e7bdb96ea40ea07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/141ef23aa714c9572da6fd616e7bdb96ea40ea07", "html_url": "https://github.com/rust-lang/rust/commit/141ef23aa714c9572da6fd616e7bdb96ea40ea07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/141ef23aa714c9572da6fd616e7bdb96ea40ea07/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e28a161b720e267c837905e5f1b0760f71ebee14", "url": "https://api.github.com/repos/rust-lang/rust/commits/e28a161b720e267c837905e5f1b0760f71ebee14", "html_url": "https://github.com/rust-lang/rust/commit/e28a161b720e267c837905e5f1b0760f71ebee14"}, {"sha": "fe41ccec6440b6ae64cae26da8e9bc42e1b06a9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe41ccec6440b6ae64cae26da8e9bc42e1b06a9f", "html_url": "https://github.com/rust-lang/rust/commit/fe41ccec6440b6ae64cae26da8e9bc42e1b06a9f"}], "stats": {"total": 205, "additions": 102, "deletions": 103}, "files": [{"sha": "1b6a7522864efc5ed412023dbb9b9c4ad8d2bb1b", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -56,7 +56,7 @@ pub enum DVec<A> {\n }\n \n /// Creates a new, empty dvec\n-pub fn DVec<A>() -> DVec<A> {\n+pub pure fn DVec<A>() -> DVec<A> {\n     DVec_({mut data: ~[]})\n }\n "}, {"sha": "d41393c23934c10e4c24b1453c0058bd9b8c1d28", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -329,11 +329,11 @@ pub mod rt {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n-          CountImplied => s.to_unique(),\n+          CountImplied => s.to_owned(),\n           CountIs(max) => if max as uint < str::char_len(s) {\n             str::substr(s, 0u, max as uint)\n           } else {\n-            s.to_unique()\n+            s.to_owned()\n           }\n         };\n         return unsafe { pad(cv, move unpadded, PadNozero) };"}, {"sha": "77f7b5023dfa97839cba366780738bbc51b3d750", "filename": "src/libcore/io.rs", "status": "modified", "additions": 76, "deletions": 66, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -37,7 +37,7 @@ pub trait Reader {\n     // FIXME (#2004): Seekable really should be orthogonal.\n \n     // FIXME (#2982): This should probably return an error.\n-    fn read(buf: &[mut u8], len: uint) -> uint;\n+    fn read(bytes: &[mut u8], len: uint) -> uint;\n     fn read_byte() -> int;\n     fn unread_byte(int);\n     fn eof() -> bool;\n@@ -65,32 +65,32 @@ pub trait ReaderUtil {\n \n impl<T: Reader> T : ReaderUtil {\n     fn read_bytes(len: uint) -> ~[u8] {\n-        let mut buf = vec::with_capacity(len);\n-        unsafe { vec::raw::set_len(&mut buf, len); }\n+        let mut bytes = vec::with_capacity(len);\n+        unsafe { vec::raw::set_len(&mut bytes, len); }\n \n-        let count = self.read(buf, len);\n+        let count = self.read(bytes, len);\n \n-        unsafe { vec::raw::set_len(&mut buf, count); }\n-        move buf\n+        unsafe { vec::raw::set_len(&mut bytes, count); }\n+        move bytes\n     }\n     fn read_line() -> ~str {\n-        let mut buf = ~[];\n+        let mut bytes = ~[];\n         loop {\n             let ch = self.read_byte();\n             if ch == -1 || ch == 10 { break; }\n-            buf.push(ch as u8);\n+            bytes.push(ch as u8);\n         }\n-        str::from_bytes(buf)\n+        str::from_bytes(bytes)\n     }\n \n     fn read_chars(n: uint) -> ~[char] {\n         // returns the (consumed offset, n_req), appends characters to &chars\n-        fn chars_from_bytes<T: Reader>(buf: &~[u8], chars: &mut ~[char])\n+        fn chars_from_bytes<T: Reader>(bytes: &~[u8], chars: &mut ~[char])\n             -> (uint, uint) {\n             let mut i = 0;\n-            let buf_len = buf.len();\n-            while i < buf_len {\n-                let b0 = buf[i];\n+            let bytes_len = bytes.len();\n+            while i < bytes_len {\n+                let b0 = bytes[i];\n                 let w = str::utf8_char_width(b0);\n                 let end = i + w;\n                 i += 1;\n@@ -100,12 +100,12 @@ impl<T: Reader> T : ReaderUtil {\n                     loop;\n                 }\n                 // can't satisfy this char with the existing data\n-                if end > buf_len {\n-                    return (i - 1, end - buf_len);\n+                if end > bytes_len {\n+                    return (i - 1, end - bytes_len);\n                 }\n                 let mut val = 0;\n                 while i < end {\n-                    let next = buf[i] as int;\n+                    let next = bytes[i] as int;\n                     i += 1;\n                     assert (next > -1);\n                     assert (next & 192 == 128);\n@@ -119,8 +119,8 @@ impl<T: Reader> T : ReaderUtil {\n             }\n             return (i, 0);\n         }\n-        let mut buf: ~[u8] = ~[];\n-        let mut chars: ~[char] = ~[];\n+        let mut bytes = ~[];\n+        let mut chars = ~[];\n         // might need more bytes, but reading n will never over-read\n         let mut nbread = n;\n         while nbread > 0 {\n@@ -130,15 +130,15 @@ impl<T: Reader> T : ReaderUtil {\n                 // we're split in a unicode char?\n                 break;\n             }\n-            buf.push_all(data);\n-            let (offset, nbreq) = chars_from_bytes::<T>(&buf, &mut chars);\n+            bytes.push_all(data);\n+            let (offset, nbreq) = chars_from_bytes::<T>(&bytes, &mut chars);\n             let ncreq = n - chars.len();\n             // again we either know we need a certain number of bytes\n             // to complete a character, or we make sure we don't\n             // over-read by reading 1-byte per char needed\n             nbread = if ncreq > nbreq { ncreq } else { nbreq };\n             if nbread > 0 {\n-                buf = vec::slice(buf, offset, buf.len());\n+                bytes = vec::slice(bytes, offset, bytes.len());\n             }\n         }\n         move chars\n@@ -154,12 +154,12 @@ impl<T: Reader> T : ReaderUtil {\n     }\n \n     fn read_c_str() -> ~str {\n-        let mut buf: ~[u8] = ~[];\n+        let mut bytes: ~[u8] = ~[];\n         loop {\n             let ch = self.read_byte();\n-            if ch < 1 { break; } else { buf.push(ch as u8); }\n+            if ch < 1 { break; } else { bytes.push(ch as u8); }\n         }\n-        str::from_bytes(buf)\n+        str::from_bytes(bytes)\n     }\n \n     // FIXME deal with eof? // #2004\n@@ -191,9 +191,9 @@ impl<T: Reader> T : ReaderUtil {\n     }\n \n     fn read_whole_stream() -> ~[u8] {\n-        let mut buf: ~[u8] = ~[];\n-        while !self.eof() { buf.push_all(self.read_bytes(2048u)); }\n-        move buf\n+        let mut bytes: ~[u8] = ~[];\n+        while !self.eof() { bytes.push_all(self.read_bytes(2048u)); }\n+        move bytes\n     }\n \n     fn each_byte(it: fn(int) -> bool) {\n@@ -226,8 +226,8 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n }\n \n impl *libc::FILE: Reader {\n-    fn read(buf: &[mut u8], len: uint) -> uint {\n-        do vec::as_mut_buf(buf) |buf_p, buf_len| {\n+    fn read(bytes: &[mut u8], len: uint) -> uint {\n+        do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n             assert buf_len <= len;\n \n             let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n@@ -250,7 +250,9 @@ impl *libc::FILE: Reader {\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n impl<T: Reader, C> {base: T, cleanup: C}: Reader {\n-    fn read(buf: &[mut u8], len: uint) -> uint { self.base.read(buf, len) }\n+    fn read(bytes: &[mut u8], len: uint) -> uint {\n+        self.base.read(bytes, len)\n+    }\n     fn read_byte() -> int { self.base.read_byte() }\n     fn unread_byte(byte: int) { self.base.unread_byte(byte); }\n     fn eof() -> bool { self.base.eof() }\n@@ -297,39 +299,41 @@ pub fn file_reader(path: &Path) -> Result<Reader, ~str> {\n }\n \n \n-// Byte buffer readers\n-\n-pub type ByteBuf = {buf: &[const u8], mut pos: uint};\n+// Byte readers\n+pub struct BytesReader {\n+    bytes: &[u8],\n+    mut pos: uint\n+}\n \n-impl ByteBuf: Reader {\n-    fn read(buf: &[mut u8], len: uint) -> uint {\n-        let count = uint::min(len, self.buf.len() - self.pos);\n+impl BytesReader: Reader {\n+    fn read(bytes: &[mut u8], len: uint) -> uint {\n+        let count = uint::min(len, self.bytes.len() - self.pos);\n \n-        let view = vec::const_view(self.buf, self.pos, self.buf.len());\n-        vec::bytes::memcpy(buf, view, count);\n+        let view = vec::view(self.bytes, self.pos, self.bytes.len());\n+        vec::bytes::memcpy(bytes, view, count);\n \n         self.pos += count;\n \n         count\n     }\n     fn read_byte() -> int {\n-        if self.pos == self.buf.len() { return -1; }\n-        let b = self.buf[self.pos];\n+        if self.pos == self.bytes.len() { return -1; }\n+        let b = self.bytes[self.pos];\n         self.pos += 1u;\n         return b as int;\n     }\n     // FIXME (#2738): implement this\n     fn unread_byte(_byte: int) { error!(\"Unimplemented: unread_byte\"); fail; }\n-    fn eof() -> bool { self.pos == self.buf.len() }\n+    fn eof() -> bool { self.pos == self.bytes.len() }\n     fn seek(offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n-        self.pos = seek_in_buf(offset, pos, self.buf.len(), whence);\n+        self.pos = seek_in_buf(offset, pos, self.bytes.len(), whence);\n     }\n     fn tell() -> uint { self.pos }\n }\n \n-pub fn with_bytes_reader<t>(bytes: &[u8], f: fn(Reader) -> t) -> t {\n-    f({buf: bytes, mut pos: 0u} as Reader)\n+pub pure fn with_bytes_reader<t>(bytes: &[u8], f: fn(Reader) -> t) -> t {\n+    f(BytesReader { bytes: bytes, pos: 0u } as Reader)\n }\n \n pub fn with_str_reader<T>(s: &str, f: fn(Reader) -> T) -> T {\n@@ -602,10 +606,10 @@ impl<T: Writer> T : WriterUtil {\n         self.write_str(&\"\\n\");\n     }\n     fn write_int(n: int) {\n-        int::to_str_bytes(n, 10u, |buf| self.write(buf))\n+        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n     fn write_uint(n: uint) {\n-        uint::to_str_bytes(false, n, 10u, |buf| self.write(buf))\n+        uint::to_str_bytes(false, n, 10u, |bytes| self.write(bytes))\n     }\n     fn write_le_uint(n: uint) {\n         u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n@@ -687,34 +691,34 @@ pub fn print(s: &str) { stdout().write_str(s); }\n pub fn println(s: &str) { stdout().write_line(s); }\n \n pub struct BytesWriter {\n-    buf: DVec<u8>,\n+    bytes: DVec<u8>,\n     mut pos: uint,\n }\n \n impl BytesWriter: Writer {\n     fn write(v: &[const u8]) {\n-        do self.buf.swap |buf| {\n-            let mut buf <- buf;\n+        do self.bytes.swap |bytes| {\n+            let mut bytes <- bytes;\n             let v_len = v.len();\n-            let buf_len = buf.len();\n+            let bytes_len = bytes.len();\n \n-            let count = uint::max(buf_len, self.pos + v_len);\n-            vec::reserve(&mut buf, count);\n-            unsafe { vec::raw::set_len(&mut buf, count); }\n+            let count = uint::max(bytes_len, self.pos + v_len);\n+            vec::reserve(&mut bytes, count);\n+            unsafe { vec::raw::set_len(&mut bytes, count); }\n \n             {\n-                let view = vec::mut_view(buf, self.pos, count);\n+                let view = vec::mut_view(bytes, self.pos, count);\n                 vec::bytes::memcpy(view, v, v_len);\n             }\n \n             self.pos += v_len;\n \n-            move buf\n+            move bytes\n         }\n     }\n     fn seek(offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n-        let len = self.buf.len();\n+        let len = self.bytes.len();\n         self.pos = seek_in_buf(offset, pos, len, whence);\n     }\n     fn tell() -> uint { self.pos }\n@@ -730,21 +734,25 @@ impl @BytesWriter : Writer {\n     fn get_type() -> WriterType { (*self).get_type() }\n }\n \n-pub fn BytesWriter() -> BytesWriter {\n-    BytesWriter { buf: DVec(), mut pos: 0u }\n+pub pure fn BytesWriter() -> BytesWriter {\n+    BytesWriter { bytes: DVec(), mut pos: 0u }\n }\n \n-pub fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n+pub pure fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n-    wr.buf.check_out(|buf| move buf)\n+    // FIXME (#3758): This should not be needed.\n+    unsafe { wr.bytes.check_out(|bytes| move bytes) }\n }\n \n-pub fn with_str_writer(f: fn(Writer)) -> ~str {\n+pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n-    // Make sure the vector has a trailing null and is proper utf8.\n-    v.push(0);\n+    // FIXME (#3758): This should not be needed.\n+    unsafe {\n+        // Make sure the vector has a trailing null and is proper utf8.\n+        v.push(0);\n+    }\n     assert str::is_utf8(v);\n \n     unsafe { move ::cast::transmute(move v) }\n@@ -975,15 +983,17 @@ mod tests {\n     fn bytes_buffer_overwrite() {\n         let wr = BytesWriter();\n         wr.write(~[0u8, 1u8, 2u8, 3u8]);\n-        assert wr.buf.borrow(|buf| buf == ~[0u8, 1u8, 2u8, 3u8]);\n+        assert wr.bytes.borrow(|bytes| bytes == ~[0u8, 1u8, 2u8, 3u8]);\n         wr.seek(-2, SeekCur);\n         wr.write(~[4u8, 5u8, 6u8, 7u8]);\n-        assert wr.buf.borrow(|buf| buf == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n+        assert wr.bytes.borrow(|bytes| bytes ==\n+            ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n         wr.seek(-2, SeekEnd);\n         wr.write(~[8u8]);\n         wr.seek(1, SeekSet);\n         wr.write(~[9u8]);\n-        assert wr.buf.borrow(|buf| buf == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n+        assert wr.bytes.borrow(|bytes| bytes ==\n+            ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n     }\n }\n "}, {"sha": "958d1ac56ea78101e7911f5f542c7b28b90ac6cd", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -32,7 +32,7 @@ pub fn console_off() {\n #[cfg(notest)]\n #[lang=\"log_type\"]\n pub fn log_type<T>(level: u32, object: &T) {\n-    let bytes = do io::with_bytes_writer() |writer| {\n+    let bytes = do io::with_bytes_writer |writer| {\n         repr::write_repr(writer, object);\n     };\n     unsafe {"}, {"sha": "50489a820291ce244f2817b473b061ddcff7c21f", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -225,7 +225,7 @@ pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n \n pub pure fn unwrap_expect<T>(opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n-    if opt.is_none() { fail reason.to_unique(); }\n+    if opt.is_none() { fail reason.to_owned(); }\n     unwrap(move opt)\n }\n "}, {"sha": "b246adcb1d7cddb6bc0a452c2596239ac80d5fd7", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -559,7 +559,7 @@ impl ReprPrinter {\n         unsafe {\n             self.align(sys::min_align_of::<T>());\n             let value_addr: &T = transmute(copy self.ptr);\n-            (*value_addr).write_repr(self.writer);\n+            value_addr.write_repr(self.writer);\n             self.bump(sys::size_of::<T>());\n             true\n         }"}, {"sha": "3122f3d7f32e2796bd596c37e42f2f074cdffb50", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -2135,7 +2135,7 @@ pub trait StrSlice {\n     pure fn trim() -> ~str;\n     pure fn trim_left() -> ~str;\n     pure fn trim_right() -> ~str;\n-    pure fn to_unique() -> ~str;\n+    pure fn to_owned() -> ~str;\n     pure fn to_managed() -> @str;\n     pure fn char_at(i: uint) -> char;\n }\n@@ -2258,13 +2258,12 @@ impl &str: StrSlice {\n     pure fn trim_right() -> ~str { trim_right(self) }\n \n     #[inline]\n-    pure fn to_unique() -> ~str { self.slice(0, self.len()) }\n+    pure fn to_owned() -> ~str { self.slice(0, self.len()) }\n \n     #[inline]\n     pure fn to_managed() -> @str {\n-        let v = at_vec::from_fn(self.len() + 1, |i| {\n-            if i == self.len() { 0 } else { self[i] }\n-        });\n+        let bytes = as_bytes_slice(self);\n+        let v = at_vec::from_fn(bytes.len(), |i| bytes[i]);\n         unsafe { ::cast::transmute(v) }\n     }\n "}, {"sha": "5f64389e58329a7245c0b853dbc97c302bab145c", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -897,7 +897,7 @@ pub impl Deserializer: serialization::Deserializer {\n                 // FIXME(#3148) This hint should not be necessary.\n                 let obj: &self/~Object = obj;\n \n-                match obj.find_ref(&name.to_unique()) {\n+                match obj.find_ref(&name.to_owned()) {\n                     None => fail fmt!(\"no such field: %s\", name),\n                     Some(json) => {\n                         self.stack.push(json);"}, {"sha": "4bd1679600ffbe917029aad14cbcfa3c8e47a4b4", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -90,9 +90,7 @@ fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n-    let mut mitems = ~[];\n-    for attrs.each |a| { mitems.push(attr_meta(*a)); }\n-    return mitems;\n+    do attrs.map |a| { attr_meta(*a) }\n }\n \n fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {"}, {"sha": "45e7cd4e9d45a47496e9e8ea92a04254ea83643f", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -27,8 +27,7 @@ fn declare_upcalls(targ_cfg: @session::config,\n     fn decl(llmod: ModuleRef, prefix: ~str, name: ~str,\n             tys: ~[TypeRef], rv: TypeRef) ->\n        ValueRef {\n-        let mut arg_tys: ~[TypeRef] = ~[];\n-        for tys.each |t| { arg_tys.push(*t); }\n+        let arg_tys = tys.map(|t| *t);\n         let fn_ty = T_fn(arg_tys, rv);\n         return base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n     }"}, {"sha": "1656efbd9668430bdd675309ce0db5fa19c629d0", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -598,13 +598,12 @@ fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n         let ctor_ty = item_type({crate: cdata.cnum, node: id}, item,\n                                 tcx, cdata);\n         let name = item_name(intr, item);\n-        let mut arg_tys: ~[ty::t] = ~[];\n-        match ty::get(ctor_ty).sty {\n-          ty::ty_fn(f) => {\n-            for f.sig.inputs.each |a| { arg_tys.push(a.ty); }\n-          }\n-          _ => { /* Nullary enum variant. */ }\n-        }\n+        let arg_tys = match ty::get(ctor_ty).sty {\n+          ty::ty_fn(f) => f.sig.inputs.map(|a| a.ty),\n+\n+          // Nullary enum variant.\n+          _ => ~[],\n+        };\n         match variant_disr_val(item) {\n           Some(val) => { disr_val = val; }\n           _         => { /* empty */ }"}, {"sha": "1579705dd0ecb55f1bff27d0647d819526c5e458", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -1162,7 +1162,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n \n     if (parms.tcx.sess.meta_stats()) {\n \n-        do wr.buf.borrow |v| {\n+        do wr.bytes.borrow |v| {\n             do v.each |e| {\n                 if *e == 0 {\n                     ecx.stats.zero_bytes += 1;\n@@ -1195,7 +1195,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n \n     (do str::as_bytes(&~\"rust\\x00\\x00\\x00\\x01\") |bytes| {\n         vec::slice(*bytes, 0, 8)\n-    }) + flate::deflate_bytes(wr.buf.check_out(|buf| buf))\n+    }) + flate::deflate_bytes(wr.bytes.check_out(|buf| buf))\n }\n \n // Get the encoded string for a type"}, {"sha": "ea992600ae19b7a537f7ae1f865c366e20589aa4", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -433,8 +433,7 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n //\n // XXX: Use a small-vector optimization to avoid allocations here.\n fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n-    let mut v: ~[ValueRef] = ~[];\n-    for vec::each(ixs) |i| { v.push(C_i32(*i as i32)); }\n+    let v = do vec::map(ixs) |i| { C_i32(*i as i32) };\n     count_insn(cx, \"gepi\");\n     return InBoundsGEP(cx, base, v);\n }"}, {"sha": "123905adba11b7ffaba7424967a53ebe8a15a408", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -34,9 +34,7 @@ type flag = HashMap<~str, ()>;\n fn field_expr(f: ast::field) -> @ast::expr { return f.node.expr; }\n \n fn field_exprs(fields: ~[ast::field]) -> ~[@ast::expr] {\n-    let mut es = ~[];\n-    for fields.each |f| { es.push(f.node.expr); }\n-    return es;\n+    fields.map(|f| f.node.expr)\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions"}, {"sha": "8207082cf20e69d87142b07ad409d52da04b9272", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141ef23aa714c9572da6fd616e7bdb96ea40ea07/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=141ef23aa714c9572da6fd616e7bdb96ea40ea07", "patch": "@@ -282,8 +282,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n           _ => { }\n         }\n         s += ~\"(\";\n-        let mut strs = ~[];\n-        for inputs.each |a| { strs.push(fn_input_to_str(cx, *a)); }\n+        let strs = inputs.map(|a| fn_input_to_str(cx, *a));\n         s += str::connect(strs, ~\", \");\n         s += ~\")\";\n         if ty::get(output).sty != ty_nil {\n@@ -338,13 +337,11 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_unboxed_vec(tm) => { ~\"unboxed_vec<\" + mt_to_str(cx, tm) + ~\">\" }\n       ty_type => ~\"type\",\n       ty_rec(elems) => {\n-        let mut strs: ~[~str] = ~[];\n-        for elems.each |fld| { strs.push(field_to_str(cx, *fld)); }\n+        let strs = elems.map(|fld| field_to_str(cx, *fld));\n         ~\"{\" + str::connect(strs, ~\",\") + ~\"}\"\n       }\n       ty_tup(elems) => {\n-        let mut strs = ~[];\n-        for elems.each |elem| { strs.push(ty_to_str(cx, *elem)); }\n+        let strs = elems.map(|elem| ty_to_str(cx, *elem));\n         ~\"(\" + str::connect(strs, ~\",\") + ~\")\"\n       }\n       ty_fn(ref f) => {"}]}