{"sha": "48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YTY3MmI0ZWVmYTFjZmU0ZGFkNjJlMzdmODc2OGUyZjVhMGMzNTU=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-14T16:13:15Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-14T16:38:28Z"}, "message": "Move paths to their own module", "tree": {"sha": "4f8194e883618578268dd7494c5d352945bb1514", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f8194e883618578268dd7494c5d352945bb1514"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "html_url": "https://github.com/rust-lang/rust/commit/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d81481bd0d3ba9893b96c9a2dd5f31d96d115e0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d81481bd0d3ba9893b96c9a2dd5f31d96d115e0a", "html_url": "https://github.com/rust-lang/rust/commit/d81481bd0d3ba9893b96c9a2dd5f31d96d115e0a"}], "stats": {"total": 274, "additions": 136, "deletions": 138}, "files": [{"sha": "a41cd141a128dd56c906a4f3256328719ca3913a", "filename": "src/attrs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -7,7 +7,8 @@ use semver::Version;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind};\n use syntax::attr::*;\n use syntax::codemap::Span;\n-use utils::{in_macro, match_path, span_lint, BEGIN_UNWIND};\n+use utils::{in_macro, match_path, span_lint};\n+use utils::paths;\n \n /// **What it does:** This lint checks for items annotated with `#[inline(always)]`, unless the annotated function is empty or simply panics.\n ///\n@@ -129,7 +130,7 @@ fn is_relevant_expr(expr: &Expr) -> bool {\n         ExprRet(None) | ExprBreak(_) => false,\n         ExprCall(ref path_expr, _) => {\n             if let ExprPath(_, ref path) = path_expr.node {\n-                !match_path(path, &BEGIN_UNWIND)\n+                !match_path(path, &paths::BEGIN_UNWIND)\n             } else {\n                 true\n             }"}, {"sha": "c9ac8f0a948b99b1f917dad2d6e4f907bcb59c32", "filename": "src/derive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fderive.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -5,7 +5,7 @@ use rustc::ty;\n use rustc::hir::*;\n use syntax::ast::{Attribute, MetaItemKind};\n use syntax::codemap::Span;\n-use utils::{CLONE_TRAIT_PATH, HASH_PATH};\n+use utils::paths;\n use utils::{match_path, span_lint_and_then};\n \n /// **What it does:** This lint warns about deriving `Hash` but implementing `PartialEq`\n@@ -88,7 +88,7 @@ impl LateLintPass for Derive {\n /// Implementation of the `DERIVE_HASH_XOR_EQ` lint.\n fn check_hash_peq<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>, hash_is_automatically_derived: bool) {\n     if_let_chain! {[\n-        match_path(&trait_ref.path, &HASH_PATH),\n+        match_path(&trait_ref.path, &paths::HASH),\n         let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n     ], {\n         let peq_trait_def = cx.tcx.lookup_trait_def(peq_trait_def_id);\n@@ -129,7 +129,7 @@ fn check_hash_peq<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n-    if match_path(&trait_ref.path, &CLONE_TRAIT_PATH) {\n+    if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n         let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n         let subst_ty = ty.subst(cx.tcx, &parameter_environment.free_substs);\n "}, {"sha": "69156f15f31767defe95506365ccd5b87d66e46c", "filename": "src/drop_ref.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdrop_ref.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -2,8 +2,7 @@ use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n use syntax::codemap::Span;\n-use utils::DROP_PATH;\n-use utils::{match_def_path, span_note_and_lint};\n+use utils::{match_def_path, paths, span_note_and_lint};\n \n /// **What it does:** This lint checks for calls to `std::mem::drop` with a reference instead of an owned value.\n ///\n@@ -37,7 +36,7 @@ impl LateLintPass for DropRefPass {\n         if let ExprCall(ref path, ref args) = expr.node {\n             if let ExprPath(None, _) = path.node {\n                 let def_id = cx.tcx.def_map.borrow()[&path.id].def_id();\n-                if match_def_path(cx, def_id, &DROP_PATH) {\n+                if match_def_path(cx, def_id, &paths::DROP) {\n                     if args.len() != 1 {\n                         return;\n                     }"}, {"sha": "24810e242ad1bd705715a383edb32f5fa200c4ea", "filename": "src/entry.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fentry.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -1,10 +1,9 @@\n-use rustc::lint::*;\n use rustc::hir::*;\n use rustc::hir::intravisit::{Visitor, walk_expr, walk_block};\n+use rustc::lint::*;\n use syntax::codemap::Span;\n use utils::SpanlessEq;\n-use utils::{BTREEMAP_PATH, HASHMAP_PATH};\n-use utils::{get_item_name, match_type, snippet, span_lint_and_then, walk_ptrs_ty};\n+use utils::{get_item_name, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty};\n \n /// **What it does:** This lint checks for uses of `contains_key` + `insert` on `HashMap` or\n /// `BTreeMap`.\n@@ -89,10 +88,10 @@ fn check_cond<'a, 'tcx, 'b>(cx: &'a LateContext<'a, 'tcx>, check: &'b Expr) -> O\n         let map = &params[0];\n         let obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(map));\n \n-        return if match_type(cx, obj_ty, &BTREEMAP_PATH) {\n+        return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n             Some((\"BTreeMap\", map, key))\n         }\n-        else if match_type(cx, obj_ty, &HASHMAP_PATH) {\n+        else if match_type(cx, obj_ty, &paths::HASHMAP) {\n             Some((\"HashMap\", map, key))\n         }\n         else {"}, {"sha": "0726fcaeab71eeb6bd317fb1a7b3f6986f9ccb41", "filename": "src/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformat.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -1,9 +1,9 @@\n+use rustc::hir::*;\n use rustc::hir::map::Node::NodeItem;\n use rustc::lint::*;\n use rustc::ty::TypeVariants;\n-use rustc::hir::*;\n use syntax::ast::LitKind;\n-use utils::{DISPLAY_FMT_METHOD_PATH, FMT_ARGUMENTS_NEWV1_PATH, STRING_PATH};\n+use utils::paths;\n use utils::{is_expn_of, match_path, match_type, span_lint, walk_ptrs_ty};\n \n /// **What it does:** This lints about use of `format!(\"string literal with no argument\")` and\n@@ -40,7 +40,7 @@ impl LateLintPass for FormatMacLint {\n                     if_let_chain!{[\n                         let ExprPath(_, ref path) = fun.node,\n                         args.len() == 2,\n-                        match_path(path, &FMT_ARGUMENTS_NEWV1_PATH),\n+                        match_path(path, &paths::FMT_ARGUMENTS_NEWV1),\n                         // ensure the format string is `\"{..}\"` with only one argument and no text\n                         check_static_str(cx, &args[0]),\n                         // ensure the format argument is `{}` ie. Display with no fancy option\n@@ -108,11 +108,11 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         let ExprCall(_, ref args) = exprs[0].node,\n         args.len() == 2,\n         let ExprPath(None, ref path) = args[1].node,\n-        match_path(path, &DISPLAY_FMT_METHOD_PATH)\n+        match_path(path, &paths::DISPLAY_FMT_METHOD)\n     ], {\n         let ty = walk_ptrs_ty(cx.tcx.pat_ty(&pat[0]));\n \n-        return ty.sty == TypeVariants::TyStr || match_type(cx, ty, &STRING_PATH);\n+        return ty.sty == TypeVariants::TyStr || match_type(cx, ty, &paths::STRING);\n     }}\n \n     false"}, {"sha": "4fb45e7c19864be9ee1e58170d7c8656ed1d2acc", "filename": "src/loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -16,7 +16,7 @@ use syntax::ast;\n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, in_external_macro,\n             span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then,\n             unsugar_range, walk_ptrs_ty, recover_for_loop};\n-use utils::{BTREEMAP_PATH, HASHMAP_PATH, LL_PATH, OPTION_PATH, RESULT_PATH, VEC_PATH};\n+use utils::paths;\n use utils::UnsugaredRange;\n \n /// **What it does:** This lint checks for looping over the range of `0..len` of some collection just to get the values by index.\n@@ -505,7 +505,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n /// Check for `for` loops over `Option`s and `Results`\n fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n     let ty = cx.tcx.expr_ty(arg);\n-    if match_type(cx, ty, &OPTION_PATH) {\n+    if match_type(cx, ty, &paths::OPTION) {\n         span_help_and_lint(cx,\n                            FOR_LOOP_OVER_OPTION,\n                            arg.span,\n@@ -515,7 +515,7 @@ fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n                            &format!(\"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n                                     snippet(cx, pat.span, \"_\"),\n                                     snippet(cx, arg.span, \"_\")));\n-    } else if match_type(cx, ty, &RESULT_PATH) {\n+    } else if match_type(cx, ty, &paths::RESULT) {\n         span_help_and_lint(cx,\n                            FOR_LOOP_OVER_RESULT,\n                            arg.span,\n@@ -589,7 +589,7 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n             };\n \n             let ty = walk_ptrs_ty(cx.tcx.expr_ty(arg));\n-            if match_type(cx, ty, &HASHMAP_PATH) || match_type(cx, ty, &BTREEMAP_PATH) {\n+            if match_type(cx, ty, &paths::HASHMAP) || match_type(cx, ty, &paths::BTREEMAP) {\n                 span_lint_and_then(cx,\n                                    FOR_KV_MAP,\n                                    expr.span,\n@@ -735,13 +735,13 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     // will allow further borrows afterwards\n     let ty = cx.tcx.expr_ty(e);\n     is_iterable_array(ty) ||\n-    match_type(cx, ty, &VEC_PATH) ||\n-    match_type(cx, ty, &LL_PATH) ||\n-    match_type(cx, ty, &HASHMAP_PATH) ||\n+    match_type(cx, ty, &paths::VEC) ||\n+    match_type(cx, ty, &paths::LL) ||\n+    match_type(cx, ty, &paths::HASHMAP) ||\n     match_type(cx, ty, &[\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"]) ||\n     match_type(cx, ty, &[\"collections\", \"vec_deque\", \"VecDeque\"]) ||\n     match_type(cx, ty, &[\"collections\", \"binary_heap\", \"BinaryHeap\"]) ||\n-    match_type(cx, ty, &BTREEMAP_PATH) ||\n+    match_type(cx, ty, &paths::BTREEMAP) ||\n     match_type(cx, ty, &[\"collections\", \"btree\", \"set\", \"BTreeSet\"])\n }\n "}, {"sha": "caefb64eb5f1f45b412b6a6965d15dfa2a0a9440", "filename": "src/map_clone.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -1,8 +1,7 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use utils::{CLONE_PATH, OPTION_PATH};\n-use utils::{is_adjusted, match_path, match_trait_method, match_type, snippet, span_help_and_lint, walk_ptrs_ty,\n-            walk_ptrs_ty_depth};\n+use utils::{is_adjusted, match_path, match_trait_method, match_type, paths, snippet,\n+            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n \n /// **What it does:** This lint checks for mapping clone() over an iterator.\n ///\n@@ -65,7 +64,7 @@ impl LateLintPass for MapClonePass {\n                         }\n                     }\n                     ExprPath(_, ref path) => {\n-                        if match_path(path, &CLONE_PATH) {\n+                        if match_path(path, &paths::CLONE) {\n                             let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n                             span_help_and_lint(cx,\n                                                MAP_CLONE,\n@@ -99,7 +98,7 @@ fn expr_eq_ident(expr: &Expr, id: Ident) -> bool {\n fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n     if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n         Some(\"iterator\")\n-    } else if match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(arg)), &OPTION_PATH) {\n+    } else if match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(arg)), &paths::OPTION) {\n         Some(\"Option\")\n     } else {\n         None"}, {"sha": "c1692ee47d298d2991478c2e923ddbac87e3d850", "filename": "src/matches.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -8,7 +8,7 @@ use rustc_const_math::ConstInt;\n use std::cmp::Ordering;\n use syntax::ast::LitKind;\n use syntax::codemap::Span;\n-use utils::{COW_PATH, OPTION_PATH, RESULT_PATH};\n+use utils::paths;\n use utils::{match_type, snippet, span_note_and_lint, span_lint_and_then, in_external_macro, expr_block};\n \n /// **What it does:** This lint checks for matches with a single arm where an `if let` will usually suffice.\n@@ -184,13 +184,13 @@ fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n \n fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: ty::Ty, els: Option<&Expr>) {\n     // list of candidate Enums we know will never get any more members\n-    let candidates = &[(&COW_PATH, \"Borrowed\"),\n-                       (&COW_PATH, \"Cow::Borrowed\"),\n-                       (&COW_PATH, \"Cow::Owned\"),\n-                       (&COW_PATH, \"Owned\"),\n-                       (&OPTION_PATH, \"None\"),\n-                       (&RESULT_PATH, \"Err\"),\n-                       (&RESULT_PATH, \"Ok\")];\n+    let candidates = &[(&paths::COW, \"Borrowed\"),\n+                       (&paths::COW, \"Cow::Borrowed\"),\n+                       (&paths::COW, \"Cow::Owned\"),\n+                       (&paths::COW, \"Owned\"),\n+                       (&paths::OPTION, \"None\"),\n+                       (&paths::RESULT, \"Err\"),\n+                       (&paths::RESULT, \"Ok\")];\n \n     let path = match arms[1].pats[0].node {\n         PatKind::TupleStruct(ref path, Some(ref inner)) => {"}, {"sha": "d2a91b615ae570b4daad0fd528e214f7eafd5df9", "filename": "src/methods.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -13,9 +13,8 @@ use syntax::ptr::P;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path, match_trait_method,\n             match_type, method_chain_args, return_ty, same_tys, snippet, snippet_opt, span_lint,\n             span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n-use utils::{CSTRING_NEW_PATH, BTREEMAP_ENTRY_PATH, DEFAULT_TRAIT_PATH, HASHMAP_ENTRY_PATH,\n-            OPTION_PATH, RESULT_PATH, VEC_PATH};\n use utils::MethodArgs;\n+use utils::paths;\n \n #[derive(Clone)]\n pub struct MethodsPass;\n@@ -470,7 +469,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tcx.expr_ty(arg);\n-                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &DEFAULT_TRAIT_PATH) {\n+                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n                         default_trait_id\n                     } else {\n                         return false;\n@@ -497,13 +496,13 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n     fn check_general_case(cx: &LateContext, name: &str, fun: &Expr, self_expr: &Expr, arg: &Expr, or_has_args: bool,\n                           span: Span) {\n         // (path, fn_has_argument, methods)\n-        let know_types: &[(&[_], _, &[_], _)] = &[(&BTREEMAP_ENTRY_PATH, false, &[\"or_insert\"], \"with\"),\n-                                                  (&HASHMAP_ENTRY_PATH, false, &[\"or_insert\"], \"with\"),\n-                                                  (&OPTION_PATH,\n+        let know_types: &[(&[_], _, &[_], _)] = &[(&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+                                                  (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+                                                  (&paths::OPTION,\n                                                    false,\n                                                    &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"],\n                                                    \"else\"),\n-                                                  (&RESULT_PATH, true, &[\"or\", \"unwrap_or\"], \"else\")];\n+                                                  (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\")];\n \n         let self_ty = cx.tcx.expr_ty(self_expr);\n \n@@ -571,7 +570,7 @@ fn lint_clone_double_ref(cx: &LateContext, expr: &Expr, arg: &Expr) {\n \n fn lint_extend(cx: &LateContext, expr: &Expr, args: &MethodArgs) {\n     let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n-    if !match_type(cx, obj_ty, &VEC_PATH) {\n+    if !match_type(cx, obj_ty, &paths::VEC) {\n         return;\n     }\n     let arg_ty = cx.tcx.expr_ty(&args[1]);\n@@ -591,7 +590,7 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &Expr, new: &Expr, unwrap: &Expr)\n         let ExprCall(ref fun, ref args) = new.node,\n         args.len() == 1,\n         let ExprPath(None, ref path) = fun.node,\n-        match_path(path, &CSTRING_NEW_PATH),\n+        match_path(path, &paths::CSTRING_NEW),\n     ], {\n         span_lint_and_then(cx, TEMPORARY_CSTRING_AS_PTR, expr.span,\n                            \"you are getting the inner pointer of a temporary `CString`\",\n@@ -606,7 +605,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty) -> Option<(Span,\n     fn may_slice(cx: &LateContext, ty: &ty::Ty) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n-            ty::TyStruct(..) => match_type(cx, ty, &VEC_PATH),\n+            ty::TyStruct(..) => match_type(cx, ty, &paths::VEC),\n             ty::TyArray(_, size) => size < 32,\n             ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) |\n             ty::TyBox(ref inner) => may_slice(cx, inner),\n@@ -641,9 +640,9 @@ fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty) -> Option<(Span,\n fn lint_unwrap(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs) {\n     let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&unwrap_args[0]));\n \n-    let mess = if match_type(cx, obj_ty, &OPTION_PATH) {\n+    let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n         Some((OPTION_UNWRAP_USED, \"an Option\", \"None\"))\n-    } else if match_type(cx, obj_ty, &RESULT_PATH) {\n+    } else if match_type(cx, obj_ty, &paths::RESULT) {\n         Some((RESULT_UNWRAP_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n@@ -666,7 +665,7 @@ fn lint_unwrap(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs) {\n /// lint use of `ok().expect()` for `Result`s\n fn lint_ok_expect(cx: &LateContext, expr: &Expr, ok_args: &MethodArgs) {\n     // lint if the caller of `ok()` is a `Result`\n-    if match_type(cx, cx.tcx.expr_ty(&ok_args[0]), &RESULT_PATH) {\n+    if match_type(cx, cx.tcx.expr_ty(&ok_args[0]), &paths::RESULT) {\n         let result_type = cx.tcx.expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type) {\n             if has_debug_impl(error_type, cx) {\n@@ -684,7 +683,7 @@ fn lint_ok_expect(cx: &LateContext, expr: &Expr, ok_args: &MethodArgs) {\n /// lint use of `map().unwrap_or()` for `Option`s\n fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n+    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n         let msg = \"called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling \\\n                    `map_or(a, f)` instead\";\n@@ -715,7 +714,7 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, map_args: &MethodArgs, unwr\n /// lint use of `map().unwrap_or_else()` for `Option`s\n fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n+    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n         let msg = \"called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling \\\n                    `map_or_else(g, f)` instead\";\n@@ -842,7 +841,7 @@ fn lint_single_char_pattern(cx: &LateContext, expr: &Expr, arg: &Expr) {\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n-    if !match_type(cx, ty, &RESULT_PATH) {\n+    if !match_type(cx, ty, &paths::RESULT) {\n         return None;\n     }\n     if let ty::TyEnum(_, substs) = ty.sty {\n@@ -853,7 +852,7 @@ fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     None\n }\n \n-/// This checks whether a given type is known to implement `Debug`.\n+/// This checks whether a given type is known to implement Debug.\n fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     match cx.tcx.lang_items.debug_trait() {\n         Some(debug) => implements_trait(cx, ty, debug, Vec::new()),"}, {"sha": "7d637adb8b8b05a4b55563dbb7d8559cdae87c32", "filename": "src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmutex_atomic.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::subst::ParamSpace;\n use rustc::ty;\n use rustc::hir::Expr;\n use syntax::ast;\n-use utils::{span_lint, MUTEX_PATH, match_type};\n+use utils::{match_type, paths, span_lint};\n \n /// **What it does:** This lint checks for usages of `Mutex<X>` where an atomic will do.\n ///\n@@ -47,7 +47,7 @@ impl LateLintPass for MutexAtomic {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         let ty = cx.tcx.expr_ty(expr);\n         if let ty::TyStruct(_, subst) = ty.sty {\n-            if match_type(cx, ty, &MUTEX_PATH) {\n+            if match_type(cx, ty, &paths::MUTEX) {\n                 let mutex_param = &subst.types.get(ParamSpace::TypeSpace, 0).sty;\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n                     let msg = format!(\"Consider using an {} instead of a Mutex here. If you just want the locking \\"}, {"sha": "f42b1d0d74a5bb92e957480253ebdc06ce8226d1", "filename": "src/new_without_default.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnew_without_default.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -1,10 +1,10 @@\n-use rustc::lint::*;\n-use rustc::hir;\n use rustc::hir::intravisit::FnKind;\n+use rustc::hir;\n+use rustc::lint::*;\n use syntax::ast;\n use syntax::codemap::Span;\n-use utils::{get_trait_def_id, implements_trait, in_external_macro, return_ty, same_tys, span_lint,\n-            DEFAULT_TRAIT_PATH};\n+use utils::paths;\n+use utils::{get_trait_def_id, implements_trait, in_external_macro, return_ty, same_tys, span_lint};\n \n /// **What it does:** This lints about type with a `fn new() -> Self` method and no `Default`\n /// implementation.\n@@ -54,7 +54,7 @@ impl LateLintPass for NewWithoutDefault {\n                     self_ty.walk_shallow().next().is_none(), // implements_trait does not work with generics\n                     let Some(ret_ty) = return_ty(cx, id),\n                     same_tys(cx, self_ty, ret_ty, id),\n-                    let Some(default_trait_id) = get_trait_def_id(cx, &DEFAULT_TRAIT_PATH),\n+                    let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT),\n                     !implements_trait(cx, self_ty, default_trait_id, Vec::new())\n                 ], {\n                     span_lint(cx, NEW_WITHOUT_DEFAULT, span,"}, {"sha": "aaaebe5b2f8bc2b390dcd8626f05d47859a9a5fd", "filename": "src/open_options.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fopen_options.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -1,8 +1,8 @@\n-use rustc::lint::*;\n use rustc::hir::{Expr, ExprMethodCall, ExprLit};\n+use rustc::lint::*;\n use syntax::ast::LitKind;\n use syntax::codemap::{Span, Spanned};\n-use utils::{walk_ptrs_ty_depth, match_type, span_lint, OPEN_OPTIONS_PATH};\n+use utils::{match_type, paths, span_lint, walk_ptrs_ty_depth};\n \n /// **What it does:** This lint checks for duplicate open options as well as combinations that make no sense.\n ///\n@@ -31,7 +31,7 @@ impl LateLintPass for NonSensicalOpenOptions {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&arguments[0]));\n-            if name.node.as_str() == \"open\" && match_type(cx, obj_ty, &OPEN_OPTIONS_PATH) {\n+            if name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n                 check_open_options(cx, &options, e.span);\n@@ -61,7 +61,7 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n         let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n-        if match_type(cx, obj_ty, &OPEN_OPTIONS_PATH) && arguments.len() >= 2 {\n+        if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n \n             let argument_option = match arguments[1].node {\n                 ExprLit(ref span) => {"}, {"sha": "78499fa1a1aa7bdc77d2992032897d87b31801be", "filename": "src/panic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpanic.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -1,7 +1,7 @@\n-use rustc::lint::*;\n use rustc::hir::*;\n+use rustc::lint::*;\n use syntax::ast::LitKind;\n-use utils::{span_lint, is_direct_expn_of, match_path, BEGIN_UNWIND};\n+use utils::{is_direct_expn_of, match_path, paths, span_lint};\n \n /// **What it does:** This lint checks for missing parameters in `panic!`.\n ///\n@@ -33,7 +33,7 @@ impl LateLintPass for PanicPass {\n             let ExprCall(ref fun, ref params) = ex.node,\n             params.len() == 2,\n             let ExprPath(None, ref path) = fun.node,\n-            match_path(path, &BEGIN_UNWIND),\n+            match_path(path, &paths::BEGIN_UNWIND),\n             let ExprLit(ref lit) = params[0].node,\n             is_direct_expn_of(cx, params[0].span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,"}, {"sha": "d426286dba480fe3cac36de26344e1601218f404", "filename": "src/print.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprint.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -1,7 +1,7 @@\n+use rustc::hir::*;\n use rustc::hir::map::Node::{NodeItem, NodeImplItem};\n use rustc::lint::*;\n-use rustc::hir::*;\n-use utils::{FMT_ARGUMENTV1_NEW_PATH, DEBUG_FMT_METHOD_PATH, IO_PRINT_PATH};\n+use utils::paths;\n use utils::{is_expn_of, match_path, span_lint};\n \n /// **What it does:** This lint warns whenever you print on *stdout*. The purpose of this lint is to catch debugging remnants.\n@@ -45,7 +45,7 @@ impl LateLintPass for PrintLint {\n             if let ExprPath(_, ref path) = fun.node {\n                 // Search for `std::io::_print(..)` which is unique in a\n                 // `print!` expansion.\n-                if match_path(path, &IO_PRINT_PATH) {\n+                if match_path(path, &paths::IO_PRINT) {\n                     if let Some(span) = is_expn_of(cx, expr.span, \"print\") {\n                         // `println!` uses `print!`.\n                         let (span, name) = match is_expn_of(cx, span, \"println\") {\n@@ -58,9 +58,9 @@ impl LateLintPass for PrintLint {\n                 }\n                 // Search for something like\n                 // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n-                else if args.len() == 2 && match_path(path, &FMT_ARGUMENTV1_NEW_PATH) {\n+                else if args.len() == 2 && match_path(path, &paths::FMT_ARGUMENTV1_NEW) {\n                     if let ExprPath(None, ref path) = args[1].node {\n-                        if match_path(path, &DEBUG_FMT_METHOD_PATH) && !is_in_debug_impl(cx, expr) &&\n+                        if match_path(path, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n                            is_expn_of(cx, expr.span, \"panic\").is_none() {\n                             span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n                         }"}, {"sha": "addcfc9e84d1b9e4701908cb06012206cdb70fd1", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -1,12 +1,11 @@\n //! Checks for usage of  `&Vec[_]` and `&String`.\n \n+use rustc::hir::*;\n use rustc::hir::map::NodeItem;\n use rustc::lint::*;\n use rustc::ty;\n-use rustc::hir::*;\n use syntax::ast::NodeId;\n-use utils::{STRING_PATH, VEC_PATH};\n-use utils::{span_lint, match_type};\n+use utils::{match_type, paths, span_lint};\n \n /// **What it does:** This lint checks for function arguments of type `&String` or `&Vec` unless the references are mutable.\n ///\n@@ -61,13 +60,13 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n \n     for (arg, ty) in decl.inputs.iter().zip(&fn_ty.inputs) {\n         if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {\n-            if match_type(cx, ty, &VEC_PATH) {\n+            if match_type(cx, ty, &paths::VEC) {\n                 span_lint(cx,\n                           PTR_ARG,\n                           arg.ty.span,\n                           \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n                            with non-Vec-based slices. Consider changing the type to `&[...]`\");\n-            } else if match_type(cx, ty, &STRING_PATH) {\n+            } else if match_type(cx, ty, &paths::STRING) {\n                 span_lint(cx,\n                           PTR_ARG,\n                           arg.ty.span,"}, {"sha": "177f7a7b04580d4dca18bbb1464e56d666c6f268", "filename": "src/regex.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fregex.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -9,7 +9,8 @@ use std::error::Error;\n use syntax::ast::{LitKind, NodeId};\n use syntax::codemap::{Span, BytePos};\n use syntax::parse::token::InternedString;\n-use utils::{is_expn_of, match_path, match_type, REGEX_NEW_PATH, span_lint, span_help_and_lint};\n+use utils::paths;\n+use utils::{is_expn_of, match_path, match_type, span_lint, span_help_and_lint};\n \n /// **What it does:** This lint checks `Regex::new(_)` invocations for correct regex syntax.\n ///\n@@ -97,7 +98,7 @@ impl LateLintPass for RegexPass {\n         if_let_chain!{[\n             let ExprCall(ref fun, ref args) = expr.node,\n             let ExprPath(_, ref path) = fun.node,\n-            match_path(path, &REGEX_NEW_PATH) && args.len() == 1\n+            match_path(path, &paths::REGEX_NEW) && args.len() == 1\n         ], {\n             if let ExprLit(ref lit) = args[0].node {\n                 if let LitKind::Str(ref r, _) = lit.node {"}, {"sha": "a6808d2dd421c1201d510b759444f9d5f2b7ccbb", "filename": "src/strings.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -3,12 +3,11 @@\n //! Note that since we have two lints where one subsumes the other, we try to\n //! disable the subsumed lint unless it has a higher level\n \n-use rustc::lint::*;\n use rustc::hir::*;\n+use rustc::lint::*;\n use syntax::codemap::Spanned;\n-use utils::STRING_PATH;\n use utils::SpanlessEq;\n-use utils::{match_type, span_lint, span_lint_and_then, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, paths, span_lint, span_lint_and_then, walk_ptrs_ty, get_parent_expr};\n \n /// **What it does:** This lint matches code of the form `x = x + y` (without `let`!).\n ///\n@@ -108,7 +107,7 @@ impl LateLintPass for StringAdd {\n }\n \n fn is_string(cx: &LateContext, e: &Expr) -> bool {\n-    match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(e)), &STRING_PATH)\n+    match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(e)), &paths::STRING)\n }\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {"}, {"sha": "8b74b1989dbdff81203c5b954db8c3b2ea7027b2", "filename": "src/transmute.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftransmute.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -2,8 +2,7 @@ use rustc::lint::*;\n use rustc::ty::TypeVariants::{TyRawPtr, TyRef};\n use rustc::ty;\n use rustc::hir::*;\n-use utils::TRANSMUTE_PATH;\n-use utils::{match_def_path, snippet_opt, span_lint, span_lint_and_then};\n+use utils::{match_def_path, paths, snippet_opt, span_lint, span_lint_and_then};\n \n /// **What it does:** This lint checks for transmutes to the original type of the object.\n ///\n@@ -67,7 +66,7 @@ impl LateLintPass for Transmute {\n             if let ExprPath(None, _) = path_expr.node {\n                 let def_id = cx.tcx.def_map.borrow()[&path_expr.id].def_id();\n \n-                if match_def_path(cx, def_id, &TRANSMUTE_PATH) {\n+                if match_def_path(cx, def_id, &paths::TRANSMUTE) {\n                     let from_ty = cx.tcx.expr_ty(&args[0]);\n                     let to_ty = cx.tcx.expr_ty(e);\n "}, {"sha": "00b36f1f5d4d285a9fc42205dfd25d788a95444f", "filename": "src/types.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -6,7 +6,9 @@ use rustc::ty;\n use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::codemap::Span;\n-use utils::*;\n+use utils::{comparisons, in_external_macro, in_macro, is_from_for_desugar, match_def_path, snippet,\n+            span_help_and_lint, span_lint};\n+use utils::paths;\n \n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n@@ -63,7 +65,7 @@ impl LateLintPass for TypePass {\n                             let Some(ref vec) = ag.types.get(0),\n                             let Some(did) = cx.tcx.def_map.borrow().get(&vec.id),\n                             let def::Def::Struct(..) = did.full_def(),\n-                            match_def_path(cx, did.def_id(), &VEC_PATH),\n+                            match_def_path(cx, did.def_id(), &paths::VEC),\n                         ],\n                         {\n                             span_help_and_lint(cx,\n@@ -73,7 +75,7 @@ impl LateLintPass for TypePass {\n                                                \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n                         }\n                     }\n-                } else if match_def_path(cx, did.def_id(), &LL_PATH) {\n+                } else if match_def_path(cx, did.def_id(), &paths::LL) {\n                     span_help_and_lint(cx,\n                                        LINKEDLIST,\n                                        ast_ty.span,"}, {"sha": "d01b0698de80e659528282e8df8b3abe2d5b83ba", "filename": "src/utils/mod.rs", "status": "modified", "additions": 8, "deletions": 43, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -22,45 +22,10 @@ use syntax::ptr::P;\n pub mod comparisons;\n pub mod conf;\n mod hir;\n+pub mod paths;\n pub use self::hir::{SpanlessEq, SpanlessHash};\n-pub type MethodArgs = HirVec<P<Expr>>;\n \n-// module DefPaths for certain structs/enums we check for\n-pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n-pub const BOX_NEW_PATH: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n-pub const BOX_PATH: [&'static str; 3] = [\"std\", \"boxed\", \"Box\"];\n-pub const BTREEMAP_ENTRY_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n-pub const BTREEMAP_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n-pub const CLONE_PATH: [&'static str; 3] = [\"clone\", \"Clone\", \"clone\"];\n-pub const CLONE_TRAIT_PATH: [&'static str; 2] = [\"clone\", \"Clone\"];\n-pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n-pub const CSTRING_NEW_PATH: [&'static str; 4] = [\"std\", \"ffi\", \"CString\", \"new\"];\n-pub const DEBUG_FMT_METHOD_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"Debug\", \"fmt\"];\n-pub const DEFAULT_TRAIT_PATH: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n-pub const DISPLAY_FMT_METHOD_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"Display\", \"fmt\"];\n-pub const DROP_PATH: [&'static str; 3] = [\"core\", \"mem\", \"drop\"];\n-pub const FMT_ARGUMENTS_NEWV1_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"Arguments\", \"new_v1\"];\n-pub const FMT_ARGUMENTV1_NEW_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"ArgumentV1\", \"new\"];\n-pub const HASHMAP_ENTRY_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n-pub const HASHMAP_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n-pub const HASH_PATH: [&'static str; 2] = [\"hash\", \"Hash\"];\n-pub const IO_PRINT_PATH: [&'static str; 3] = [\"std\", \"io\", \"_print\"];\n-pub const LL_PATH: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n-pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n-pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n-pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n-pub const RANGE_FROM_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n-pub const RANGE_FULL_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n-pub const RANGE_INCLUSIVE_NON_EMPTY_PATH: [&'static str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n-pub const RANGE_PATH: [&'static str; 3] = [\"std\", \"ops\", \"Range\"];\n-pub const RANGE_TO_INCLUSIVE_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n-pub const RANGE_TO_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n-pub const REGEX_NEW_PATH: [&'static str; 3] = [\"regex\", \"Regex\", \"new\"];\n-pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n-pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n-pub const TRANSMUTE_PATH: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n-pub const VEC_FROM_ELEM_PATH: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];\n-pub const VEC_PATH: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n+pub type MethodArgs = HirVec<P<Expr>>;\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n@@ -764,22 +729,22 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n \n     match unwrap_unstable(&expr).node {\n         ExprPath(None, ref path) => {\n-            if match_path(path, &RANGE_FULL_PATH) {\n+            if match_path(path, &paths::RANGE_FULL) {\n                 Some(UnsugaredRange { start: None, end: None, limits: RangeLimits::HalfOpen })\n             } else {\n                 None\n             }\n         }\n         ExprStruct(ref path, ref fields, None) => {\n-            if match_path(path, &RANGE_FROM_PATH) {\n+            if match_path(path, &paths::RANGE_FROM) {\n                 Some(UnsugaredRange { start: get_field(\"start\", fields), end: None, limits: RangeLimits::HalfOpen })\n-            } else if match_path(path, &RANGE_INCLUSIVE_NON_EMPTY_PATH) {\n+            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n                 Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n-            } else if match_path(path, &RANGE_PATH) {\n+            } else if match_path(path, &paths::RANGE) {\n                 Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n-            } else if match_path(path, &RANGE_TO_INCLUSIVE_PATH) {\n+            } else if match_path(path, &paths::RANGE_TO_INCLUSIVE) {\n                 Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n-            } else if match_path(path, &RANGE_TO_PATH) {\n+            } else if match_path(path, &paths::RANGE_TO) {\n                 Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n             } else {\n                 None"}, {"sha": "94f1d17f27a9f9ea1d93741a5fa1803f21611704", "filename": "src/utils/paths.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fpaths.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -0,0 +1,37 @@\n+//! This module contains paths to types and functions Clippy needs to know about.\n+\n+pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n+pub const BOX_NEW: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n+pub const BOX: [&'static str; 3] = [\"std\", \"boxed\", \"Box\"];\n+pub const BTREEMAP_ENTRY: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n+pub const BTREEMAP: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n+pub const CLONE: [&'static str; 3] = [\"clone\", \"Clone\", \"clone\"];\n+pub const CLONE_TRAIT: [&'static str; 2] = [\"clone\", \"Clone\"];\n+pub const COW: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n+pub const CSTRING_NEW: [&'static str; 4] = [\"std\", \"ffi\", \"CString\", \"new\"];\n+pub const DEBUG_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Debug\", \"fmt\"];\n+pub const DEFAULT_TRAIT: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n+pub const DISPLAY_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Display\", \"fmt\"];\n+pub const DROP: [&'static str; 3] = [\"core\", \"mem\", \"drop\"];\n+pub const FMT_ARGUMENTS_NEWV1: [&'static str; 4] = [\"std\", \"fmt\", \"Arguments\", \"new_v1\"];\n+pub const FMT_ARGUMENTV1_NEW: [&'static str; 4] = [\"std\", \"fmt\", \"ArgumentV1\", \"new\"];\n+pub const HASHMAP_ENTRY: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n+pub const HASHMAP: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n+pub const HASH: [&'static str; 2] = [\"hash\", \"Hash\"];\n+pub const IO_PRINT: [&'static str; 3] = [\"std\", \"io\", \"_print\"];\n+pub const LL: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+pub const MUTEX: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n+pub const OPEN_OPTIONS: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n+pub const OPTION: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RANGE_FROM: [&'static str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n+pub const RANGE_FULL: [&'static str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n+pub const RANGE_INCLUSIVE_NON_EMPTY: [&'static str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n+pub const RANGE: [&'static str; 3] = [\"std\", \"ops\", \"Range\"];\n+pub const RANGE_TO_INCLUSIVE: [&'static str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n+pub const RANGE_TO: [&'static str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n+pub const REGEX_NEW: [&'static str; 3] = [\"regex\", \"Regex\", \"new\"];\n+pub const RESULT: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n+pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n+pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n+pub const VEC_FROM_ELEM: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];\n+pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];"}, {"sha": "513efa1a2a4fd7611b1395522632ade8ec1f426a", "filename": "src/vec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a672b4eefa1cfe4dad62e37f8768e2f5a0c355/src%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvec.rs?ref=48a672b4eefa1cfe4dad62e37f8768e2f5a0c355", "patch": "@@ -3,8 +3,7 @@ use rustc::ty::TypeVariants;\n use rustc::hir::*;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n-use utils::VEC_FROM_ELEM_PATH;\n-use utils::{is_expn_of, match_path, recover_for_loop, snippet, span_lint_and_then};\n+use utils::{is_expn_of, match_path, paths, recover_for_loop, snippet, span_lint_and_then};\n \n /// **What it does:** This lint warns about using `&vec![..]` when using `&[..]` would be possible.\n ///\n@@ -92,7 +91,7 @@ pub fn unexpand_vec<'e>(cx: &LateContext, expr: &'e Expr) -> Option<VecArgs<'e>>\n         let ExprPath(_, ref path) = fun.node,\n         is_expn_of(cx, fun.span, \"vec\").is_some()\n     ], {\n-        return if match_path(path, &VEC_FROM_ELEM_PATH) && args.len() == 2 {\n+        return if match_path(path, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n             // `vec![elem; size]` case\n             Some(VecArgs::Repeat(&args[0], &args[1]))\n         }"}]}