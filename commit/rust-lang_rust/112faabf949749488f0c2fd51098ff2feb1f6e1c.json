{"sha": "112faabf949749488f0c2fd51098ff2feb1f6e1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMmZhYWJmOTQ5NzQ5NDg4ZjBjMmZkNTEwOThmZjJmZWIxZjZlMWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-26T15:02:46Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-14T09:21:57Z"}, "message": "Update guide/intro to take into account the removal of `proc`.\n\ncc @steveklabnick", "tree": {"sha": "f643471e4325ad6762c111b7d67a8805050afa23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f643471e4325ad6762c111b7d67a8805050afa23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/112faabf949749488f0c2fd51098ff2feb1f6e1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/112faabf949749488f0c2fd51098ff2feb1f6e1c", "html_url": "https://github.com/rust-lang/rust/commit/112faabf949749488f0c2fd51098ff2feb1f6e1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/112faabf949749488f0c2fd51098ff2feb1f6e1c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27676d9aa96bd68f8560ade8b9fa61c9298874ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/27676d9aa96bd68f8560ade8b9fa61c9298874ea", "html_url": "https://github.com/rust-lang/rust/commit/27676d9aa96bd68f8560ade8b9fa61c9298874ea"}], "stats": {"total": 198, "additions": 80, "deletions": 118}, "files": [{"sha": "4adca43be18e946baa973d260903aedad5af58a3", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/112faabf949749488f0c2fd51098ff2feb1f6e1c/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/112faabf949749488f0c2fd51098ff2feb1f6e1c/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=112faabf949749488f0c2fd51098ff2feb1f6e1c", "patch": "@@ -30,7 +30,7 @@ fn print_message() { println!(\"I am running in a different task!\"); }\n spawn(print_message);\n \n // Alternatively, use a `move ||` expression instead of a named function.\n-// `||` expressions evaluate to an unnamed closures. The `move` keyword\n+// `||` expressions evaluate to an unnamed closure. The `move` keyword\n // indicates that the closure should take ownership of any variables it\n // touches.\n spawn(move || println!(\"I am also running in a different task!\"));\n@@ -44,7 +44,7 @@ details to the standard library.\n The `spawn` function has the type signature: `fn\n spawn<F:FnOnce()+Send>(f: F)`.  This indicates that it takes as\n argument a closure (of type `F`) that it will run exactly once. This\n-closure is limited to capturing `Send`-able data form its environment\n+closure is limited to capturing `Send`-able data from its environment\n (that is, data which is deeply owned). Limiting the closure to `Send`\n ensures that `spawn` can safely move the entire closure and all its\n associated state into an entirely different task for execution."}, {"sha": "6e178a2648dbfb1ab20c2bb1db9c56b2c553a266", "filename": "src/doc/guide.md", "status": "modified", "additions": 34, "deletions": 51, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/112faabf949749488f0c2fd51098ff2feb1f6e1c/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/112faabf949749488f0c2fd51098ff2feb1f6e1c/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=112faabf949749488f0c2fd51098ff2feb1f6e1c", "patch": "@@ -4235,36 +4235,16 @@ fn main() {\n }\n ```\n \n-## Procs\n+## Moving closures\n \n-Rust has a second type of closure, called a **proc**. Procs are created\n-with the `proc` keyword:\n-\n-```{rust}\n-let x = 5i;\n-\n-let p = proc() { x * x };\n-println!(\"{}\", p()); // prints 25\n-```\n-\n-There is a big difference between procs and closures: procs may only be called once. This\n-will error when we try to compile:\n-\n-```{rust,ignore}\n-let x = 5i;\n-\n-let p = proc() { x * x };\n-println!(\"{}\", p());\n-println!(\"{}\", p()); // error: use of moved value `p`\n-```\n-\n-This restriction is important. Procs are allowed to consume values that they\n-capture, and thus have to be restricted to being called once for soundness\n-reasons: any value consumed would be invalid on a second call.\n-\n-Procs are most useful with Rust's concurrency features, and so we'll just leave\n-it at this for now. We'll talk about them more in the \"Tasks\" section of the\n-guide.\n+Rust has a second type of closure, called a **moving closure**. Moving\n+closures are indicated using the `move` keyword (e.g., `move || x *\n+x`). The difference between a moving closure and an ordinary closure\n+is that a moving closure always takes ownership of all variables that\n+it uses. Ordinary closures, in contrast, just create a reference into\n+the enclosing stack frame. Moving closures are most useful with Rust's\n+concurrency features, and so we'll just leave it at this for\n+now. We'll talk about them more in the \"Tasks\" section of the guide.\n \n ## Accepting closures as arguments\n \n@@ -5231,28 +5211,30 @@ concurrency libraries can be written for Rust to help in specific scenarios.\n Here's an example of creating a task:\n \n ```{rust}\n-spawn(proc() {\n+spawn(move || {\n     println!(\"Hello from a task!\");\n });\n ```\n \n-The `spawn` function takes a proc as an argument, and runs that proc in a new\n-task. A proc takes ownership of its entire environment, and so any variables\n-that you use inside the proc will not be usable afterward:\n+The `spawn` function takes a closure as an argument, and runs that\n+closure in a new task. Typically, you will want to use a moving\n+closure, so that the closure takes ownership of any variables that it\n+touches.  This implies that those variables are not usable from the\n+parent task after the child task is spawned:\n \n ```{rust,ignore}\n let mut x = vec![1i, 2i, 3i];\n \n-spawn(proc() {\n+spawn(move || {\n     println!(\"The value of x[0] is: {}\", x[0]);\n });\n \n println!(\"The value of x[0] is: {}\", x[0]); // error: use of moved value: `x`\n ```\n \n-`x` is now owned by the proc, and so we can't use it anymore. Many other\n-languages would let us do this, but it's not safe to do so. Rust's borrow\n-checker catches the error.\n+`x` is now owned by the closure, and so we can't use it anymore. Many\n+other languages would let us do this, but it's not safe to do\n+so. Rust's borrow checker catches the error.\n \n If tasks were only able to capture these values, they wouldn't be very useful.\n Luckily, tasks can communicate with each other through **channel**s. Channels\n@@ -5261,7 +5243,7 @@ work like this:\n ```{rust}\n let (tx, rx) = channel();\n \n-spawn(proc() {\n+spawn(move || {\n     tx.send(\"Hello from a task!\".to_string());\n });\n \n@@ -5281,7 +5263,7 @@ If you want to send messages to the task as well, create two channels!\n let (tx1, rx1) = channel();\n let (tx2, rx2) = channel();\n \n-spawn(proc() {\n+spawn(move || {\n     tx1.send(\"Hello from a task!\".to_string());\n     let message = rx2.recv();\n     println!(\"{}\", message);\n@@ -5293,8 +5275,9 @@ println!(\"{}\", message);\n tx2.send(\"Goodbye from main!\".to_string());\n ```\n \n-The proc has one sending end and one receiving end, and the main task has one\n-of each as well. Now they can talk back and forth in whatever way they wish.\n+The closure has one sending end and one receiving end, and the main\n+task has one of each as well. Now they can talk back and forth in\n+whatever way they wish.\n \n Notice as well that because `Sender` and `Receiver` are generic, while you can\n pass any kind of information through the channel, the ends are strongly typed.\n@@ -5310,34 +5293,34 @@ a useful thing to use:\n ```{rust}\n use std::sync::Future;\n \n-let mut delayed_value = Future::spawn(proc() {\n+let mut delayed_value = Future::spawn(move || {\n     // just return anything for examples' sake\n \n     12345i\n });\n println!(\"value = {}\", delayed_value.get());\n ```\n \n-Calling `Future::spawn` works just like `spawn()`: it takes a proc. In this\n-case, though, you don't need to mess with the channel: just have the proc\n-return the value.\n+Calling `Future::spawn` works just like `spawn()`: it takes a\n+closure. In this case, though, you don't need to mess with the\n+channel: just have the closure return the value.\n \n `Future::spawn` will return a value which we can bind with `let`. It needs\n to be mutable, because once the value is computed, it saves a copy of the\n value, and if it were immutable, it couldn't update itself.\n \n-The proc will go on processing in the background, and when we need the final\n-value, we can call `get()` on it. This will block until the result is done,\n-but if it's finished computing in the background, we'll just get the value\n-immediately.\n+The future will go on processing in the background, and when we need\n+the final value, we can call `get()` on it. This will block until the\n+result is done, but if it's finished computing in the background,\n+we'll just get the value immediately.\n \n ## Success and failure\n \n Tasks don't always succeed, they can also panic. A task that wishes to panic\n can call the `panic!` macro, passing a message:\n \n ```{rust}\n-spawn(proc() {\n+spawn(move || {\n     panic!(\"Nope.\");\n });\n ```\n@@ -5349,7 +5332,7 @@ notify other tasks that it has panicked. We can do this with `task::try`:\n use std::task;\n use std::rand;\n \n-let result = task::try(proc() {\n+let result = task::try(move || {\n     if rand::random() {\n         println!(\"OK\");\n     } else {"}, {"sha": "c0a1d5fa8816f7e9e6a2936bbc93b8389af3f13f", "filename": "src/doc/intro.md", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/112faabf949749488f0c2fd51098ff2feb1f6e1c/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/112faabf949749488f0c2fd51098ff2feb1f6e1c/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=112faabf949749488f0c2fd51098ff2feb1f6e1c", "patch": "@@ -391,26 +391,29 @@ Here's an example of a concurrent Rust program:\n ```{rust}\n fn main() {\n     for _ in range(0u, 10u) {\n-        spawn(proc() {\n+        spawn(move || {\n             println!(\"Hello, world!\");\n         });\n     }\n }\n ```\n \n-This program creates ten threads, who all print `Hello, world!`. The `spawn`\n-function takes one argument, a `proc`. 'proc' is short for 'procedure,' and is\n-a form of closure. This closure is executed in a new thread, created by `spawn`\n-itself.\n-\n-One common form of problem in concurrent programs is a 'data race.' This occurs\n-when two different threads attempt to access the same location in memory in a\n-non-synchronized way, where at least one of them is a write. If one thread is\n-attempting to read, and one thread is attempting to write, you cannot be sure\n-that your data will not be corrupted. Note the first half of that requirement:\n-two threads that attempt to access the same location in memory. Rust's\n-ownership model can track which pointers own which memory locations, which\n-solves this problem.\n+This program creates ten threads, who all print `Hello, world!`. The\n+`spawn` function takes one argument, a closure, indicated by the\n+double bars `||`. (The `move` keyword indicates that the closure takes\n+ownership of any data it uses; we'll have more on the significance of\n+this shortly.) This closure is executed in a new thread created by\n+`spawn`.\n+\n+One common form of problem in concurrent programs is a 'data race.'\n+This occurs when two different threads attempt to access the same\n+location in memory in a non-synchronized way, where at least one of\n+them is a write. If one thread is attempting to read, and one thread\n+is attempting to write, you cannot be sure that your data will not be\n+corrupted. Note the first half of that requirement: two threads that\n+attempt to access the same location in memory. Rust's ownership model\n+can track which pointers own which memory locations, which solves this\n+problem.\n \n Let's see an example. This Rust code will not compile:\n \n@@ -419,7 +422,7 @@ fn main() {\n     let mut numbers = vec![1i, 2i, 3i];\n \n     for i in range(0u, 3u) {\n-        spawn(proc() {\n+        spawn(move || {\n             for j in range(0, 3) { numbers[j] += 1 }\n         });\n     }\n@@ -432,20 +435,25 @@ It gives us this error:\n 6:71 error: capture of moved value: `numbers`\n     for j in range(0, 3) { numbers[j] += 1 }\n                ^~~~~~~\n-7:50 note: `numbers` moved into closure environment here because it has type `proc():Send`, which is non-copyable (perhaps you meant to use clone()?)\n-    spawn(proc() {\n+7:50 note: `numbers` moved into closure environment here\n+    spawn(move || {\n         for j in range(0, 3) { numbers[j] += 1 }\n     });\n 6:79 error: cannot assign to immutable dereference (dereference is implicit, due to indexing)\n         for j in range(0, 3) { numbers[j] += 1 }\n                            ^~~~~~~~~~~~~~~\n ```\n \n-It mentions that \"numbers moved into closure environment\". Because we referred\n-to `numbers` inside of our `proc`, and we create three `proc`s, we would have\n-three references. Rust detects this and gives us the error: we claim that\n-`numbers` has ownership, but our code tries to make three owners. This may\n-cause a safety problem, so Rust disallows it.\n+It mentions that \"numbers moved into closure environment\". Because we\n+declared the closure as a moving closure, and it referred to\n+`numbers`, the closure will try to take ownership of the vector. But\n+the closure itself is created in a loop, and hence we will actually\n+create three closures, one for every iteration of the loop. This means\n+that all three of those closures would try to own `numbers`, which is\n+impossible -- `numbers` must have just one owner. Rust detects this\n+and gives us the error: we claim that `numbers` has ownership, but our\n+code tries to make three owners. This may cause a safety problem, so\n+Rust disallows it.\n \n What to do here? Rust has two types that helps us: `Arc<T>` and `Mutex<T>`.\n \"Arc\" stands for \"atomically reference counted.\" In other words, an Arc will\n@@ -468,7 +476,7 @@ fn main() {\n \n     for i in range(0u, 3u) {\n         let number = numbers.clone();\n-        spawn(proc() {\n+        spawn(move || {\n             let mut array = number.lock();\n \n             (*array)[i] += 1;\n@@ -528,7 +536,7 @@ fn main() {\n     let vec = vec![1i, 2, 3];\n \n     for i in range(1u, 3) {\n-        spawn(proc() {\n+        spawn(move || {\n             println!(\"{}\", vec[i]);\n         });\n     }"}, {"sha": "c24cd6d8bf3911f9a1d5bc4527a67f27fd88910c", "filename": "src/doc/reference.md", "status": "modified", "additions": 12, "deletions": 41, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/112faabf949749488f0c2fd51098ff2feb1f6e1c/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/112faabf949749488f0c2fd51098ff2feb1f6e1c/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=112faabf949749488f0c2fd51098ff2feb1f6e1c", "patch": "@@ -187,19 +187,18 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n \n <p id=\"keyword-table-marker\"></p>\n \n-|          |          |          |          |        |\n-|----------|----------|----------|----------|--------|\n-| abstract | alignof  | as       | be       | box    |\n-| break    | const    | continue | crate    | do     |\n-| else     | enum     | extern   | false    | final  |\n-| fn       | for      | if       | impl     | in     |\n-| let      | loop     | match    | mod      | move   |\n-| mut      | offsetof | once     | override | priv   |\n-| proc     | pub      | pure     | ref      | return |\n-| sizeof   | static   | self     | struct   | super  |\n-| true     | trait    | type     | typeof   | unsafe |\n-| unsized  | use      | virtual  | where    | while  |\n-| yield    |          |          |          |        |\n+|          |          |          |          |         |\n+|----------|----------|----------|----------|---------|\n+| abstract | alignof  | as       | be       | box     |\n+| break    | const    | continue | crate    | do      |\n+| else     | enum     | extern   | false    | final   |\n+| fn       | for      | if       | impl     | in      |\n+| let      | loop     | match    | mod      | move    |\n+| mut      | offsetof | once     | override | priv    |\n+| pub      | pure     | ref      | return   | sizeof  |\n+| static   | self     | struct   | super    | true    |\n+| trait    | type     | typeof   | unsafe   | unsized |\n+| use      | virtual  | where    | while    | yield   |\n \n \n Each of these keywords has special meaning in its grammar, and all of them are\n@@ -3842,8 +3841,6 @@ x = bo(5,7);\n ```{.ebnf .notation}\n closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'\n                 [ ':' bound-list ] [ '->' type ]\n-procedure_type := 'proc' [ '<' lifetime-list '>' ] '(' arg-list ')'\n-                  [ ':' bound-list ] [ '->' type ]\n lifetime-list := lifetime | lifetime ',' lifetime-list\n arg-list := ident ':' type | ident ':' type ',' arg-list\n bound-list := bound | bound '+' bound-list\n@@ -3852,8 +3849,6 @@ bound := path | lifetime\n \n The type of a closure mapping an input of type `A` to an output of type `B` is\n `|A| -> B`. A closure with no arguments or return values has type `||`.\n-Similarly, a procedure mapping `A` to `B` is `proc(A) -> B` and a no-argument\n-and no-return value closure has type `proc()`.\n \n An example of creating and calling a closure:\n \n@@ -3876,30 +3871,6 @@ call_closure(closure_no_args, closure_args);\n \n ```\n \n-Unlike closures, procedures may only be invoked once, but own their\n-environment, and are allowed to move out of their environment. Procedures are\n-allocated on the heap (unlike closures). An example of creating and calling a\n-procedure:\n-\n-```rust\n-let string = \"Hello\".to_string();\n-\n-// Creates a new procedure, passing it to the `spawn` function.\n-spawn(proc() {\n-  println!(\"{} world!\", string);\n-});\n-\n-// the variable `string` has been moved into the previous procedure, so it is\n-// no longer usable.\n-\n-\n-// Create an invoke a procedure. Note that the procedure is *moved* when\n-// invoked, so it cannot be invoked again.\n-let f = proc(n: int) { n + 22 };\n-println!(\"answer: {}\", f(20));\n-\n-```\n-\n ### Object types\n \n Every trait item (see [traits](#traits)) defines a type with the same name as"}]}