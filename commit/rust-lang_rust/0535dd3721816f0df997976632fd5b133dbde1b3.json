{"sha": "0535dd3721816f0df997976632fd5b133dbde1b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MzVkZDM3MjE4MTZmMGRmOTk3OTc2NjMyZmQ1YjEzM2RiZGUxYjM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-22T10:44:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-14T13:17:13Z"}, "message": "Split librustc_infer.", "tree": {"sha": "8133562b593a3c5c6a3a3c5ebb8ed2f0d2b00592", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8133562b593a3c5c6a3a3c5ebb8ed2f0d2b00592"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0535dd3721816f0df997976632fd5b133dbde1b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0535dd3721816f0df997976632fd5b133dbde1b3", "html_url": "https://github.com/rust-lang/rust/commit/0535dd3721816f0df997976632fd5b133dbde1b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0535dd3721816f0df997976632fd5b133dbde1b3/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1e3d556bffa1a3a5a80fe1c5687cd2f062ce30d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1e3d556bffa1a3a5a80fe1c5687cd2f062ce30d", "html_url": "https://github.com/rust-lang/rust/commit/c1e3d556bffa1a3a5a80fe1c5687cd2f062ce30d"}], "stats": {"total": 3709, "additions": 2245, "deletions": 1464}, "files": [{"sha": "f453705db9e58b001cac44852163d1f26278952f", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -4129,11 +4129,13 @@ name = \"rustc_trait_selection\"\n version = \"0.0.0\"\n dependencies = [\n  \"fmt_macros\",\n+ \"graphviz\",\n  \"log\",\n  \"rustc\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\","}, {"sha": "9322df48235113a0ff1aa039ce3adc17cf2ebc1c", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -14,7 +14,7 @@ use crate::infer::canonical::{\n };\n use crate::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n-use crate::infer::{InferCtxt, InferCtxtBuilder, InferOk, InferResult, NLLRegionVariableOrigin};\n+use crate::infer::{InferCtxt, InferOk, InferResult, NLLRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n use crate::traits::{DomainGoal, TraitEngine};\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n@@ -26,52 +26,8 @@ use rustc::ty::{self, BoundVar, Ty, TyCtxt};\n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n-use rustc_span::DUMMY_SP;\n use std::fmt::Debug;\n \n-impl<'tcx> InferCtxtBuilder<'tcx> {\n-    /// The \"main method\" for a canonicalized trait query. Given the\n-    /// canonical key `canonical_key`, this method will create a new\n-    /// inference context, instantiate the key, and run your operation\n-    /// `op`. The operation should yield up a result (of type `R`) as\n-    /// well as a set of trait obligations that must be fully\n-    /// satisfied. These obligations will be processed and the\n-    /// canonical result created.\n-    ///\n-    /// Returns `NoSolution` in the event of any error.\n-    ///\n-    /// (It might be mildly nicer to implement this on `TyCtxt`, and\n-    /// not `InferCtxtBuilder`, but that is a bit tricky right now.\n-    /// In part because we would need a `for<'tcx>` sort of\n-    /// bound for the closure and in part because it is convenient to\n-    /// have `'tcx` be free on this function so that we can talk about\n-    /// `K: TypeFoldable<'tcx>`.)\n-    pub fn enter_canonical_trait_query<K, R>(\n-        &mut self,\n-        canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'_, 'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n-    where\n-        K: TypeFoldable<'tcx>,\n-        R: Debug + TypeFoldable<'tcx>,\n-        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable,\n-    {\n-        self.enter_with_canonical(\n-            DUMMY_SP,\n-            canonical_key,\n-            |ref infcx, key, canonical_inference_vars| {\n-                let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n-                let value = operation(infcx, &mut *fulfill_cx, key)?;\n-                infcx.make_canonicalized_query_response(\n-                    canonical_inference_vars,\n-                    value,\n-                    &mut *fulfill_cx,\n-                )\n-            },\n-        )\n-    }\n-}\n-\n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// This method is meant to be invoked as the final step of a canonical query\n     /// implementation. It is given:"}, {"sha": "4a39403f211cc437948864a6e966fc3bed943f32", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -2156,7 +2156,7 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n /// This is a bare signal of what kind of type we're dealing with. `ty::TyKind` tracks\n /// extra information about each type, but we only care about the category.\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-crate enum TyCategory {\n+pub enum TyCategory {\n     Closure,\n     Opaque,\n     Generator,"}, {"sha": "9ae131c568d0dcf16a2da5e39ee74515d54d1b35", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 49, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -13,11 +13,11 @@ use rustc::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc::middle::free_region::RegionRelations;\n-use rustc::middle::lang_items;\n use rustc::middle::region;\n use rustc::mir;\n use rustc::mir::interpret::ConstEvalResult;\n use rustc::session::config::BorrowckMode;\n+use rustc::traits::select;\n use rustc::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::relate::RelateResult;\n@@ -58,7 +58,6 @@ pub mod lattice;\n mod lexical_region_resolve;\n mod lub;\n pub mod nll_relate;\n-pub mod opaque_types;\n pub mod outlives;\n pub mod region_constraints;\n pub mod resolve;\n@@ -215,10 +214,10 @@ pub struct InferCtxt<'a, 'tcx> {\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n-    pub selection_cache: traits::SelectionCache<'tcx>,\n+    pub selection_cache: select::SelectionCache<'tcx>,\n \n     /// Caches the results of trait evaluation.\n-    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n+    pub evaluation_cache: select::EvaluationCache<'tcx>,\n \n     /// the set of predicates on which errors have been reported, to\n     /// avoid reporting the same error twice.\n@@ -1474,27 +1473,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .verify_generic_bound(origin, kind, a, bound);\n     }\n \n-    pub fn type_is_copy_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool {\n-        let ty = self.resolve_vars_if_possible(&ty);\n-\n-        if !(param_env, ty).has_local_value() {\n-            return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n-        }\n-\n-        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n-\n-        // This can get called from typeck (by euv), and `moves_by_default`\n-        // rightly refuses to work with inference variables, but\n-        // moves_by_default has a cache, which we want to use in other\n-        // cases.\n-        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id, span)\n-    }\n-\n     /// Obtains the latest type of the given closure; this may be a\n     /// closure in the current function, in which case its\n     /// `ClosureKind` may not yet be known.\n@@ -1518,30 +1496,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         closure_sig_ty.fn_sig(self.tcx)\n     }\n \n-    /// Normalizes associated types in `value`, potentially returning\n-    /// new obligations that must further be processed.\n-    pub fn partially_normalize_associated_types_in<T>(\n-        &self,\n-        span: Span,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n-    ) -> InferOk<'tcx, T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n-        let mut selcx = traits::SelectionContext::new(self);\n-        let cause = ObligationCause::misc(span, body_id);\n-        let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, param_env, cause, value);\n-        debug!(\n-            \"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n-            value, obligations\n-        );\n-        InferOk { value, obligations }\n-    }\n-\n     /// Clears the selection, evaluation, and projection caches. This is useful when\n     /// repeatedly attempting to select an `Obligation` while changing only\n     /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing."}, {"sha": "6c1e86bf408b0d97422e4f3512e4610c92466572", "filename": "src/librustc_infer/infer/outlives/env.rs", "status": "modified", "additions": 6, "deletions": 37, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -1,10 +1,9 @@\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n+use rustc::ty;\n use rustc::ty::free_region_map::FreeRegionMap;\n-use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_span::Span;\n \n use super::explicit_outlives_bounds;\n \n@@ -144,39 +143,6 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n         self.region_bound_pairs_accum.truncate(len);\n     }\n \n-    /// This method adds \"implied bounds\" into the outlives environment.\n-    /// Implied bounds are outlives relationships that we can deduce\n-    /// on the basis that certain types must be well-formed -- these are\n-    /// either the types that appear in the function signature or else\n-    /// the input types to an impl. For example, if you have a function\n-    /// like\n-    ///\n-    /// ```\n-    /// fn foo<'a, 'b, T>(x: &'a &'b [T]) { }\n-    /// ```\n-    ///\n-    /// we can assume in the caller's body that `'b: 'a` and that `T:\n-    /// 'b` (and hence, transitively, that `T: 'a`). This method would\n-    /// add those assumptions into the outlives-environment.\n-    ///\n-    /// Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n-    pub fn add_implied_bounds(\n-        &mut self,\n-        infcx: &InferCtxt<'a, 'tcx>,\n-        fn_sig_tys: &[Ty<'tcx>],\n-        body_id: hir::HirId,\n-        span: Span,\n-    ) {\n-        debug!(\"add_implied_bounds()\");\n-\n-        for &ty in fn_sig_tys {\n-            let ty = infcx.resolve_vars_if_possible(&ty);\n-            debug!(\"add_implied_bounds: ty = {}\", ty);\n-            let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);\n-            self.add_outlives_bounds(Some(infcx), implied_bounds)\n-        }\n-    }\n-\n     /// Save the current set of region-bound pairs under the given `body_id`.\n     pub fn save_implied_bounds(&mut self, body_id: hir::HirId) {\n         let old =\n@@ -190,8 +156,11 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n     /// contain inference variables, it must be supplied, in which\n     /// case we will register \"givens\" on the inference context. (See\n     /// `RegionConstraintData`.)\n-    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'a, 'tcx>>, outlives_bounds: I)\n-    where\n+    pub fn add_outlives_bounds<I>(\n+        &mut self,\n+        infcx: Option<&InferCtxt<'a, 'tcx>>,\n+        outlives_bounds: I,\n+    ) where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n         // Record relationships such as `T:'x` that don't go into the"}, {"sha": "9ad722342a19ebad877383914d9fb97fdedbd8bb", "filename": "src/librustc_infer/traits/engine.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fengine.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -0,0 +1,78 @@\n+use crate::infer::InferCtxt;\n+use crate::traits::Obligation;\n+use rustc::ty::{self, ToPredicate, Ty, WithConstness};\n+use rustc_hir::def_id::DefId;\n+\n+use super::FulfillmentError;\n+use super::{ObligationCause, PredicateObligation};\n+\n+pub trait TraitEngine<'tcx>: 'tcx {\n+    fn normalize_projection_type(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+    ) -> Ty<'tcx>;\n+\n+    /// Requires that `ty` must implement the trait with `def_id` in\n+    /// the given environment. This trait must not have any type\n+    /// parameters (except for `Self`).\n+    fn register_bound(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        def_id: DefId,\n+        cause: ObligationCause<'tcx>,\n+    ) {\n+        let trait_ref = ty::TraitRef { def_id, substs: infcx.tcx.mk_substs_trait(ty, &[]) };\n+        self.register_predicate_obligation(\n+            infcx,\n+            Obligation {\n+                cause,\n+                recursion_depth: 0,\n+                param_env,\n+                predicate: trait_ref.without_const().to_predicate(),\n+            },\n+        );\n+    }\n+\n+    fn register_predicate_obligation(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    );\n+\n+    fn select_all_or_error(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n+\n+    fn select_where_possible(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n+\n+    fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n+}\n+\n+pub trait TraitEngineExt<'tcx> {\n+    fn register_predicate_obligations(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n+    );\n+}\n+\n+impl<T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n+    fn register_predicate_obligations(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n+    ) {\n+        for obligation in obligations {\n+            self.register_predicate_obligation(infcx, obligation);\n+        }\n+    }\n+}"}, {"sha": "8943ce4e6c505c5f9d0abcef7f4ea8c19638d583", "filename": "src/librustc_infer/traits/error_reporting/mod.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -0,0 +1,106 @@\n+use super::ObjectSafetyViolation;\n+\n+use crate::infer::InferCtxt;\n+use rustc::ty::TyCtxt;\n+use rustc_ast::ast;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::Span;\n+use std::fmt;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn report_extra_impl_obligation(\n+        &self,\n+        error_span: Span,\n+        item_name: ast::Name,\n+        _impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+        requirement: &dyn fmt::Display,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let msg = \"impl has stricter requirements than trait\";\n+        let sp = self.tcx.sess.source_map().def_span(error_span);\n+\n+        let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n+\n+        if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n+            let span = self.tcx.sess.source_map().def_span(trait_item_span);\n+            err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n+        }\n+\n+        err.span_label(sp, format!(\"impl has extra requirement {}\", requirement));\n+\n+        err\n+    }\n+}\n+\n+pub fn report_object_safety_error(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    trait_def_id: DefId,\n+    violations: Vec<ObjectSafetyViolation>,\n+) -> DiagnosticBuilder<'tcx> {\n+    let trait_str = tcx.def_path_str(trait_def_id);\n+    let trait_span = tcx.hir().get_if_local(trait_def_id).and_then(|node| match node {\n+        hir::Node::Item(item) => Some(item.ident.span),\n+        _ => None,\n+    });\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0038,\n+        \"the trait `{}` cannot be made into an object\",\n+        trait_str\n+    );\n+    err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n+\n+    let mut reported_violations = FxHashSet::default();\n+    let mut had_span_label = false;\n+    for violation in violations {\n+        if let ObjectSafetyViolation::SizedSelf(sp) = &violation {\n+            if !sp.is_empty() {\n+                // Do not report `SizedSelf` without spans pointing at `SizedSelf` obligations\n+                // with a `Span`.\n+                reported_violations.insert(ObjectSafetyViolation::SizedSelf(vec![].into()));\n+            }\n+        }\n+        if reported_violations.insert(violation.clone()) {\n+            let spans = violation.spans();\n+            let msg = if trait_span.is_none() || spans.is_empty() {\n+                format!(\"the trait cannot be made into an object because {}\", violation.error_msg())\n+            } else {\n+                had_span_label = true;\n+                format!(\"...because {}\", violation.error_msg())\n+            };\n+            if spans.is_empty() {\n+                err.note(&msg);\n+            } else {\n+                for span in spans {\n+                    err.span_label(span, &msg);\n+                }\n+            }\n+            match (trait_span, violation.solution()) {\n+                (Some(_), Some((note, None))) => {\n+                    err.help(&note);\n+                }\n+                (Some(_), Some((note, Some((sugg, span))))) => {\n+                    err.span_suggestion(span, &note, sugg, Applicability::MachineApplicable);\n+                }\n+                // Only provide the help if its a local trait, otherwise it's not actionable.\n+                _ => {}\n+            }\n+        }\n+    }\n+    if let (Some(trait_span), true) = (trait_span, had_span_label) {\n+        err.span_label(trait_span, \"this trait cannot be made into an object...\");\n+    }\n+\n+    if tcx.sess.trait_methods_not_found.borrow().contains(&span) {\n+        // Avoid emitting error caused by non-existing method (#58734)\n+        err.cancel();\n+    }\n+\n+    err\n+}"}, {"sha": "1c0785497be221501de17896961466a5558ffbb1", "filename": "src/librustc_infer/traits/mod.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -0,0 +1,136 @@\n+//! Trait Resolution. See the [rustc guide] for more information on how this works.\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n+\n+mod engine;\n+pub mod error_reporting;\n+mod project;\n+mod structural_impls;\n+mod util;\n+\n+use rustc::ty::error::{ExpectedFound, TypeError};\n+use rustc::ty::{self, Ty};\n+use rustc_hir as hir;\n+use rustc_span::Span;\n+\n+pub use self::FulfillmentErrorCode::*;\n+pub use self::ObligationCauseCode::*;\n+pub use self::SelectionError::*;\n+pub use self::Vtable::*;\n+\n+pub use self::engine::{TraitEngine, TraitEngineExt};\n+pub use self::project::MismatchedProjectionTypes;\n+pub use self::project::{\n+    Normalized, NormalizedTy, ProjectionCache, ProjectionCacheEntry, ProjectionCacheKey,\n+    ProjectionCacheSnapshot, Reveal,\n+};\n+crate use self::util::elaborate_predicates;\n+\n+pub use rustc::traits::*;\n+\n+/// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n+/// which the vtable must be found. The process of finding a vtable is\n+/// called \"resolving\" the `Obligation`. This process consists of\n+/// either identifying an `impl` (e.g., `impl Eq for int`) that\n+/// provides the required vtable, or else finding a bound that is in\n+/// scope. The eventual result is usually a `Selection` (defined below).\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct Obligation<'tcx, T> {\n+    /// The reason we have to prove this thing.\n+    pub cause: ObligationCause<'tcx>,\n+\n+    /// The environment in which we should prove this thing.\n+    pub param_env: ty::ParamEnv<'tcx>,\n+\n+    /// The thing we are trying to prove.\n+    pub predicate: T,\n+\n+    /// If we started proving this as a result of trying to prove\n+    /// something else, track the total depth to ensure termination.\n+    /// If this goes over a certain threshold, we abort compilation --\n+    /// in such cases, we can not say whether or not the predicate\n+    /// holds for certain. Stupid halting problem; such a drag.\n+    pub recursion_depth: usize,\n+}\n+\n+pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n+pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n+\n+// `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PredicateObligation<'_>, 112);\n+\n+pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n+pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n+pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n+\n+pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n+\n+pub struct FulfillmentError<'tcx> {\n+    pub obligation: PredicateObligation<'tcx>,\n+    pub code: FulfillmentErrorCode<'tcx>,\n+    /// Diagnostics only: we opportunistically change the `code.span` when we encounter an\n+    /// obligation error caused by a call argument. When this is the case, we also signal that in\n+    /// this field to ensure accuracy of suggestions.\n+    pub points_at_arg_span: bool,\n+}\n+\n+#[derive(Clone)]\n+pub enum FulfillmentErrorCode<'tcx> {\n+    CodeSelectionError(SelectionError<'tcx>),\n+    CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n+    CodeSubtypeError(ExpectedFound<Ty<'tcx>>, TypeError<'tcx>), // always comes from a SubtypePredicate\n+    CodeAmbiguity,\n+}\n+\n+impl<'tcx, O> Obligation<'tcx, O> {\n+    pub fn new(\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: O,\n+    ) -> Obligation<'tcx, O> {\n+        Obligation { cause, param_env, recursion_depth: 0, predicate }\n+    }\n+\n+    pub fn with_depth(\n+        cause: ObligationCause<'tcx>,\n+        recursion_depth: usize,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: O,\n+    ) -> Obligation<'tcx, O> {\n+        Obligation { cause, param_env, recursion_depth, predicate }\n+    }\n+\n+    pub fn misc(\n+        span: Span,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        trait_ref: O,\n+    ) -> Obligation<'tcx, O> {\n+        Obligation::new(ObligationCause::misc(span, body_id), param_env, trait_ref)\n+    }\n+\n+    pub fn with<P>(&self, value: P) -> Obligation<'tcx, P> {\n+        Obligation {\n+            cause: self.cause.clone(),\n+            param_env: self.param_env,\n+            recursion_depth: self.recursion_depth,\n+            predicate: value,\n+        }\n+    }\n+}\n+\n+impl<'tcx> FulfillmentError<'tcx> {\n+    pub fn new(\n+        obligation: PredicateObligation<'tcx>,\n+        code: FulfillmentErrorCode<'tcx>,\n+    ) -> FulfillmentError<'tcx> {\n+        FulfillmentError { obligation, code, points_at_arg_span: false }\n+    }\n+}\n+\n+impl<'tcx> TraitObligation<'tcx> {\n+    pub fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+        self.predicate.map_bound(|p| p.self_ty())\n+    }\n+}"}, {"sha": "183e4be189022df4e6a6b7ab89b869e30bd50ca6", "filename": "src/librustc_infer/traits/project.rs", "status": "renamed", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -65,7 +65,13 @@ pub struct ProjectionCache<'tcx> {\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct ProjectionCacheKey<'tcx> {\n-    pub ty: ty::ProjectionTy<'tcx>,\n+    ty: ty::ProjectionTy<'tcx>,\n+}\n+\n+impl ProjectionCacheKey<'tcx> {\n+    pub fn new(ty: ty::ProjectionTy<'tcx>) -> Self {\n+        Self { ty }\n+    }\n }\n \n #[derive(Clone, Debug)]", "previous_filename": "src/librustc_trait_selection/traits/projection_cache.rs"}, {"sha": "6630f664f96e4ac9d93049e51d04f7b107003dfd", "filename": "src/librustc_infer/traits/structural_impls.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -1,5 +1,5 @@\n use crate::traits;\n-use crate::traits::Normalized;\n+use crate::traits::project::Normalized;\n use rustc::ty;\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n ", "previous_filename": "src/librustc_trait_selection/traits/structural_impls.rs"}, {"sha": "a7c0267111522eee1f7cee40e439c24cce5833c4", "filename": "src/librustc_infer/traits/util.rs", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -0,0 +1,225 @@\n+use smallvec::smallvec;\n+\n+use rustc::ty::outlives::Component;\n+use rustc::ty::{self, ToPolyTraitRef, TyCtxt};\n+use rustc_data_structures::fx::FxHashSet;\n+\n+fn anonymize_predicate<'tcx>(tcx: TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+    match *pred {\n+        ty::Predicate::Trait(ref data, constness) => {\n+            ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data), constness)\n+        }\n+\n+        ty::Predicate::RegionOutlives(ref data) => {\n+            ty::Predicate::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n+        }\n+\n+        ty::Predicate::TypeOutlives(ref data) => {\n+            ty::Predicate::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n+        }\n+\n+        ty::Predicate::Projection(ref data) => {\n+            ty::Predicate::Projection(tcx.anonymize_late_bound_regions(data))\n+        }\n+\n+        ty::Predicate::WellFormed(data) => ty::Predicate::WellFormed(data),\n+\n+        ty::Predicate::ObjectSafe(data) => ty::Predicate::ObjectSafe(data),\n+\n+        ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind)\n+        }\n+\n+        ty::Predicate::Subtype(ref data) => {\n+            ty::Predicate::Subtype(tcx.anonymize_late_bound_regions(data))\n+        }\n+\n+        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            ty::Predicate::ConstEvaluatable(def_id, substs)\n+        }\n+    }\n+}\n+\n+struct PredicateSet<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    set: FxHashSet<ty::Predicate<'tcx>>,\n+}\n+\n+impl PredicateSet<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        Self { tcx: tcx, set: Default::default() }\n+    }\n+\n+    fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n+        // We have to be careful here because we want\n+        //\n+        //    for<'a> Foo<&'a int>\n+        //\n+        // and\n+        //\n+        //    for<'b> Foo<&'b int>\n+        //\n+        // to be considered equivalent. So normalize all late-bound\n+        // regions before we throw things into the underlying set.\n+        self.set.insert(anonymize_predicate(self.tcx, pred))\n+    }\n+}\n+\n+impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'tcx> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        for pred in iter {\n+            self.insert(pred.as_ref());\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// `Elaboration` iterator\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// \"Elaboration\" is the process of identifying all the predicates that\n+/// are implied by a source predicate. Currently, this basically means\n+/// walking the \"supertraits\" and other similar assumptions. For example,\n+/// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n+/// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that\n+/// `T: Foo`, then we know that `T: 'static`.\n+pub struct Elaborator<'tcx> {\n+    stack: Vec<ty::Predicate<'tcx>>,\n+    visited: PredicateSet<'tcx>,\n+}\n+\n+pub fn elaborate_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mut predicates: Vec<ty::Predicate<'tcx>>,\n+) -> Elaborator<'tcx> {\n+    let mut visited = PredicateSet::new(tcx);\n+    predicates.retain(|pred| visited.insert(pred));\n+    Elaborator { stack: predicates, visited }\n+}\n+\n+impl Elaborator<'tcx> {\n+    fn elaborate(&mut self, predicate: &ty::Predicate<'tcx>) {\n+        let tcx = self.visited.tcx;\n+        match *predicate {\n+            ty::Predicate::Trait(ref data, _) => {\n+                // Get predicates declared on the trait.\n+                let predicates = tcx.super_predicates_of(data.def_id());\n+\n+                let predicates = predicates\n+                    .predicates\n+                    .iter()\n+                    .map(|(pred, _)| pred.subst_supertrait(tcx, &data.to_poly_trait_ref()));\n+                debug!(\"super_predicates: data={:?} predicates={:?}\", data, predicates.clone());\n+\n+                // Only keep those bounds that we haven't already seen.\n+                // This is necessary to prevent infinite recursion in some\n+                // cases. One common case is when people define\n+                // `trait Sized: Sized { }` rather than `trait Sized { }`.\n+                let visited = &mut self.visited;\n+                let predicates = predicates.filter(|pred| visited.insert(pred));\n+\n+                self.stack.extend(predicates);\n+            }\n+            ty::Predicate::WellFormed(..) => {\n+                // Currently, we do not elaborate WF predicates,\n+                // although we easily could.\n+            }\n+            ty::Predicate::ObjectSafe(..) => {\n+                // Currently, we do not elaborate object-safe\n+                // predicates.\n+            }\n+            ty::Predicate::Subtype(..) => {\n+                // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n+                // though conceivably we might.\n+            }\n+            ty::Predicate::Projection(..) => {\n+                // Nothing to elaborate in a projection predicate.\n+            }\n+            ty::Predicate::ClosureKind(..) => {\n+                // Nothing to elaborate when waiting for a closure's kind to be inferred.\n+            }\n+            ty::Predicate::ConstEvaluatable(..) => {\n+                // Currently, we do not elaborate const-evaluatable\n+                // predicates.\n+            }\n+            ty::Predicate::RegionOutlives(..) => {\n+                // Nothing to elaborate from `'a: 'b`.\n+            }\n+            ty::Predicate::TypeOutlives(ref data) => {\n+                // We know that `T: 'a` for some type `T`. We can\n+                // often elaborate this. For example, if we know that\n+                // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n+                // we know `&'a U: 'b`, then we know that `'a: 'b` and\n+                // `U: 'b`.\n+                //\n+                // We can basically ignore bound regions here. So for\n+                // example `for<'c> Foo<'a,'c>: 'b` can be elaborated to\n+                // `'a: 'b`.\n+\n+                // Ignore `for<'a> T: 'a` -- we might in the future\n+                // consider this as evidence that `T: 'static`, but\n+                // I'm a bit wary of such constructions and so for now\n+                // I want to be conservative. --nmatsakis\n+                let ty_max = data.skip_binder().0;\n+                let r_min = data.skip_binder().1;\n+                if r_min.is_late_bound() {\n+                    return;\n+                }\n+\n+                let visited = &mut self.visited;\n+                let mut components = smallvec![];\n+                tcx.push_outlives_components(ty_max, &mut components);\n+                self.stack.extend(\n+                    components\n+                        .into_iter()\n+                        .filter_map(|component| match component {\n+                            Component::Region(r) => {\n+                                if r.is_late_bound() {\n+                                    None\n+                                } else {\n+                                    Some(ty::Predicate::RegionOutlives(ty::Binder::dummy(\n+                                        ty::OutlivesPredicate(r, r_min),\n+                                    )))\n+                                }\n+                            }\n+\n+                            Component::Param(p) => {\n+                                let ty = tcx.mk_ty_param(p.index, p.name);\n+                                Some(ty::Predicate::TypeOutlives(ty::Binder::dummy(\n+                                    ty::OutlivesPredicate(ty, r_min),\n+                                )))\n+                            }\n+\n+                            Component::UnresolvedInferenceVariable(_) => None,\n+\n+                            Component::Projection(_) | Component::EscapingProjection(_) => {\n+                                // We can probably do more here. This\n+                                // corresponds to a case like `<T as\n+                                // Foo<'a>>::U: 'b`.\n+                                None\n+                            }\n+                        })\n+                        .filter(|p| visited.insert(p)),\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+impl Iterator for Elaborator<'tcx> {\n+    type Item = ty::Predicate<'tcx>;\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.stack.len(), None)\n+    }\n+\n+    fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n+        // Extract next item from top-most stack frame, if any.\n+        if let Some(pred) = self.stack.pop() {\n+            self.elaborate(&pred);\n+            Some(pred)\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "c7f2cc34b84701bad65cdff7b0335727faed31b2", "filename": "src/librustc_trait_selection/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2FCargo.toml?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -11,12 +11,14 @@ doctest = false\n \n [dependencies]\n fmt_macros = { path = \"../libfmt_macros\" }\n+graphviz = { path = \"../libgraphviz\" }\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc = { path = \"../librustc\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_error_codes = { path = \"../librustc_error_codes\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_infer = { path = \"../librustc_infer\" }"}, {"sha": "7abcbf45277fba9ed4cc4783a86f802d9b675b35", "filename": "src/librustc_trait_selection/infer.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Finfer.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -0,0 +1,182 @@\n+use crate::traits::query::outlives_bounds::InferCtxtExt as _;\n+use crate::traits::{self, TraitEngine, TraitEngineExt};\n+\n+use rustc::arena::ArenaAllocatable;\n+use rustc::infer::canonical::{Canonical, CanonicalizedQueryResponse, QueryResponse};\n+use rustc::middle::lang_items;\n+use rustc::traits::query::Fallible;\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc_hir as hir;\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_span::{Span, DUMMY_SP};\n+\n+use std::fmt::Debug;\n+\n+pub use rustc_infer::infer::*;\n+\n+pub trait InferCtxtExt<'tcx> {\n+    fn type_is_copy_modulo_regions(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> bool;\n+\n+    fn partially_normalize_associated_types_in<T>(\n+        &self,\n+        span: Span,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> InferOk<'tcx, T>\n+    where\n+        T: TypeFoldable<'tcx>;\n+}\n+\n+impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n+    fn type_is_copy_modulo_regions(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> bool {\n+        let ty = self.resolve_vars_if_possible(&ty);\n+\n+        if !(param_env, ty).has_local_value() {\n+            return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n+        }\n+\n+        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n+\n+        // This can get called from typeck (by euv), and `moves_by_default`\n+        // rightly refuses to work with inference variables, but\n+        // moves_by_default has a cache, which we want to use in other\n+        // cases.\n+        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id, span)\n+    }\n+\n+    /// Normalizes associated types in `value`, potentially returning\n+    /// new obligations that must further be processed.\n+    fn partially_normalize_associated_types_in<T>(\n+        &self,\n+        span: Span,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> InferOk<'tcx, T>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n+        let mut selcx = traits::SelectionContext::new(self);\n+        let cause = ObligationCause::misc(span, body_id);\n+        let traits::Normalized { value, obligations } =\n+            traits::normalize(&mut selcx, param_env, cause, value);\n+        debug!(\n+            \"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n+            value, obligations\n+        );\n+        InferOk { value, obligations }\n+    }\n+}\n+\n+pub trait InferCtxtBuilderExt<'tcx> {\n+    fn enter_canonical_trait_query<K, R>(\n+        &mut self,\n+        canonical_key: &Canonical<'tcx, K>,\n+        operation: impl FnOnce(&InferCtxt<'_, 'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n+    where\n+        K: TypeFoldable<'tcx>,\n+        R: Debug + TypeFoldable<'tcx>,\n+        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable;\n+}\n+\n+impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n+    /// The \"main method\" for a canonicalized trait query. Given the\n+    /// canonical key `canonical_key`, this method will create a new\n+    /// inference context, instantiate the key, and run your operation\n+    /// `op`. The operation should yield up a result (of type `R`) as\n+    /// well as a set of trait obligations that must be fully\n+    /// satisfied. These obligations will be processed and the\n+    /// canonical result created.\n+    ///\n+    /// Returns `NoSolution` in the event of any error.\n+    ///\n+    /// (It might be mildly nicer to implement this on `TyCtxt`, and\n+    /// not `InferCtxtBuilder`, but that is a bit tricky right now.\n+    /// In part because we would need a `for<'tcx>` sort of\n+    /// bound for the closure and in part because it is convenient to\n+    /// have `'tcx` be free on this function so that we can talk about\n+    /// `K: TypeFoldable<'tcx>`.)\n+    fn enter_canonical_trait_query<K, R>(\n+        &mut self,\n+        canonical_key: &Canonical<'tcx, K>,\n+        operation: impl FnOnce(&InferCtxt<'_, 'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n+    where\n+        K: TypeFoldable<'tcx>,\n+        R: Debug + TypeFoldable<'tcx>,\n+        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable,\n+    {\n+        self.enter_with_canonical(\n+            DUMMY_SP,\n+            canonical_key,\n+            |ref infcx, key, canonical_inference_vars| {\n+                let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n+                let value = operation(infcx, &mut *fulfill_cx, key)?;\n+                infcx.make_canonicalized_query_response(\n+                    canonical_inference_vars,\n+                    value,\n+                    &mut *fulfill_cx,\n+                )\n+            },\n+        )\n+    }\n+}\n+\n+pub trait OutlivesEnvironmentExt<'tcx> {\n+    fn add_implied_bounds(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'tcx>,\n+        fn_sig_tys: &[Ty<'tcx>],\n+        body_id: hir::HirId,\n+        span: Span,\n+    );\n+}\n+\n+impl<'tcx> OutlivesEnvironmentExt<'tcx> for OutlivesEnvironment<'tcx> {\n+    /// This method adds \"implied bounds\" into the outlives environment.\n+    /// Implied bounds are outlives relationships that we can deduce\n+    /// on the basis that certain types must be well-formed -- these are\n+    /// either the types that appear in the function signature or else\n+    /// the input types to an impl. For example, if you have a function\n+    /// like\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b, T>(x: &'a &'b [T]) { }\n+    /// ```\n+    ///\n+    /// we can assume in the caller's body that `'b: 'a` and that `T:\n+    /// 'b` (and hence, transitively, that `T: 'a`). This method would\n+    /// add those assumptions into the outlives-environment.\n+    ///\n+    /// Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n+    fn add_implied_bounds(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'tcx>,\n+        fn_sig_tys: &[Ty<'tcx>],\n+        body_id: hir::HirId,\n+        span: Span,\n+    ) {\n+        debug!(\"add_implied_bounds()\");\n+\n+        for &ty in fn_sig_tys {\n+            let ty = infcx.resolve_vars_if_possible(&ty);\n+            debug!(\"add_implied_bounds: ty = {}\", ty);\n+            let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);\n+            self.add_outlives_bounds(Some(infcx), implied_bounds)\n+        }\n+    }\n+}"}, {"sha": "8b5cf223826a90406e33b9a47876bbff0d395c27", "filename": "src/librustc_trait_selection/lib.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Flib.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -0,0 +1,39 @@\n+//! This crates defines the trait resolution method and the type inference engine.\n+//!\n+//! - **Traits.** Trait resolution is implemented in the `traits` module.\n+//! - **Type inference.** The type inference code can be found in the `infer` module;\n+//!   this code handles low-level equality and subtyping operations. The\n+//!   type check pass in the compiler is found in the `librustc_typeck` crate.\n+//!\n+//! For more information about how rustc works, see the [rustc guide].\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(bool_to_option)]\n+#![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![feature(drain_filter)]\n+#![feature(never_type)]\n+#![feature(range_is_empty)]\n+#![feature(in_band_lifetimes)]\n+#![feature(crate_visibility_modifier)]\n+#![recursion_limit = \"512\"]\n+\n+#[macro_use]\n+extern crate rustc_macros;\n+#[cfg(target_arch = \"x86_64\")]\n+#[macro_use]\n+extern crate rustc_data_structures;\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate rustc;\n+\n+pub mod infer;\n+pub mod opaque_types;\n+pub mod traits;"}, {"sha": "6cf1302783c0b9cf313987ba7d77a1fb3e1f2785", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 60, "deletions": 7, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -1,5 +1,4 @@\n-use crate::infer::error_reporting::unexpected_hidden_region_diagnostic;\n-use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::infer::InferCtxtExt as _;\n use crate::traits::{self, PredicateObligation};\n use rustc::session::config::nightly_options;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n@@ -11,6 +10,9 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIdMap};\n use rustc_hir::Node;\n+use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_span::Span;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n@@ -103,7 +105,58 @@ pub enum GenerateMemberConstraints {\n     IfNoStaticBound,\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+pub trait InferCtxtExt<'tcx> {\n+    fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n+        &self,\n+        parent_def_id: DefId,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+        value_span: Span,\n+    ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)>;\n+\n+    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(\n+        &self,\n+        opaque_types: &OpaqueTypeMap<'tcx>,\n+        free_region_relations: &FRR,\n+    );\n+\n+    fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n+        &self,\n+        def_id: DefId,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        mode: GenerateMemberConstraints,\n+        free_region_relations: &FRR,\n+    );\n+\n+    /*private*/\n+    fn generate_member_constraint(\n+        &self,\n+        concrete_ty: Ty<'tcx>,\n+        opaque_type_generics: &ty::Generics,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        opaque_type_def_id: DefId,\n+    );\n+\n+    /*private*/\n+    fn member_constraint_feature_gate(\n+        &self,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        opaque_type_def_id: DefId,\n+        conflict1: ty::Region<'tcx>,\n+        conflict2: ty::Region<'tcx>,\n+    ) -> bool;\n+\n+    fn infer_opaque_definition_from_instantiation(\n+        &self,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+        instantiated_ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Ty<'tcx>;\n+}\n+\n+impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// Replaces all opaque types in `value` with fresh inference variables\n     /// and creates appropriate obligations. For example, given the input:\n     ///\n@@ -129,7 +182,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///   obligations\n     /// - `value` -- the value within which we are instantiating opaque types\n     /// - `value_span` -- the span where the value came from, used in error reporting\n-    pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n+    fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n         parent_def_id: DefId,\n         body_id: hir::HirId,\n@@ -317,7 +370,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n     /// - `free_region_relations` -- something that can be used to relate\n     ///   the free regions (`'a`) that appear in the impl trait.\n-    pub fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(\n+    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n         opaque_types: &OpaqueTypeMap<'tcx>,\n         free_region_relations: &FRR,\n@@ -335,7 +388,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// See `constrain_opaque_types` for documentation.\n-    pub fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n+    fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n         def_id: DefId,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n@@ -577,7 +630,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// - `substs`, the substs  used to instantiate this opaque type\n     /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n     ///   `opaque_defn.concrete_ty`\n-    pub fn infer_opaque_definition_from_instantiation(\n+    fn infer_opaque_definition_from_instantiation(\n         &self,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,"}, {"sha": "5c2fc3f305c1f9e2f276bfe2ac49ca4495a99fde", "filename": "src/librustc_trait_selection/traits/codegen/mod.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -72,7 +72,7 @@ pub fn codegen_fulfill_obligation<'tcx>(\n             debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n         });\n-        let vtable = infcx.drain_fulfillment_cx_or_panic(&mut fulfill_cx, &vtable);\n+        let vtable = drain_fulfillment_cx_or_panic(&infcx, &mut fulfill_cx, &vtable);\n \n         info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n         Some(vtable)\n@@ -81,34 +81,32 @@ pub fn codegen_fulfill_obligation<'tcx>(\n \n // # Global Cache\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    /// Finishes processes any obligations that remain in the\n-    /// fulfillment context, and then returns the result with all type\n-    /// variables removed and regions erased. Because this is intended\n-    /// for use after type-check has completed, if any errors occur,\n-    /// it will panic. It is used during normalization and other cases\n-    /// where processing the obligations in `fulfill_cx` may cause\n-    /// type inference variables that appear in `result` to be\n-    /// unified, and hence we need to process those obligations to get\n-    /// the complete picture of the type.\n-    fn drain_fulfillment_cx_or_panic<T>(\n-        &self,\n-        fulfill_cx: &mut FulfillmentContext<'tcx>,\n-        result: &T,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\"drain_fulfillment_cx_or_panic()\");\n+/// Finishes processes any obligations that remain in the\n+/// fulfillment context, and then returns the result with all type\n+/// variables removed and regions erased. Because this is intended\n+/// for use after type-check has completed, if any errors occur,\n+/// it will panic. It is used during normalization and other cases\n+/// where processing the obligations in `fulfill_cx` may cause\n+/// type inference variables that appear in `result` to be\n+/// unified, and hence we need to process those obligations to get\n+/// the complete picture of the type.\n+fn drain_fulfillment_cx_or_panic<T>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    fulfill_cx: &mut FulfillmentContext<'tcx>,\n+    result: &T,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    debug!(\"drain_fulfillment_cx_or_panic()\");\n \n-        // In principle, we only need to do this so long as `result`\n-        // contains unbound type parameters. It could be a slight\n-        // optimization to stop iterating early.\n-        if let Err(errors) = fulfill_cx.select_all_or_error(self) {\n-            bug!(\"Encountered errors `{:?}` resolving bounds after type-checking\", errors);\n-        }\n-\n-        let result = self.resolve_vars_if_possible(result);\n-        self.tcx.erase_regions(&result)\n+    // In principle, we only need to do this so long as `result`\n+    // contains unbound type parameters. It could be a slight\n+    // optimization to stop iterating early.\n+    if let Err(errors) = fulfill_cx.select_all_or_error(infcx) {\n+        bug!(\"Encountered errors `{:?}` resolving bounds after type-checking\", errors);\n     }\n+\n+    let result = infcx.resolve_vars_if_possible(result);\n+    infcx.tcx.erase_regions(&result)\n }"}, {"sha": "ee4715e0c20f6b54ebda56f7414cd0f58375389b", "filename": "src/librustc_trait_selection/traits/engine.rs", "status": "modified", "additions": 6, "deletions": 76, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -1,84 +1,14 @@\n-use crate::infer::InferCtxt;\n-use crate::traits::Obligation;\n-use rustc::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n-use rustc_hir::def_id::DefId;\n+use rustc::ty::TyCtxt;\n \n-use super::{FulfillmentContext, FulfillmentError};\n-use super::{ObligationCause, PredicateObligation};\n-\n-pub trait TraitEngine<'tcx>: 'tcx {\n-    fn normalize_projection_type(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-        cause: ObligationCause<'tcx>,\n-    ) -> Ty<'tcx>;\n-\n-    /// Requires that `ty` must implement the trait with `def_id` in\n-    /// the given environment. This trait must not have any type\n-    /// parameters (except for `Self`).\n-    fn register_bound(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        def_id: DefId,\n-        cause: ObligationCause<'tcx>,\n-    ) {\n-        let trait_ref = ty::TraitRef { def_id, substs: infcx.tcx.mk_substs_trait(ty, &[]) };\n-        self.register_predicate_obligation(\n-            infcx,\n-            Obligation {\n-                cause,\n-                recursion_depth: 0,\n-                param_env,\n-                predicate: trait_ref.without_const().to_predicate(),\n-            },\n-        );\n-    }\n-\n-    fn register_predicate_obligation(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        obligation: PredicateObligation<'tcx>,\n-    );\n-\n-    fn select_all_or_error(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n-\n-    fn select_where_possible(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n-\n-    fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n-}\n+use super::FulfillmentContext;\n+use super::TraitEngine;\n \n pub trait TraitEngineExt<'tcx> {\n-    fn register_predicate_obligations(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n-    );\n-}\n-\n-impl<T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n-    fn register_predicate_obligations(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n-    ) {\n-        for obligation in obligations {\n-            self.register_predicate_obligation(infcx, obligation);\n-        }\n-    }\n+    fn new(tcx: TyCtxt<'tcx>) -> Box<Self>;\n }\n \n-impl dyn TraitEngine<'tcx> {\n-    pub fn new(_tcx: TyCtxt<'tcx>) -> Box<Self> {\n+impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n+    fn new(_tcx: TyCtxt<'tcx>) -> Box<Self> {\n         Box::new(FulfillmentContext::new())\n     }\n }"}, {"sha": "abd9638bfa78b2e4585afe5e8b15af1a8e381ed3", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1085, "deletions": 828, "changes": 1913, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -3,10 +3,9 @@ pub mod suggestions;\n \n use super::{\n     ConstEvalFailure, EvaluationResult, FulfillmentError, FulfillmentErrorCode,\n-    MismatchedProjectionTypes, ObjectSafetyViolation, Obligation, ObligationCause,\n-    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote,\n-    OutputTypeParameterMismatch, Overflow, PredicateObligation, SelectionContext, SelectionError,\n-    TraitNotObjectSafe,\n+    MismatchedProjectionTypes, Obligation, ObligationCause, ObligationCauseCode,\n+    OnUnimplementedDirective, OnUnimplementedNote, OutputTypeParameterMismatch, Overflow,\n+    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n };\n \n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n@@ -21,18 +20,69 @@ use rustc::ty::SubtypePredicate;\n use rustc::ty::{\n     self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n-use rustc_ast::ast;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n+use rustc_hir::{Node, QPath, TyKind, WhereBoundPredicate, WherePredicate};\n use rustc_span::source_map::SourceMap;\n use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn report_fulfillment_errors(\n+use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n+use crate::traits::query::normalize::AtExt as _;\n+use on_unimplemented::InferCtxtExt as _;\n+use suggestions::InferCtxtExt as _;\n+\n+pub use rustc_infer::traits::error_reporting::*;\n+\n+pub trait InferCtxtExt<'tcx> {\n+    fn report_fulfillment_errors(\n+        &self,\n+        errors: &[FulfillmentError<'tcx>],\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    );\n+\n+    fn report_overflow_error<T>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        suggest_increasing_limit: bool,\n+    ) -> !\n+    where\n+        T: fmt::Display + TypeFoldable<'tcx>;\n+\n+    fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> !;\n+\n+    fn report_selection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &SelectionError<'tcx>,\n+        fallback_has_occurred: bool,\n+        points_at_arg: bool,\n+    );\n+\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>);\n+\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_args: Vec<ArgKind>,\n+        found_args: Vec<ArgKind>,\n+        is_closure: bool,\n+    ) -> DiagnosticBuilder<'tcx>;\n+}\n+\n+impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+    fn report_fulfillment_errors(\n         &self,\n         errors: &[FulfillmentError<'tcx>],\n         body_id: Option<hir::BodyId>,\n@@ -118,827 +168,1106 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n-    // `error` occurring implies that `cond` occurs.\n-    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool {\n-        if cond == error {\n-            return true;\n-        }\n-\n-        let (cond, error) = match (cond, error) {\n-            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error, _)) => (cond, error),\n-            _ => {\n-                // FIXME: make this work in other cases too.\n-                return false;\n-            }\n-        };\n+    /// Reports that an overflow has occurred and halts compilation. We\n+    /// halt compilation unconditionally because it is important that\n+    /// overflows never be masked -- they basically represent computations\n+    /// whose result could not be truly determined and thus we can't say\n+    /// if the program type checks or not -- and they are unusual\n+    /// occurrences in any case.\n+    fn report_overflow_error<T>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        suggest_increasing_limit: bool,\n+    ) -> !\n+    where\n+        T: fmt::Display + TypeFoldable<'tcx>,\n+    {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            obligation.cause.span,\n+            E0275,\n+            \"overflow evaluating the requirement `{}`\",\n+            predicate\n+        );\n \n-        for implication in super::elaborate_predicates(self.tcx, vec![*cond]) {\n-            if let ty::Predicate::Trait(implication, _) = implication {\n-                let error = error.to_poly_trait_ref();\n-                let implication = implication.to_poly_trait_ref();\n-                // FIXME: I'm just not taking associated types at all here.\n-                // Eventually I'll need to implement param-env-aware\n-                // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n-                let param_env = ty::ParamEnv::empty();\n-                if self.can_sub(param_env, error, implication).is_ok() {\n-                    debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n-                    return true;\n-                }\n-            }\n+        if suggest_increasing_limit {\n+            self.suggest_new_overflow_limit(&mut err);\n         }\n \n-        false\n+        self.note_obligation_cause_code(\n+            &mut err,\n+            &obligation.predicate,\n+            &obligation.cause.code,\n+            &mut vec![],\n+        );\n+\n+        err.emit();\n+        self.tcx.sess.abort_if_errors();\n+        bug!();\n     }\n \n-    fn report_fulfillment_error(\n-        &self,\n-        error: &FulfillmentError<'tcx>,\n-        body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n-    ) {\n-        debug!(\"report_fulfillment_error({:?})\", error);\n-        match error.code {\n-            FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n-                self.report_selection_error(\n-                    &error.obligation,\n-                    selection_error,\n-                    fallback_has_occurred,\n-                    error.points_at_arg_span,\n-                );\n-            }\n-            FulfillmentErrorCode::CodeProjectionError(ref e) => {\n-                self.report_projection_error(&error.obligation, e);\n-            }\n-            FulfillmentErrorCode::CodeAmbiguity => {\n-                self.maybe_report_ambiguity(&error.obligation, body_id);\n-            }\n-            FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n-                self.report_mismatched_types(\n-                    &error.obligation.cause,\n-                    expected_found.expected,\n-                    expected_found.found,\n-                    err.clone(),\n-                )\n-                .emit();\n-            }\n-        }\n+    /// Reports that a cycle was detected which led to overflow and halts\n+    /// compilation. This is equivalent to `report_overflow_error` except\n+    /// that we can give a more helpful error message (and, in particular,\n+    /// we do not suggest increasing the overflow limit, which is not\n+    /// going to help).\n+    fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n+        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n+        assert!(!cycle.is_empty());\n+\n+        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+\n+        self.report_overflow_error(&cycle[0], false);\n     }\n \n-    fn report_projection_error(\n+    fn report_selection_error(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        error: &MismatchedProjectionTypes<'tcx>,\n+        error: &SelectionError<'tcx>,\n+        fallback_has_occurred: bool,\n+        points_at_arg: bool,\n     ) {\n-        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n-\n-        if predicate.references_error() {\n-            return;\n-        }\n+        let tcx = self.tcx;\n+        let span = obligation.cause.span;\n \n-        self.probe(|_| {\n-            let err_buf;\n-            let mut err = &error.err;\n-            let mut values = None;\n+        let mut err = match *error {\n+            SelectionError::Unimplemented => {\n+                if let ObligationCauseCode::CompareImplMethodObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                }\n+                | ObligationCauseCode::CompareImplTypeObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                } = obligation.cause.code\n+                {\n+                    self.report_extra_impl_obligation(\n+                        span,\n+                        item_name,\n+                        impl_item_def_id,\n+                        trait_item_def_id,\n+                        &format!(\"`{}`\", obligation.predicate),\n+                    )\n+                    .emit();\n+                    return;\n+                }\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(ref trait_predicate, _) => {\n+                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n \n-            // try to find the mismatched types to report the error with.\n-            //\n-            // this can fail if the problem was higher-ranked, in which\n-            // cause I have no idea for a good error message.\n-            if let ty::Predicate::Projection(ref data) = predicate {\n-                let mut selcx = SelectionContext::new(self);\n-                let (data, _) = self.replace_bound_vars_with_fresh_vars(\n-                    obligation.cause.span,\n-                    infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    data,\n-                );\n-                let mut obligations = vec![];\n-                let normalized_ty = super::normalize_projection_type(\n-                    &mut selcx,\n-                    obligation.param_env,\n-                    data.projection_ty,\n-                    obligation.cause.clone(),\n-                    0,\n-                    &mut obligations,\n-                );\n+                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n+                            return;\n+                        }\n+                        let trait_ref = trait_predicate.to_poly_trait_ref();\n+                        let (post_message, pre_message, type_def) = self\n+                            .get_parent_trait_ref(&obligation.cause.code)\n+                            .map(|(t, s)| {\n+                                (\n+                                    format!(\" in `{}`\", t),\n+                                    format!(\"within `{}`, \", t),\n+                                    s.map(|s| (format!(\"within this `{}`\", t), s)),\n+                                )\n+                            })\n+                            .unwrap_or_default();\n \n-                debug!(\n-                    \"report_projection_error obligation.cause={:?} obligation.param_env={:?}\",\n-                    obligation.cause, obligation.param_env\n-                );\n+                        let OnUnimplementedNote { message, label, note, enclosing_scope } =\n+                            self.on_unimplemented_note(trait_ref, obligation);\n+                        let have_alt_message = message.is_some() || label.is_some();\n+                        let is_try = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(span)\n+                            .map(|s| &s == \"?\")\n+                            .unwrap_or(false);\n+                        let is_from = format!(\"{}\", trait_ref.print_only_trait_path())\n+                            .starts_with(\"std::convert::From<\");\n+                        let (message, note) = if is_try && is_from {\n+                            (\n+                                Some(format!(\n+                                    \"`?` couldn't convert the error to `{}`\",\n+                                    trait_ref.self_ty(),\n+                                )),\n+                                Some(\n+                                    \"the question mark operation (`?`) implicitly performs a \\\n+                                     conversion on the error value using the `From` trait\"\n+                                        .to_owned(),\n+                                ),\n+                            )\n+                        } else {\n+                            (message, note)\n+                        };\n \n-                debug!(\n-                    \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n-                    normalized_ty, data.ty\n-                );\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0277,\n+                            \"{}\",\n+                            message.unwrap_or_else(|| format!(\n+                                \"the trait bound `{}` is not satisfied{}\",\n+                                trait_ref.without_const().to_predicate(),\n+                                post_message,\n+                            ))\n+                        );\n \n-                let is_normalized_ty_expected = match &obligation.cause.code {\n-                    ObligationCauseCode::ItemObligation(_)\n-                    | ObligationCauseCode::BindingObligation(_, _)\n-                    | ObligationCauseCode::ObjectCastObligation(_) => false,\n-                    _ => true,\n+                        let explanation =\n+                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n+                                \"consider using `()`, or a `Result`\".to_owned()\n+                            } else {\n+                                format!(\n+                                    \"{}the trait `{}` is not implemented for `{}`\",\n+                                    pre_message,\n+                                    trait_ref.print_only_trait_path(),\n+                                    trait_ref.self_ty(),\n+                                )\n+                            };\n+\n+                        if self.suggest_add_reference_to_arg(\n+                            &obligation,\n+                            &mut err,\n+                            &trait_ref,\n+                            points_at_arg,\n+                            have_alt_message,\n+                        ) {\n+                            self.note_obligation_cause(&mut err, obligation);\n+                            err.emit();\n+                            return;\n+                        }\n+                        if let Some(ref s) = label {\n+                            // If it has a custom `#[rustc_on_unimplemented]`\n+                            // error message, let's display it as the label!\n+                            err.span_label(span, s.as_str());\n+                            err.help(&explanation);\n+                        } else {\n+                            err.span_label(span, explanation);\n+                        }\n+                        if let Some((msg, span)) = type_def {\n+                            err.span_label(span, &msg);\n+                        }\n+                        if let Some(ref s) = note {\n+                            // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n+                            err.note(s.as_str());\n+                        }\n+                        if let Some(ref s) = enclosing_scope {\n+                            let enclosing_scope_span = tcx.def_span(\n+                                tcx.hir()\n+                                    .opt_local_def_id(obligation.cause.body_id)\n+                                    .unwrap_or_else(|| {\n+                                        tcx.hir().body_owner_def_id(hir::BodyId {\n+                                            hir_id: obligation.cause.body_id,\n+                                        })\n+                                    }),\n+                            );\n+\n+                            err.span_label(enclosing_scope_span, s.as_str());\n+                        }\n+\n+                        self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n+                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n+                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n+                        self.note_version_mismatch(&mut err, &trait_ref);\n+                        if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n+                            err.emit();\n+                            return;\n+                        }\n+\n+                        // Try to report a help message\n+                        if !trait_ref.has_infer_types_or_consts()\n+                            && self.predicate_can_apply(obligation.param_env, trait_ref)\n+                        {\n+                            // If a where-clause may be useful, remind the\n+                            // user that they can add it.\n+                            //\n+                            // don't display an on-unimplemented note, as\n+                            // these notes will often be of the form\n+                            //     \"the type `T` can't be frobnicated\"\n+                            // which is somewhat confusing.\n+                            self.suggest_restricting_param_bound(\n+                                &mut err,\n+                                &trait_ref,\n+                                obligation.cause.body_id,\n+                            );\n+                        } else {\n+                            if !have_alt_message {\n+                                // Can't show anything else useful, try to find similar impls.\n+                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n+                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                            }\n+                            self.suggest_change_mut(\n+                                &obligation,\n+                                &mut err,\n+                                &trait_ref,\n+                                points_at_arg,\n+                            );\n+                        }\n+\n+                        // If this error is due to `!: Trait` not implemented but `(): Trait` is\n+                        // implemented, and fallback has occurred, then it could be due to a\n+                        // variable that used to fallback to `()` now falling back to `!`. Issue a\n+                        // note informing about the change in behaviour.\n+                        if trait_predicate.skip_binder().self_ty().is_never()\n+                            && fallback_has_occurred\n+                        {\n+                            let predicate = trait_predicate.map_bound(|mut trait_pred| {\n+                                trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n+                                    self.tcx.mk_unit(),\n+                                    &trait_pred.trait_ref.substs[1..],\n+                                );\n+                                trait_pred\n+                            });\n+                            let unit_obligation = Obligation {\n+                                predicate: ty::Predicate::Trait(\n+                                    predicate,\n+                                    hir::Constness::NotConst,\n+                                ),\n+                                ..obligation.clone()\n+                            };\n+                            if self.predicate_may_hold(&unit_obligation) {\n+                                err.note(\n+                                    \"the trait is implemented for `()`. \\\n+                                     Possibly this error has been caused by changes to \\\n+                                     Rust's type-inference algorithm (see issue #48950 \\\n+                                     <https://github.com/rust-lang/rust/issues/48950> \\\n+                                     for more information). Consider whether you meant to use \\\n+                                     the type `()` here instead.\",\n+                                );\n+                            }\n+                        }\n+\n+                        err\n+                    }\n+\n+                    ty::Predicate::Subtype(ref predicate) => {\n+                        // Errors for Subtype predicates show up as\n+                        // `FulfillmentErrorCode::CodeSubtypeError`,\n+                        // not selection error.\n+                        span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                        let predicate = self.resolve_vars_if_possible(predicate);\n+                        let err = self\n+                            .region_outlives_predicate(&obligation.cause, &predicate)\n+                            .err()\n+                            .unwrap();\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0279,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate,\n+                            err,\n+                        )\n+                    }\n+\n+                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0280,\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate\n+                        )\n+                    }\n+\n+                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                        let violations = self.tcx.object_safety_violations(trait_def_id);\n+                        report_object_safety_error(self.tcx, span, trait_def_id, violations)\n+                    }\n+\n+                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                        let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n+                        let closure_span = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n+                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            closure_span,\n+                            E0525,\n+                            \"expected a closure that implements the `{}` trait, \\\n+                             but this closure only implements `{}`\",\n+                            kind,\n+                            found_kind\n+                        );\n+\n+                        err.span_label(\n+                            closure_span,\n+                            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n+                        );\n+                        err.span_label(\n+                            obligation.cause.span,\n+                            format!(\"the requirement to implement `{}` derives from here\", kind),\n+                        );\n+\n+                        // Additional context information explaining why the closure only implements\n+                        // a particular trait.\n+                        if let Some(tables) = self.in_progress_tables {\n+                            let tables = tables.borrow();\n+                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n+                                (ty::ClosureKind::FnOnce, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnOnce` because it moves the \\\n+                                         variable `{}` out of its environment\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                (ty::ClosureKind::FnMut, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnMut` because it mutates the \\\n+                                         variable `{}` here\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+\n+                        err.emit();\n+                        return;\n+                    }\n+\n+                    ty::Predicate::WellFormed(ty) => {\n+                        // WF predicates cannot themselves make\n+                        // errors. They can only block due to\n+                        // ambiguity; otherwise, they always\n+                        // degenerate into other obligations\n+                        // (which may fail).\n+                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                    }\n+\n+                    ty::Predicate::ConstEvaluatable(..) => {\n+                        // Errors for `ConstEvaluatable` predicates show up as\n+                        // `SelectionError::ConstEvalFailure`,\n+                        // not `Unimplemented`.\n+                        span_bug!(\n+                            span,\n+                            \"const-evaluatable requirement gave wrong error: `{:?}`\",\n+                            obligation\n+                        )\n+                    }\n+                }\n+            }\n+\n+            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n+                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n+                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n+\n+                if expected_trait_ref.self_ty().references_error() {\n+                    return;\n+                }\n+\n+                let found_trait_ty = found_trait_ref.self_ty();\n+\n+                let found_did = match found_trait_ty.kind {\n+                    ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n+                    ty::Adt(def, _) => Some(def.did),\n+                    _ => None,\n                 };\n \n-                if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n-                    is_normalized_ty_expected,\n-                    normalized_ty,\n-                    data.ty,\n-                ) {\n-                    values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n-                        is_normalized_ty_expected,\n-                        normalized_ty,\n-                        data.ty,\n-                    )));\n+                let found_span = found_did\n+                    .and_then(|did| self.tcx.hir().span_if_local(did))\n+                    .map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n \n-                    err_buf = error;\n-                    err = &err_buf;\n+                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n+                    // We check closures twice, with obligations flowing in different directions,\n+                    // but we want to complain about them only once.\n+                    return;\n+                }\n+\n+                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n+\n+                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n+                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n+                    _ => vec![ArgKind::empty()],\n+                };\n+\n+                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n+                let expected = match expected_ty.kind {\n+                    ty::Tuple(ref tys) => tys\n+                        .iter()\n+                        .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span)))\n+                        .collect(),\n+                    _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n+                };\n+\n+                if found.len() == expected.len() {\n+                    self.report_closure_arg_mismatch(\n+                        span,\n+                        found_span,\n+                        found_trait_ref,\n+                        expected_trait_ref,\n+                    )\n+                } else {\n+                    let (closure_span, found) = found_did\n+                        .and_then(|did| self.tcx.hir().get_if_local(did))\n+                        .map(|node| {\n+                            let (found_span, found) = self.get_fn_like_arguments(node);\n+                            (Some(found_span), found)\n+                        })\n+                        .unwrap_or((found_span, found));\n+\n+                    self.report_arg_count_mismatch(\n+                        span,\n+                        closure_span,\n+                        expected,\n+                        found,\n+                        found_trait_ty.is_closure(),\n+                    )\n                 }\n             }\n \n-            let msg = format!(\"type mismatch resolving `{}`\", predicate);\n-            let error_id = (DiagnosticMessageId::ErrorId(271), Some(obligation.cause.span), msg);\n-            let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-            if fresh {\n-                let mut diag = struct_span_err!(\n-                    self.tcx.sess,\n-                    obligation.cause.span,\n-                    E0271,\n-                    \"type mismatch resolving `{}`\",\n-                    predicate\n-                );\n-                self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n-                self.note_obligation_cause(&mut diag, obligation);\n-                diag.emit();\n+            TraitNotObjectSafe(did) => {\n+                let violations = self.tcx.object_safety_violations(did);\n+                report_object_safety_error(self.tcx, span, did, violations)\n+            }\n+\n+            ConstEvalFailure(ErrorHandled::TooGeneric) => {\n+                // In this instance, we have a const expression containing an unevaluated\n+                // generic parameter. We have no idea whether this expression is valid or\n+                // not (e.g. it might result in an error), but we don't want to just assume\n+                // that it's okay, because that might result in post-monomorphisation time\n+                // errors. The onus is really on the caller to provide values that it can\n+                // prove are well-formed.\n+                let mut err = self\n+                    .tcx\n+                    .sess\n+                    .struct_span_err(span, \"constant expression depends on a generic parameter\");\n+                // FIXME(const_generics): we should suggest to the user how they can resolve this\n+                // issue. However, this is currently not actually possible\n+                // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n+                err.note(\"this may fail depending on what value the parameter takes\");\n+                err\n+            }\n+\n+            // Already reported in the query.\n+            ConstEvalFailure(ErrorHandled::Reported) => {\n+                self.tcx.sess.delay_span_bug(span, \"constant in type had an ignored error\");\n+                return;\n             }\n-        });\n-    }\n \n-    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        /// returns the fuzzy category of a given type, or None\n-        /// if the type can be equated to any type.\n-        fn type_category(t: Ty<'_>) -> Option<u32> {\n-            match t.kind {\n-                ty::Bool => Some(0),\n-                ty::Char => Some(1),\n-                ty::Str => Some(2),\n-                ty::Int(..) | ty::Uint(..) | ty::Infer(ty::IntVar(..)) => Some(3),\n-                ty::Float(..) | ty::Infer(ty::FloatVar(..)) => Some(4),\n-                ty::Ref(..) | ty::RawPtr(..) => Some(5),\n-                ty::Array(..) | ty::Slice(..) => Some(6),\n-                ty::FnDef(..) | ty::FnPtr(..) => Some(7),\n-                ty::Dynamic(..) => Some(8),\n-                ty::Closure(..) => Some(9),\n-                ty::Tuple(..) => Some(10),\n-                ty::Projection(..) => Some(11),\n-                ty::Param(..) => Some(12),\n-                ty::Opaque(..) => Some(13),\n-                ty::Never => Some(14),\n-                ty::Adt(adt, ..) => match adt.adt_kind() {\n-                    AdtKind::Struct => Some(15),\n-                    AdtKind::Union => Some(16),\n-                    AdtKind::Enum => Some(17),\n-                },\n-                ty::Generator(..) => Some(18),\n-                ty::Foreign(..) => Some(19),\n-                ty::GeneratorWitness(..) => Some(20),\n-                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n-                ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+            Overflow => {\n+                bug!(\"overflow should be handled before the `report_selection_error` path\");\n             }\n-        }\n+        };\n \n-        match (type_category(a), type_category(b)) {\n-            (Some(cat_a), Some(cat_b)) => match (&a.kind, &b.kind) {\n-                (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n-                _ => cat_a == cat_b,\n-            },\n-            // infer and error can be equated to all types\n-            _ => true,\n-        }\n-    }\n+        self.note_obligation_cause(&mut err, obligation);\n+        self.point_at_returns_when_relevant(&mut err, &obligation);\n \n-    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str> {\n-        self.tcx.hir().body(body_id).generator_kind.map(|gen_kind| match gen_kind {\n-            hir::GeneratorKind::Gen => \"a generator\",\n-            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"an async block\",\n-            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"an async function\",\n-            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"an async closure\",\n-        })\n+        err.emit();\n     }\n \n-    fn find_similar_impl_candidates(\n-        &self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-    ) -> Vec<ty::TraitRef<'tcx>> {\n-        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n-        let all_impls = self.tcx.all_impls(trait_ref.def_id());\n-\n-        match simp {\n-            Some(simp) => all_impls\n-                .iter()\n-                .filter_map(|&def_id| {\n-                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-                    let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n-                    if let Some(imp_simp) = imp_simp {\n-                        if simp != imp_simp {\n-                            return None;\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n+        match node {\n+            Node::Expr(&hir::Expr {\n+                kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n+                ..\n+            }) => (\n+                self.tcx.sess.source_map().def_span(span),\n+                self.tcx\n+                    .hir()\n+                    .body(id)\n+                    .params\n+                    .iter()\n+                    .map(|arg| {\n+                        if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n+                            *arg.pat\n+                        {\n+                            ArgKind::Tuple(\n+                                Some(span),\n+                                args.iter()\n+                                    .map(|pat| {\n+                                        let snippet = self\n+                                            .tcx\n+                                            .sess\n+                                            .source_map()\n+                                            .span_to_snippet(pat.span)\n+                                            .unwrap();\n+                                        (snippet, \"_\".to_owned())\n+                                    })\n+                                    .collect::<Vec<_>>(),\n+                            )\n+                        } else {\n+                            let name =\n+                                self.tcx.sess.source_map().span_to_snippet(arg.pat.span).unwrap();\n+                            ArgKind::Arg(name, \"_\".to_owned())\n                         }\n-                    }\n-\n-                    Some(imp)\n-                })\n-                .collect(),\n-            None => {\n-                all_impls.iter().map(|&def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect()\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n+            | Node::ImplItem(&hir::ImplItem {\n+                span,\n+                kind: hir::ImplItemKind::Method(ref sig, _),\n+                ..\n+            })\n+            | Node::TraitItem(&hir::TraitItem {\n+                span,\n+                kind: hir::TraitItemKind::Fn(ref sig, _),\n+                ..\n+            }) => (\n+                self.tcx.sess.source_map().def_span(span),\n+                sig.decl\n+                    .inputs\n+                    .iter()\n+                    .map(|arg| match arg.clone().kind {\n+                        hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n+                            Some(arg.span),\n+                            vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],\n+                        ),\n+                        _ => ArgKind::empty(),\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Ctor(ref variant_data) => {\n+                let span = variant_data\n+                    .ctor_hir_id()\n+                    .map(|hir_id| self.tcx.hir().span(hir_id))\n+                    .unwrap_or(DUMMY_SP);\n+                let span = self.tcx.sess.source_map().def_span(span);\n+\n+                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n+            _ => panic!(\"non-FnLike node found: {:?}\", node),\n         }\n     }\n \n-    fn report_similar_impl_candidates(\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    fn report_arg_count_mismatch(\n         &self,\n-        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n-        err: &mut DiagnosticBuilder<'_>,\n-    ) {\n-        if impl_candidates.is_empty() {\n-            return;\n-        }\n-\n-        let len = impl_candidates.len();\n-        let end = if impl_candidates.len() <= 5 { impl_candidates.len() } else { 4 };\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_args: Vec<ArgKind>,\n+        found_args: Vec<ArgKind>,\n+        is_closure: bool,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let kind = if is_closure { \"closure\" } else { \"function\" };\n \n-        let normalize = |candidate| {\n-            self.tcx.infer_ctxt().enter(|ref infcx| {\n-                let normalized = infcx\n-                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n-                    .normalize(candidate)\n-                    .ok();\n-                match normalized {\n-                    Some(normalized) => format!(\"\\n  {:?}\", normalized.value),\n-                    None => format!(\"\\n  {:?}\", candidate),\n+        let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n+            let arg_length = arguments.len();\n+            let distinct = match &other[..] {\n+                &[ArgKind::Tuple(..)] => true,\n+                _ => false,\n+            };\n+            match (arg_length, arguments.get(0)) {\n+                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n+                    format!(\"a single {}-tuple as argument\", fields.len())\n                 }\n-            })\n+                _ => format!(\n+                    \"{} {}argument{}\",\n+                    arg_length,\n+                    if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n+                    pluralize!(arg_length)\n+                ),\n+            }\n         };\n \n-        // Sort impl candidates so that ordering is consistent for UI tests.\n-        let mut normalized_impl_candidates =\n-            impl_candidates.iter().map(normalize).collect::<Vec<String>>();\n-\n-        // Sort before taking the `..end` range,\n-        // because the ordering of `impl_candidates` may not be deterministic:\n-        // https://github.com/rust-lang/rust/pull/57475#issuecomment-455519507\n-        normalized_impl_candidates.sort();\n-\n-        err.help(&format!(\n-            \"the following implementations were found:{}{}\",\n-            normalized_impl_candidates[..end].join(\"\"),\n-            if len > 5 { format!(\"\\nand {} others\", len - 4) } else { String::new() }\n-        ));\n-    }\n+        let expected_str = args_str(&expected_args, &found_args);\n+        let found_str = args_str(&found_args, &expected_args);\n \n-    /// Reports that an overflow has occurred and halts compilation. We\n-    /// halt compilation unconditionally because it is important that\n-    /// overflows never be masked -- they basically represent computations\n-    /// whose result could not be truly determined and thus we can't say\n-    /// if the program type checks or not -- and they are unusual\n-    /// occurrences in any case.\n-    pub fn report_overflow_error<T>(\n-        &self,\n-        obligation: &Obligation<'tcx, T>,\n-        suggest_increasing_limit: bool,\n-    ) -> !\n-    where\n-        T: fmt::Display + TypeFoldable<'tcx>,\n-    {\n-        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n-            obligation.cause.span,\n-            E0275,\n-            \"overflow evaluating the requirement `{}`\",\n-            predicate\n+            span,\n+            E0593,\n+            \"{} is expected to take {}, but it takes {}\",\n+            kind,\n+            expected_str,\n+            found_str,\n         );\n \n-        if suggest_increasing_limit {\n-            self.suggest_new_overflow_limit(&mut err);\n-        }\n-\n-        self.note_obligation_cause_code(\n-            &mut err,\n-            &obligation.predicate,\n-            &obligation.cause.code,\n-            &mut vec![],\n-        );\n+        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n \n-        err.emit();\n-        self.tcx.sess.abort_if_errors();\n-        bug!();\n-    }\n+        if let Some(found_span) = found_span {\n+            err.span_label(found_span, format!(\"takes {}\", found_str));\n \n-    /// Reports that a cycle was detected which led to overflow and halts\n-    /// compilation. This is equivalent to `report_overflow_error` except\n-    /// that we can give a more helpful error message (and, in particular,\n-    /// we do not suggest increasing the overflow limit, which is not\n-    /// going to help).\n-    pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n-        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n-        assert!(!cycle.is_empty());\n+            // move |_| { ... }\n+            // ^^^^^^^^-- def_span\n+            //\n+            // move |_| { ... }\n+            // ^^^^^-- prefix\n+            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n+            // move |_| { ... }\n+            //      ^^^-- pipe_span\n+            let pipe_span =\n+                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n+\n+            // Suggest to take and ignore the arguments with expected_args_length `_`s if\n+            // found arguments is empty (assume the user just wants to ignore args in this case).\n+            // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n+            if found_args.is_empty() && is_closure {\n+                let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n+                err.span_suggestion(\n+                    pipe_span,\n+                    &format!(\n+                        \"consider changing the closure to take and ignore the expected argument{}\",\n+                        if expected_args.len() < 2 { \"\" } else { \"s\" }\n+                    ),\n+                    format!(\"|{}|\", underscores),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n \n-        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+                if fields.len() == expected_args.len() {\n+                    let sugg = fields\n+                        .iter()\n+                        .map(|(name, _)| name.to_owned())\n+                        .collect::<Vec<String>>()\n+                        .join(\", \");\n+                    err.span_suggestion(\n+                        found_span,\n+                        \"change the closure to take multiple arguments instead of a single tuple\",\n+                        format!(\"|{}|\", sugg),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n+                if fields.len() == found_args.len() && is_closure {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        found_args\n+                            .iter()\n+                            .map(|arg| match arg {\n+                                ArgKind::Arg(name, _) => name.to_owned(),\n+                                _ => \"_\".to_owned(),\n+                            })\n+                            .collect::<Vec<String>>()\n+                            .join(\", \"),\n+                        // add type annotations if available\n+                        if found_args.iter().any(|arg| match arg {\n+                            ArgKind::Arg(_, ty) => ty != \"_\",\n+                            _ => false,\n+                        }) {\n+                            format!(\n+                                \": ({})\",\n+                                fields\n+                                    .iter()\n+                                    .map(|(_, ty)| ty.to_owned())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \")\n+                            )\n+                        } else {\n+                            String::new()\n+                        },\n+                    );\n+                    err.span_suggestion(\n+                        found_span,\n+                        \"change the closure to accept a tuple instead of individual arguments\",\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n \n-        self.report_overflow_error(&cycle[0], false);\n+        err\n     }\n+}\n+\n+trait InferCtxtPrivExt<'tcx> {\n+    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n+    // `error` occurring implies that `cond` occurs.\n+    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool;\n \n-    pub fn report_extra_impl_obligation(\n+    fn report_fulfillment_error(\n         &self,\n-        error_span: Span,\n-        item_name: ast::Name,\n-        _impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-        requirement: &dyn fmt::Display,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        let msg = \"impl has stricter requirements than trait\";\n-        let sp = self.tcx.sess.source_map().def_span(error_span);\n+        error: &FulfillmentError<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    );\n+\n+    fn report_projection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &MismatchedProjectionTypes<'tcx>,\n+    );\n \n-        let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n+    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool;\n \n-        if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n-            let span = self.tcx.sess.source_map().def_span(trait_item_span);\n-            err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n-        }\n+    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str>;\n \n-        err.span_label(sp, format!(\"impl has extra requirement {}\", requirement));\n+    fn find_similar_impl_candidates(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<ty::TraitRef<'tcx>>;\n \n-        err\n-    }\n+    fn report_similar_impl_candidates(\n+        &self,\n+        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    );\n \n     /// Gets the parent trait chain start\n     fn get_parent_trait_ref(\n         &self,\n         code: &ObligationCauseCode<'tcx>,\n-    ) -> Option<(String, Option<Span>)> {\n-        match code {\n-            &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n-                match self.get_parent_trait_ref(&data.parent_code) {\n-                    Some(t) => Some(t),\n-                    None => {\n-                        let ty = parent_trait_ref.skip_binder().self_ty();\n-                        let span =\n-                            TyCategory::from_ty(ty).map(|(_, def_id)| self.tcx.def_span(def_id));\n-                        Some((ty.to_string(), span))\n-                    }\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n+    ) -> Option<(String, Option<Span>)>;\n+\n+    /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n+    /// with the same path as `trait_ref`, a help message about\n+    /// a probable version mismatch is added to `err`\n+    fn note_version_mismatch(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    );\n+\n+    fn mk_obligation_for_def_id(\n+        &self,\n+        def_id: DefId,\n+        output_ty: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> PredicateObligation<'tcx>;\n \n-    pub fn report_selection_error(\n+    fn maybe_report_ambiguity(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        error: &SelectionError<'tcx>,\n-        fallback_has_occurred: bool,\n-        points_at_arg: bool,\n-    ) {\n-        let tcx = self.tcx;\n-        let span = obligation.cause.span;\n-\n-        let mut err = match *error {\n-            SelectionError::Unimplemented => {\n-                if let ObligationCauseCode::CompareImplMethodObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                }\n-                | ObligationCauseCode::CompareImplTypeObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                } = obligation.cause.code\n-                {\n-                    self.report_extra_impl_obligation(\n-                        span,\n-                        item_name,\n-                        impl_item_def_id,\n-                        trait_item_def_id,\n-                        &format!(\"`{}`\", obligation.predicate),\n-                    )\n-                    .emit();\n-                    return;\n-                }\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(ref trait_predicate, _) => {\n-                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n-\n-                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n-                            return;\n-                        }\n-                        let trait_ref = trait_predicate.to_poly_trait_ref();\n-                        let (post_message, pre_message, type_def) = self\n-                            .get_parent_trait_ref(&obligation.cause.code)\n-                            .map(|(t, s)| {\n-                                (\n-                                    format!(\" in `{}`\", t),\n-                                    format!(\"within `{}`, \", t),\n-                                    s.map(|s| (format!(\"within this `{}`\", t), s)),\n-                                )\n-                            })\n-                            .unwrap_or_default();\n-\n-                        let OnUnimplementedNote { message, label, note, enclosing_scope } =\n-                            self.on_unimplemented_note(trait_ref, obligation);\n-                        let have_alt_message = message.is_some() || label.is_some();\n-                        let is_try = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .span_to_snippet(span)\n-                            .map(|s| &s == \"?\")\n-                            .unwrap_or(false);\n-                        let is_from = format!(\"{}\", trait_ref.print_only_trait_path())\n-                            .starts_with(\"std::convert::From<\");\n-                        let (message, note) = if is_try && is_from {\n-                            (\n-                                Some(format!(\n-                                    \"`?` couldn't convert the error to `{}`\",\n-                                    trait_ref.self_ty(),\n-                                )),\n-                                Some(\n-                                    \"the question mark operation (`?`) implicitly performs a \\\n-                                     conversion on the error value using the `From` trait\"\n-                                        .to_owned(),\n-                                ),\n-                            )\n-                        } else {\n-                            (message, note)\n-                        };\n+        body_id: Option<hir::BodyId>,\n+    );\n \n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0277,\n-                            \"{}\",\n-                            message.unwrap_or_else(|| format!(\n-                                \"the trait bound `{}` is not satisfied{}\",\n-                                trait_ref.without_const().to_predicate(),\n-                                post_message,\n-                            ))\n-                        );\n+    fn predicate_can_apply(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        pred: ty::PolyTraitRef<'tcx>,\n+    ) -> bool;\n \n-                        let explanation =\n-                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n-                                \"consider using `()`, or a `Result`\".to_owned()\n-                            } else {\n-                                format!(\n-                                    \"{}the trait `{}` is not implemented for `{}`\",\n-                                    pre_message,\n-                                    trait_ref.print_only_trait_path(),\n-                                    trait_ref.self_ty(),\n-                                )\n-                            };\n+    fn note_obligation_cause(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    );\n \n-                        if self.suggest_add_reference_to_arg(\n-                            &obligation,\n-                            &mut err,\n-                            &trait_ref,\n-                            points_at_arg,\n-                            have_alt_message,\n-                        ) {\n-                            self.note_obligation_cause(&mut err, obligation);\n-                            err.emit();\n-                            return;\n-                        }\n-                        if let Some(ref s) = label {\n-                            // If it has a custom `#[rustc_on_unimplemented]`\n-                            // error message, let's display it as the label!\n-                            err.span_label(span, s.as_str());\n-                            err.help(&explanation);\n-                        } else {\n-                            err.span_label(span, explanation);\n-                        }\n-                        if let Some((msg, span)) = type_def {\n-                            err.span_label(span, &msg);\n-                        }\n-                        if let Some(ref s) = note {\n-                            // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n-                            err.note(s.as_str());\n-                        }\n-                        if let Some(ref s) = enclosing_scope {\n-                            let enclosing_scope_span = tcx.def_span(\n-                                tcx.hir()\n-                                    .opt_local_def_id(obligation.cause.body_id)\n-                                    .unwrap_or_else(|| {\n-                                        tcx.hir().body_owner_def_id(hir::BodyId {\n-                                            hir_id: obligation.cause.body_id,\n-                                        })\n-                                    }),\n-                            );\n+    fn suggest_unsized_bound_if_applicable(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    );\n \n-                            err.span_label(enclosing_scope_span, s.as_str());\n-                        }\n+    fn is_recursive_obligation(\n+        &self,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+    ) -> bool;\n+}\n \n-                        self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n-                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n-                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n-                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n-                        self.note_version_mismatch(&mut err, &trait_ref);\n-                        if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n-                            err.emit();\n-                            return;\n-                        }\n+impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n+    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n+    // `error` occurring implies that `cond` occurs.\n+    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool {\n+        if cond == error {\n+            return true;\n+        }\n \n-                        // Try to report a help message\n-                        if !trait_ref.has_infer_types_or_consts()\n-                            && self.predicate_can_apply(obligation.param_env, trait_ref)\n-                        {\n-                            // If a where-clause may be useful, remind the\n-                            // user that they can add it.\n-                            //\n-                            // don't display an on-unimplemented note, as\n-                            // these notes will often be of the form\n-                            //     \"the type `T` can't be frobnicated\"\n-                            // which is somewhat confusing.\n-                            self.suggest_restricting_param_bound(\n-                                &mut err,\n-                                &trait_ref,\n-                                obligation.cause.body_id,\n-                            );\n-                        } else {\n-                            if !have_alt_message {\n-                                // Can't show anything else useful, try to find similar impls.\n-                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n-                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n-                            }\n-                            self.suggest_change_mut(\n-                                &obligation,\n-                                &mut err,\n-                                &trait_ref,\n-                                points_at_arg,\n-                            );\n-                        }\n+        let (cond, error) = match (cond, error) {\n+            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error, _)) => (cond, error),\n+            _ => {\n+                // FIXME: make this work in other cases too.\n+                return false;\n+            }\n+        };\n \n-                        // If this error is due to `!: Trait` not implemented but `(): Trait` is\n-                        // implemented, and fallback has occurred, then it could be due to a\n-                        // variable that used to fallback to `()` now falling back to `!`. Issue a\n-                        // note informing about the change in behaviour.\n-                        if trait_predicate.skip_binder().self_ty().is_never()\n-                            && fallback_has_occurred\n-                        {\n-                            let predicate = trait_predicate.map_bound(|mut trait_pred| {\n-                                trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n-                                    self.tcx.mk_unit(),\n-                                    &trait_pred.trait_ref.substs[1..],\n-                                );\n-                                trait_pred\n-                            });\n-                            let unit_obligation = Obligation {\n-                                predicate: ty::Predicate::Trait(\n-                                    predicate,\n-                                    hir::Constness::NotConst,\n-                                ),\n-                                ..obligation.clone()\n-                            };\n-                            if self.predicate_may_hold(&unit_obligation) {\n-                                err.note(\n-                                    \"the trait is implemented for `()`. \\\n-                                     Possibly this error has been caused by changes to \\\n-                                     Rust's type-inference algorithm (see issue #48950 \\\n-                                     <https://github.com/rust-lang/rust/issues/48950> \\\n-                                     for more information). Consider whether you meant to use \\\n-                                     the type `()` here instead.\",\n-                                );\n-                            }\n-                        }\n+        for implication in super::elaborate_predicates(self.tcx, vec![*cond]) {\n+            if let ty::Predicate::Trait(implication, _) = implication {\n+                let error = error.to_poly_trait_ref();\n+                let implication = implication.to_poly_trait_ref();\n+                // FIXME: I'm just not taking associated types at all here.\n+                // Eventually I'll need to implement param-env-aware\n+                // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n+                let param_env = ty::ParamEnv::empty();\n+                if self.can_sub(param_env, error, implication).is_ok() {\n+                    debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n+                    return true;\n+                }\n+            }\n+        }\n \n-                        err\n-                    }\n+        false\n+    }\n \n-                    ty::Predicate::Subtype(ref predicate) => {\n-                        // Errors for Subtype predicates show up as\n-                        // `FulfillmentErrorCode::CodeSubtypeError`,\n-                        // not selection error.\n-                        span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n-                    }\n+    fn report_fulfillment_error(\n+        &self,\n+        error: &FulfillmentError<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n+        debug!(\"report_fulfillment_error({:?})\", error);\n+        match error.code {\n+            FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n+                self.report_selection_error(\n+                    &error.obligation,\n+                    selection_error,\n+                    fallback_has_occurred,\n+                    error.points_at_arg_span,\n+                );\n+            }\n+            FulfillmentErrorCode::CodeProjectionError(ref e) => {\n+                self.report_projection_error(&error.obligation, e);\n+            }\n+            FulfillmentErrorCode::CodeAmbiguity => {\n+                self.maybe_report_ambiguity(&error.obligation, body_id);\n+            }\n+            FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n+                self.report_mismatched_types(\n+                    &error.obligation.cause,\n+                    expected_found.expected,\n+                    expected_found.found,\n+                    err.clone(),\n+                )\n+                .emit();\n+            }\n+        }\n+    }\n \n-                    ty::Predicate::RegionOutlives(ref predicate) => {\n-                        let predicate = self.resolve_vars_if_possible(predicate);\n-                        let err = self\n-                            .region_outlives_predicate(&obligation.cause, &predicate)\n-                            .err()\n-                            .unwrap();\n-                        struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0279,\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate,\n-                            err,\n-                        )\n-                    }\n+    fn report_projection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &MismatchedProjectionTypes<'tcx>,\n+    ) {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n \n-                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n-                        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n-                        struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0280,\n-                            \"the requirement `{}` is not satisfied\",\n-                            predicate\n-                        )\n-                    }\n+        if predicate.references_error() {\n+            return;\n+        }\n \n-                    ty::Predicate::ObjectSafe(trait_def_id) => {\n-                        let violations = self.tcx.object_safety_violations(trait_def_id);\n-                        report_object_safety_error(self.tcx, span, trait_def_id, violations)\n-                    }\n+        self.probe(|_| {\n+            let err_buf;\n+            let mut err = &error.err;\n+            let mut values = None;\n \n-                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                        let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n-                        let closure_span = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n-                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            closure_span,\n-                            E0525,\n-                            \"expected a closure that implements the `{}` trait, \\\n-                             but this closure only implements `{}`\",\n-                            kind,\n-                            found_kind\n-                        );\n+            // try to find the mismatched types to report the error with.\n+            //\n+            // this can fail if the problem was higher-ranked, in which\n+            // cause I have no idea for a good error message.\n+            if let ty::Predicate::Projection(ref data) = predicate {\n+                let mut selcx = SelectionContext::new(self);\n+                let (data, _) = self.replace_bound_vars_with_fresh_vars(\n+                    obligation.cause.span,\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    data,\n+                );\n+                let mut obligations = vec![];\n+                let normalized_ty = super::normalize_projection_type(\n+                    &mut selcx,\n+                    obligation.param_env,\n+                    data.projection_ty,\n+                    obligation.cause.clone(),\n+                    0,\n+                    &mut obligations,\n+                );\n \n-                        err.span_label(\n-                            closure_span,\n-                            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n-                        );\n-                        err.span_label(\n-                            obligation.cause.span,\n-                            format!(\"the requirement to implement `{}` derives from here\", kind),\n-                        );\n+                debug!(\n+                    \"report_projection_error obligation.cause={:?} obligation.param_env={:?}\",\n+                    obligation.cause, obligation.param_env\n+                );\n \n-                        // Additional context information explaining why the closure only implements\n-                        // a particular trait.\n-                        if let Some(tables) = self.in_progress_tables {\n-                            let tables = tables.borrow();\n-                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n-                                (ty::ClosureKind::FnOnce, Some((span, name))) => {\n-                                    err.span_label(\n-                                        *span,\n-                                        format!(\n-                                            \"closure is `FnOnce` because it moves the \\\n-                                         variable `{}` out of its environment\",\n-                                            name\n-                                        ),\n-                                    );\n-                                }\n-                                (ty::ClosureKind::FnMut, Some((span, name))) => {\n-                                    err.span_label(\n-                                        *span,\n-                                        format!(\n-                                            \"closure is `FnMut` because it mutates the \\\n-                                         variable `{}` here\",\n-                                            name\n-                                        ),\n-                                    );\n-                                }\n-                                _ => {}\n-                            }\n-                        }\n+                debug!(\n+                    \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n+                    normalized_ty, data.ty\n+                );\n \n-                        err.emit();\n-                        return;\n-                    }\n+                let is_normalized_ty_expected = match &obligation.cause.code {\n+                    ObligationCauseCode::ItemObligation(_)\n+                    | ObligationCauseCode::BindingObligation(_, _)\n+                    | ObligationCauseCode::ObjectCastObligation(_) => false,\n+                    _ => true,\n+                };\n \n-                    ty::Predicate::WellFormed(ty) => {\n-                        // WF predicates cannot themselves make\n-                        // errors. They can only block due to\n-                        // ambiguity; otherwise, they always\n-                        // degenerate into other obligations\n-                        // (which may fail).\n-                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n-                    }\n+                if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n+                    is_normalized_ty_expected,\n+                    normalized_ty,\n+                    data.ty,\n+                ) {\n+                    values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n+                        is_normalized_ty_expected,\n+                        normalized_ty,\n+                        data.ty,\n+                    )));\n \n-                    ty::Predicate::ConstEvaluatable(..) => {\n-                        // Errors for `ConstEvaluatable` predicates show up as\n-                        // `SelectionError::ConstEvalFailure`,\n-                        // not `Unimplemented`.\n-                        span_bug!(\n-                            span,\n-                            \"const-evaluatable requirement gave wrong error: `{:?}`\",\n-                            obligation\n-                        )\n-                    }\n+                    err_buf = error;\n+                    err = &err_buf;\n                 }\n             }\n \n-            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n-                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n-                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n-\n-                if expected_trait_ref.self_ty().references_error() {\n-                    return;\n-                }\n+            let msg = format!(\"type mismatch resolving `{}`\", predicate);\n+            let error_id = (DiagnosticMessageId::ErrorId(271), Some(obligation.cause.span), msg);\n+            let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+            if fresh {\n+                let mut diag = struct_span_err!(\n+                    self.tcx.sess,\n+                    obligation.cause.span,\n+                    E0271,\n+                    \"type mismatch resolving `{}`\",\n+                    predicate\n+                );\n+                self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n+                self.note_obligation_cause(&mut diag, obligation);\n+                diag.emit();\n+            }\n+        });\n+    }\n \n-                let found_trait_ty = found_trait_ref.self_ty();\n+    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+        /// returns the fuzzy category of a given type, or None\n+        /// if the type can be equated to any type.\n+        fn type_category(t: Ty<'_>) -> Option<u32> {\n+            match t.kind {\n+                ty::Bool => Some(0),\n+                ty::Char => Some(1),\n+                ty::Str => Some(2),\n+                ty::Int(..) | ty::Uint(..) | ty::Infer(ty::IntVar(..)) => Some(3),\n+                ty::Float(..) | ty::Infer(ty::FloatVar(..)) => Some(4),\n+                ty::Ref(..) | ty::RawPtr(..) => Some(5),\n+                ty::Array(..) | ty::Slice(..) => Some(6),\n+                ty::FnDef(..) | ty::FnPtr(..) => Some(7),\n+                ty::Dynamic(..) => Some(8),\n+                ty::Closure(..) => Some(9),\n+                ty::Tuple(..) => Some(10),\n+                ty::Projection(..) => Some(11),\n+                ty::Param(..) => Some(12),\n+                ty::Opaque(..) => Some(13),\n+                ty::Never => Some(14),\n+                ty::Adt(adt, ..) => match adt.adt_kind() {\n+                    AdtKind::Struct => Some(15),\n+                    AdtKind::Union => Some(16),\n+                    AdtKind::Enum => Some(17),\n+                },\n+                ty::Generator(..) => Some(18),\n+                ty::Foreign(..) => Some(19),\n+                ty::GeneratorWitness(..) => Some(20),\n+                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n+                ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+            }\n+        }\n \n-                let found_did = match found_trait_ty.kind {\n-                    ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n-                    ty::Adt(def, _) => Some(def.did),\n-                    _ => None,\n-                };\n+        match (type_category(a), type_category(b)) {\n+            (Some(cat_a), Some(cat_b)) => match (&a.kind, &b.kind) {\n+                (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n+                _ => cat_a == cat_b,\n+            },\n+            // infer and error can be equated to all types\n+            _ => true,\n+        }\n+    }\n \n-                let found_span = found_did\n-                    .and_then(|did| self.tcx.hir().span_if_local(did))\n-                    .map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n+    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str> {\n+        self.tcx.hir().body(body_id).generator_kind.map(|gen_kind| match gen_kind {\n+            hir::GeneratorKind::Gen => \"a generator\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"an async block\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"an async function\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"an async closure\",\n+        })\n+    }\n \n-                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n-                    // We check closures twice, with obligations flowing in different directions,\n-                    // but we want to complain about them only once.\n-                    return;\n-                }\n+    fn find_similar_impl_candidates(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<ty::TraitRef<'tcx>> {\n+        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n+        let all_impls = self.tcx.all_impls(trait_ref.def_id());\n \n-                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n+        match simp {\n+            Some(simp) => all_impls\n+                .iter()\n+                .filter_map(|&def_id| {\n+                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                    let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n+                    if let Some(imp_simp) = imp_simp {\n+                        if simp != imp_simp {\n+                            return None;\n+                        }\n+                    }\n \n-                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n-                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n-                    _ => vec![ArgKind::empty()],\n-                };\n+                    Some(imp)\n+                })\n+                .collect(),\n+            None => {\n+                all_impls.iter().map(|&def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect()\n+            }\n+        }\n+    }\n \n-                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n-                let expected = match expected_ty.kind {\n-                    ty::Tuple(ref tys) => tys\n-                        .iter()\n-                        .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span)))\n-                        .collect(),\n-                    _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n-                };\n+    fn report_similar_impl_candidates(\n+        &self,\n+        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        if impl_candidates.is_empty() {\n+            return;\n+        }\n \n-                if found.len() == expected.len() {\n-                    self.report_closure_arg_mismatch(\n-                        span,\n-                        found_span,\n-                        found_trait_ref,\n-                        expected_trait_ref,\n-                    )\n-                } else {\n-                    let (closure_span, found) = found_did\n-                        .and_then(|did| self.tcx.hir().get_if_local(did))\n-                        .map(|node| {\n-                            let (found_span, found) = self.get_fn_like_arguments(node);\n-                            (Some(found_span), found)\n-                        })\n-                        .unwrap_or((found_span, found));\n+        let len = impl_candidates.len();\n+        let end = if impl_candidates.len() <= 5 { impl_candidates.len() } else { 4 };\n \n-                    self.report_arg_count_mismatch(\n-                        span,\n-                        closure_span,\n-                        expected,\n-                        found,\n-                        found_trait_ty.is_closure(),\n-                    )\n+        let normalize = |candidate| {\n+            self.tcx.infer_ctxt().enter(|ref infcx| {\n+                let normalized = infcx\n+                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+                    .normalize(candidate)\n+                    .ok();\n+                match normalized {\n+                    Some(normalized) => format!(\"\\n  {:?}\", normalized.value),\n+                    None => format!(\"\\n  {:?}\", candidate),\n                 }\n-            }\n+            })\n+        };\n \n-            TraitNotObjectSafe(did) => {\n-                let violations = self.tcx.object_safety_violations(did);\n-                report_object_safety_error(self.tcx, span, did, violations)\n-            }\n+        // Sort impl candidates so that ordering is consistent for UI tests.\n+        let mut normalized_impl_candidates =\n+            impl_candidates.iter().map(normalize).collect::<Vec<String>>();\n \n-            ConstEvalFailure(ErrorHandled::TooGeneric) => {\n-                // In this instance, we have a const expression containing an unevaluated\n-                // generic parameter. We have no idea whether this expression is valid or\n-                // not (e.g. it might result in an error), but we don't want to just assume\n-                // that it's okay, because that might result in post-monomorphisation time\n-                // errors. The onus is really on the caller to provide values that it can\n-                // prove are well-formed.\n-                let mut err = self\n-                    .tcx\n-                    .sess\n-                    .struct_span_err(span, \"constant expression depends on a generic parameter\");\n-                // FIXME(const_generics): we should suggest to the user how they can resolve this\n-                // issue. However, this is currently not actually possible\n-                // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n-                err.note(\"this may fail depending on what value the parameter takes\");\n-                err\n-            }\n+        // Sort before taking the `..end` range,\n+        // because the ordering of `impl_candidates` may not be deterministic:\n+        // https://github.com/rust-lang/rust/pull/57475#issuecomment-455519507\n+        normalized_impl_candidates.sort();\n \n-            // Already reported in the query.\n-            ConstEvalFailure(ErrorHandled::Reported) => {\n-                self.tcx.sess.delay_span_bug(span, \"constant in type had an ignored error\");\n-                return;\n-            }\n+        err.help(&format!(\n+            \"the following implementations were found:{}{}\",\n+            normalized_impl_candidates[..end].join(\"\"),\n+            if len > 5 { format!(\"\\nand {} others\", len - 4) } else { String::new() }\n+        ));\n+    }\n \n-            Overflow => {\n-                bug!(\"overflow should be handled before the `report_selection_error` path\");\n+    /// Gets the parent trait chain start\n+    fn get_parent_trait_ref(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+    ) -> Option<(String, Option<Span>)> {\n+        match code {\n+            &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                match self.get_parent_trait_ref(&data.parent_code) {\n+                    Some(t) => Some(t),\n+                    None => {\n+                        let ty = parent_trait_ref.skip_binder().self_ty();\n+                        let span =\n+                            TyCategory::from_ty(ty).map(|(_, def_id)| self.tcx.def_span(def_id));\n+                        Some((ty.to_string(), span))\n+                    }\n+                }\n             }\n-        };\n-\n-        self.note_obligation_cause(&mut err, obligation);\n-        self.point_at_returns_when_relevant(&mut err, &obligation);\n-\n-        err.emit();\n+            _ => None,\n+        }\n     }\n \n     /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n@@ -990,102 +1319,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n         Obligation::new(cause, param_env, new_trait_ref.without_const().to_predicate())\n     }\n-}\n-\n-pub fn recursive_type_with_infinite_size_error(\n-    tcx: TyCtxt<'tcx>,\n-    type_def_id: DefId,\n-) -> DiagnosticBuilder<'tcx> {\n-    assert!(type_def_id.is_local());\n-    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n-    let span = tcx.sess.source_map().def_span(span);\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0072,\n-        \"recursive type `{}` has infinite size\",\n-        tcx.def_path_str(type_def_id)\n-    );\n-    err.span_label(span, \"recursive type has infinite size\");\n-    err.help(&format!(\n-        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n-                           at some point to make `{}` representable\",\n-        tcx.def_path_str(type_def_id)\n-    ));\n-    err\n-}\n-\n-pub fn report_object_safety_error(\n-    tcx: TyCtxt<'tcx>,\n-    span: Span,\n-    trait_def_id: DefId,\n-    violations: Vec<ObjectSafetyViolation>,\n-) -> DiagnosticBuilder<'tcx> {\n-    let trait_str = tcx.def_path_str(trait_def_id);\n-    let trait_span = tcx.hir().get_if_local(trait_def_id).and_then(|node| match node {\n-        hir::Node::Item(item) => Some(item.ident.span),\n-        _ => None,\n-    });\n-    let span = tcx.sess.source_map().def_span(span);\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0038,\n-        \"the trait `{}` cannot be made into an object\",\n-        trait_str\n-    );\n-    err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n-\n-    let mut reported_violations = FxHashSet::default();\n-    let mut had_span_label = false;\n-    for violation in violations {\n-        if let ObjectSafetyViolation::SizedSelf(sp) = &violation {\n-            if !sp.is_empty() {\n-                // Do not report `SizedSelf` without spans pointing at `SizedSelf` obligations\n-                // with a `Span`.\n-                reported_violations.insert(ObjectSafetyViolation::SizedSelf(vec![].into()));\n-            }\n-        }\n-        if reported_violations.insert(violation.clone()) {\n-            let spans = violation.spans();\n-            let msg = if trait_span.is_none() || spans.is_empty() {\n-                format!(\"the trait cannot be made into an object because {}\", violation.error_msg())\n-            } else {\n-                had_span_label = true;\n-                format!(\"...because {}\", violation.error_msg())\n-            };\n-            if spans.is_empty() {\n-                err.note(&msg);\n-            } else {\n-                for span in spans {\n-                    err.span_label(span, &msg);\n-                }\n-            }\n-            match (trait_span, violation.solution()) {\n-                (Some(_), Some((note, None))) => {\n-                    err.help(&note);\n-                }\n-                (Some(_), Some((note, Some((sugg, span))))) => {\n-                    err.span_suggestion(span, &note, sugg, Applicability::MachineApplicable);\n-                }\n-                // Only provide the help if its a local trait, otherwise it's not actionable.\n-                _ => {}\n-            }\n-        }\n-    }\n-    if let (Some(trait_span), true) = (trait_span, had_span_label) {\n-        err.span_label(trait_span, \"this trait cannot be made into an object...\");\n-    }\n-\n-    if tcx.sess.trait_methods_not_found.borrow().contains(&span) {\n-        // Avoid emitting error caused by non-existing method (#58734)\n-        err.cancel();\n-    }\n-\n-    err\n-}\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     fn maybe_report_ambiguity(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1385,6 +1619,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n+pub fn recursive_type_with_infinite_size_error(\n+    tcx: TyCtxt<'tcx>,\n+    type_def_id: DefId,\n+) -> DiagnosticBuilder<'tcx> {\n+    assert!(type_def_id.is_local());\n+    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0072,\n+        \"recursive type `{}` has infinite size\",\n+        tcx.def_path_str(type_def_id)\n+    );\n+    err.span_label(span, \"recursive type has infinite size\");\n+    err.help(&format!(\n+        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                           at some point to make `{}` representable\",\n+        tcx.def_path_str(type_def_id)\n+    ));\n+    err\n+}\n+\n /// Summarizes information\n #[derive(Clone)]\n pub enum ArgKind {"}, {"sha": "6e3074cd3ca98afc021efa001bc7f84a324c990e", "filename": "src/librustc_trait_selection/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -8,7 +8,27 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::sym;\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+use super::InferCtxtPrivExt;\n+\n+crate trait InferCtxtExt<'tcx> {\n+    /*private*/\n+    fn impl_similar_to(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> Option<DefId>;\n+\n+    /*private*/\n+    fn describe_enclosure(&self, hir_id: hir::HirId) -> Option<&'static str>;\n+\n+    fn on_unimplemented_note(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> OnUnimplementedNote;\n+}\n+\n+impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn impl_similar_to(\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -101,7 +121,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn on_unimplemented_note(\n+    fn on_unimplemented_note(\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         obligation: &PredicateObligation<'tcx>,"}, {"sha": "351e557d40b302d1f804c7305393429e3278c111", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 147, "deletions": 237, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -1,16 +1,13 @@\n use super::{\n-    ArgKind, EvaluationResult, Obligation, ObligationCause, ObligationCauseCode,\n-    PredicateObligation,\n+    EvaluationResult, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation,\n };\n \n use crate::infer::InferCtxt;\n use crate::traits::error_reporting::suggest_constraining_type_param;\n \n use rustc::ty::TypeckTables;\n use rustc::ty::{self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n-use rustc_errors::{\n-    error_code, pluralize, struct_span_err, Applicability, DiagnosticBuilder, Style,\n-};\n+use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder, Style};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -20,8 +17,136 @@ use rustc_span::symbol::{kw, sym};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    crate fn suggest_restricting_param_bound(\n+use super::InferCtxtPrivExt;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n+\n+crate trait InferCtxtExt<'tcx> {\n+    fn suggest_restricting_param_bound(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'_>,\n+        body_id: hir::HirId,\n+    );\n+\n+    fn suggest_borrow_on_unsized_slice(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+    );\n+\n+    fn get_closure_name(\n+        &self,\n+        def_id: DefId,\n+        err: &mut DiagnosticBuilder<'_>,\n+        msg: &str,\n+    ) -> Option<String>;\n+\n+    fn suggest_fn_call(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    );\n+\n+    fn suggest_add_reference_to_arg(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+        has_custom_message: bool,\n+    ) -> bool;\n+\n+    fn suggest_remove_reference(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    );\n+\n+    fn suggest_change_mut(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    );\n+\n+    fn suggest_semicolon_removal(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    );\n+\n+    fn suggest_impl_trait(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) -> bool;\n+\n+    fn point_at_returns_when_relevant(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    );\n+\n+    fn report_closure_arg_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_ref: ty::PolyTraitRef<'tcx>,\n+        found: ty::PolyTraitRef<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx>;\n+\n+    fn suggest_fully_qualified_path(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        def_id: DefId,\n+        span: Span,\n+        trait_ref: DefId,\n+    );\n+\n+    fn maybe_note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool;\n+\n+    fn note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        target_span: Span,\n+        scope_span: &Option<Span>,\n+        expr: Option<hir::HirId>,\n+        snippet: String,\n+        first_generator: DefId,\n+        last_generator: Option<DefId>,\n+        trait_ref: ty::TraitRef<'_>,\n+        target_ty: Ty<'tcx>,\n+        tables: &ty::TypeckTables<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+        next_code: Option<&ObligationCauseCode<'tcx>>,\n+    );\n+\n+    fn note_obligation_cause_code<T>(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        predicate: &T,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+    ) where\n+        T: fmt::Display;\n+\n+    fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>);\n+}\n+\n+impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+    fn suggest_restricting_param_bound(\n         &self,\n         mut err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::PolyTraitRef<'_>,\n@@ -168,7 +293,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n     /// suggestion to borrow the initializer in order to use have a slice instead.\n-    crate fn suggest_borrow_on_unsized_slice(\n+    fn suggest_borrow_on_unsized_slice(\n         &self,\n         code: &ObligationCauseCode<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -195,7 +320,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Given a closure's `DefId`, return the given name of the closure.\n     ///\n     /// This doesn't account for reassignments, but it's only used for suggestions.\n-    crate fn get_closure_name(\n+    fn get_closure_name(\n         &self,\n         def_id: DefId,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -233,7 +358,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// We tried to apply the bound to an `fn` or closure. Check whether calling it would\n     /// evaluate to a type that *would* satisfy the trait binding. If it would, suggest calling\n     /// it: `bar(foo)` \u2192 `bar(foo())`. This case is *very* likely to be hit if `foo` is `async`.\n-    crate fn suggest_fn_call(\n+    fn suggest_fn_call(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -317,7 +442,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn suggest_add_reference_to_arg(\n+    fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -389,7 +514,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n     /// suggest removing these references until we reach a type that implements the trait.\n-    crate fn suggest_remove_reference(\n+    fn suggest_remove_reference(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -451,7 +576,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Check if the trait bound is implemented for a different mutability and note it in the\n     /// final error.\n-    crate fn suggest_change_mut(\n+    fn suggest_change_mut(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -513,7 +638,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn suggest_semicolon_removal(\n+    fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -549,7 +674,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// If all conditions are met to identify a returned `dyn Trait`, suggest using `impl Trait` if\n     /// applicable and signal that the error has been expanded appropriately and needs to be\n     /// emitted.\n-    crate fn suggest_impl_trait(\n+    fn suggest_impl_trait(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,\n         span: Span,\n@@ -723,7 +848,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         true\n     }\n \n-    crate fn point_at_returns_when_relevant(\n+    fn point_at_returns_when_relevant(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n@@ -753,220 +878,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Given some node representing a fn-like thing in the HIR map,\n-    /// returns a span and `ArgKind` information that describes the\n-    /// arguments it expects. This can be supplied to\n-    /// `report_arg_count_mismatch`.\n-    pub fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n-        match node {\n-            Node::Expr(&hir::Expr {\n-                kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n-                ..\n-            }) => (\n-                self.tcx.sess.source_map().def_span(span),\n-                self.tcx\n-                    .hir()\n-                    .body(id)\n-                    .params\n-                    .iter()\n-                    .map(|arg| {\n-                        if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n-                            *arg.pat\n-                        {\n-                            ArgKind::Tuple(\n-                                Some(span),\n-                                args.iter()\n-                                    .map(|pat| {\n-                                        let snippet = self\n-                                            .tcx\n-                                            .sess\n-                                            .source_map()\n-                                            .span_to_snippet(pat.span)\n-                                            .unwrap();\n-                                        (snippet, \"_\".to_owned())\n-                                    })\n-                                    .collect::<Vec<_>>(),\n-                            )\n-                        } else {\n-                            let name =\n-                                self.tcx.sess.source_map().span_to_snippet(arg.pat.span).unwrap();\n-                            ArgKind::Arg(name, \"_\".to_owned())\n-                        }\n-                    })\n-                    .collect::<Vec<ArgKind>>(),\n-            ),\n-            Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n-            | Node::ImplItem(&hir::ImplItem {\n-                span,\n-                kind: hir::ImplItemKind::Method(ref sig, _),\n-                ..\n-            })\n-            | Node::TraitItem(&hir::TraitItem {\n-                span,\n-                kind: hir::TraitItemKind::Fn(ref sig, _),\n-                ..\n-            }) => (\n-                self.tcx.sess.source_map().def_span(span),\n-                sig.decl\n-                    .inputs\n-                    .iter()\n-                    .map(|arg| match arg.clone().kind {\n-                        hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n-                            Some(arg.span),\n-                            vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],\n-                        ),\n-                        _ => ArgKind::empty(),\n-                    })\n-                    .collect::<Vec<ArgKind>>(),\n-            ),\n-            Node::Ctor(ref variant_data) => {\n-                let span = variant_data\n-                    .ctor_hir_id()\n-                    .map(|hir_id| self.tcx.hir().span(hir_id))\n-                    .unwrap_or(DUMMY_SP);\n-                let span = self.tcx.sess.source_map().def_span(span);\n-\n-                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n-            }\n-            _ => panic!(\"non-FnLike node found: {:?}\", node),\n-        }\n-    }\n-\n-    /// Reports an error when the number of arguments needed by a\n-    /// trait match doesn't match the number that the expression\n-    /// provides.\n-    pub fn report_arg_count_mismatch(\n-        &self,\n-        span: Span,\n-        found_span: Option<Span>,\n-        expected_args: Vec<ArgKind>,\n-        found_args: Vec<ArgKind>,\n-        is_closure: bool,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        let kind = if is_closure { \"closure\" } else { \"function\" };\n-\n-        let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n-            let arg_length = arguments.len();\n-            let distinct = match &other[..] {\n-                &[ArgKind::Tuple(..)] => true,\n-                _ => false,\n-            };\n-            match (arg_length, arguments.get(0)) {\n-                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n-                    format!(\"a single {}-tuple as argument\", fields.len())\n-                }\n-                _ => format!(\n-                    \"{} {}argument{}\",\n-                    arg_length,\n-                    if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n-                    pluralize!(arg_length)\n-                ),\n-            }\n-        };\n-\n-        let expected_str = args_str(&expected_args, &found_args);\n-        let found_str = args_str(&found_args, &expected_args);\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            span,\n-            E0593,\n-            \"{} is expected to take {}, but it takes {}\",\n-            kind,\n-            expected_str,\n-            found_str,\n-        );\n-\n-        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n-\n-        if let Some(found_span) = found_span {\n-            err.span_label(found_span, format!(\"takes {}\", found_str));\n-\n-            // move |_| { ... }\n-            // ^^^^^^^^-- def_span\n-            //\n-            // move |_| { ... }\n-            // ^^^^^-- prefix\n-            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n-            // move |_| { ... }\n-            //      ^^^-- pipe_span\n-            let pipe_span =\n-                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n-\n-            // Suggest to take and ignore the arguments with expected_args_length `_`s if\n-            // found arguments is empty (assume the user just wants to ignore args in this case).\n-            // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n-            if found_args.is_empty() && is_closure {\n-                let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n-                err.span_suggestion(\n-                    pipe_span,\n-                    &format!(\n-                        \"consider changing the closure to take and ignore the expected argument{}\",\n-                        if expected_args.len() < 2 { \"\" } else { \"s\" }\n-                    ),\n-                    format!(\"|{}|\", underscores),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-\n-            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n-                if fields.len() == expected_args.len() {\n-                    let sugg = fields\n-                        .iter()\n-                        .map(|(name, _)| name.to_owned())\n-                        .collect::<Vec<String>>()\n-                        .join(\", \");\n-                    err.span_suggestion(\n-                        found_span,\n-                        \"change the closure to take multiple arguments instead of a single tuple\",\n-                        format!(\"|{}|\", sugg),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n-                if fields.len() == found_args.len() && is_closure {\n-                    let sugg = format!(\n-                        \"|({}){}|\",\n-                        found_args\n-                            .iter()\n-                            .map(|arg| match arg {\n-                                ArgKind::Arg(name, _) => name.to_owned(),\n-                                _ => \"_\".to_owned(),\n-                            })\n-                            .collect::<Vec<String>>()\n-                            .join(\", \"),\n-                        // add type annotations if available\n-                        if found_args.iter().any(|arg| match arg {\n-                            ArgKind::Arg(_, ty) => ty != \"_\",\n-                            _ => false,\n-                        }) {\n-                            format!(\n-                                \": ({})\",\n-                                fields\n-                                    .iter()\n-                                    .map(|(_, ty)| ty.to_owned())\n-                                    .collect::<Vec<String>>()\n-                                    .join(\", \")\n-                            )\n-                        } else {\n-                            String::new()\n-                        },\n-                    );\n-                    err.span_suggestion(\n-                        found_span,\n-                        \"change the closure to accept a tuple instead of individual arguments\",\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-\n-        err\n-    }\n-\n-    crate fn report_closure_arg_mismatch(\n+    fn report_closure_arg_mismatch(\n         &self,\n         span: Span,\n         found_span: Option<Span>,\n@@ -1022,10 +934,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         err\n     }\n-}\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    crate fn suggest_fully_qualified_path(\n+    fn suggest_fully_qualified_path(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         def_id: DefId,\n@@ -1091,7 +1001,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// ```\n     ///\n     /// Returns `true` if an async-await specific note was added to the diagnostic.\n-    crate fn maybe_note_obligation_cause_for_async_await(\n+    fn maybe_note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1271,7 +1181,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Unconditionally adds the diagnostic note described in\n     /// `maybe_note_obligation_cause_for_async_await`'s documentation comment.\n-    crate fn note_obligation_cause_for_async_await(\n+    fn note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         target_span: Span,\n@@ -1423,7 +1333,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         );\n     }\n \n-    crate fn note_obligation_cause_code<T>(\n+    fn note_obligation_cause_code<T>(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         predicate: &T,\n@@ -1638,7 +1548,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>) {\n         let current_limit = self.tcx.sess.recursion_limit.get();\n         let suggested_limit = current_limit * 2;\n         err.help(&format!("}, {"sha": "5def77ce7324cba1f1b5f48024874cbf9212e073", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -4,9 +4,9 @@ use rustc::ty::{self, ToPolyTraitRef, Ty, TypeFoldable};\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n+use rustc_infer::traits::{TraitEngine, TraitEngineExt as _};\n use std::marker::PhantomData;\n \n-use super::engine::{TraitEngine, TraitEngineExt};\n use super::project;\n use super::select::SelectionContext;\n use super::wf;\n@@ -17,6 +17,9 @@ use super::{ConstEvalFailure, Unimplemented};\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation};\n \n+use crate::traits::error_reporting::InferCtxtExt as _;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n+\n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     /// Note that we include both the `ParamEnv` and the `Predicate`,\n     /// as the `ParamEnv` can influence whether fulfillment succeeds"}, {"sha": "d500cff67c64b01b0f862266a2c4e55bb7b43ca0", "filename": "src/librustc_trait_selection/traits/misc.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmisc.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -1,10 +1,13 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n-use crate::infer::TyCtxtInferExt;\n+use crate::infer::InferCtxtExt as _;\n use crate::traits::{self, ObligationCause};\n \n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as hir;\n+use rustc_infer::infer::TyCtxtInferExt;\n+\n+use crate::traits::error_reporting::InferCtxtExt;\n \n #[derive(Clone)]\n pub enum CopyImplementationError<'tcx> {"}, {"sha": "7b93982db974b94c4bf757708e67092eb4e39a71", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 117, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -13,19 +13,18 @@ pub mod misc;\n mod object_safety;\n mod on_unimplemented;\n mod project;\n-mod projection_cache;\n pub mod query;\n mod select;\n mod specialize;\n-mod structural_impls;\n mod structural_match;\n mod util;\n pub mod wf;\n \n use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::{InferCtxt, SuppressRegionErrors, TyCtxtInferExt};\n+use crate::traits::error_reporting::InferCtxtExt as _;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc::middle::region;\n-use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, WithConstness};\n@@ -43,7 +42,7 @@ pub use self::Vtable::*;\n \n pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n pub use self::coherence::{OrphanCheckErr, OverlapResult};\n-pub use self::engine::{TraitEngine, TraitEngineExt};\n+pub use self::engine::TraitEngineExt;\n pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;\n@@ -53,11 +52,6 @@ pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::project::{\n     normalize, normalize_projection_type, normalize_to, poly_project_and_unify_type,\n };\n-pub use self::projection_cache::MismatchedProjectionTypes;\n-pub use self::projection_cache::{\n-    Normalized, ProjectionCache, ProjectionCacheEntry, ProjectionCacheKey, ProjectionCacheSnapshot,\n-    Reveal,\n-};\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::find_associated_item;\n@@ -77,7 +71,7 @@ pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n };\n \n-pub use rustc::traits::*;\n+pub use rustc_infer::traits::*;\n \n /// Whether to skip the leak check, as part of a future compatibility warning step.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -114,61 +108,6 @@ pub enum TraitQueryMode {\n     Canonical,\n }\n \n-/// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n-/// which the vtable must be found. The process of finding a vtable is\n-/// called \"resolving\" the `Obligation`. This process consists of\n-/// either identifying an `impl` (e.g., `impl Eq for int`) that\n-/// provides the required vtable, or else finding a bound that is in\n-/// scope. The eventual result is usually a `Selection` (defined below).\n-#[derive(Clone, PartialEq, Eq, Hash)]\n-pub struct Obligation<'tcx, T> {\n-    /// The reason we have to prove this thing.\n-    pub cause: ObligationCause<'tcx>,\n-\n-    /// The environment in which we should prove this thing.\n-    pub param_env: ty::ParamEnv<'tcx>,\n-\n-    /// The thing we are trying to prove.\n-    pub predicate: T,\n-\n-    /// If we started proving this as a result of trying to prove\n-    /// something else, track the total depth to ensure termination.\n-    /// If this goes over a certain threshold, we abort compilation --\n-    /// in such cases, we can not say whether or not the predicate\n-    /// holds for certain. Stupid halting problem; such a drag.\n-    pub recursion_depth: usize,\n-}\n-\n-pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n-pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n-\n-// `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PredicateObligation<'_>, 112);\n-\n-pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n-pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n-pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n-\n-pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n-\n-pub struct FulfillmentError<'tcx> {\n-    pub obligation: PredicateObligation<'tcx>,\n-    pub code: FulfillmentErrorCode<'tcx>,\n-    /// Diagnostics only: we opportunistically change the `code.span` when we encounter an\n-    /// obligation error caused by a call argument. When this is the case, we also signal that in\n-    /// this field to ensure accuracy of suggestions.\n-    pub points_at_arg_span: bool,\n-}\n-\n-#[derive(Clone)]\n-pub enum FulfillmentErrorCode<'tcx> {\n-    CodeSelectionError(SelectionError<'tcx>),\n-    CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n-    CodeSubtypeError(ExpectedFound<Ty<'tcx>>, TypeError<'tcx>), // always comes from a SubtypePredicate\n-    CodeAmbiguity,\n-}\n-\n /// Creates predicate obligations from the generic bounds.\n pub fn predicates_for_generics<'tcx>(\n     cause: ObligationCause<'tcx>,\n@@ -581,58 +520,6 @@ fn vtable_methods<'tcx>(\n     }))\n }\n \n-impl<'tcx, O> Obligation<'tcx, O> {\n-    pub fn new(\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        predicate: O,\n-    ) -> Obligation<'tcx, O> {\n-        Obligation { cause, param_env, recursion_depth: 0, predicate }\n-    }\n-\n-    fn with_depth(\n-        cause: ObligationCause<'tcx>,\n-        recursion_depth: usize,\n-        param_env: ty::ParamEnv<'tcx>,\n-        predicate: O,\n-    ) -> Obligation<'tcx, O> {\n-        Obligation { cause, param_env, recursion_depth, predicate }\n-    }\n-\n-    pub fn misc(\n-        span: Span,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: O,\n-    ) -> Obligation<'tcx, O> {\n-        Obligation::new(ObligationCause::misc(span, body_id), param_env, trait_ref)\n-    }\n-\n-    pub fn with<P>(&self, value: P) -> Obligation<'tcx, P> {\n-        Obligation {\n-            cause: self.cause.clone(),\n-            param_env: self.param_env,\n-            recursion_depth: self.recursion_depth,\n-            predicate: value,\n-        }\n-    }\n-}\n-\n-impl<'tcx> FulfillmentError<'tcx> {\n-    fn new(\n-        obligation: PredicateObligation<'tcx>,\n-        code: FulfillmentErrorCode<'tcx>,\n-    ) -> FulfillmentError<'tcx> {\n-        FulfillmentError { obligation, code, points_at_arg_span: false }\n-    }\n-}\n-\n-impl<'tcx> TraitObligation<'tcx> {\n-    fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.predicate.map_bound(|p| p.self_ty())\n-    }\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     object_safety::provide(providers);\n     *providers = ty::query::Providers {"}, {"sha": "d0d41f3ae32ad33d117635b5d756d106d0465883", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -11,6 +11,7 @@\n use super::elaborate_predicates;\n \n use crate::infer::TyCtxtInferExt;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};"}, {"sha": "dde78aa4357e9d0240ab5ead86d52d490b9917f4", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -1,7 +1,6 @@\n //! Code for projecting associated types out of trait references.\n \n use super::elaborate_predicates;\n-use super::projection_cache::NormalizedTy;\n use super::specialization_graph;\n use super::translate_substs;\n use super::util;\n@@ -12,11 +11,12 @@ use super::PredicateObligation;\n use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n-use super::{Normalized, ProjectionCacheEntry, ProjectionCacheKey};\n+use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n use super::{VtableClosureData, VtableFnPointerData, VtableGeneratorData, VtableImplData};\n \n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use crate::traits::error_reporting::InferCtxtExt;\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n@@ -452,7 +452,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     let infcx = selcx.infcx();\n \n     let projection_ty = infcx.resolve_vars_if_possible(&projection_ty);\n-    let cache_key = ProjectionCacheKey { ty: projection_ty };\n+    let cache_key = ProjectionCacheKey::new(projection_ty);\n \n     debug!(\n         \"opt_normalize_projection_type(\\\n@@ -1483,20 +1483,29 @@ fn assoc_ty_def(\n     }\n }\n \n-impl<'cx, 'tcx> ProjectionCacheKey<'tcx> {\n-    pub fn from_poly_projection_predicate(\n+crate trait ProjectionCacheKeyExt<'tcx>: Sized {\n+    fn from_poly_projection_predicate(\n+        selcx: &mut SelectionContext<'cx, 'tcx>,\n+        predicate: &ty::PolyProjectionPredicate<'tcx>,\n+    ) -> Option<Self>;\n+}\n+\n+impl<'tcx> ProjectionCacheKeyExt<'tcx> for ProjectionCacheKey<'tcx> {\n+    fn from_poly_projection_predicate(\n         selcx: &mut SelectionContext<'cx, 'tcx>,\n         predicate: &ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<Self> {\n         let infcx = selcx.infcx();\n         // We don't do cross-snapshot caching of obligations with escaping regions,\n         // so there's no cache key to use\n-        predicate.no_bound_vars().map(|predicate| ProjectionCacheKey {\n-            // We don't attempt to match up with a specific type-variable state\n-            // from a specific call to `opt_normalize_projection_type` - if\n-            // there's no precise match, the original cache entry is \"stranded\"\n-            // anyway.\n-            ty: infcx.resolve_vars_if_possible(&predicate.projection_ty),\n+        predicate.no_bound_vars().map(|predicate| {\n+            ProjectionCacheKey::new(\n+                // We don't attempt to match up with a specific type-variable state\n+                // from a specific call to `opt_normalize_projection_type` - if\n+                // there's no precise match, the original cache entry is \"stranded\"\n+                // anyway.\n+                infcx.resolve_vars_if_possible(&predicate.projection_ty),\n+            )\n         })\n     }\n }"}, {"sha": "40a21b5a6ed4aa53cd45c9af5645d1677accfe64", "filename": "src/librustc_trait_selection/traits/query/dropck_outlives.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -7,7 +7,11 @@ use rustc::ty::{self, Ty, TyCtxt};\n \n pub use rustc::traits::query::{DropckOutlivesResult, DtorckConstraint};\n \n-impl<'cx, 'tcx> At<'cx, 'tcx> {\n+pub trait AtExt<'tcx> {\n+    fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<GenericArg<'tcx>>>;\n+}\n+\n+impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n     /// of \"kinds\" (types, regions) that must be outlive the execution\n     /// of the destructor. These basically correspond to data that the\n@@ -25,7 +29,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n     ///\n     /// [#1238]: https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n     /// [#1327]: https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md\n-    pub fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<GenericArg<'tcx>>> {\n+    fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<GenericArg<'tcx>>> {\n         debug!(\"dropck_outlives(ty={:?}, param_env={:?})\", ty, self.param_env,);\n \n         // Quick check: there are a number of cases that we know do not require"}, {"sha": "0569f6217da653c38c9c6bbeb6af332974fadd3a", "filename": "src/librustc_trait_selection/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -4,10 +4,35 @@ use crate::traits::{\n     EvaluationResult, OverflowError, PredicateObligation, SelectionContext, TraitQueryMode,\n };\n \n-impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n+pub trait InferCtxtExt<'tcx> {\n+    fn predicate_may_hold(&self, obligation: &PredicateObligation<'tcx>) -> bool;\n+\n+    fn predicate_must_hold_considering_regions(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool;\n+\n+    fn predicate_must_hold_modulo_regions(&self, obligation: &PredicateObligation<'tcx>) -> bool;\n+\n+    fn evaluate_obligation(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> Result<EvaluationResult, OverflowError>;\n+\n+    // Helper function that canonicalizes and runs the query. If an\n+    // overflow results, we re-run it in the local context so we can\n+    // report a nice error.\n+    /*crate*/\n+    fn evaluate_obligation_no_overflow(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> EvaluationResult;\n+}\n+\n+impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// Evaluates whether the predicate can be satisfied (by any means)\n     /// in the given `ParamEnv`.\n-    pub fn predicate_may_hold(&self, obligation: &PredicateObligation<'tcx>) -> bool {\n+    fn predicate_may_hold(&self, obligation: &PredicateObligation<'tcx>) -> bool {\n         self.evaluate_obligation_no_overflow(obligation).may_apply()\n     }\n \n@@ -17,7 +42,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ///\n     /// This version may conservatively fail when outlives obligations\n     /// are required.\n-    pub fn predicate_must_hold_considering_regions(\n+    fn predicate_must_hold_considering_regions(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> bool {\n@@ -29,15 +54,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// not entirely accurate if inference variables are involved.\n     ///\n     /// This version ignores all outlives constraints.\n-    pub fn predicate_must_hold_modulo_regions(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-    ) -> bool {\n+    fn predicate_must_hold_modulo_regions(&self, obligation: &PredicateObligation<'tcx>) -> bool {\n         self.evaluate_obligation_no_overflow(obligation).must_apply_modulo_regions()\n     }\n \n     /// Evaluate a given predicate, capturing overflow and propagating it back.\n-    pub fn evaluate_obligation(\n+    fn evaluate_obligation(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n@@ -53,7 +75,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     // Helper function that canonicalizes and runs the query. If an\n     // overflow results, we re-run it in the local context so we can\n     // report a nice error.\n-    crate fn evaluate_obligation_no_overflow(\n+    fn evaluate_obligation_no_overflow(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> EvaluationResult {"}, {"sha": "adec2ddb25322c7f2987e7351ba82ff55acfa097", "filename": "src/librustc_trait_selection/traits/query/normalize.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -5,17 +5,24 @@\n use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::Normalized;\n+use crate::traits::error_reporting::InferCtxtExt;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_infer::traits::Normalized;\n \n use super::NoSolution;\n \n pub use rustc::traits::query::NormalizationResult;\n \n-impl<'cx, 'tcx> At<'cx, 'tcx> {\n+pub trait AtExt<'tcx> {\n+    fn normalize<T>(&self, value: &T) -> Result<Normalized<'tcx, T>, NoSolution>\n+    where\n+        T: TypeFoldable<'tcx>;\n+}\n+\n+impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n     /// Normalize `value` in the context of the inference context,\n     /// yielding a resulting type, or an error if `value` cannot be\n     /// normalized. If you don't care about regions, you should prefer\n@@ -29,7 +36,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// normalizing, but for now should be used only when we actually\n     /// know that normalization will succeed, since error reporting\n     /// and other details are still \"under development\".\n-    pub fn normalize<T>(&self, value: &T) -> Result<Normalized<'tcx, T>, NoSolution>\n+    fn normalize<T>(&self, value: &T) -> Result<Normalized<'tcx, T>, NoSolution>\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "05c96dd520ab732b5c182181ea6afd5ba5c4b245", "filename": "src/librustc_trait_selection/traits/query/outlives_bounds.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -1,14 +1,25 @@\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferCtxt;\n use crate::traits::query::NoSolution;\n-use crate::traits::{FulfillmentContext, ObligationCause, TraitEngine, TraitEngineExt};\n+use crate::traits::{FulfillmentContext, ObligationCause, TraitEngine};\n use rustc::ty::{self, Ty};\n use rustc_hir as hir;\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::Span;\n \n pub use rustc::traits::query::OutlivesBound;\n \n-impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n+pub trait InferCtxtExt<'tcx> {\n+    fn implied_outlives_bounds(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: hir::HirId,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Vec<OutlivesBound<'tcx>>;\n+}\n+\n+impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// Implied bounds are region relationships that we deduce\n     /// automatically. The idea is that (e.g.) a caller must check that a\n     /// function's argument types are well-formed immediately before\n@@ -30,7 +41,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// - `ty`, the type that we are supposed to assume is WF.\n     /// - `span`, a span to use when normalizing, hopefully not important,\n     ///   might be useful if a `bug!` occurs.\n-    pub fn implied_outlives_bounds(\n+    fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         body_id: hir::HirId,"}, {"sha": "915e8ae4a7ad6bbd1b57bf66d4f6442934ee70cb", "filename": "src/librustc_trait_selection/traits/query/type_op/custom.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -4,7 +4,9 @@ use std::fmt;\n \n use crate::infer::canonical::query_response;\n use crate::infer::canonical::QueryRegionConstraints;\n-use crate::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n+use crate::traits::engine::TraitEngineExt as _;\n+use crate::traits::{ObligationCause, TraitEngine};\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::DUMMY_SP;\n use std::rc::Rc;\n "}, {"sha": "ab3214d8d2d234b09922c687e8dec4296b0fb061", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -33,6 +33,8 @@ use super::{\n };\n \n use crate::infer::{CombinedSnapshot, InferCtxt, InferOk, PlaceholderMap, TypeFreshener};\n+use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::project::ProjectionCacheKeyExt;\n use rustc::dep_graph::{DepKind, DepNodeIndex};\n use rustc::middle::lang_items;\n use rustc::ty::fast_reject;\n@@ -3464,9 +3466,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n }\n \n-impl<'tcx> TraitObligation<'tcx> {\n+trait TraitObligationExt<'tcx> {\n+    fn derived_cause(\n+        &self,\n+        variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>,\n+    ) -> ObligationCause<'tcx>;\n+}\n+\n+impl<'tcx> TraitObligationExt<'tcx> for TraitObligation<'tcx> {\n     #[allow(unused_comparisons)]\n-    pub fn derived_cause(\n+    fn derived_cause(\n         &self,\n         variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>,\n     ) -> ObligationCause<'tcx> {"}, {"sha": "b69c5bdce2abc713b7a8ced083cf4e8d1643563f", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0535dd3721816f0df997976632fd5b133dbde1b3/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=0535dd3721816f0df997976632fd5b133dbde1b3", "patch": "@@ -1,5 +1,5 @@\n-use crate::infer::opaque_types::required_region_bounds;\n use crate::infer::InferCtxt;\n+use crate::opaque_types::required_region_bounds;\n use crate::traits::{self, AssocTypeBoundData};\n use rustc::middle::lang_items;\n use rustc::ty::subst::SubstsRef;"}]}