{"sha": "3b871402998d093de327dc2bf424f69fab277b54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiODcxNDAyOTk4ZDA5M2RlMzI3ZGMyYmY0MjRmNjlmYWIyNzdiNTQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-09T10:23:59Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-09T18:54:42Z"}, "message": "Rollup merge of #24191 - nikomatsakis:issue-20791, r=pnkfelix\n\n Modify the ExprUseVisitor to walk each part of an AutoRef, and in\nparticular to treat an AutoUnsize as as kind of \\\"instantaneous\\\" borrow\nof the value being unsized. This prevents us from feeding uninitialized\ndata.\n\nThis caused a problem for the eager reborrow of comparison traits,\nbecause that wound up introducing a \\\"double AutoRef\\\", which was not\nbeing thoroughly checked before but turned out not to type check.\nFortunately, we can just remove that \\\"eager reborrow\\\" as it is no longer\nneeded now that `PartialEq` doesn't force both LHS and RHS to have the\nsame type (and even if we did have this problem, the better way would be\nto lean on introducing a common supertype).\n\nFixes #20791.\n\nr? @nrc", "tree": {"sha": "70a20a8fc0d7e0ae1ea9d13e6450bded8cde7b03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70a20a8fc0d7e0ae1ea9d13e6450bded8cde7b03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b871402998d093de327dc2bf424f69fab277b54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b871402998d093de327dc2bf424f69fab277b54", "html_url": "https://github.com/rust-lang/rust/commit/3b871402998d093de327dc2bf424f69fab277b54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b871402998d093de327dc2bf424f69fab277b54/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68100e4c07f986dfacbd75b38cd25336de344b7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/68100e4c07f986dfacbd75b38cd25336de344b7c", "html_url": "https://github.com/rust-lang/rust/commit/68100e4c07f986dfacbd75b38cd25336de344b7c"}, {"sha": "1e79870770c08973d018e71d309816b970c7abe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e79870770c08973d018e71d309816b970c7abe1", "html_url": "https://github.com/rust-lang/rust/commit/1e79870770c08973d018e71d309816b970c7abe1"}], "stats": {"total": 300, "additions": 226, "deletions": 74}, "files": [{"sha": "ee9d1e015539e337a18a19ca066d6ddb197b2610", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=3b871402998d093de327dc2bf424f69fab277b54", "patch": "@@ -662,7 +662,19 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n               cmt: mc::cmt<'tcx>,\n               _loan_region: ty::Region,\n               bk: ty::BorrowKind,\n-              loan_cause: euv::LoanCause) {\n+              loan_cause: euv::LoanCause)\n+    {\n+        // Kind of hacky, but we allow Unsafe coercions in constants.\n+        // These occur when we convert a &T or *T to a *U, as well as\n+        // when making a thin pointer (e.g., `*T`) into a fat pointer\n+        // (e.g., `*Trait`).\n+        match loan_cause {\n+            euv::LoanCause::AutoUnsafe => {\n+                return;\n+            }\n+            _ => { }\n+        }\n+\n         let mut cur = &cmt;\n         let mut is_interior = false;\n         loop {"}, {"sha": "18e634a2dd6308ecb23e3e35cb4c8578bf075fd9", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 145, "deletions": 28, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3b871402998d093de327dc2bf424f69fab277b54", "patch": "@@ -99,6 +99,7 @@ pub enum LoanCause {\n     ClosureCapture(Span),\n     AddrOf,\n     AutoRef,\n+    AutoUnsafe,\n     RefBinding,\n     OverloadedOperator,\n     ClosureInvocation,\n@@ -800,18 +801,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                     }\n-                    ty::AdjustDerefRef(ty::AutoDerefRef {\n-                        autoref: ref opt_autoref,\n-                        autoderefs: n\n-                    }) => {\n-                        self.walk_autoderefs(expr, n);\n-\n-                        match *opt_autoref {\n-                            None => { }\n-                            Some(ref r) => {\n-                                self.walk_autoref(expr, r, n);\n-                            }\n-                        }\n+                    ty::AdjustDerefRef(ref adj) => {\n+                        self.walk_autoderefref(expr, adj);\n                     }\n                 }\n             }\n@@ -852,39 +843,165 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         }\n     }\n \n+    fn walk_autoderefref(&mut self,\n+                         expr: &ast::Expr,\n+                         adj: &ty::AutoDerefRef<'tcx>) {\n+        debug!(\"walk_autoderefref expr={} adj={}\",\n+               expr.repr(self.tcx()),\n+               adj.repr(self.tcx()));\n+\n+        self.walk_autoderefs(expr, adj.autoderefs);\n+\n+        // Weird hacky special case: AutoUnsizeUniq, which converts\n+        // from a ~T to a ~Trait etc, always comes in a stylized\n+        // fashion. In particular, we want to consume the ~ pointer\n+        // being dereferenced, not the dereferenced content (as the\n+        // content is, at least for upcasts, unsized).\n+        match adj.autoref {\n+            Some(ty::AutoUnsizeUniq(_)) => {\n+                assert!(adj.autoderefs == 1,\n+                        format!(\"Expected exactly 1 deref with Uniq AutoRefs, found: {}\",\n+                                adj.autoderefs));\n+                let cmt_unadjusted =\n+                    return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+                self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n+                return;\n+            }\n+            _ => { }\n+        }\n+\n+        let autoref = adj.autoref.as_ref();\n+        let cmt_derefd = return_if_err!(\n+            self.mc.cat_expr_autoderefd(expr, adj.autoderefs));\n+        self.walk_autoref(expr, &cmt_derefd, autoref);\n+    }\n+\n+    /// Walks the autoref `opt_autoref` applied to the autoderef'd\n+    /// `expr`. `cmt_derefd` is the mem-categorized form of `expr`\n+    /// after all relevant autoderefs have occurred. Because AutoRefs\n+    /// can be recursive, this function is recursive: it first walks\n+    /// deeply all the way down the autoref chain, and then processes\n+    /// the autorefs on the way out. At each point, it returns the\n+    /// `cmt` for the rvalue that will be produced by introduced an\n+    /// autoref.\n     fn walk_autoref(&mut self,\n                     expr: &ast::Expr,\n-                    autoref: &ty::AutoRef,\n-                    n: usize) {\n-        debug!(\"walk_autoref expr={}\", expr.repr(self.tcx()));\n+                    cmt_derefd: &mc::cmt<'tcx>,\n+                    opt_autoref: Option<&ty::AutoRef<'tcx>>)\n+                    -> mc::cmt<'tcx>\n+    {\n+        debug!(\"walk_autoref(expr.id={} cmt_derefd={} opt_autoref={:?})\",\n+               expr.id,\n+               cmt_derefd.repr(self.tcx()),\n+               opt_autoref);\n+\n+        let autoref = match opt_autoref {\n+            Some(autoref) => autoref,\n+            None => {\n+                // No recursive step here, this is a base case.\n+                return cmt_derefd.clone();\n+            }\n+        };\n \n         match *autoref {\n-            ty::AutoPtr(r, m, _) => {\n-                let cmt_derefd = return_if_err!(\n-                    self.mc.cat_expr_autoderefd(expr, n));\n-                debug!(\"walk_adjustment: cmt_derefd={}\",\n-                       cmt_derefd.repr(self.tcx()));\n+            ty::AutoPtr(r, m, ref baseref) => {\n+                let cmt_base = self.walk_autoref_recursively(expr, cmt_derefd, baseref);\n+\n+                debug!(\"walk_autoref: expr.id={} cmt_base={}\",\n+                       expr.id,\n+                       cmt_base.repr(self.tcx()));\n \n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n-                                     cmt_derefd,\n+                                     cmt_base,\n                                      r,\n                                      ty::BorrowKind::from_mutbl(m),\n                                      AutoRef);\n             }\n-            ty::AutoUnsize(_) |\n+\n+            ty::AutoUnsize(_) => {\n+                // Converting a `[T; N]` to `[T]` or `T` to `Trait`\n+                // isn't really a borrow, move, etc, in and of itself.\n+                // Also, no recursive step here, this is a base case.\n+\n+                // It may seem a bit odd to return the cmt_derefd\n+                // unmodified here, but in fact I think it's the right\n+                // thing to do. Essentially the unsize transformation\n+                // isn't really relevant to the borrowing rules --\n+                // it's best thought of as a kind of side-modifier to\n+                // the autoref, adding additional data that is\n+                // attached to the pointer that is produced, but not\n+                // affecting the data being borrowed in any other\n+                // way. To see what I mean, consider this example:\n+                //\n+                //    fn foo<'a>(&'a self) -> &'a Trait { self }\n+                //\n+                // This is valid because the underlying `self` value\n+                // lives for the lifetime 'a. If we were to treat the\n+                // \"unsizing\" as e.g. producing an rvalue, that would\n+                // only be valid for the temporary scope, which isn't\n+                // enough to justify the return value, which have the\n+                // lifetime 'a.\n+                //\n+                // Another option would be to add a variant for\n+                // categorization (like downcast) that wraps\n+                // cmt_derefd and represents the unsizing operation.\n+                // But I don't think there is any particular use for\n+                // this (yet). -nmatsakis\n+                return cmt_derefd.clone();\n+            }\n+\n             ty::AutoUnsizeUniq(_) => {\n-                assert!(n == 1, format!(\"Expected exactly 1 deref with Uniq \\\n-                                         AutoRefs, found: {}\", n));\n-                let cmt_unadjusted =\n-                    return_if_err!(self.mc.cat_expr_unadjusted(expr));\n-                self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n+                // these are handled via special case above\n+                self.tcx().sess.span_bug(expr.span, \"nexpected AutoUnsizeUniq\");\n             }\n-            ty::AutoUnsafe(..) => {\n+\n+            ty::AutoUnsafe(m, ref baseref) => {\n+                let cmt_base = self.walk_autoref_recursively(expr, cmt_derefd, baseref);\n+\n+                debug!(\"walk_autoref: expr.id={} cmt_base={}\",\n+                       expr.id,\n+                       cmt_base.repr(self.tcx()));\n+\n+                // Converting from a &T to *T (or &mut T to *mut T) is\n+                // treated as borrowing it for the enclosing temporary\n+                // scope.\n+                let r = ty::ReScope(region::CodeExtent::from_node_id(expr.id));\n+\n+                self.delegate.borrow(expr.id,\n+                                     expr.span,\n+                                     cmt_base,\n+                                     r,\n+                                     ty::BorrowKind::from_mutbl(m),\n+                                     AutoUnsafe);\n             }\n         }\n+\n+        // Construct the categorization for the result of the autoref.\n+        // This is always an rvalue, since we are producing a new\n+        // (temporary) indirection.\n+\n+        let adj_ty =\n+            ty::adjust_ty_for_autoref(self.tcx(),\n+                                      expr.span,\n+                                      cmt_derefd.ty,\n+                                      opt_autoref);\n+\n+        self.mc.cat_rvalue_node(expr.id, expr.span, adj_ty)\n     }\n \n+    fn walk_autoref_recursively(&mut self,\n+                                expr: &ast::Expr,\n+                                cmt_derefd: &mc::cmt<'tcx>,\n+                                autoref: &Option<Box<ty::AutoRef<'tcx>>>)\n+                                -> mc::cmt<'tcx>\n+    {\n+        // Shuffle from a ref to an optional box to an optional ref.\n+        let autoref: Option<&ty::AutoRef<'tcx>> = autoref.as_ref().map(|b| &**b);\n+        self.walk_autoref(expr, cmt_derefd, autoref)\n+    }\n+\n+\n     // When this returns true, it means that the expression *is* a\n     // method-call (i.e. via the operator-overload).  This true result\n     // also implies that walk_overloaded_operator already took care of"}, {"sha": "6c7dc61109fb5109cd5f4b5cf3ae524b672404c6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3b871402998d093de327dc2bf424f69fab277b54", "patch": "@@ -833,6 +833,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         ret\n     }\n \n+    /// Returns the lifetime of a temporary created by expr with id `id`.\n+    /// This could be `'static` if `id` is part of a constant expression.\n+    pub fn temporary_scope(&self, id: ast::NodeId) -> ty::Region {\n+        match self.typer.temporary_scope(id) {\n+            Some(scope) => ty::ReScope(scope),\n+            None => ty::ReStatic\n+        }\n+    }\n+\n     pub fn cat_rvalue_node(&self,\n                            id: ast::NodeId,\n                            span: Span,\n@@ -848,17 +857,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             _ => check_const::NOT_CONST\n         };\n \n+        // Compute maximum lifetime of this rvalue. This is 'static if\n+        // we can promote to a constant, otherwise equal to enclosing temp\n+        // lifetime.\n         let re = match qualif & check_const::NON_STATIC_BORROWS {\n-            check_const::PURE_CONST => {\n-                // Constant rvalues get promoted to 'static.\n-                ty::ReStatic\n-            }\n-            _ => {\n-                match self.typer.temporary_scope(id) {\n-                    Some(scope) => ty::ReScope(scope),\n-                    None => ty::ReStatic\n-                }\n-            }\n+            check_const::PURE_CONST => ty::ReStatic,\n+            _ => self.temporary_scope(id),\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {}\", ret.repr(self.tcx()));"}, {"sha": "9776538de3fedc748f03f584706ac35b43312b0b", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=3b871402998d093de327dc2bf424f69fab277b54", "patch": "@@ -542,6 +542,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 euv::OverloadedOperator(..) |\n                 euv::AddrOf(..) |\n                 euv::AutoRef(..) |\n+                euv::AutoUnsafe(..) |\n                 euv::ClosureInvocation(..) |\n                 euv::ForLoop(..) |\n                 euv::RefBinding(..) |"}, {"sha": "c57cbcb929fbc8999d32287a047e78bad3b078b7", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=3b871402998d093de327dc2bf424f69fab277b54", "patch": "@@ -775,6 +775,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     euv::AddrOf |\n                     euv::RefBinding |\n                     euv::AutoRef |\n+                    euv::AutoUnsafe |\n                     euv::ForLoop |\n                     euv::MatchDiscriminant => {\n                         format!(\"cannot borrow {} as mutable\", descr)\n@@ -822,6 +823,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             BorrowViolation(euv::OverloadedOperator) |\n             BorrowViolation(euv::AddrOf) |\n             BorrowViolation(euv::AutoRef) |\n+            BorrowViolation(euv::AutoUnsafe) |\n             BorrowViolation(euv::RefBinding) |\n             BorrowViolation(euv::MatchDiscriminant) => {\n                 \"cannot borrow data mutably\""}, {"sha": "7c1fea4e60f6ecffa0281f906bbdb92da26f254a", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=3b871402998d093de327dc2bf424f69fab277b54", "patch": "@@ -20,7 +20,6 @@ use super::{\n     PreferMutLvalue,\n     structurally_resolved_type,\n };\n-use middle::infer;\n use middle::traits;\n use middle::ty::{self, Ty};\n use syntax::ast;\n@@ -314,36 +313,9 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     let method = match trait_did {\n         Some(trait_did) => {\n-            // We do eager coercions to make using operators\n-            // more ergonomic:\n-            //\n-            // - If the input is of type &'a T (resp. &'a mut T),\n-            //   then reborrow it to &'b T (resp. &'b mut T) where\n-            //   'b <= 'a.  This makes things like `x == y`, where\n-            //   `x` and `y` are both region pointers, work.  We\n-            //   could also solve this with variance or different\n-            //   traits that don't force left and right to have same\n-            //   type.\n-            let (adj_ty, adjustment) = match lhs_ty.sty {\n-                ty::ty_rptr(r_in, mt) => {\n-                    let r_adj = fcx.infcx().next_region_var(infer::Autoref(lhs_expr.span));\n-                    fcx.mk_subr(infer::Reborrow(lhs_expr.span), r_adj, *r_in);\n-                    let adjusted_ty = ty::mk_rptr(fcx.tcx(), fcx.tcx().mk_region(r_adj), mt);\n-                    let autoptr = ty::AutoPtr(r_adj, mt.mutbl, None);\n-                    let adjustment = ty::AutoDerefRef { autoderefs: 1, autoref: Some(autoptr) };\n-                    (adjusted_ty, adjustment)\n-                }\n-                _ => {\n-                    (lhs_ty, ty::AutoDerefRef { autoderefs: 0, autoref: None })\n-                }\n-            };\n-\n-            debug!(\"adjusted_ty={} adjustment={:?}\",\n-                   adj_ty.repr(fcx.tcx()),\n-                   adjustment);\n-\n+            let noop = ty::AutoDerefRef { autoderefs: 0, autoref: None };\n             method::lookup_in_trait_adjusted(fcx, expr.span, Some(lhs_expr), opname,\n-                                             trait_did, adjustment, adj_ty, Some(other_tys))\n+                                             trait_did, noop, lhs_ty, Some(other_tys))\n         }\n         None => None\n     };"}, {"sha": "9554e6ad8aad3881f1a8be980429b32ddf3e9604", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b871402998d093de327dc2bf424f69fab277b54/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3b871402998d093de327dc2bf424f69fab277b54", "patch": "@@ -1119,20 +1119,24 @@ fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n fn link_autoref(rcx: &Rcx,\n                 expr: &ast::Expr,\n                 autoderefs: usize,\n-                autoref: &ty::AutoRef) {\n-\n+                autoref: &ty::AutoRef)\n+{\n     debug!(\"link_autoref(autoref={:?})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n \n     match *autoref {\n         ty::AutoPtr(r, m, _) => {\n-            link_region(rcx, expr.span, r,\n-                ty::BorrowKind::from_mutbl(m), expr_cmt);\n+            link_region(rcx, expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n+        }\n+\n+        ty::AutoUnsafe(m, _) => {\n+            let r = ty::ReScope(CodeExtent::from_node_id(expr.id));\n+            link_region(rcx, expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n \n-        ty::AutoUnsafe(..) | ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) => {}\n+        ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) => {}\n     }\n }\n "}, {"sha": "796b455f5c70a3258edc4bcadcf2288438be4df0", "filename": "src/test/compile-fail/borrowck-use-uninitialized-in-cast-trait.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b871402998d093de327dc2bf424f69fab277b54/src%2Ftest%2Fcompile-fail%2Fborrowck-use-uninitialized-in-cast-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b871402998d093de327dc2bf424f69fab277b54/src%2Ftest%2Fcompile-fail%2Fborrowck-use-uninitialized-in-cast-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-use-uninitialized-in-cast-trait.rs?ref=3b871402998d093de327dc2bf424f69fab277b54", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Variation on `borrowck-use-uninitialized-in-cast` in which we do a\n+// trait cast from an uninitialized source. Issue #20791.\n+\n+trait Foo { fn dummy(&self) { } }\n+impl Foo for i32 { }\n+\n+fn main() {\n+    let x: &i32;\n+    let y = x as *const Foo; //~ ERROR use of possibly uninitialized variable: `*x`\n+}"}, {"sha": "a3d5af80b533b6ac220635007281b56c954ad2ff", "filename": "src/test/compile-fail/borrowck-use-uninitialized-in-cast.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b871402998d093de327dc2bf424f69fab277b54/src%2Ftest%2Fcompile-fail%2Fborrowck-use-uninitialized-in-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b871402998d093de327dc2bf424f69fab277b54/src%2Ftest%2Fcompile-fail%2Fborrowck-use-uninitialized-in-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-use-uninitialized-in-cast.rs?ref=3b871402998d093de327dc2bf424f69fab277b54", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we detect unused values that are cast to other things.\n+// The problem was specified to casting to `*`, as creating unsafe\n+// pointers was not being fully checked. Issue #20791.\n+\n+// pretty-expanded FIXME #23616\n+\n+fn main() {\n+    let x: &i32;\n+    let y = x as *const i32; //~ ERROR use of possibly uninitialized variable: `*x`\n+}"}]}