{"sha": "9fa12def3c231f3b60f53d68c3787b8a82376843", "node_id": "C_kwDOAAsO6NoAKDlmYTEyZGVmM2MyMzFmM2I2MGY1M2Q2OGMzNzg3YjhhODIzNzY4NDM", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-07-07T14:45:20Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-07-08T02:10:24Z"}, "message": "Improve `while_let_on_iterator` suggestion inside an `FnOnce` closure", "tree": {"sha": "ebab7ed7396b82ab2a1434573927b50f51f1ff88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebab7ed7396b82ab2a1434573927b50f51f1ff88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fa12def3c231f3b60f53d68c3787b8a82376843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fa12def3c231f3b60f53d68c3787b8a82376843", "html_url": "https://github.com/rust-lang/rust/commit/9fa12def3c231f3b60f53d68c3787b8a82376843", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fa12def3c231f3b60f53d68c3787b8a82376843/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54feac18d1ad9cc5af1f71dfb34baa32f99630ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/54feac18d1ad9cc5af1f71dfb34baa32f99630ae", "html_url": "https://github.com/rust-lang/rust/commit/54feac18d1ad9cc5af1f71dfb34baa32f99630ae"}], "stats": {"total": 297, "additions": 240, "deletions": 57}, "files": [{"sha": "c18151a44e26e78da6c7350b8d234345e7bb5fea", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9fa12def3c231f3b60f53d68c3787b8a82376843/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa12def3c231f3b60f53d68c3787b8a82376843/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=9fa12def3c231f3b60f53d68c3787b8a82376843", "patch": "@@ -3,13 +3,15 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{\n-    get_enclosing_loop_or_closure, is_refutable, is_trait_method, match_def_path, paths, visitors::is_res_used,\n+    get_enclosing_loop_or_multi_call_closure, is_refutable, is_trait_method, match_def_path, paths,\n+    visitors::is_res_used,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n+use rustc_middle::hir::nested_filter::OnlyBodies;\n use rustc_middle::ty::adjustment::Adjust;\n use rustc_span::{symbol::sym, Symbol};\n \n@@ -249,6 +251,11 @@ fn needs_mutable_borrow(cx: &LateContext<'_>, iter_expr: &IterExpr, loop_expr: &\n         used_iter: bool,\n     }\n     impl<'tcx> Visitor<'tcx> for AfterLoopVisitor<'_, '_, 'tcx> {\n+        type NestedFilter = OnlyBodies;\n+        fn nested_visit_map(&mut self) -> Self::Map {\n+            self.cx.tcx.hir()\n+        }\n+\n         fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n             if self.used_iter {\n                 return;\n@@ -283,6 +290,11 @@ fn needs_mutable_borrow(cx: &LateContext<'_>, iter_expr: &IterExpr, loop_expr: &\n         used_after: bool,\n     }\n     impl<'a, 'b, 'tcx> Visitor<'tcx> for NestedLoopVisitor<'a, 'b, 'tcx> {\n+        type NestedFilter = OnlyBodies;\n+        fn nested_visit_map(&mut self) -> Self::Map {\n+            self.cx.tcx.hir()\n+        }\n+\n         fn visit_local(&mut self, l: &'tcx Local<'_>) {\n             if !self.after_loop {\n                 l.pat.each_binding_or_first(&mut |_, id, _, _| {\n@@ -320,10 +332,7 @@ fn needs_mutable_borrow(cx: &LateContext<'_>, iter_expr: &IterExpr, loop_expr: &\n         }\n     }\n \n-    if let Some(e) = get_enclosing_loop_or_closure(cx.tcx, loop_expr) {\n-        // The iterator expression will be used on the next iteration (for loops), or on the next call (for\n-        // closures) unless it is declared within the enclosing expression. TODO: Check for closures\n-        // used where an `FnOnce` type is expected.\n+    if let Some(e) = get_enclosing_loop_or_multi_call_closure(cx, loop_expr) {\n         let local_id = match iter_expr.path {\n             Res::Local(id) => id,\n             _ => return true,"}, {"sha": "0d31203f3f70f8a96ab0eaad319334e8f986186b", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9fa12def3c231f3b60f53d68c3787b8a82376843/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa12def3c231f3b60f53d68c3787b8a82376843/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=9fa12def3c231f3b60f53d68c3787b8a82376843", "patch": "@@ -93,7 +93,9 @@ use rustc_middle::ty::fast_reject::SimplifiedTypeGen::{\n     ArraySimplifiedType, BoolSimplifiedType, CharSimplifiedType, FloatSimplifiedType, IntSimplifiedType,\n     PtrSimplifiedType, SliceSimplifiedType, StrSimplifiedType, UintSimplifiedType,\n };\n-use rustc_middle::ty::{layout::IntegerExt, BorrowKind, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable, UpvarCapture};\n+use rustc_middle::ty::{\n+    layout::IntegerExt, BorrowKind, ClosureKind, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable, UpvarCapture,\n+};\n use rustc_middle::ty::{FloatTy, IntTy, UintTy};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n@@ -105,7 +107,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n-use crate::ty::{can_partially_move_ty, is_copy, is_recursively_primitive_type};\n+use crate::ty::{can_partially_move_ty, expr_sig, is_copy, is_recursively_primitive_type, ty_is_fn_once_param};\n use crate::visitors::expr_visitor_no_bodies;\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n@@ -1197,16 +1199,54 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n }\n \n /// Gets the loop or closure enclosing the given expression, if any.\n-pub fn get_enclosing_loop_or_closure<'tcx>(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    for (_, node) in tcx.hir().parent_iter(expr.hir_id) {\n+pub fn get_enclosing_loop_or_multi_call_closure<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &Expr<'_>,\n+) -> Option<&'tcx Expr<'tcx>> {\n+    for (_, node) in cx.tcx.hir().parent_iter(expr.hir_id) {\n         match node {\n-            Node::Expr(\n-                e @ Expr {\n-                    kind: ExprKind::Loop(..) | ExprKind::Closure { .. },\n-                    ..\n+            Node::Expr(e) => match e.kind {\n+                ExprKind::Closure { .. } => {\n+                    if let rustc_ty::Closure(_, subs) = cx.typeck_results().expr_ty(e).kind()\n+                        && subs.as_closure().kind() == ClosureKind::FnOnce\n+                    {\n+                        continue;\n+                    }\n+                    let is_once = walk_to_expr_usage(cx, e, |node, id| {\n+                        let Node::Expr(e) = node else {\n+                            return None;\n+                        };\n+                        match e.kind {\n+                            ExprKind::Call(f, _) if f.hir_id == id => Some(()),\n+                            ExprKind::Call(f, args) => {\n+                                let i = args.iter().position(|arg| arg.hir_id == id)?;\n+                                let sig = expr_sig(cx, f)?;\n+                                let predicates = sig\n+                                    .predicates_id()\n+                                    .map_or(cx.param_env, |id| cx.tcx.param_env(id))\n+                                    .caller_bounds();\n+                                sig.input(i).and_then(|ty| {\n+                                    ty_is_fn_once_param(cx.tcx, ty.skip_binder(), predicates).then_some(())\n+                                })\n+                            },\n+                            ExprKind::MethodCall(_, args, _) => {\n+                                let i = args.iter().position(|arg| arg.hir_id == id)?;\n+                                let id = cx.typeck_results().type_dependent_def_id(e.hir_id)?;\n+                                let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n+                                ty_is_fn_once_param(cx.tcx, ty, cx.tcx.param_env(id).caller_bounds()).then_some(())\n+                            },\n+                            _ => None,\n+                        }\n+                    })\n+                    .is_some();\n+                    if !is_once {\n+                        return Some(e);\n+                    }\n                 },\n-            ) => return Some(e),\n-            Node::Expr(_) | Node::Stmt(_) | Node::Block(_) | Node::Local(_) | Node::Arm(_) => (),\n+                ExprKind::Loop(..) => return Some(e),\n+                _ => (),\n+            },\n+            Node::Stmt(_) | Node::Block(_) | Node::Local(_) | Node::Arm(_) => (),\n             _ => break,\n         }\n     }"}, {"sha": "2bfe550c8959c1f5acc1ff90de699b3f1562bb24", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9fa12def3c231f3b60f53d68c3787b8a82376843/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa12def3c231f3b60f53d68c3787b8a82376843/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=9fa12def3c231f3b60f53d68c3787b8a82376843", "patch": "@@ -501,7 +501,7 @@ pub fn all_predicates_of(tcx: TyCtxt<'_>, id: DefId) -> impl Iterator<Item = &(P\n /// A signature for a function like type.\n #[derive(Clone, Copy)]\n pub enum ExprFnSig<'tcx> {\n-    Sig(Binder<'tcx, FnSig<'tcx>>),\n+    Sig(Binder<'tcx, FnSig<'tcx>>, Option<DefId>),\n     Closure(Option<&'tcx FnDecl<'tcx>>, Binder<'tcx, FnSig<'tcx>>),\n     Trait(Binder<'tcx, Ty<'tcx>>, Option<Binder<'tcx, Ty<'tcx>>>),\n }\n@@ -510,7 +510,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n     /// bounds only for variadic functions, otherwise this will panic.\n     pub fn input(self, i: usize) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         match self {\n-            Self::Sig(sig) => {\n+            Self::Sig(sig, _) => {\n                 if sig.c_variadic() {\n                     sig.inputs().map_bound(|inputs| inputs.get(i).copied()).transpose()\n                 } else {\n@@ -527,7 +527,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n     /// functions, otherwise this will panic.\n     pub fn input_with_hir(self, i: usize) -> Option<(Option<&'tcx hir::Ty<'tcx>>, Binder<'tcx, Ty<'tcx>>)> {\n         match self {\n-            Self::Sig(sig) => {\n+            Self::Sig(sig, _) => {\n                 if sig.c_variadic() {\n                     sig.inputs()\n                         .map_bound(|inputs| inputs.get(i).copied())\n@@ -549,16 +549,20 @@ impl<'tcx> ExprFnSig<'tcx> {\n     /// specified.\n     pub fn output(self) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         match self {\n-            Self::Sig(sig) | Self::Closure(_, sig) => Some(sig.output()),\n+            Self::Sig(sig, _) | Self::Closure(_, sig) => Some(sig.output()),\n             Self::Trait(_, output) => output,\n         }\n     }\n+\n+    pub fn predicates_id(&self) -> Option<DefId> {\n+        if let ExprFnSig::Sig(_, id) = *self { id } else { None }\n+    }\n }\n \n /// If the expression is function like, get the signature for it.\n pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnSig<'tcx>> {\n     if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = path_res(cx, expr) {\n-        Some(ExprFnSig::Sig(cx.tcx.fn_sig(id)))\n+        Some(ExprFnSig::Sig(cx.tcx.fn_sig(id), Some(id)))\n     } else {\n         ty_sig(cx, cx.typeck_results().expr_ty_adjusted(expr).peel_refs())\n     }\n@@ -575,9 +579,9 @@ fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>>\n                 .and_then(|id| cx.tcx.hir().fn_decl_by_hir_id(cx.tcx.hir().local_def_id_to_hir_id(id)));\n             Some(ExprFnSig::Closure(decl, subs.as_closure().sig()))\n         },\n-        ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs))),\n+        ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs), Some(id))),\n         ty::Opaque(id, _) => ty_sig(cx, cx.tcx.type_of(id)),\n-        ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig)),\n+        ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig, None)),\n         ty::Dynamic(bounds, _) => {\n             let lang_items = cx.tcx.lang_items();\n             match bounds.principal() {\n@@ -793,3 +797,33 @@ pub fn variant_of_res<'tcx>(cx: &LateContext<'tcx>, res: Res) -> Option<&'tcx Va\n         _ => None,\n     }\n }\n+\n+/// Checks if the type is a type parameter implementing `FnOnce`, but not `FnMut`.\n+pub fn ty_is_fn_once_param<'tcx>(tcx: TyCtxt<'_>, ty: Ty<'tcx>, predicates: &'tcx [Predicate<'_>]) -> bool {\n+    let ty::Param(ty) = *ty.kind() else {\n+        return false;\n+    };\n+    let lang = tcx.lang_items();\n+    let (Some(fn_once_id), Some(fn_mut_id), Some(fn_id))\n+        = (lang.fn_once_trait(), lang.fn_mut_trait(), lang.fn_trait())\n+    else {\n+        return false;\n+    };\n+    predicates\n+        .iter()\n+        .try_fold(false, |found, p| {\n+            if let PredicateKind::Trait(p) = p.kind().skip_binder()\n+            && let ty::Param(self_ty) = p.trait_ref.self_ty().kind()\n+            && ty.index == self_ty.index\n+        {\n+            // This should use `super_traits_of`, but that's a private function.\n+            if p.trait_ref.def_id == fn_once_id {\n+                return Some(true);\n+            } else if p.trait_ref.def_id == fn_mut_id || p.trait_ref.def_id == fn_id {\n+                return None;\n+            }\n+        }\n+            Some(found)\n+        })\n+        .unwrap_or(false)\n+}"}, {"sha": "c57c46736342b6814b1bb919126521ae516ca28f", "filename": "tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9fa12def3c231f3b60f53d68c3787b8a82376843/tests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9fa12def3c231f3b60f53d68c3787b8a82376843/tests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.fixed?ref=9fa12def3c231f3b60f53d68c3787b8a82376843", "patch": "@@ -7,7 +7,8 @@\n     unused_mut,\n     dead_code,\n     clippy::equatable_if_let,\n-    clippy::manual_find\n+    clippy::manual_find,\n+    clippy::redundant_closure_call\n )]\n \n fn base() {\n@@ -259,7 +260,7 @@ fn issue1924() {\n         fn f(&mut self) -> Option<u32> {\n             // Used as a field.\n             for i in self.0.by_ref() {\n-                if !(3..=7).contains(&i) {\n+                if !(3..8).contains(&i) {\n                     return Some(i);\n                 }\n             }\n@@ -403,6 +404,47 @@ fn issue_8113() {\n     }\n }\n \n+fn fn_once_closure() {\n+    let mut it = 0..10;\n+    (|| {\n+        for x in it {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    })();\n+\n+    fn f(_: impl FnOnce()) {}\n+    let mut it = 0..10;\n+    f(|| {\n+        for x in it {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    });\n+\n+    fn f2(_: impl FnMut()) {}\n+    let mut it = 0..10;\n+    f2(|| {\n+        for x in it.by_ref() {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    });\n+\n+    fn f3(_: fn()) {}\n+    f3(|| {\n+        let mut it = 0..10;\n+        for x in it {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    })\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     for _ in it {"}, {"sha": "8b9a2dbcce3a7c62149ad36a72137281ce61ca53", "filename": "tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9fa12def3c231f3b60f53d68c3787b8a82376843/tests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa12def3c231f3b60f53d68c3787b8a82376843/tests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.rs?ref=9fa12def3c231f3b60f53d68c3787b8a82376843", "patch": "@@ -7,7 +7,8 @@\n     unused_mut,\n     dead_code,\n     clippy::equatable_if_let,\n-    clippy::manual_find\n+    clippy::manual_find,\n+    clippy::redundant_closure_call\n )]\n \n fn base() {\n@@ -259,7 +260,7 @@ fn issue1924() {\n         fn f(&mut self) -> Option<u32> {\n             // Used as a field.\n             while let Some(i) = self.0.next() {\n-                if i < 3 || i > 7 {\n+                if !(3..8).contains(&i) {\n                     return Some(i);\n                 }\n             }\n@@ -403,6 +404,47 @@ fn issue_8113() {\n     }\n }\n \n+fn fn_once_closure() {\n+    let mut it = 0..10;\n+    (|| {\n+        while let Some(x) = it.next() {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    })();\n+\n+    fn f(_: impl FnOnce()) {}\n+    let mut it = 0..10;\n+    f(|| {\n+        while let Some(x) = it.next() {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    });\n+\n+    fn f2(_: impl FnMut()) {}\n+    let mut it = 0..10;\n+    f2(|| {\n+        while let Some(x) = it.next() {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    });\n+\n+    fn f3(_: fn()) {}\n+    f3(|| {\n+        let mut it = 0..10;\n+        while let Some(x) = it.next() {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    })\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     while let Some(..) = it.next() {"}, {"sha": "3236765e1db0faa069607cd734d99a4c2db548d6", "filename": "tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9fa12def3c231f3b60f53d68c3787b8a82376843/tests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fa12def3c231f3b60f53d68c3787b8a82376843/tests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.stderr?ref=9fa12def3c231f3b60f53d68c3787b8a82376843", "patch": "@@ -1,144 +1,160 @@\n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:15:5\n+  --> $DIR/while_let_on_iterator.rs:16:5\n    |\n LL |     while let Option::Some(x) = iter.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in iter`\n    |\n    = note: `-D clippy::while-let-on-iterator` implied by `-D warnings`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:20:5\n+  --> $DIR/while_let_on_iterator.rs:21:5\n    |\n LL |     while let Some(x) = iter.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in iter`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:25:5\n+  --> $DIR/while_let_on_iterator.rs:26:5\n    |\n LL |     while let Some(_) = iter.next() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in iter`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:101:9\n+  --> $DIR/while_let_on_iterator.rs:102:9\n    |\n LL |         while let Some([..]) = it.next() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [..] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:108:9\n+  --> $DIR/while_let_on_iterator.rs:109:9\n    |\n LL |         while let Some([_x]) = it.next() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [_x] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:121:9\n+  --> $DIR/while_let_on_iterator.rs:122:9\n    |\n LL |         while let Some(x @ [_]) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x @ [_] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:141:9\n+  --> $DIR/while_let_on_iterator.rs:142:9\n    |\n LL |         while let Some(_) = y.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in y`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:198:9\n+  --> $DIR/while_let_on_iterator.rs:199:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:209:5\n+  --> $DIR/while_let_on_iterator.rs:210:5\n    |\n LL |     while let Some(n) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:211:9\n+  --> $DIR/while_let_on_iterator.rs:212:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:220:9\n+  --> $DIR/while_let_on_iterator.rs:221:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:229:9\n+  --> $DIR/while_let_on_iterator.rs:230:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:246:9\n+  --> $DIR/while_let_on_iterator.rs:247:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:261:13\n+  --> $DIR/while_let_on_iterator.rs:262:13\n    |\n LL |             while let Some(i) = self.0.next() {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in self.0.by_ref()`\n \n-error: manual `!RangeInclusive::contains` implementation\n-  --> $DIR/while_let_on_iterator.rs:262:20\n-   |\n-LL |                 if i < 3 || i > 7 {\n-   |                    ^^^^^^^^^^^^^^ help: use: `!(3..=7).contains(&i)`\n-   |\n-   = note: `-D clippy::manual-range-contains` implied by `-D warnings`\n-\n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:293:13\n+  --> $DIR/while_let_on_iterator.rs:294:13\n    |\n LL |             while let Some(i) = self.0.0.0.next() {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in self.0.0.0.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:322:5\n+  --> $DIR/while_let_on_iterator.rs:323:5\n    |\n LL |     while let Some(n) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:334:9\n+  --> $DIR/while_let_on_iterator.rs:335:9\n    |\n LL |         while let Some(x) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:348:5\n+  --> $DIR/while_let_on_iterator.rs:349:5\n    |\n LL |     while let Some(x) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:359:5\n+  --> $DIR/while_let_on_iterator.rs:360:5\n    |\n LL |     while let Some(x) = it.0.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.0.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:394:5\n+  --> $DIR/while_let_on_iterator.rs:395:5\n    |\n LL |     while let Some(x) = s.x.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in s.x.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:401:5\n+  --> $DIR/while_let_on_iterator.rs:402:5\n    |\n LL |     while let Some(x) = x[0].next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in x[0].by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:408:5\n+  --> $DIR/while_let_on_iterator.rs:410:9\n+   |\n+LL |         while let Some(x) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:420:9\n+   |\n+LL |         while let Some(x) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:430:9\n+   |\n+LL |         while let Some(x) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.by_ref()`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:440:9\n+   |\n+LL |         while let Some(x) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:450:5\n    |\n LL |     while let Some(..) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in it`\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 26 previous errors\n "}]}