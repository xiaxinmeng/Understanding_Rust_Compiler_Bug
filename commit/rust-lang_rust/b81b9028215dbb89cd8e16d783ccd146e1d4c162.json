{"sha": "b81b9028215dbb89cd8e16d783ccd146e1d4c162", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MWI5MDI4MjE1ZGJiODljZDhlMTZkNzgzY2NkMTQ2ZTFkNGMxNjI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-10-14T22:48:12Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-10-14T22:48:12Z"}, "message": "Simplify situations in which the last sub-expr in a bin-op can go multiline without making the whole expr multiline\n\nFixes #3034", "tree": {"sha": "fa93afa507e64920156b01454821a376c5cba358", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa93afa507e64920156b01454821a376c5cba358"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b81b9028215dbb89cd8e16d783ccd146e1d4c162", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b81b9028215dbb89cd8e16d783ccd146e1d4c162", "html_url": "https://github.com/rust-lang/rust/commit/b81b9028215dbb89cd8e16d783ccd146e1d4c162", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b81b9028215dbb89cd8e16d783ccd146e1d4c162/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6ef302236dd353bd737d1196d7dc581ffc703a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6ef302236dd353bd737d1196d7dc581ffc703a0", "html_url": "https://github.com/rust-lang/rust/commit/a6ef302236dd353bd737d1196d7dc581ffc703a0"}], "stats": {"total": 39, "additions": 13, "deletions": 26}, "files": [{"sha": "c4451a8e466093cff12969ac2fd9cf7f4f901c89", "filename": "src/pairs.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b81b9028215dbb89cd8e16d783ccd146e1d4c162/src%2Fpairs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81b9028215dbb89cd8e16d783ccd146e1d4c162/src%2Fpairs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpairs.rs?ref=b81b9028215dbb89cd8e16d783ccd146e1d4c162", "patch": "@@ -43,7 +43,7 @@ pub(crate) fn rewrite_all_pairs(\n     context: &RewriteContext,\n ) -> Option<String> {\n     // First we try formatting on one line.\n-    if let Some(list) = expr.flatten(context, false) {\n+    if let Some(list) = expr.flatten(false) {\n         if let Some(r) = rewrite_pairs_one_line(&list, shape, context) {\n             return Some(r);\n         }\n@@ -53,7 +53,7 @@ pub(crate) fn rewrite_all_pairs(\n     // to only flatten pairs with the same operator, that way we don't\n     // necessarily need one line per sub-expression, but we don't do anything\n     // too funny wrt precedence.\n-    expr.flatten(context, true)\n+    expr.flatten(true)\n         .and_then(|list| rewrite_pairs_multiline(list, shape, context))\n }\n \n@@ -83,33 +83,22 @@ fn rewrite_pairs_one_line<T: Rewrite>(\n         result.push(' ');\n     }\n \n+    let prefix_len = result.len();\n     let last = list.list.last().unwrap();\n     let cur_shape = base_shape.offset_left(last_line_width(&result))?;\n-    let rewrite = last.rewrite(context, cur_shape)?;\n-    result.push_str(&rewrite);\n+    let last_rewrite = last.rewrite(context, cur_shape)?;\n+    result.push_str(&last_rewrite);\n \n     if first_line_width(&result) > shape.width {\n         return None;\n     }\n \n-    // Check the last expression in the list. We let this expression go over\n-    // multiple lines, but we check that if this is necessary, then we can't\n-    // do better using multi-line formatting.\n-    if !is_single_line(&result) {\n-        let multiline_shape = shape.offset_left(list.separators.last().unwrap().len() + 1)?;\n-        let multiline_list: PairList<T> = PairList {\n-            list: vec![last],\n-            separators: vec![],\n-            separator_place: list.separator_place,\n-        };\n-        // Format as if we were multi-line.\n-        if let Some(rewrite) = rewrite_pairs_multiline(multiline_list, multiline_shape, context) {\n-            // Also, don't let expressions surrounded by parens go multi-line,\n-            // this looks really bad.\n-            if rewrite.starts_with('(') || is_single_line(&rewrite) {\n-                return None;\n-            }\n-        }\n+    // Check the last expression in the list. We sometimes let this expression\n+    // go over multiple lines, but we check for some ugly conditions.\n+    if !(is_single_line(&result) || last_rewrite.starts_with('{'))\n+        && (last_rewrite.starts_with('(') || prefix_len > context.config.tab_spaces())\n+    {\n+        return None;\n     }\n \n     wrap_str(result, context.config.max_width(), shape)\n@@ -272,19 +261,18 @@ trait FlattenPair: Rewrite + Sized {\n     // operator into the list. E.g,, if the source is `a * b + c`, if `_same_op`\n     // is true, we make `[(a * b), c]` if `_same_op` is false, we make\n     // `[a, b, c]`\n-    fn flatten(&self, _context: &RewriteContext, _same_op: bool) -> Option<PairList<Self>> {\n+    fn flatten(&self, _same_op: bool) -> Option<PairList<Self>> {\n         None\n     }\n }\n \n struct PairList<'a, 'b, T: Rewrite + 'b> {\n     list: Vec<&'b T>,\n     separators: Vec<&'a str>,\n-    separator_place: SeparatorPlace,\n }\n \n impl FlattenPair for ast::Expr {\n-    fn flatten(&self, context: &RewriteContext, same_op: bool) -> Option<PairList<ast::Expr>> {\n+    fn flatten(&self, same_op: bool) -> Option<PairList<ast::Expr>> {\n         let top_op = match self.node {\n             ast::ExprKind::Binary(op, _, _) => op.node,\n             _ => return None,\n@@ -323,7 +311,6 @@ impl FlattenPair for ast::Expr {\n         Some(PairList {\n             list,\n             separators,\n-            separator_place: context.config.binop_separator(),\n         })\n     }\n }"}]}