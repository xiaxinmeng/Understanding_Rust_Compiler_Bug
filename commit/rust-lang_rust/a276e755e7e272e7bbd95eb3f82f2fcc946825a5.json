{"sha": "a276e755e7e272e7bbd95eb3f82f2fcc946825a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNzZlNzU1ZTdlMjcyZTdiYmQ5NWViM2Y4MmYyZmNjOTQ2ODI1YTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-23T16:26:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-23T20:42:55Z"}, "message": "introduce \"call-site-scope\" as the outermost scope\n\nalso, when exiting a scope, assign the final goto terminator with the\ntarget scope's id", "tree": {"sha": "0043bcec8ed1dfc5b34cfdae2c5e8f0476140259", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0043bcec8ed1dfc5b34cfdae2c5e8f0476140259"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a276e755e7e272e7bbd95eb3f82f2fcc946825a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a276e755e7e272e7bbd95eb3f82f2fcc946825a5", "html_url": "https://github.com/rust-lang/rust/commit/a276e755e7e272e7bbd95eb3f82f2fcc946825a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a276e755e7e272e7bbd95eb3f82f2fcc946825a5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c0fa3431052e8b6d944891dc20a1dd614bedd13", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c0fa3431052e8b6d944891dc20a1dd614bedd13", "html_url": "https://github.com/rust-lang/rust/commit/1c0fa3431052e8b6d944891dc20a1dd614bedd13"}], "stats": {"total": 141, "additions": 84, "deletions": 57}, "files": [{"sha": "30c039cdde0c3e5b5ec13da488b71c02b68c3640", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a276e755e7e272e7bbd95eb3f82f2fcc946825a5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a276e755e7e272e7bbd95eb3f82f2fcc946825a5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=a276e755e7e272e7bbd95eb3f82f2fcc946825a5", "patch": "@@ -261,7 +261,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         block\n                     }\n                 };\n-                let extent = this.extent_of_outermost_scope();\n+                let extent = this.extent_of_return_scope();\n                 this.exit_scope(expr_span, extent, block, END_BLOCK);\n                 this.cfg.start_new_block().unit()\n             }"}, {"sha": "a88b138a44ddea3d67f7b04e53822f659d64c639", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 63, "deletions": 46, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a276e755e7e272e7bbd95eb3f82f2fcc946825a5/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a276e755e7e272e7bbd95eb3f82f2fcc946825a5/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a276e755e7e272e7bbd95eb3f82f2fcc946825a5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hair::cx::Cx;\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::ty::{FnOutput, Ty};\n use rustc::mir::repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n@@ -153,12 +153,14 @@ macro_rules! unpack {\n \n pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n                           span: Span,\n+                          fn_id: ast::NodeId,\n+                          body_id: ast::NodeId,\n                           implicit_arguments: Vec<Ty<'tcx>>,\n                           explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n-                          argument_extent: CodeExtent,\n                           return_ty: FnOutput<'tcx>,\n                           ast_block: &'tcx hir::Block)\n                           -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+    let tcx = hir.tcx();\n     let cfg = CFG { basic_blocks: vec![] };\n \n     let mut builder = Builder {\n@@ -178,27 +180,41 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n     assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n     assert_eq!(builder.cfg.start_new_block(), END_BLOCK);\n \n-    let mut block = START_BLOCK;\n-    let (arg_decls, arg_scope_id) =\n-        unpack!(block = builder.args_and_body(block,\n-                                              implicit_arguments,\n-                                              explicit_arguments,\n-                                              argument_extent,\n-                                              ast_block));\n \n-    builder.cfg.terminate(block, arg_scope_id, span,\n-                          TerminatorKind::Goto { target: END_BLOCK });\n-    builder.cfg.terminate(END_BLOCK, arg_scope_id, span,\n-                          TerminatorKind::Return);\n+    let mut arg_decls = None; // assigned to `Some` in closures below\n+    let call_site_extent =\n+        tcx.region_maps.lookup_code_extent(\n+            CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id });\n+    let _ = builder.in_scope(call_site_extent, START_BLOCK, |builder, call_site_scope_id| {\n+        let mut block = START_BLOCK;\n+        let arg_extent =\n+            tcx.region_maps.lookup_code_extent(\n+                CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id });\n+        unpack!(block = builder.in_scope(arg_extent, block, |builder, arg_scope_id| {\n+            arg_decls = Some(unpack!(block = builder.args_and_body(block,\n+                                                                   implicit_arguments,\n+                                                                   explicit_arguments,\n+                                                                   arg_scope_id,\n+                                                                   ast_block)));\n+            block.unit()\n+        }));\n+\n+        builder.cfg.terminate(block, call_site_scope_id, span,\n+                              TerminatorKind::Goto { target: END_BLOCK });\n+        builder.cfg.terminate(END_BLOCK, call_site_scope_id, span,\n+                              TerminatorKind::Return);\n+\n+        END_BLOCK.unit()\n+    });\n \n     assert!(\n         builder.cfg.basic_blocks\n                    .iter()\n                    .enumerate()\n                    .all(|(index, block)| {\n                        if block.terminator.is_none() {\n-                           panic!(\"no terminator on block {:?} in {:?}\",\n-                               index, argument_extent)\n+                           panic!(\"no terminator on block {:?} in fn {:?}\",\n+                               index, fn_id)\n                        }\n                        true\n                    }));\n@@ -208,7 +224,7 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n             basic_blocks: builder.cfg.basic_blocks,\n             scopes: builder.scope_datas,\n             var_decls: builder.var_decls,\n-            arg_decls: arg_decls,\n+            arg_decls: arg_decls.take().expect(\"args never built?\"),\n             temp_decls: builder.temp_decls,\n             return_ty: return_ty,\n             span: span\n@@ -222,39 +238,40 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                      mut block: BasicBlock,\n                      implicit_arguments: Vec<Ty<'tcx>>,\n                      explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n-                     argument_extent: CodeExtent,\n+                     argument_scope_id: ScopeId,\n                      ast_block: &'tcx hir::Block)\n-                     -> BlockAnd<(Vec<ArgDecl<'tcx>>, ScopeId)>\n+                     -> BlockAnd<Vec<ArgDecl<'tcx>>>\n     {\n-        self.in_scope(argument_extent, block, |this, argument_scope_id| {\n-            // to start, translate the argument patterns and collect the argument types.\n-            let implicits = implicit_arguments.into_iter().map(|ty| (ty, None));\n-            let explicits = explicit_arguments.into_iter().map(|(ty, pat)| (ty, Some(pat)));\n+        // to start, translate the argument patterns and collect the argument types.\n+        let implicits = implicit_arguments.into_iter().map(|ty| (ty, None));\n+        let explicits = explicit_arguments.into_iter().map(|(ty, pat)| (ty, Some(pat)));\n             let arg_decls =\n-                implicits\n-                .chain(explicits)\n-                .enumerate()\n-                .map(|(index, (ty, pattern))| {\n-                    let lvalue = Lvalue::Arg(index as u32);\n-                    if let Some(pattern) = pattern {\n-                        let pattern = this.hir.irrefutable_pat(pattern);\n-                        unpack!(block = this.lvalue_into_pattern(block,\n-                                                                 argument_scope_id,\n-                                                                 pattern,\n-                                                                 &lvalue));\n-                    }\n-                    // Make sure we drop (parts of) the argument even when not matched on.\n-                    this.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n-                                       argument_extent, &lvalue, ty);\n-                    ArgDecl { ty: ty, spread: false }\n-                })\n-                .collect();\n-\n-            // start the first basic block and translate the body\n-            unpack!(block = this.ast_block(&Lvalue::ReturnPointer, block, ast_block));\n-\n-            block.and((arg_decls, argument_scope_id))\n-        })\n+            implicits\n+            .chain(explicits)\n+            .enumerate()\n+            .map(|(index, (ty, pattern))| {\n+                let lvalue = Lvalue::Arg(index as u32);\n+                if let Some(pattern) = pattern {\n+                    let pattern = self.hir.irrefutable_pat(pattern);\n+                    unpack!(block = self.lvalue_into_pattern(block,\n+                                                             argument_scope_id,\n+                                                             pattern,\n+                                                             &lvalue));\n+                }\n+\n+                // Make sure we drop (parts of) the argument even when not matched on.\n+                let argument_extent = self.scope_auxiliary[argument_scope_id].extent;\n+                self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n+                                   argument_extent, &lvalue, ty);\n+\n+                ArgDecl { ty: ty, spread: false }\n+            })\n+            .collect();\n+\n+        // start the first basic block and translate the body\n+        unpack!(block = self.ast_block(&Lvalue::ReturnPointer, block, ast_block));\n+\n+        block.and(arg_decls)\n     }\n \n     fn get_unit_temp(&mut self) -> Lvalue<'tcx> {"}, {"sha": "acca2637c82c193def7a28f4acea41605e1bbe92", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a276e755e7e272e7bbd95eb3f82f2fcc946825a5/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a276e755e7e272e7bbd95eb3f82f2fcc946825a5/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=a276e755e7e272e7bbd95eb3f82f2fcc946825a5", "patch": "@@ -87,7 +87,7 @@ should go to.\n */\n \n use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary};\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::lang_items;\n use rustc::middle::subst::{Substs, Subst, VecPerParamSpace};\n use rustc::middle::ty::{self, Ty, TyCtxt};\n@@ -326,9 +326,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 .push(self.cfg.current_location(block));\n         }\n \n-        let scope_id = self.innermost_scope_id();\n+        assert!(scope_count < self.scopes.len(),\n+                \"should never use `exit_scope` to pop *ALL* scopes\");\n+        let scope = self.scopes.iter().rev().skip(scope_count)\n+                                            .next()\n+                                            .unwrap();\n         self.cfg.terminate(block,\n-                           scope_id,\n+                           scope.id,\n                            span,\n                            TerminatorKind::Goto { target: target });\n     }\n@@ -365,8 +369,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.scopes.last().map(|scope| scope.extent).unwrap()\n     }\n \n-    pub fn extent_of_outermost_scope(&self) -> CodeExtent {\n-        self.scopes.first().map(|scope| scope.extent).unwrap()\n+    /// Returns the extent of the scope which should be exited by a\n+    /// return.\n+    pub fn extent_of_return_scope(&self) -> CodeExtent {\n+        // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n+        // We want `scopes[1]`, which is the `ParameterScope`.\n+        assert!(self.scopes.len() >= 2);\n+        assert!(match self.hir.tcx().region_maps.code_extent_data(self.scopes[1].extent) {\n+            CodeExtentData::ParameterScope { .. } => true,\n+            _ => false,\n+        });\n+        self.scopes[1].extent\n     }\n \n     // Scheduling drops"}, {"sha": "5a6e2edfdf9e78745df9a95d8822f96237ecfd63", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a276e755e7e272e7bbd95eb3f82f2fcc946825a5/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a276e755e7e272e7bbd95eb3f82f2fcc946825a5/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=a276e755e7e272e7bbd95eb3f82f2fcc946825a5", "patch": "@@ -27,7 +27,6 @@ use hair::cx::Cx;\n \n use rustc::mir::mir_map::MirMap;\n use rustc::middle::infer;\n-use rustc::middle::region::CodeExtentData;\n use rustc::middle::traits::ProjectionMode;\n use rustc::middle::ty::{self, Ty, TyCtxt};\n use rustc::util::common::ErrorReported;\n@@ -180,15 +179,13 @@ fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n             })\n             .collect();\n \n-    let parameter_scope =\n-        cx.tcx().region_maps.lookup_code_extent(\n-            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.id });\n     let (mut mir, scope_auxiliary) =\n         build::construct(cx,\n                          span,\n+                         fn_id,\n+                         body.id,\n                          implicit_arg_tys,\n                          arguments,\n-                         parameter_scope,\n                          fn_sig.output,\n                          body);\n "}]}