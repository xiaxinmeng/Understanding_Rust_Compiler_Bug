{"sha": "6384dca100f3cedfa031a9204586f94f8612eae5", "node_id": "C_kwDOAAsO6NoAKDYzODRkY2ExMDBmM2NlZGZhMDMxYTkyMDQ1ODZmOTRmODYxMmVhZTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-02T08:11:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-02T08:11:57Z"}, "message": "Auto merge of #90439 - m-ou-se:thread-is-running, r=Mark-Simulacrum\n\nAdd JoinHandle::is_running.\n\nThis adds:\n```rust\nimpl<T> JoinHandle<T> {\n    /// Checks if the the associated thread is still running its main function.\n    ///\n    /// This might return `false` for a brief moment after the thread's main\n    /// function has returned, but before the thread itself has stopped running.\n    pub fn is_running(&self) -> bool;\n}\n```\nThe usual way to check if a background thread is still running is to set some atomic flag at the end of its main function. We already do that, in the form of dropping an Arc which will reduce the reference counter. So we might as well expose that information.\n\nThis is useful in applications with a main loop (e.g. a game, gui, control system, ..) where you spawn some background task, and check every frame/iteration whether the background task is finished to .join() it in that frame/iteration while keeping the program responsive.", "tree": {"sha": "d90c4c0cd5cc67f24780b19c2ec378009f6b8cae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d90c4c0cd5cc67f24780b19c2ec378009f6b8cae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6384dca100f3cedfa031a9204586f94f8612eae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6384dca100f3cedfa031a9204586f94f8612eae5", "html_url": "https://github.com/rust-lang/rust/commit/6384dca100f3cedfa031a9204586f94f8612eae5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6384dca100f3cedfa031a9204586f94f8612eae5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dca3f1b786efd27be3b325ed1e01e247aa589c3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/dca3f1b786efd27be3b325ed1e01e247aa589c3b", "html_url": "https://github.com/rust-lang/rust/commit/dca3f1b786efd27be3b325ed1e01e247aa589c3b"}, {"sha": "978ebd9c8cd91079be62656ca193a9cbc85e157b", "url": "https://api.github.com/repos/rust-lang/rust/commits/978ebd9c8cd91079be62656ca193a9cbc85e157b", "html_url": "https://github.com/rust-lang/rust/commit/978ebd9c8cd91079be62656ca193a9cbc85e157b"}], "stats": {"total": 45, "additions": 44, "deletions": 1}, "files": [{"sha": "2a155ce31173130d028af622c1944985ffb608d8", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6384dca100f3cedfa031a9204586f94f8612eae5/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6384dca100f3cedfa031a9204586f94f8612eae5/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=6384dca100f3cedfa031a9204586f94f8612eae5", "patch": "@@ -1407,6 +1407,15 @@ impl<T> JoinHandle<T> {\n     pub fn join(mut self) -> Result<T> {\n         self.0.join()\n     }\n+\n+    /// Checks if the the associated thread is still running its main function.\n+    ///\n+    /// This might return `false` for a brief moment after the thread's main\n+    /// function has returned, but before the thread itself has stopped running.\n+    #[unstable(feature = \"thread_is_running\", issue = \"90470\")]\n+    pub fn is_running(&self) -> bool {\n+        Arc::strong_count(&self.0.packet.0) > 1\n+    }\n }\n \n impl<T> AsInner<imp::Thread> for JoinHandle<T> {"}, {"sha": "ca0d88135a5d8ae43fe35edb7654507da6b34bd7", "filename": "library/std/src/thread/tests.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6384dca100f3cedfa031a9204586f94f8612eae5/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6384dca100f3cedfa031a9204586f94f8612eae5/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs?ref=6384dca100f3cedfa031a9204586f94f8612eae5", "patch": "@@ -2,9 +2,13 @@ use super::Builder;\n use crate::any::Any;\n use crate::mem;\n use crate::result;\n-use crate::sync::mpsc::{channel, Sender};\n+use crate::sync::{\n+    mpsc::{channel, Sender},\n+    Arc, Barrier,\n+};\n use crate::thread::{self, ThreadId};\n use crate::time::Duration;\n+use crate::time::Instant;\n \n // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n@@ -46,6 +50,36 @@ fn test_run_basic() {\n     rx.recv().unwrap();\n }\n \n+#[test]\n+fn test_is_running() {\n+    let b = Arc::new(Barrier::new(2));\n+    let t = thread::spawn({\n+        let b = b.clone();\n+        move || {\n+            b.wait();\n+            1234\n+        }\n+    });\n+\n+    // Thread is definitely running here, since it's still waiting for the barrier.\n+    assert_eq!(t.is_running(), true);\n+\n+    // Unblock the barrier.\n+    b.wait();\n+\n+    // Now check that t.is_running() becomes false within a reasonable time.\n+    let start = Instant::now();\n+    while t.is_running() {\n+        assert!(start.elapsed() < Duration::from_secs(2));\n+        thread::sleep(Duration::from_millis(15));\n+    }\n+\n+    // Joining the thread should not block for a significant time now.\n+    let join_time = Instant::now();\n+    assert_eq!(t.join().unwrap(), 1234);\n+    assert!(join_time.elapsed() < Duration::from_secs(2));\n+}\n+\n #[test]\n fn test_join_panic() {\n     match thread::spawn(move || panic!()).join() {"}]}