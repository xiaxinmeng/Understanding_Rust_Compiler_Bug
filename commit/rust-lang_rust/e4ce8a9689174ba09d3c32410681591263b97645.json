{"sha": "e4ce8a9689174ba09d3c32410681591263b97645", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0Y2U4YTk2ODkxNzRiYTA5ZDNjMzI0MTA2ODE1OTEyNjNiOTc2NDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-18T12:06:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-18T12:06:48Z"}, "message": "auto merge of #12314 : huonw/rust/is_utf8_iter, r=kballard\n\nSee the commit messages for more details, but this makes `std::str::is_utf8` slightly faster and 100% non-`unsafe` and uses a similar thing to make the first scan of `from_utf8_lossy` 100% safe & faster.", "tree": {"sha": "8e829147e5a941a907ba0a50556b31bc5dacb533", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e829147e5a941a907ba0a50556b31bc5dacb533"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4ce8a9689174ba09d3c32410681591263b97645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4ce8a9689174ba09d3c32410681591263b97645", "html_url": "https://github.com/rust-lang/rust/commit/e4ce8a9689174ba09d3c32410681591263b97645", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4ce8a9689174ba09d3c32410681591263b97645/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3ed38f2196e8636f9f295da8d06c6921db183fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3ed38f2196e8636f9f295da8d06c6921db183fe", "html_url": "https://github.com/rust-lang/rust/commit/b3ed38f2196e8636f9f295da8d06c6921db183fe"}, {"sha": "a39056e614b61489a8b8afc4171586e454d4dcbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a39056e614b61489a8b8afc4171586e454d4dcbd", "html_url": "https://github.com/rust-lang/rust/commit/a39056e614b61489a8b8afc4171586e454d4dcbd"}], "stats": {"total": 115, "additions": 70, "deletions": 45}, "files": [{"sha": "a780a912d4df3cfa1d954a84a265d6f0f1d2fa3a", "filename": "src/libstd/str.rs", "status": "modified", "additions": 70, "deletions": 45, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/e4ce8a9689174ba09d3c32410681591263b97645/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4ce8a9689174ba09d3c32410681591263b97645/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=e4ce8a9689174ba09d3c32410681591263b97645", "patch": "@@ -731,29 +731,38 @@ pub fn eq(a: &~str, b: &~str) -> bool {\n Section: Misc\n */\n \n-/// Determines if a vector of bytes contains valid UTF-8\n-pub fn is_utf8(v: &[u8]) -> bool {\n-    first_non_utf8_index(v).is_none()\n-}\n-\n+/// Walk through `iter` checking that it's a valid UTF-8 sequence,\n+/// returning `true` in that case, or, if it is invalid, `false` with\n+/// `iter` reset such that it is pointing at the first byte in the\n+/// invalid sequence.\n #[inline(always)]\n-fn first_non_utf8_index(v: &[u8]) -> Option<uint> {\n-    let mut i = 0u;\n-    let total = v.len();\n-    fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n-        unsafe { *xs.unsafe_ref(i) }\n-    }\n-    while i < total {\n-        let v_i = unsafe_get(v, i);\n-        if v_i < 128u8 {\n-            i += 1u;\n-        } else {\n-            let w = utf8_char_width(v_i);\n-            if w == 0u { return Some(i); }\n+fn run_utf8_validation_iterator(iter: &mut vec::Items<u8>) -> bool {\n+    loop {\n+        // save the current thing we're pointing at.\n+        let old = *iter;\n+\n+        // restore the iterator we had at the start of this codepoint.\n+        macro_rules! err ( () => { {*iter = old; return false} });\n+        macro_rules! next ( () => {\n+                match iter.next() {\n+                    Some(a) => *a,\n+                    // we needed data, but there was none: error!\n+                    None => err!()\n+                }\n+            });\n \n-            let nexti = i + w;\n-            if nexti > total { return Some(i); }\n+        let first = match iter.next() {\n+            Some(&b) => b,\n+            // we're at the end of the iterator and a codepoint\n+            // boundary at the same time, so this string is valid.\n+            None => return true\n+        };\n \n+        // ASCII characters are always valid, so only large\n+        // bytes need more examination.\n+        if first >= 128 {\n+            let w = utf8_char_width(first);\n+            let second = next!();\n             // 2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n             //        first  C2 80        last DF BF\n             // 3-byte encoding is for codepoints  \\u0800 to  \\uffff\n@@ -772,35 +781,51 @@ fn first_non_utf8_index(v: &[u8]) -> Option<uint> {\n             //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n             // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n             //               %xF4 %x80-8F 2( UTF8-tail )\n-            // UTF8-tail   = %x80-BF\n             match w {\n-                2 => if unsafe_get(v, i + 1) & 192u8 != TAG_CONT_U8 {\n-                    return Some(i)\n-                },\n-                3 => match (v_i,\n-                            unsafe_get(v, i + 1),\n-                            unsafe_get(v, i + 2) & 192u8) {\n-                    (0xE0        , 0xA0 .. 0xBF, TAG_CONT_U8) => (),\n-                    (0xE1 .. 0xEC, 0x80 .. 0xBF, TAG_CONT_U8) => (),\n-                    (0xED        , 0x80 .. 0x9F, TAG_CONT_U8) => (),\n-                    (0xEE .. 0xEF, 0x80 .. 0xBF, TAG_CONT_U8) => (),\n-                    _ => return Some(i),\n-                },\n-                _ => match (v_i,\n-                            unsafe_get(v, i + 1),\n-                            unsafe_get(v, i + 2) & 192u8,\n-                            unsafe_get(v, i + 3) & 192u8) {\n-                    (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) => (),\n-                    (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) => (),\n-                    (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => (),\n-                    _ => return Some(i)\n-                },\n+                2 => if second & 192 != TAG_CONT_U8 {err!()},\n+                3 => {\n+                    match (first, second, next!() & 192) {\n+                        (0xE0        , 0xA0 .. 0xBF, TAG_CONT_U8) |\n+                        (0xE1 .. 0xEC, 0x80 .. 0xBF, TAG_CONT_U8) |\n+                        (0xED        , 0x80 .. 0x9F, TAG_CONT_U8) |\n+                        (0xEE .. 0xEF, 0x80 .. 0xBF, TAG_CONT_U8) => {}\n+                        _ => err!()\n+                    }\n+                }\n+                4 => {\n+                    match (first, second, next!() & 192, next!() & 192) {\n+                        (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n+                        (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n+                        (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => {}\n+                        _ => err!()\n+                    }\n+                }\n+                _ => err!()\n             }\n-\n-            i = nexti;\n         }\n     }\n-    None\n+}\n+\n+/// Determines if a vector of bytes contains valid UTF-8.\n+pub fn is_utf8(v: &[u8]) -> bool {\n+    run_utf8_validation_iterator(&mut v.iter())\n+}\n+\n+#[inline(always)]\n+fn first_non_utf8_index(v: &[u8]) -> Option<uint> {\n+    let mut it = v.iter();\n+\n+    let ok = run_utf8_validation_iterator(&mut it);\n+    if ok {\n+        None\n+    } else {\n+        // work out how many valid bytes we've consumed\n+        // (run_utf8_validation_iterator resets the iterator to just\n+        // after the last good byte), which we can do because the\n+        // vector iterator size_hint is exact.\n+        let (remaining, _) = it.size_hint();\n+        Some(v.len() - remaining)\n+    }\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16"}]}