{"sha": "9fcf2c972663ab510417ba1df058f99f0b0d0abe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmY2YyYzk3MjY2M2FiNTEwNDE3YmExZGYwNThmOTlmMGIwZDBhYmU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-07-30T07:04:03Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-01T22:33:04Z"}, "message": "use the same length computation everywhere", "tree": {"sha": "cf1c95da289d20d0f9cc8422afdcce293a7b241c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf1c95da289d20d0f9cc8422afdcce293a7b241c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fcf2c972663ab510417ba1df058f99f0b0d0abe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fcf2c972663ab510417ba1df058f99f0b0d0abe", "html_url": "https://github.com/rust-lang/rust/commit/9fcf2c972663ab510417ba1df058f99f0b0d0abe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fcf2c972663ab510417ba1df058f99f0b0d0abe/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1471cf41f6b88f6ddc91278f5a0a975a27b3de0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1471cf41f6b88f6ddc91278f5a0a975a27b3de0", "html_url": "https://github.com/rust-lang/rust/commit/e1471cf41f6b88f6ddc91278f5a0a975a27b3de0"}], "stats": {"total": 31, "additions": 10, "deletions": 21}, "files": [{"sha": "a4dde38cb7bb636abb201cbd26c056a0b4cd21f5", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9fcf2c972663ab510417ba1df058f99f0b0d0abe/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcf2c972663ab510417ba1df058f99f0b0d0abe/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=9fcf2c972663ab510417ba1df058f99f0b0d0abe", "patch": "@@ -2349,20 +2349,9 @@ macro_rules! is_empty {\n     // and non-ZST.\n     ($self: ident) => {$self.ptr == $self.end}\n }\n+// To get rid of some bounds checks (see `position`), we compute the length in a somewhat\n+// unexpected way. (Tested by `codegen/slice-position-bounds-check`.)\n macro_rules! len {\n-    ($self: ident) => {{\n-        let start = $self.ptr;\n-        if size_from_ptr(start) == 0 {\n-            ($self.end as usize).wrapping_sub(start as usize)\n-        } else {\n-            $self.end.offset_from(start) as usize\n-        }\n-    }}\n-}\n-// To get rid of some bounds checks (see `position`), for some reason it\n-// makes a difference to compute the length in this way.\n-// (Tested by `codegen/slice-position-bounds-check`.)\n-macro_rules! len2 {\n     ($self: ident) => {{\n         let start = $self.ptr;\n         let diff = ($self.end as usize).wrapping_sub(start as usize);\n@@ -2383,7 +2372,7 @@ macro_rules! iterator {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n             fn make_slice(&self) -> &'a [T] {\n-                unsafe { from_raw_parts(self.ptr, len2!(self)) }\n+                unsafe { from_raw_parts(self.ptr, len!(self)) }\n             }\n \n             // Helper function for moving the start of the iterator forwards by `offset` elements,\n@@ -2421,7 +2410,7 @@ macro_rules! iterator {\n         impl<'a, T> ExactSizeIterator for $name<'a, T> {\n             #[inline(always)]\n             fn len(&self) -> usize {\n-                unsafe { len!(self) }\n+                len!(self)\n             }\n \n             #[inline(always)]\n@@ -2452,18 +2441,18 @@ macro_rules! iterator {\n \n             #[inline]\n             fn size_hint(&self) -> (usize, Option<usize>) {\n-                let exact = unsafe { len!(self) };\n+                let exact = len!(self);\n                 (exact, Some(exact))\n             }\n \n             #[inline]\n             fn count(self) -> usize {\n-                self.len()\n+                len!(self)\n             }\n \n             #[inline]\n             fn nth(&mut self, n: usize) -> Option<$elem> {\n-                if n >= unsafe { len!(self) } {\n+                if n >= len!(self) {\n                     // This iterator is now empty.\n                     if mem::size_of::<T>() == 0 {\n                         // We have to do it this way as `ptr` may never be 0, but `end`\n@@ -2527,7 +2516,7 @@ macro_rules! iterator {\n                 P: FnMut(Self::Item) -> bool,\n             {\n                 // The addition might panic on overflow.\n-                let n = len2!(self);\n+                let n = len!(self);\n                 self.try_fold(0, move |i, x| {\n                     if predicate(x) { Err(i) }\n                     else { Ok(i + 1) }\n@@ -2544,7 +2533,7 @@ macro_rules! iterator {\n                 Self: Sized + ExactSizeIterator + DoubleEndedIterator\n             {\n                 // No need for an overflow check here, because `ExactSizeIterator`\n-                let n = len2!(self);\n+                let n = len!(self);\n                 self.try_rfold(n, move |i, x| {\n                     let i = i - 1;\n                     if predicate(x) { Err(i) }\n@@ -2789,7 +2778,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n-        unsafe { from_raw_parts_mut(self.ptr, len2!(self)) }\n+        unsafe { from_raw_parts_mut(self.ptr, len!(self)) }\n     }\n }\n "}]}