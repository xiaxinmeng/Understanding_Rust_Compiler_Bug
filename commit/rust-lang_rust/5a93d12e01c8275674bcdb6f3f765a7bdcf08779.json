{"sha": "5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhOTNkMTJlMDFjODI3NTY3NGJjZGI2ZjNmNzY1YTdiZGNmMDg3Nzk=", "commit": {"author": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2013-12-08T07:12:07Z"}, "committer": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2013-12-11T06:50:51Z"}, "message": "std::io: Add Buffer.lines(), change .bytes() api\n\n-   `Buffer.lines()` returns `LineIterator` which yields line using\n    `.read_line()`.\n-   `Reader.bytes()` now takes `&mut self` instead of `self`.\n-   `Reader.read_until()` swallows `EndOfFile`. This also affects\n    `.read_line()`.", "tree": {"sha": "32866c4cc1b0bdcd81e23dad666a51e34c94d8d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32866c4cc1b0bdcd81e23dad666a51e34c94d8d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "html_url": "https://github.com/rust-lang/rust/commit/5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/comments", "author": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8b16ae0996074861693f0f76d5d937fafe6a37e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b16ae0996074861693f0f76d5d937fafe6a37e", "html_url": "https://github.com/rust-lang/rust/commit/b8b16ae0996074861693f0f76d5d937fafe6a37e"}], "stats": {"total": 217, "additions": 141, "deletions": 76}, "files": [{"sha": "b15bf73c193eae422c4d9c726c9620c30c2d8828", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "patch": "@@ -19,10 +19,7 @@ pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n     let mut error_patterns = ~[];\n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n     let mut line_num = 1u;\n-    loop {\n-        let ln = match rdr.read_line() {\n-            Some(ln) => ln, None => break,\n-        };\n+    for ln in rdr.lines() {\n         error_patterns.push_all_move(parse_expected(line_num, ln));\n         line_num += 1u;\n     }"}, {"sha": "98989a2cba29c342074c464d58f73b93cac2e2aa", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "patch": "@@ -107,11 +107,7 @@ fn iter_header(testfile: &Path, it: |&str| -> bool) -> bool {\n     use std::io::File;\n \n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n-    loop {\n-        let ln = match rdr.read_line() {\n-            Some(ln) => ln, None => break\n-        };\n-\n+    for ln in rdr.lines() {\n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one."}, {"sha": "04f4d50036fdd1d30134c5d2c746d969c2876d19", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "patch": "@@ -454,6 +454,28 @@ mod test {\n             ~[0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2, 3, '\\n' as u8]);\n     }\n \n+    #[test]\n+    fn test_read_line() {\n+        let in_buf = MemReader::new(bytes!(\"a\\nb\\nc\").to_owned());\n+        let mut reader = BufferedReader::with_capacity(2, in_buf);\n+        assert_eq!(reader.read_line(), Some(~\"a\\n\"));\n+        assert_eq!(reader.read_line(), Some(~\"b\\n\"));\n+        assert_eq!(reader.read_line(), Some(~\"c\"));\n+        assert_eq!(reader.read_line(), None);\n+    }\n+\n+    #[test]\n+    fn test_lines() {\n+        let in_buf = MemReader::new(bytes!(\"a\\nb\\nc\").to_owned());\n+        let mut reader = BufferedReader::with_capacity(2, in_buf);\n+        let mut it = reader.lines();\n+        assert_eq!(it.next(), Some(~\"a\\n\"));\n+        assert_eq!(it.next(), Some(~\"b\\n\"));\n+        assert_eq!(it.next(), Some(~\"c\"));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+\n     #[bench]\n     fn bench_buffered_reader(bh: &mut Harness) {\n         bh.iter(|| {"}, {"sha": "a7361fa8c373c6a8d1a7441c25954686f2cc73d7", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "patch": "@@ -15,7 +15,7 @@\n \n use iter::Iterator;\n use option::Option;\n-use io::{Reader, Decorator};\n+use io::Reader;\n \n /// An iterator that reads a single byte on each iteration,\n /// until `.read_byte()` returns `None`.\n@@ -31,23 +31,17 @@ use io::{Reader, Decorator};\n /// Raises the same conditions as the `read` method, for\n /// each call to its `.next()` method.\n /// Yields `None` if the condition is handled.\n-pub struct ByteIterator<T> {\n-    priv reader: T,\n+pub struct ByteIterator<'r, T> {\n+    priv reader: &'r mut T,\n }\n \n-impl<R: Reader> ByteIterator<R> {\n-    pub fn new(r: R) -> ByteIterator<R> {\n+impl<'r, R: Reader> ByteIterator<'r, R> {\n+    pub fn new(r: &'r mut R) -> ByteIterator<'r, R> {\n         ByteIterator { reader: r }\n     }\n }\n \n-impl<R> Decorator<R> for ByteIterator<R> {\n-    fn inner(self) -> R { self.reader }\n-    fn inner_ref<'a>(&'a self) -> &'a R { &self.reader }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R { &mut self.reader }\n-}\n-\n-impl<'self, R: Reader> Iterator<u8> for ByteIterator<R> {\n+impl<'r, R: Reader> Iterator<u8> for ByteIterator<'r, R> {\n     #[inline]\n     fn next(&mut self) -> Option<u8> {\n         self.reader.read_byte()\n@@ -285,7 +279,7 @@ mod test {\n \n     #[test]\n     fn bytes_0_bytes() {\n-        let reader = InitialZeroByteReader {\n+        let mut reader = InitialZeroByteReader {\n             count: 0,\n         };\n         let byte = reader.bytes().next();\n@@ -294,14 +288,14 @@ mod test {\n \n     #[test]\n     fn bytes_eof() {\n-        let reader = EofReader;\n+        let mut reader = EofReader;\n         let byte = reader.bytes().next();\n         assert!(byte == None);\n     }\n \n     #[test]\n     fn bytes_error() {\n-        let reader = ErroringReader;\n+        let mut reader = ErroringReader;\n         let mut it = reader.bytes();\n         io_error::cond.trap(|_| ()).inside(|| {\n             let byte = it.next();"}, {"sha": "77bdf86633849a0a9633188a34969b6fa7af3468", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 105, "deletions": 37, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "patch": "@@ -25,41 +25,63 @@ Some examples of obvious things you might want to do\n \n * Read lines from stdin\n \n-    for stdin().each_line |line| {\n-        println(line)\n+    ```rust\n+    let mut stdin = BufferedReader::new(stdin());\n+    for line in stdin.lines() {\n+        print(line);\n     }\n+    ```\n \n-* Read a complete file to a string, (converting newlines?)\n+* Read a complete file\n \n-    let contents = File::open(\"message.txt\").read_to_str(); // read_to_str??\n+    ```rust\n+    let contents = File::open(&Path::new(\"message.txt\")).read_to_end();\n+    ```\n \n * Write a line to a file\n \n-    let file = File::open(\"message.txt\", Create, Write);\n-    file.write_line(\"hello, file!\");\n+    ```rust\n+    let mut file = File::create(&Path::new(\"message.txt\"));\n+    file.write(bytes!(\"hello, file!\\n\"));\n+    ```\n \n * Iterate over the lines of a file\n \n-    File::open(\"message.txt\").each_line(|line| {\n-        println(line)\n-    })\n+    ```rust\n+    let path = Path::new(\"message.txt\");\n+    let mut file = BufferedReader::new(File::open(&path));\n+    for line in file.lines() {\n+        print(line);\n+    }\n+    ```\n \n * Pull the lines of a file into a vector of strings\n \n-    let lines = File::open(\"message.txt\").lines().to_vec();\n+    ```rust\n+    let path = Path::new(\"message.txt\");\n+    let mut file = BufferedReader::new(File::open(&path));\n+    let lines: ~[~str] = file.lines().collect();\n+    ```\n \n * Make an simple HTTP request\n+  XXX This needs more improvement: TcpStream constructor taking &str,\n+  `write_str` and `write_line` methods.\n \n-    let socket = TcpStream::open(\"localhost:8080\");\n-    socket.write_line(\"GET / HTTP/1.0\");\n-    socket.write_line(\"\");\n+    ```rust\n+    let addr = from_str::<SocketAddr>(\"127.0.0.1:8080\").unwrap();\n+    let mut socket = TcpStream::connect(addr).unwrap();\n+    socket.write(bytes!(\"GET / HTTP/1.0\\n\\n\"));\n     let response = socket.read_to_end();\n+    ```\n \n * Connect based on URL? Requires thinking about where the URL type lives\n   and how to make protocol handlers extensible, e.g. the \"tcp\" protocol\n   yields a `TcpStream`.\n+  XXX this is not implemented now.\n \n-    connect(\"tcp://localhost:8080\");\n+    ```rust\n+    // connect(\"tcp://localhost:8080\");\n+    ```\n \n # Terms\n \n@@ -535,7 +557,8 @@ pub trait Reader {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the same conditions as the `read` method.\n+    /// Raises the same conditions as the `read` method except for\n+    /// `EndOfFile` which is swallowed.\n     fn read_to_end(&mut self) -> ~[u8] {\n         let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n         let mut keep_reading = true;\n@@ -561,7 +584,7 @@ pub trait Reader {\n     /// Raises the same conditions as the `read` method, for\n     /// each call to its `.next()` method.\n     /// Ends the iteration if the condition is handled.\n-    fn bytes(self) -> extensions::ByteIterator<Self> {\n+    fn bytes<'r>(&'r mut self) -> extensions::ByteIterator<'r, Self> {\n         extensions::ByteIterator::new(self)\n     }\n \n@@ -958,6 +981,30 @@ pub trait Stream: Reader + Writer { }\n \n impl<T: Reader + Writer> Stream for T {}\n \n+/// An iterator that reads a line on each iteration,\n+/// until `.read_line()` returns `None`.\n+///\n+/// # Notes about the Iteration Protocol\n+///\n+/// The `LineIterator` may yield `None` and thus terminate\n+/// an iteration, but continue to yield elements if iteration\n+/// is attempted again.\n+///\n+/// # Failure\n+///\n+/// Raises the same conditions as the `read` method except for `EndOfFile`\n+/// which is swallowed.\n+/// Iteration yields `None` if the condition is handled.\n+struct LineIterator<'r, T> {\n+    priv buffer: &'r mut T,\n+}\n+\n+impl<'r, T: Buffer> Iterator<~str> for LineIterator<'r, T> {\n+    fn next(&mut self) -> Option<~str> {\n+        self.buffer.read_line()\n+    }\n+}\n+\n /// A Buffer is a type of reader which has some form of internal buffering to\n /// allow certain kinds of reading operations to be more optimized than others.\n /// This type extends the `Reader` trait with a few methods that are not\n@@ -987,46 +1034,67 @@ pub trait Buffer: Reader {\n     ///\n     /// # Failure\n     ///\n-    /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered. The task will also fail if sequence of bytes leading up to\n+    /// This function will raise on the `io_error` condition (except for\n+    /// `EndOfFile` which is swallowed) if a read error is encountered.\n+    /// The task will also fail if sequence of bytes leading up to\n     /// the newline character are not valid utf-8.\n     fn read_line(&mut self) -> Option<~str> {\n         self.read_until('\\n' as u8).map(str::from_utf8_owned)\n     }\n \n+    /// Create an iterator that reads a line on each iteration until EOF.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Iterator raises the same conditions as the `read` method\n+    /// except for `EndOfFile`.\n+    fn lines<'r>(&'r mut self) -> LineIterator<'r, Self> {\n+        LineIterator {\n+            buffer: self,\n+        }\n+    }\n+\n     /// Reads a sequence of bytes leading up to a specified delimeter. Once the\n     /// specified byte is encountered, reading ceases and the bytes up to and\n     /// including the delimiter are returned.\n     ///\n     /// # Failure\n     ///\n     /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered.\n+    /// encountered, except that `EndOfFile` is swallowed.\n     fn read_until(&mut self, byte: u8) -> Option<~[u8]> {\n         let mut res = ~[];\n-        let mut used;\n-        loop {\n-            {\n-                let available = self.fill();\n-                match available.iter().position(|&b| b == byte) {\n-                    Some(i) => {\n-                        res.push_all(available.slice_to(i + 1));\n-                        used = i + 1;\n-                        break\n-                    }\n-                    None => {\n-                        res.push_all(available);\n-                        used = available.len();\n+\n+        io_error::cond.trap(|e| {\n+            if e.kind != EndOfFile {\n+                io_error::cond.raise(e);\n+            }\n+        }).inside(|| {\n+            let mut used;\n+            loop {\n+                {\n+                    let available = self.fill();\n+                    match available.iter().position(|&b| b == byte) {\n+                        Some(i) => {\n+                            res.push_all(available.slice_to(i + 1));\n+                            used = i + 1;\n+                            break\n+                        }\n+                        None => {\n+                            res.push_all(available);\n+                            used = available.len();\n+                        }\n                     }\n                 }\n-            }\n-            if used == 0 {\n-                break\n+                if used == 0 {\n+                    break\n+                }\n+                self.consume(used);\n             }\n             self.consume(used);\n-        }\n-        self.consume(used);\n+        });\n         return if res.len() == 0 {None} else {Some(res)};\n+\n     }\n \n     /// Reads the next utf8-encoded character from the underlying stream."}, {"sha": "9be462f736bc5883744386ecb121143d8afe84db", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "patch": "@@ -77,8 +77,7 @@ fn read_line() {\n \n     for _ in range(0, 3) {\n         let mut reader = BufferedReader::new(File::open(&path).unwrap());\n-        while !reader.eof() {\n-            reader.read_line();\n+        for _line in reader.lines() {\n         }\n     }\n }"}, {"sha": "a12eac50852846cbae8a4b35fbcc43b2b14903f3", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "patch": "@@ -188,14 +188,7 @@ fn main() {\n    // reading the sequence of interest\n    let mut proc_mode = false;\n \n-   loop {\n-       let line = {\n-           let _guard = io::ignore_io_error();\n-           match rdr.read_line() {\n-               Some(ln) => ln,\n-               None => break,\n-           }\n-       };\n+   for line in rdr.lines() {\n        let line = line.trim().to_owned();\n \n        if line.len() == 0u { continue; }"}, {"sha": "39bcfde2826d1a46654994d7da0f3b41cb2c271f", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a93d12e01c8275674bcdb6f3f765a7bdcf08779/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=5a93d12e01c8275674bcdb6f3f765a7bdcf08779", "patch": "@@ -18,7 +18,6 @@ use std::io;\n use std::io::stdio::StdReader;\n use std::io::buffered::BufferedReader;\n use std::os;\n-use std::uint;\n use std::unstable::intrinsics::cttz16;\n use std::vec;\n \n@@ -72,10 +71,7 @@ impl Sudoku {\n         assert!(reader.read_line().unwrap() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n \n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n-        loop {\n-            let line = match reader.read_line() {\n-                Some(ln) => ln, None => break\n-            };\n+        for line in reader.lines() {\n             let comps: ~[&str] = line.trim().split(',').collect();\n \n             if comps.len() == 3u {"}]}