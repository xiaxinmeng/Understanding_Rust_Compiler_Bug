{"sha": "eb626e71199d1d89a0242043f096d89941fa2ec7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNjI2ZTcxMTk5ZDFkODlhMDI0MjA0M2YwOTZkODk5NDFmYTJlYzc=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-07T23:33:20Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-08T00:20:19Z"}, "message": "Remove the old serializers (needs snapshot)", "tree": {"sha": "04ca276c78ac129c630c12922985a438e0a8a489", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04ca276c78ac129c630c12922985a438e0a8a489"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb626e71199d1d89a0242043f096d89941fa2ec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb626e71199d1d89a0242043f096d89941fa2ec7", "html_url": "https://github.com/rust-lang/rust/commit/eb626e71199d1d89a0242043f096d89941fa2ec7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb626e71199d1d89a0242043f096d89941fa2ec7/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91b7a9a529cad2db9503fa469b2e2ce7a86257e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/91b7a9a529cad2db9503fa469b2e2ce7a86257e6", "html_url": "https://github.com/rust-lang/rust/commit/91b7a9a529cad2db9503fa469b2e2ce7a86257e6"}], "stats": {"total": 5045, "additions": 2177, "deletions": 2868}, "files": [{"sha": "79e491e309bc1e0ceee646fa32dc5523cf51e426", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 207, "deletions": 187, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -1,21 +1,35 @@\n #[forbid(deprecated_mode)];\n+use serialization;\n+\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n-use core::Option;\n-use option::{Some, None};\n \n-type EbmlTag = {id: uint, size: uint};\n+struct EbmlTag {\n+    id: uint,\n+    size: uint,\n+}\n \n-type EbmlState = {ebml_tag: EbmlTag, tag_pos: uint, data_pos: uint};\n+struct EbmlState {\n+    ebml_tag: EbmlTag,\n+    tag_pos: uint,\n+    data_pos: uint,\n+}\n \n // FIXME (#2739): When we have module renaming, make \"reader\" and \"writer\"\n // separate modules within this file.\n \n // ebml reading\n-pub type Doc = {data: @~[u8], start: uint, end: uint};\n+struct Doc {\n+    data: @~[u8],\n+    start: uint,\n+    end: uint,\n+}\n \n-type TaggedDoc = {tag: uint, doc: Doc};\n+struct TaggedDoc {\n+    tag: uint,\n+    doc: Doc,\n+}\n \n impl Doc: ops::Index<uint,Doc> {\n     pure fn index(tag: uint) -> Doc {\n@@ -49,15 +63,17 @@ fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n }\n \n pub fn Doc(data: @~[u8]) -> Doc {\n-    return {data: data, start: 0u, end: vec::len::<u8>(*data)};\n+    Doc { data: data, start: 0u, end: vec::len::<u8>(*data) }\n }\n \n pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n     let elt_tag = vuint_at(*data, start);\n     let elt_size = vuint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n-    return {tag: elt_tag.val,\n-         doc: {data: data, start: elt_size.next, end: end}};\n+    TaggedDoc {\n+        tag: elt_tag.val,\n+        doc: Doc { data: data, start: elt_size.next, end: end }\n+    }\n }\n \n pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n@@ -67,19 +83,15 @@ pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n-            return Some::<Doc>({\n-                data: d.data,\n-                start: elt_size.next,\n-                end: pos\n-            });\n+            return Some(Doc { data: d.data, start: elt_size.next, end: pos });\n         }\n     }\n-    return None::<Doc>;\n+    None\n }\n \n pub fn get_doc(d: Doc, tg: uint) -> Doc {\n     match maybe_get_doc(d, tg) {\n-      Some(d) => return d,\n+      Some(d) => d,\n       None => {\n         error!(\"failed to find block with tag %u\", tg);\n         fail;\n@@ -93,7 +105,8 @@ pub fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n         let elt_tag = vuint_at(*d.data, pos);\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n-        if !it(elt_tag.val, {data: d.data, start: elt_size.next, end: pos}) {\n+        let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n+        if !it(elt_tag.val, doc) {\n             break;\n         }\n     }\n@@ -106,7 +119,8 @@ pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n-            if !it({data: d.data, start: elt_size.next, end: pos}) {\n+            let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n+            if !it(doc) {\n                 break;\n             }\n         }\n@@ -116,29 +130,29 @@ pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n pub fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n \n pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n-    return f(vec::view(*d.data, d.start, d.end));\n+    f(vec::view(*d.data, d.start, d.end))\n }\n \n-pub fn doc_as_str(d: Doc) -> ~str { return str::from_bytes(doc_data(d)); }\n+pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n \n pub fn doc_as_u8(d: Doc) -> u8 {\n     assert d.end == d.start + 1u;\n-    return (*d.data)[d.start];\n+    (*d.data)[d.start]\n }\n \n pub fn doc_as_u16(d: Doc) -> u16 {\n     assert d.end == d.start + 2u;\n-    return io::u64_from_be_bytes(*d.data, d.start, 2u) as u16;\n+    io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n }\n \n pub fn doc_as_u32(d: Doc) -> u32 {\n     assert d.end == d.start + 4u;\n-    return io::u64_from_be_bytes(*d.data, d.start, 4u) as u32;\n+    io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n }\n \n pub fn doc_as_u64(d: Doc) -> u64 {\n     assert d.end == d.start + 8u;\n-    return io::u64_from_be_bytes(*d.data, d.start, 8u);\n+    io::u64_from_be_bytes(*d.data, d.start, 8u)\n }\n \n pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n@@ -147,10 +161,9 @@ pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n // ebml writing\n-type Writer_ = {writer: io::Writer, mut size_positions: ~[uint]};\n-\n-pub enum Writer {\n-    Writer_(Writer_)\n+struct Serializer {\n+    writer: io::Writer,\n+    priv mut size_positions: ~[uint],\n }\n \n fn write_sized_vuint(w: io::Writer, n: uint, size: uint) {\n@@ -173,13 +186,13 @@ fn write_vuint(w: io::Writer, n: uint) {\n     fail fmt!(\"vint to write too big: %?\", n);\n }\n \n-pub fn Writer(w: io::Writer) -> Writer {\n+pub fn Serializer(w: io::Writer) -> Serializer {\n     let size_positions: ~[uint] = ~[];\n-    return Writer_({writer: w, mut size_positions: size_positions});\n+    Serializer { writer: w, mut size_positions: size_positions }\n }\n \n // FIXME (#2741): Provide a function to write the standard ebml header.\n-impl Writer {\n+impl Serializer {\n     fn start_tag(tag_id: uint) {\n         debug!(\"Start tag %u\", tag_id);\n \n@@ -295,12 +308,7 @@ enum EbmlSerializerTag {\n     EsLabel // Used only when debugging\n }\n \n-trait SerializerPriv {\n-    fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint);\n-    fn _emit_label(label: &str);\n-}\n-\n-impl ebml::Writer: SerializerPriv {\n+priv impl Serializer {\n     // used internally to emit things like the vector length and so on\n     fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint) {\n         assert v <= 0xFFFF_FFFF_u;\n@@ -318,103 +326,137 @@ impl ebml::Writer: SerializerPriv {\n     }\n }\n \n-impl ebml::Writer {\n-    fn emit_opaque(f: fn()) {\n+impl Serializer {\n+    fn emit_opaque(&self, f: fn()) {\n         do self.wr_tag(EsOpaque as uint) {\n             f()\n         }\n     }\n }\n \n-impl ebml::Writer: serialization::Serializer {\n-    fn emit_nil() {}\n+impl Serializer: serialization::Serializer {\n+    fn emit_nil(&self) {}\n \n-    fn emit_uint(v: uint) { self.wr_tagged_u64(EsUint as uint, v as u64); }\n-    fn emit_u64(v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n-    fn emit_u32(v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n-    fn emit_u16(v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n-    fn emit_u8(v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n+    fn emit_uint(&self, v: uint) {\n+        self.wr_tagged_u64(EsUint as uint, v as u64);\n+    }\n+    fn emit_u64(&self, v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n+    fn emit_u32(&self, v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n+    fn emit_u16(&self, v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n+    fn emit_u8(&self, v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n \n-    fn emit_int(v: int) { self.wr_tagged_i64(EsInt as uint, v as i64); }\n-    fn emit_i64(v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n-    fn emit_i32(v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n-    fn emit_i16(v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n-    fn emit_i8(v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n+    fn emit_int(&self, v: int) {\n+        self.wr_tagged_i64(EsInt as uint, v as i64);\n+    }\n+    fn emit_i64(&self, v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n+    fn emit_i32(&self, v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n+    fn emit_i16(&self, v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n+    fn emit_i8(&self, v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n \n-    fn emit_bool(v: bool) { self.wr_tagged_u8(EsBool as uint, v as u8) }\n+    fn emit_bool(&self, v: bool) {\n+        self.wr_tagged_u8(EsBool as uint, v as u8)\n+    }\n \n     // FIXME (#2742): implement these\n-    fn emit_f64(_v: f64) { fail ~\"Unimplemented: serializing an f64\"; }\n-    fn emit_f32(_v: f32) { fail ~\"Unimplemented: serializing an f32\"; }\n-    fn emit_float(_v: float) { fail ~\"Unimplemented: serializing a float\"; }\n+    fn emit_f64(&self, _v: f64) { fail ~\"Unimplemented: serializing an f64\"; }\n+    fn emit_f32(&self, _v: f32) { fail ~\"Unimplemented: serializing an f32\"; }\n+    fn emit_float(&self, _v: float) {\n+        fail ~\"Unimplemented: serializing a float\";\n+    }\n+\n+    fn emit_char(&self, _v: char) {\n+        fail ~\"Unimplemented: serializing a char\";\n+    }\n \n-    fn emit_str(v: &str) { self.wr_tagged_str(EsStr as uint, v) }\n+    fn emit_borrowed_str(&self, v: &str) {\n+        self.wr_tagged_str(EsStr as uint, v)\n+    }\n \n-    fn emit_enum(name: &str, f: fn()) {\n+    fn emit_owned_str(&self, v: &str) {\n+        self.emit_borrowed_str(v)\n+    }\n+\n+    fn emit_managed_str(&self, v: &str) {\n+        self.emit_borrowed_str(v)\n+    }\n+\n+    fn emit_borrowed(&self, f: fn()) { f() }\n+    fn emit_owned(&self, f: fn()) { f() }\n+    fn emit_managed(&self, f: fn()) { f() }\n+\n+    fn emit_enum(&self, name: &str, f: fn()) {\n         self._emit_label(name);\n         self.wr_tag(EsEnum as uint, f)\n     }\n-    fn emit_enum_variant(_v_name: &str, v_id: uint, _cnt: uint, f: fn()) {\n+    fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n+                         f: fn()) {\n         self._emit_tagged_uint(EsEnumVid, v_id);\n         self.wr_tag(EsEnumBody as uint, f)\n     }\n-    fn emit_enum_variant_arg(_idx: uint, f: fn()) { f() }\n+    fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) { f() }\n \n-    fn emit_vec(len: uint, f: fn()) {\n+    fn emit_borrowed_vec(&self, len: uint, f: fn()) {\n         do self.wr_tag(EsVec as uint) {\n             self._emit_tagged_uint(EsVecLen, len);\n             f()\n         }\n     }\n \n-    fn emit_vec_elt(_idx: uint, f: fn()) {\n+    fn emit_owned_vec(&self, len: uint, f: fn()) {\n+        self.emit_borrowed_vec(len, f)\n+    }\n+\n+    fn emit_managed_vec(&self, len: uint, f: fn()) {\n+        self.emit_borrowed_vec(len, f)\n+    }\n+\n+    fn emit_vec_elt(&self, _idx: uint, f: fn()) {\n         self.wr_tag(EsVecElt as uint, f)\n     }\n \n-    fn emit_box(f: fn()) { f() }\n-    fn emit_uniq(f: fn()) { f() }\n-    fn emit_rec(f: fn()) { f() }\n-    fn emit_rec_field(f_name: &str, _f_idx: uint, f: fn()) {\n-        self._emit_label(f_name);\n+    fn emit_rec(&self, f: fn()) { f() }\n+    fn emit_struct(&self, _name: &str, f: fn()) { f() }\n+    fn emit_field(&self, name: &str, _idx: uint, f: fn()) {\n+        self._emit_label(name);\n         f()\n     }\n-    fn emit_tup(_sz: uint, f: fn()) { f() }\n-    fn emit_tup_elt(_idx: uint, f: fn()) { f() }\n-}\n \n-type EbmlDeserializer_ = {mut parent: ebml::Doc,\n-                          mut pos: uint};\n+    fn emit_tup(&self, _len: uint, f: fn()) { f() }\n+    fn emit_tup_elt(&self, _idx: uint, f: fn()) { f() }\n+}\n \n-pub enum EbmlDeserializer {\n-    EbmlDeserializer_(EbmlDeserializer_)\n+struct Deserializer {\n+    priv mut parent: Doc,\n+    priv mut pos: uint,\n }\n \n-pub fn ebml_deserializer(d: ebml::Doc) -> EbmlDeserializer {\n-    EbmlDeserializer_({mut parent: d, mut pos: d.start})\n+pub fn Deserializer(d: Doc) -> Deserializer {\n+    Deserializer { mut parent: d, mut pos: d.start }\n }\n \n-priv impl EbmlDeserializer {\n+priv impl Deserializer {\n     fn _check_label(lbl: &str) {\n         if self.pos < self.parent.end {\n-            let {tag: r_tag, doc: r_doc} =\n-                ebml::doc_at(self.parent.data, self.pos);\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                doc_at(self.parent.data, self.pos);\n+\n             if r_tag == (EsLabel as uint) {\n                 self.pos = r_doc.end;\n-                let str = ebml::doc_as_str(r_doc);\n+                let str = doc_as_str(r_doc);\n                 if lbl != str {\n                     fail fmt!(\"Expected label %s but found %s\", lbl, str);\n                 }\n             }\n         }\n     }\n \n-    fn next_doc(exp_tag: EbmlSerializerTag) -> ebml::Doc {\n+    fn next_doc(exp_tag: EbmlSerializerTag) -> Doc {\n         debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n         if self.pos >= self.parent.end {\n             fail ~\"no more documents in current node!\";\n         }\n-        let {tag: r_tag, doc: r_doc} =\n-            ebml::doc_at(self.parent.data, self.pos);\n+        let TaggedDoc { tag: r_tag, doc: r_doc } =\n+            doc_at(self.parent.data, self.pos);\n         debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n                copy self.parent.start, copy self.parent.end,\n                copy self.pos, r_tag, r_doc.start, r_doc.end);\n@@ -427,10 +469,10 @@ priv impl EbmlDeserializer {\n                       r_doc.end, self.parent.end);\n         }\n         self.pos = r_doc.end;\n-        return r_doc;\n+        r_doc\n     }\n \n-    fn push_doc<T>(d: ebml::Doc, f: fn() -> T) -> T{\n+    fn push_doc<T>(d: Doc, f: fn() -> T) -> T{\n         let old_parent = self.parent;\n         let old_pos = self.pos;\n         self.parent = d;\n@@ -442,63 +484,76 @@ priv impl EbmlDeserializer {\n     }\n \n     fn _next_uint(exp_tag: EbmlSerializerTag) -> uint {\n-        let r = ebml::doc_as_u32(self.next_doc(exp_tag));\n+        let r = doc_as_u32(self.next_doc(exp_tag));\n         debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n-        return r as uint;\n+        r as uint\n     }\n }\n \n-impl EbmlDeserializer {\n-    fn read_opaque<R>(op: fn(ebml::Doc) -> R) -> R {\n+impl Deserializer {\n+    fn read_opaque<R>(&self, op: fn(Doc) -> R) -> R {\n         do self.push_doc(self.next_doc(EsOpaque)) {\n             op(copy self.parent)\n         }\n     }\n }\n \n-impl EbmlDeserializer: serialization::Deserializer {\n-    fn read_nil() -> () { () }\n+impl Deserializer: serialization::Deserializer {\n+    fn read_nil(&self) -> () { () }\n \n-    fn read_u64() -> u64 { ebml::doc_as_u64(self.next_doc(EsU64)) }\n-    fn read_u32() -> u32 { ebml::doc_as_u32(self.next_doc(EsU32)) }\n-    fn read_u16() -> u16 { ebml::doc_as_u16(self.next_doc(EsU16)) }\n-    fn read_u8 () -> u8  { ebml::doc_as_u8 (self.next_doc(EsU8 )) }\n-    fn read_uint() -> uint {\n-        let v = ebml::doc_as_u64(self.next_doc(EsUint));\n+    fn read_u64(&self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n+    fn read_u32(&self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n+    fn read_u16(&self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n+    fn read_u8 (&self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n+    fn read_uint(&self) -> uint {\n+        let v = doc_as_u64(self.next_doc(EsUint));\n         if v > (core::uint::max_value as u64) {\n             fail fmt!(\"uint %? too large for this architecture\", v);\n         }\n-        return v as uint;\n+        v as uint\n     }\n \n-    fn read_i64() -> i64 { ebml::doc_as_u64(self.next_doc(EsI64)) as i64 }\n-    fn read_i32() -> i32 { ebml::doc_as_u32(self.next_doc(EsI32)) as i32 }\n-    fn read_i16() -> i16 { ebml::doc_as_u16(self.next_doc(EsI16)) as i16 }\n-    fn read_i8 () -> i8  { ebml::doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n-    fn read_int() -> int {\n-        let v = ebml::doc_as_u64(self.next_doc(EsInt)) as i64;\n+    fn read_i64(&self) -> i64 { doc_as_u64(self.next_doc(EsI64)) as i64 }\n+    fn read_i32(&self) -> i32 { doc_as_u32(self.next_doc(EsI32)) as i32 }\n+    fn read_i16(&self) -> i16 { doc_as_u16(self.next_doc(EsI16)) as i16 }\n+    fn read_i8 (&self) -> i8  { doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n+    fn read_int(&self) -> int {\n+        let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n         if v > (int::max_value as i64) || v < (int::min_value as i64) {\n             fail fmt!(\"int %? out of range for this architecture\", v);\n         }\n-        return v as int;\n+        v as int\n     }\n \n-    fn read_bool() -> bool { ebml::doc_as_u8(self.next_doc(EsBool)) as bool }\n+    fn read_bool(&self) -> bool { doc_as_u8(self.next_doc(EsBool)) as bool }\n+\n+    fn read_f64(&self) -> f64 { fail ~\"read_f64()\"; }\n+    fn read_f32(&self) -> f32 { fail ~\"read_f32()\"; }\n+    fn read_float(&self) -> float { fail ~\"read_float()\"; }\n \n-    fn read_f64() -> f64 { fail ~\"read_f64()\"; }\n-    fn read_f32() -> f32 { fail ~\"read_f32()\"; }\n-    fn read_float() -> float { fail ~\"read_float()\"; }\n+    fn read_char(&self) -> char { fail ~\"read_char()\"; }\n \n-    fn read_str() -> ~str { ebml::doc_as_str(self.next_doc(EsStr)) }\n+    fn read_owned_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n+    fn read_managed_str(&self) -> @str { fail ~\"read_managed_str()\"; }\n \n     // Compound types:\n-    fn read_enum<T>(name: &str, f: fn() -> T) -> T {\n+    fn read_owned<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_owned()\");\n+        f()\n+    }\n+\n+    fn read_managed<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_managed()\");\n+        f()\n+    }\n+\n+    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n         self._check_label(name);\n         self.push_doc(self.next_doc(EsEnum), f)\n     }\n \n-    fn read_enum_variant<T>(f: fn(uint) -> T) -> T {\n+    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n         debug!(\"read_enum_variant()\");\n         let idx = self._next_uint(EsEnumVid);\n         debug!(\"  idx=%u\", idx);\n@@ -507,118 +562,83 @@ impl EbmlDeserializer: serialization::Deserializer {\n         }\n     }\n \n-    fn read_enum_variant_arg<T>(idx: uint, f: fn() -> T) -> T {\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n         debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n         f()\n     }\n \n-    fn read_vec<T>(f: fn(uint) -> T) -> T {\n-        debug!(\"read_vec()\");\n+    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_owned_vec()\");\n         do self.push_doc(self.next_doc(EsVec)) {\n             let len = self._next_uint(EsVecLen);\n             debug!(\"  len=%u\", len);\n             f(len)\n         }\n     }\n \n-    fn read_vec_elt<T>(idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_vec_elt(idx=%u)\", idx);\n-        self.push_doc(self.next_doc(EsVecElt), f)\n+    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_managed_vec()\");\n+        do self.push_doc(self.next_doc(EsVec)) {\n+            let len = self._next_uint(EsVecLen);\n+            debug!(\"  len=%u\", len);\n+            f(len)\n+        }\n     }\n \n-    fn read_box<T>(f: fn() -> T) -> T {\n-        debug!(\"read_box()\");\n-        f()\n+    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_vec_elt(idx=%u)\", idx);\n+        self.push_doc(self.next_doc(EsVecElt), f)\n     }\n \n-    fn read_uniq<T>(f: fn() -> T) -> T {\n-        debug!(\"read_uniq()\");\n+    fn read_rec<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_rec()\");\n         f()\n     }\n \n-    fn read_rec<T>(f: fn() -> T) -> T {\n-        debug!(\"read_rec()\");\n+    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T {\n+        debug!(\"read_struct(name=%s)\", name);\n         f()\n     }\n \n-    fn read_rec_field<T>(f_name: &str, f_idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_rec_field(%s, idx=%u)\", f_name, f_idx);\n-        self._check_label(f_name);\n+    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_field(name=%s, idx=%u)\", name, idx);\n+        self._check_label(name);\n         f()\n     }\n \n-    fn read_tup<T>(sz: uint, f: fn() -> T) -> T {\n-        debug!(\"read_tup(sz=%u)\", sz);\n+    fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n+        debug!(\"read_tup(len=%u)\", len);\n         f()\n     }\n \n-    fn read_tup_elt<T>(idx: uint, f: fn() -> T) -> T {\n+    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n         debug!(\"read_tup_elt(idx=%u)\", idx);\n         f()\n     }\n }\n \n-\n // ___________________________________________________________________________\n // Testing\n \n-#[test]\n-fn test_option_int() {\n-    fn serialize_1<S: serialization::Serializer>(s: &S, v: int) {\n-        s.emit_i64(v as i64);\n-    }\n-\n-    fn serialize_0<S: serialization::Serializer>(s: &S, v: Option<int>) {\n-        do s.emit_enum(~\"core::option::t\") {\n-            match v {\n-              None => s.emit_enum_variant(\n-                  ~\"core::option::None\", 0u, 0u, || { } ),\n-              Some(v0) => {\n-                do s.emit_enum_variant(~\"core::option::some\", 1u, 1u) {\n-                    s.emit_enum_variant_arg(0u, || serialize_1(s, v0));\n-                }\n-              }\n-            }\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_option_int() {\n+        fn test_v(v: Option<int>) {\n+            debug!(\"v == %?\", v);\n+            let bytes = do io::with_bytes_writer |wr| {\n+                let ebml_w = Serializer(wr);\n+                v.serialize(&ebml_w)\n+            };\n+            let ebml_doc = Doc(@bytes);\n+            let deser = Deserializer(ebml_doc);\n+            let v1 = serialization::deserialize(&deser);\n+            debug!(\"v1 == %?\", v1);\n+            assert v == v1;\n         }\n-    }\n \n-    fn deserialize_1<S: serialization::Deserializer>(s: &S) -> int {\n-        s.read_i64() as int\n-    }\n-\n-    fn deserialize_0<S: serialization::Deserializer>(s: &S) -> Option<int> {\n-        do s.read_enum(~\"core::option::t\") {\n-            do s.read_enum_variant |i| {\n-                match i {\n-                  0 => None,\n-                  1 => {\n-                    let v0 = do s.read_enum_variant_arg(0u) {\n-                        deserialize_1(s)\n-                    };\n-                    Some(v0)\n-                  }\n-                  _ => {\n-                    fail #fmt(\"deserialize_0: unexpected variant %u\", i);\n-                  }\n-                }\n-            }\n-        }\n+        test_v(Some(22));\n+        test_v(None);\n+        test_v(Some(3));\n     }\n-\n-    fn test_v(v: Option<int>) {\n-        debug!(\"v == %?\", v);\n-        let bytes = do io::with_bytes_writer |wr| {\n-            let ebml_w = ebml::Writer(wr);\n-            serialize_0(&ebml_w, v);\n-        };\n-        let ebml_doc = ebml::Doc(@bytes);\n-        let deser = ebml_deserializer(ebml_doc);\n-        let v1 = deserialize_0(&deser);\n-        debug!(\"v1 == %?\", v1);\n-        assert v == v1;\n-    }\n-\n-    test_v(Some(22));\n-    test_v(None);\n-    test_v(Some(3));\n }"}, {"sha": "f5410233c92108e1ca9c75e0fdfba01b67253536", "filename": "src/libstd/ebml2.rs", "status": "modified", "additions": 1, "deletions": 644, "changes": 645, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Febml2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Febml2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml2.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -1,644 +1 @@\n-#[forbid(deprecated_mode)];\n-use serialization2;\n-\n-// Simple Extensible Binary Markup Language (ebml) reader and writer on a\n-// cursor model. See the specification here:\n-//     http://www.matroska.org/technical/specs/rfc/index.html\n-\n-struct EbmlTag {\n-    id: uint,\n-    size: uint,\n-}\n-\n-struct EbmlState {\n-    ebml_tag: EbmlTag,\n-    tag_pos: uint,\n-    data_pos: uint,\n-}\n-\n-// FIXME (#2739): When we have module renaming, make \"reader\" and \"writer\"\n-// separate modules within this file.\n-\n-// ebml reading\n-struct Doc {\n-    data: @~[u8],\n-    start: uint,\n-    end: uint,\n-}\n-\n-struct TaggedDoc {\n-    tag: uint,\n-    doc: Doc,\n-}\n-\n-impl Doc: ops::Index<uint,Doc> {\n-    pure fn index(tag: uint) -> Doc {\n-        unsafe {\n-            get_doc(self, tag)\n-        }\n-    }\n-}\n-\n-fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n-    let a = data[start];\n-    if a & 0x80u8 != 0u8 {\n-        return {val: (a & 0x7fu8) as uint, next: start + 1u};\n-    }\n-    if a & 0x40u8 != 0u8 {\n-        return {val: ((a & 0x3fu8) as uint) << 8u |\n-                 (data[start + 1u] as uint),\n-             next: start + 2u};\n-    } else if a & 0x20u8 != 0u8 {\n-        return {val: ((a & 0x1fu8) as uint) << 16u |\n-                 (data[start + 1u] as uint) << 8u |\n-                 (data[start + 2u] as uint),\n-             next: start + 3u};\n-    } else if a & 0x10u8 != 0u8 {\n-        return {val: ((a & 0x0fu8) as uint) << 24u |\n-                 (data[start + 1u] as uint) << 16u |\n-                 (data[start + 2u] as uint) << 8u |\n-                 (data[start + 3u] as uint),\n-             next: start + 4u};\n-    } else { error!(\"vint too big\"); fail; }\n-}\n-\n-pub fn Doc(data: @~[u8]) -> Doc {\n-    Doc { data: data, start: 0u, end: vec::len::<u8>(*data) }\n-}\n-\n-pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n-    let elt_tag = vuint_at(*data, start);\n-    let elt_size = vuint_at(*data, elt_tag.next);\n-    let end = elt_size.next + elt_size.val;\n-    TaggedDoc {\n-        tag: elt_tag.val,\n-        doc: Doc { data: data, start: elt_size.next, end: end }\n-    }\n-}\n-\n-pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n-    let mut pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vuint_at(*d.data, pos);\n-        let elt_size = vuint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        if elt_tag.val == tg {\n-            return Some(Doc { data: d.data, start: elt_size.next, end: pos });\n-        }\n-    }\n-    None\n-}\n-\n-pub fn get_doc(d: Doc, tg: uint) -> Doc {\n-    match maybe_get_doc(d, tg) {\n-      Some(d) => d,\n-      None => {\n-        error!(\"failed to find block with tag %u\", tg);\n-        fail;\n-      }\n-    }\n-}\n-\n-pub fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n-    let mut pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vuint_at(*d.data, pos);\n-        let elt_size = vuint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n-        if !it(elt_tag.val, doc) {\n-            break;\n-        }\n-    }\n-}\n-\n-pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n-    let mut pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vuint_at(*d.data, pos);\n-        let elt_size = vuint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        if elt_tag.val == tg {\n-            let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n-            if !it(doc) {\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n-pub fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n-\n-pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n-    f(vec::view(*d.data, d.start, d.end))\n-}\n-\n-pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n-\n-pub fn doc_as_u8(d: Doc) -> u8 {\n-    assert d.end == d.start + 1u;\n-    (*d.data)[d.start]\n-}\n-\n-pub fn doc_as_u16(d: Doc) -> u16 {\n-    assert d.end == d.start + 2u;\n-    io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n-}\n-\n-pub fn doc_as_u32(d: Doc) -> u32 {\n-    assert d.end == d.start + 4u;\n-    io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n-}\n-\n-pub fn doc_as_u64(d: Doc) -> u64 {\n-    assert d.end == d.start + 8u;\n-    io::u64_from_be_bytes(*d.data, d.start, 8u)\n-}\n-\n-pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n-pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n-pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n-pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n-\n-// ebml writing\n-struct Serializer {\n-    writer: io::Writer,\n-    priv mut size_positions: ~[uint],\n-}\n-\n-fn write_sized_vuint(w: io::Writer, n: uint, size: uint) {\n-    match size {\n-      1u => w.write(&[0x80u8 | (n as u8)]),\n-      2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n-      3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n-                      n as u8]),\n-      4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n-                      (n >> 8_u) as u8, n as u8]),\n-      _ => fail fmt!(\"vint to write too big: %?\", n)\n-    };\n-}\n-\n-fn write_vuint(w: io::Writer, n: uint) {\n-    if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n-    if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n-    if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n-    if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n-    fail fmt!(\"vint to write too big: %?\", n);\n-}\n-\n-pub fn Serializer(w: io::Writer) -> Serializer {\n-    let size_positions: ~[uint] = ~[];\n-    Serializer { writer: w, mut size_positions: size_positions }\n-}\n-\n-// FIXME (#2741): Provide a function to write the standard ebml header.\n-impl Serializer {\n-    fn start_tag(tag_id: uint) {\n-        debug!(\"Start tag %u\", tag_id);\n-\n-        // Write the enum ID:\n-        write_vuint(self.writer, tag_id);\n-\n-        // Write a placeholder four-byte size.\n-        self.size_positions.push(self.writer.tell());\n-        let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n-        self.writer.write(zeroes);\n-    }\n-\n-    fn end_tag() {\n-        let last_size_pos = self.size_positions.pop();\n-        let cur_pos = self.writer.tell();\n-        self.writer.seek(last_size_pos as int, io::SeekSet);\n-        let size = (cur_pos - last_size_pos - 4u);\n-        write_sized_vuint(self.writer, size, 4u);\n-        self.writer.seek(cur_pos as int, io::SeekSet);\n-\n-        debug!(\"End tag (size = %u)\", size);\n-    }\n-\n-    fn wr_tag(tag_id: uint, blk: fn()) {\n-        self.start_tag(tag_id);\n-        blk();\n-        self.end_tag();\n-    }\n-\n-    fn wr_tagged_bytes(tag_id: uint, b: &[u8]) {\n-        write_vuint(self.writer, tag_id);\n-        write_vuint(self.writer, vec::len(b));\n-        self.writer.write(b);\n-    }\n-\n-    fn wr_tagged_u64(tag_id: uint, v: u64) {\n-        do io::u64_to_be_bytes(v, 8u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_u32(tag_id: uint, v: u32) {\n-        do io::u64_to_be_bytes(v as u64, 4u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_u16(tag_id: uint, v: u16) {\n-        do io::u64_to_be_bytes(v as u64, 2u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_u8(tag_id: uint, v: u8) {\n-        self.wr_tagged_bytes(tag_id, &[v]);\n-    }\n-\n-    fn wr_tagged_i64(tag_id: uint, v: i64) {\n-        do io::u64_to_be_bytes(v as u64, 8u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_i32(tag_id: uint, v: i32) {\n-        do io::u64_to_be_bytes(v as u64, 4u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_i16(tag_id: uint, v: i16) {\n-        do io::u64_to_be_bytes(v as u64, 2u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_i8(tag_id: uint, v: i8) {\n-        self.wr_tagged_bytes(tag_id, &[v as u8]);\n-    }\n-\n-    fn wr_tagged_str(tag_id: uint, v: &str) {\n-        str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n-    }\n-\n-    fn wr_bytes(b: &[u8]) {\n-        debug!(\"Write %u bytes\", vec::len(b));\n-        self.writer.write(b);\n-    }\n-\n-    fn wr_str(s: &str) {\n-        debug!(\"Write str: %?\", s);\n-        self.writer.write(str::to_bytes(s));\n-    }\n-}\n-\n-// FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n-// efficiently encode sizes; this is a fixed point iteration\n-\n-// Set to true to generate more debugging in EBML serialization.\n-// Totally lame approach.\n-const debug: bool = false;\n-\n-enum EbmlSerializerTag {\n-    EsUint, EsU64, EsU32, EsU16, EsU8,\n-    EsInt, EsI64, EsI32, EsI16, EsI8,\n-    EsBool,\n-    EsStr,\n-    EsF64, EsF32, EsFloat,\n-    EsEnum, EsEnumVid, EsEnumBody,\n-    EsVec, EsVecLen, EsVecElt,\n-\n-    EsOpaque,\n-\n-    EsLabel // Used only when debugging\n-}\n-\n-priv impl Serializer {\n-    // used internally to emit things like the vector length and so on\n-    fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint) {\n-        assert v <= 0xFFFF_FFFF_u;\n-        self.wr_tagged_u32(t as uint, v as u32);\n-    }\n-\n-    fn _emit_label(label: &str) {\n-        // There are various strings that we have access to, such as\n-        // the name of a record field, which do not actually appear in\n-        // the serialized EBML (normally).  This is just for\n-        // efficiency.  When debugging, though, we can emit such\n-        // labels and then they will be checked by deserializer to\n-        // try and check failures more quickly.\n-        if debug { self.wr_tagged_str(EsLabel as uint, label) }\n-    }\n-}\n-\n-impl Serializer {\n-    fn emit_opaque(&self, f: fn()) {\n-        do self.wr_tag(EsOpaque as uint) {\n-            f()\n-        }\n-    }\n-}\n-\n-impl Serializer: serialization2::Serializer {\n-    fn emit_nil(&self) {}\n-\n-    fn emit_uint(&self, v: uint) {\n-        self.wr_tagged_u64(EsUint as uint, v as u64);\n-    }\n-    fn emit_u64(&self, v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n-    fn emit_u32(&self, v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n-    fn emit_u16(&self, v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n-    fn emit_u8(&self, v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n-\n-    fn emit_int(&self, v: int) {\n-        self.wr_tagged_i64(EsInt as uint, v as i64);\n-    }\n-    fn emit_i64(&self, v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n-    fn emit_i32(&self, v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n-    fn emit_i16(&self, v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n-    fn emit_i8(&self, v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n-\n-    fn emit_bool(&self, v: bool) {\n-        self.wr_tagged_u8(EsBool as uint, v as u8)\n-    }\n-\n-    // FIXME (#2742): implement these\n-    fn emit_f64(&self, _v: f64) { fail ~\"Unimplemented: serializing an f64\"; }\n-    fn emit_f32(&self, _v: f32) { fail ~\"Unimplemented: serializing an f32\"; }\n-    fn emit_float(&self, _v: float) {\n-        fail ~\"Unimplemented: serializing a float\";\n-    }\n-\n-    fn emit_char(&self, _v: char) {\n-        fail ~\"Unimplemented: serializing a char\";\n-    }\n-\n-    fn emit_borrowed_str(&self, v: &str) {\n-        self.wr_tagged_str(EsStr as uint, v)\n-    }\n-\n-    fn emit_owned_str(&self, v: &str) {\n-        self.emit_borrowed_str(v)\n-    }\n-\n-    fn emit_managed_str(&self, v: &str) {\n-        self.emit_borrowed_str(v)\n-    }\n-\n-    fn emit_borrowed(&self, f: fn()) { f() }\n-    fn emit_owned(&self, f: fn()) { f() }\n-    fn emit_managed(&self, f: fn()) { f() }\n-\n-    fn emit_enum(&self, name: &str, f: fn()) {\n-        self._emit_label(name);\n-        self.wr_tag(EsEnum as uint, f)\n-    }\n-    fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n-                         f: fn()) {\n-        self._emit_tagged_uint(EsEnumVid, v_id);\n-        self.wr_tag(EsEnumBody as uint, f)\n-    }\n-    fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) { f() }\n-\n-    fn emit_borrowed_vec(&self, len: uint, f: fn()) {\n-        do self.wr_tag(EsVec as uint) {\n-            self._emit_tagged_uint(EsVecLen, len);\n-            f()\n-        }\n-    }\n-\n-    fn emit_owned_vec(&self, len: uint, f: fn()) {\n-        self.emit_borrowed_vec(len, f)\n-    }\n-\n-    fn emit_managed_vec(&self, len: uint, f: fn()) {\n-        self.emit_borrowed_vec(len, f)\n-    }\n-\n-    fn emit_vec_elt(&self, _idx: uint, f: fn()) {\n-        self.wr_tag(EsVecElt as uint, f)\n-    }\n-\n-    fn emit_rec(&self, f: fn()) { f() }\n-    fn emit_struct(&self, _name: &str, f: fn()) { f() }\n-    fn emit_field(&self, name: &str, _idx: uint, f: fn()) {\n-        self._emit_label(name);\n-        f()\n-    }\n-\n-    fn emit_tup(&self, _len: uint, f: fn()) { f() }\n-    fn emit_tup_elt(&self, _idx: uint, f: fn()) { f() }\n-}\n-\n-struct Deserializer {\n-    priv mut parent: Doc,\n-    priv mut pos: uint,\n-}\n-\n-pub fn Deserializer(d: Doc) -> Deserializer {\n-    Deserializer { mut parent: d, mut pos: d.start }\n-}\n-\n-priv impl Deserializer {\n-    fn _check_label(lbl: &str) {\n-        if self.pos < self.parent.end {\n-            let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                doc_at(self.parent.data, self.pos);\n-\n-            if r_tag == (EsLabel as uint) {\n-                self.pos = r_doc.end;\n-                let str = doc_as_str(r_doc);\n-                if lbl != str {\n-                    fail fmt!(\"Expected label %s but found %s\", lbl, str);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn next_doc(exp_tag: EbmlSerializerTag) -> Doc {\n-        debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n-        if self.pos >= self.parent.end {\n-            fail ~\"no more documents in current node!\";\n-        }\n-        let TaggedDoc { tag: r_tag, doc: r_doc } =\n-            doc_at(self.parent.data, self.pos);\n-        debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n-               copy self.parent.start, copy self.parent.end,\n-               copy self.pos, r_tag, r_doc.start, r_doc.end);\n-        if r_tag != (exp_tag as uint) {\n-            fail fmt!(\"expected EMBL doc with tag %? but found tag %?\",\n-                      exp_tag, r_tag);\n-        }\n-        if r_doc.end > self.parent.end {\n-            fail fmt!(\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n-                      r_doc.end, self.parent.end);\n-        }\n-        self.pos = r_doc.end;\n-        r_doc\n-    }\n-\n-    fn push_doc<T>(d: Doc, f: fn() -> T) -> T{\n-        let old_parent = self.parent;\n-        let old_pos = self.pos;\n-        self.parent = d;\n-        self.pos = d.start;\n-        let r = f();\n-        self.parent = old_parent;\n-        self.pos = old_pos;\n-        move r\n-    }\n-\n-    fn _next_uint(exp_tag: EbmlSerializerTag) -> uint {\n-        let r = doc_as_u32(self.next_doc(exp_tag));\n-        debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n-        r as uint\n-    }\n-}\n-\n-impl Deserializer {\n-    fn read_opaque<R>(&self, op: fn(Doc) -> R) -> R {\n-        do self.push_doc(self.next_doc(EsOpaque)) {\n-            op(copy self.parent)\n-        }\n-    }\n-}\n-\n-impl Deserializer: serialization2::Deserializer {\n-    fn read_nil(&self) -> () { () }\n-\n-    fn read_u64(&self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n-    fn read_u32(&self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n-    fn read_u16(&self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n-    fn read_u8 (&self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n-    fn read_uint(&self) -> uint {\n-        let v = doc_as_u64(self.next_doc(EsUint));\n-        if v > (core::uint::max_value as u64) {\n-            fail fmt!(\"uint %? too large for this architecture\", v);\n-        }\n-        v as uint\n-    }\n-\n-    fn read_i64(&self) -> i64 { doc_as_u64(self.next_doc(EsI64)) as i64 }\n-    fn read_i32(&self) -> i32 { doc_as_u32(self.next_doc(EsI32)) as i32 }\n-    fn read_i16(&self) -> i16 { doc_as_u16(self.next_doc(EsI16)) as i16 }\n-    fn read_i8 (&self) -> i8  { doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n-    fn read_int(&self) -> int {\n-        let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n-        if v > (int::max_value as i64) || v < (int::min_value as i64) {\n-            fail fmt!(\"int %? out of range for this architecture\", v);\n-        }\n-        v as int\n-    }\n-\n-    fn read_bool(&self) -> bool { doc_as_u8(self.next_doc(EsBool)) as bool }\n-\n-    fn read_f64(&self) -> f64 { fail ~\"read_f64()\"; }\n-    fn read_f32(&self) -> f32 { fail ~\"read_f32()\"; }\n-    fn read_float(&self) -> float { fail ~\"read_float()\"; }\n-\n-    fn read_char(&self) -> char { fail ~\"read_char()\"; }\n-\n-    fn read_owned_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n-    fn read_managed_str(&self) -> @str { fail ~\"read_managed_str()\"; }\n-\n-    // Compound types:\n-    fn read_owned<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_owned()\");\n-        f()\n-    }\n-\n-    fn read_managed<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_managed()\");\n-        f()\n-    }\n-\n-    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n-        debug!(\"read_enum(%s)\", name);\n-        self._check_label(name);\n-        self.push_doc(self.next_doc(EsEnum), f)\n-    }\n-\n-    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n-        debug!(\"read_enum_variant()\");\n-        let idx = self._next_uint(EsEnumVid);\n-        debug!(\"  idx=%u\", idx);\n-        do self.push_doc(self.next_doc(EsEnumBody)) {\n-            f(idx)\n-        }\n-    }\n-\n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n-        f()\n-    }\n-\n-    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n-        debug!(\"read_owned_vec()\");\n-        do self.push_doc(self.next_doc(EsVec)) {\n-            let len = self._next_uint(EsVecLen);\n-            debug!(\"  len=%u\", len);\n-            f(len)\n-        }\n-    }\n-\n-    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n-        debug!(\"read_managed_vec()\");\n-        do self.push_doc(self.next_doc(EsVec)) {\n-            let len = self._next_uint(EsVecLen);\n-            debug!(\"  len=%u\", len);\n-            f(len)\n-        }\n-    }\n-\n-    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_vec_elt(idx=%u)\", idx);\n-        self.push_doc(self.next_doc(EsVecElt), f)\n-    }\n-\n-    fn read_rec<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_rec()\");\n-        f()\n-    }\n-\n-    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T {\n-        debug!(\"read_struct(name=%s)\", name);\n-        f()\n-    }\n-\n-    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_field(name=%s, idx=%u)\", name, idx);\n-        self._check_label(name);\n-        f()\n-    }\n-\n-    fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n-        debug!(\"read_tup(len=%u)\", len);\n-        f()\n-    }\n-\n-    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_tup_elt(idx=%u)\", idx);\n-        f()\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Testing\n-\n-#[cfg(test)]\n-mod tests {\n-    #[test]\n-    fn test_option_int() {\n-        fn test_v(v: Option<int>) {\n-            debug!(\"v == %?\", v);\n-            let bytes = do io::with_bytes_writer |wr| {\n-                let ebml_w = Serializer(wr);\n-                v.serialize(&ebml_w)\n-            };\n-            let ebml_doc = Doc(@bytes);\n-            let deser = Deserializer(ebml_doc);\n-            let v1 = serialization2::deserialize(&deser);\n-            debug!(\"v1 == %?\", v1);\n-            assert v == v1;\n-        }\n-\n-        test_v(Some(22));\n-        test_v(None);\n-        test_v(Some(3));\n-    }\n-}\n+pub use ebml::*;"}, {"sha": "fa7c0286dc1e57cecaf4f42825806b0b9fbf8e37", "filename": "src/libstd/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -63,7 +63,7 @@ pub fn Serializer(wr: io::Writer) -> Serializer {\n     Serializer { wr: wr }\n }\n \n-pub impl Serializer: serialization2::Serializer {\n+pub impl Serializer: serialization::Serializer {\n     fn emit_nil(&self) { self.wr.write_str(\"null\") }\n \n     fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n@@ -167,7 +167,7 @@ pub fn PrettySerializer(wr: io::Writer) -> PrettySerializer {\n     PrettySerializer { wr: wr, indent: 0 }\n }\n \n-pub impl PrettySerializer: serialization2::Serializer {\n+pub impl PrettySerializer: serialization::Serializer {\n     fn emit_nil(&self) { self.wr.write_str(\"null\") }\n \n     fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n@@ -273,8 +273,8 @@ pub impl PrettySerializer: serialization2::Serializer {\n     }\n }\n \n-pub impl Json: serialization2::Serializable {\n-    fn serialize<S: serialization2::Serializer>(&self, s: &S) {\n+pub impl Json: serialization::Serializable {\n+    fn serialize<S: serialization::Serializer>(&self, s: &S) {\n         match *self {\n             Number(v) => v.serialize(s),\n             String(ref v) => v.serialize(s),\n@@ -721,7 +721,7 @@ priv impl Deserializer {\n     }\n }\n \n-pub impl Deserializer: serialization2::Deserializer {\n+pub impl Deserializer: serialization::Deserializer {\n     fn read_nil(&self) -> () {\n         debug!(\"read_nil\");\n         match *self.pop() {"}, {"sha": "6119c03cdcaf0dd4c30f44d1018feea7e4e58732", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 106, "deletions": 62, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -2,131 +2,175 @@\n \n use io::Writer;\n use io::WriterUtil;\n-use serialization::Serializer;\n+use serialization;\n \n-impl Writer: Serializer {\n-    fn emit_nil() {\n-        self.write_str(~\"()\")\n+pub struct Serializer {\n+    wr: io::Writer,\n+}\n+\n+pub fn Serializer(wr: io::Writer) -> Serializer {\n+    Serializer { wr: wr }\n+}\n+\n+pub impl Serializer: serialization::Serializer {\n+    fn emit_nil(&self) {\n+        self.wr.write_str(~\"()\")\n+    }\n+\n+    fn emit_uint(&self, v: uint) {\n+        self.wr.write_str(fmt!(\"%?u\", v));\n+    }\n+\n+    fn emit_u64(&self, v: u64) {\n+        self.wr.write_str(fmt!(\"%?_u64\", v));\n+    }\n+\n+    fn emit_u32(&self, v: u32) {\n+        self.wr.write_str(fmt!(\"%?_u32\", v));\n+    }\n+\n+    fn emit_u16(&self, v: u16) {\n+        self.wr.write_str(fmt!(\"%?_u16\", v));\n+    }\n+\n+    fn emit_u8(&self, v: u8) {\n+        self.wr.write_str(fmt!(\"%?_u8\", v));\n     }\n \n-    fn emit_uint(v: uint) {\n-        self.write_str(fmt!(\"%?u\", v));\n+    fn emit_int(&self, v: int) {\n+        self.wr.write_str(fmt!(\"%?\", v));\n     }\n \n-    fn emit_u64(v: u64) {\n-        self.write_str(fmt!(\"%?_u64\", v));\n+    fn emit_i64(&self, v: i64) {\n+        self.wr.write_str(fmt!(\"%?_i64\", v));\n     }\n \n-    fn emit_u32(v: u32) {\n-        self.write_str(fmt!(\"%?_u32\", v));\n+    fn emit_i32(&self, v: i32) {\n+        self.wr.write_str(fmt!(\"%?_i32\", v));\n     }\n \n-    fn emit_u16(v: u16) {\n-        self.write_str(fmt!(\"%?_u16\", v));\n+    fn emit_i16(&self, v: i16) {\n+        self.wr.write_str(fmt!(\"%?_i16\", v));\n     }\n \n-    fn emit_u8(v: u8) {\n-        self.write_str(fmt!(\"%?_u8\", v));\n+    fn emit_i8(&self, v: i8) {\n+        self.wr.write_str(fmt!(\"%?_i8\", v));\n     }\n \n-    fn emit_int(v: int) {\n-        self.write_str(fmt!(\"%?\", v));\n+    fn emit_bool(&self, v: bool) {\n+        self.wr.write_str(fmt!(\"%b\", v));\n     }\n \n-    fn emit_i64(v: i64) {\n-        self.write_str(fmt!(\"%?_i64\", v));\n+    fn emit_float(&self, v: float) {\n+        self.wr.write_str(fmt!(\"%?_f\", v));\n     }\n \n-    fn emit_i32(v: i32) {\n-        self.write_str(fmt!(\"%?_i32\", v));\n+    fn emit_f64(&self, v: f64) {\n+        self.wr.write_str(fmt!(\"%?_f64\", v));\n     }\n \n-    fn emit_i16(v: i16) {\n-        self.write_str(fmt!(\"%?_i16\", v));\n+    fn emit_f32(&self, v: f32) {\n+        self.wr.write_str(fmt!(\"%?_f32\", v));\n     }\n \n-    fn emit_i8(v: i8) {\n-        self.write_str(fmt!(\"%?_i8\", v));\n+    fn emit_char(&self, v: char) {\n+        self.wr.write_str(fmt!(\"%?\", v));\n     }\n \n-    fn emit_bool(v: bool) {\n-        self.write_str(fmt!(\"%b\", v));\n+    fn emit_borrowed_str(&self, v: &str) {\n+        self.wr.write_str(fmt!(\"&%?\", v));\n     }\n \n-    fn emit_float(v: float) {\n-        self.write_str(fmt!(\"%?_f\", v));\n+    fn emit_owned_str(&self, v: &str) {\n+        self.wr.write_str(fmt!(\"~%?\", v));\n     }\n \n-    fn emit_f64(v: f64) {\n-        self.write_str(fmt!(\"%?_f64\", v));\n+    fn emit_managed_str(&self, v: &str) {\n+        self.wr.write_str(fmt!(\"@%?\", v));\n     }\n \n-    fn emit_f32(v: f32) {\n-        self.write_str(fmt!(\"%?_f32\", v));\n+    fn emit_borrowed(&self, f: fn()) {\n+        self.wr.write_str(~\"&\");\n+        f();\n     }\n \n-    fn emit_str(v: &str) {\n-        self.write_str(fmt!(\"%?\", v));\n+    fn emit_owned(&self, f: fn()) {\n+        self.wr.write_str(~\"~\");\n+        f();\n+    }\n+\n+    fn emit_managed(&self, f: fn()) {\n+        self.wr.write_str(~\"@\");\n+        f();\n+    }\n+\n+    fn emit_enum(&self, _name: &str, f: fn()) {\n+        f();\n     }\n \n-    fn emit_enum(_name: &str, f: fn()) {\n+    fn emit_enum_variant(&self, v_name: &str, _v_id: uint, sz: uint,\n+                         f: fn()) {\n+        self.wr.write_str(v_name);\n+        if sz > 0u { self.wr.write_str(~\"(\"); }\n         f();\n+        if sz > 0u { self.wr.write_str(~\")\"); }\n     }\n \n-    fn emit_enum_variant(v_name: &str, _v_id: uint, sz: uint, f: fn()) {\n-        self.write_str(v_name);\n-        if sz > 0u { self.write_str(~\"(\"); }\n+    fn emit_enum_variant_arg(&self, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n-        if sz > 0u { self.write_str(~\")\"); }\n     }\n \n-    fn emit_enum_variant_arg(idx: uint, f: fn()) {\n-        if idx > 0u { self.write_str(~\", \"); }\n+    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"&[\");\n         f();\n+        self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_vec(_len: uint, f: fn()) {\n-        self.write_str(~\"[\");\n+    fn emit_owned_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"~[\");\n         f();\n-        self.write_str(~\"]\");\n+        self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_vec_elt(idx: uint, f: fn()) {\n-        if idx > 0u { self.write_str(~\", \"); }\n+    fn emit_managed_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"@[\");\n         f();\n+        self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_box(f: fn()) {\n-        self.write_str(~\"@\");\n+    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }\n \n-    fn emit_uniq(f: fn()) {\n-        self.write_str(~\"~\");\n+    fn emit_rec(&self, f: fn()) {\n+        self.wr.write_str(~\"{\");\n         f();\n+        self.wr.write_str(~\"}\");\n     }\n \n-    fn emit_rec(f: fn()) {\n-        self.write_str(~\"{\");\n+    fn emit_struct(&self, name: &str, f: fn()) {\n+        self.wr.write_str(fmt!(\"%s {\", name));\n         f();\n-        self.write_str(~\"}\");\n+        self.wr.write_str(~\"}\");\n     }\n \n-    fn emit_rec_field(f_name: &str, f_idx: uint, f: fn()) {\n-        if f_idx > 0u { self.write_str(~\", \"); }\n-        self.write_str(f_name);\n-        self.write_str(~\": \");\n+    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n+        self.wr.write_str(name);\n+        self.wr.write_str(~\": \");\n         f();\n     }\n \n-    fn emit_tup(_sz: uint, f: fn()) {\n-        self.write_str(~\"(\");\n+    fn emit_tup(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"(\");\n         f();\n-        self.write_str(~\")\");\n+        self.wr.write_str(~\")\");\n     }\n \n-    fn emit_tup_elt(idx: uint, f: fn()) {\n-        if idx > 0u { self.write_str(~\", \"); }\n+    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }\n }"}, {"sha": "a3bf40ecf72f200dca4cf9de7696b30502c4fa03", "filename": "src/libstd/prettyprint2.rs", "status": "modified", "additions": 1, "deletions": 176, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Fprettyprint2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Fprettyprint2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint2.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -1,176 +1 @@\n-#[forbid(deprecated_mode)];\n-\n-use io::Writer;\n-use io::WriterUtil;\n-use serialization2;\n-\n-pub struct Serializer {\n-    wr: io::Writer,\n-}\n-\n-pub fn Serializer(wr: io::Writer) -> Serializer {\n-    Serializer { wr: wr }\n-}\n-\n-pub impl Serializer: serialization2::Serializer {\n-    fn emit_nil(&self) {\n-        self.wr.write_str(~\"()\")\n-    }\n-\n-    fn emit_uint(&self, v: uint) {\n-        self.wr.write_str(fmt!(\"%?u\", v));\n-    }\n-\n-    fn emit_u64(&self, v: u64) {\n-        self.wr.write_str(fmt!(\"%?_u64\", v));\n-    }\n-\n-    fn emit_u32(&self, v: u32) {\n-        self.wr.write_str(fmt!(\"%?_u32\", v));\n-    }\n-\n-    fn emit_u16(&self, v: u16) {\n-        self.wr.write_str(fmt!(\"%?_u16\", v));\n-    }\n-\n-    fn emit_u8(&self, v: u8) {\n-        self.wr.write_str(fmt!(\"%?_u8\", v));\n-    }\n-\n-    fn emit_int(&self, v: int) {\n-        self.wr.write_str(fmt!(\"%?\", v));\n-    }\n-\n-    fn emit_i64(&self, v: i64) {\n-        self.wr.write_str(fmt!(\"%?_i64\", v));\n-    }\n-\n-    fn emit_i32(&self, v: i32) {\n-        self.wr.write_str(fmt!(\"%?_i32\", v));\n-    }\n-\n-    fn emit_i16(&self, v: i16) {\n-        self.wr.write_str(fmt!(\"%?_i16\", v));\n-    }\n-\n-    fn emit_i8(&self, v: i8) {\n-        self.wr.write_str(fmt!(\"%?_i8\", v));\n-    }\n-\n-    fn emit_bool(&self, v: bool) {\n-        self.wr.write_str(fmt!(\"%b\", v));\n-    }\n-\n-    fn emit_float(&self, v: float) {\n-        self.wr.write_str(fmt!(\"%?_f\", v));\n-    }\n-\n-    fn emit_f64(&self, v: f64) {\n-        self.wr.write_str(fmt!(\"%?_f64\", v));\n-    }\n-\n-    fn emit_f32(&self, v: f32) {\n-        self.wr.write_str(fmt!(\"%?_f32\", v));\n-    }\n-\n-    fn emit_char(&self, v: char) {\n-        self.wr.write_str(fmt!(\"%?\", v));\n-    }\n-\n-    fn emit_borrowed_str(&self, v: &str) {\n-        self.wr.write_str(fmt!(\"&%?\", v));\n-    }\n-\n-    fn emit_owned_str(&self, v: &str) {\n-        self.wr.write_str(fmt!(\"~%?\", v));\n-    }\n-\n-    fn emit_managed_str(&self, v: &str) {\n-        self.wr.write_str(fmt!(\"@%?\", v));\n-    }\n-\n-    fn emit_borrowed(&self, f: fn()) {\n-        self.wr.write_str(~\"&\");\n-        f();\n-    }\n-\n-    fn emit_owned(&self, f: fn()) {\n-        self.wr.write_str(~\"~\");\n-        f();\n-    }\n-\n-    fn emit_managed(&self, f: fn()) {\n-        self.wr.write_str(~\"@\");\n-        f();\n-    }\n-\n-    fn emit_enum(&self, _name: &str, f: fn()) {\n-        f();\n-    }\n-\n-    fn emit_enum_variant(&self, v_name: &str, _v_id: uint, sz: uint,\n-                         f: fn()) {\n-        self.wr.write_str(v_name);\n-        if sz > 0u { self.wr.write_str(~\"(\"); }\n-        f();\n-        if sz > 0u { self.wr.write_str(~\")\"); }\n-    }\n-\n-    fn emit_enum_variant_arg(&self, idx: uint, f: fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        f();\n-    }\n-\n-    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n-        self.wr.write_str(~\"&[\");\n-        f();\n-        self.wr.write_str(~\"]\");\n-    }\n-\n-    fn emit_owned_vec(&self, _len: uint, f: fn()) {\n-        self.wr.write_str(~\"~[\");\n-        f();\n-        self.wr.write_str(~\"]\");\n-    }\n-\n-    fn emit_managed_vec(&self, _len: uint, f: fn()) {\n-        self.wr.write_str(~\"@[\");\n-        f();\n-        self.wr.write_str(~\"]\");\n-    }\n-\n-    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        f();\n-    }\n-\n-    fn emit_rec(&self, f: fn()) {\n-        self.wr.write_str(~\"{\");\n-        f();\n-        self.wr.write_str(~\"}\");\n-    }\n-\n-    fn emit_struct(&self, name: &str, f: fn()) {\n-        self.wr.write_str(fmt!(\"%s {\", name));\n-        f();\n-        self.wr.write_str(~\"}\");\n-    }\n-\n-    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        self.wr.write_str(name);\n-        self.wr.write_str(~\": \");\n-        f();\n-    }\n-\n-    fn emit_tup(&self, _len: uint, f: fn()) {\n-        self.wr.write_str(~\"(\");\n-        f();\n-        self.wr.write_str(~\")\");\n-    }\n-\n-    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        f();\n-    }\n-}\n+pub use prettyprint::*;"}, {"sha": "5173ef163a22aef06ea3fd6787bea0dbcaa8efa9", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 453, "deletions": 161, "changes": 614, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -1,270 +1,562 @@\n //! Support code for serialization.\n \n-#[allow(deprecated_mode)];\n-\n /*\n Core serialization interfaces.\n */\n \n+#[forbid(deprecated_mode)];\n+#[forbid(non_camel_case_types)];\n+\n pub trait Serializer {\n     // Primitive types:\n-    fn emit_nil();\n-    fn emit_uint(v: uint);\n-    fn emit_u64(v: u64);\n-    fn emit_u32(v: u32);\n-    fn emit_u16(v: u16);\n-    fn emit_u8(v: u8);\n-    fn emit_int(v: int);\n-    fn emit_i64(v: i64);\n-    fn emit_i32(v: i32);\n-    fn emit_i16(v: i16);\n-    fn emit_i8(v: i8);\n-    fn emit_bool(v: bool);\n-    fn emit_float(v: float);\n-    fn emit_f64(v: f64);\n-    fn emit_f32(v: f32);\n-    fn emit_str(v: &str);\n+    fn emit_nil(&self);\n+    fn emit_uint(&self, v: uint);\n+    fn emit_u64(&self, v: u64);\n+    fn emit_u32(&self, v: u32);\n+    fn emit_u16(&self, v: u16);\n+    fn emit_u8(&self, v: u8);\n+    fn emit_int(&self, v: int);\n+    fn emit_i64(&self, v: i64);\n+    fn emit_i32(&self, v: i32);\n+    fn emit_i16(&self, v: i16);\n+    fn emit_i8(&self, v: i8);\n+    fn emit_bool(&self, v: bool);\n+    fn emit_float(&self, v: float);\n+    fn emit_f64(&self, v: f64);\n+    fn emit_f32(&self, v: f32);\n+    fn emit_char(&self, v: char);\n+    fn emit_borrowed_str(&self, v: &str);\n+    fn emit_owned_str(&self, v: &str);\n+    fn emit_managed_str(&self, v: &str);\n \n     // Compound types:\n-    fn emit_enum(name: &str, f: fn());\n-    fn emit_enum_variant(v_name: &str, v_id: uint, sz: uint, f: fn());\n-    fn emit_enum_variant_arg(idx: uint, f: fn());\n-    fn emit_vec(len: uint, f: fn());\n-    fn emit_vec_elt(idx: uint, f: fn());\n-    fn emit_box(f: fn());\n-    fn emit_uniq(f: fn());\n-    fn emit_rec(f: fn());\n-    fn emit_rec_field(f_name: &str, f_idx: uint, f: fn());\n-    fn emit_tup(sz: uint, f: fn());\n-    fn emit_tup_elt(idx: uint, f: fn());\n+    fn emit_borrowed(&self, f: fn());\n+    fn emit_owned(&self, f: fn());\n+    fn emit_managed(&self, f: fn());\n+\n+    fn emit_enum(&self, name: &str, f: fn());\n+    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: fn());\n+    fn emit_enum_variant_arg(&self, idx: uint, f: fn());\n+\n+    fn emit_borrowed_vec(&self, len: uint, f: fn());\n+    fn emit_owned_vec(&self, len: uint, f: fn());\n+    fn emit_managed_vec(&self, len: uint, f: fn());\n+    fn emit_vec_elt(&self, idx: uint, f: fn());\n+\n+    fn emit_rec(&self, f: fn());\n+    fn emit_struct(&self, name: &str, f: fn());\n+    fn emit_field(&self, f_name: &str, f_idx: uint, f: fn());\n+\n+    fn emit_tup(&self, len: uint, f: fn());\n+    fn emit_tup_elt(&self, idx: uint, f: fn());\n }\n \n pub trait Deserializer {\n     // Primitive types:\n-    fn read_nil() -> ();\n+    fn read_nil(&self) -> ();\n+    fn read_uint(&self) -> uint;\n+    fn read_u64(&self) -> u64;\n+    fn read_u32(&self) -> u32;\n+    fn read_u16(&self) -> u16;\n+    fn read_u8(&self) -> u8;\n+    fn read_int(&self) -> int;\n+    fn read_i64(&self) -> i64;\n+    fn read_i32(&self) -> i32;\n+    fn read_i16(&self) -> i16;\n+    fn read_i8(&self) -> i8;\n+    fn read_bool(&self) -> bool;\n+    fn read_f64(&self) -> f64;\n+    fn read_f32(&self) -> f32;\n+    fn read_float(&self) -> float;\n+    fn read_char(&self) -> char;\n+    fn read_owned_str(&self) -> ~str;\n+    fn read_managed_str(&self) -> @str;\n \n-    fn read_uint() -> uint;\n-    fn read_u64() -> u64;\n-    fn read_u32() -> u32;\n-    fn read_u16() -> u16;\n-    fn read_u8() -> u8;\n+    // Compound types:\n+    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T;\n+    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T;\n \n-    fn read_int() -> int;\n-    fn read_i64() -> i64;\n-    fn read_i32() -> i32;\n-    fn read_i16() -> i16;\n-    fn read_i8() -> i8;\n+    fn read_owned<T>(&self, f: fn() -> T) -> T;\n+    fn read_managed<T>(&self, f: fn() -> T) -> T;\n \n+    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n \n-    fn read_bool() -> bool;\n+    fn read_rec<T>(&self, f: fn() -> T) -> T;\n+    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T;\n+    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T;\n \n-    fn read_str() -> ~str;\n+    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T;\n+    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n+}\n \n-    fn read_f64() -> f64;\n-    fn read_f32() -> f32;\n-    fn read_float() -> float;\n+pub trait Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S);\n+}\n \n-    // Compound types:\n-    fn read_enum<T>(name: &str, f: fn() -> T) -> T;\n-    fn read_enum_variant<T>(f: fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T>(idx: uint, f: fn() -> T) -> T;\n-    fn read_vec<T>(f: fn(uint) -> T) -> T;\n-    fn read_vec_elt<T>(idx: uint, f: fn() -> T) -> T;\n-    fn read_box<T>(f: fn() -> T) -> T;\n-    fn read_uniq<T>(f: fn() -> T) -> T;\n-    fn read_rec<T>(f: fn() -> T) -> T;\n-    fn read_rec_field<T>(f_name: &str, f_idx: uint, f: fn() -> T) -> T;\n-    fn read_tup<T>(sz: uint, f: fn() -> T) -> T;\n-    fn read_tup_elt<T>(idx: uint, f: fn() -> T) -> T;\n+pub trait Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> self;\n }\n \n-// ___________________________________________________________________________\n-// Helper routines\n-//\n-// In some cases, these should eventually be coded as traits.\n+pub impl uint: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_uint(*self) }\n+}\n \n-pub fn emit_from_vec<S: Serializer, T>(&&s: S, &&v: ~[T], f: fn(&&x: T)) {\n-    do s.emit_vec(vec::len(v)) {\n-        for vec::eachi(v) |i,e| {\n-            do s.emit_vec_elt(i) {\n-                f(*e)\n-            }\n-        }\n+pub impl uint: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> uint {\n+        d.read_uint()\n     }\n }\n \n-pub fn read_to_vec<D: Deserializer, T: Copy>(&&d: D, f: fn() -> T) -> ~[T] {\n-    do d.read_vec |len| {\n-        do vec::from_fn(len) |i| {\n-            d.read_vec_elt(i, || f())\n-        }\n+pub impl u8: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u8(*self) }\n+}\n+\n+pub impl u8: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u8 {\n+        d.read_u8()\n     }\n }\n \n-pub trait SerializerHelpers {\n-    fn emit_from_vec<T>(&&v: ~[T], f: fn(&&x: T));\n+pub impl u16: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u16(*self) }\n }\n \n-impl<S: Serializer> S: SerializerHelpers {\n-    fn emit_from_vec<T>(&&v: ~[T], f: fn(&&x: T)) {\n-        emit_from_vec(self, v, f)\n+pub impl u16: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u16 {\n+        d.read_u16()\n     }\n }\n \n-pub trait DeserializerHelpers {\n-    fn read_to_vec<T: Copy>(f: fn() -> T) -> ~[T];\n+pub impl u32: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u32(*self) }\n }\n \n-impl<D: Deserializer> D: DeserializerHelpers {\n-    fn read_to_vec<T: Copy>(f: fn() -> T) -> ~[T] {\n-        read_to_vec(self, f)\n+pub impl u32: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u32 {\n+        d.read_u32()\n     }\n }\n \n-pub fn serialize_uint<S: Serializer>(&&s: S, v: uint) {\n-    s.emit_uint(v);\n+pub impl u64: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u64(*self) }\n }\n \n-pub fn deserialize_uint<D: Deserializer>(&&d: D) -> uint {\n-    d.read_uint()\n+pub impl u64: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u64 {\n+        d.read_u64()\n+    }\n }\n \n-pub fn serialize_u8<S: Serializer>(&&s: S, v: u8) {\n-    s.emit_u8(v);\n+pub impl int: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_int(*self) }\n }\n \n-pub fn deserialize_u8<D: Deserializer>(&&d: D) -> u8 {\n-    d.read_u8()\n+pub impl int: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> int {\n+        d.read_int()\n+    }\n }\n \n-pub fn serialize_u16<S: Serializer>(&&s: S, v: u16) {\n-    s.emit_u16(v);\n+pub impl i8: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i8(*self) }\n }\n \n-pub fn deserialize_u16<D: Deserializer>(&&d: D) -> u16 {\n-    d.read_u16()\n+pub impl i8: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i8 {\n+        d.read_i8()\n+    }\n }\n \n-pub fn serialize_u32<S: Serializer>(&&s: S, v: u32) {\n-    s.emit_u32(v);\n+pub impl i16: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i16(*self) }\n }\n \n-pub fn deserialize_u32<D: Deserializer>(&&d: D) -> u32 {\n-    d.read_u32()\n+pub impl i16: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i16 {\n+        d.read_i16()\n+    }\n }\n \n-pub fn serialize_u64<S: Serializer>(&&s: S, v: u64) {\n-    s.emit_u64(v);\n+pub impl i32: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i32(*self) }\n }\n \n-pub fn deserialize_u64<D: Deserializer>(&&d: D) -> u64 {\n-    d.read_u64()\n+pub impl i32: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i32 {\n+        d.read_i32()\n+    }\n }\n \n-pub fn serialize_int<S: Serializer>(&&s: S, v: int) {\n-    s.emit_int(v);\n+pub impl i64: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i64(*self) }\n }\n \n-pub fn deserialize_int<D: Deserializer>(&&d: D) -> int {\n-    d.read_int()\n+pub impl i64: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i64 {\n+        d.read_i64()\n+    }\n }\n \n-pub fn serialize_i8<S: Serializer>(&&s: S, v: i8) {\n-    s.emit_i8(v);\n+pub impl &str: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_borrowed_str(*self) }\n }\n \n-pub fn deserialize_i8<D: Deserializer>(&&d: D) -> i8 {\n-    d.read_i8()\n+pub impl ~str: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_owned_str(*self) }\n }\n \n-pub fn serialize_i16<S: Serializer>(&&s: S, v: i16) {\n-    s.emit_i16(v);\n+pub impl ~str: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~str {\n+        d.read_owned_str()\n+    }\n }\n \n-pub fn deserialize_i16<D: Deserializer>(&&d: D) -> i16 {\n-    d.read_i16()\n+pub impl @str: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_managed_str(*self) }\n }\n \n-pub fn serialize_i32<S: Serializer>(&&s: S, v: i32) {\n-    s.emit_i32(v);\n+pub impl @str: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> @str {\n+        d.read_managed_str()\n+    }\n }\n \n-pub fn deserialize_i32<D: Deserializer>(&&d: D) -> i32 {\n-    d.read_i32()\n+pub impl float: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_float(*self) }\n }\n \n-pub fn serialize_i64<S: Serializer>(&&s: S, v: i64) {\n-    s.emit_i64(v);\n+pub impl float: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> float {\n+        d.read_float()\n+    }\n }\n \n-pub fn deserialize_i64<D: Deserializer>(&&d: D) -> i64 {\n-    d.read_i64()\n+pub impl f32: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f32(*self) }\n }\n \n-pub fn serialize_str<S: Serializer>(&&s: S, v: &str) {\n-    s.emit_str(v);\n+pub impl f32: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> f32 {\n+        d.read_f32() }\n }\n \n-pub fn deserialize_str<D: Deserializer>(&&d: D) -> ~str {\n-    d.read_str()\n+pub impl f64: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f64(*self) }\n }\n \n-pub fn serialize_float<S: Serializer>(&&s: S, v: float) {\n-    s.emit_float(v);\n+pub impl f64: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> f64 {\n+        d.read_f64()\n+    }\n }\n \n-pub fn deserialize_float<D: Deserializer>(&&d: D) -> float {\n-    d.read_float()\n+pub impl bool: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_bool(*self) }\n }\n \n-pub fn serialize_f32<S: Serializer>(&&s: S, v: f32) {\n-    s.emit_f32(v);\n+pub impl bool: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> bool {\n+        d.read_bool()\n+    }\n+}\n+\n+pub impl (): Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_nil() }\n+}\n+\n+pub impl (): Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> () {\n+        d.read_nil()\n+    }\n }\n \n-pub fn deserialize_f32<D: Deserializer>(&&d: D) -> f32 {\n-    d.read_f32()\n+pub impl<T: Serializable> &T: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        s.emit_borrowed(|| (**self).serialize(s))\n+    }\n }\n \n-pub fn serialize_f64<S: Serializer>(&&s: S, v: f64) {\n-    s.emit_f64(v);\n+pub impl<T: Serializable> ~T: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        s.emit_owned(|| (**self).serialize(s))\n+    }\n }\n \n-pub fn deserialize_f64<D: Deserializer>(&&d: D) -> f64 {\n-    d.read_f64()\n+pub impl<T: Deserializable> ~T: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~T {\n+        d.read_owned(|| ~deserialize(d))\n+    }\n }\n \n-pub fn serialize_bool<S: Serializer>(&&s: S, v: bool) {\n-    s.emit_bool(v);\n+pub impl<T: Serializable> @T: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        s.emit_managed(|| (**self).serialize(s))\n+    }\n }\n \n-pub fn deserialize_bool<D: Deserializer>(&&d: D) -> bool {\n-    d.read_bool()\n+pub impl<T: Deserializable> @T: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> @T {\n+        d.read_managed(|| @deserialize(d))\n+    }\n }\n \n-pub fn serialize_Option<S: Serializer,T>(&&s: S, &&v: Option<T>,\n-                                         st: fn(&&x: T)) {\n-    do s.emit_enum(~\"option\") {\n-        match v {\n-          None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n-          },\n+pub impl<T: Serializable> &[T]: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        do s.emit_borrowed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n \n-          Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n-            do s.emit_enum_variant_arg(0u) {\n-                st(*v)\n+pub impl<T: Serializable> ~[T]: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        do s.emit_owned_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n             }\n-          }\n         }\n     }\n }\n \n-pub fn deserialize_Option<D: Deserializer,T: Copy>(&&d: D, st: fn() -> T)\n-    -> Option<T> {\n-    do d.read_enum(~\"option\") {\n-        do d.read_enum_variant |i| {\n-            match i {\n-              0 => None,\n-              1 => Some(d.read_enum_variant_arg(0u, || st() )),\n-              _ => fail(#fmt(\"Bad variant for option: %u\", i))\n+pub impl<T: Deserializable> ~[T]: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~[T] {\n+        do d.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || deserialize(d))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<T: Serializable> @[T]: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        do s.emit_managed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<T: Deserializable> @[T]: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> @[T] {\n+        do d.read_managed_vec |len| {\n+            do at_vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || deserialize(d))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<T: Serializable> Option<T>: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        do s.emit_enum(~\"option\") {\n+            match *self {\n+              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n+              },\n+\n+              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n+                s.emit_enum_variant_arg(0u, || v.serialize(s))\n+              }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<T: Deserializable> Option<T>: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> Option<T> {\n+        do d.read_enum(~\"option\") {\n+            do d.read_enum_variant |i| {\n+                match i {\n+                  0 => None,\n+                  1 => Some(d.read_enum_variant_arg(0u, || deserialize(d))),\n+                  _ => fail(#fmt(\"Bad variant for option: %u\", i))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Serializable,\n+    T1: Serializable\n+> (T0, T1): Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1) => {\n+                do s.emit_tup(2) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable\n+> (T0, T1): Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1) {\n+        do d.read_tup(2) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Serializable,\n+    T1: Serializable,\n+    T2: Serializable\n+> (T0, T1, T2): Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2) => {\n+                do s.emit_tup(3) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable,\n+    T2: Deserializable\n+> (T0, T1, T2): Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2) {\n+        do d.read_tup(3) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Serializable,\n+    T1: Serializable,\n+    T2: Serializable,\n+    T3: Serializable\n+> (T0, T1, T2, T3): Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3) => {\n+                do s.emit_tup(4) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                    s.emit_tup_elt(3, || t3.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable,\n+    T2: Deserializable,\n+    T3: Deserializable\n+> (T0, T1, T2, T3): Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2, T3) {\n+        do d.read_tup(4) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d)),\n+                d.read_tup_elt(3, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Serializable,\n+    T1: Serializable,\n+    T2: Serializable,\n+    T3: Serializable,\n+    T4: Serializable\n+> (T0, T1, T2, T3, T4): Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n+                do s.emit_tup(5) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                    s.emit_tup_elt(3, || t3.serialize(s));\n+                    s.emit_tup_elt(4, || t4.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable,\n+    T2: Deserializable,\n+    T3: Deserializable,\n+    T4: Deserializable\n+> (T0, T1, T2, T3, T4): Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D)\n+      -> (T0, T1, T2, T3, T4) {\n+        do d.read_tup(5) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d)),\n+                d.read_tup_elt(3, || deserialize(d)),\n+                d.read_tup_elt(4, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+// ___________________________________________________________________________\n+// Helper routines\n+//\n+// In some cases, these should eventually be coded as traits.\n+\n+pub trait SerializerHelpers {\n+    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T));\n+}\n+\n+pub impl<S: Serializer> S: SerializerHelpers {\n+    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T)) {\n+        do self.emit_owned_vec(v.len()) {\n+            for v.eachi |i, e| {\n+                do self.emit_vec_elt(i) {\n+                    f(e)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub trait DeserializerHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n+}\n+\n+pub impl<D: Deserializer> D: DeserializerHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n+        do self.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                self.read_vec_elt(i, || f())\n             }\n         }\n     }"}, {"sha": "9ea54477869411a19a0df6a57d916386bc50618d", "filename": "src/libstd/serialization2.rs", "status": "modified", "additions": 1, "deletions": 557, "changes": 558, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Fserialization2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibstd%2Fserialization2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization2.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -4,560 +4,4 @@\n Core serialization interfaces.\n */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(non_camel_case_types)];\n-\n-pub trait Serializer {\n-    // Primitive types:\n-    fn emit_nil(&self);\n-    fn emit_uint(&self, v: uint);\n-    fn emit_u64(&self, v: u64);\n-    fn emit_u32(&self, v: u32);\n-    fn emit_u16(&self, v: u16);\n-    fn emit_u8(&self, v: u8);\n-    fn emit_int(&self, v: int);\n-    fn emit_i64(&self, v: i64);\n-    fn emit_i32(&self, v: i32);\n-    fn emit_i16(&self, v: i16);\n-    fn emit_i8(&self, v: i8);\n-    fn emit_bool(&self, v: bool);\n-    fn emit_float(&self, v: float);\n-    fn emit_f64(&self, v: f64);\n-    fn emit_f32(&self, v: f32);\n-    fn emit_char(&self, v: char);\n-    fn emit_borrowed_str(&self, v: &str);\n-    fn emit_owned_str(&self, v: &str);\n-    fn emit_managed_str(&self, v: &str);\n-\n-    // Compound types:\n-    fn emit_borrowed(&self, f: fn());\n-    fn emit_owned(&self, f: fn());\n-    fn emit_managed(&self, f: fn());\n-\n-    fn emit_enum(&self, name: &str, f: fn());\n-    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: fn());\n-    fn emit_enum_variant_arg(&self, idx: uint, f: fn());\n-\n-    fn emit_borrowed_vec(&self, len: uint, f: fn());\n-    fn emit_owned_vec(&self, len: uint, f: fn());\n-    fn emit_managed_vec(&self, len: uint, f: fn());\n-    fn emit_vec_elt(&self, idx: uint, f: fn());\n-\n-    fn emit_rec(&self, f: fn());\n-    fn emit_struct(&self, name: &str, f: fn());\n-    fn emit_field(&self, f_name: &str, f_idx: uint, f: fn());\n-\n-    fn emit_tup(&self, len: uint, f: fn());\n-    fn emit_tup_elt(&self, idx: uint, f: fn());\n-}\n-\n-pub trait Deserializer {\n-    // Primitive types:\n-    fn read_nil(&self) -> ();\n-    fn read_uint(&self) -> uint;\n-    fn read_u64(&self) -> u64;\n-    fn read_u32(&self) -> u32;\n-    fn read_u16(&self) -> u16;\n-    fn read_u8(&self) -> u8;\n-    fn read_int(&self) -> int;\n-    fn read_i64(&self) -> i64;\n-    fn read_i32(&self) -> i32;\n-    fn read_i16(&self) -> i16;\n-    fn read_i8(&self) -> i8;\n-    fn read_bool(&self) -> bool;\n-    fn read_f64(&self) -> f64;\n-    fn read_f32(&self) -> f32;\n-    fn read_float(&self) -> float;\n-    fn read_char(&self) -> char;\n-    fn read_owned_str(&self) -> ~str;\n-    fn read_managed_str(&self) -> @str;\n-\n-    // Compound types:\n-    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T;\n-    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T;\n-\n-    fn read_owned<T>(&self, f: fn() -> T) -> T;\n-    fn read_managed<T>(&self, f: fn() -> T) -> T;\n-\n-    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n-\n-    fn read_rec<T>(&self, f: fn() -> T) -> T;\n-    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T;\n-    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T;\n-\n-    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T;\n-    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n-}\n-\n-pub trait Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S);\n-}\n-\n-pub trait Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> self;\n-}\n-\n-pub impl uint: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_uint(*self) }\n-}\n-\n-pub impl uint: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> uint {\n-        d.read_uint()\n-    }\n-}\n-\n-pub impl u8: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u8(*self) }\n-}\n-\n-pub impl u8: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u8 {\n-        d.read_u8()\n-    }\n-}\n-\n-pub impl u16: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u16(*self) }\n-}\n-\n-pub impl u16: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u16 {\n-        d.read_u16()\n-    }\n-}\n-\n-pub impl u32: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u32(*self) }\n-}\n-\n-pub impl u32: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u32 {\n-        d.read_u32()\n-    }\n-}\n-\n-pub impl u64: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u64(*self) }\n-}\n-\n-pub impl u64: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u64 {\n-        d.read_u64()\n-    }\n-}\n-\n-pub impl int: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_int(*self) }\n-}\n-\n-pub impl int: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> int {\n-        d.read_int()\n-    }\n-}\n-\n-pub impl i8: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i8(*self) }\n-}\n-\n-pub impl i8: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i8 {\n-        d.read_i8()\n-    }\n-}\n-\n-pub impl i16: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i16(*self) }\n-}\n-\n-pub impl i16: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i16 {\n-        d.read_i16()\n-    }\n-}\n-\n-pub impl i32: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i32(*self) }\n-}\n-\n-pub impl i32: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i32 {\n-        d.read_i32()\n-    }\n-}\n-\n-pub impl i64: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i64(*self) }\n-}\n-\n-pub impl i64: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i64 {\n-        d.read_i64()\n-    }\n-}\n-\n-pub impl &str: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_borrowed_str(*self) }\n-}\n-\n-pub impl ~str: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_owned_str(*self) }\n-}\n-\n-pub impl ~str: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~str {\n-        d.read_owned_str()\n-    }\n-}\n-\n-pub impl @str: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_managed_str(*self) }\n-}\n-\n-pub impl @str: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> @str {\n-        d.read_managed_str()\n-    }\n-}\n-\n-pub impl float: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_float(*self) }\n-}\n-\n-pub impl float: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> float {\n-        d.read_float()\n-    }\n-}\n-\n-pub impl f32: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f32(*self) }\n-}\n-\n-pub impl f32: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> f32 {\n-        d.read_f32() }\n-}\n-\n-pub impl f64: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f64(*self) }\n-}\n-\n-pub impl f64: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> f64 {\n-        d.read_f64()\n-    }\n-}\n-\n-pub impl bool: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_bool(*self) }\n-}\n-\n-pub impl bool: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> bool {\n-        d.read_bool()\n-    }\n-}\n-\n-pub impl (): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_nil() }\n-}\n-\n-pub impl (): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> () {\n-        d.read_nil()\n-    }\n-}\n-\n-pub impl<T: Serializable> &T: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        s.emit_borrowed(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<T: Serializable> ~T: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        s.emit_owned(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<T: Deserializable> ~T: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~T {\n-        d.read_owned(|| ~deserialize(d))\n-    }\n-}\n-\n-pub impl<T: Serializable> @T: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        s.emit_managed(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<T: Deserializable> @T: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> @T {\n-        d.read_managed(|| @deserialize(d))\n-    }\n-}\n-\n-pub impl<T: Serializable> &[T]: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_borrowed_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Serializable> ~[T]: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_owned_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Deserializable> ~[T]: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~[T] {\n-        do d.read_owned_vec |len| {\n-            do vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || deserialize(d))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Serializable> @[T]: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_managed_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Deserializable> @[T]: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> @[T] {\n-        do d.read_managed_vec |len| {\n-            do at_vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || deserialize(d))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Serializable> Option<T>: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_enum(~\"option\") {\n-            match *self {\n-              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n-              },\n-\n-              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n-                s.emit_enum_variant_arg(0u, || v.serialize(s))\n-              }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Deserializable> Option<T>: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> Option<T> {\n-        do d.read_enum(~\"option\") {\n-            do d.read_enum_variant |i| {\n-                match i {\n-                  0 => None,\n-                  1 => Some(d.read_enum_variant_arg(0u, || deserialize(d))),\n-                  _ => fail(#fmt(\"Bad variant for option: %u\", i))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable\n-> (T0, T1): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1) => {\n-                do s.emit_tup(2) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable\n-> (T0, T1): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1) {\n-        do d.read_tup(2) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable,\n-    T2: Serializable\n-> (T0, T1, T2): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2) => {\n-                do s.emit_tup(3) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable,\n-    T2: Deserializable\n-> (T0, T1, T2): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2) {\n-        do d.read_tup(3) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable,\n-    T2: Serializable,\n-    T3: Serializable\n-> (T0, T1, T2, T3): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3) => {\n-                do s.emit_tup(4) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                    s.emit_tup_elt(3, || t3.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable,\n-    T2: Deserializable,\n-    T3: Deserializable\n-> (T0, T1, T2, T3): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2, T3) {\n-        do d.read_tup(4) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d)),\n-                d.read_tup_elt(3, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable,\n-    T2: Serializable,\n-    T3: Serializable,\n-    T4: Serializable\n-> (T0, T1, T2, T3, T4): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                do s.emit_tup(5) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                    s.emit_tup_elt(3, || t3.serialize(s));\n-                    s.emit_tup_elt(4, || t4.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable,\n-    T2: Deserializable,\n-    T3: Deserializable,\n-    T4: Deserializable\n-> (T0, T1, T2, T3, T4): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D)\n-      -> (T0, T1, T2, T3, T4) {\n-        do d.read_tup(5) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d)),\n-                d.read_tup_elt(3, || deserialize(d)),\n-                d.read_tup_elt(4, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Helper routines\n-//\n-// In some cases, these should eventually be coded as traits.\n-\n-pub trait SerializerHelpers {\n-    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T));\n-}\n-\n-pub impl<S: Serializer> S: SerializerHelpers {\n-    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T)) {\n-        do self.emit_owned_vec(v.len()) {\n-            for v.eachi |i, e| {\n-                do self.emit_vec_elt(i) {\n-                    f(e)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub trait DeserializerHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n-}\n-\n-pub impl<D: Deserializer> D: DeserializerHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n-        do self.read_owned_vec |len| {\n-            do vec::from_fn(len) |i| {\n-                self.read_vec_elt(i, || f())\n-            }\n-        }\n-    }\n-}\n+pub use serialization::*;"}, {"sha": "f3e118461e663c507b4cabb938fea63ead445a87", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 174, "deletions": 4, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -1,9 +1,9 @@\n // The Rust abstract syntax tree.\n \n-use std::serialization2::{Serializable,\n-                          Deserializable,\n-                          Serializer,\n-                          Deserializer};\n+use std::serialization::{Serializable,\n+                         Deserializable,\n+                         Serializer,\n+                         Deserializer};\n use codemap::{span, filename};\n use parse::token;\n \n@@ -18,6 +18,8 @@ impl span: Deserializable {\n     }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type spanned<T> = {node: T, span: span};\n@@ -74,6 +76,8 @@ impl ident: to_bytes::IterBytes {\n // Functions may or may not have names.\n type fn_ident = Option<ident>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type path = {span: span,\n@@ -86,6 +90,8 @@ type crate_num = int;\n \n type node_id = int;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type def_id = {crate: crate_num, node: node_id};\n@@ -100,6 +106,8 @@ impl def_id : cmp::Eq {\n const local_crate: crate_num = 0;\n const crate_node_id: node_id = 0;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum ty_param_bound {\n@@ -110,10 +118,14 @@ enum ty_param_bound {\n     bound_trait(@ty),\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type ty_param = {ident: ident, id: node_id, bounds: @~[ty_param_bound]};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum def {\n@@ -294,6 +306,8 @@ type crate_directive = spanned<crate_directive_>;\n \n type meta_item = spanned<meta_item_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum meta_item_ {\n@@ -304,6 +318,8 @@ enum meta_item_ {\n \n type blk = spanned<blk_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type blk_ = {view_items: ~[@view_item],\n@@ -312,14 +328,20 @@ type blk_ = {view_items: ~[@view_item],\n              id: node_id,\n              rules: blk_check_mode};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type pat = {id: node_id, node: pat_, span: span};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type field_pat = {ident: ident, pat: @pat};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum binding_mode {\n@@ -377,6 +399,8 @@ impl binding_mode : cmp::Eq {\n     pure fn ne(other: &binding_mode) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum pat_ {\n@@ -401,6 +425,8 @@ enum pat_ {\n     pat_range(@expr, @expr),\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum mutability { m_mutbl, m_imm, m_const, }\n@@ -418,6 +444,8 @@ impl mutability : cmp::Eq {\n     pure fn ne(other: &mutability) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum proto {\n@@ -434,6 +462,8 @@ impl proto : cmp::Eq {\n     pure fn ne(other: &proto) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum vstore {\n@@ -444,6 +474,8 @@ enum vstore {\n     vstore_slice(@region)         // &[1,2,3,4](foo)?\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum expr_vstore {\n@@ -461,6 +493,8 @@ pure fn is_blockish(p: ast::proto) -> bool {\n     }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum binop {\n@@ -491,6 +525,8 @@ impl binop : cmp::Eq {\n     pure fn ne(other: &binop) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum unop {\n@@ -543,6 +579,8 @@ impl unop : cmp::Eq {\n \n // Generally, after typeck you can get the inferred value\n // using ty::resolved_T(...).\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum inferable<T> {\n@@ -583,6 +621,8 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n }\n \n // \"resolved\" mode: the real modes.\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum rmode { by_ref, by_val, by_move, by_copy }\n@@ -606,6 +646,8 @@ type mode = inferable<rmode>;\n \n type stmt = spanned<stmt_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum stmt_ {\n@@ -618,6 +660,8 @@ enum stmt_ {\n     stmt_semi(@expr, node_id),\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum init_op { init_assign, init_move, }\n@@ -642,12 +686,16 @@ impl init_op : cmp::Eq {\n     pure fn ne(other: &init_op) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type initializer = {op: init_op, expr: @expr};\n \n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type local_ =  {is_mutbl: bool, ty: @ty, pat: @pat,\n@@ -657,20 +705,28 @@ type local = spanned<local_>;\n \n type decl = spanned<decl_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type arm = {pats: ~[@pat], guard: Option<@expr>, body: blk};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n \n type field = spanned<field_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum blk_check_mode { default_blk, unsafe_blk, }\n@@ -687,20 +743,28 @@ impl blk_check_mode : cmp::Eq {\n     pure fn ne(other: &blk_check_mode) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type expr = {id: node_id, callee_id: node_id, node: expr_, span: span};\n // Extra node ID is only used for index, assign_op, unary, binary\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum log_level { error, debug, other }\n // 0 = error, 1 = debug, 2 = other\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum alt_mode { alt_check, alt_exhaustive, }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum expr_ {\n@@ -758,6 +822,8 @@ enum expr_ {\n     expr_repeat(@expr /* element */, @expr /* count */, mutability)\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type capture_item_ = {\n@@ -787,6 +853,8 @@ type capture_clause = @~[capture_item];\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n@@ -852,6 +920,8 @@ enum token_tree {\n //\n type matcher = spanned<matcher_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum matcher_ {\n@@ -868,12 +938,16 @@ type mac = spanned<mac_>;\n \n type mac_arg = Option<@expr>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type mac_body_ = {span: span};\n \n type mac_body = Option<mac_body_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum mac_ {\n@@ -888,6 +962,8 @@ enum mac_ {\n \n type lit = spanned<lit_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum lit_ {\n@@ -930,22 +1006,30 @@ impl ast::lit_: cmp::Eq {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type mt = {ty: @ty, mutbl: mutability};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type ty_field_ = {ident: ident, mt: mt};\n \n type ty_field = spanned<ty_field_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type ty_method = {ident: ident, attrs: ~[attribute], purity: purity,\n                   decl: fn_decl, tps: ~[ty_param], self_ty: self_ty,\n                   id: node_id, span: span};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n // A trait method is either required (meaning it doesn't have an\n@@ -956,6 +1040,8 @@ enum trait_method {\n     provided(@method),\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n@@ -986,6 +1072,8 @@ impl int_ty : cmp::Eq {\n     pure fn ne(other: &int_ty) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n@@ -1014,6 +1102,8 @@ impl uint_ty : cmp::Eq {\n     pure fn ne(other: &uint_ty) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum float_ty { ty_f, ty_f32, ty_f64, }\n@@ -1033,11 +1123,15 @@ impl float_ty : cmp::Eq {\n     pure fn ne(other: &float_ty) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type ty = {id: node_id, node: ty_, span: span};\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum prim_ty {\n@@ -1086,10 +1180,14 @@ impl prim_ty : cmp::Eq {\n     pure fn ne(other: &prim_ty) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type region = {id: node_id, node: region_};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum region_ {\n@@ -1099,6 +1197,8 @@ enum region_ {\n     re_named(ident)\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum ty_ {\n@@ -1139,17 +1239,23 @@ impl ty : to_bytes::IterBytes {\n }\n \n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type fn_decl =\n     {inputs: ~[arg],\n      output: @ty,\n      cf: ret_style};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum purity {\n@@ -1172,6 +1278,8 @@ impl purity : cmp::Eq {\n     pure fn ne(other: &purity) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum ret_style {\n@@ -1198,6 +1306,8 @@ impl ret_style : cmp::Eq {\n     pure fn ne(other: &ret_style) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum self_ty_ {\n@@ -1255,6 +1365,8 @@ impl self_ty_ : cmp::Eq {\n \n type self_ty = spanned<self_ty_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type method = {ident: ident, attrs: ~[attribute],\n@@ -1263,10 +1375,14 @@ type method = {ident: ident, attrs: ~[attribute],\n                id: node_id, span: span, self_id: node_id,\n                vis: visibility};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type _mod = {view_items: ~[@view_item], items: ~[@item]};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum foreign_abi {\n@@ -1276,6 +1392,8 @@ enum foreign_abi {\n }\n \n // Foreign mods can be named or anonymous\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum foreign_mod_sort { named, anonymous }\n@@ -1301,17 +1419,23 @@ impl foreign_abi : cmp::Eq {\n     pure fn ne(other: &foreign_abi) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type foreign_mod =\n     {sort: foreign_mod_sort,\n      view_items: ~[@view_item],\n      items: ~[@foreign_item]};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type variant_arg = {ty: @ty, id: node_id};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum variant_kind {\n@@ -1320,27 +1444,37 @@ enum variant_kind {\n     enum_variant_kind(enum_def)\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type enum_def_ = { variants: ~[variant], common: Option<@struct_def> };\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum enum_def = enum_def_;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type variant_ = {name: ident, attrs: ~[attribute], kind: variant_kind,\n                  id: node_id, disr_expr: Option<@expr>, vis: visibility};\n \n type variant = spanned<variant_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type path_list_ident_ = {name: ident, id: node_id};\n \n type path_list_ident = spanned<path_list_ident_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum namespace { module_ns, type_value_ns }\n@@ -1354,6 +1488,8 @@ impl namespace : cmp::Eq {\n \n type view_path = spanned<view_path_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum view_path_ {\n@@ -1372,11 +1508,15 @@ enum view_path_ {\n     view_path_list(@path, ~[path_list_ident], node_id)\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type view_item = {node: view_item_, attrs: ~[attribute],\n                   vis: visibility, span: span};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum view_item_ {\n@@ -1391,6 +1531,8 @@ type attribute = spanned<attribute_>;\n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum attr_style { attr_outer, attr_inner, }\n@@ -1403,6 +1545,8 @@ impl attr_style : cmp::Eq {\n }\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n@@ -1416,10 +1560,14 @@ type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n   conceptually, the impl_id stands in for the pair of (this class, this\n   trait)\n  */\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum visibility { public, private, inherited }\n@@ -1438,6 +1586,8 @@ impl visibility : cmp::Eq {\n     pure fn ne(other: &visibility) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type struct_field_ = {\n@@ -1448,13 +1598,17 @@ type struct_field_ = {\n \n type struct_field = spanned<struct_field_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum struct_field_kind {\n     named_field(ident, class_mutability, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type struct_def = {\n@@ -1472,12 +1626,16 @@ type struct_def = {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type item = {ident: ident, attrs: ~[attribute],\n              id: node_id, node: item_,\n              vis: visibility, span: span};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum item_ {\n@@ -1496,6 +1654,8 @@ enum item_ {\n     item_mac(mac),\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum class_mutability { class_mutable, class_immutable }\n@@ -1520,6 +1680,8 @@ impl class_mutability : cmp::Eq {\n \n type class_ctor = spanned<class_ctor_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type class_ctor_ = {id: node_id,\n@@ -1530,13 +1692,17 @@ type class_ctor_ = {id: node_id,\n \n type class_dtor = spanned<class_dtor_>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type class_dtor_ = {id: node_id,\n                     attrs: ~[attribute],\n                     self_id: node_id,\n                     body: blk};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type foreign_item =\n@@ -1547,6 +1713,8 @@ type foreign_item =\n      span: span,\n      vis: visibility};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum foreign_item_ {\n@@ -1557,6 +1725,8 @@ enum foreign_item_ {\n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum inlined_item {"}, {"sha": "897a51f710c67276de7680c9de5c9c33c8e6b67a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -406,6 +406,8 @@ fn dtor_dec() -> fn_decl {\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type id_range = {min: node_id, max: node_id};"}, {"sha": "b06536f4e026abff6329a3e0b042060891951efa", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 967, "deletions": 718, "changes": 1685, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -1,62 +1,64 @@\n /*\n \n-The compiler code necessary to implement the #[auto_serialize]\n-extension.  The idea here is that type-defining items may be tagged\n-with #[auto_serialize], which will cause us to generate a little\n-companion module with the same name as the item.\n+The compiler code necessary to implement the #[auto_serialize] and\n+#[auto_deserialize] extension.  The idea here is that type-defining items may\n+be tagged with #[auto_serialize] and #[auto_deserialize], which will cause\n+us to generate a little companion module with the same name as the item.\n \n For example, a type like:\n \n-    type node_id = uint;\n+    #[auto_serialize]\n+    #[auto_deserialize]\n+    struct Node {id: uint}\n \n-would generate two functions like:\n+would generate two implementations like:\n \n-    fn serialize_node_id<S: serializer>(s: S, v: node_id) {\n-        s.emit_uint(v);\n+    impl Node: Serializable {\n+        fn serialize<S: Serializer>(s: &S) {\n+            do s.emit_struct(\"Node\") {\n+                s.emit_field(\"id\", 0, || s.emit_uint(self))\n+            }\n+        }\n     }\n-    fn deserialize_node_id<D: deserializer>(d: D) -> node_id {\n-        d.read_uint()\n+\n+    impl node_id: Deserializable {\n+        static fn deserialize<D: Deserializer>(d: &D) -> Node {\n+            do d.read_struct(\"Node\") {\n+                Node {\n+                    id: d.read_field(~\"x\", 0, || deserialize(d))\n+                }\n+            }\n+        }\n     }\n \n Other interesting scenarios are whe the item has type parameters or\n references other non-built-in types.  A type definition like:\n \n+    #[auto_serialize]\n+    #[auto_deserialize]\n     type spanned<T> = {node: T, span: span};\n \n would yield functions like:\n \n-    fn serialize_spanned<S: serializer,T>(s: S, v: spanned<T>, t: fn(T)) {\n-         s.emit_rec(2u) {||\n-             s.emit_rec_field(\"node\", 0u) {||\n-                 t(s.node);\n-             };\n-             s.emit_rec_field(\"span\", 1u) {||\n-                 serialize_span(s, s.span);\n-             };\n-         }\n-    }\n-    fn deserialize_spanned<D: deserializer>(d: D, t: fn() -> T) -> node_id {\n-         d.read_rec(2u) {||\n-             {node: d.read_rec_field(\"node\", 0u, t),\n-              span: d.read_rec_field(\"span\", 1u) {||deserialize_span(d)}}\n-         }\n+    impl<T: Serializable> spanned<T>: Serializable {\n+        fn serialize<S: Serializer>(s: &S) {\n+            do s.emit_rec {\n+                s.emit_field(\"node\", 0, || self.node.serialize(s));\n+                s.emit_field(\"span\", 1, || self.span.serialize(s));\n+            }\n+        }\n     }\n \n-In general, the code to serialize an instance `v` of a non-built-in\n-type a::b::c<T0,...,Tn> looks like:\n-\n-    a::b::serialize_c(s, {|v| c_T0}, ..., {|v| c_Tn}, v)\n-\n-where `c_Ti` is the code to serialize an instance `v` of the type\n-`Ti`.\n-\n-Similarly, the code to deserialize an instance of a non-built-in type\n-`a::b::c<T0,...,Tn>` using the deserializer `d` looks like:\n-\n-    a::b::deserialize_c(d, {|| c_T0}, ..., {|| c_Tn})\n-\n-where `c_Ti` is the code to deserialize an instance of `Ti` using the\n-deserializer `d`.\n+    impl<T: Deserializable> spanned<T>: Deserializable {\n+        static fn deserialize<D: Deserializer>(d: &D) -> spanned<T> {\n+            do d.read_rec {\n+                {\n+                    node: d.read_field(~\"node\", 0, || deserialize(d)),\n+                    span: d.read_field(~\"span\", 1, || deserialize(d)),\n+                }\n+            }\n+        }\n+    }\n \n FIXME (#2810)--Hygiene. Search for \"__\" strings.  We also assume \"std\" is the\n standard library.\n@@ -69,788 +71,1035 @@ into the tree.  This is intended to prevent us from inserting the same\n node twice.\n \n */\n+\n use base::*;\n use codemap::span;\n use std::map;\n use std::map::HashMap;\n \n-export expand;\n+export expand_auto_serialize;\n+export expand_auto_deserialize;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n-    #[legacy_exports];\n     pub use ext;\n     pub use parse;\n }\n \n-type ser_tps_map = map::HashMap<ast::ident, fn@(@ast::expr) -> ~[@ast::stmt]>;\n-type deser_tps_map = map::HashMap<ast::ident, fn@() -> @ast::expr>;\n+fn expand_auto_serialize(\n+    cx: ext_ctxt,\n+    span: span,\n+    _mitem: ast::meta_item,\n+    in_items: ~[@ast::item]\n+) -> ~[@ast::item] {\n+    fn is_auto_serialize(a: &ast::attribute) -> bool {\n+        attr::get_attr_name(*a) == ~\"auto_serialize\"\n+    }\n+\n+    fn filter_attrs(item: @ast::item) -> @ast::item {\n+        @{attrs: vec::filter(item.attrs, |a| !is_auto_serialize(a)),\n+          .. *item}\n+    }\n+\n+    do vec::flat_map(in_items) |item| {\n+        if item.attrs.any(is_auto_serialize) {\n+            match item.node {\n+                ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n+                    let ser_impl = mk_rec_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                ast::item_class(@{ fields, _}, tps) => {\n+                    let ser_impl = mk_struct_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                ast::item_enum(enum_def, tps) => {\n+                    let ser_impl = mk_enum_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        enum_def,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                _ => {\n+                    cx.span_err(span, ~\"#[auto_serialize] can only be \\\n+                                        applied to structs, record types, \\\n+                                        and enum definitions\");\n+                    ~[*item]\n+                }\n+            }\n+        } else {\n+            ~[*item]\n+        }\n+    }\n+}\n \n-fn expand(cx: ext_ctxt,\n-          span: span,\n-          _mitem: ast::meta_item,\n-          in_items: ~[@ast::item]) -> ~[@ast::item] {\n-    fn not_auto_serialize(a: &ast::attribute) -> bool {\n-        attr::get_attr_name(*a) != ~\"auto_serialize\"\n+fn expand_auto_deserialize(\n+    cx: ext_ctxt,\n+    span: span,\n+    _mitem: ast::meta_item,\n+    in_items: ~[@ast::item]\n+) -> ~[@ast::item] {\n+    fn is_auto_deserialize(a: &ast::attribute) -> bool {\n+        attr::get_attr_name(*a) == ~\"auto_deserialize\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {\n-        @{attrs: vec::filter(item.attrs, not_auto_serialize),\n+        @{attrs: vec::filter(item.attrs, |a| !is_auto_deserialize(a)),\n           .. *item}\n     }\n \n-    do vec::flat_map(in_items) |in_item| {\n-        match in_item.node {\n-          ast::item_ty(ty, tps) => {\n-            vec::append(~[filter_attrs(*in_item)],\n-                        ty_fns(cx, in_item.ident, ty, tps))\n-          }\n-\n-          ast::item_enum(enum_definition, tps) => {\n-            vec::append(~[filter_attrs(*in_item)],\n-                        enum_fns(cx, in_item.ident,\n-                                 in_item.span, enum_definition.variants, tps))\n-          }\n-\n-          _ => {\n-            cx.span_err(span, ~\"#[auto_serialize] can only be \\\n-                               applied to type and enum \\\n-                               definitions\");\n-            ~[*in_item]\n-          }\n+    do vec::flat_map(in_items) |item| {\n+        if item.attrs.any(is_auto_deserialize) {\n+            match item.node {\n+                ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n+                    let deser_impl = mk_rec_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                ast::item_class(@{ fields, _}, tps) => {\n+                    let deser_impl = mk_struct_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                ast::item_enum(enum_def, tps) => {\n+                    let deser_impl = mk_enum_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        enum_def,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                _ => {\n+                    cx.span_err(span, ~\"#[auto_deserialize] can only be \\\n+                                        applied to structs, record types, \\\n+                                        and enum definitions\");\n+                    ~[*item]\n+                }\n+            }\n+        } else {\n+            ~[*item]\n         }\n     }\n }\n \n priv impl ext_ctxt {\n-    fn helper_path(base_path: @ast::path,\n-                   helper_name: ~str) -> @ast::path {\n-        let head = vec::init(base_path.idents);\n-        let tail = vec::last(base_path.idents);\n-        self.path(base_path.span,\n-                  vec::append(head,\n-                              ~[self.parse_sess().interner.\n-                                intern(@(helper_name + ~\"_\" +\n-                                         *self.parse_sess().interner.get(\n-                                             tail)))]))\n-    }\n-\n-    fn ty_fn(span: span,\n-             -input_tys: ~[@ast::ty],\n-             -output: @ast::ty) -> @ast::ty {\n-        let args = do vec::map(input_tys) |ty| {\n-            {mode: ast::expl(ast::by_ref),\n-             ty: *ty,\n-             ident: parse::token::special_idents::invalid,\n-             id: self.next_id()}\n-        };\n+    fn expr(span: span, node: ast::expr_) -> @ast::expr {\n+        @{id: self.next_id(), callee_id: self.next_id(),\n+          node: node, span: span}\n+    }\n+\n+    fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n+        @{span: span, global: false, idents: strs, rp: None, types: ~[]}\n+    }\n \n+    fn path_tps(span: span, strs: ~[ast::ident],\n+                tps: ~[@ast::ty]) -> @ast::path {\n+        @{span: span, global: false, idents: strs, rp: None, types: tps}\n+    }\n+\n+    fn ty_path(span: span, strs: ~[ast::ident],\n+               tps: ~[@ast::ty]) -> @ast::ty {\n         @{id: self.next_id(),\n-          node: ast::ty_fn(ast::proto_block,\n-                           ast::impure_fn,\n-                           @~[],\n-                           {inputs: args,\n-                            output: output,\n-                            cf: ast::return_val}),\n+          node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n           span: span}\n     }\n \n-    fn ty_nil(span: span) -> @ast::ty {\n-        @{id: self.next_id(), node: ast::ty_nil, span: span}\n+    fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n+        let path = @{span: span, global: false, idents: ~[nm],\n+                     rp: None, types: ~[]};\n+        @{id: self.next_id(),\n+          node: ast::pat_ident(ast::bind_by_implicit_ref,\n+                               path,\n+                               None),\n+          span: span}\n     }\n \n-    fn var_ref(span: span, name: ast::ident) -> @ast::expr {\n-        self.expr(span, ast::expr_path(self.path(span, ~[name])))\n+    fn stmt(expr: @ast::expr) -> @ast::stmt {\n+        @{node: ast::stmt_semi(expr, self.next_id()),\n+          span: expr.span}\n     }\n \n-    fn alt_stmt(arms: ~[ast::arm],\n-                span: span, -v: @ast::expr) -> @ast::stmt {\n-        self.stmt(\n-            self.expr(\n-                span,\n-                ast::expr_match(v, arms)))\n+    fn lit_str(span: span, s: @~str) -> @ast::expr {\n+        self.expr(\n+            span,\n+            ast::expr_vstore(\n+                self.expr(\n+                    span,\n+                    ast::expr_lit(\n+                        @{node: ast::lit_str(s),\n+                          span: span})),\n+                ast::expr_vstore_uniq))\n     }\n \n-    fn clone_folder() -> fold::ast_fold {\n-        fold::make_fold(@{\n-            new_id: |_id| self.next_id(),\n-            .. *fold::default_ast_fold()\n-        })\n+    fn lit_uint(span: span, i: uint) -> @ast::expr {\n+        self.expr(\n+            span,\n+            ast::expr_lit(\n+                @{node: ast::lit_uint(i as u64, ast::ty_u),\n+                  span: span}))\n     }\n \n-    fn clone(v: @ast::expr) -> @ast::expr {\n-        let fld = self.clone_folder();\n-        fld.fold_expr(v)\n+    fn lambda(blk: ast::blk) -> @ast::expr {\n+        let ext_cx = self;\n+        let blk_e = self.expr(blk.span, ast::expr_block(blk));\n+        #ast{ || $(blk_e) }\n     }\n \n-    fn clone_ty(v: @ast::ty) -> @ast::ty {\n-        let fld = self.clone_folder();\n-        fld.fold_ty(v)\n+    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n+        {node: {view_items: ~[],\n+                stmts: stmts,\n+                expr: None,\n+                id: self.next_id(),\n+                rules: ast::default_blk},\n+         span: span}\n     }\n \n-    fn clone_ty_param(v: ast::ty_param) -> ast::ty_param {\n-        let fld = self.clone_folder();\n-        fold::fold_ty_param(v, fld)\n+    fn expr_blk(expr: @ast::expr) -> ast::blk {\n+        {node: {view_items: ~[],\n+                stmts: ~[],\n+                expr: Some(expr),\n+                id: self.next_id(),\n+                rules: ast::default_blk},\n+         span: expr.span}\n     }\n \n-    fn at(span: span, expr: @ast::expr) -> @ast::expr {\n-        fn repl_sp(old_span: span, repl_span: span, with_span: span) -> span {\n-            if old_span == repl_span {\n-                with_span\n-            } else {\n-                old_span\n-            }\n-        }\n+    fn expr_path(span: span, strs: ~[ast::ident]) -> @ast::expr {\n+        self.expr(span, ast::expr_path(self.path(span, strs)))\n+    }\n \n-        let fld = fold::make_fold(@{\n-            new_span: |a| repl_sp(a, ast_util::dummy_sp(), span),\n-            .. *fold::default_ast_fold()\n-        });\n+    fn expr_var(span: span, var: ~str) -> @ast::expr {\n+        self.expr_path(span, ~[self.ident_of(var)])\n+    }\n \n-        fld.fold_expr(expr)\n+    fn expr_field(\n+        span: span,\n+        expr: @ast::expr,\n+        ident: ast::ident\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_field(expr, ident, ~[]))\n     }\n-}\n \n-fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n-                  -s: @ast::expr, -v: @ast::expr)\n-    -> ~[@ast::stmt] {\n-    let ext_cx = cx; // required for #ast{}\n-\n-    // We want to take a path like a::b::c<...> and generate a call\n-    // like a::b::c::serialize(s, ...), as described above.\n-\n-    let callee =\n-        cx.expr(\n-            path.span,\n-            ast::expr_path(\n-                cx.helper_path(path, ~\"serialize\")));\n-\n-    let ty_args = do vec::map(path.types) |ty| {\n-        let sv_stmts = ser_ty(cx, tps, *ty, cx.clone(s), #ast{ __v });\n-        let sv = cx.expr(path.span,\n-                         ast::expr_block(cx.blk(path.span, sv_stmts)));\n-        cx.at(ty.span, #ast{ |__v| $(sv) })\n-    };\n+    fn expr_call(\n+        span: span,\n+        expr: @ast::expr,\n+        args: ~[@ast::expr]\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_call(expr, args, false))\n+    }\n \n-    ~[cx.stmt(\n-        cx.expr(\n-            path.span,\n-            ast::expr_call(callee, vec::append(~[s, v], ty_args), false)))]\n+    fn lambda_expr(expr: @ast::expr) -> @ast::expr {\n+        self.lambda(self.expr_blk(expr))\n+    }\n+\n+    fn lambda_stmts(span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n+        self.lambda(self.blk(span, stmts))\n+    }\n }\n \n-fn ser_variant(cx: ext_ctxt,\n-               tps: ser_tps_map,\n-               tys: ~[@ast::ty],\n-               span: span,\n-               -s: @ast::expr,\n-               pfn: fn(~[@ast::pat]) -> ast::pat_,\n-               bodyfn: fn(-v: @ast::expr, ast::blk) -> @ast::expr,\n-               argfn: fn(-v: @ast::expr, uint, ast::blk) -> @ast::expr)\n-    -> ast::arm {\n-    let vnames = do vec::from_fn(vec::len(tys)) |i| {\n-        cx.parse_sess().interner.intern(@fmt!(\"__v%u\", i))\n-    };\n-    let pats = do vec::from_fn(vec::len(tys)) |i| {\n-        cx.binder_pat(tys[i].span, vnames[i])\n-    };\n-    let pat: @ast::pat = @{id: cx.next_id(), node: pfn(pats), span: span};\n-    let stmts = do vec::from_fn(vec::len(tys)) |i| {\n-        let v = cx.var_ref(span, vnames[i]);\n-        let arg_blk =\n-            cx.blk(\n-                span,\n-                ser_ty(cx, tps, tys[i], cx.clone(s), move v));\n-        cx.stmt(argfn(cx.clone(s), i, arg_blk))\n-    };\n+fn mk_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    path: @ast::path,\n+    tps: ~[ast::ty_param],\n+    f: fn(@ast::ty) -> @ast::method\n+) -> @ast::item {\n+    // All the type parameters need to bound to the trait.\n+    let trait_tps = do tps.map |tp| {\n+        let t_bound = ast::bound_trait(@{\n+            id: cx.next_id(),\n+            node: ast::ty_path(path, cx.next_id()),\n+            span: span,\n+        });\n \n-    let body_blk = cx.blk(span, stmts);\n-    let body = cx.blk(span, ~[cx.stmt(bodyfn(move s, body_blk))]);\n+        {\n+            ident: tp.ident,\n+            id: cx.next_id(),\n+            bounds: @vec::append(~[t_bound], *tp.bounds)\n+        }\n+    };\n \n-    {pats: ~[pat], guard: None, body: body}\n+    let opt_trait = Some(@{\n+        path: path,\n+        ref_id: cx.next_id(),\n+        impl_id: cx.next_id(),\n+    });\n+\n+    let ty = cx.ty_path(\n+        span,\n+        ~[ident],\n+        tps.map(|tp| cx.ty_path(span, ~[tp.ident], ~[]))\n+    );\n+\n+    @{\n+        // This is a new-style impl declaration.\n+        // XXX: clownshoes\n+        ident: ast::token::special_idents::clownshoes_extensions,\n+        attrs: ~[],\n+        id: cx.next_id(),\n+        node: ast::item_impl(trait_tps, opt_trait, ty, ~[f(ty)]),\n+        vis: ast::public,\n+        span: span,\n+    }\n }\n \n-fn ser_lambda(cx: ext_ctxt, tps: ser_tps_map, ty: @ast::ty,\n-              -s: @ast::expr, -v: @ast::expr) -> @ast::expr {\n-    cx.lambda(cx.blk(ty.span, ser_ty(cx, tps, ty, move s, move v)))\n+fn mk_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    tps: ~[ast::ty_param],\n+    body: @ast::expr\n+) -> @ast::item {\n+    // Make a path to the std::serialization::Serializable trait.\n+    let path = cx.path(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialization\"),\n+            cx.ident_of(~\"Serializable\"),\n+        ]\n+    );\n+\n+    mk_impl(\n+        cx,\n+        span,\n+        ident,\n+        path,\n+        tps,\n+        |_ty| mk_ser_method(cx, span, cx.expr_blk(body))\n+    )\n }\n \n-fn is_vec_or_str(ty: @ast::ty) -> bool {\n-    match ty.node {\n-      ast::ty_vec(_) => true,\n-      // This may be wrong if the user has shadowed (!) str\n-      ast::ty_path(@{span: _, global: _, idents: ids,\n-                             rp: None, types: _}, _)\n-      if ids == ~[parse::token::special_idents::str] => true,\n-      _ => false\n-    }\n+fn mk_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    tps: ~[ast::ty_param],\n+    body: @ast::expr\n+) -> @ast::item {\n+    // Make a path to the std::serialization::Deserializable trait.\n+    let path = cx.path(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialization\"),\n+            cx.ident_of(~\"Deserializable\"),\n+        ]\n+    );\n+\n+    mk_impl(\n+        cx,\n+        span,\n+        ident,\n+        path,\n+        tps,\n+        |ty| mk_deser_method(cx, span, ty, cx.expr_blk(body))\n+    )\n }\n \n-fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n-          ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n-    -> ~[@ast::stmt] {\n-\n-    let ext_cx = cx; // required for #ast{}\n-\n-    match ty.node {\n-      ast::ty_nil => {\n-        ~[#ast[stmt]{$(s).emit_nil()}]\n-      }\n-\n-      ast::ty_bot => {\n-        cx.span_err(\n-            ty.span, fmt!(\"Cannot serialize bottom type\"));\n+fn mk_ser_method(\n+    cx: ext_ctxt,\n+    span: span,\n+    ser_body: ast::blk\n+) -> @ast::method {\n+    let ser_bound = cx.ty_path(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialization\"),\n+            cx.ident_of(~\"Serializer\"),\n+        ],\n         ~[]\n-      }\n-\n-      ast::ty_box(mt) => {\n-        let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n-        ~[#ast[stmt]{$(s).emit_box($(l));}]\n-      }\n+    );\n+\n+    let ser_tps = ~[{\n+        ident: cx.ident_of(~\"__S\"),\n+        id: cx.next_id(),\n+        bounds: @~[ast::bound_trait(ser_bound)],\n+    }];\n+\n+    let ty_s = @{\n+        id: cx.next_id(),\n+        node: ast::ty_rptr(\n+            @{\n+                id: cx.next_id(),\n+                node: ast::re_anon,\n+            },\n+            {\n+                ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n+                mutbl: ast::m_imm\n+            }\n+        ),\n+        span: span,\n+    };\n \n-      // For unique evecs/estrs, just pass through to underlying vec or str\n-      ast::ty_uniq(mt) if is_vec_or_str(mt.ty) => {\n-        ser_ty(cx, tps, mt.ty, move s, move v)\n-      }\n+    let ser_inputs = ~[{\n+        mode: ast::infer(cx.next_id()),\n+        ty: ty_s,\n+        ident: cx.ident_of(~\"__s\"),\n+        id: cx.next_id(),\n+    }];\n+\n+    let ser_output = @{\n+        id: cx.next_id(),\n+        node: ast::ty_nil,\n+        span: span,\n+    };\n \n-      ast::ty_uniq(mt) => {\n-        let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n-        ~[#ast[stmt]{$(s).emit_uniq($(l));}]\n-      }\n+    let ser_decl = {\n+        inputs: ser_inputs,\n+        output: ser_output,\n+        cf: ast::return_val,\n+    };\n \n-      ast::ty_ptr(_) | ast::ty_rptr(_, _) => {\n-        cx.span_err(ty.span, ~\"cannot serialize pointer types\");\n-        ~[]\n-      }\n-\n-      ast::ty_rec(flds) => {\n-        let fld_stmts = do vec::from_fn(vec::len(flds)) |fidx| {\n-            let fld = flds[fidx];\n-            let vf = cx.expr(fld.span,\n-                             ast::expr_field(cx.clone(v),\n-                                             fld.node.ident,\n-                                             ~[]));\n-            let s = cx.clone(s);\n-            let f = cx.lit_str(fld.span, cx.parse_sess().interner.get(\n-                fld.node.ident));\n-            let i = cx.lit_uint(fld.span, fidx);\n-            let l = ser_lambda(cx, tps, fld.node.mt.ty, cx.clone(s), move vf);\n-            #ast[stmt]{$(s).emit_rec_field($(f), $(i), $(l));}\n-        };\n-        let fld_lambda = cx.lambda(cx.blk(ty.span, fld_stmts));\n-        ~[#ast[stmt]{$(s).emit_rec($(fld_lambda));}]\n-      }\n+    @{\n+        ident: cx.ident_of(~\"serialize\"),\n+        attrs: ~[],\n+        tps: ser_tps,\n+        self_ty: { node: ast::sty_region(ast::m_imm), span: span },\n+        purity: ast::impure_fn,\n+        decl: ser_decl,\n+        body: ser_body,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: ast::public,\n+    }\n+}\n \n-      ast::ty_fn(*) => {\n-        cx.span_err(ty.span, ~\"cannot serialize function types\");\n+fn mk_deser_method(\n+    cx: ext_ctxt,\n+    span: span,\n+    ty: @ast::ty,\n+    deser_body: ast::blk\n+) -> @ast::method {\n+    let deser_bound = cx.ty_path(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialization\"),\n+            cx.ident_of(~\"Deserializer\"),\n+        ],\n         ~[]\n-      }\n-\n-      ast::ty_tup(tys) => {\n-        // Generate code like\n-        //\n-        // match v {\n-        //    (v1, v2, v3) {\n-        //       .. serialize v1, v2, v3 ..\n-        //    }\n-        // };\n-\n-        let arms = ~[\n-            ser_variant(\n-\n-                cx, tps, tys, ty.span, move s,\n-\n-                // Generate pattern (v1, v2, v3)\n-                |pats| ast::pat_tup(pats),\n-\n-                // Generate body s.emit_tup(3, {|| blk })\n-                |-s, blk| {\n-                    let sz = cx.lit_uint(ty.span, vec::len(tys));\n-                    let body = cx.lambda(blk);\n-                    #ast{ $(s).emit_tup($(sz), $(body)) }\n-                },\n-\n-                // Generate s.emit_tup_elt(i, {|| blk })\n-                |-s, i, blk| {\n-                    let idx = cx.lit_uint(ty.span, i);\n-                    let body = cx.lambda(blk);\n-                    #ast{ $(s).emit_tup_elt($(idx), $(body)) }\n-                })\n-        ];\n-        ~[cx.alt_stmt(arms, ty.span, move v)]\n-      }\n-\n-      ast::ty_path(path, _) => {\n-        if path.idents.len() == 1 && path.types.is_empty() {\n-            let ident = path.idents[0];\n-\n-            match tps.find(ident) {\n-              Some(f) => f(v),\n-              None => ser_path(cx, tps, path, move s, move v)\n+    );\n+\n+    let deser_tps = ~[{\n+        ident: cx.ident_of(~\"__D\"),\n+        id: cx.next_id(),\n+        bounds: @~[ast::bound_trait(deser_bound)],\n+    }];\n+\n+    let ty_d = @{\n+        id: cx.next_id(),\n+        node: ast::ty_rptr(\n+            @{\n+                id: cx.next_id(),\n+                node: ast::re_anon,\n+            },\n+            {\n+                ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n+                mutbl: ast::m_imm\n             }\n-        } else {\n-            ser_path(cx, tps, path, move s, move v)\n-        }\n-      }\n-\n-      ast::ty_mac(_) => {\n-        cx.span_err(ty.span, ~\"cannot serialize macro types\");\n-        ~[]\n-      }\n+        ),\n+        span: span,\n+    };\n \n-      ast::ty_infer => {\n-        cx.span_err(ty.span, ~\"cannot serialize inferred types\");\n-        ~[]\n-      }\n+    let deser_inputs = ~[{\n+        mode: ast::infer(cx.next_id()),\n+        ty: ty_d,\n+        ident: cx.ident_of(~\"__d\"),\n+        id: cx.next_id(),\n+    }];\n+\n+    let deser_decl = {\n+        inputs: deser_inputs,\n+        output: ty,\n+        cf: ast::return_val,\n+    };\n \n-      ast::ty_vec(mt) => {\n-        let ser_e =\n-            cx.expr(\n-                ty.span,\n-                ast::expr_block(\n-                    cx.blk(\n-                        ty.span,\n-                        ser_ty(\n-                            cx, tps, mt.ty,\n-                            cx.clone(s),\n-                            cx.at(ty.span, #ast{ __e })))));\n-\n-        ~[#ast[stmt]{\n-            std::serialization::emit_from_vec($(s), $(v), |__e| $(ser_e))\n-        }]\n-      }\n-\n-      ast::ty_fixed_length(_, _) => {\n-        cx.span_unimpl(ty.span, ~\"serialization for fixed length types\");\n-      }\n+    @{\n+        ident: cx.ident_of(~\"deserialize\"),\n+        attrs: ~[],\n+        tps: deser_tps,\n+        self_ty: { node: ast::sty_static, span: span },\n+        purity: ast::impure_fn,\n+        decl: deser_decl,\n+        body: deser_body,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: ast::public,\n     }\n }\n \n-fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n-             tps: ~[ast::ty_param],\n-             f: fn(ext_ctxt, ser_tps_map,\n-                   -v: @ast::expr, -v: @ast::expr) -> ~[@ast::stmt])\n-    -> @ast::item {\n-    let ext_cx = cx; // required for #ast\n-\n-    let tp_types = vec::map(tps, |tp| cx.ty_path(span, ~[tp.ident], ~[]));\n-    let v_ty = cx.ty_path(span, ~[name], tp_types);\n-\n-    let tp_inputs =\n-        vec::map(tps, |tp|\n-            {mode: ast::expl(ast::by_ref),\n-             ty: cx.ty_fn(span,\n-                          ~[cx.ty_path(span, ~[tp.ident], ~[])],\n-                          cx.ty_nil(span)),\n-             ident: cx.ident_of(~\"__s\" + cx.str_of(tp.ident)),\n-             id: cx.next_id()});\n-\n-    debug!(\"tp_inputs = %?\", tp_inputs);\n-\n-\n-    let ser_inputs: ~[ast::arg] =\n-        vec::append(~[{mode: ast::expl(ast::by_ref),\n-                      ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n-                      ident: cx.ident_of(~\"__s\"),\n-                      id: cx.next_id()},\n-                     {mode: ast::expl(ast::by_ref),\n-                      ty: v_ty,\n-                      ident: cx.ident_of(~\"__v\"),\n-                      id: cx.next_id()}],\n-                    tp_inputs);\n-\n-    let tps_map = map::HashMap();\n-    for vec::each2(tps, tp_inputs) |tp, arg| {\n-        let arg_ident = arg.ident;\n-        tps_map.insert(\n-            tp.ident,\n-            fn@(v: @ast::expr) -> ~[@ast::stmt] {\n-                let f = cx.var_ref(span, arg_ident);\n-                debug!(\"serializing type arg %s\", cx.str_of(arg_ident));\n-                ~[#ast[stmt]{$(f)($(v));}]\n-            });\n-    }\n-\n-    let ser_bnds = @~[\n-        ast::bound_trait(cx.ty_path(span,\n-                                    ~[cx.ident_of(~\"std\"),\n-                                      cx.ident_of(~\"serialization\"),\n-                                      cx.ident_of(~\"Serializer\")],\n-                                    ~[]))];\n-\n-    let ser_tps: ~[ast::ty_param] =\n-        vec::append(~[{ident: cx.ident_of(~\"__S\"),\n-                      id: cx.next_id(),\n-                      bounds: ser_bnds}],\n-                    vec::map(tps, |tp| cx.clone_ty_param(*tp)));\n-\n-    let ser_output: @ast::ty = @{id: cx.next_id(),\n-                                 node: ast::ty_nil,\n-                                 span: span};\n-\n-    let ser_blk = cx.blk(span,\n-                         f(cx, tps_map, #ast{ __s }, #ast{ __v }));\n-\n-    @{ident: cx.ident_of(~\"serialize_\" + cx.str_of(name)),\n-      attrs: ~[],\n-      id: cx.next_id(),\n-      node: ast::item_fn({inputs: ser_inputs,\n-                          output: ser_output,\n-                          cf: ast::return_val},\n-                         ast::impure_fn,\n-                         ser_tps,\n-                         ser_blk),\n-      vis: ast::public,\n-      span: span}\n-}\n-\n-// ______________________________________________________________________\n-\n-fn deser_path(cx: ext_ctxt, tps: deser_tps_map, path: @ast::path,\n-                    -d: @ast::expr) -> @ast::expr {\n-    // We want to take a path like a::b::c<...> and generate a call\n-    // like a::b::c::deserialize(d, ...), as described above.\n+fn mk_rec_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[ast::ty_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_ser_fields(cx, span, mk_rec_fields(fields));\n+\n+    // ast for `__s.emit_rec(|| $(fields))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_rec\")\n+        ),\n+        ~[cx.lambda_stmts(span, fields)]\n+    );\n \n-    let callee =\n-        cx.expr(\n-            path.span,\n-            ast::expr_path(\n-                cx.helper_path(path, ~\"deserialize\")));\n+    mk_ser_impl(cx, span, ident, tps, body)\n+}\n \n-    let ty_args = do vec::map(path.types) |ty| {\n-        let dv_expr = deser_ty(cx, tps, *ty, cx.clone(d));\n-        cx.lambda(cx.expr_blk(dv_expr))\n-    };\n+fn mk_rec_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[ast::ty_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_deser_fields(cx, span, mk_rec_fields(fields));\n+\n+    // ast for `read_rec(|| $(fields))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_rec\")\n+        ),\n+        ~[\n+            cx.lambda_expr(\n+                cx.expr(\n+                    span,\n+                    ast::expr_rec(fields, None)\n+                )\n+            )\n+        ]\n+    );\n+\n+    mk_deser_impl(cx, span, ident, tps, body)\n+}\n \n-    cx.expr(path.span, ast::expr_call(callee, vec::append(~[d], ty_args),\n-                                      false))\n+fn mk_struct_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[@ast::struct_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_ser_fields(cx, span, mk_struct_fields(fields));\n+\n+    // ast for `__s.emit_struct($(name), || $(fields))`\n+    let ser_body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_struct\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(ident)),\n+            cx.lambda_stmts(span, fields),\n+        ]\n+    );\n+\n+    mk_ser_impl(cx, span, ident, tps, ser_body)\n }\n \n-fn deser_lambda(cx: ext_ctxt, tps: deser_tps_map, ty: @ast::ty,\n-                -d: @ast::expr) -> @ast::expr {\n-    cx.lambda(cx.expr_blk(deser_ty(cx, tps, ty, move d)))\n+fn mk_struct_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[@ast::struct_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_deser_fields(cx, span, mk_struct_fields(fields));\n+\n+    // ast for `read_struct($(name), || $(fields))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_struct\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(ident)),\n+            cx.lambda_expr(\n+                cx.expr(\n+                    span,\n+                    ast::expr_struct(\n+                        cx.path(span, ~[ident]),\n+                        fields,\n+                        None\n+                    )\n+                )\n+            ),\n+        ]\n+    );\n+\n+    mk_deser_impl(cx, span, ident, tps, body)\n }\n \n-fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n-                  ty: @ast::ty, -d: @ast::expr) -> @ast::expr {\n-\n-    let ext_cx = cx; // required for #ast{}\n-\n-    match ty.node {\n-      ast::ty_nil => {\n-        #ast{ $(d).read_nil() }\n-      }\n-\n-      ast::ty_bot => {\n-        #ast{ fail }\n-      }\n-\n-      ast::ty_box(mt) => {\n-        let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n-        #ast{ @$(d).read_box($(l)) }\n-      }\n-\n-      // For unique evecs/estrs, just pass through to underlying vec or str\n-      ast::ty_uniq(mt) if is_vec_or_str(mt.ty) => {\n-        deser_ty(cx, tps, mt.ty, move d)\n-      }\n-\n-      ast::ty_uniq(mt) => {\n-        let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n-        #ast{ ~$(d).read_uniq($(l)) }\n-      }\n-\n-      ast::ty_ptr(_) | ast::ty_rptr(_, _) => {\n-        #ast{ fail }\n-      }\n-\n-      ast::ty_rec(flds) => {\n-        let fields = do vec::from_fn(vec::len(flds)) |fidx| {\n-            let fld = flds[fidx];\n-            let d = cx.clone(d);\n-            let f = cx.lit_str(fld.span, @cx.str_of(fld.node.ident));\n-            let i = cx.lit_uint(fld.span, fidx);\n-            let l = deser_lambda(cx, tps, fld.node.mt.ty, cx.clone(d));\n-            {node: {mutbl: fld.node.mt.mutbl,\n-                    ident: fld.node.ident,\n-                    expr: #ast{ $(d).read_rec_field($(f), $(i), $(l))} },\n-             span: fld.span}\n-        };\n-        let fld_expr = cx.expr(ty.span, ast::expr_rec(fields, None));\n-        let fld_lambda = cx.lambda(cx.expr_blk(fld_expr));\n-        #ast{ $(d).read_rec($(fld_lambda)) }\n-      }\n-\n-      ast::ty_fn(*) => {\n-        #ast{ fail }\n-      }\n-\n-      ast::ty_tup(tys) => {\n-        // Generate code like\n-        //\n-        // d.read_tup(3u) {||\n-        //   (d.read_tup_elt(0u, {||...}),\n-        //    d.read_tup_elt(1u, {||...}),\n-        //    d.read_tup_elt(2u, {||...}))\n-        // }\n-\n-        let arg_exprs = do vec::from_fn(vec::len(tys)) |i| {\n-            let idx = cx.lit_uint(ty.span, i);\n-            let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n-            #ast{ $(d).read_tup_elt($(idx), $(body)) }\n-        };\n-        let body =\n-            cx.lambda(cx.expr_blk(\n-                cx.expr(ty.span, ast::expr_tup(arg_exprs))));\n-        let sz = cx.lit_uint(ty.span, vec::len(tys));\n-        #ast{ $(d).read_tup($(sz), $(body)) }\n-      }\n-\n-      ast::ty_path(path, _) => {\n-        if vec::len(path.idents) == 1u &&\n-            vec::is_empty(path.types) {\n-            let ident = path.idents[0];\n-\n-            match tps.find(ident) {\n-              Some(f) => f(),\n-              None => deser_path(cx, tps, path, move d)\n-            }\n-        } else {\n-            deser_path(cx, tps, path, move d)\n+// Records and structs don't have the same fields types, but they share enough\n+// that if we extract the right subfields out we can share the serialization\n+// generator code.\n+type field = { span: span, ident: ast::ident, mutbl: ast::mutability };\n+\n+fn mk_rec_fields(fields: ~[ast::ty_field]) -> ~[field] {\n+    do fields.map |field| {\n+        {\n+            span: field.span,\n+            ident: field.node.ident,\n+            mutbl: field.node.mt.mutbl,\n         }\n-      }\n-\n-      ast::ty_mac(_) => {\n-        #ast{ fail }\n-      }\n+    }\n+}\n \n-      ast::ty_infer => {\n-        #ast{ fail }\n-      }\n+fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n+    do fields.map |field| {\n+        let (ident, mutbl) = match field.node.kind {\n+            ast::named_field(ident, mutbl, _) => (ident, mutbl),\n+            _ => fail ~\"[auto_serialize] does not support \\\n+                        unnamed fields\",\n+        };\n \n-      ast::ty_vec(mt) => {\n-        let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n-        #ast{ std::serialization::read_to_vec($(d), $(l)) }\n-      }\n+        {\n+            span: field.span,\n+            ident: ident,\n+            mutbl: match mutbl {\n+                ast::class_mutable => ast::m_mutbl,\n+                ast::class_immutable => ast::m_imm,\n+            },\n+        }\n+    }\n+}\n \n-      ast::ty_fixed_length(_, _) => {\n-        cx.span_unimpl(ty.span, ~\"deserialization for fixed length types\");\n-      }\n+fn mk_ser_fields(\n+    cx: ext_ctxt,\n+    span: span,\n+    fields: ~[field]\n+) -> ~[@ast::stmt] {\n+    do fields.mapi |idx, field| {\n+        // ast for `|| self.$(name).serialize(__s)`\n+        let expr_lambda = cx.lambda_expr(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_field(\n+                        span,\n+                        cx.expr_var(span, ~\"self\"),\n+                        field.ident\n+                    ),\n+                    cx.ident_of(~\"serialize\")\n+                ),\n+                ~[cx.expr_var(span, ~\"__s\")]\n+            )\n+        );\n+\n+        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n+        cx.stmt(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_var(span, ~\"__s\"),\n+                    cx.ident_of(~\"emit_field\")\n+                ),\n+                ~[\n+                    cx.lit_str(span, @cx.str_of(field.ident)),\n+                    cx.lit_uint(span, idx),\n+                    expr_lambda,\n+                ]\n+            )\n+        )\n     }\n }\n \n-fn mk_deser_fn(cx: ext_ctxt, span: span,\n-               name: ast::ident, tps: ~[ast::ty_param],\n-               f: fn(ext_ctxt, deser_tps_map, -v: @ast::expr) -> @ast::expr)\n-    -> @ast::item {\n-    let ext_cx = cx; // required for #ast\n-\n-    let tp_types = vec::map(tps, |tp| cx.ty_path(span, ~[tp.ident], ~[]));\n-    let v_ty = cx.ty_path(span, ~[name], tp_types);\n-\n-    let tp_inputs =\n-        vec::map(tps, |tp|\n-            {mode: ast::expl(ast::by_ref),\n-             ty: cx.ty_fn(span,\n-                          ~[],\n-                          cx.ty_path(span, ~[tp.ident], ~[])),\n-             ident: cx.ident_of(~\"__d\" + cx.str_of(tp.ident)),\n-             id: cx.next_id()});\n-\n-    debug!(\"tp_inputs = %?\", tp_inputs);\n-\n-    let deser_inputs: ~[ast::arg] =\n-        vec::append(~[{mode: ast::expl(ast::by_ref),\n-                      ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n-                      ident: cx.ident_of(~\"__d\"),\n-                      id: cx.next_id()}],\n-                    tp_inputs);\n-\n-    let tps_map = map::HashMap();\n-    for vec::each2(tps, tp_inputs) |tp, arg| {\n-        let arg_ident = arg.ident;\n-        tps_map.insert(\n-            tp.ident,\n-            fn@() -> @ast::expr {\n-                let f = cx.var_ref(span, arg_ident);\n-                #ast{ $(f)() }\n-            });\n-    }\n-\n-    let deser_bnds = @~[\n-        ast::bound_trait(cx.ty_path(\n+fn mk_deser_fields(\n+    cx: ext_ctxt,\n+    span: span,\n+    fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }]\n+) -> ~[ast::field] {\n+    do fields.mapi |idx, field| {\n+        // ast for `|| std::serialization::deserialize(__d)`\n+        let expr_lambda = cx.lambda(\n+            cx.expr_blk(\n+                cx.expr_call(\n+                    span,\n+                    cx.expr_path(span, ~[\n+                        cx.ident_of(~\"std\"),\n+                        cx.ident_of(~\"serialization\"),\n+                        cx.ident_of(~\"deserialize\"),\n+                    ]),\n+                    ~[cx.expr_var(span, ~\"__d\")]\n+                )\n+            )\n+        );\n+\n+        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n+        let expr: @ast::expr = cx.expr_call(\n             span,\n-            ~[cx.ident_of(~\"std\"), cx.ident_of(~\"serialization\"),\n-              cx.ident_of(~\"Deserializer\")],\n-            ~[]))];\n-\n-    let deser_tps: ~[ast::ty_param] =\n-        vec::append(~[{ident: cx.ident_of(~\"__D\"),\n-                      id: cx.next_id(),\n-                      bounds: deser_bnds}],\n-                    vec::map(tps, |tp| {\n-                        let cloned = cx.clone_ty_param(*tp);\n-                        {bounds: @(vec::append(*cloned.bounds,\n-                                               ~[ast::bound_copy])),\n-                         .. cloned}\n-                    }));\n-\n-    let deser_blk = cx.expr_blk(f(cx, tps_map, #ast[expr]{__d}));\n-\n-    @{ident: cx.ident_of(~\"deserialize_\" + cx.str_of(name)),\n-      attrs: ~[],\n-      id: cx.next_id(),\n-      node: ast::item_fn({inputs: deser_inputs,\n-                          output: v_ty,\n-                          cf: ast::return_val},\n-                         ast::impure_fn,\n-                         deser_tps,\n-                         deser_blk),\n-      vis: ast::public,\n-      span: span}\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_field\")\n+            ),\n+            ~[\n+                cx.lit_str(span, @cx.str_of(field.ident)),\n+                cx.lit_uint(span, idx),\n+                expr_lambda,\n+            ]\n+        );\n+\n+        {\n+            node: { mutbl: field.mutbl, ident: field.ident, expr: expr },\n+            span: span,\n+        }\n+    }\n }\n \n-fn ty_fns(cx: ext_ctxt, name: ast::ident,\n-          ty: @ast::ty, tps: ~[ast::ty_param])\n-    -> ~[@ast::item] {\n+fn mk_enum_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    enum_def: ast::enum_def,\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let body = mk_enum_ser_body(\n+        cx,\n+        span,\n+        ident,\n+        enum_def.variants\n+    );\n+\n+    mk_ser_impl(cx, span, ident, tps, body)\n+}\n \n-    let span = ty.span;\n-    ~[\n-        mk_ser_fn(cx, span, name, tps, |a,b,c,d| ser_ty(a, b, ty, move c,\n-                                                        move d)),\n-        mk_deser_fn(cx, span, name, tps, |a,b,c| deser_ty(a, b, ty, move c))\n-    ]\n+fn mk_enum_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    enum_def: ast::enum_def,\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let body = mk_enum_deser_body(\n+        cx,\n+        span,\n+        ident,\n+        enum_def.variants\n+    );\n+\n+    mk_deser_impl(cx, span, ident, tps, body)\n }\n \n-fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n-            e_span: span, variants: ~[ast::variant],\n-            -s: @ast::expr, -v: @ast::expr) -> ~[@ast::stmt] {\n-    let ext_cx = cx;\n-    let arms = do vec::from_fn(vec::len(variants)) |vidx| {\n-        let variant = variants[vidx];\n-        let v_span = variant.span;\n-        let v_name = variant.node.name;\n+fn ser_variant(\n+    cx: ext_ctxt,\n+    span: span,\n+    v_name: ast::ident,\n+    v_idx: uint,\n+    args: ~[ast::variant_arg]\n+) -> ast::arm {\n+    // Name the variant arguments.\n+    let names = args.mapi(|i, _arg| cx.ident_of(fmt!(\"__v%u\", i)));\n+\n+    // Bind the names to the variant argument type.\n+    let pats = args.mapi(|i, arg| cx.binder_pat(arg.ty.span, names[i]));\n+\n+    let pat_node = if pats.is_empty() {\n+        ast::pat_ident(\n+            ast::bind_by_implicit_ref,\n+            cx.path(span, ~[v_name]),\n+            None\n+        )\n+    } else {\n+        ast::pat_enum(\n+            cx.path(span, ~[v_name]),\n+            Some(pats)\n+        )\n+    };\n \n-        match variant.node.kind {\n-            ast::tuple_variant_kind(args) => {\n-                let variant_tys = vec::map(args, |a| a.ty);\n-\n-                ser_variant(\n-                    cx, tps, variant_tys, v_span, cx.clone(s),\n-\n-                    // Generate pattern var(v1, v2, v3)\n-                    |pats| {\n-                        if vec::is_empty(pats) {\n-                            ast::pat_ident(ast::bind_by_implicit_ref,\n-                                           cx.path(v_span, ~[v_name]),\n-                                           None)\n-                        } else {\n-                            ast::pat_enum(cx.path(v_span, ~[v_name]),\n-                                                  Some(pats))\n-                        }\n-                    },\n+    let pat = @{\n+        id: cx.next_id(),\n+        node: pat_node,\n+        span: span,\n+    };\n \n-                    // Generate body s.emit_enum_variant(\"foo\", 0u,\n-                    //                                   3u, {|| blk })\n-                    |-s, blk| {\n-                        let v_name = cx.lit_str(v_span, @cx.str_of(v_name));\n-                        let v_id = cx.lit_uint(v_span, vidx);\n-                        let sz = cx.lit_uint(v_span, vec::len(variant_tys));\n-                        let body = cx.lambda(blk);\n-                        #ast[expr]{\n-                            $(s).emit_enum_variant($(v_name), $(v_id),\n-                                                   $(sz), $(body))\n-                        }\n-                    },\n+    let stmts = do args.mapi |a_idx, _arg| {\n+        // ast for `__s.emit_enum_variant_arg`\n+        let expr_emit = cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum_variant_arg\")\n+        );\n \n-                    // Generate s.emit_enum_variant_arg(i, {|| blk })\n-                    |-s, i, blk| {\n-                        let idx = cx.lit_uint(v_span, i);\n-                        let body = cx.lambda(blk);\n-                        #ast[expr]{\n-                            $(s).emit_enum_variant_arg($(idx), $(body))\n-                        }\n-                    })\n-            }\n-            _ =>\n-                fail ~\"struct variants unimplemented for auto serialize\"\n-        }\n+        // ast for `|| $(v).serialize(__s)`\n+        let expr_serialize = cx.lambda_expr(\n+             cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_path(span, ~[names[a_idx]]),\n+                    cx.ident_of(~\"serialize\")\n+                ),\n+                ~[cx.expr_var(span, ~\"__s\")]\n+            )\n+        );\n+\n+        // ast for `$(expr_emit)($(a_idx), $(expr_serialize))`\n+        cx.stmt(\n+            cx.expr_call(\n+                span,\n+                expr_emit,\n+                ~[cx.lit_uint(span, a_idx), expr_serialize]\n+            )\n+        )\n     };\n-    let lam = cx.lambda(cx.blk(e_span, ~[cx.alt_stmt(arms, e_span, move v)]));\n-    let e_name = cx.lit_str(e_span, @cx.str_of(e_name));\n-    ~[#ast[stmt]{ $(s).emit_enum($(e_name), $(lam)) }]\n-}\n \n-fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n-              e_span: span, variants: ~[ast::variant],\n-              -d: @ast::expr) -> @ast::expr {\n-    let ext_cx = cx;\n-    let mut arms: ~[ast::arm] = do vec::from_fn(vec::len(variants)) |vidx| {\n-        let variant = variants[vidx];\n-        let v_span = variant.span;\n-        let v_name = variant.node.name;\n+    // ast for `__s.emit_enum_variant($(name), $(idx), $(sz), $(lambda))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum_variant\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(v_name)),\n+            cx.lit_uint(span, v_idx),\n+            cx.lit_uint(span, stmts.len()),\n+            cx.lambda_stmts(span, stmts),\n+        ]\n+    );\n+\n+    { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n+}\n \n-        let body;\n+fn mk_enum_ser_body(\n+    cx: ext_ctxt,\n+    span: span,\n+    name: ast::ident,\n+    variants: ~[ast::variant]\n+) -> @ast::expr {\n+    let arms = do variants.mapi |v_idx, variant| {\n         match variant.node.kind {\n-            ast::tuple_variant_kind(args) => {\n-                let tys = vec::map(args, |a| a.ty);\n-\n-                let arg_exprs = do vec::from_fn(vec::len(tys)) |i| {\n-                    let idx = cx.lit_uint(v_span, i);\n-                    let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n-                    #ast{ $(d).read_enum_variant_arg($(idx), $(body)) }\n-                };\n-\n-                body = {\n-                    if vec::is_empty(tys) {\n-                        // for a nullary variant v, do \"v\"\n-                        cx.var_ref(v_span, v_name)\n-                    } else {\n-                        // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n-                        cx.expr(v_span, ast::expr_call(\n-                            cx.var_ref(v_span, v_name), arg_exprs, false))\n-                    }\n-                };\n-            }\n+            ast::tuple_variant_kind(args) =>\n+                ser_variant(cx, span, variant.node.name, v_idx, args),\n             ast::struct_variant_kind(*) =>\n                 fail ~\"struct variants unimplemented\",\n             ast::enum_variant_kind(*) =>\n-                fail ~\"enum variants unimplemented\"\n+                fail ~\"enum variants unimplemented\",\n         }\n+    };\n+\n+    // ast for `match *self { $(arms) }`\n+    let match_expr = cx.expr(\n+        span,\n+        ast::expr_match(\n+            cx.expr(\n+                span,\n+                ast::expr_unary(ast::deref, cx.expr_var(span, ~\"self\"))\n+            ),\n+            arms\n+        )\n+    );\n+\n+    // ast for `__s.emit_enum($(name), || $(match_expr))`\n+    cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(name)),\n+            cx.lambda_expr(match_expr),\n+        ]\n+    )\n+}\n \n-        {pats: ~[@{id: cx.next_id(),\n-                  node: ast::pat_lit(cx.lit_uint(v_span, vidx)),\n-                  span: v_span}],\n-         guard: None,\n-         body: cx.expr_blk(body)}\n+fn mk_enum_deser_variant_nary(\n+    cx: ext_ctxt,\n+    span: span,\n+    name: ast::ident,\n+    args: ~[ast::variant_arg]\n+) -> @ast::expr {\n+    let args = do args.mapi |idx, _arg| {\n+        // ast for `|| std::serialization::deserialize(__d)`\n+        let expr_lambda = cx.lambda_expr(\n+            cx.expr_call(\n+                span,\n+                cx.expr_path(span, ~[\n+                    cx.ident_of(~\"std\"),\n+                    cx.ident_of(~\"serialization\"),\n+                    cx.ident_of(~\"deserialize\"),\n+                ]),\n+                ~[cx.expr_var(span, ~\"__d\")]\n+            )\n+        );\n+\n+        // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n+        cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_enum_variant_arg\")\n+            ),\n+            ~[cx.lit_uint(span, idx), expr_lambda]\n+        )\n     };\n \n-    let impossible_case = {pats: ~[@{id: cx.next_id(),\n-                                     node: ast::pat_wild,\n-                                     span: e_span}],\n-                        guard: None,\n-                        // FIXME #3198: proper error message\n-                           body: cx.expr_blk(cx.expr(e_span,\n-                                                     ast::expr_fail(None)))};\n-    arms += ~[impossible_case];\n-\n-    // Generate code like:\n-    let e_name = cx.lit_str(e_span, @cx.str_of(e_name));\n-    let alt_expr = cx.expr(e_span,\n-                           ast::expr_match(#ast{__i}, arms));\n-    let var_lambda = #ast{ |__i| $(alt_expr) };\n-    let read_var = #ast{ $(cx.clone(d)).read_enum_variant($(var_lambda)) };\n-    let read_lambda = cx.lambda(cx.expr_blk(read_var));\n-    #ast{ $(d).read_enum($(e_name), $(read_lambda)) }\n+    // ast for `$(name)($(args))`\n+    cx.expr_call(span, cx.expr_path(span, ~[name]), args)\n }\n \n-fn enum_fns(cx: ext_ctxt, e_name: ast::ident, e_span: span,\n-               variants: ~[ast::variant], tps: ~[ast::ty_param])\n-    -> ~[@ast::item] {\n-    ~[\n-        mk_ser_fn(cx, e_span, e_name, tps,\n-                  |a,b,c,d| ser_enum(a, b, e_name, e_span, variants, move c,\n-                                     move d)),\n-        mk_deser_fn(cx, e_span, e_name, tps,\n-          |a,b,c| deser_enum(a, b, e_name, e_span, variants, move c))\n-    ]\n+fn mk_enum_deser_body(\n+    cx: ext_ctxt,\n+    span: span,\n+    name: ast::ident,\n+    variants: ~[ast::variant]\n+) -> @ast::expr {\n+    let mut arms = do variants.mapi |v_idx, variant| {\n+        let body = match variant.node.kind {\n+            ast::tuple_variant_kind(args) => {\n+                if args.is_empty() {\n+                    // for a nullary variant v, do \"v\"\n+                    cx.expr_path(span, ~[variant.node.name])\n+                } else {\n+                    // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n+                    mk_enum_deser_variant_nary(\n+                        cx,\n+                        span,\n+                        variant.node.name,\n+                        args\n+                    )\n+                }\n+            },\n+            ast::struct_variant_kind(*) =>\n+                fail ~\"struct variants unimplemented\",\n+            ast::enum_variant_kind(*) =>\n+                fail ~\"enum variants unimplemented\",\n+        };\n+\n+        let pat = @{\n+            id: cx.next_id(),\n+            node: ast::pat_lit(cx.lit_uint(span, v_idx)),\n+            span: span,\n+        };\n+\n+        {\n+            pats: ~[pat],\n+            guard: None,\n+            body: cx.expr_blk(body),\n+        }\n+    };\n+\n+    let impossible_case = {\n+        pats: ~[@{ id: cx.next_id(), node: ast::pat_wild, span: span}],\n+        guard: None,\n+\n+        // FIXME(#3198): proper error message\n+        body: cx.expr_blk(cx.expr(span, ast::expr_fail(None))),\n+    };\n+\n+    arms.push(impossible_case);\n+\n+    // ast for `|i| { match i { $(arms) } }`\n+    let expr_lambda = cx.expr(\n+        span,\n+        ast::expr_fn_block(\n+            {\n+                inputs: ~[{\n+                    mode: ast::infer(cx.next_id()),\n+                    ty: @{\n+                        id: cx.next_id(),\n+                        node: ast::ty_infer,\n+                        span: span\n+                    },\n+                    ident: cx.ident_of(~\"i\"),\n+                    id: cx.next_id(),\n+                }],\n+                output: @{\n+                    id: cx.next_id(),\n+                    node: ast::ty_infer,\n+                    span: span,\n+                },\n+                cf: ast::return_val,\n+            },\n+            cx.expr_blk(\n+                cx.expr(\n+                    span,\n+                    ast::expr_match(cx.expr_var(span, ~\"i\"), arms)\n+                )\n+            ),\n+            @~[]\n+        )\n+    );\n+\n+    // ast for `__d.read_enum_variant($(expr_lambda))`\n+    let expr_lambda = cx.lambda_expr(\n+        cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_enum_variant\")\n+            ),\n+            ~[expr_lambda]\n+        )\n+    );\n+\n+    // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n+    cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_enum\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(name)),\n+            expr_lambda\n+        ]\n+    )\n }"}, {"sha": "b3102f8b4f72d57604ab5518c04ee16e56093ad6", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "modified", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -214,120 +214,6 @@ fn expand_auto_deserialize(\n     }\n }\n \n-priv impl ext_ctxt {\n-    fn expr(span: span, node: ast::expr_) -> @ast::expr {\n-        @{id: self.next_id(), callee_id: self.next_id(),\n-          node: node, span: span}\n-    }\n-\n-    fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, rp: None, types: ~[]}\n-    }\n-\n-    fn path_tps(span: span, strs: ~[ast::ident],\n-                tps: ~[@ast::ty]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, rp: None, types: tps}\n-    }\n-\n-    fn ty_path(span: span, strs: ~[ast::ident],\n-               tps: ~[@ast::ty]) -> @ast::ty {\n-        @{id: self.next_id(),\n-          node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n-          span: span}\n-    }\n-\n-    fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n-        let path = @{span: span, global: false, idents: ~[nm],\n-                     rp: None, types: ~[]};\n-        @{id: self.next_id(),\n-          node: ast::pat_ident(ast::bind_by_implicit_ref,\n-                               path,\n-                               None),\n-          span: span}\n-    }\n-\n-    fn stmt(expr: @ast::expr) -> @ast::stmt {\n-        @{node: ast::stmt_semi(expr, self.next_id()),\n-          span: expr.span}\n-    }\n-\n-    fn lit_str(span: span, s: @~str) -> @ast::expr {\n-        self.expr(\n-            span,\n-            ast::expr_vstore(\n-                self.expr(\n-                    span,\n-                    ast::expr_lit(\n-                        @{node: ast::lit_str(s),\n-                          span: span})),\n-                ast::expr_vstore_uniq))\n-    }\n-\n-    fn lit_uint(span: span, i: uint) -> @ast::expr {\n-        self.expr(\n-            span,\n-            ast::expr_lit(\n-                @{node: ast::lit_uint(i as u64, ast::ty_u),\n-                  span: span}))\n-    }\n-\n-    fn lambda(blk: ast::blk) -> @ast::expr {\n-        let ext_cx = self;\n-        let blk_e = self.expr(blk.span, ast::expr_block(blk));\n-        #ast{ || $(blk_e) }\n-    }\n-\n-    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n-        {node: {view_items: ~[],\n-                stmts: stmts,\n-                expr: None,\n-                id: self.next_id(),\n-                rules: ast::default_blk},\n-         span: span}\n-    }\n-\n-    fn expr_blk(expr: @ast::expr) -> ast::blk {\n-        {node: {view_items: ~[],\n-                stmts: ~[],\n-                expr: Some(expr),\n-                id: self.next_id(),\n-                rules: ast::default_blk},\n-         span: expr.span}\n-    }\n-\n-    fn expr_path(span: span, strs: ~[ast::ident]) -> @ast::expr {\n-        self.expr(span, ast::expr_path(self.path(span, strs)))\n-    }\n-\n-    fn expr_var(span: span, var: ~str) -> @ast::expr {\n-        self.expr_path(span, ~[self.ident_of(var)])\n-    }\n-\n-    fn expr_field(\n-        span: span,\n-        expr: @ast::expr,\n-        ident: ast::ident\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_field(expr, ident, ~[]))\n-    }\n-\n-    fn expr_call(\n-        span: span,\n-        expr: @ast::expr,\n-        args: ~[@ast::expr]\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_call(expr, args, false))\n-    }\n-\n-    fn lambda_expr(expr: @ast::expr) -> @ast::expr {\n-        self.lambda(self.expr_blk(expr))\n-    }\n-\n-    fn lambda_stmts(span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n-        self.lambda(self.blk(span, stmts))\n-    }\n-}\n-\n fn mk_impl(\n     cx: ext_ctxt,\n     span: span,"}, {"sha": "ab56b6bb322edc154f3cc46d0b9ca59f1d7c2e08", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -81,8 +81,6 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n                             builtin_item_tt(\n                                 ext::tt::macro_rules::add_new_extension));\n     syntax_expanders.insert(~\"fmt\", builtin(ext::fmt::expand_syntax_ext));\n-    syntax_expanders.insert(~\"auto_serialize\",\n-                            item_decorator(ext::auto_serialize::expand));\n     syntax_expanders.insert(\n         ~\"auto_serialize2\",\n         item_decorator(ext::auto_serialize2::expand_auto_serialize));\n@@ -143,16 +141,10 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n     syntax_expanders.insert(~\"fmt\", builtin(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(\n         ~\"auto_serialize\",\n-        item_decorator(ext::auto_serialize2::expand_auto_serialize));\n+        item_decorator(ext::auto_serialize::expand_auto_serialize));\n     syntax_expanders.insert(\n         ~\"auto_deserialize\",\n-        item_decorator(ext::auto_serialize2::expand_auto_deserialize));\n-    syntax_expanders.insert(\n-        ~\"auto_serialize2\",\n-        item_decorator(ext::auto_serialize2::expand_auto_serialize));\n-    syntax_expanders.insert(\n-        ~\"auto_deserialize2\",\n-        item_decorator(ext::auto_serialize2::expand_auto_deserialize));\n+        item_decorator(ext::auto_serialize::expand_auto_deserialize));\n     syntax_expanders.insert(~\"env\", builtin(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(~\"concat_idents\",\n                             builtin(ext::concat_idents::expand_syntax_ext));"}, {"sha": "b63260997f75b903ca6ec9363aebf168e568b7cd", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -2,6 +2,8 @@ use util::interner;\n use util::interner::interner;\n use std::map::HashMap;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum binop {\n@@ -17,6 +19,8 @@ enum binop {\n     SHR,\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum token {\n@@ -75,6 +79,8 @@ enum token {\n     EOF,\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n /// For interpolation during macro expansion."}, {"sha": "4c29fc5512a79ade2eb88840893766857a9e8b0f", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -128,9 +128,9 @@ mod ext {\n     mod ident_to_str;\n     #[legacy_exports]\n     mod log_syntax;\n-    #[cfg(stage0)]\n     #[legacy_exports]\n     mod auto_serialize;\n+    #[cfg(stage0)]\n     #[legacy_exports]\n     mod auto_serialize2;\n     #[legacy_exports]"}, {"sha": "6b8c995ffd26198c55ddd93e52ebd47297fe8b5f", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 123, "deletions": 122, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -1,8 +1,9 @@\n // Decoding metadata from a single crate's metadata\n \n-use std::{ebml2, map};\n+use std::ebml;\n+use std::map;\n use std::map::HashMap;\n-use std::serialization2::deserialize;\n+use std::serialization::deserialize;\n use io::WriterUtil;\n use dvec::DVec;\n use syntax::{ast, ast_util};\n@@ -64,25 +65,25 @@ export translate_def_id;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml2::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n-   Option<ebml2::Doc> {\n-    let index = ebml2::get_doc(d, tag_index);\n-    let table = ebml2::get_doc(index, tag_index_table);\n+fn lookup_hash(d: ebml::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n+   Option<ebml::Doc> {\n+    let index = ebml::get_doc(d, tag_index);\n+    let table = ebml::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n     let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4u) as uint;\n-    let tagged_doc = ebml2::doc_at(d.data, pos);\n+    let tagged_doc = ebml::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n-    for ebml2::tagged_docs(tagged_doc.doc, belt) |elt| {\n+    for ebml::tagged_docs(tagged_doc.doc, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::view(*elt.data, elt.start + 4u, elt.end)) {\n-            return Some(ebml2::doc_at(d.data, pos).doc);\n+            return Some(ebml::doc_at(d.data, pos).doc);\n         }\n     };\n     None\n }\n \n-fn maybe_find_item(item_id: int, items: ebml2::Doc) -> Option<ebml2::Doc> {\n+fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         return io::u64_from_be_bytes(vec::view(bytes, 0u, 4u), 0u, 4u) as int\n             == item_id;\n@@ -92,14 +93,14 @@ fn maybe_find_item(item_id: int, items: ebml2::Doc) -> Option<ebml2::Doc> {\n                 item_id.hash() as uint)\n }\n \n-fn find_item(item_id: int, items: ebml2::Doc) -> ebml2::Doc {\n+fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n     return maybe_find_item(item_id, items).get();\n }\n \n-// Looks up an item in the given metadata and returns an ebml2 doc pointing\n+// Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-fn lookup_item(item_id: int, data: @~[u8]) -> ebml2::Doc {\n-    let items = ebml2::get_doc(ebml2::Doc(data), tag_items);\n+fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n+    let items = ebml::get_doc(ebml::Doc(data), tag_items);\n     match maybe_find_item(item_id, items) {\n        None => fail(fmt!(\"lookup_item: id not found: %d\", item_id)),\n        Some(d) => d\n@@ -137,9 +138,9 @@ impl Family : cmp::Eq {\n     pure fn ne(other: &Family) -> bool { !self.eq(other) }\n }\n \n-fn item_family(item: ebml2::Doc) -> Family {\n-    let fam = ebml2::get_doc(item, tag_items_data_item_family);\n-    match ebml2::doc_as_u8(fam) as char {\n+fn item_family(item: ebml::Doc) -> Family {\n+    let fam = ebml::get_doc(item, tag_items_data_item_family);\n+    match ebml::doc_as_u8(fam) as char {\n       'c' => Const,\n       'f' => Fn,\n       'u' => UnsafeFn,\n@@ -165,78 +166,78 @@ fn item_family(item: ebml2::Doc) -> Family {\n     }\n }\n \n-fn item_symbol(item: ebml2::Doc) -> ~str {\n-    let sym = ebml2::get_doc(item, tag_items_data_item_symbol);\n-    return str::from_bytes(ebml2::doc_data(sym));\n+fn item_symbol(item: ebml::Doc) -> ~str {\n+    let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n+    return str::from_bytes(ebml::doc_data(sym));\n }\n \n-fn item_parent_item(d: ebml2::Doc) -> Option<ast::def_id> {\n-    for ebml2::tagged_docs(d, tag_items_data_parent_item) |did| {\n-        return Some(ebml2::with_doc_data(did, |d| parse_def_id(d)));\n+fn item_parent_item(d: ebml::Doc) -> Option<ast::def_id> {\n+    for ebml::tagged_docs(d, tag_items_data_parent_item) |did| {\n+        return Some(ebml::with_doc_data(did, |d| parse_def_id(d)));\n     }\n     None\n }\n \n-fn item_def_id(d: ebml2::Doc, cdata: cmd) -> ast::def_id {\n-    let tagdoc = ebml2::get_doc(d, tag_def_id);\n-    return translate_def_id(cdata, ebml2::with_doc_data(tagdoc,\n+fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n+    let tagdoc = ebml::get_doc(d, tag_def_id);\n+    return translate_def_id(cdata, ebml::with_doc_data(tagdoc,\n                                                     |d| parse_def_id(d)));\n }\n \n-fn each_reexport(d: ebml2::Doc, f: fn(ebml2::Doc) -> bool) {\n-    for ebml2::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n+fn each_reexport(d: ebml::Doc, f: fn(ebml::Doc) -> bool) {\n+    for ebml::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n         if !f(reexport_doc) {\n             return;\n         }\n     }\n }\n \n-fn field_mutability(d: ebml2::Doc) -> ast::class_mutability {\n+fn field_mutability(d: ebml::Doc) -> ast::class_mutability {\n     // Use maybe_get_doc in case it's a method\n     option::map_default(\n-        &ebml2::maybe_get_doc(d, tag_class_mut),\n+        &ebml::maybe_get_doc(d, tag_class_mut),\n         ast::class_immutable,\n         |d| {\n-            match ebml2::doc_as_u8(*d) as char {\n+            match ebml::doc_as_u8(*d) as char {\n               'm' => ast::class_mutable,\n               _   => ast::class_immutable\n             }\n         })\n }\n \n-fn variant_disr_val(d: ebml2::Doc) -> Option<int> {\n-    do option::chain(ebml2::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n-        int::parse_bytes(ebml2::doc_data(val_doc), 10u)\n+fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n+    do option::chain(ebml::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n+        int::parse_bytes(ebml::doc_data(val_doc), 10u)\n     }\n }\n \n-fn doc_type(doc: ebml2::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n-    let tp = ebml2::get_doc(doc, tag_items_data_item_type);\n+fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n+    let tp = ebml::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx, |did| {\n         translate_def_id(cdata, did)\n     })\n }\n \n-fn item_type(item_id: ast::def_id, item: ebml2::Doc,\n+fn item_type(item_id: ast::def_id, item: ebml::Doc,\n              tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let t = doc_type(item, tcx, cdata);\n     if family_names_type(item_family(item)) {\n         ty::mk_with_id(tcx, t, item_id)\n     } else { t }\n }\n \n-fn item_impl_traits(item: ebml2::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n+fn item_impl_traits(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n     let mut results = ~[];\n-    for ebml2::tagged_docs(item, tag_impl_trait) |ity| {\n+    for ebml::tagged_docs(item, tag_impl_trait) |ity| {\n         results.push(doc_type(ity, tcx, cdata));\n     };\n     results\n }\n \n-fn item_ty_param_bounds(item: ebml2::Doc, tcx: ty::ctxt, cdata: cmd)\n+fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n     -> @~[ty::param_bounds] {\n     let mut bounds = ~[];\n-    for ebml2::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n+    for ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, |did| {\n             translate_def_id(cdata, did)\n         });\n@@ -245,42 +246,42 @@ fn item_ty_param_bounds(item: ebml2::Doc, tcx: ty::ctxt, cdata: cmd)\n     @bounds\n }\n \n-fn item_ty_region_param(item: ebml2::Doc) -> Option<ty::region_variance> {\n-    ebml2::maybe_get_doc(item, tag_region_param).map(|doc| {\n-        deserialize(&ebml2::Deserializer(*doc))\n+fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n+    ebml::maybe_get_doc(item, tag_region_param).map(|doc| {\n+        deserialize(&ebml::Deserializer(*doc))\n     })\n }\n \n-fn item_ty_param_count(item: ebml2::Doc) -> uint {\n+fn item_ty_param_count(item: ebml::Doc) -> uint {\n     let mut n = 0u;\n-    ebml2::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n+    ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n                       |_p| { n += 1u; true } );\n     n\n }\n \n-fn enum_variant_ids(item: ebml2::Doc, cdata: cmd) -> ~[ast::def_id] {\n+fn enum_variant_ids(item: ebml::Doc, cdata: cmd) -> ~[ast::def_id] {\n     let mut ids: ~[ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n-    for ebml2::tagged_docs(item, v) |p| {\n-        let ext = ebml2::with_doc_data(p, |d| parse_def_id(d));\n+    for ebml::tagged_docs(item, v) |p| {\n+        let ext = ebml::with_doc_data(p, |d| parse_def_id(d));\n         ids.push({crate: cdata.cnum, node: ext.node});\n     };\n     return ids;\n }\n \n-fn item_path(intr: @ident_interner, item_doc: ebml2::Doc) -> ast_map::path {\n-    let path_doc = ebml2::get_doc(item_doc, tag_path);\n+fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n+    let path_doc = ebml::get_doc(item_doc, tag_path);\n \n-    let len_doc = ebml2::get_doc(path_doc, tag_path_len);\n-    let len = ebml2::doc_as_u32(len_doc) as uint;\n+    let len_doc = ebml::get_doc(path_doc, tag_path_len);\n+    let len = ebml::doc_as_u32(len_doc) as uint;\n \n     let mut result = vec::with_capacity(len);\n-    for ebml2::docs(path_doc) |tag, elt_doc| {\n+    for ebml::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n-            let str = ebml2::doc_as_str(elt_doc);\n+            let str = ebml::doc_as_str(elt_doc);\n             result.push(ast_map::path_mod(intr.intern(@str)));\n         } else if tag == tag_path_elt_name {\n-            let str = ebml2::doc_as_str(elt_doc);\n+            let str = ebml::doc_as_str(elt_doc);\n             result.push(ast_map::path_name(intr.intern(@str)));\n         } else {\n             // ignore tag_path_len element\n@@ -290,12 +291,12 @@ fn item_path(intr: @ident_interner, item_doc: ebml2::Doc) -> ast_map::path {\n     return result;\n }\n \n-fn item_name(intr: @ident_interner, item: ebml2::Doc) -> ast::ident {\n-    let name = ebml2::get_doc(item, tag_paths_data_name);\n-    intr.intern(@str::from_bytes(ebml2::doc_data(name)))\n+fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n+    let name = ebml::get_doc(item, tag_paths_data_name);\n+    intr.intern(@str::from_bytes(ebml::doc_data(name)))\n }\n \n-fn item_to_def_like(item: ebml2::Doc, did: ast::def_id, cnum: ast::crate_num)\n+fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n         -> def_like {\n     let fam = item_family(item);\n     match fam {\n@@ -367,10 +368,10 @@ fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n \n fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                    name: ast::ident) -> ast::def_id {\n-    let items = ebml2::get_doc(ebml2::Doc(cdata.data), tag_items);\n+    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n     let mut found = None;\n-    for ebml2::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n-        let m_did = ebml2::with_doc_data(mid, |d| parse_def_id(d));\n+    for ebml::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n+        let m_did = ebml::with_doc_data(mid, |d| parse_def_id(d));\n         if item_name(intr, find_item(m_did.node, items)) == name {\n             found = Some(translate_def_id(cdata, m_did));\n         }\n@@ -380,14 +381,14 @@ fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n \n fn get_class_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                     name: ast::ident) -> ast::def_id {\n-    let items = ebml2::get_doc(ebml2::Doc(cdata.data), tag_items);\n+    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n       Some(it) => it,\n       None => fail (fmt!(\"get_class_method: class id not found \\\n                               when looking up method %s\", *intr.get(name)))\n     };\n-    for ebml2::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n+    for ebml::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n         let m_did = item_def_id(mid, cdata);\n         if item_name(intr, mid) == name {\n             found = Some(m_did);\n@@ -401,16 +402,16 @@ fn get_class_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n }\n \n fn class_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n-    let items = ebml2::get_doc(ebml2::Doc(cdata.data), tag_items);\n+    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n             Some(it) => it,\n             None     => fail (fmt!(\"class_dtor: class id not found \\\n               when looking up dtor for %d\", id))\n     };\n-    for ebml2::tagged_docs(cls_items, tag_item_dtor) |doc| {\n-         let doc1 = ebml2::get_doc(doc, tag_def_id);\n-         let did = ebml2::with_doc_data(doc1, |d| parse_def_id(d));\n+    for ebml::tagged_docs(cls_items, tag_item_dtor) |doc| {\n+         let doc1 = ebml::get_doc(doc, tag_def_id);\n+         let did = ebml::with_doc_data(doc1, |d| parse_def_id(d));\n          found = Some(translate_def_id(cdata, did));\n     };\n     found\n@@ -452,14 +453,14 @@ fn path_entry(path_string: ~str, def_like: def_like) -> path_entry {\n \n /// Iterates over all the paths in the given crate.\n fn each_path(intr: @ident_interner, cdata: cmd, f: fn(path_entry) -> bool) {\n-    let root = ebml2::Doc(cdata.data);\n-    let items = ebml2::get_doc(root, tag_items);\n-    let items_data = ebml2::get_doc(items, tag_items_data);\n+    let root = ebml::Doc(cdata.data);\n+    let items = ebml::get_doc(root, tag_items);\n+    let items_data = ebml::get_doc(items, tag_items_data);\n \n     let mut broken = false;\n \n     // First, go through all the explicit items.\n-    for ebml2::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n+    for ebml::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n         if !broken {\n             let path = ast_map::path_to_str_with_sep(\n                 item_path(intr, item_doc), ~\"::\", intr);\n@@ -482,16 +483,16 @@ fn each_path(intr: @ident_interner, cdata: cmd, f: fn(path_entry) -> bool) {\n             for each_reexport(item_doc) |reexport_doc| {\n                 if !broken {\n                     let def_id_doc =\n-                        ebml2::get_doc(reexport_doc,\n+                        ebml::get_doc(reexport_doc,\n                             tag_items_data_item_reexport_def_id);\n                     let def_id =\n-                        ebml2::with_doc_data(def_id_doc, |d| parse_def_id(d));\n+                        ebml::with_doc_data(def_id_doc, |d| parse_def_id(d));\n                     let def_id = translate_def_id(cdata, def_id);\n \n                     let reexport_name_doc =\n-                        ebml2::get_doc(reexport_doc,\n+                        ebml::get_doc(reexport_doc,\n                                       tag_items_data_item_reexport_name);\n-                    let reexport_name = ebml2::doc_as_str(reexport_name_doc);\n+                    let reexport_name = ebml::doc_as_str(reexport_name_doc);\n \n                     let reexport_path;\n                     if path == ~\"\" {\n@@ -540,7 +541,7 @@ type decode_inlined_item = fn(\n     cdata: cstore::crate_metadata,\n     tcx: ty::ctxt,\n     path: ast_map::path,\n-    par_doc: ebml2::Doc) -> Option<ast::inlined_item>;\n+    par_doc: ebml::Doc) -> Option<ast::inlined_item>;\n \n fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n                       id: ast::node_id,\n@@ -571,7 +572,7 @@ fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                      tcx: ty::ctxt) -> ~[ty::variant_info] {\n     let data = cdata.data;\n-    let items = ebml2::get_doc(ebml2::Doc(data), tag_items);\n+    let items = ebml::get_doc(ebml::Doc(data), tag_items);\n     let item = find_item(id, items);\n     let mut infos: ~[ty::variant_info] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n@@ -609,7 +610,7 @@ type method_info = {\n \n type _impl = {did: ast::def_id, ident: ast::ident, methods: ~[@method_info]};\n \n-fn get_self_ty(item: ebml2::Doc) -> ast::self_ty_ {\n+fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n     fn get_mutability(ch: u8) -> ast::mutability {\n         match ch as char {\n             'i' => { ast::m_imm }\n@@ -621,8 +622,8 @@ fn get_self_ty(item: ebml2::Doc) -> ast::self_ty_ {\n         }\n     }\n \n-    let self_type_doc = ebml2::get_doc(item, tag_item_trait_method_self_ty);\n-    let string = ebml2::doc_as_str(self_type_doc);\n+    let self_type_doc = ebml::get_doc(item, tag_item_trait_method_self_ty);\n+    let string = ebml::doc_as_str(self_type_doc);\n \n     let self_ty_kind = string[0];\n     match self_ty_kind as char {\n@@ -638,11 +639,11 @@ fn get_self_ty(item: ebml2::Doc) -> ast::self_ty_ {\n     }\n }\n \n-fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml2::Doc,\n+fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n                      base_tps: uint) -> ~[@method_info] {\n     let mut rslt = ~[];\n-    for ebml2::tagged_docs(item, tag_item_impl_method) |doc| {\n-        let m_did = ebml2::with_doc_data(doc, |d| parse_def_id(d));\n+    for ebml::tagged_docs(item, tag_item_impl_method) |doc| {\n+        let m_did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         let self_ty = get_self_ty(mth_item);\n         rslt.push(@{did: translate_def_id(cdata, m_did),\n@@ -662,8 +663,8 @@ fn get_impls_for_mod(intr: @ident_interner, cdata: cmd,\n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data);\n     let mut result = ~[];\n-    for ebml2::tagged_docs(mod_item, tag_mod_impl) |doc| {\n-        let did = ebml2::with_doc_data(doc, |d| parse_def_id(d));\n+    for ebml::tagged_docs(mod_item, tag_mod_impl) |doc| {\n+        let did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n         let local_did = translate_def_id(cdata, did);\n         debug!(\"(get impls for mod) getting did %? for '%?'\",\n                local_did, name);\n@@ -690,7 +691,7 @@ fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    for ebml2::tagged_docs(item, tag_item_trait_method) |mth| {\n+    for ebml::tagged_docs(item, tag_item_trait_method) |mth| {\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n@@ -722,7 +723,7 @@ fn get_method_names_if_trait(intr: @ident_interner, cdata: cmd,\n     }\n \n     let resulting_methods = @DVec();\n-    for ebml2::tagged_docs(item, tag_item_trait_method) |method| {\n+    for ebml::tagged_docs(item, tag_item_trait_method) |method| {\n         resulting_methods.push(\n             (item_name(intr, method), get_self_ty(method)));\n     }\n@@ -734,8 +735,8 @@ fn get_item_attrs(cdata: cmd,\n                   f: fn(~[@ast::meta_item])) {\n \n     let item = lookup_item(node_id, cdata.data);\n-    for ebml2::tagged_docs(item, tag_attributes) |attributes| {\n-        for ebml2::tagged_docs(attributes, tag_attribute) |attribute| {\n+    for ebml::tagged_docs(item, tag_attributes) |attributes| {\n+        for ebml::tagged_docs(attributes, tag_attribute) |attribute| {\n             f(get_meta_items(attribute));\n         }\n     }\n@@ -747,7 +748,7 @@ fn get_class_members(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    for ebml2::tagged_docs(item, tag_item_field) |an_item| {\n+    for ebml::tagged_docs(item, tag_item_field) |an_item| {\n        let f = item_family(an_item);\n        if p(f) {\n           let name = item_name(intr, an_item);\n@@ -787,15 +788,15 @@ fn family_names_type(fam: Family) -> bool {\n     match fam { Type | Mod | Trait => true, _ => false }\n }\n \n-fn read_path(d: ebml2::Doc) -> {path: ~str, pos: uint} {\n-    let desc = ebml2::doc_data(d);\n+fn read_path(d: ebml::Doc) -> {path: ~str, pos: uint} {\n+    let desc = ebml::doc_data(d);\n     let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::from_bytes(pathbytes);\n     return {path: path, pos: pos};\n }\n \n-fn describe_def(items: ebml2::Doc, id: ast::def_id) -> ~str {\n+fn describe_def(items: ebml::Doc, id: ast::def_id) -> ~str {\n     if id.crate != ast::local_crate { return ~\"external\"; }\n     let it = match maybe_find_item(id.node, items) {\n         Some(it) => it,\n@@ -830,36 +831,36 @@ fn item_family_to_str(fam: Family) -> ~str {\n     }\n }\n \n-fn get_meta_items(md: ebml2::Doc) -> ~[@ast::meta_item] {\n+fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n     let mut items: ~[@ast::meta_item] = ~[];\n-    for ebml2::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n-        let nd = ebml2::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(ebml2::doc_data(nd));\n+    for ebml::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n+        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::from_bytes(ebml::doc_data(nd));\n         items.push(attr::mk_word_item(n));\n     };\n-    for ebml2::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n-        let nd = ebml2::get_doc(meta_item_doc, tag_meta_item_name);\n-        let vd = ebml2::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = str::from_bytes(ebml2::doc_data(nd));\n-        let v = str::from_bytes(ebml2::doc_data(vd));\n+    for ebml::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n+        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n+        let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n+        let n = str::from_bytes(ebml::doc_data(nd));\n+        let v = str::from_bytes(ebml::doc_data(vd));\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n         items.push(attr::mk_name_value_item_str(n, v));\n     };\n-    for ebml2::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n-        let nd = ebml2::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(ebml2::doc_data(nd));\n+    for ebml::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n+        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n         items.push(attr::mk_list_item(n, subitems));\n     };\n     return items;\n }\n \n-fn get_attributes(md: ebml2::Doc) -> ~[ast::attribute] {\n+fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n     let mut attrs: ~[ast::attribute] = ~[];\n-    match ebml2::maybe_get_doc(md, tag_attributes) {\n+    match ebml::maybe_get_doc(md, tag_attributes) {\n       option::Some(attrs_d) => {\n-        for ebml2::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n+        for ebml::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n@@ -877,13 +878,13 @@ fn get_attributes(md: ebml2::Doc) -> ~[ast::attribute] {\n }\n \n fn list_meta_items(intr: @ident_interner,\n-                   meta_items: ebml2::Doc, out: io::Writer) {\n+                   meta_items: ebml::Doc, out: io::Writer) {\n     for get_meta_items(meta_items).each |mi| {\n         out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(*mi, intr)));\n     }\n }\n \n-fn list_crate_attributes(intr: @ident_interner, md: ebml2::Doc, hash: ~str,\n+fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: ~str,\n                          out: io::Writer) {\n     out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n@@ -895,21 +896,21 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml2::Doc, hash: ~str,\n }\n \n fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n-    return get_attributes(ebml2::Doc(data));\n+    return get_attributes(ebml::Doc(data));\n }\n \n type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n                   vers: ~str, hash: ~str};\n \n fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n-    let cratedoc = ebml2::Doc(data);\n-    let depsdoc = ebml2::get_doc(cratedoc, tag_crate_deps);\n+    let cratedoc = ebml::Doc(data);\n+    let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: ebml2::Doc, tag_: uint) -> ~str {\n-        str::from_bytes(ebml2::doc_data(ebml2::get_doc(doc, tag_)))\n+    fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n+        str::from_bytes(ebml::doc_data(ebml::get_doc(doc, tag_)))\n     }\n-    for ebml2::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n+    for ebml::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push({cnum: crate_num,\n                   name: intr.intern(@docstr(depdoc, tag_crate_dep_name)),\n                   vers: docstr(depdoc, tag_crate_dep_vers),\n@@ -932,9 +933,9 @@ fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: io::Writer) {\n }\n \n fn get_crate_hash(data: @~[u8]) -> ~str {\n-    let cratedoc = ebml2::Doc(data);\n-    let hashdoc = ebml2::get_doc(cratedoc, tag_crate_hash);\n-    return str::from_bytes(ebml2::doc_data(hashdoc));\n+    let cratedoc = ebml::Doc(data);\n+    let hashdoc = ebml::get_doc(cratedoc, tag_crate_hash);\n+    return str::from_bytes(ebml::doc_data(hashdoc));\n }\n \n fn get_crate_vers(data: @~[u8]) -> ~str {\n@@ -988,7 +989,7 @@ fn get_crate_module_paths(intr: @ident_interner, cdata: cmd)\n fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n                        out: io::Writer) {\n     let hash = get_crate_hash(bytes);\n-    let md = ebml2::Doc(bytes);\n+    let md = ebml::Doc(bytes);\n     list_crate_attributes(intr, md, hash, out);\n     list_crate_deps(intr, bytes, out);\n }"}, {"sha": "f188d8ee5d8c2e0d402415dc4c80b28e896f24e7", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -2,10 +2,10 @@\n \n use util::ppaux::ty_to_str;\n \n-use std::{ebml2, map};\n+use std::{ebml, map};\n use std::map::HashMap;\n use io::WriterUtil;\n-use ebml2::Serializer;\n+use ebml::Serializer;\n use syntax::ast::*;\n use syntax::print::pprust;\n use syntax::{ast_util, visit};\n@@ -40,7 +40,7 @@ export encode_def_id;\n type abbrev_map = map::HashMap<ty::t, tyencode::ty_abbrev>;\n \n type encode_inlined_item = fn@(ecx: @encode_ctxt,\n-                               ebml_w: ebml2::Serializer,\n+                               ebml_w: ebml::Serializer,\n                                path: ast_map::path,\n                                ii: ast::inlined_item);\n \n@@ -86,15 +86,15 @@ fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n     ecx.reachable.contains_key(id)\n }\n \n-fn encode_name(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, name: ident) {\n+fn encode_name(ecx: @encode_ctxt, ebml_w: ebml::Serializer, name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_def_id(ebml_w: ebml2::Serializer, id: def_id) {\n+fn encode_def_id(ebml_w: ebml::Serializer, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(it.id);\n     for opt_rp.each |rp| {\n@@ -104,7 +104,7 @@ fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n     }\n }\n \n-fn encode_mutability(ebml_w: ebml2::Serializer, mt: class_mutability) {\n+fn encode_mutability(ebml_w: ebml::Serializer, mt: class_mutability) {\n     do ebml_w.wr_tag(tag_class_mut) {\n         let val = match mt {\n           class_immutable => 'a',\n@@ -116,7 +116,7 @@ fn encode_mutability(ebml_w: ebml2::Serializer, mt: class_mutability) {\n \n type entry<T> = {val: T, pos: uint};\n \n-fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, path: &[ident],\n+fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml::Serializer, path: &[ident],\n                 index: &mut ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n@@ -127,7 +127,7 @@ fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, path: &[ident],\n          pos: ebml_w.writer.tell()});\n }\n \n-fn encode_trait_ref(ebml_w: ebml2::Serializer, ecx: @encode_ctxt,\n+fn encode_trait_ref(ebml_w: ebml::Serializer, ecx: @encode_ctxt,\n                     t: @trait_ref) {\n     ebml_w.start_tag(tag_impl_trait);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.ref_id));\n@@ -136,15 +136,15 @@ fn encode_trait_ref(ebml_w: ebml2::Serializer, ecx: @encode_ctxt,\n \n \n // Item info table encoding\n-fn encode_family(ebml_w: ebml2::Serializer, c: char) {\n+fn encode_family(ebml_w: ebml::Serializer, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n     ebml_w.end_tag();\n }\n \n fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_bounds(ebml_w: ebml2::Serializer, ecx: @encode_ctxt,\n+fn encode_ty_type_param_bounds(ebml_w: ebml::Serializer, ecx: @encode_ctxt,\n                                params: @~[ty::param_bounds]) {\n     let ty_str_ctxt = @{diag: ecx.diag,\n                         ds: def_to_str,\n@@ -158,21 +158,21 @@ fn encode_ty_type_param_bounds(ebml_w: ebml2::Serializer, ecx: @encode_ctxt,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: ebml2::Serializer, ecx: @encode_ctxt,\n+fn encode_type_param_bounds(ebml_w: ebml::Serializer, ecx: @encode_ctxt,\n                             params: ~[ty_param]) {\n     let ty_param_bounds =\n         @params.map(|param| ecx.tcx.ty_param_bounds.get(param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n }\n \n \n-fn encode_variant_id(ebml_w: ebml2::Serializer, vid: def_id) {\n+fn encode_variant_id(ebml_w: ebml::Serializer, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n     ebml_w.end_tag();\n }\n \n-fn write_type(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, typ: ty::t) {\n+fn write_type(ecx: @encode_ctxt, ebml_w: ebml::Serializer, typ: ty::t) {\n     let ty_str_ctxt =\n         @{diag: ecx.diag,\n           ds: def_to_str,\n@@ -182,7 +182,7 @@ fn write_type(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-fn write_vstore(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn write_vstore(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                 vstore: ty::vstore) {\n     let ty_str_ctxt =\n         @{diag: ecx.diag,\n@@ -193,13 +193,13 @@ fn write_vstore(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-fn encode_type(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, typ: ty::t) {\n+fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::Serializer, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, id: node_id) {\n+fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::Serializer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     let sym = match ecx.item_symbols.find(id) {\n       Some(x) => x,\n@@ -212,27 +212,27 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, id: node_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_discriminant(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::to_bytes(int::to_str(disr_val,10u)));\n     ebml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: ebml2::Serializer, id: def_id) {\n+fn encode_parent_item(ebml_w: ebml::Serializer, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                             id: node_id, variants: ~[variant],\n                             path: ast_map::path, index: @mut ~[entry<int>],\n                             ty_params: ~[ty_param]) {\n@@ -269,9 +269,9 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n     }\n }\n \n-fn encode_path(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_path(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                path: ast_map::path, name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n@@ -290,7 +290,7 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n     }\n }\n \n-fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, md: _mod,\n+fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::Serializer, md: _mod,\n                        id: node_id, path: ast_map::path, name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n@@ -348,15 +348,15 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, md: _mod,\n     ebml_w.end_tag();\n }\n \n-fn encode_visibility(ebml_w: ebml2::Serializer, visibility: visibility) {\n+fn encode_visibility(ebml_w: ebml::Serializer, visibility: visibility) {\n     encode_family(ebml_w, match visibility {\n         public => 'g',\n         private => 'j',\n         inherited => 'N'\n     });\n }\n \n-fn encode_self_type(ebml_w: ebml2::Serializer, self_type: ast::self_ty_) {\n+fn encode_self_type(ebml_w: ebml::Serializer, self_type: ast::self_ty_) {\n     ebml_w.start_tag(tag_item_trait_method_self_ty);\n \n     // Encode the base self type.\n@@ -389,7 +389,7 @@ fn encode_self_type(ebml_w: ebml2::Serializer, self_type: ast::self_ty_) {\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                          id: node_id, path: ast_map::path,\n                          class_tps: ~[ty_param],\n                          fields: ~[@struct_field],\n@@ -445,7 +445,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n }\n \n // This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                         id: node_id, ident: ident, path: ast_map::path,\n                         item: Option<inlined_item>, tps: ~[ty_param]) {\n         ebml_w.start_tag(tag_items_data_item);\n@@ -470,7 +470,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n         ebml_w.end_tag();\n }\n \n-fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n                           m: @method, all_tps: ~[ty_param]) {\n@@ -520,7 +520,7 @@ fn should_inline(attrs: ~[attribute]) -> bool {\n }\n \n \n-fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                         item: @item, index: @mut ~[entry<int>],\n                         path: ast_map::path) {\n \n@@ -533,7 +533,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n \n-    fn add_to_index_(item: @item, ebml_w: ebml2::Serializer,\n+    fn add_to_index_(item: @item, ebml_w: ebml::Serializer,\n                      index: @mut ~[entry<int>]) {\n         index.push({val: item.id, pos: ebml_w.writer.tell()});\n     }\n@@ -810,7 +810,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path, abi: foreign_abi) {\n@@ -843,7 +843,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                          crate: @crate) -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n@@ -898,7 +898,7 @@ fn create_index<T: Copy Hash IterBytes>(index: ~[entry<T>]) ->\n     return buckets_frozen;\n }\n \n-fn encode_index<T>(ebml_w: ebml2::Serializer, buckets: ~[@~[entry<T>]],\n+fn encode_index<T>(ebml_w: ebml::Serializer, buckets: ~[@~[entry<T>]],\n                    write_fn: fn(io::Writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n@@ -933,7 +933,7 @@ fn write_int(writer: io::Writer, &&n: int) {\n     writer.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: ebml2::Serializer, mi: meta_item) {\n+fn encode_meta_item(ebml_w: ebml::Serializer, mi: meta_item) {\n     match mi.node {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n@@ -970,7 +970,7 @@ fn encode_meta_item(ebml_w: ebml2::Serializer, mi: meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: ebml2::Serializer, attrs: ~[attribute]) {\n+fn encode_attributes(ebml_w: ebml::Serializer, attrs: ~[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n         ebml_w.start_tag(tag_attribute);\n@@ -1031,7 +1031,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     return attrs;\n }\n \n-fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                      cstore: cstore::cstore) {\n \n     fn get_ordered_deps(ecx: @encode_ctxt, cstore: cstore::cstore)\n@@ -1077,7 +1077,7 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n@@ -1092,7 +1092,7 @@ fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: ebml2::Serializer, hash: ~str) {\n+fn encode_hash(ebml_w: ebml::Serializer, hash: ~str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n     ebml_w.end_tag();\n@@ -1130,7 +1130,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n         type_abbrevs: ty::new_ty_hash()\n      });\n \n-    let ebml_w = ebml2::Serializer(wr as io::Writer);\n+    let ebml_w = ebml::Serializer(wr as io::Writer);\n \n     encode_hash(ebml_w, ecx.link_meta.extras_hash);\n "}, {"sha": "103f1eecf87addf68d32b1985b79dced38ffa721", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -7,15 +7,14 @@ use syntax::visit;\n use syntax::ast_map;\n use syntax::ast_util;\n use syntax::codemap::span;\n-use std::ebml2;\n-use std::ebml2::Serializer;\n-use std::ebml2::get_doc;\n+use std::ebml;\n+use std::ebml::{Serializer, get_doc};\n use std::map::HashMap;\n-use std::serialization2;\n-use std::serialization2::{Serializable,\n-                          SerializerHelpers,\n-                          DeserializerHelpers,\n-                          deserialize};\n+use std::serialization;\n+use std::serialization::{Serializable,\n+                         SerializerHelpers,\n+                         DeserializerHelpers,\n+                         deserialize};\n use middle::{ty, typeck};\n use middle::typeck::{method_origin, method_map_entry,\n                      vtable_res,\n@@ -74,7 +73,7 @@ trait tr {\n // Top-level methods.\n \n fn encode_inlined_item(ecx: @e::encode_ctxt,\n-                       ebml_w: ebml2::Serializer,\n+                       ebml_w: ebml::Serializer,\n                        path: ast_map::path,\n                        ii: ast::inlined_item,\n                        maps: maps) {\n@@ -100,14 +99,14 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n                        tcx: ty::ctxt,\n                        maps: maps,\n                        path: ast_map::path,\n-                       par_doc: ebml2::Doc) -> Option<ast::inlined_item> {\n+                       par_doc: ebml::Doc) -> Option<ast::inlined_item> {\n     let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n     match par_doc.opt_child(c::tag_ast) {\n       None => None,\n       Some(ast_doc) => {\n         debug!(\"> Decoding inlined fn: %s::?\",\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n-        let ast_dsr = &ebml2::Deserializer(ast_doc);\n+        let ast_dsr = &ebml::Deserializer(ast_doc);\n         let from_id_range = deserialize(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n         let xcx = extended_decode_ctxt_(@{dcx: dcx,\n@@ -185,7 +184,7 @@ trait def_id_serializer_helpers {\n     fn emit_def_id(did: ast::def_id);\n }\n \n-impl<S: serialization2::Serializer> S: def_id_serializer_helpers {\n+impl<S: serialization::Serializer> S: def_id_serializer_helpers {\n     fn emit_def_id(did: ast::def_id) {\n         did.serialize(&self)\n     }\n@@ -195,7 +194,7 @@ trait def_id_deserializer_helpers {\n     fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id;\n }\n \n-impl<D: serialization2::Deserializer> D: def_id_deserializer_helpers {\n+impl<D: serialization::Deserializer> D: def_id_deserializer_helpers {\n \n     fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id {\n         let did: ast::def_id = deserialize(&self);\n@@ -218,7 +217,7 @@ impl<D: serialization2::Deserializer> D: def_id_deserializer_helpers {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: ebml2::Serializer, item: ast::inlined_item) {\n+fn encode_ast(ebml_w: ebml::Serializer, item: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n         item.serialize(&ebml_w)\n     }\n@@ -278,9 +277,9 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n     }\n }\n \n-fn decode_ast(par_doc: ebml2::Doc) -> ast::inlined_item {\n+fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n-    let d = &ebml2::Deserializer(chi_doc);\n+    let d = &ebml::Deserializer(chi_doc);\n     deserialize(d)\n }\n \n@@ -332,12 +331,12 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn encode_def(ebml_w: ebml2::Serializer, def: ast::def) {\n+fn encode_def(ebml_w: ebml::Serializer, def: ast::def) {\n     def.serialize(&ebml_w)\n }\n \n-fn decode_def(xcx: extended_decode_ctxt, doc: ebml2::Doc) -> ast::def {\n-    let dsr = &ebml2::Deserializer(doc);\n+fn decode_def(xcx: extended_decode_ctxt, doc: ebml::Doc) -> ast::def {\n+    let dsr = &ebml::Deserializer(doc);\n     let def: ast::def = deserialize(dsr);\n     def.tr(xcx)\n }\n@@ -423,15 +422,15 @@ impl ty::bound_region: tr {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: ebml2::Serializer, fv: @freevar_entry) {\n+fn encode_freevar_entry(ebml_w: ebml::Serializer, fv: @freevar_entry) {\n     (*fv).serialize(&ebml_w)\n }\n \n trait ebml_deserializer_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry;\n }\n \n-impl ebml2::Deserializer: ebml_deserializer_helper {\n+impl ebml::Deserializer: ebml_deserializer_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n         let fv: freevar_entry = deserialize(&self);\n         fv.tr(xcx)\n@@ -452,7 +451,7 @@ trait read_method_map_entry_helper {\n }\n \n fn serialize_method_map_entry(ecx: @e::encode_ctxt,\n-                              ebml_w: ebml2::Serializer,\n+                              ebml_w: ebml::Serializer,\n                               mme: method_map_entry) {\n     do ebml_w.emit_rec {\n         do ebml_w.emit_field(~\"self_arg\", 0u) {\n@@ -464,7 +463,7 @@ fn serialize_method_map_entry(ecx: @e::encode_ctxt,\n     }\n }\n \n-impl ebml2::Deserializer: read_method_map_entry_helper {\n+impl ebml::Deserializer: read_method_map_entry_helper {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry {\n         do self.read_rec {\n             {self_arg:\n@@ -503,7 +502,7 @@ impl method_origin: tr {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res(ecx: @e::encode_ctxt,\n-                     ebml_w: ebml2::Serializer,\n+                     ebml_w: ebml::Serializer,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic serialization of\n     // ty::t doesn't work, and there is no way (atm) to have\n@@ -515,7 +514,7 @@ fn encode_vtable_res(ecx: @e::encode_ctxt,\n }\n \n fn encode_vtable_origin(ecx: @e::encode_ctxt,\n-                      ebml_w: ebml2::Serializer,\n+                      ebml_w: ebml::Serializer,\n                       vtable_origin: typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n         match vtable_origin {\n@@ -562,7 +561,7 @@ trait vtable_deserialization_helpers {\n     fn read_vtable_origin(xcx: extended_decode_ctxt) -> typeck::vtable_origin;\n }\n \n-impl ebml2::Deserializer: vtable_deserialization_helpers {\n+impl ebml::Deserializer: vtable_deserialization_helpers {\n     fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n         @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n     }\n@@ -639,7 +638,7 @@ trait ebml_writer_helpers {\n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty);\n }\n \n-impl ebml2::Serializer: ebml_writer_helpers {\n+impl ebml::Serializer: ebml_writer_helpers {\n     fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t) {\n         do self.emit_opaque {\n             e::write_type(ecx, self, ty)\n@@ -692,7 +691,7 @@ trait write_tag_and_id {\n     fn id(id: ast::node_id);\n }\n \n-impl ebml2::Serializer: write_tag_and_id {\n+impl ebml::Serializer: write_tag_and_id {\n     fn tag(tag_id: c::astencode_tag, f: fn()) {\n         do self.wr_tag(tag_id as uint) { f() }\n     }\n@@ -704,7 +703,7 @@ impl ebml2::Serializer: write_tag_and_id {\n \n fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: ebml2::Serializer,\n+                             ebml_w: ebml::Serializer,\n                              ii: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_table as uint) {\n         ast_util::visit_ids_for_inlined_item(\n@@ -720,7 +719,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n \n fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: ebml2::Serializer,\n+                             ebml_w: ebml::Serializer,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n@@ -849,13 +848,13 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n \n trait doc_decoder_helpers {\n     fn as_int() -> int;\n-    fn opt_child(tag: c::astencode_tag) -> Option<ebml2::Doc>;\n+    fn opt_child(tag: c::astencode_tag) -> Option<ebml::Doc>;\n }\n \n-impl ebml2::Doc: doc_decoder_helpers {\n-    fn as_int() -> int { ebml2::doc_as_u64(self) as int }\n-    fn opt_child(tag: c::astencode_tag) -> Option<ebml2::Doc> {\n-        ebml2::maybe_get_doc(self, tag as uint)\n+impl ebml::Doc: doc_decoder_helpers {\n+    fn as_int() -> int { ebml::doc_as_u64(self) as int }\n+    fn opt_child(tag: c::astencode_tag) -> Option<ebml::Doc> {\n+        ebml::maybe_get_doc(self, tag as uint)\n     }\n }\n \n@@ -868,7 +867,7 @@ trait ebml_deserializer_decoder_helpers {\n                                 -> ty::ty_param_bounds_and_ty;\n }\n \n-impl ebml2::Deserializer: ebml_deserializer_decoder_helpers {\n+impl ebml::Deserializer: ebml_deserializer_decoder_helpers {\n \n     fn read_arg(xcx: extended_decode_ctxt) -> ty::arg {\n         do self.read_opaque |doc| {\n@@ -923,10 +922,10 @@ impl ebml2::Deserializer: ebml_deserializer_decoder_helpers {\n }\n \n fn decode_side_tables(xcx: extended_decode_ctxt,\n-                      ast_doc: ebml2::Doc) {\n+                      ast_doc: ebml::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc[c::tag_table as uint];\n-    for ebml2::docs(tbl_doc) |tag, entry_doc| {\n+    for ebml::docs(tbl_doc) |tag, entry_doc| {\n         let id0 = entry_doc[c::tag_table_id as uint].as_int();\n         let id = xcx.tr_id(id0);\n \n@@ -940,7 +939,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             dcx.tcx.legacy_boxed_traits.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val as uint];\n-            let val_dsr = &ebml2::Deserializer(val_doc);\n+            let val_dsr = &ebml::Deserializer(val_doc);\n             if tag == (c::tag_table_def as uint) {\n                 let def = decode_def(xcx, val_doc);\n                 dcx.tcx.def_map.insert(id, def);\n@@ -993,16 +992,16 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: ebml2::Serializer, item: @ast::item) {\n+fn encode_item_ast(ebml_w: ebml::Serializer, item: @ast::item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n         (*item).serialize(&ebml_w)\n     }\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: ebml2::Doc) -> @ast::item {\n+fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n-    let d = &ebml2::Deserializer(chi_doc);\n+    let d = &ebml::Deserializer(chi_doc);\n     @deserialize(d)\n }\n \n@@ -1029,17 +1028,17 @@ fn mk_ctxt() -> fake_ext_ctxt {\n #[cfg(test)]\n fn roundtrip(in_item: @ast::item) {\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = ebml2::Serializer(wr);\n+        let ebml_w = ebml::Serializer(wr);\n         encode_item_ast(ebml_w, in_item);\n     };\n-    let ebml_doc = ebml2::Doc(@bytes);\n+    let ebml_doc = ebml::Doc(@bytes);\n     let out_item = decode_item_ast(ebml_doc);\n \n     let exp_str = do io::with_str_writer |w| {\n-        in_item.serialize(&std::prettyprint2::Serializer(w))\n+        in_item.serialize(&std::prettyprint::Serializer(w))\n     };\n     let out_str = do io::with_str_writer |w| {\n-        out_item.serialize(&std::prettyprint2::Serializer(w))\n+        out_item.serialize(&std::prettyprint::Serializer(w))\n     };\n \n     debug!(\"expected string: %s\", exp_str);"}, {"sha": "28400b5455d56129194afa79a3e9503d019e371a", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -16,6 +16,8 @@ export has_freevars;\n \n // A vector of defs representing the free variables referred to in a function.\n // (The def_upvar will already have been stripped).\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type freevar_entry = {"}, {"sha": "85f03e1f0b336aa9c76fb5cceef43ca6b7f1c921", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -211,6 +211,8 @@ type method = {ident: ast::ident,\n \n type mt = {ty: t, mutbl: ast::mutability};\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum vstore {\n@@ -271,6 +273,8 @@ enum ast_ty_to_ty_cache_entry {\n \n type opt_region_variance = Option<region_variance>;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n@@ -289,13 +293,17 @@ impl region_variance : cmp::Eq {\n     pure fn ne(other: &region_variance) -> bool { !self.eq(other) }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type AutoAdjustment = {\n     autoderefs: uint,\n     autoref: Option<AutoRef>\n };\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type AutoRef = {\n@@ -304,6 +312,8 @@ type AutoRef = {\n     mutbl: ast::mutability\n };\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum AutoRefKind {\n@@ -509,6 +519,8 @@ impl param_ty : to_bytes::IterBytes {\n \n \n /// Representation of regions:\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum region {\n@@ -538,6 +550,8 @@ enum region {\n     re_var(RegionVid)\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum bound_region {\n@@ -669,6 +683,8 @@ enum param_bound {\n enum TyVid = uint;\n enum IntVid = uint;\n enum FnVid = uint;\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum RegionVid = uint;"}, {"sha": "027a1d067423f46763ccf6cd8cd274a8d4d7b4c7", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -75,6 +75,8 @@ export method_static, method_param, method_trait, method_self;\n export vtable_static, vtable_param, vtable_trait;\n export provided_methods_map;\n \n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n enum method_origin {\n@@ -93,6 +95,8 @@ enum method_origin {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n+#[auto_serialize]\n+#[auto_deserialize]\n #[auto_serialize2]\n #[auto_deserialize2]\n type method_param = {"}, {"sha": "6c85f59b74ed2352450eafb6b96bec349154816d", "filename": "src/test/run-pass/auto_serialize.rs", "status": "renamed", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb626e71199d1d89a0242043f096d89941fa2ec7/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=eb626e71199d1d89a0242043f096d89941fa2ec7", "patch": "@@ -4,34 +4,34 @@ extern mod std;\n // the common code.\n \n use cmp::Eq;\n-use std::ebml2;\n+use std::ebml;\n use io::Writer;\n-use std::serialization2::{Serializable, Deserializable, deserialize};\n-use std::prettyprint2;\n+use std::serialization::{Serializable, Deserializable, deserialize};\n+use std::prettyprint;\n \n fn test_ser_and_deser<A:Eq Serializable Deserializable>(\n     a1: &A,\n     +expected: ~str\n ) {\n     // check the pretty printer:\n     let s = do io::with_str_writer |w| {\n-        a1.serialize(&prettyprint2::Serializer(w))\n+        a1.serialize(&prettyprint::Serializer(w))\n     };\n     debug!(\"s == %?\", s);\n     assert s == expected;\n \n     // check the EBML serializer:\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = &ebml2::Serializer(wr);\n+        let ebml_w = &ebml::Serializer(wr);\n         a1.serialize(ebml_w)\n     };\n-    let d = ebml2::Doc(@bytes);\n-    let a2: A = deserialize(&ebml2::Deserializer(d));\n+    let d = ebml::Doc(@bytes);\n+    let a2: A = deserialize(&ebml::Deserializer(d));\n     assert *a1 == a2;\n }\n \n-#[auto_serialize2]\n-#[auto_deserialize2]\n+#[auto_serialize]\n+#[auto_deserialize]\n enum Expr {\n     Val(uint),\n     Plus(@Expr, @Expr),\n@@ -105,8 +105,8 @@ impl CLike : cmp::Eq {\n     pure fn ne(other: &CLike) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize2]\n-#[auto_deserialize2]\n+#[auto_serialize]\n+#[auto_deserialize]\n type Spanned<T> = {lo: uint, hi: uint, node: T};\n \n impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n@@ -116,27 +116,27 @@ impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n     pure fn ne(other: &Spanned<T>) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize2]\n-#[auto_deserialize2]\n+#[auto_serialize]\n+#[auto_deserialize]\n type SomeRec = {v: ~[uint]};\n \n-#[auto_serialize2]\n-#[auto_deserialize2]\n+#[auto_serialize]\n+#[auto_deserialize]\n enum AnEnum = SomeRec;\n \n-#[auto_serialize2]\n-#[auto_deserialize2]\n+#[auto_serialize]\n+#[auto_deserialize]\n struct Point {x: uint, y: uint}\n \n-#[auto_serialize2]\n-#[auto_deserialize2]\n+#[auto_serialize]\n+#[auto_deserialize]\n enum Quark<T> {\n     Top(T),\n     Bottom(T)\n }\n \n-#[auto_serialize2]\n-#[auto_deserialize2]\n+#[auto_serialize]\n+#[auto_deserialize]\n enum CLike { A, B, C }\n \n fn main() {", "previous_filename": "src/test/run-pass/auto_serialize2.rs"}]}