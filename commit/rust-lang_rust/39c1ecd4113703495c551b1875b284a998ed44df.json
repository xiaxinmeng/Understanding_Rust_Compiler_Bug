{"sha": "39c1ecd4113703495c551b1875b284a998ed44df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YzFlY2Q0MTEzNzAzNDk1YzU1MWIxODc1YjI4NGE5OThlZDQ0ZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-24T11:56:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-24T11:56:25Z"}, "message": "auto merge of #14396 : vhbit/rust/opaque-mutex, r=alexcrichton\n\nOn some systems (iOS for example) mutex is represented by opaque data structure which doesn't play well with simple data copy. Therefore mutex should be initialized from magic static value and filled by OS only when it landed RC.\r\n\r\nInitially written for iOS but since landing iOS support might require quite a lot of time I think it is better to split parts which aren't directly related to iOS and merge them in", "tree": {"sha": "311c45ed14aa863a3b36c50d457c4ac5d7c89b6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/311c45ed14aa863a3b36c50d457c4ac5d7c89b6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39c1ecd4113703495c551b1875b284a998ed44df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39c1ecd4113703495c551b1875b284a998ed44df", "html_url": "https://github.com/rust-lang/rust/commit/39c1ecd4113703495c551b1875b284a998ed44df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39c1ecd4113703495c551b1875b284a998ed44df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e72a21b2bb6b889a991229a966a9243b6d81e4d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e72a21b2bb6b889a991229a966a9243b6d81e4d0", "html_url": "https://github.com/rust-lang/rust/commit/e72a21b2bb6b889a991229a966a9243b6d81e4d0"}, {"sha": "41b65d39ab5b4fae52cbcc370b464ba370bedb87", "url": "https://api.github.com/repos/rust-lang/rust/commits/41b65d39ab5b4fae52cbcc370b464ba370bedb87", "html_url": "https://github.com/rust-lang/rust/commit/41b65d39ab5b4fae52cbcc370b464ba370bedb87"}], "stats": {"total": 54, "additions": 31, "deletions": 23}, "files": [{"sha": "18857e221fa15b3db35c9e48ab11e74ffdf0f49e", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39c1ecd4113703495c551b1875b284a998ed44df/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39c1ecd4113703495c551b1875b284a998ed44df/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=39c1ecd4113703495c551b1875b284a998ed44df", "patch": "@@ -600,20 +600,22 @@ impl<T: Send> Clone for Sender<T> {\n         let (packet, sleeper) = match *unsafe { self.inner() } {\n             Oneshot(ref p) => {\n                 let a = Arc::new(Unsafe::new(shared::Packet::new()));\n-                match unsafe {\n-                    (*p.get()).upgrade(Receiver::new(Shared(a.clone())))\n-                } {\n-                    oneshot::UpSuccess | oneshot::UpDisconnected => (a, None),\n-                    oneshot::UpWoke(task) => (a, Some(task))\n+                unsafe {\n+                    (*a.get()).postinit_lock();\n+                    match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n+                        oneshot::UpSuccess | oneshot::UpDisconnected => (a, None),\n+                        oneshot::UpWoke(task) => (a, Some(task))\n+                    }\n                 }\n             }\n             Stream(ref p) => {\n                 let a = Arc::new(Unsafe::new(shared::Packet::new()));\n-                match unsafe {\n-                    (*p.get()).upgrade(Receiver::new(Shared(a.clone())))\n-                } {\n-                    stream::UpSuccess | stream::UpDisconnected => (a, None),\n-                    stream::UpWoke(task) => (a, Some(task)),\n+                unsafe {\n+                    (*a.get()).postinit_lock();\n+                    match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n+                        stream::UpSuccess | stream::UpDisconnected => (a, None),\n+                        stream::UpWoke(task) => (a, Some(task)),\n+                    }\n                 }\n             }\n             Shared(ref p) => {"}, {"sha": "3fde584a46f719096f87474a7ea947981e3c4218", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/39c1ecd4113703495c551b1875b284a998ed44df/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39c1ecd4113703495c551b1875b284a998ed44df/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=39c1ecd4113703495c551b1875b284a998ed44df", "patch": "@@ -66,7 +66,8 @@ pub enum Failure {\n }\n \n impl<T: Send> Packet<T> {\n-    // Creation of a packet *must* be followed by a call to inherit_blocker\n+    // Creation of a packet *must* be followed by a call to postinit_lock\n+    // and later by inherit_blocker\n     pub fn new() -> Packet<T> {\n         let p = Packet {\n             queue: mpsc::Queue::new(),\n@@ -78,11 +79,18 @@ impl<T: Send> Packet<T> {\n             sender_drain: atomics::AtomicInt::new(0),\n             select_lock: unsafe { NativeMutex::new() },\n         };\n-        // see comments in inherit_blocker about why we grab this lock\n-        unsafe { p.select_lock.lock_noguard() }\n         return p;\n     }\n \n+    // This function should be used after newly created Packet\n+    // was wrapped with an Arc\n+    // In other case mutex data will be duplicated while clonning\n+    // and that could cause problems on platforms where it is\n+    // represented by opaque data structure\n+    pub fn postinit_lock(&mut self) {\n+        unsafe { self.select_lock.lock_noguard() }\n+    }\n+\n     // This function is used at the creation of a shared packet to inherit a\n     // previously blocked task. This is done to prevent spurious wakeups of\n     // tasks in select()."}, {"sha": "04da7dab6c658f8a0fb4ddc5187411fa0dc0702c", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/39c1ecd4113703495c551b1875b284a998ed44df/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39c1ecd4113703495c551b1875b284a998ed44df/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=39c1ecd4113703495c551b1875b284a998ed44df", "patch": "@@ -98,6 +98,7 @@ impl StaticNativeMutex {\n     ///\n     /// Note that a mutex created in this way needs to be explicit\n     /// freed with a call to `destroy` or it will leak.\n+    /// Also it is important to avoid locking until mutex has stopped moving\n     pub unsafe fn new() -> StaticNativeMutex {\n         StaticNativeMutex { inner: imp::Mutex::new() }\n     }\n@@ -172,6 +173,7 @@ impl NativeMutex {\n     ///\n     /// The user must be careful to ensure the mutex is not locked when its is\n     /// being destroyed.\n+    /// Also it is important to avoid locking until mutex has stopped moving\n     pub unsafe fn new() -> NativeMutex {\n         NativeMutex { inner: StaticNativeMutex::new() }\n     }\n@@ -262,7 +264,6 @@ mod imp {\n     use libc;\n     use self::os::{PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER,\n                    pthread_mutex_t, pthread_cond_t};\n-    use mem;\n     use ty::Unsafe;\n     use kinds::marker;\n \n@@ -294,6 +295,7 @@ mod imp {\n         static __PTHREAD_MUTEX_SIZE__: uint = 40;\n         #[cfg(target_arch = \"x86\")]\n         static __PTHREAD_COND_SIZE__: uint = 24;\n+\n         static _PTHREAD_MUTEX_SIG_init: libc::c_long = 0x32AAABA7;\n         static _PTHREAD_COND_SIG_init: libc::c_long = 0x3CB0B1BB;\n \n@@ -389,14 +391,14 @@ mod imp {\n \n     impl Mutex {\n         pub unsafe fn new() -> Mutex {\n+            // As mutex might be moved and address is changing it\n+            // is better to avoid initialization of potentially\n+            // opaque OS data before it landed\n             let m = Mutex {\n-                lock: Unsafe::new(mem::zeroed()),\n-                cond: Unsafe::new(mem::zeroed()),\n+                lock: Unsafe::new(PTHREAD_MUTEX_INITIALIZER),\n+                cond: Unsafe::new(PTHREAD_COND_INITIALIZER),\n             };\n \n-            pthread_mutex_init(m.lock.get(), 0 as *libc::c_void);\n-            pthread_cond_init(m.cond.get(), 0 as *libc::c_void);\n-\n             return m;\n         }\n \n@@ -416,11 +418,7 @@ mod imp {\n     }\n \n     extern {\n-        fn pthread_mutex_init(lock: *mut pthread_mutex_t,\n-                              attr: *pthread_mutexattr_t) -> libc::c_int;\n         fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;\n-        fn pthread_cond_init(cond: *mut pthread_cond_t,\n-                              attr: *pthread_condattr_t) -> libc::c_int;\n         fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;\n         fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;\n         fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;"}]}