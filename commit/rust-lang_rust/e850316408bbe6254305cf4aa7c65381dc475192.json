{"sha": "e850316408bbe6254305cf4aa7c65381dc475192", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NTAzMTY0MDhiYmU2MjU0MzA1Y2Y0YWE3YzY1MzgxZGM0NzUxOTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-10T10:36:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-10T10:36:30Z"}, "message": "auto merge of #14068 : alexcrichton/rust/rustdoc-xcrate-links, r=brson\n\nThis should improve the libcore experience quite a bit when looking at the\r\nlibstd documentation.", "tree": {"sha": "9e942f8281b75bc77dc8c08ccfeed9cb9ebfb27f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e942f8281b75bc77dc8c08ccfeed9cb9ebfb27f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e850316408bbe6254305cf4aa7c65381dc475192", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e850316408bbe6254305cf4aa7c65381dc475192", "html_url": "https://github.com/rust-lang/rust/commit/e850316408bbe6254305cf4aa7c65381dc475192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e850316408bbe6254305cf4aa7c65381dc475192/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "061450dcf14ea88c77312764fd80d712ff47fdb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/061450dcf14ea88c77312764fd80d712ff47fdb8", "html_url": "https://github.com/rust-lang/rust/commit/061450dcf14ea88c77312764fd80d712ff47fdb8"}, {"sha": "620b4352f28d58801d82d58faa0a71f75ad9087f", "url": "https://api.github.com/repos/rust-lang/rust/commits/620b4352f28d58801d82d58faa0a71f75ad9087f", "html_url": "https://github.com/rust-lang/rust/commit/620b4352f28d58801d82d58faa0a71f75ad9087f"}], "stats": {"total": 291, "additions": 153, "deletions": 138}, "files": [{"sha": "4530d3d443c92394da2c7f44cc49c52d6586b3e5", "filename": "src/doc/rust.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e850316408bbe6254305cf4aa7c65381dc475192/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/e850316408bbe6254305cf4aa7c65381dc475192/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=e850316408bbe6254305cf4aa7c65381dc475192", "patch": "@@ -17,14 +17,13 @@ This document does not serve as a tutorial introduction to the\n language. Background familiarity with the language is assumed. A separate\n [tutorial] document is available to help acquire such background familiarity.\n \n-This document also does not serve as a reference to the [standard] or [extra]\n-libraries included in the language distribution. Those libraries are\n+This document also does not serve as a reference to the [standard]\n+library included in the language distribution. Those libraries are\n documented separately by extracting documentation attributes from their\n source code.\n \n [tutorial]: tutorial.html\n [standard]: std/index.html\n-[extra]: extra/index.html\n \n ## Disclaimer\n "}, {"sha": "cced502846032f0ac3713079898fd9a7762e55a3", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=e850316408bbe6254305cf4aa7c65381dc475192", "patch": "@@ -24,7 +24,7 @@\n //!\n //! Functions return `Result` whenever errors are expected and\n //! recoverable. In the `std` crate `Result` is most prominently used\n-//! for [I/O](../io/index.html).\n+//! for [I/O](../../std/io/index.html).\n //!\n //! A simple function returning `Result` might be\n //! defined and used like so:"}, {"sha": "aef289a4a7f3926a2d8bee9c880fe638641a8517", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 37, "deletions": 47, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=e850316408bbe6254305cf4aa7c65381dc475192", "patch": "@@ -670,15 +670,7 @@ pub enum Type {\n     ResolvedPath {\n         pub path: Path,\n         pub typarams: Option<Vec<TyParamBound>>,\n-        pub id: ast::NodeId,\n-    },\n-    /// Same as above, but only external variants\n-    ExternalPath {\n-        pub path: Path,\n-        pub typarams: Option<Vec<TyParamBound>>,\n-        pub fqn: Vec<~str>,\n-        pub kind: TypeKind,\n-        pub krate: ast::CrateNum,\n+        pub did: ast::DefId,\n     },\n     // I have no idea how to usefully use this.\n     TyParamBinder(ast::NodeId),\n@@ -715,19 +707,18 @@ pub enum Type {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub enum TypeKind {\n-    TypeStruct,\n     TypeEnum,\n-    TypeTrait,\n     TypeFunction,\n+    TypeModule,\n+    TypeStatic,\n+    TypeStruct,\n+    TypeTrait,\n+    TypeVariant,\n }\n \n impl Clean<Type> for ast::Ty {\n     fn clean(&self) -> Type {\n         use syntax::ast::*;\n-        debug!(\"cleaning type `{:?}`\", self);\n-        let ctxt = super::ctxtkey.get().unwrap();\n-        let codemap = ctxt.sess().codemap();\n-        debug!(\"span corresponds to `{}`\", codemap.span_to_str(self.span));\n         match self.node {\n             TyNil => Unit,\n             TyPtr(ref m) => RawPointer(m.mutbl.clean(), box m.ty.clean()),\n@@ -1153,7 +1144,7 @@ pub enum ViewPath {\n     // use source::*;\n     GlobImport(ImportSource),\n     // use source::{a, b, c};\n-    ImportList(ImportSource, Vec<ViewListIdent> ),\n+    ImportList(ImportSource, Vec<ViewListIdent>),\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -1298,48 +1289,47 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound> >,\n         core::NotTyped(_) => return Bool\n     };\n     debug!(\"searching for {:?} in defmap\", id);\n-    let d = match tycx.def_map.borrow().find(&id) {\n+    let def = match tycx.def_map.borrow().find(&id) {\n         Some(&k) => k,\n-        None => {\n-            debug!(\"could not find {:?} in defmap (`{}`)\", id, tycx.map.node_to_str(id));\n-            fail!(\"Unexpected failure: unresolved id not in defmap (this is a bug!)\")\n-        }\n+        None => fail!(\"unresolved id not in defmap\")\n     };\n \n-    let (def_id, kind) = match d {\n-        ast::DefFn(i, _) => (i, TypeFunction),\n+    match def {\n         ast::DefSelfTy(i) => return Self(i),\n-        ast::DefTy(i) => (i, TypeEnum),\n-        ast::DefTrait(i) => {\n-            debug!(\"saw DefTrait in def_to_id\");\n-            (i, TypeTrait)\n-        },\n         ast::DefPrimTy(p) => match p {\n             ast::TyStr => return String,\n             ast::TyBool => return Bool,\n             _ => return Primitive(p)\n         },\n         ast::DefTyParam(i, _) => return Generic(i.node),\n+        ast::DefTyParamBinder(i) => return TyParamBinder(i),\n+        _ => {}\n+    };\n+    let did = register_def(&**cx, def);\n+    ResolvedPath { path: path, typarams: tpbs, did: did }\n+}\n+\n+fn register_def(cx: &core::DocContext, def: ast::Def) -> ast::DefId {\n+    let (did, kind) = match def {\n+        ast::DefFn(i, _) => (i, TypeFunction),\n+        ast::DefTy(i) => (i, TypeEnum),\n+        ast::DefTrait(i) => (i, TypeTrait),\n         ast::DefStruct(i) => (i, TypeStruct),\n-        ast::DefTyParamBinder(i) => {\n-            debug!(\"found a typaram_binder, what is it? {}\", i);\n-            return TyParamBinder(i);\n-        },\n-        x => fail!(\"resolved type maps to a weird def {:?}\", x),\n+        ast::DefMod(i) => (i, TypeModule),\n+        ast::DefStatic(i, _) => (i, TypeStatic),\n+        ast::DefVariant(i, _, _) => (i, TypeEnum),\n+        _ => return ast_util::def_id_of_def(def),\n     };\n-    if ast_util::is_local(def_id) {\n-        ResolvedPath{ path: path, typarams: tpbs, id: def_id.node }\n-    } else {\n-        let fqn = csearch::get_item_path(tycx, def_id);\n-        let fqn = fqn.move_iter().map(|i| i.to_str()).collect();\n-        ExternalPath {\n-            path: path,\n-            typarams: tpbs,\n-            fqn: fqn,\n-            kind: kind,\n-            krate: def_id.krate,\n-        }\n-    }\n+    if ast_util::is_local(did) { return did }\n+    let tcx = match cx.maybe_typed {\n+        core::Typed(ref t) => t,\n+        core::NotTyped(_) => return did\n+    };\n+    let fqn = csearch::get_item_path(tcx, did);\n+    let fqn = fqn.move_iter().map(|i| i.to_str()).collect();\n+    debug!(\"recording {} => {}\", did, fqn);\n+    cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n+    return did;\n }\n \n fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n@@ -1353,7 +1343,7 @@ fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n     let cx = super::ctxtkey.get().unwrap();\n     match cx.maybe_typed {\n         core::Typed(ref tcx) => {\n-            tcx.def_map.borrow().find(&id).map(|&d| ast_util::def_id_of_def(d))\n+            tcx.def_map.borrow().find(&id).map(|&def| register_def(&**cx, def))\n         }\n         core::NotTyped(_) => None\n     }"}, {"sha": "d65d5a1e458e6c1f2b97a0e9f66db72b5ecfbc7d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e850316408bbe6254305cf4aa7c65381dc475192", "patch": "@@ -20,7 +20,7 @@ use syntax;\n \n use std::cell::RefCell;\n use std::os;\n-use collections::HashSet;\n+use collections::{HashSet, HashMap};\n \n use visit_ast::RustdocVisitor;\n use clean;\n@@ -31,10 +31,14 @@ pub enum MaybeTyped {\n     NotTyped(driver::session::Session)\n }\n \n+pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n+                                                (Vec<~str>, clean::TypeKind)>>>;\n+\n pub struct DocContext {\n     pub krate: ast::Crate,\n     pub maybe_typed: MaybeTyped,\n     pub src: Path,\n+    pub external_paths: ExternalPaths,\n }\n \n impl DocContext {\n@@ -49,6 +53,7 @@ impl DocContext {\n pub struct CrateAnalysis {\n     pub exported_items: privacy::ExportedItems,\n     pub public_items: privacy::PublicItems,\n+    pub external_paths: ExternalPaths,\n }\n \n /// Parses, resolves, and typechecks the given crate\n@@ -98,9 +103,11 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<~str>)\n         krate: krate,\n         maybe_typed: Typed(ty_cx),\n         src: cpath.clone(),\n+        external_paths: RefCell::new(Some(HashMap::new())),\n     }, CrateAnalysis {\n         exported_items: exported_items,\n         public_items: public_items,\n+        external_paths: RefCell::new(None),\n     })\n }\n \n@@ -116,5 +123,7 @@ pub fn run_core(libs: HashSet<Path>, cfgs: Vec<~str>, path: &Path)\n         v.clean()\n     };\n \n+    let external_paths = ctxt.external_paths.borrow_mut().take();\n+    *analysis.external_paths.borrow_mut() = external_paths;\n     (krate, analysis)\n }"}, {"sha": "7038ce75a840b84118fca9e5a88fdcd912484b7e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 19, "deletions": 42, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e850316408bbe6254305cf4aa7c65381dc475192", "patch": "@@ -146,41 +146,28 @@ impl fmt::Show for clean::Path {\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n-fn resolved_path(w: &mut io::Writer, id: ast::NodeId, p: &clean::Path,\n+fn resolved_path(w: &mut io::Writer, did: ast::DefId, p: &clean::Path,\n                  print_all: bool) -> fmt::Result {\n     path(w, p, print_all,\n-        |_cache, loc| { Some(\"../\".repeat(loc.len())) },\n+        |cache, loc| {\n+            if ast_util::is_local(did) {\n+                Some(\"../\".repeat(loc.len()))\n+            } else {\n+                match *cache.extern_locations.get(&did.krate) {\n+                    render::Remote(ref s) => Some(s.clone()),\n+                    render::Local => Some(\"../\".repeat(loc.len())),\n+                    render::Unknown => None,\n+                }\n+            }\n+        },\n         |cache| {\n-            match cache.paths.find(&id) {\n+            match cache.paths.find(&did) {\n                 None => None,\n                 Some(&(ref fqp, shortty)) => Some((fqp.clone(), shortty))\n             }\n         })\n }\n \n-/// Used when rendering an `ExternalPath` structure. Like `resolved_path` this\n-/// will invoke `path` with proper linking-style arguments.\n-fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n-                 fqn: &[~str], kind: clean::TypeKind,\n-                 krate: ast::CrateNum) -> fmt::Result {\n-    path(w, p, print_all,\n-        |cache, loc| {\n-            match *cache.extern_locations.get(&krate) {\n-                render::Remote(ref s) => Some(s.clone()),\n-                render::Local => Some(\"../\".repeat(loc.len())),\n-                render::Unknown => None,\n-            }\n-        },\n-        |_cache| {\n-            Some((Vec::from_slice(fqn), match kind {\n-                clean::TypeStruct => item_type::Struct,\n-                clean::TypeEnum => item_type::Enum,\n-                clean::TypeFunction => item_type::Function,\n-                clean::TypeTrait => item_type::Trait,\n-            }))\n-        })\n-}\n-\n fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         root: |&render::Cache, &[~str]| -> Option<~str>,\n         info: |&render::Cache| -> Option<(Vec<~str> , ItemType)>)\n@@ -298,15 +285,9 @@ impl fmt::Show for clean::Type {\n                 let m = cache_key.get().unwrap();\n                 f.buf.write(m.typarams.get(&id).as_bytes())\n             }\n-            clean::ResolvedPath{id, typarams: ref tp, path: ref path} => {\n-                try!(resolved_path(f.buf, id, path, false));\n-                tybounds(f.buf, tp)\n-            }\n-            clean::ExternalPath{path: ref path, typarams: ref tp,\n-                                fqn: ref fqn, kind, krate} => {\n-                try!(external_path(f.buf, path, false, fqn.as_slice(), kind,\n-                                     krate))\n-                tybounds(f.buf, tp)\n+            clean::ResolvedPath{ did, ref typarams, ref path} => {\n+                try!(resolved_path(f.buf, did, path, false));\n+                tybounds(f.buf, typarams)\n             }\n             clean::Self(..) => f.buf.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => {\n@@ -543,10 +524,7 @@ impl fmt::Show for clean::ViewPath {\n impl fmt::Show for clean::ImportSource {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.did {\n-            // FIXME: shouldn't be restricted to just local imports\n-            Some(did) if ast_util::is_local(did) => {\n-                resolved_path(f.buf, did.node, &self.path, true)\n-            }\n+            Some(did) => resolved_path(f.buf, did, &self.path, true),\n             _ => {\n                 for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {\n@@ -563,8 +541,7 @@ impl fmt::Show for clean::ImportSource {\n impl fmt::Show for clean::ViewListIdent {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.source {\n-            // FIXME: shouldn't be limited to just local imports\n-            Some(did) if ast_util::is_local(did) => {\n+            Some(did) => {\n                 let path = clean::Path {\n                     global: false,\n                     segments: vec!(clean::PathSegment {\n@@ -573,7 +550,7 @@ impl fmt::Show for clean::ViewListIdent {\n                         types: Vec::new(),\n                     })\n                 };\n-                resolved_path(f.buf, did.node, &path, false)\n+                resolved_path(f.buf, did, &path, false)\n             }\n             _ => write!(f.buf, \"{}\", self.name),\n         }"}, {"sha": "a19d0b6fb301bc8c4ed37d970f8b3aa9435e3b2c", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=e850316408bbe6254305cf4aa7c65381dc475192", "patch": "@@ -44,9 +44,9 @@ impl ItemType {\n         match *self {\n             Module          => \"mod\",\n             Struct          => \"struct\",\n-            Enum            => \"enum\",\n+            Enum            => \"type\",\n             Function        => \"fn\",\n-            Typedef         => \"typedef\",\n+            Typedef         => \"type\",\n             Static          => \"static\",\n             Trait           => \"trait\",\n             Impl            => \"impl\","}, {"sha": "370ac79c04df319940e7190815059e3d5df40ec9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 62, "deletions": 26, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e850316408bbe6254305cf4aa7c65381dc475192", "patch": "@@ -43,20 +43,21 @@ use std::strbuf::StrBuf;\n use sync::Arc;\n use serialize::json::ToJson;\n use syntax::ast;\n+use syntax::ast_util;\n use syntax::attr;\n use syntax::parse::token::InternedString;\n use rustc::util::nodemap::NodeSet;\n \n use clean;\n use doctree;\n use fold::DocFolder;\n-use html::item_type;\n-use html::item_type::{ItemType, shortty};\n use html::format::{VisSpace, Method, FnStyleSpace};\n+use html::highlight;\n+use html::item_type::{ItemType, shortty};\n+use html::item_type;\n use html::layout;\n-use html::markdown;\n use html::markdown::Markdown;\n-use html::highlight;\n+use html::markdown;\n \n /// Major driving force in all rustdoc rendering. This contains information\n /// about where in the tree-like hierarchy rendering is occurring and controls\n@@ -138,7 +139,7 @@ pub struct Cache {\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    pub paths: HashMap<ast::NodeId, (Vec<~str> , ItemType)>,\n+    pub paths: HashMap<ast::DefId, (Vec<~str>, ItemType)>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n@@ -242,20 +243,34 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     }\n \n     // Crawl the crate to build various caches used for the output\n-    let public_items = ::analysiskey.get().map(|a| a.public_items.clone());\n-    let public_items = public_items.unwrap_or(NodeSet::new());\n+    let analysis = ::analysiskey.get();\n+    let public_items = analysis.as_ref().map(|a| a.public_items.clone());\n+    let paths = analysis.as_ref().map(|a| {\n+        let paths = a.external_paths.borrow_mut().take_unwrap();\n+        paths.move_iter().map(|(k, (v, t))| {\n+            (k, (v, match t {\n+                clean::TypeStruct => item_type::Struct,\n+                clean::TypeEnum => item_type::Enum,\n+                clean::TypeFunction => item_type::Function,\n+                clean::TypeTrait => item_type::Trait,\n+                clean::TypeModule => item_type::Module,\n+                clean::TypeStatic => item_type::Static,\n+                clean::TypeVariant => item_type::Variant,\n+            }))\n+        }).collect()\n+    }).unwrap_or(HashMap::new());\n     let mut cache = Cache {\n         impls: HashMap::new(),\n         typarams: HashMap::new(),\n-        paths: HashMap::new(),\n+        paths: paths,\n         traits: HashMap::new(),\n         implementors: HashMap::new(),\n         stack: Vec::new(),\n         parent_stack: Vec::new(),\n         search_index: Vec::new(),\n         extern_locations: HashMap::new(),\n         privmod: false,\n-        public_items: public_items,\n+        public_items: public_items.unwrap_or(NodeSet::new()),\n         orphan_methods: Vec::new(),\n     };\n     cache.stack.push(krate.name.clone());\n@@ -269,15 +284,16 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n \n         // Attach all orphan methods to the type's definition if the type\n         // has since been learned.\n-        for &(ref pid, ref item) in meths.iter() {\n-            match paths.find(pid) {\n+        for &(pid, ref item) in meths.iter() {\n+            let did = ast_util::local_def(pid);\n+            match paths.find(&did) {\n                 Some(&(ref fqp, _)) => {\n                     index.push(IndexItem {\n                         ty: shortty(item),\n                         name: item.name.clone().unwrap(),\n                         path: fqp.slice_to(fqp.len() - 1).connect(\"::\"),\n                         desc: shorter(item.doc_value()).to_owned(),\n-                        parent: Some(*pid),\n+                        parent: Some(pid),\n                     });\n                 },\n                 None => {}\n@@ -336,7 +352,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         try!(write!(&mut w, r#\"],\"paths\":[\"#));\n \n         for (i, &nodeid) in pathid_to_nodeid.iter().enumerate() {\n-            let &(ref fqp, short) = cache.paths.find(&nodeid).unwrap();\n+            let def = ast_util::local_def(nodeid);\n+            let &(ref fqp, short) = cache.paths.find(&def).unwrap();\n             if i > 0 {\n                 try!(write!(&mut w, \",\"));\n             }\n@@ -414,6 +431,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n \n     for &(n, ref e) in krate.externs.iter() {\n         cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n+        let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n+        cache.paths.insert(did, (Vec::new(), item_type::Module));\n     }\n \n     // And finally render the whole crate's documentation\n@@ -606,7 +625,12 @@ impl DocFolder for Cache {\n         match item.inner {\n             clean::ImplItem(ref i) => {\n                 match i.trait_ {\n-                    Some(clean::ResolvedPath{ id, .. }) => {\n+                    // FIXME: this is_local() check seems to be losing\n+                    // information\n+                    Some(clean::ResolvedPath{ did, .. })\n+                        if ast_util::is_local(did) =>\n+                    {\n+                        let id = did.node;\n                         let v = self.implementors.find_or_insert_with(id, |_|{\n                             Vec::new()\n                         });\n@@ -643,7 +667,8 @@ impl DocFolder for Cache {\n                             (None, None)\n                         } else {\n                             let last = self.parent_stack.last().unwrap();\n-                            let path = match self.paths.find(last) {\n+                            let did = ast_util::local_def(*last);\n+                            let path = match self.paths.find(&did) {\n                                 Some(&(_, item_type::Trait)) =>\n                                     Some(self.stack.slice_to(self.stack.len() - 1)),\n                                 // The current stack not necessarily has correlation for\n@@ -699,18 +724,20 @@ impl DocFolder for Cache {\n                 // a reexported item doesn't show up in the `public_items` map,\n                 // so we can skip inserting into the paths map if there was\n                 // already an entry present and we're not a public item.\n-                if !self.paths.contains_key(&item.id) ||\n+                let did = ast_util::local_def(item.id);\n+                if !self.paths.contains_key(&did) ||\n                    self.public_items.contains(&item.id) {\n-                    self.paths.insert(item.id,\n-                                      (self.stack.clone(), shortty(&item)));\n+                    self.paths.insert(did, (self.stack.clone(),\n+                                            shortty(&item)));\n                 }\n             }\n             // link variants to their parent enum because pages aren't emitted\n             // for each variant\n             clean::VariantItem(..) => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n-                self.paths.insert(item.id, (stack, item_type::Enum));\n+                self.paths.insert(ast_util::local_def(item.id),\n+                                  (stack, item_type::Enum));\n             }\n             _ => {}\n         }\n@@ -722,8 +749,13 @@ impl DocFolder for Cache {\n             }\n             clean::ImplItem(ref i) => {\n                 match i.for_ {\n-                    clean::ResolvedPath{ id, .. } => {\n-                        self.parent_stack.push(id); true\n+                    clean::ResolvedPath{ did, .. } => {\n+                        if ast_util::is_local(did) {\n+                            self.parent_stack.push(did.node);\n+                            true\n+                        } else {\n+                            false\n+                        }\n                     }\n                     _ => false\n                 }\n@@ -738,8 +770,10 @@ impl DocFolder for Cache {\n                 match item {\n                     clean::Item{ attrs, inner: clean::ImplItem(i), .. } => {\n                         match i.for_ {\n-                            clean::ResolvedPath { id, .. } => {\n-                                let v = self.impls.find_or_insert_with(id, |_| {\n+                            clean::ResolvedPath { did, .. }\n+                                if ast_util::is_local(did) =>\n+                            {\n+                                let v = self.impls.find_or_insert_with(did.node, |_| {\n                                     Vec::new()\n                                 });\n                                 // extract relevant documentation for this impl\n@@ -1596,7 +1630,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n         Some(ref ty) => {\n             try!(write!(w, \"{} for \", *ty));\n             match *ty {\n-                clean::ResolvedPath { id, .. } => Some(id),\n+                clean::ResolvedPath { did, .. } => Some(did),\n                 _ => None,\n             }\n         }\n@@ -1635,9 +1669,10 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n     // default methods which weren't overridden in the implementation block.\n     match trait_id {\n         None => {}\n-        Some(id) => {\n+        // FIXME: this should work for non-local traits\n+        Some(did) if ast_util::is_local(did) => {\n             try!({\n-                match cache_key.get().unwrap().traits.find(&id) {\n+                match cache_key.get().unwrap().traits.find(&did.node) {\n                     Some(t) => {\n                         for method in t.methods.iter() {\n                             let n = method.item().name.clone();\n@@ -1654,6 +1689,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n                 Ok(())\n             })\n         }\n+        Some(..) => {}\n     }\n     try!(write!(w, \"</div>\"));\n     Ok(())"}, {"sha": "2ad8be462b2dadc3c008f8917f9df4a846036614", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=e850316408bbe6254305cf4aa7c65381dc475192", "patch": "@@ -65,9 +65,10 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n         impl<'a> fold::DocFolder for ImplStripper<'a> {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n                 match i.inner {\n-                    clean::ImplItem(clean::Impl{ for_: clean::ResolvedPath{ id: for_id, .. },\n-                                                 .. }) => {\n-                        if self.stripped.contains(&for_id) {\n+                    clean::ImplItem(clean::Impl{\n+                        for_: clean::ResolvedPath{ did, .. }, ..\n+                    }) => {\n+                        if self.stripped.contains(&did.node) {\n                             return None;\n                         }\n                     }\n@@ -146,8 +147,10 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::ModuleItem(..) => {}\n \n             // trait impls for private items should be stripped\n-            clean::ImplItem(clean::Impl{ for_: clean::ResolvedPath{ id: ref for_id, .. }, .. }) => {\n-                if !self.exported_items.contains(for_id) {\n+            clean::ImplItem(clean::Impl{\n+                for_: clean::ResolvedPath{ did, .. }, ..\n+            }) => {\n+                if !self.exported_items.contains(&did.node) {\n                     return None;\n                 }\n             }\n@@ -201,9 +204,9 @@ impl<'a> fold::DocFolder for ImplStripper<'a> {\n         match i.inner {\n             clean::ImplItem(ref imp) => {\n                 match imp.trait_ {\n-                    Some(clean::ResolvedPath{ id, .. }) => {\n+                    Some(clean::ResolvedPath{ did, .. }) => {\n                         let ImplStripper(s) = *self;\n-                        if !s.contains(&id) {\n+                        if !s.contains(&did.node) {\n                             return None;\n                         }\n                     }"}, {"sha": "c8a19183485e1e61330ec9ff8a923058f50711b3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e850316408bbe6254305cf4aa7c65381dc475192", "patch": "@@ -16,7 +16,7 @@ use std::os;\n use std::str;\n use std::strbuf::StrBuf;\n \n-use collections::HashSet;\n+use collections::{HashSet, HashMap};\n use testing;\n use rustc::back::link;\n use rustc::driver::driver;\n@@ -73,6 +73,7 @@ pub fn run(input: &str,\n         krate: krate,\n         maybe_typed: core::NotTyped(sess),\n         src: input_path,\n+        external_paths: RefCell::new(Some(HashMap::new())),\n     };\n     super::ctxtkey.replace(Some(ctx));\n "}, {"sha": "0ac6f1dba4fa032628377ccbf529b97906f6b573", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e850316408bbe6254305cf4aa7c65381dc475192", "patch": "@@ -16,11 +16,11 @@\n //!\n //! ## Intrinsic types and operations\n //!\n-//! The [`ptr`](ptr/index.html), [`mem`](mem/index.html),\n-//! and [`cast`](cast/index.html) modules deal with unsafe pointers,\n+//! The [`ptr`](../core/ptr/index.html), [`mem`](../core/mem/index.html),\n+//! and [`cast`](../core/cast/index.html) modules deal with unsafe pointers,\n //! memory manipulation, and coercion.\n-//! [`kinds`](kinds/index.html) defines the special built-in traits,\n-//! and [`raw`](raw/index.html) the runtime representation of Rust types.\n+//! [`kinds`](../core/kinds/index.html) defines the special built-in traits,\n+//! and [`raw`](../core/raw/index.html) the runtime representation of Rust types.\n //! These are some of the lowest-level building blocks of Rust\n //! abstractions.\n //!\n@@ -35,9 +35,9 @@\n //!\n //! The [`option`](option/index.html) and [`result`](result/index.html)\n //! modules define optional and error-handling types, `Option` and `Result`.\n-//! [`iter`](iter/index.html) defines Rust's iterator protocol\n+//! [`iter`](../core/iter/index.html) defines Rust's iterator protocol\n //! along with a wide variety of iterators.\n-//! [`Cell` and `RefCell`](cell/index.html) are for creating types that\n+//! [`Cell` and `RefCell`](../core/cell/index.html) are for creating types that\n //! manage their own mutability.\n //!\n //! ## Vectors, slices and strings"}, {"sha": "ecbc164590b5e85b81a21c1925676bd28c8cbf70", "filename": "src/libstd/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e850316408bbe6254305cf4aa7c65381dc475192/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=e850316408bbe6254305cf4aa7c65381dc475192", "patch": "@@ -226,8 +226,8 @@\n //! similar and complementary: they are often employed to indicate a\n //! lack of a return value; and they are trivially converted between\n //! each other, so `Result`s are often handled by first converting to\n-//! `Option` with the [`ok`](enum.Result.html#method.ok) and\n-//! [`err`](enum.Result.html#method.ok) methods.\n+//! `Option` with the [`ok`](../../core/result/enum.Result.html#method.ok) and\n+//! [`err`](../../core/result/enum.Result.html#method.ok) methods.\n //!\n //! Whereas `Option` only indicates the lack of a value, `Result` is\n //! specifically for error reporting, and carries with it an error"}]}