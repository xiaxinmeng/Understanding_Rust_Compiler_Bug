{"sha": "bee0608fadc1d10f525171d0986ada74024beb83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZTA2MDhmYWRjMWQxMGY1MjUxNzFkMDk4NmFkYTc0MDI0YmViODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-01T07:43:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-01T07:43:16Z"}, "message": "Auto merge of #5623 - JarredAllen:sort_by_key_reverse, r=phansch\n\nNew lint: Use Reverse with sort_by_key\n\nImplements  #5578\n\nchangelog: New lint: [`unnecessary_sort_by`]", "tree": {"sha": "afc031558abfa36ebe5225aa18105e01c299a146", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afc031558abfa36ebe5225aa18105e01c299a146"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bee0608fadc1d10f525171d0986ada74024beb83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bee0608fadc1d10f525171d0986ada74024beb83", "html_url": "https://github.com/rust-lang/rust/commit/bee0608fadc1d10f525171d0986ada74024beb83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bee0608fadc1d10f525171d0986ada74024beb83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c008d7e91edee907fca45741ac70560c66f0222", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c008d7e91edee907fca45741ac70560c66f0222", "html_url": "https://github.com/rust-lang/rust/commit/6c008d7e91edee907fca45741ac70560c66f0222"}, {"sha": "b89880a30ce4dd7887614f305a565b6779dc4825", "url": "https://api.github.com/repos/rust-lang/rust/commits/b89880a30ce4dd7887614f305a565b6779dc4825", "html_url": "https://github.com/rust-lang/rust/commit/b89880a30ce4dd7887614f305a565b6779dc4825"}], "stats": {"total": 378, "additions": 378, "deletions": 0}, "files": [{"sha": "086a1141be55219015bafec79a39b532ea701bca", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bee0608fadc1d10f525171d0986ada74024beb83/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/bee0608fadc1d10f525171d0986ada74024beb83/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=bee0608fadc1d10f525171d0986ada74024beb83", "patch": "@@ -1601,6 +1601,7 @@ Released 2018-09-13\n [`unnecessary_fold`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_fold\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n+[`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by\n [`unnecessary_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_unwrap\n [`unneeded_field_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_field_pattern\n [`unneeded_wildcard_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_wildcard_pattern"}, {"sha": "03addf1f4a40c03112f7342f5623dea6b36bf1d7", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bee0608fadc1d10f525171d0986ada74024beb83/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee0608fadc1d10f525171d0986ada74024beb83/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=bee0608fadc1d10f525171d0986ada74024beb83", "patch": "@@ -318,6 +318,7 @@ mod try_err;\n mod types;\n mod unicode;\n mod unnamed_address;\n+mod unnecessary_sort_by;\n mod unsafe_removed_from_name;\n mod unused_io_amount;\n mod unused_self;\n@@ -833,6 +834,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &unicode::ZERO_WIDTH_SPACE,\n         &unnamed_address::FN_ADDRESS_COMPARISONS,\n         &unnamed_address::VTABLE_ADDRESS_COMPARISONS,\n+        &unnecessary_sort_by::UNNECESSARY_SORT_BY,\n         &unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n         &unused_io_amount::UNUSED_IO_AMOUNT,\n         &unused_self::UNUSED_SELF,\n@@ -996,6 +998,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box ptr_offset_with_cast::PtrOffsetWithCast);\n     store.register_late_pass(|| box redundant_clone::RedundantClone);\n     store.register_late_pass(|| box slow_vector_initialization::SlowVectorInit);\n+    store.register_late_pass(|| box unnecessary_sort_by::UnnecessarySortBy);\n     store.register_late_pass(|| box types::RefToMut);\n     store.register_late_pass(|| box assertions_on_constants::AssertionsOnConstants);\n     store.register_late_pass(|| box missing_const_for_fn::MissingConstForFn);\n@@ -1427,6 +1430,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&unicode::ZERO_WIDTH_SPACE),\n         LintId::of(&unnamed_address::FN_ADDRESS_COMPARISONS),\n         LintId::of(&unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n+        LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n         LintId::of(&unused_io_amount::UNUSED_IO_AMOUNT),\n         LintId::of(&unwrap::PANICKING_UNWRAP),\n@@ -1608,6 +1612,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::UNIT_ARG),\n         LintId::of(&types::UNNECESSARY_CAST),\n         LintId::of(&types::VEC_BOX),\n+        LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n         LintId::of(&useless_conversion::USELESS_CONVERSION),\n         LintId::of(&zero_div_zero::ZERO_DIVIDED_BY_ZERO),"}, {"sha": "33d8331c2923c4b376b7964217abd9272c18ee4f", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/bee0608fadc1d10f525171d0986ada74024beb83/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee0608fadc1d10f525171d0986ada74024beb83/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=bee0608fadc1d10f525171d0986ada74024beb83", "patch": "@@ -0,0 +1,267 @@\n+use crate::utils;\n+use crate::utils::paths;\n+use crate::utils::sugg::Sugg;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Ident;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Detects when people use `Vec::sort_by` and pass in a function\n+    /// which compares the two arguments, either directly or indirectly.\n+    ///\n+    /// **Why is this bad?**\n+    /// It is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\n+    /// possible) than to use `Vec::sort_by` and and a more complicated\n+    /// closure.\n+    ///\n+    /// **Known problems:**\n+    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't\n+    /// imported by a use statement in the current frame, then a `use`\n+    /// statement that imports it will need to be added (which this lint\n+    /// can't do).\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # struct A;\n+    /// # impl A { fn foo(&self) {} }\n+    /// # let mut vec: Vec<A> = Vec::new();\n+    /// vec.sort_by(|a, b| a.foo().cmp(&b.foo()));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # struct A;\n+    /// # impl A { fn foo(&self) {} }\n+    /// # let mut vec: Vec<A> = Vec::new();\n+    /// vec.sort_by_key(|a| a.foo());\n+    /// ```\n+    pub UNNECESSARY_SORT_BY,\n+    complexity,\n+    \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\"\n+}\n+\n+declare_lint_pass!(UnnecessarySortBy => [UNNECESSARY_SORT_BY]);\n+\n+enum LintTrigger {\n+    Sort(SortDetection),\n+    SortByKey(SortByKeyDetection),\n+}\n+\n+struct SortDetection {\n+    vec_name: String,\n+    unstable: bool,\n+}\n+\n+struct SortByKeyDetection {\n+    vec_name: String,\n+    closure_arg: String,\n+    closure_body: String,\n+    reverse: bool,\n+    unstable: bool,\n+}\n+\n+/// Detect if the two expressions are mirrored (identical, except one\n+/// contains a and the other replaces it with b)\n+fn mirrored_exprs(\n+    cx: &LateContext<'_, '_>,\n+    a_expr: &Expr<'_>,\n+    a_ident: &Ident,\n+    b_expr: &Expr<'_>,\n+    b_ident: &Ident,\n+) -> bool {\n+    match (&a_expr.kind, &b_expr.kind) {\n+        // Two boxes with mirrored contents\n+        (ExprKind::Box(left_expr), ExprKind::Box(right_expr)) => {\n+            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+        },\n+        // Two arrays with mirrored contents\n+        (ExprKind::Array(left_exprs), ExprKind::Array(right_exprs)) => left_exprs\n+            .iter()\n+            .zip(right_exprs.iter())\n+            .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        // The two exprs are function calls.\n+        // Check to see that the function itself and its arguments are mirrored\n+        (ExprKind::Call(left_expr, left_args), ExprKind::Call(right_expr, right_args)) => {\n+            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+                && left_args\n+                    .iter()\n+                    .zip(right_args.iter())\n+                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+        },\n+        // The two exprs are method calls.\n+        // Check to see that the function is the same and the arguments are mirrored\n+        // This is enough because the receiver of the method is listed in the arguments\n+        (ExprKind::MethodCall(left_segment, _, left_args), ExprKind::MethodCall(right_segment, _, right_args)) => {\n+            left_segment.ident == right_segment.ident\n+                && left_args\n+                    .iter()\n+                    .zip(right_args.iter())\n+                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+        },\n+        // Two tuples with mirrored contents\n+        (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => left_exprs\n+            .iter()\n+            .zip(right_exprs.iter())\n+            .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        // Two binary ops, which are the same operation and which have mirrored arguments\n+        (ExprKind::Binary(left_op, left_left, left_right), ExprKind::Binary(right_op, right_left, right_right)) => {\n+            left_op.node == right_op.node\n+                && mirrored_exprs(cx, left_left, a_ident, right_left, b_ident)\n+                && mirrored_exprs(cx, left_right, a_ident, right_right, b_ident)\n+        },\n+        // Two unary ops, which are the same operation and which have the same argument\n+        (ExprKind::Unary(left_op, left_expr), ExprKind::Unary(right_op, right_expr)) => {\n+            left_op == right_op && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+        },\n+        // The two exprs are literals of some kind\n+        (ExprKind::Lit(left_lit), ExprKind::Lit(right_lit)) => left_lit.node == right_lit.node,\n+        (ExprKind::Cast(left, _), ExprKind::Cast(right, _)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n+        (ExprKind::DropTemps(left_block), ExprKind::DropTemps(right_block)) => {\n+            mirrored_exprs(cx, left_block, a_ident, right_block, b_ident)\n+        },\n+        (ExprKind::Field(left_expr, left_ident), ExprKind::Field(right_expr, right_ident)) => {\n+            left_ident.name == right_ident.name && mirrored_exprs(cx, left_expr, a_ident, right_expr, right_ident)\n+        },\n+        // Two paths: either one is a and the other is b, or they're identical to each other\n+        (\n+            ExprKind::Path(QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: left_segments,\n+                    ..\n+                },\n+            )),\n+            ExprKind::Path(QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: right_segments,\n+                    ..\n+                },\n+            )),\n+        ) => {\n+            (left_segments\n+                .iter()\n+                .zip(right_segments.iter())\n+                .all(|(left, right)| left.ident == right.ident)\n+                && left_segments\n+                    .iter()\n+                    .all(|seg| &seg.ident != a_ident && &seg.ident != b_ident))\n+                || (left_segments.len() == 1\n+                    && &left_segments[0].ident == a_ident\n+                    && right_segments.len() == 1\n+                    && &right_segments[0].ident == b_ident)\n+        },\n+        // Matching expressions, but one or both is borrowed\n+        (\n+            ExprKind::AddrOf(left_kind, Mutability::Not, left_expr),\n+            ExprKind::AddrOf(right_kind, Mutability::Not, right_expr),\n+        ) => left_kind == right_kind && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n+        (_, ExprKind::AddrOf(_, Mutability::Not, right_expr)) => {\n+            mirrored_exprs(cx, a_expr, a_ident, right_expr, b_ident)\n+        },\n+        (ExprKind::AddrOf(_, Mutability::Not, left_expr), _) => mirrored_exprs(cx, left_expr, a_ident, b_expr, b_ident),\n+        _ => false,\n+    }\n+}\n+\n+fn detect_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(name_ident, _, args) = &expr.kind;\n+        if let name = name_ident.ident.name.to_ident_string();\n+        if name == \"sort_by\" || name == \"sort_unstable_by\";\n+        if let [vec, Expr { kind: ExprKind::Closure(_, _, closure_body_id, _, _), .. }] = args;\n+        if utils::match_type(cx, &cx.tables.expr_ty(vec), &paths::VEC);\n+        if let closure_body = cx.tcx.hir().body(*closure_body_id);\n+        if let &[\n+            Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},\n+            Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n+        ] = &closure_body.params;\n+        if let ExprKind::MethodCall(method_path, _, [ref left_expr, ref right_expr]) = &closure_body.value.kind;\n+        if method_path.ident.name.to_ident_string() == \"cmp\";\n+        then {\n+            let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n+                &cx,\n+                &left_expr,\n+                &left_ident,\n+                &right_expr,\n+                &right_ident\n+            ) {\n+                (Sugg::hir(cx, &left_expr, \"..\").to_string(), left_ident.name.to_string(), false)\n+            } else if mirrored_exprs(&cx, &left_expr, &right_ident, &right_expr, &left_ident) {\n+                (Sugg::hir(cx, &left_expr, \"..\").to_string(), right_ident.name.to_string(), true)\n+            } else {\n+                return None;\n+            };\n+            let vec_name = Sugg::hir(cx, &args[0], \"..\").to_string();\n+            let unstable = name == \"sort_unstable_by\";\n+            if_chain! {\n+                if let ExprKind::Path(QPath::Resolved(_, Path {\n+                    segments: [PathSegment { ident: left_name, .. }], ..\n+                })) = &left_expr.kind;\n+                if left_name == left_ident;\n+                then {\n+                    Some(LintTrigger::Sort(SortDetection { vec_name, unstable }))\n+                }\n+                else {\n+                    Some(LintTrigger::SortByKey(SortByKeyDetection {\n+                        vec_name,\n+                        unstable,\n+                        closure_arg,\n+                        closure_body,\n+                        reverse\n+                    }))\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl LateLintPass<'_, '_> for UnnecessarySortBy {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+        match detect_lint(cx, expr) {\n+            Some(LintTrigger::SortByKey(trigger)) => utils::span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_SORT_BY,\n+                expr.span,\n+                \"use Vec::sort_by_key here instead\",\n+                \"try\",\n+                format!(\n+                    \"{}.sort{}_by_key(|&{}| {})\",\n+                    trigger.vec_name,\n+                    if trigger.unstable { \"_unstable\" } else { \"\" },\n+                    trigger.closure_arg,\n+                    if trigger.reverse {\n+                        format!(\"Reverse({})\", trigger.closure_body)\n+                    } else {\n+                        trigger.closure_body.to_string()\n+                    },\n+                ),\n+                if trigger.reverse {\n+                    Applicability::MaybeIncorrect\n+                } else {\n+                    Applicability::MachineApplicable\n+                },\n+            ),\n+            Some(LintTrigger::Sort(trigger)) => utils::span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_SORT_BY,\n+                expr.span,\n+                \"use Vec::sort here instead\",\n+                \"try\",\n+                format!(\n+                    \"{}.sort{}()\",\n+                    trigger.vec_name,\n+                    if trigger.unstable { \"_unstable\" } else { \"\" },\n+                ),\n+                Applicability::MachineApplicable,\n+            ),\n+            None => {},\n+        }\n+    }\n+}"}, {"sha": "ab9542a7b9c8cc745a89e3c96f5f5288eada8766", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bee0608fadc1d10f525171d0986ada74024beb83/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee0608fadc1d10f525171d0986ada74024beb83/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=bee0608fadc1d10f525171d0986ada74024beb83", "patch": "@@ -2292,6 +2292,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"no_effect\",\n     },\n+    Lint {\n+        name: \"unnecessary_sort_by\",\n+        group: \"complexity\",\n+        desc: \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\",\n+        deprecation: None,\n+        module: \"unnecessary_sort_by\",\n+    },\n     Lint {\n         name: \"unnecessary_unwrap\",\n         group: \"complexity\","}, {"sha": "779fd57707ad4f517e9ec9e6b235c728f5996008", "filename": "tests/ui/unnecessary_sort_by.fixed", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bee0608fadc1d10f525171d0986ada74024beb83/tests%2Fui%2Funnecessary_sort_by.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bee0608fadc1d10f525171d0986ada74024beb83/tests%2Fui%2Funnecessary_sort_by.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.fixed?ref=bee0608fadc1d10f525171d0986ada74024beb83", "patch": "@@ -0,0 +1,26 @@\n+// run-rustfix\n+\n+use std::cmp::Reverse;\n+\n+fn id(x: isize) -> isize {\n+    x\n+}\n+\n+fn main() {\n+    let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n+    // Forward examples\n+    vec.sort();\n+    vec.sort_unstable();\n+    vec.sort_by_key(|&a| (a + 5).abs());\n+    vec.sort_unstable_by_key(|&a| id(-a));\n+    // Reverse examples\n+    vec.sort_by_key(|&b| Reverse(b));\n+    vec.sort_by_key(|&b| Reverse((b + 5).abs()));\n+    vec.sort_unstable_by_key(|&b| Reverse(id(-b)));\n+    // Negative examples (shouldn't be changed)\n+    let c = &7;\n+    vec.sort_by(|a, b| (b - a).cmp(&(a - b)));\n+    vec.sort_by(|_, b| b.cmp(&5));\n+    vec.sort_by(|_, b| b.cmp(c));\n+    vec.sort_unstable_by(|a, _| a.cmp(c));\n+}"}, {"sha": "0485a5630afef682c80e9729bbf2855c9d782b62", "filename": "tests/ui/unnecessary_sort_by.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bee0608fadc1d10f525171d0986ada74024beb83/tests%2Fui%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee0608fadc1d10f525171d0986ada74024beb83/tests%2Fui%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.rs?ref=bee0608fadc1d10f525171d0986ada74024beb83", "patch": "@@ -0,0 +1,26 @@\n+// run-rustfix\n+\n+use std::cmp::Reverse;\n+\n+fn id(x: isize) -> isize {\n+    x\n+}\n+\n+fn main() {\n+    let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n+    // Forward examples\n+    vec.sort_by(|a, b| a.cmp(b));\n+    vec.sort_unstable_by(|a, b| a.cmp(b));\n+    vec.sort_by(|a, b| (a + 5).abs().cmp(&(b + 5).abs()));\n+    vec.sort_unstable_by(|a, b| id(-a).cmp(&id(-b)));\n+    // Reverse examples\n+    vec.sort_by(|a, b| b.cmp(a));\n+    vec.sort_by(|a, b| (b + 5).abs().cmp(&(a + 5).abs()));\n+    vec.sort_unstable_by(|a, b| id(-b).cmp(&id(-a)));\n+    // Negative examples (shouldn't be changed)\n+    let c = &7;\n+    vec.sort_by(|a, b| (b - a).cmp(&(a - b)));\n+    vec.sort_by(|_, b| b.cmp(&5));\n+    vec.sort_by(|_, b| b.cmp(c));\n+    vec.sort_unstable_by(|a, _| a.cmp(c));\n+}"}, {"sha": "903b6e5099ce8b68c9aa1363a8b7999418ca52ee", "filename": "tests/ui/unnecessary_sort_by.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bee0608fadc1d10f525171d0986ada74024beb83/tests%2Fui%2Funnecessary_sort_by.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bee0608fadc1d10f525171d0986ada74024beb83/tests%2Fui%2Funnecessary_sort_by.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.stderr?ref=bee0608fadc1d10f525171d0986ada74024beb83", "patch": "@@ -0,0 +1,46 @@\n+error: use Vec::sort here instead\n+  --> $DIR/unnecessary_sort_by.rs:12:5\n+   |\n+LL |     vec.sort_by(|a, b| a.cmp(b));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort()`\n+   |\n+   = note: `-D clippy::unnecessary-sort-by` implied by `-D warnings`\n+\n+error: use Vec::sort here instead\n+  --> $DIR/unnecessary_sort_by.rs:13:5\n+   |\n+LL |     vec.sort_unstable_by(|a, b| a.cmp(b));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable()`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:14:5\n+   |\n+LL |     vec.sort_by(|a, b| (a + 5).abs().cmp(&(b + 5).abs()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&a| (a + 5).abs())`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:15:5\n+   |\n+LL |     vec.sort_unstable_by(|a, b| id(-a).cmp(&id(-b)));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|&a| id(-a))`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:17:5\n+   |\n+LL |     vec.sort_by(|a, b| b.cmp(a));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse(b))`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:18:5\n+   |\n+LL |     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a + 5).abs()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse((b + 5).abs()))`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:19:5\n+   |\n+LL |     vec.sort_unstable_by(|a, b| id(-b).cmp(&id(-a)));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|&b| Reverse(id(-b)))`\n+\n+error: aborting due to 7 previous errors\n+"}]}