{"sha": "c985648593122a6fc8ec146a9ca755b73d0dc788", "node_id": "C_kwDOAAsO6NoAKGM5ODU2NDg1OTMxMjJhNmZjOGVjMTQ2YTljYTc1NWI3M2QwZGM3ODg", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-08-04T00:46:14Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-08-04T00:46:14Z"}, "message": "Remove Windows function preloading", "tree": {"sha": "a53a5f51c9e9a2584206706f0bc6edd228fab07c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a53a5f51c9e9a2584206706f0bc6edd228fab07c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c985648593122a6fc8ec146a9ca755b73d0dc788", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmLrFtYACgkQcTRy8vRW\nJ96fzg/7B0CFEA6058kWS0BBfRgWf8pfjxqCUaST1cS6FHdFGD4uh7IqAq0ek9VJ\nC5tKzZ/H/Z6EDIDu7vlSr+DKwcgZUqGNbJEtl80XymfkcbtijSQQ95X9YNazF9T8\n1dM8kek8TeTmmuBP7OdMDCs1U+2PeuK1VxKnG/DmwGpJ1TCHA9aGcBaIjvEUW1kb\ngmPQOeQbKZOijUcH95anFUVOMxolVvhNYlEStg1qhFyplxG5sZ0V46oE6ChPC8DX\n6+HhHlPv7ah7gH87objeqNpbr65MrHMptSeMlWA/OulwD10Xxkl41w7ZVzbhbSio\n12jaPXBNdbAkl3pm7BqlqYTJtpFO8thcYzirbw1tn2mDP/NeIINlBT28WuVLDG2D\no8NGRNltvdwofj4N54qSmwOmVPXZU7bfOFJ9eFhd5iFGxwjkiKBl2SOLu7islZvi\nMrCW06om+wzNVEOl41JhmAli4tS8LgWh48FwhyDYlhB7u90wG0cwygoCYoiXXnD/\ngPt0OzYvwP9zosFb3RFfwLGyQzW/155S1I3jdHy7wI25CMX674IwKu36yOJ2j0ql\nYsDNL6u2zhgxqqg/j10F/BabMZeNq3XGUI7lrRf2E8luh10iHH7fE4bwEHNUrNY8\n/ct3Y4mrVEyGHTE7BHD9xzqUhnRrzGbX7wGTVzo4jvokTAQk7CM=\n=Sq+Y\n-----END PGP SIGNATURE-----", "payload": "tree a53a5f51c9e9a2584206706f0bc6edd228fab07c\nparent aac82a9e187d314b770baa4bf1bda7ce3d113d01\nauthor Chris Denton <christophersdenton@gmail.com> 1659573974 +0100\ncommitter Chris Denton <christophersdenton@gmail.com> 1659573974 +0100\n\nRemove Windows function preloading\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c985648593122a6fc8ec146a9ca755b73d0dc788", "html_url": "https://github.com/rust-lang/rust/commit/c985648593122a6fc8ec146a9ca755b73d0dc788", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c985648593122a6fc8ec146a9ca755b73d0dc788/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aac82a9e187d314b770baa4bf1bda7ce3d113d01", "url": "https://api.github.com/repos/rust-lang/rust/commits/aac82a9e187d314b770baa4bf1bda7ce3d113d01", "html_url": "https://github.com/rust-lang/rust/commit/aac82a9e187d314b770baa4bf1bda7ce3d113d01"}], "stats": {"total": 244, "additions": 86, "deletions": 158}, "files": [{"sha": "c340baf2a4a2a5947505f5d2be0870cd42122e3f", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c985648593122a6fc8ec146a9ca755b73d0dc788/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c985648593122a6fc8ec146a9ca755b73d0dc788/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=c985648593122a6fc8ec146a9ca755b73d0dc788", "patch": "@@ -1250,19 +1250,15 @@ compat_fn_with_fallback! {\n     }\n }\n \n-compat_fn_optional! {\n+compat_fn_with_fallback! {\n     pub static SYNCH_API: &CStr = ansi_str!(\"api-ms-win-core-synch-l1-2-0\");\n-\n-    // >= Windows 8 / Server 2012\n-    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress\n-    pub fn WaitOnAddress(\n-        Address: LPVOID,\n-        CompareAddress: LPVOID,\n-        AddressSize: SIZE_T,\n-        dwMilliseconds: DWORD\n-    ) -> BOOL;\n-    pub fn WakeByAddressSingle(Address: LPVOID) -> ();\n+    #[allow(unused)]\n+    fn WakeByAddressSingle(Address: LPVOID) -> () {\n+        crate::sys::windows::thread_parker::unpark_keyed_event(Address)\n+    }\n }\n+pub use crate::sys::compat::WaitOnAddress;\n+pub use WakeByAddressSingle::call as wake_by_address_single_or_unpark_keyed_event;\n \n compat_fn_with_fallback! {\n     pub static NTDLL: &CStr = ansi_str!(\"ntdll\");"}, {"sha": "ca5b223513498eb56bc4418a922257e339b63405", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 63, "deletions": 132, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/c985648593122a6fc8ec146a9ca755b73d0dc788/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c985648593122a6fc8ec146a9ca755b73d0dc788/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=c985648593122a6fc8ec146a9ca755b73d0dc788", "patch": "@@ -7,47 +7,17 @@\n //! `GetModuleHandle` and `GetProcAddress` to look up DLL entry points at\n //! runtime.\n //!\n-//! This implementation uses a static initializer to look up the DLL entry\n-//! points. The CRT (C runtime) executes static initializers before `main`\n-//! is called (for binaries) and before `DllMain` is called (for DLLs).\n-//! This is the ideal time to look up DLL imports, because we are guaranteed\n-//! that no other threads will attempt to call these entry points. Thus,\n-//! we can look up the imports and store them in `static mut` fields\n-//! without any synchronization.\n+//! This is implemented simply by storing a function pointer in an atomic\n+//! and using relaxed ordering to load it. This means that calling it will be no\n+//! more expensive then calling any other dynamically imported function.\n //!\n-//! This has an additional advantage: Because the DLL import lookup happens\n-//! at module initialization, the cost of these lookups is deterministic,\n-//! and is removed from the code paths that actually call the DLL imports.\n-//! That is, there is no unpredictable \"cache miss\" that occurs when calling\n-//! a DLL import. For applications that benefit from predictable delays,\n-//! this is a benefit. This also eliminates the comparison-and-branch\n-//! from the hot path.\n-//!\n-//! Currently, the standard library uses only a small number of dynamic\n-//! DLL imports. If this number grows substantially, then the cost of\n-//! performing all of the lookups at initialization time might become\n-//! substantial.\n-//!\n-//! The mechanism of registering a static initializer with the CRT is\n-//! documented in\n-//! [CRT Initialization](https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-160).\n-//! It works by contributing a global symbol to the `.CRT$XCU` section.\n-//! The linker builds a table of all static initializer functions.\n-//! The CRT startup code then iterates that table, calling each\n-//! initializer function.\n-//!\n-//! # **WARNING!!*\n-//! The environment that a static initializer function runs in is highly\n-//! constrained. There are **many** restrictions on what static initializers\n-//! can safely do. Static initializer functions **MUST NOT** do any of the\n-//! following (this list is not comprehensive):\n-//! * touch any other static field that is used by a different static\n-//!   initializer, because the order that static initializers run in\n-//!   is not defined.\n-//! * call `LoadLibrary` or any other function that acquires the DLL\n-//!   loader lock.\n-//! * call any Rust function or CRT function that touches any static\n-//!   (global) state.\n+//! The stored function pointer starts out as an importer function which will\n+//! swap itself with the real function when it's called for the first time. If\n+//! the real function can't be imported then a fallback function is used in its\n+//! place. While this is zero cost for the happy path (where the function is\n+//! already loaded) it does mean there's some overhead the first time the\n+//! function is called. In the worst case, multiple threads may all end up\n+//! importing the same function unnecessarily.\n \n use crate::ffi::{c_void, CStr};\n use crate::ptr::NonNull;\n@@ -85,39 +55,6 @@ pub(crate) const fn const_cstr_from_bytes(bytes: &'static [u8]) -> &'static CStr\n     unsafe { crate::ffi::CStr::from_bytes_with_nul_unchecked(bytes) }\n }\n \n-#[used]\n-#[link_section = \".CRT$XCU\"]\n-static INIT_TABLE_ENTRY: unsafe extern \"C\" fn() = init;\n-\n-/// This is where the magic preloading of symbols happens.\n-///\n-/// Note that any functions included here will be unconditionally included in\n-/// the final binary, regardless of whether or not they're actually used.\n-///\n-/// Therefore, this is limited to `compat_fn_optional` functions which must be\n-/// preloaded and any functions which may be more time sensitive, even for the first call.\n-unsafe extern \"C\" fn init() {\n-    // There is no locking here. This code is executed before main() is entered, and\n-    // is guaranteed to be single-threaded.\n-    //\n-    // DO NOT do anything interesting or complicated in this function! DO NOT call\n-    // any Rust functions or CRT functions if those functions touch any global state,\n-    // because this function runs during global initialization. For example, DO NOT\n-    // do any dynamic allocation, don't call LoadLibrary, etc.\n-\n-    if let Some(synch) = Module::new(c::SYNCH_API) {\n-        // These are optional and so we must manually attempt to load them\n-        // before they can be used.\n-        c::WaitOnAddress::preload(synch);\n-        c::WakeByAddressSingle::preload(synch);\n-    }\n-\n-    if let Some(kernel32) = Module::new(c::KERNEL32) {\n-        // Preloading this means getting a precise time will be as fast as possible.\n-        c::GetSystemTimePreciseAsFileTime::preload(kernel32);\n-    }\n-}\n-\n /// Represents a loaded module.\n ///\n /// Note that the modules std depends on must not be unloaded.\n@@ -196,11 +133,6 @@ macro_rules! compat_fn_with_fallback {\n                 $fallback_body\n             }\n \n-            #[allow(unused)]\n-            pub(in crate::sys) fn preload(module: Module) {\n-                load_from_module(Some(module));\n-            }\n-\n             #[inline(always)]\n             pub unsafe fn call($($argname: $argtype),*) -> $rettype {\n                 let func: F = mem::transmute(PTR.load(Ordering::Relaxed));\n@@ -212,62 +144,61 @@ macro_rules! compat_fn_with_fallback {\n     )*)\n }\n \n-/// A function that either exists or doesn't.\n+/// Optionally load `WaitOnAddress`.\n+/// Unlike the dynamic loading described above, this does not have a fallback.\n ///\n-/// NOTE: Optional functions must be preloaded in the `init` function above, or they will always be None.\n-macro_rules! compat_fn_optional {\n-    (pub static $module:ident: &CStr = $name:expr; $(\n-        $(#[$meta:meta])*\n-        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty;\n-    )*) => (\n-        pub static $module: &CStr = $name;\n-    $(\n-        $(#[$meta])*\n-        pub mod $symbol {\n-            #[allow(unused_imports)]\n-            use super::*;\n-            use crate::mem;\n-            use crate::sync::atomic::{AtomicPtr, Ordering};\n-            use crate::sys::compat::Module;\n-            use crate::ptr::{self, NonNull};\n-\n-            type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n-\n-            /// `PTR` will either be `null()` or set to the loaded function.\n-            static PTR: AtomicPtr<c_void> = AtomicPtr::new(ptr::null_mut());\n-\n-            /// Only allow access to the function if it has loaded successfully.\n-            #[inline(always)]\n-            #[cfg(not(miri))]\n-            pub fn option() -> Option<F> {\n-                unsafe {\n-                    NonNull::new(PTR.load(Ordering::Relaxed)).map(|f| mem::transmute(f))\n-                }\n-            }\n-\n-            // Miri does not understand the way we do preloading\n-            // therefore load the function here instead.\n-            #[cfg(miri)]\n-            pub fn option() -> Option<F> {\n-                let mut func = NonNull::new(PTR.load(Ordering::Relaxed));\n-                if func.is_none() {\n-                    unsafe { Module::new($module).map(preload) };\n-                    func = NonNull::new(PTR.load(Ordering::Relaxed));\n-                }\n-                unsafe {\n-                    func.map(|f| mem::transmute(f))\n-                }\n-            }\n+/// This is rexported from sys::c. You should prefer to import\n+/// from there in case this changes again in the future.\n+pub mod WaitOnAddress {\n+    use super::*;\n+    use crate::mem;\n+    use crate::ptr;\n+    use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n+    use crate::sys::c;\n+\n+    static MODULE_NAME: &CStr = ansi_str!(\"api-ms-win-core-synch-l1-2-0\");\n+    static SYMBOL_NAME: &CStr = ansi_str!(\"WaitOnAddress\");\n+\n+    // WaitOnAddress function signature.\n+    type F = unsafe extern \"system\" fn(\n+        Address: c::LPVOID,\n+        CompareAddress: c::LPVOID,\n+        AddressSize: c::SIZE_T,\n+        dwMilliseconds: c::DWORD,\n+    );\n+\n+    // A place to store the loaded function atomically.\n+    static WAIT_ON_ADDRESS: AtomicPtr<c_void> = AtomicPtr::new(ptr::null_mut());\n+\n+    // We can skip trying to load again if we already tried.\n+    static LOAD_MODULE: AtomicBool = AtomicBool::new(true);\n+\n+    #[inline(always)]\n+    pub fn option() -> Option<F> {\n+        let f = WAIT_ON_ADDRESS.load(Ordering::Relaxed);\n+        if !f.is_null() { Some(unsafe { mem::transmute(f) }) } else { try_load() }\n+    }\n \n-            #[allow(unused)]\n-            pub(in crate::sys) fn preload(module: Module) {\n-                unsafe {\n-                    static SYMBOL_NAME: &CStr = ansi_str!(sym $symbol);\n-                    if let Some(f) = module.proc_address(SYMBOL_NAME) {\n-                        PTR.store(f.as_ptr(), Ordering::Relaxed);\n-                    }\n-                }\n+    #[cold]\n+    fn try_load() -> Option<F> {\n+        if LOAD_MODULE.load(Ordering::Acquire) {\n+            // load the module\n+            let mut wait_on_address = None;\n+            if let Some(func) = try_load_inner() {\n+                WAIT_ON_ADDRESS.store(func.as_ptr(), Ordering::Relaxed);\n+                wait_on_address = Some(unsafe { mem::transmute(func) });\n             }\n+            // Don't try to load the module again even if loading failed.\n+            LOAD_MODULE.store(false, Ordering::Release);\n+            wait_on_address\n+        } else {\n+            None\n         }\n-    )*)\n+    }\n+\n+    // In the future this could be a `try` block but until then I think it's a\n+    // little bit cleaner as a separate function.\n+    fn try_load_inner() -> Option<NonNull<c_void>> {\n+        unsafe { Module::new(MODULE_NAME)?.proc_address(SYMBOL_NAME) }\n+    }\n }"}, {"sha": "16863c9903ac7f76a5947fd2b386941c19575fcd", "filename": "library/std/src/sys/windows/thread_parker.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c985648593122a6fc8ec146a9ca755b73d0dc788/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c985648593122a6fc8ec146a9ca755b73d0dc788/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs?ref=c985648593122a6fc8ec146a9ca755b73d0dc788", "patch": "@@ -197,21 +197,9 @@ impl Parker {\n         // purpose, to make sure every unpark() has a release-acquire ordering\n         // with park().\n         if self.state.swap(NOTIFIED, Release) == PARKED {\n-            if let Some(wake_by_address_single) = c::WakeByAddressSingle::option() {\n-                unsafe {\n-                    wake_by_address_single(self.ptr());\n-                }\n-            } else {\n-                // If we run NtReleaseKeyedEvent before the waiting thread runs\n-                // NtWaitForKeyedEvent, this (shortly) blocks until we can wake it up.\n-                // If the waiting thread wakes up before we run NtReleaseKeyedEvent\n-                // (e.g. due to a timeout), this blocks until we do wake up a thread.\n-                // To prevent this thread from blocking indefinitely in that case,\n-                // park_impl() will, after seeing the state set to NOTIFIED after\n-                // waking up, call NtWaitForKeyedEvent again to unblock us.\n-                unsafe {\n-                    c::NtReleaseKeyedEvent(keyed_event_handle(), self.ptr(), 0, ptr::null_mut());\n-                }\n+            unsafe {\n+                // This calls either WakeByAddressSingle or unpark_keyed_event (see below).\n+                c::wake_by_address_single_or_unpark_keyed_event(self.ptr());\n             }\n         }\n     }\n@@ -221,6 +209,19 @@ impl Parker {\n     }\n }\n \n+// This function signature makes it compatible with c::WakeByAddressSingle\n+// so that it can be used as a fallback for that function.\n+pub unsafe extern \"C\" fn unpark_keyed_event(address: c::LPVOID) {\n+    // If we run NtReleaseKeyedEvent before the waiting thread runs\n+    // NtWaitForKeyedEvent, this (shortly) blocks until we can wake it up.\n+    // If the waiting thread wakes up before we run NtReleaseKeyedEvent\n+    // (e.g. due to a timeout), this blocks until we do wake up a thread.\n+    // To prevent this thread from blocking indefinitely in that case,\n+    // park_impl() will, after seeing the state set to NOTIFIED after\n+    // waking up, call NtWaitForKeyedEvent again to unblock us.\n+    c::NtReleaseKeyedEvent(keyed_event_handle(), address, 0, ptr::null_mut());\n+}\n+\n fn keyed_event_handle() -> c::HANDLE {\n     const INVALID: c::HANDLE = ptr::invalid_mut(!0);\n     static HANDLE: AtomicPtr<libc::c_void> = AtomicPtr::new(INVALID);"}]}