{"sha": "2e00b3177001dd8281038930f4a5d0f214420bc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMDBiMzE3NzAwMWRkODI4MTAzODkzMGY0YTVkMGYyMTQ0MjBiYzQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-07-11T19:46:06Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-07-11T19:46:06Z"}, "message": "We just have to replace error codes but code is good now", "tree": {"sha": "b30cf59fdf13f7b0845feb0dd30957e211a603e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b30cf59fdf13f7b0845feb0dd30957e211a603e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e00b3177001dd8281038930f4a5d0f214420bc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e00b3177001dd8281038930f4a5d0f214420bc4", "html_url": "https://github.com/rust-lang/rust/commit/2e00b3177001dd8281038930f4a5d0f214420bc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e00b3177001dd8281038930f4a5d0f214420bc4/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3fd0e12297d9e535f8e8e70eb942babfc11901d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3fd0e12297d9e535f8e8e70eb942babfc11901d", "html_url": "https://github.com/rust-lang/rust/commit/c3fd0e12297d9e535f8e8e70eb942babfc11901d"}], "stats": {"total": 299, "additions": 222, "deletions": 77}, "files": [{"sha": "06019b96f6f5f8156589eb1c552855156c46235c", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e00b3177001dd8281038930f4a5d0f214420bc4/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e00b3177001dd8281038930f4a5d0f214420bc4/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=2e00b3177001dd8281038930f4a5d0f214420bc4", "patch": "@@ -202,8 +202,8 @@ http://doc.rust-lang.org/reference.html#types\n }\n \n register_diagnostics! {\n-    E0157,\n-    E0153,\n+    E0153, // called no where\n+    E0157, // called from no where\n     E0253, // not directly importable\n     E0254, // import conflicts with imported crate in this module\n     E0257,"}, {"sha": "b314772c8cb1543fd0fae0f7ae76fb917cd3a9c4", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 220, "deletions": 75, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/2e00b3177001dd8281038930f4a5d0f214420bc4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e00b3177001dd8281038930f4a5d0f214420bc4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2e00b3177001dd8281038930f4a5d0f214420bc4", "patch": "@@ -109,10 +109,17 @@ mod record_exports;\n mod build_reduced_graph;\n mod resolve_imports;\n \n+macro_rules! span_err {\n+    ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n+        __diagnostic_used!($code);\n+        $session.span_err_with_code($span, &format!($($message)*), stringify!($code))\n+    })\n+}\n+\n macro_rules! resolve_err {\n-    ($this:expr, $($rest:tt)*) => {\n+    ($this:expr, $span:expr, $code:ident, $($rest:tt)*) => {\n         if $this.emit_errors {\n-            span_err!($this.session, $($rest)*);\n+            span_err!($this.session, $span, $code, $($rest)*);\n         }\n     }\n }\n@@ -1311,9 +1318,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               PathSearch,\n                                               true) {\n                 Failed(Some((span, msg))) => {\n-                    self.resolve_error(span,\n+                    /*self.resolve_error(span,\n                                        &format!(\"failed to resolve. {}\",\n-                                                msg));\n+                                                msg));*/\n+                    resolve_err!(self, span, E0253, \"failed to resolve. {}\", msg);\n                 },\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n@@ -1571,12 +1579,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                          .span_to_snippet((*imports)[index].span)\n                          .unwrap();\n             if sn.contains(\"::\") {\n-                self.resolve_error((*imports)[index].span,\n-                                   \"unresolved import\");\n+                /*self.resolve_error((*imports)[index].span,\n+                                   \"unresolved import\");*/\n+                resolve_err!(self, (*imports)[index].span, E0253,\n+                             \"{}\", \"unresolved import\");\n             } else {\n-                let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n+                /*let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                   sn);\n-                self.resolve_error((*imports)[index].span, &err[..]);\n+                self.resolve_error((*imports)[index].span, &err[..]);*/\n+                resolve_err!(self, (*imports)[index].span, E0253,\n+                             \"unresolved import (maybe you meant `{}::*`?)\", sn);\n             }\n         }\n \n@@ -1703,16 +1715,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // named function item. This is not allowed, so we\n                             // report an error.\n \n-                            self.resolve_error(span,\n+                            /*self.resolve_error(span,\n                                 \"can't capture dynamic environment in a fn item; \\\n-                                 use the || { ... } closure form instead\");\n+                                 use the || { ... } closure form instead\");*/\n+                            resolve_err!(self, span, E0253, \"{}\",\n+                                         \"can't capture dynamic environment in a fn item; \\\n+                                          use the || { ... } closure form instead\");\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n-                            self.resolve_error(span,\n+                            /*self.resolve_error(span,\n                                                \"attempt to use a non-constant \\\n-                                                value in a constant\");\n+                                                value in a constant\");*/\n+                            resolve_err!(self, span, E0253, \"{}\",\n+                                         \"attempt to use a non-constant \\\n+                                          value in a constant\");\n                             return None;\n                         }\n                     }\n@@ -1728,17 +1746,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // This was an attempt to use a type parameter outside\n                             // its scope.\n \n-                            self.resolve_error(span,\n+                            /*self.resolve_error(span,\n                                                \"can't use type parameters from \\\n                                                 outer function; try using a local \\\n-                                                type parameter instead\");\n+                                                type parameter instead\");*/\n+                            resolve_err!(self, span, E0253, \"{}\",\n+                                         \"can't use type parameters from \\\n+                                          outer function; try using a local \\\n+                                          type parameter instead\");\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n-                            self.resolve_error(span,\n+                            /*self.resolve_error(span,\n                                                \"cannot use an outer type \\\n-                                                parameter in this context\");\n+                                                parameter in this context\");*/\n+                            resolve_err!(self, span, E0253, \"{}\",\n+                                         \"cannot use an outer type \\\n+                                          parameter in this context\");\n                             return None;\n                         }\n                     }\n@@ -1936,12 +1961,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n                     if seen_bindings.contains(&name) {\n-                        self.resolve_error(type_parameter.span,\n+                        /*self.resolve_error(type_parameter.span,\n                                            &format!(\"the name `{}` is already \\\n                                                      used for a type \\\n                                                      parameter in this type \\\n                                                      parameter list\",\n-                                                    name))\n+                                                    name))*/\n+                        resolve_err!(self, type_parameter.span, E0253,\n+                                     \"the name `{}` is already \\\n+                                      used for a type \\\n+                                      parameter in this type \\\n+                                      parameter list\",\n+                                     name)\n                     }\n                     seen_bindings.insert(name);\n \n@@ -2028,9 +2059,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n             } else {\n-                self.resolve_error(trait_path.span,\n+                /*self.resolve_error(trait_path.span,\n                     &format!(\"`{}` is not a trait\",\n-                             path_names_to_string(trait_path, path_depth)));\n+                             path_names_to_string(trait_path, path_depth)));*/\n+                resolve_err!(self, trait_path.span, E0253,\n+                             \"`{}` is not a trait\",\n+                             path_names_to_string(trait_path, path_depth));\n \n                 // If it's a typedef, give a note\n                 if let DefTy(..) = path_res.base_def {\n@@ -2040,9 +2074,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Err(())\n             }\n         } else {\n-            let msg = format!(\"use of undeclared trait name `{}`\",\n+            /*let msg = format!(\"use of undeclared trait name `{}`\",\n                               path_names_to_string(trait_path, path_depth));\n-            self.resolve_error(trait_path.span, &msg);\n+            self.resolve_error(trait_path.span, &msg);*/\n+            resolve_err!(self, trait_path.span, E0253,\n+                         \"use of undeclared trait name `{}`\",\n+                         path_names_to_string(trait_path, path_depth));\n             Err(())\n         }\n     }\n@@ -2060,7 +2097,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if let Some(PathResolution { base_def: DefTyParam(..), .. }) = path_res {\n                         self.record_def(eq_pred.id, path_res.unwrap());\n                     } else {\n-                        self.resolve_error(eq_pred.path.span, \"undeclared associated type\");\n+                        //self.resolve_error(eq_pred.path.span, \"undeclared associated type\");\n+                        resolve_err!(self, eq_pred.span, E0253, \"{}\",\n+                                     \"undeclared associated type\");\n                     }\n                 }\n             }\n@@ -2185,10 +2224,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if !self.trait_item_map.contains_key(&(name, did)) {\n                 let path_str = path_names_to_string(&trait_ref.path, 0);\n-                self.resolve_error(span,\n+                /*self.resolve_error(span,\n                                     &format!(\"method `{}` is not a member of trait `{}`\",\n                                             name,\n-                                            path_str));\n+                                            path_str));*/\n+                resolve_err!(self, span, E0253, \"method `{}` is not a member of trait `{}`\",\n+                             name, path_str);\n             }\n         }\n     }\n@@ -2235,34 +2276,49 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n                   None => {\n-                    self.resolve_error(\n+                    /*self.resolve_error(\n                         p.span,\n                         &format!(\"variable `{}` from pattern #1 is \\\n                                   not bound in pattern #{}\",\n                                 key,\n-                                i + 1));\n+                                i + 1));*/\n+                    resolve_err!(self, p.span, E0253,\n+                                 \"variable `{}` from pattern #1 is \\\n+                                  not bound in pattern #{}\",\n+                                 key,\n+                                 i + 1);\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n-                        self.resolve_error(\n+                        /*self.resolve_error(\n                             binding_i.span,\n                             &format!(\"variable `{}` is bound with different \\\n                                       mode in pattern #{} than in pattern #1\",\n                                     key,\n-                                    i + 1));\n+                                    i + 1));*/\n+                        resolve_err!(self, binding_i.span, E0253,\n+                                     \"variable `{}` is bound with different \\\n+                                      mode in pattern #{} than in pattern #1\",\n+                                     key,\n+                                     i + 1);\n                     }\n                   }\n                 }\n             }\n \n             for (&key, &binding) in &map_i {\n                 if !map_0.contains_key(&key) {\n-                    self.resolve_error(\n+                    /*self.resolve_error(\n                         binding.span,\n                         &format!(\"variable `{}` from pattern {}{} is \\\n                                   not bound in pattern {}1\",\n                                 key,\n-                                \"#\", i + 1, \"#\"));\n+                                \"#\", i + 1, \"#\"));*/\n+                    resolve_err!(self, binding.span, E0253,\n+                                 \"variable `{}` from pattern {}{} is \\\n+                                  not bound in pattern {}1\",\n+                                 key,\n+                                 \"#\", i + 1, \"#\");\n                 }\n             }\n         }\n@@ -2382,7 +2438,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 kind, path_names_to_string(path, 0))\n                         };\n \n-                        self.resolve_error(ty.span, &msg[..]);\n+                        //self.resolve_error(ty.span, &msg[..]);\n+                        resolve_err!(self, ty.span, E0253,\n+                                     \"{}\", msg);\n                     }\n                 }\n             }\n@@ -2433,12 +2491,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             });\n                         }\n                         FoundStructOrEnumVariant(..) => {\n-                            self.resolve_error(\n+                            /*self.resolve_error(\n                                 pattern.span,\n                                 &format!(\"declaration of `{}` shadows an enum \\\n                                          variant or unit-like struct in \\\n                                          scope\",\n-                                        renamed));\n+                                        renamed));*/\n+                            resolve_err!(self, pattern.span, E0253,\n+                                         \"declaration of `{}` shadows an enum \\\n+                                         variant or unit-like struct in \\\n+                                         scope\",\n+                                         renamed);\n                         }\n                         FoundConst(def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -2456,9 +2519,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             });\n                         }\n                         FoundConst(..) => {\n-                            self.resolve_error(pattern.span,\n+                            /*self.resolve_error(pattern.span,\n                                                   \"only irrefutable patterns \\\n-                                                   allowed here\");\n+                                                   allowed here\");*/\n+                            resolve_err!(self, pattern.span, E0253,\n+                                         \"{}\",\n+                                         \"only irrefutable patterns \\\n+                                          allowed here\");\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `{}`\",\n@@ -2490,24 +2557,36 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     bindings_list.contains_key(&renamed) {\n                                 // Forbid duplicate bindings in the same\n                                 // parameter list.\n-                                self.resolve_error(pattern.span,\n+                                /*self.resolve_error(pattern.span,\n                                                    &format!(\"identifier `{}` \\\n                                                             is bound more \\\n                                                             than once in \\\n                                                             this parameter \\\n                                                             list\",\n                                                            token::get_ident(\n                                                                ident))\n-                                                   )\n+                                                   )*/\n+                                resolve_err!(self, pattern.span, E0253,\n+                                             \"identifier `{}` \\\n+                                              is bound more \\\n+                                              than once in \\\n+                                              this parameter \\\n+                                              list\",\n+                                             token::get_ident(ident));\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n                                 // same disjunction, which is an error.\n-                                self.resolve_error(pattern.span,\n+                                /*self.resolve_error(pattern.span,\n                                     &format!(\"identifier `{}` is bound \\\n                                              more than once in the same \\\n                                              pattern\",\n-                                            token::get_ident(ident)));\n+                                            token::get_ident(ident)));*/\n+                                resolve_err!(self, pattern.span, E0253,\n+                                             \"identifier `{}` is bound \\\n+                                              more than once in the same \\\n+                                              pattern\",\n+                                             token::get_ident(ident));\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -2538,22 +2617,30 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             DefStatic(..) => {\n-                                self.resolve_error(path.span,\n+                                /*self.resolve_error(path.span,\n                                                    \"static variables cannot be \\\n                                                     referenced in a pattern, \\\n-                                                    use a `const` instead\");\n+                                                    use a `const` instead\");*/\n+                                resolve_err!(self, path.span, E0253, \"{}\",\n+                                             \"static variables cannot be \\\n+                                              referenced in a pattern, \\\n+                                              use a `const` instead\");\n                             }\n                             _ => {\n                                 // If anything ends up here entirely resolved,\n                                 // it's an error. If anything ends up here\n                                 // partially resolved, that's OK, because it may\n                                 // be a `T::CONST` that typeck will resolve.\n                                 if path_res.depth == 0 {\n-                                    self.resolve_error(\n+                                    /*self.resolve_error(\n                                         path.span,\n                                         &format!(\"`{}` is not an enum variant, struct or const\",\n                                                  token::get_ident(\n-                                                     path.segments.last().unwrap().identifier)));\n+                                                     path.segments.last().unwrap().identifier)));*/\n+                                    resolve_err!(self, path.span, E0253,\n+                                                 \"`{}` is not an enum variant, struct or const\",\n+                                                 token::get_ident(\n+                                                     path.segments.last().unwrap().identifier));\n                                 } else {\n                                     let const_name = path.segments.last().unwrap()\n                                                          .identifier.name;\n@@ -2564,9 +2651,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             }\n                         }\n                     } else {\n-                        self.resolve_error(path.span,\n+                        /*self.resolve_error(path.span,\n                             &format!(\"unresolved enum variant, struct or const `{}`\",\n-                                token::get_ident(path.segments.last().unwrap().identifier)));\n+                                token::get_ident(path.segments.last().unwrap().identifier)));*/\n+                        resolve_err!(self, path.span, E0253,\n+                                     \"unresolved enum variant, struct or const `{}`\",\n+                                     token::get_ident(path.segments.last().unwrap().identifier));\n                     }\n                     visit::walk_path(self, path);\n                 }\n@@ -2598,16 +2688,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             _ => {\n-                                self.resolve_error(path.span,\n+                                /*self.resolve_error(path.span,\n                                     &format!(\"`{}` is not an associated const\",\n                                         token::get_ident(\n-                                            path.segments.last().unwrap().identifier)));\n+                                            path.segments.last().unwrap().identifier)));*/\n+                                resolve_err!(self, path.span, E0253,\n+                                             \"`{}` is not an associated const\",\n+                                             token::get_ident(\n+                                                 path.segments.last().unwrap().identifier));\n                             }\n                         }\n                     } else {\n-                        self.resolve_error(path.span,\n+                        /*self.resolve_error(path.span,\n                             &format!(\"unresolved associated const `{}`\",\n-                                token::get_ident(path.segments.last().unwrap().identifier)));\n+                                token::get_ident(path.segments.last().unwrap().identifier)));*/\n+                        resolve_err!(self, path.span, E0253,\n+                                     \"unresolved associated const `{}`\",\n+                                     token::get_ident(path.segments.last().unwrap().identifier));\n                     }\n                     visit::walk_pat(self, pattern);\n                 }\n@@ -2620,9 +2717,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {:?}\", result);\n-                            let msg = format!(\"`{}` does not name a structure\",\n+                            /*let msg = format!(\"`{}` does not name a structure\",\n                                               path_names_to_string(path, 0));\n-                            self.resolve_error(path.span, &msg[..]);\n+                            self.resolve_error(path.span, &msg[..]);*/\n+                            resolve_err!(self, path.span, E0253,\n+                                         \"`{}` does not name a structure\",\n+                                         path_names_to_string(path, 0));\n                         }\n                     }\n                     visit::walk_path(self, path);\n@@ -2668,10 +2768,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n                             DefStatic(..) => {\n-                                self.resolve_error(span,\n+                                /*self.resolve_error(span,\n                                                    \"static variables cannot be \\\n                                                     referenced in a pattern, \\\n-                                                    use a `const` instead\");\n+                                                    use a `const` instead\");*/\n+                                resolve_err!(self, span, E0253,\n+                                             \"{}\",\n+                                             \"static variables cannot be \\\n+                                              referenced in a pattern, \\\n+                                              use a `const` instead\");\n                                 return BareIdentifierPatternUnresolved;\n                             }\n                             _ => {\n@@ -2688,8 +2793,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) => {\n-                        self.resolve_error(span, &format!(\"failed to resolve: {}\",\n-                                                         msg));\n+                        /*self.resolve_error(span, &format!(\"failed to resolve: {}\",\n+                                                         msg));*/\n+                        resolve_err!(self, span, E0253,\n+                                     \"failed to resolve: {}\",\n+                                     msg);\n                     }\n                     None => ()\n                 }\n@@ -2918,8 +3026,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                 msg));\n+                /*self.resolve_error(span, &format!(\"failed to resolve. {}\",\n+                                                 msg));*/\n+                resolve_err!(self, span, E0253,\n+                             \"failed to resolve: {}\",\n+                             msg);\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -2978,8 +3089,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                 msg));\n+                /*self.resolve_error(span, &format!(\"failed to resolve. {}\",\n+                                                 msg));*/\n+                resolve_err!(self, span, E0253,\n+                             \"failed to resolve: {}\",\n+                             msg);\n                 return None;\n             }\n \n@@ -3075,7 +3189,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                          failed to resolve {}\", name);\n \n                 if let Some((span, msg)) = err {\n-                    self.resolve_error(span, &format!(\"failed to resolve. {}\", msg))\n+                    //self.resolve_error(span, &format!(\"failed to resolve. {}\", msg))\n+                    resolve_err!(self, span, E0253,\n+                                 \"failed to resolve: {}\",\n+                                 msg)\n                 }\n \n                 return None;\n@@ -3283,11 +3400,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Check if struct variant\n                     if let DefVariant(_, _, true) = path_res.base_def {\n                         let path_name = path_names_to_string(path, 0);\n-                        self.resolve_error(expr.span,\n+                        /*self.resolve_error(expr.span,\n                                 &format!(\"`{}` is a struct variant name, but \\\n                                           this expression \\\n                                           uses it like a function name\",\n-                                         path_name));\n+                                         path_name));*/\n+                        resolve_err!(self, expr.span, E0253,\n+                                     \"`{}` is a struct variant name, but \\\n+                                      this expression \\\n+                                      uses it like a function name\",\n+                                     path_name);\n \n                         let msg = format!(\"did you mean to write: \\\n                                            `{} {{ /* fields */ }}`?\",\n@@ -3324,11 +3446,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     match type_res.map(|r| r.base_def) {\n                         Some(DefTy(struct_id, _))\n                             if self.structs.contains_key(&struct_id) => {\n-                                self.resolve_error(expr.span,\n+                                /*self.resolve_error(expr.span,\n                                     &format!(\"`{}` is a structure name, but \\\n                                                 this expression \\\n                                                 uses it like a function name\",\n-                                                path_name));\n+                                                path_name));*/\n+                                resolve_err!(self, expr.span, E0253,\n+                                             \"{}` is a structure name, but \\\n+                                              this expression \\\n+                                              uses it like a function name\",\n+                                              path_name);\n \n                                 let msg = format!(\"did you mean to write: \\\n                                                      `{} {{ /* fields */ }}`?\",\n@@ -3355,11 +3482,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                             if method_scope &&\n                                &token::get_name(special_names::self_)[..] == path_name {\n-                                    self.resolve_error(\n+                                    /*self.resolve_error(\n                                         expr.span,\n                                         \"`self` is not available \\\n                                          in a static method. Maybe a \\\n-                                         `self` argument is missing?\");\n+                                         `self` argument is missing?\");*/\n+                                    resolve_err!(self, expr.span, E0253,\n+                                                 \"{}\",\n+                                                 \"`self` is not available \\\n+                                                  in a static method. Maybe a \\\n+                                                  `self` argument is missing?\");\n                             } else {\n                                 let last_name = path.segments.last().unwrap().identifier.name;\n                                 let mut msg = match self.find_fallback_in_self_type(last_name) {\n@@ -3383,10 +3515,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     msg = format!(\". Did you mean {}?\", msg)\n                                 }\n \n-                                self.resolve_error(\n+                                /*self.resolve_error(\n                                     expr.span,\n                                     &format!(\"unresolved name `{}`{}\",\n-                                             path_name, msg));\n+                                             path_name, msg));*/\n+                                resolve_err!(self, expr.span, E0253,\n+                                             \"unresolved name `{}`{}\",\n+                                             path_name,\n+                                             msg);\n                             }\n                         }\n                     }\n@@ -3403,9 +3539,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(definition) => self.record_def(expr.id, definition),\n                     None => {\n                         debug!(\"(resolving expression) didn't find struct def\",);\n-                        let msg = format!(\"`{}` does not name a structure\",\n+                        /*let msg = format!(\"`{}` does not name a structure\",\n                                           path_names_to_string(path, 0));\n-                        self.resolve_error(path.span, &msg[..]);\n+                        self.resolve_error(path.span, &msg[..]);*/\n+                        resolve_err!(self, path.span, E0253,\n+                                     \"`{}` does not name a structure\",\n+                                     path_names_to_string(path, 0));\n                     }\n                 }\n \n@@ -3430,10 +3569,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let renamed = mtwt::resolve(label);\n                 match self.search_label(renamed) {\n                     None => {\n-                        self.resolve_error(\n+                        /*self.resolve_error(\n                             expr.span,\n                             &format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label)))\n+                                    token::get_ident(label)))*/\n+                        resolve_err!(self, expr.span, E0253,\n+                                     \"use of undeclared label `{}`\",\n+                                     token::get_ident(label))\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -3579,10 +3721,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match pat_binding_mode {\n             BindByValue(_) => {}\n             BindByRef(..) => {\n-                self.resolve_error(pat.span,\n+                /*self.resolve_error(pat.span,\n                                    &format!(\"cannot use `ref` binding mode \\\n                                             with {}\",\n-                                           descr));\n+                                           descr));*/\n+                resolve_err!(self, pat.span, E0253,\n+                             \"cannot use `ref` binding mode with {}\",\n+                             descr);\n             }\n         }\n     }"}]}